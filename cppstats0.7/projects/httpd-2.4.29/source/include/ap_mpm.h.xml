<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C" filename="projects/httpd-2.4.29/include/ap_mpm.h"><comment type="block">/* Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */</comment>

<comment type="block">/**
 * @file  ap_mpm.h
 * @brief Apache Multi-Processing Module library
 *
 * @defgroup APACHE_CORE_MPM Multi-Processing Module library
 * @ingroup  APACHE_CORE
 * @{
 */</comment>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>AP_MPM_H</name></cpp:ifndef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AP_MPM_H</name></cpp:macro></cpp:define>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"apr_thread_proc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"httpd.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"scoreboard.h"</cpp:file></cpp:include>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__cplusplus</name></cpp:ifdef>
<extern>extern "C" <block>{
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
    The MPM, "multi-processing model" provides an abstraction of the
    interface with the OS for distributing incoming connections to
    threads/process for processing.  http_main invokes the MPM, and
    the MPM runs until a shutdown/restart has been indicated.
    The MPM calls out to the apache core via the ap_process_connection
    function when a connection arrives.

    The MPM may or may not be multithreaded.  In the event that it is
    multithreaded, at any instant it guarantees a 1:1 mapping of threads
    ap_process_connection invocations.

    Note: In the future it will be possible for ap_process_connection
    to return to the MPM prior to finishing the entire connection; and
    the MPM will proceed with asynchronous handling for the connection;
    in the future the MPM may call ap_process_connection again -- but
    does not guarantee it will occur on the same thread as the first call.

    The MPM further guarantees that no asynchronous behaviour such as
    longjmps and signals will interfere with the user code that is
    invoked through ap_process_connection.  The MPM may reserve some
    signals for its use (i.e. SIGUSR1), but guarantees that these signals
    are ignored when executing outside the MPM code itself.  (This
    allows broken user code that does not handle EINTR to function
    properly.)

    The suggested server restart and stop behaviour will be "graceful".
    However the MPM may choose to terminate processes when the user
    requests a non-graceful restart/stop.  When this occurs, the MPM kills
    all threads with extreme prejudice, and destroys the pchild pool.
    User cleanups registered in the pchild apr_pool_t will be invoked at
    this point.  (This can pose some complications, the user cleanups
    are asynchronous behaviour not unlike longjmp/signal... but if the
    admin is asking for a non-graceful shutdown, how much effort should
    we put into doing it in a nice way?)

    unix/posix notes:
    - The MPM does not set a SIGALRM handler, user code may use SIGALRM.
        But the preferred method of handling timeouts is to use the
        timeouts provided by the BUFF abstraction.
    - The proper setting for SIGPIPE is SIG_IGN, if user code changes it
        for any of their own processing, it must be restored to SIG_IGN
        prior to executing or returning to any apache code.
    TODO: add SIGPIPE debugging check somewhere to make sure it's SIG_IGN
*/</comment>

<comment type="block">/**
 * Pass control to the MPM for steady-state processing.  It is responsible
 * for controlling the parent and child processes.  It will run until a
 * restart/shutdown is indicated.
 * @param pconf the configuration pool, reset before the config file is read
 * @param plog the log pool, reset after the config file is read
 * @param server_conf the global server config.
 * @return DONE for shutdown OK otherwise.
 */</comment>
<macro><name>AP_DECLARE_HOOK</name><argument_list>(<argument>int</argument>, <argument>mpm</argument>, <argument>(apr_pool_t *pconf, apr_pool_t *plog, server_rec *server_conf)</argument>)</argument_list></macro>

<comment type="block">/**
 * Spawn a process with privileges that another module has requested
 * @param r The request_rec of the current request
 * @param newproc The resulting process handle.
 * @param progname The program to run
 * @param args the arguments to pass to the new program.  The first
 *                   one should be the program name.
 * @param env The new environment apr_table_t for the new process.  This
 *            should be a list of NULL-terminated strings.
 * @param attr the procattr we should use to determine how to create the new
 *         process
 * @param p The pool to use.
 */</comment>
<macro><name>AP_DECLARE</name><argument_list>(<argument>apr_status_t</argument>)</argument_list></macro> <expr_stmt><expr><call><name>ap_os_create_privileged_process</name><argument_list>(
    <argument><expr>const <name>request_rec</name> *<name>r</name></expr></argument>,
    <argument><expr><name>apr_proc_t</name> *<name>newproc</name></expr></argument>,
    <argument><expr>const <name>char</name> *<name>progname</name></expr></argument>,
    <argument><expr>const <name>char</name> * const *<name>args</name></expr></argument>,
    <argument><expr>const <name>char</name> * const *<name>env</name></expr></argument>,
    <argument><expr><name>apr_procattr_t</name> *<name>attr</name></expr></argument>,
    <argument><expr><name>apr_pool_t</name> *<name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/* Subtypes/Values for AP_MPMQ_IS_THREADED and AP_MPMQ_IS_FORKED        */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AP_MPMQ_NOT_SUPPORTED</name></cpp:macro>      <cpp:value>0</cpp:value></cpp:define>  <comment type="block">/* This value specifies that an */</comment>
                                      <comment type="block">/* MPM is not capable of        */</comment>
                                      <comment type="block">/* threading or forking.        */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AP_MPMQ_STATIC</name></cpp:macro>             <cpp:value>1</cpp:value></cpp:define>  <comment type="block">/* This value specifies that    */</comment>
                                      <comment type="block">/* an MPM is using a static     */</comment>
                                      <comment type="block">/* number of threads or daemons */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AP_MPMQ_DYNAMIC</name></cpp:macro>            <cpp:value>2</cpp:value></cpp:define>  <comment type="block">/* This value specifies that    */</comment>
                                      <comment type="block">/* an MPM is using a dynamic    */</comment>
                                      <comment type="block">/* number of threads or daemons */</comment>

<comment type="block">/* Values returned for AP_MPMQ_MPM_STATE */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AP_MPMQ_STARTING</name></cpp:macro>              <cpp:value>0</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AP_MPMQ_RUNNING</name></cpp:macro>               <cpp:value>1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AP_MPMQ_STOPPING</name></cpp:macro>              <cpp:value>2</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AP_MPMQ_MAX_DAEMON_USED</name></cpp:macro>       <cpp:value>1</cpp:value></cpp:define>  <comment type="block">/* Max # of daemons used so far */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AP_MPMQ_IS_THREADED</name></cpp:macro>           <cpp:value>2</cpp:value></cpp:define>  <comment type="block">/* MPM can do threading         */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AP_MPMQ_IS_FORKED</name></cpp:macro>             <cpp:value>3</cpp:value></cpp:define>  <comment type="block">/* MPM can do forking           */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AP_MPMQ_HARD_LIMIT_DAEMONS</name></cpp:macro>    <cpp:value>4</cpp:value></cpp:define>  <comment type="block">/* The compiled max # daemons   */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AP_MPMQ_HARD_LIMIT_THREADS</name></cpp:macro>    <cpp:value>5</cpp:value></cpp:define>  <comment type="block">/* The compiled max # threads   */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AP_MPMQ_MAX_THREADS</name></cpp:macro>           <cpp:value>6</cpp:value></cpp:define>  <comment type="block">/* # of threads/child by config */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AP_MPMQ_MIN_SPARE_DAEMONS</name></cpp:macro>     <cpp:value>7</cpp:value></cpp:define>  <comment type="block">/* Min # of spare daemons       */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AP_MPMQ_MIN_SPARE_THREADS</name></cpp:macro>     <cpp:value>8</cpp:value></cpp:define>  <comment type="block">/* Min # of spare threads       */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AP_MPMQ_MAX_SPARE_DAEMONS</name></cpp:macro>     <cpp:value>9</cpp:value></cpp:define>  <comment type="block">/* Max # of spare daemons       */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AP_MPMQ_MAX_SPARE_THREADS</name></cpp:macro>    <cpp:value>10</cpp:value></cpp:define>  <comment type="block">/* Max # of spare threads       */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AP_MPMQ_MAX_REQUESTS_DAEMON</name></cpp:macro>  <cpp:value>11</cpp:value></cpp:define>  <comment type="block">/* Max # of requests per daemon */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AP_MPMQ_MAX_DAEMONS</name></cpp:macro>          <cpp:value>12</cpp:value></cpp:define>  <comment type="block">/* Max # of daemons by config   */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AP_MPMQ_MPM_STATE</name></cpp:macro>            <cpp:value>13</cpp:value></cpp:define>  <comment type="block">/* starting, running, stopping  */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AP_MPMQ_IS_ASYNC</name></cpp:macro>             <cpp:value>14</cpp:value></cpp:define>  <comment type="block">/* MPM can process async connections  */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AP_MPMQ_GENERATION</name></cpp:macro>           <cpp:value>15</cpp:value></cpp:define>  <comment type="block">/* MPM generation */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AP_MPMQ_HAS_SERF</name></cpp:macro>             <cpp:value>16</cpp:value></cpp:define>  <comment type="block">/* MPM can drive serf internally  */</comment>

<comment type="block">/**
 * Query a property of the current MPM.
 * @param query_code One of APM_MPMQ_*
 * @param result A location to place the result of the query
 * @return APR_EGENERAL if an mpm-query hook has not been registered;
 * APR_SUCCESS or APR_ENOTIMPL otherwise
 * @remark The MPM doesn't register the implementing hook until the
 * register_hooks hook is called, so modules cannot use ap_mpm_query()
 * until after that point.
 * @fn int ap_mpm_query(int query_code, int *result)
 */</comment>
<macro><name>AP_DECLARE</name><argument_list>(<argument>apr_status_t</argument>)</argument_list></macro> <macro><name>ap_mpm_query</name><argument_list>(<argument>int query_code</argument>, <argument>int *result</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>


<typedef>typedef <function_decl><type><name>void</name></type> (<name>ap_mpm_callback_fn_t</name>)<parameter_list>(<param><decl><type><name>void</name> *</type><name>baton</name></decl></param>)</parameter_list>;</function_decl></typedef>

<comment type="block">/* only added support in the Event MPM....  check for APR_ENOTIMPL */</comment>
<macro><name>AP_DECLARE</name><argument_list>(<argument>apr_status_t</argument>)</argument_list></macro> <macro><name>ap_mpm_register_timed_callback</name><argument_list>(<argument>apr_time_t t</argument>,
                                                       <argument>ap_mpm_callback_fn_t *cbfn</argument>,
                                                       <argument>void *baton</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

<typedef>typedef <type><enum>enum <name>mpm_child_status</name> <block>{
    <decl><name>MPM_CHILD_STARTED</name></decl>,
    <decl><name>MPM_CHILD_EXITED</name></decl>,
    <decl><name>MPM_CHILD_LOST_SLOT</name></decl>
}</block></enum></type> <name>mpm_child_status</name>;</typedef>

<comment type="block">/**
 * Allow a module to remain aware of MPM child process state changes,
 * along with the generation and scoreboard slot of the process changing
 * state.
 *
 * With some MPMs (event and worker), an active MPM child process may lose
 * its scoreboard slot if the child process is exiting and the scoreboard
 * slot is needed by other processes.  When this occurs, the hook will be
 * called with the MPM_CHILD_LOST_SLOT state.
 *
 * @param s The main server_rec.
 * @param pid The id of the MPM child process.
 * @param gen The server generation of that child process.
 * @param slot The scoreboard slot number, or -1.  It will be -1 when an
 * MPM child process exits, and that child had previously lost its
 * scoreboard slot.
 * @param state One of the mpm_child_status values.  Modules should ignore
 * unrecognized values.
 */</comment>
<macro><name>AP_DECLARE_HOOK</name><argument_list>(<argument>void</argument>,<argument>child_status</argument>,<argument>(server_rec *s, pid_t pid, ap_generation_t gen,
                                   int slot, mpm_child_status state)</argument>)</argument_list></macro>

<comment type="block">/**
 * Allow a module to be notified when the last child process of a generation
 * exits.
 *
 * @param s The main server_rec.
 * @param gen The server generation which is now completely finished.
 */</comment>
<macro><name>AP_DECLARE_HOOK</name><argument_list>(<argument>void</argument>,<argument>end_generation</argument>,<argument>(server_rec *s, ap_generation_t gen)</argument>)</argument_list></macro>

<comment type="block">/* Defining GPROF when compiling uses the moncontrol() function to
 * disable gprof profiling in the parent, and enable it only for
 * request processing in children (or in one_process mode).  It's
 * absolutely required to get useful gprof results under linux
 * because the profile itimers and such are disabled across a
 * fork().  It's probably useful elsewhere as well.
 */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>GPROF</name></cpp:ifdef>
<function_decl><type><specifier>extern</specifier> <name>void</name></type> <name>moncontrol</name><parameter_list>(<param><decl><type><name>int</name></type></decl></param>)</parameter_list>;</function_decl>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AP_MONCONTROL</name><parameter_list>(<param><type><name>x</name></type></param>)</parameter_list></cpp:macro> <cpp:value>moncontrol(x)</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AP_MONCONTROL</name><parameter_list>(<param><type><name>x</name></type></param>)</parameter_list></cpp:macro></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>AP_ENABLE_EXCEPTION_HOOK</name></cpp:ifdef>
<typedef>typedef <type><struct>struct <name>ap_exception_info_t</name> <block>{
    <decl_stmt><decl><type><name>int</name></type> <name>sig</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>pid_t</name></type> <name>pid</name></decl>;</decl_stmt>
}</block></struct></type> <name>ap_exception_info_t</name>;</typedef>

<macro><name>AP_DECLARE_HOOK</name><argument_list>(<argument>int</argument>,<argument>fatal_exception</argument>,<argument>(ap_exception_info_t *ei)</argument>)</argument_list></macro>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/*AP_ENABLE_EXCEPTION_HOOK*/</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__cplusplus</name></cpp:ifdef>
}</block></extern>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<comment type="block">/** @} */</comment>
</unit>
