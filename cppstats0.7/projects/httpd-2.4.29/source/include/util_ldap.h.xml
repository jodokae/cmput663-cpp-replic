<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C" filename="projects/httpd-2.4.29/include/util_ldap.h"><comment type="block">/* Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */</comment>

<comment type="block">/**
 * @file util_ldap.h
 * @brief Apache LDAP library
 */</comment>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>UTIL_LDAP_H</name></cpp:ifndef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>UTIL_LDAP_H</name></cpp:macro></cpp:define>

<comment type="block">/* APR header files */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"apr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"apr_thread_mutex.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"apr_thread_rwlock.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"apr_tables.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"apr_time.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"apr_version.h"</cpp:file></cpp:include>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>APR_MAJOR_VERSION</name> &lt; 2</expr></cpp:if>
<comment type="block">/* The LDAP API is currently only present in APR 1.x */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"apr_ldap.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"apr_ldap_rebind.h"</cpp:file></cpp:include>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>APR_HAS_LDAP</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>APR_HAS_SHARED_MEMORY</name></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"apr_rmm.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"apr_shm.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* this whole thing disappears if LDAP is not enabled */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>APR_HAS_LDAP</name></expr></cpp:if>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>LDAP_UNAVAILABLE</name></expr></argument>)</argument_list></call> || <name>APR_HAS_MICROSOFT_LDAPSDK</name></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AP_LDAP_IS_SERVER_DOWN</name><parameter_list>(<param><type><name>s</name></type></param>)</parameter_list></cpp:macro>                <cpp:value>((s) == LDAP_SERVER_DOWN \
                ||(s) == LDAP_UNAVAILABLE)</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AP_LDAP_IS_SERVER_DOWN</name><parameter_list>(<param><type><name>s</name></type></param>)</parameter_list></cpp:macro>                <cpp:value>((s) == LDAP_SERVER_DOWN)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* Apache header files */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ap_config.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"httpd.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"http_config.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"http_core.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"http_log.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"http_protocol.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"http_request.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"apr_optional.h"</cpp:file></cpp:include>

<comment type="block">/* Create a set of LDAP_DECLARE macros with appropriate export
 * and import tags for the platform
 */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>WIN32</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LDAP_DECLARE</name><parameter_list>(<param><type><name>type</name></type></param>)</parameter_list></cpp:macro>            <cpp:value>type</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LDAP_DECLARE_NONSTD</name><parameter_list>(<param><type><name>type</name></type></param>)</parameter_list></cpp:macro>     <cpp:value>type</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LDAP_DECLARE_DATA</name></cpp:macro></cpp:define>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>LDAP_DECLARE_STATIC</name></expr></argument>)</argument_list></call></expr></cpp:elif>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LDAP_DECLARE</name><parameter_list>(<param><type><name>type</name></type></param>)</parameter_list></cpp:macro>            <cpp:value>type __stdcall</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LDAP_DECLARE_NONSTD</name><parameter_list>(<param><type><name>type</name></type></param>)</parameter_list></cpp:macro>     <cpp:value>type</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LDAP_DECLARE_DATA</name></cpp:macro></cpp:define>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>LDAP_DECLARE_EXPORT</name></expr></argument>)</argument_list></call></expr></cpp:elif>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LDAP_DECLARE</name><parameter_list>(<param><type><name>type</name></type></param>)</parameter_list></cpp:macro>            <cpp:value>__declspec(dllexport) type __stdcall</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LDAP_DECLARE_NONSTD</name><parameter_list>(<param><type><name>type</name></type></param>)</parameter_list></cpp:macro>     <cpp:value>__declspec(dllexport) type</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LDAP_DECLARE_DATA</name></cpp:macro>             <cpp:value>__declspec(dllexport)</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LDAP_DECLARE</name><parameter_list>(<param><type><name>type</name></type></param>)</parameter_list></cpp:macro>            <cpp:value>__declspec(dllimport) type __stdcall</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LDAP_DECLARE_NONSTD</name><parameter_list>(<param><type><name>type</name></type></param>)</parameter_list></cpp:macro>     <cpp:value>__declspec(dllimport) type</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LDAP_DECLARE_DATA</name></cpp:macro>             <cpp:value>__declspec(dllimport)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>APR_HAS_MICROSOFT_LDAPSDK</name></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>timeval</name></cpp:macro> <cpp:value>l_timeval</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__cplusplus</name></cpp:ifdef>
<extern>extern "C" <block>{
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
 * LDAP Connections
 */</comment>

<comment type="block">/* Values that the deref member can have */</comment>
<typedef>typedef <type><enum>enum <block>{
    <decl><name>never</name><init>=<expr><name>LDAP_DEREF_NEVER</name></expr></init></decl>,
    <decl><name>searching</name><init>=<expr><name>LDAP_DEREF_SEARCHING</name></expr></init></decl>,
    <decl><name>finding</name><init>=<expr><name>LDAP_DEREF_FINDING</name></expr></init></decl>,
    <decl><name>always</name><init>=<expr><name>LDAP_DEREF_ALWAYS</name></expr></init></decl>
}</block></enum></type> <name>deref_options</name>;</typedef>

<comment type="block">/* Structure representing an LDAP connection */</comment>
<typedef>typedef <type><struct>struct <name>util_ldap_connection_t</name> <block>{
    <decl_stmt><decl><type><name>LDAP</name> *</type><name>ldap</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl>;</decl_stmt>                   <comment type="block">/* Pool from which this connection is created */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>APR_HAS_THREADS</name></expr></cpp:if>
    <decl_stmt><decl><type><name>apr_thread_mutex_t</name> *</type><name>lock</name></decl>;</decl_stmt>           <comment type="block">/* Lock to indicate this connection is in use */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>host</name></decl>;</decl_stmt>                   <comment type="block">/* Name of the LDAP server (or space separated list) */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>port</name></decl>;</decl_stmt>                           <comment type="block">/* Port of the LDAP server */</comment>
    <decl_stmt><decl><type><name>deref_options</name></type> <name>deref</name></decl>;</decl_stmt>                <comment type="block">/* how to handle alias dereferening */</comment>

    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>binddn</name></decl>;</decl_stmt>                 <comment type="block">/* DN to bind to server (can be NULL) */</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>bindpw</name></decl>;</decl_stmt>                 <comment type="block">/* Password to bind to server (can be NULL) */</comment>

    <decl_stmt><decl><type><name>int</name></type> <name>bound</name></decl>;</decl_stmt>                          <comment type="block">/* Flag to indicate whether this connection is bound yet */</comment>

    <decl_stmt><decl><type><name>int</name></type> <name>secure</name></decl>;</decl_stmt>                         <comment type="block">/* SSL/TLS mode of the connection */</comment>
    <decl_stmt><decl><type><name>apr_array_header_t</name> *</type><name>client_certs</name></decl>;</decl_stmt>   <comment type="block">/* Client certificates on this connection */</comment>

    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>reason</name></decl>;</decl_stmt>                 <comment type="block">/* Reason for an error failure */</comment>

    <decl_stmt><decl><type>struct <name>util_ldap_connection_t</name> *</type><name>next</name></decl>;</decl_stmt>
    <decl_stmt><decl><type>struct <name>util_ldap_state_t</name> *</type><name>st</name></decl>;</decl_stmt>        <comment type="block">/* The LDAP vhost config this connection belongs to */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>keep</name></decl>;</decl_stmt>                            <comment type="block">/* Will this connection be kept when it's unlocked */</comment>

    <decl_stmt><decl><type><name>int</name></type> <name>ChaseReferrals</name></decl>;</decl_stmt>                 <comment type="block">/* [on|off] (default = AP_LDAP_CHASEREFERRALS_ON)*/</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>ReferralHopLimit</name></decl>;</decl_stmt>               <comment type="block">/* # of referral hops to follow (default = AP_LDAP_DEFAULT_HOPLIMIT) */</comment>
    <decl_stmt><decl><type><name>apr_time_t</name></type> <name>freed</name></decl>;</decl_stmt>                   <comment type="block">/* the time this conn was placed back in the pool */</comment>
    <decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>rebind_pool</name></decl>;</decl_stmt>            <comment type="block">/* frequently cleared pool for rebind data */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>must_rebind</name></decl>;</decl_stmt>                    <comment type="block">/* The connection was last bound with other then binddn/bindpw */</comment>
    <decl_stmt><decl><type><name>request_rec</name> *</type><name>r</name></decl>;</decl_stmt>                     <comment type="block">/* request_rec used to find this util_ldap_connection_t */</comment>
    <decl_stmt><decl><type><name>apr_time_t</name></type> <name>last_backend_conn</name></decl>;</decl_stmt>       <comment type="block">/* the approximate time of the last backend LDAP requst */</comment>
}</block></struct></type> <name>util_ldap_connection_t</name>;</typedef>

<typedef>typedef <type><struct>struct <name>util_ldap_config_t</name> <block>{
    <decl_stmt><decl><type><name>int</name></type> <name>ChaseReferrals</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>ReferralHopLimit</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_array_header_t</name> *</type><name>client_certs</name></decl>;</decl_stmt>  <comment type="block">/* Client certificates */</comment>
}</block></struct></type> <name>util_ldap_config_t</name>;</typedef>

<comment type="block">/* LDAP cache state information */</comment>
<typedef>typedef <type><struct>struct <name>util_ldap_state_t</name> <block>{
    <decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl>;</decl_stmt>           <comment type="block">/* pool from which this state is allocated */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>APR_HAS_THREADS</name></expr></cpp:if>
    <decl_stmt><decl><type><name>apr_thread_mutex_t</name> *</type><name>mutex</name></decl>;</decl_stmt>          <comment type="block">/* mutex lock for the connection list */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <decl_stmt><decl><type><name>apr_global_mutex_t</name> *</type><name>util_ldap_cache_lock</name></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>apr_size_t</name></type> <name>cache_bytes</name></decl>;</decl_stmt>     <comment type="block">/* Size (in bytes) of shared memory cache */</comment>
    <decl_stmt><decl><type><name>char</name> *</type><name>cache_file</name></decl>;</decl_stmt>           <comment type="block">/* filename for shm */</comment>
    <decl_stmt><decl><type><name>long</name></type> <name>search_cache_ttl</name></decl>;</decl_stmt>      <comment type="block">/* TTL for search cache */</comment>
    <decl_stmt><decl><type><name>long</name></type> <name>search_cache_size</name></decl>;</decl_stmt>     <comment type="block">/* Size (in entries) of search cache */</comment>
    <decl_stmt><decl><type><name>long</name></type> <name>compare_cache_ttl</name></decl>;</decl_stmt>     <comment type="block">/* TTL for compare cache */</comment>
    <decl_stmt><decl><type><name>long</name></type> <name>compare_cache_size</name></decl>;</decl_stmt>    <comment type="block">/* Size (in entries) of compare cache */</comment>

    <decl_stmt><decl><type>struct <name>util_ldap_connection_t</name> *</type><name>connections</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_array_header_t</name> *</type><name>global_certs</name></decl>;</decl_stmt>  <comment type="block">/* Global CA certificates */</comment>
    <decl_stmt><decl><type><name>int</name></type>   <name>ssl_supported</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>   <name>secure</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>   <name>secure_set</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>   <name>verify_svr_cert</name></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>APR_HAS_SHARED_MEMORY</name></expr></cpp:if>
    <decl_stmt><decl><type><name>apr_shm_t</name> *</type><name>cache_shm</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_rmm_t</name> *</type><name>cache_rmm</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/* cache ald */</comment>
    <decl_stmt><decl><type><name>void</name> *</type><name>util_ldap_cache</name></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>long</name></type>  <name>connectionTimeout</name></decl>;</decl_stmt>
    <decl_stmt><decl><type>struct <name>timeval</name> *</type><name>opTimeout</name></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>int</name></type> <name>debug_level</name></decl>;</decl_stmt>                    <comment type="block">/* SDK debug level */</comment>
    <decl_stmt><decl><type><name>apr_interval_time_t</name></type> <name>connection_pool_ttl</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>retries</name></decl>;</decl_stmt>                        <comment type="block">/* number of retries for failed bind/search/compare */</comment>
    <decl_stmt><decl><type><name>apr_interval_time_t</name></type> <name>retry_delay</name></decl>;</decl_stmt>    <comment type="block">/* delay between retries of failed bind/search/compare */</comment>
}</block></struct></type> <name>util_ldap_state_t</name>;</typedef>

<comment type="block">/* Used to store arrays of attribute labels/values. */</comment>
<struct>struct <name>mod_auth_ldap_groupattr_entry_t</name> <block>{
    <decl_stmt><decl><type><name>char</name> *</type><name>name</name></decl>;</decl_stmt>
}</block>;</struct>

<comment type="block">/**
 * Open a connection to an LDAP server
 * @param ldc A structure containing the expanded details of the server
 *            to connect to. The handle to the LDAP connection is returned
 *            as ldc-&gt;ldap.
 * @tip This function connects to the LDAP server and binds. It does not
 *      connect if already connected (ldc-&gt;ldap != NULL). Does not bind
 *      if already bound.
 * @return If successful LDAP_SUCCESS is returned.
 * @fn int util_ldap_connection_open(request_rec *r,
 *                                        util_ldap_connection_t *ldc)
 */</comment>
<expr_stmt><expr><call><name>APR_DECLARE_OPTIONAL_FN</name><argument_list>(<argument><expr><name>int</name></expr></argument>,<argument><expr><name>uldap_connection_open</name></expr></argument>,<argument><expr>(<name>request_rec</name> *<name>r</name>,
                                            <name>util_ldap_connection_t</name> *<name>ldc</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/**
 * Close a connection to an LDAP server
 * @param ldc A structure containing the expanded details of the server
 *            that was connected.
 * @tip This function unbinds from the LDAP server, and clears ldc-&gt;ldap.
 *      It is possible to rebind to this server again using the same ldc
 *      structure, using apr_ldap_open_connection().
 * @fn util_ldap_close_connection(util_ldap_connection_t *ldc)
 */</comment>
<expr_stmt><expr><call><name>APR_DECLARE_OPTIONAL_FN</name><argument_list>(<argument><expr><name>void</name></expr></argument>,<argument><expr><name>uldap_connection_close</name></expr></argument>,<argument><expr>(<name>util_ldap_connection_t</name> *<name>ldc</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/**
 * Unbind a connection to an LDAP server
 * @param ldc A structure containing the expanded details of the server
 *            that was connected.
 * @tip This function unbinds the LDAP connection, and disconnects from
 *      the server. It is used during error conditions, to bring the LDAP
 *      connection back to a known state.
 * @fn apr_status_t util_ldap_connection_unbind(util_ldap_connection_t *ldc)
 */</comment>
<expr_stmt><expr><call><name>APR_DECLARE_OPTIONAL_FN</name><argument_list>(<argument><expr><name>apr_status_t</name></expr></argument>,<argument><expr><name>uldap_connection_unbind</name></expr></argument>,<argument><expr>(<name>void</name> *<name>param</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/**
 * Find a connection in a list of connections
 * @param r The request record
 * @param host The hostname to connect to (multiple hosts space separated)
 * @param port The port to connect to
 * @param binddn The DN to bind with
 * @param bindpw The password to bind with
 * @param deref The dereferencing behavior
 * @param secure use SSL on the connection
 * @tip Once a connection is found and returned, a lock will be acquired to
 *      lock that particular connection, so that another thread does not try and
 *      use this connection while it is busy. Once you are finished with a connection,
 *      apr_ldap_connection_close() must be called to release this connection.
 * @fn util_ldap_connection_t *util_ldap_connection_find(request_rec *r, const char *host, int port,
 *                                                           const char *binddn, const char *bindpw, deref_options deref,
 *                                                           int netscapessl, int starttls)
 */</comment>
<expr_stmt><expr><call><name>APR_DECLARE_OPTIONAL_FN</name><argument_list>(<argument><expr><name>util_ldap_connection_t</name> *</expr></argument>,<argument><expr><name>uldap_connection_find</name></expr></argument>,<argument><expr>(<name>request_rec</name> *<name>r</name>, const <name>char</name> *<name>host</name>, <name>int</name> <name>port</name>,
                                                  const <name>char</name> *<name>binddn</name>, const <name>char</name> *<name>bindpw</name>, <name>deref_options</name> <name>deref</name>,
                                                  <name>int</name> <name>secure</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/**
 * Compare two DNs for sameness
 * @param r The request record
 * @param ldc The LDAP connection being used.
 * @param url The URL of the LDAP connection - used for deciding which cache to use.
 * @param dn The first DN to compare.
 * @param reqdn The DN to compare the first DN to.
 * @param compare_dn_on_server Flag to determine whether the DNs should be checked using
 *                             LDAP calls or with a direct string comparison. A direct
 *                             string comparison is faster, but not as accurate - false
 *                             negative comparisons are possible.
 * @tip Two DNs can be equal and still fail a string comparison. Eg "dc=example,dc=com"
 *      and "dc=example, dc=com". Use the compare_dn_on_server unless there are serious
 *      performance issues.
 * @fn int util_ldap_cache_comparedn(request_rec *r, util_ldap_connection_t *ldc,
 *                                        const char *url, const char *dn, const char *reqdn,
 *                                        int compare_dn_on_server)
 */</comment>
<expr_stmt><expr><call><name>APR_DECLARE_OPTIONAL_FN</name><argument_list>(<argument><expr><name>int</name></expr></argument>,<argument><expr><name>uldap_cache_comparedn</name></expr></argument>,<argument><expr>(<name>request_rec</name> *<name>r</name>, <name>util_ldap_connection_t</name> *<name>ldc</name>,
                              const <name>char</name> *<name>url</name>, const <name>char</name> *<name>dn</name>, const <name>char</name> *<name>reqdn</name>,
                              <name>int</name> <name>compare_dn_on_server</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/**
 * A generic LDAP compare function
 * @param r The request record
 * @param ldc The LDAP connection being used.
 * @param url The URL of the LDAP connection - used for deciding which cache to use.
 * @param dn The DN of the object in which we do the compare.
 * @param attrib The attribute within the object we are comparing for.
 * @param value The value of the attribute we are trying to compare for.
 * @tip Use this function to determine whether an attribute/value pair exists within an
 *      object. Typically this would be used to determine LDAP top-level group
 *      membership.
 * @fn int util_ldap_cache_compare(request_rec *r, util_ldap_connection_t *ldc,
 *                                      const char *url, const char *dn, const char *attrib, const char *value)
 */</comment>
<expr_stmt><expr><call><name>APR_DECLARE_OPTIONAL_FN</name><argument_list>(<argument><expr><name>int</name></expr></argument>,<argument><expr><name>uldap_cache_compare</name></expr></argument>,<argument><expr>(<name>request_rec</name> *<name>r</name>, <name>util_ldap_connection_t</name> *<name>ldc</name>,
                            const <name>char</name> *<name>url</name>, const <name>char</name> *<name>dn</name>, const <name>char</name> *<name>attrib</name>, const <name>char</name> *<name>value</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/**
 * An LDAP function that checks if the specified user is a member of a subgroup.
 * @param r The request record
 * @param ldc The LDAP connection being used.
 * @param url The URL of the LDAP connection - used for deciding which cache to use.
 * @param dn The DN of the object in which we find subgroups to search within.
 * @param attrib The attribute within group objects that identify users.
 * @param value The user attribute value we are trying to compare for.
 * @param subgroupAttrs The attributes within group objects that identify subgroups.
 *                      Array of strings.
 * @param subgroupclasses The objectClass values used to identify groups (and
 *                      subgroups). apr_array_header_t *.
 * @param cur_subgroup_depth Current recursive depth during subgroup processing.
 * @param max_subgroup_depth Maximum depth of recursion allowed during subgroup
 *                           processing.
 * @tip Use this function to determine whether an attribute/value pair exists within a
 *      starting group object or one of its nested subgroups. Typically this would be
 *      used to determine LDAP nested group membership.
 * @deffunc int util_ldap_cache_check_subgroups(request_rec *r, util_ldap_connection_t
 *                                      *ldc, const char *url, const char *dn,
 *                                      const char *attrib, const char value,
 *                                      char **subgroupAttrs, apr_array_header_t
 *                                      *subgroupclasses, int cur_subgroup_depth, int
 *                                      max_subgroup_depth )
 */</comment>
<expr_stmt><expr><call><name>APR_DECLARE_OPTIONAL_FN</name><argument_list>(<argument><expr><name>int</name></expr></argument>,<argument><expr><name>uldap_cache_check_subgroups</name></expr></argument>,<argument><expr>(<name>request_rec</name> *<name>r</name>, <name>util_ldap_connection_t</name> *<name>ldc</name>,
                                       const <name>char</name> *<name>url</name>, const <name>char</name> *<name>dn</name>, const <name>char</name> *<name>attrib</name>, const <name>char</name> *<name>value</name>,
                                       <name>char</name> **<name>subgroupAttrs</name>, <name>apr_array_header_t</name> *<name>subgroupclasses</name>,
                                       <name>int</name> <name>cur_subgroup_depth</name>, <name>int</name> <name>max_subgroup_depth</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/**
 * Checks a username/password combination by binding to the LDAP server
 * @param r The request record
 * @param ldc The LDAP connection being used.
 * @param url The URL of the LDAP connection - used for deciding which cache to use.
 * @param basedn The Base DN to search for the user in.
 * @param scope LDAP scope of the search.
 * @param attrs LDAP attributes to return in search.
 * @param filter The user to search for in the form of an LDAP filter. This filter must return
 *               exactly one user for the check to be successful.
 * @param bindpw The user password to bind as.
 * @param binddn The DN of the user will be returned in this variable.
 * @param retvals The values corresponding to the attributes requested in the attrs array.
 * @tip The filter supplied will be searched for. If a single entry is returned, an attempt
 *      is made to bind as that user. If this bind succeeds, the user is not validated.
 * @fn int util_ldap_cache_checkuserid(request_rec *r, util_ldap_connection_t *ldc,
 *                                          char *url, const char *basedn, int scope, char **attrs,
 *                                          char *filter, char *bindpw, char **binddn, char ***retvals)
 */</comment>
<expr_stmt><expr><call><name>APR_DECLARE_OPTIONAL_FN</name><argument_list>(<argument><expr><name>int</name></expr></argument>,<argument><expr><name>uldap_cache_checkuserid</name></expr></argument>,<argument><expr>(<name>request_rec</name> *<name>r</name>, <name>util_ldap_connection_t</name> *<name>ldc</name>,
                              const <name>char</name> *<name>url</name>, const <name>char</name> *<name>basedn</name>, <name>int</name> <name>scope</name>, <name>char</name> **<name>attrs</name>,
                              const <name>char</name> *<name>filter</name>, const <name>char</name> *<name>bindpw</name>, const <name>char</name> **<name>binddn</name>, const <name>char</name> ***<name>retvals</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/**
 * Searches for a specified user object in an LDAP directory
 * @param r The request record
 * @param ldc The LDAP connection being used.
 * @param url The URL of the LDAP connection - used for deciding which cache to use.
 * @param basedn The Base DN to search for the user in.
 * @param scope LDAP scope of the search.
 * @param attrs LDAP attributes to return in search.
 * @param filter The user to search for in the form of an LDAP filter. This filter must return
 *               exactly one user for the check to be successful.
 * @param binddn The DN of the user will be returned in this variable.
 * @param retvals The values corresponding to the attributes requested in the attrs array.
 * @tip The filter supplied will be searched for. If a single entry is returned, an attempt
 *      is made to bind as that user. If this bind succeeds, the user is not validated.
 * @fn int util_ldap_cache_getuserdn(request_rec *r, util_ldap_connection_t *ldc,
 *                                          char *url, const char *basedn, int scope, char **attrs,
 *                                          char *filter, char **binddn, char ***retvals)
 */</comment>
<expr_stmt><expr><call><name>APR_DECLARE_OPTIONAL_FN</name><argument_list>(<argument><expr><name>int</name></expr></argument>,<argument><expr><name>uldap_cache_getuserdn</name></expr></argument>,<argument><expr>(<name>request_rec</name> *<name>r</name>, <name>util_ldap_connection_t</name> *<name>ldc</name>,
                              const <name>char</name> *<name>url</name>, const <name>char</name> *<name>basedn</name>, <name>int</name> <name>scope</name>, <name>char</name> **<name>attrs</name>,
                              const <name>char</name> *<name>filter</name>, const <name>char</name> **<name>binddn</name>, const <name>char</name> ***<name>retvals</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/**
 * Checks if SSL support is available in mod_ldap
 * @fn int util_ldap_ssl_supported(request_rec *r)
 */</comment>
<expr_stmt><expr><call><name>APR_DECLARE_OPTIONAL_FN</name><argument_list>(<argument><expr><name>int</name></expr></argument>,<argument><expr><name>uldap_ssl_supported</name></expr></argument>,<argument><expr>(<name>request_rec</name> *<name>r</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/* from apr_ldap_cache.c */</comment>

<comment type="block">/**
 * Init the LDAP cache
 * @param pool The pool to use to initialise the cache
 * @param reqsize The size of the shared memory segment to request. A size
 *                of zero requests the max size possible from
 *                apr_shmem_init()
 * @fn void util_ldap_cache_init(apr_pool_t *p, util_ldap_state_t *st)
 * @return The status code returned is the status code of the
 *         apr_smmem_init() call. Regardless of the status, the cache
 *         will be set up at least for in-process or in-thread operation.
 */</comment>
<function_decl><type><name>apr_status_t</name></type> <name>util_ldap_cache_init</name><parameter_list>(<param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>, <param><decl><type><name>util_ldap_state_t</name> *</type><name>st</name></decl></param>)</parameter_list>;</function_decl>

<comment type="block">/* from apr_ldap_cache_mgr.c */</comment>

<comment type="block">/**
 * Display formatted stats for cache
 * @param The pool to allocate the returned string from
 * @tip This function returns a string allocated from the provided pool that describes
 *      various stats about the cache.
 * @fn char *util_ald_cache_display(apr_pool_t *pool, util_ldap_state_t *st)
 */</comment>
<function_decl><type><name>char</name> *</type><name>util_ald_cache_display</name><parameter_list>(<param><decl><type><name>request_rec</name> *</type><name>r</name></decl></param>, <param><decl><type><name>util_ldap_state_t</name> *</type><name>st</name></decl></param>)</parameter_list>;</function_decl>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__cplusplus</name></cpp:ifdef>
}</block></extern>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* APR_HAS_LDAP */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* UTIL_LDAP_H */</comment>
</unit>
