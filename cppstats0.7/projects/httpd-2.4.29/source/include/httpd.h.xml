<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C" filename="projects/httpd-2.4.29/include/httpd.h"><comment type="block">/* Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */</comment>

<comment type="block">/**
 * @file httpd.h
 * @brief HTTP Daemon routines
 *
 * @defgroup APACHE Apache HTTP Server
 *
 * Top level group of which all other groups are a member
 * @{
 *
 * @defgroup APACHE_MODS Loadable modules
 *           Top level group for modules
 * @defgroup APACHE_OS Operating System Specific
 * @defgroup APACHE_INTERNAL Internal interfaces
 * @defgroup APACHE_CORE Core routines
 * @{
 * @defgroup APACHE_CORE_DAEMON HTTP Daemon Routine
 * @{
 */</comment>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>APACHE_HTTPD_H</name></cpp:ifndef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>APACHE_HTTPD_H</name></cpp:macro></cpp:define>

<comment type="block">/* XXX - We need to push more stuff to other .h files, or even .c files, to
 * make this file smaller
 */</comment>

<comment type="block">/* Headers in which EVERYONE has an interest... */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ap_config.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ap_mmn.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ap_release.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"apr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"apr_general.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"apr_tables.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"apr_pools.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"apr_time.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"apr_network_io.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"apr_buckets.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"apr_poll.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"apr_thread_proc.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"os.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ap_regex.h"</cpp:file></cpp:include>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>APR_HAVE_STDLIB_H</name></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdlib.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* Note: apr_uri.h is also included, see below */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__cplusplus</name></cpp:ifdef>
<extern>extern "C" <block>{
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* ----------------------------- config dir ------------------------------ */</comment>

<comment type="block">/** Define this to be the default server home dir. Most things later in this
 * file with a relative pathname will have this added.
 */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>HTTPD_ROOT</name></cpp:ifndef>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>OS2</name></cpp:ifdef>
<comment type="block">/** Set default for OS/2 file system */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HTTPD_ROOT</name></cpp:macro> <cpp:value>"/os2httpd"</cpp:value></cpp:define>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>WIN32</name></expr></argument>)</argument_list></call></expr></cpp:elif>
<comment type="block">/** Set default for Windows file system */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HTTPD_ROOT</name></cpp:macro> <cpp:value>"/apache"</cpp:value></cpp:define>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name> <argument_list>(<argument><expr><name>NETWARE</name></expr></argument>)</argument_list></call></expr></cpp:elif>
<comment type="block">/** Set the default for NetWare */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HTTPD_ROOT</name></cpp:macro> <cpp:value>"/apache"</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<comment type="block">/** Set for all other OSs */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HTTPD_ROOT</name></cpp:macro> <cpp:value>"/usr/local/apache"</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* HTTPD_ROOT */</comment>

<comment type="block">/*
 * --------- You shouldn't have to edit anything below this line ----------
 *
 * Any modifications to any defaults not defined above should be done in the
 * respective configuration file.
 *
 */</comment>

<comment type="block">/**
 * Default location of documents.  Can be overridden by the DocumentRoot
 * directive.
 */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>DOCUMENT_LOCATION</name></cpp:ifndef>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>OS2</name></cpp:ifdef>
<comment type="block">/* Set default for OS/2 file system */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DOCUMENT_LOCATION</name></cpp:macro>  <cpp:value>HTTPD_ROOT "/docs"</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<comment type="block">/* Set default for non OS/2 file system */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DOCUMENT_LOCATION</name></cpp:macro>  <cpp:value>HTTPD_ROOT "/htdocs"</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* DOCUMENT_LOCATION */</comment>

<comment type="block">/** Maximum number of dynamically loaded modules */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>DYNAMIC_MODULE_LIMIT</name></cpp:ifndef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DYNAMIC_MODULE_LIMIT</name></cpp:macro> <cpp:value>256</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/** Default administrator's address */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DEFAULT_ADMIN</name></cpp:macro> <cpp:value>"[no address given]"</cpp:value></cpp:define>

<comment type="block">/** The name of the log files */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>DEFAULT_ERRORLOG</name></cpp:ifndef>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>OS2</name></expr></argument>)</argument_list></call> || <call><name>defined</name><argument_list>(<argument><expr><name>WIN32</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DEFAULT_ERRORLOG</name></cpp:macro> <cpp:value>"logs/error.log"</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DEFAULT_ERRORLOG</name></cpp:macro> <cpp:value>"logs/error_log"</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* DEFAULT_ERRORLOG */</comment>

<comment type="block">/** Define this to be what your per-directory security files are called */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>DEFAULT_ACCESS_FNAME</name></cpp:ifndef>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>OS2</name></cpp:ifdef>
<comment type="block">/* Set default for OS/2 file system */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DEFAULT_ACCESS_FNAME</name></cpp:macro> <cpp:value>"htaccess"</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DEFAULT_ACCESS_FNAME</name></cpp:macro> <cpp:value>".htaccess"</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* DEFAULT_ACCESS_FNAME */</comment>

<comment type="block">/** The name of the server config file */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SERVER_CONFIG_FILE</name></cpp:ifndef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SERVER_CONFIG_FILE</name></cpp:macro> <cpp:value>"conf/httpd.conf"</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/** The default path for CGI scripts if none is currently set */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>DEFAULT_PATH</name></cpp:ifndef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DEFAULT_PATH</name></cpp:macro> <cpp:value>"/bin:/usr/bin:/usr/ucb:/usr/bsd:/usr/local/bin"</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/** The path to the suExec wrapper, can be overridden in Configuration */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SUEXEC_BIN</name></cpp:ifndef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SUEXEC_BIN</name></cpp:macro>  <cpp:value>HTTPD_ROOT "/bin/suexec"</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/** The timeout for waiting for messages */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>DEFAULT_TIMEOUT</name></cpp:ifndef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DEFAULT_TIMEOUT</name></cpp:macro> <cpp:value>60</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/** The timeout for waiting for keepalive timeout until next request */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>DEFAULT_KEEPALIVE_TIMEOUT</name></cpp:ifndef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DEFAULT_KEEPALIVE_TIMEOUT</name></cpp:macro> <cpp:value>5</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/** The number of requests to entertain per connection */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>DEFAULT_KEEPALIVE</name></cpp:ifndef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DEFAULT_KEEPALIVE</name></cpp:macro> <cpp:value>100</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
 * Limits on the size of various request items.  These limits primarily
 * exist to prevent simple denial-of-service attacks on a server based
 * on misuse of the protocol.  The recommended values will depend on the
 * nature of the server resources -- CGI scripts and database backends
 * might require large values, but most servers could get by with much
 * smaller limits than we use below.  The request message body size can
 * be limited by the per-dir config directive LimitRequestBody.
 *
 * Internal buffer sizes are two bytes more than the DEFAULT_LIMIT_REQUEST_LINE
 * and DEFAULT_LIMIT_REQUEST_FIELDSIZE below, which explains the 8190.
 * These two limits can be lowered or raised by the server config
 * directives LimitRequestLine and LimitRequestFieldsize, respectively.
 *
 * DEFAULT_LIMIT_REQUEST_FIELDS can be modified or disabled (set = 0) by
 * the server config directive LimitRequestFields.
 */</comment>

<comment type="block">/** default limit on bytes in Request-Line (Method+URI+HTTP-version) */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>DEFAULT_LIMIT_REQUEST_LINE</name></cpp:ifndef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DEFAULT_LIMIT_REQUEST_LINE</name></cpp:macro> <cpp:value>8190</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<comment type="block">/** default limit on bytes in any one header field  */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>DEFAULT_LIMIT_REQUEST_FIELDSIZE</name></cpp:ifndef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DEFAULT_LIMIT_REQUEST_FIELDSIZE</name></cpp:macro> <cpp:value>8190</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<comment type="block">/** default limit on number of request header fields */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>DEFAULT_LIMIT_REQUEST_FIELDS</name></cpp:ifndef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DEFAULT_LIMIT_REQUEST_FIELDS</name></cpp:macro> <cpp:value>100</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<comment type="block">/** default/hard limit on number of leading/trailing empty lines */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>DEFAULT_LIMIT_BLANK_LINES</name></cpp:ifndef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DEFAULT_LIMIT_BLANK_LINES</name></cpp:macro> <cpp:value>10</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/**
 * The default default character set name to add if AddDefaultCharset is
 * enabled.  Overridden with AddDefaultCharsetName.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DEFAULT_ADD_DEFAULT_CHARSET_NAME</name></cpp:macro> <cpp:value>"iso-8859-1"</cpp:value></cpp:define>

<comment type="block">/** default HTTP Server protocol */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AP_SERVER_PROTOCOL</name></cpp:macro> <cpp:value>"HTTP/1.1"</cpp:value></cpp:define>


<comment type="block">/* ------------------ stuff that modules are allowed to look at ----------- */</comment>

<comment type="block">/** Define this to be what your HTML directory content files are called */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>AP_DEFAULT_INDEX</name></cpp:ifndef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AP_DEFAULT_INDEX</name></cpp:macro> <cpp:value>"index.html"</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/** The name of the MIME types file */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>AP_TYPES_CONFIG_FILE</name></cpp:ifndef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AP_TYPES_CONFIG_FILE</name></cpp:macro> <cpp:value>"conf/mime.types"</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
 * Define the HTML doctype strings centrally.
 */</comment>
<comment type="block">/** HTML 2.0 Doctype */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DOCTYPE_HTML_2_0</name></cpp:macro>  <cpp:value>"&lt;!DOCTYPE HTML PUBLIC \"-//IETF//" \
                          "DTD HTML 2.0//EN\"&gt;\n"</cpp:value></cpp:define>
<comment type="block">/** HTML 3.2 Doctype */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DOCTYPE_HTML_3_2</name></cpp:macro>  <cpp:value>"&lt;!DOCTYPE HTML PUBLIC \"-//W3C//" \
                          "DTD HTML 3.2 Final//EN\"&gt;\n"</cpp:value></cpp:define>
<comment type="block">/** HTML 4.0 Strict Doctype */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DOCTYPE_HTML_4_0S</name></cpp:macro> <cpp:value>"&lt;!DOCTYPE HTML PUBLIC \"-//W3C//" \
                          "DTD HTML 4.0//EN\"\n" \
                          "\"http://www.w3.org/TR/REC-html40/strict.dtd\"&gt;\n"</cpp:value></cpp:define>
<comment type="block">/** HTML 4.0 Transitional Doctype */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DOCTYPE_HTML_4_0T</name></cpp:macro> <cpp:value>"&lt;!DOCTYPE HTML PUBLIC \"-//W3C//" \
                          "DTD HTML 4.0 Transitional//EN\"\n" \
                          "\"http://www.w3.org/TR/REC-html40/loose.dtd\"&gt;\n"</cpp:value></cpp:define>
<comment type="block">/** HTML 4.0 Frameset Doctype */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DOCTYPE_HTML_4_0F</name></cpp:macro> <cpp:value>"&lt;!DOCTYPE HTML PUBLIC \"-//W3C//" \
                          "DTD HTML 4.0 Frameset//EN\"\n" \
                          "\"http://www.w3.org/TR/REC-html40/frameset.dtd\"&gt;\n"</cpp:value></cpp:define>
<comment type="block">/** XHTML 1.0 Strict Doctype */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DOCTYPE_XHTML_1_0S</name></cpp:macro> <cpp:value>"&lt;!DOCTYPE html PUBLIC \"-//W3C//" \
                           "DTD XHTML 1.0 Strict//EN\"\n" \
                           "\"http://www.w3.org/TR/xhtml1/DTD/" \
                           "xhtml1-strict.dtd\"&gt;\n"</cpp:value></cpp:define>
<comment type="block">/** XHTML 1.0 Transitional Doctype */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DOCTYPE_XHTML_1_0T</name></cpp:macro> <cpp:value>"&lt;!DOCTYPE html PUBLIC \"-//W3C//" \
                           "DTD XHTML 1.0 Transitional//EN\"\n" \
                           "\"http://www.w3.org/TR/xhtml1/DTD/" \
                           "xhtml1-transitional.dtd\"&gt;\n"</cpp:value></cpp:define>
<comment type="block">/** XHTML 1.0 Frameset Doctype */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DOCTYPE_XHTML_1_0F</name></cpp:macro> <cpp:value>"&lt;!DOCTYPE html PUBLIC \"-//W3C//" \
                           "DTD XHTML 1.0 Frameset//EN\"\n" \
                           "\"http://www.w3.org/TR/xhtml1/DTD/" \
                           "xhtml1-frameset.dtd\"&gt;"</cpp:value></cpp:define>

<comment type="block">/** Internal representation for a HTTP protocol number, e.g., HTTP/1.1 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HTTP_VERSION</name><parameter_list>(<param><type><name>major</name></type></param>,<param><type><name>minor</name></type></param>)</parameter_list></cpp:macro> <cpp:value>(1000*(major)+(minor))</cpp:value></cpp:define>
<comment type="block">/** Major part of HTTP protocol */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HTTP_VERSION_MAJOR</name><parameter_list>(<param><type><name>number</name></type></param>)</parameter_list></cpp:macro> <cpp:value>((number)/1000)</cpp:value></cpp:define>
<comment type="block">/** Minor part of HTTP protocol */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HTTP_VERSION_MINOR</name><parameter_list>(<param><type><name>number</name></type></param>)</parameter_list></cpp:macro> <cpp:value>((number)%1000)</cpp:value></cpp:define>

<comment type="block">/* -------------- Port number for server running standalone --------------- */</comment>

<comment type="block">/** default HTTP Port */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DEFAULT_HTTP_PORT</name></cpp:macro>       <cpp:value>80</cpp:value></cpp:define>
<comment type="block">/** default HTTPS Port */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DEFAULT_HTTPS_PORT</name></cpp:macro>      <cpp:value>443</cpp:value></cpp:define>
<comment type="block">/**
 * Check whether @a port is the default port for the request @a r.
 * @param port The port number
 * @param r The request
 * @see #ap_default_port
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ap_is_default_port</name><parameter_list>(<param><type><name>port</name></type></param>,<param><type><name>r</name></type></param>)</parameter_list></cpp:macro>      <cpp:value>((port) == ap_default_port(r))</cpp:value></cpp:define>
<comment type="block">/**
 * Get the default port for a request (which depends on the scheme).
 * @param r The request
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ap_default_port</name><parameter_list>(<param><type><name>r</name></type></param>)</parameter_list></cpp:macro>      <cpp:value>ap_run_default_port(r)</cpp:value></cpp:define>
<comment type="block">/**
 * Get the scheme for a request.
 * @param r The request
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ap_http_scheme</name><parameter_list>(<param><type><name>r</name></type></param>)</parameter_list></cpp:macro>       <cpp:value>ap_run_http_scheme(r)</cpp:value></cpp:define>

<comment type="block">/** The default string length */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAX_STRING_LEN</name></cpp:macro> <cpp:value>HUGE_STRING_LEN</cpp:value></cpp:define>

<comment type="block">/** The length of a Huge string */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HUGE_STRING_LEN</name></cpp:macro> <cpp:value>8192</cpp:value></cpp:define>

<comment type="block">/** The size of the server's internal read-write buffers */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AP_IOBUFSIZE</name></cpp:macro> <cpp:value>8192</cpp:value></cpp:define>

<comment type="block">/** The max number of regex captures that can be expanded by ap_pregsub */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AP_MAX_REG_MATCH</name></cpp:macro> <cpp:value>10</cpp:value></cpp:define>

<comment type="block">/**
 * APR_HAS_LARGE_FILES introduces the problem of spliting sendfile into
 * multiple buckets, no greater than MAX(apr_size_t), and more granular
 * than that in case the brigade code/filters attempt to read it directly.
 * ### 16mb is an invention, no idea if it is reasonable.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AP_MAX_SENDFILE</name></cpp:macro> <cpp:value>16777216</cpp:value></cpp:define>  <comment type="block">/* 2^24 */</comment>

<comment type="block">/**
 * MPM child process exit status values
 * The MPM parent process may check the status to see if special
 * error handling is required.
 */</comment>
<comment type="block">/** a normal exit */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>APEXIT_OK</name></cpp:macro>               <cpp:value>0x0</cpp:value></cpp:define>
<comment type="block">/** A fatal error arising during the server's init sequence */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>APEXIT_INIT</name></cpp:macro>             <cpp:value>0x2</cpp:value></cpp:define>
<comment type="block">/**  The child died during its init sequence */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>APEXIT_CHILDINIT</name></cpp:macro>        <cpp:value>0x3</cpp:value></cpp:define>
<comment type="block">/**
 *   The child exited due to a resource shortage.
 *   The parent should limit the rate of forking until
 *   the situation is resolved.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>APEXIT_CHILDSICK</name></cpp:macro>        <cpp:value>0x7</cpp:value></cpp:define>
<comment type="block">/**
 *     A fatal error, resulting in the whole server aborting.
 *     If a child exits with this error, the parent process
 *     considers this a server-wide fatal error and aborts.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>APEXIT_CHILDFATAL</name></cpp:macro>       <cpp:value>0xf</cpp:value></cpp:define>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>AP_DECLARE</name></cpp:ifndef>
<comment type="block">/**
 * Stuff marked #AP_DECLARE is part of the API, and intended for use
 * by modules. Its purpose is to allow us to add attributes that
 * particular platforms or compilers require to every exported function.
 */</comment>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>AP_DECLARE</name><parameter_list>(<param><type><name>type</name></type></param>)</parameter_list></cpp:macro>    <cpp:value>type</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>AP_DECLARE_NONSTD</name></cpp:ifndef>
<comment type="block">/**
 * Stuff marked #AP_DECLARE_NONSTD is part of the API, and intended for
 * use by modules.  The difference between #AP_DECLARE and
 * #AP_DECLARE_NONSTD is that the latter is required for any functions
 * which use varargs or are used via indirect function call.  This
 * is to accommodate the two calling conventions in windows dlls.
 */</comment>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>AP_DECLARE_NONSTD</name><parameter_list>(<param><type><name>type</name></type></param>)</parameter_list></cpp:macro>    <cpp:value>type</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>AP_DECLARE_DATA</name></cpp:ifndef>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>AP_DECLARE_DATA</name></cpp:macro></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>AP_MODULE_DECLARE</name></cpp:ifndef>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>AP_MODULE_DECLARE</name><parameter_list>(<param><type><name>type</name></type></param>)</parameter_list></cpp:macro>    <cpp:value>type</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>AP_MODULE_DECLARE_NONSTD</name></cpp:ifndef>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>AP_MODULE_DECLARE_NONSTD</name><parameter_list>(<param><type><name>type</name></type></param>)</parameter_list></cpp:macro>  <cpp:value>type</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>AP_MODULE_DECLARE_DATA</name></cpp:ifndef>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>AP_MODULE_DECLARE_DATA</name></cpp:macro></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/**
 * @internal
 * modules should not use functions marked AP_CORE_DECLARE
 */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>AP_CORE_DECLARE</name></cpp:ifndef>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>AP_CORE_DECLARE</name></cpp:macro>        <cpp:value>AP_DECLARE</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/**
 * @internal
 * modules should not use functions marked AP_CORE_DECLARE_NONSTD
 */</comment>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>AP_CORE_DECLARE_NONSTD</name></cpp:ifndef>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>AP_CORE_DECLARE_NONSTD</name></cpp:macro> <cpp:value>AP_DECLARE_NONSTD</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/**
 * @defgroup APACHE_APR_STATUS_T HTTPD specific values of apr_status_t
 * @{
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AP_START_USERERR</name></cpp:macro>            <cpp:value>(APR_OS_START_USERERR + 2000)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AP_USERERR_LEN</name></cpp:macro>              <cpp:value>1000</cpp:value></cpp:define>

<comment type="block">/** The function declines to handle the request */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AP_DECLINED</name></cpp:macro>                 <cpp:value>(AP_START_USERERR + 0)</cpp:value></cpp:define>

<comment type="block">/** @} */</comment>

<comment type="block">/**
 * @brief The numeric version information is broken out into fields within this
 * structure.
 */</comment>
<typedef>typedef <type><struct>struct <block>{
    <decl_stmt><decl><type><name>int</name></type> <name>major</name></decl>;</decl_stmt>              <comment type="block">/**&lt; major number */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>minor</name></decl>;</decl_stmt>              <comment type="block">/**&lt; minor number */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>patch</name></decl>;</decl_stmt>              <comment type="block">/**&lt; patch number */</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>add_string</name></decl>;</decl_stmt> <comment type="block">/**&lt; additional string like "-dev" */</comment>
}</block></struct></type> <name>ap_version_t</name>;</typedef>

<comment type="block">/**
 * Return httpd's version information in a numeric form.
 *
 *  @param version Pointer to a version structure for returning the version
 *                 information.
 */</comment>
<macro><name>AP_DECLARE</name><argument_list>(<argument>void</argument>)</argument_list></macro> <expr_stmt><expr><call><name>ap_get_server_revision</name><argument_list>(<argument><expr><name>ap_version_t</name> *<name>version</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/**
 * Get the server banner in a form suitable for sending over the
 * network, with the level of information controlled by the
 * ServerTokens directive.
 * @return The server banner
 */</comment>
<macro><name>AP_DECLARE</name><argument_list>(<argument>const char *</argument>)</argument_list></macro> <expr_stmt><expr><call><name>ap_get_server_banner</name><argument_list>(<argument><expr><name>void</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/**
 * Get the server description in a form suitable for local displays,
 * status reports, or logging.  This includes the detailed server
 * version and information about some modules.  It is not affected
 * by the ServerTokens directive.
 * @return The server description
 */</comment>
<macro><name>AP_DECLARE</name><argument_list>(<argument>const char *</argument>)</argument_list></macro> <expr_stmt><expr><call><name>ap_get_server_description</name><argument_list>(<argument><expr><name>void</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/**
 * Add a component to the server description and banner strings
 * @param pconf The pool to allocate the component from
 * @param component The string to add
 */</comment>
<macro><name>AP_DECLARE</name><argument_list>(<argument>void</argument>)</argument_list></macro> <expr_stmt><expr><call><name>ap_add_version_component</name><argument_list>(<argument><expr><name>apr_pool_t</name> *<name>pconf</name></expr></argument>, <argument><expr>const <name>char</name> *<name>component</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/**
 * Get the date a time that the server was built
 * @return The server build time string
 */</comment>
<macro><name>AP_DECLARE</name><argument_list>(<argument>const char *</argument>)</argument_list></macro> <expr_stmt><expr><call><name>ap_get_server_built</name><argument_list>(<argument><expr><name>void</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/* non-HTTP status codes returned by hooks */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>OK</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>                    <comment type="block">/**&lt; Module has handled this stage. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DECLINED</name></cpp:macro> <cpp:value>-1</cpp:value></cpp:define>             <comment type="block">/**&lt; Module declines to handle */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DONE</name></cpp:macro> <cpp:value>-2</cpp:value></cpp:define>                 <comment type="block">/**&lt; Module has served the response completely
                                 *  - it's safe to die() with no more output
                                 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SUSPENDED</name></cpp:macro> <cpp:value>-3</cpp:value></cpp:define> <comment type="block">/**&lt; Module will handle the remainder of the request.
                      * The core will never invoke the request again, */</comment>

<comment type="block">/** Returned by the bottom-most filter if no data was written.
 *  @see ap_pass_brigade(). */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AP_NOBODY_WROTE</name></cpp:macro>         <cpp:value>-100</cpp:value></cpp:define>
<comment type="block">/** Returned by the bottom-most filter if no data was read.
 *  @see ap_get_brigade(). */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AP_NOBODY_READ</name></cpp:macro>          <cpp:value>-101</cpp:value></cpp:define>
<comment type="block">/** Returned by any filter if the filter chain encounters an error
 *  and has already dealt with the error response.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AP_FILTER_ERROR</name></cpp:macro>         <cpp:value>-102</cpp:value></cpp:define>

<comment type="block">/**
 * @defgroup HTTP_Status HTTP Status Codes
 * @{
 */</comment>
<comment type="block">/**
 * The size of the static status_lines array in http_protocol.c for
 * storing all of the potential response status-lines (a sparse table).
 * When adding a new code here add it to status_lines as well.
 * A future version should dynamically generate the apr_table_t at startup.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RESPONSE_CODES</name></cpp:macro> <cpp:value>103</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HTTP_CONTINUE</name></cpp:macro>                        <cpp:value>100</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HTTP_SWITCHING_PROTOCOLS</name></cpp:macro>             <cpp:value>101</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HTTP_PROCESSING</name></cpp:macro>                      <cpp:value>102</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HTTP_OK</name></cpp:macro>                              <cpp:value>200</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HTTP_CREATED</name></cpp:macro>                         <cpp:value>201</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HTTP_ACCEPTED</name></cpp:macro>                        <cpp:value>202</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HTTP_NON_AUTHORITATIVE</name></cpp:macro>               <cpp:value>203</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HTTP_NO_CONTENT</name></cpp:macro>                      <cpp:value>204</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HTTP_RESET_CONTENT</name></cpp:macro>                   <cpp:value>205</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HTTP_PARTIAL_CONTENT</name></cpp:macro>                 <cpp:value>206</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HTTP_MULTI_STATUS</name></cpp:macro>                    <cpp:value>207</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HTTP_ALREADY_REPORTED</name></cpp:macro>                <cpp:value>208</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HTTP_IM_USED</name></cpp:macro>                         <cpp:value>226</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HTTP_MULTIPLE_CHOICES</name></cpp:macro>                <cpp:value>300</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HTTP_MOVED_PERMANENTLY</name></cpp:macro>               <cpp:value>301</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HTTP_MOVED_TEMPORARILY</name></cpp:macro>               <cpp:value>302</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HTTP_SEE_OTHER</name></cpp:macro>                       <cpp:value>303</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HTTP_NOT_MODIFIED</name></cpp:macro>                    <cpp:value>304</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HTTP_USE_PROXY</name></cpp:macro>                       <cpp:value>305</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HTTP_TEMPORARY_REDIRECT</name></cpp:macro>              <cpp:value>307</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HTTP_PERMANENT_REDIRECT</name></cpp:macro>              <cpp:value>308</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HTTP_BAD_REQUEST</name></cpp:macro>                     <cpp:value>400</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HTTP_UNAUTHORIZED</name></cpp:macro>                    <cpp:value>401</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HTTP_PAYMENT_REQUIRED</name></cpp:macro>                <cpp:value>402</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HTTP_FORBIDDEN</name></cpp:macro>                       <cpp:value>403</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HTTP_NOT_FOUND</name></cpp:macro>                       <cpp:value>404</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HTTP_METHOD_NOT_ALLOWED</name></cpp:macro>              <cpp:value>405</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HTTP_NOT_ACCEPTABLE</name></cpp:macro>                  <cpp:value>406</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HTTP_PROXY_AUTHENTICATION_REQUIRED</name></cpp:macro>   <cpp:value>407</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HTTP_REQUEST_TIME_OUT</name></cpp:macro>                <cpp:value>408</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HTTP_CONFLICT</name></cpp:macro>                        <cpp:value>409</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HTTP_GONE</name></cpp:macro>                            <cpp:value>410</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HTTP_LENGTH_REQUIRED</name></cpp:macro>                 <cpp:value>411</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HTTP_PRECONDITION_FAILED</name></cpp:macro>             <cpp:value>412</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HTTP_REQUEST_ENTITY_TOO_LARGE</name></cpp:macro>        <cpp:value>413</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HTTP_REQUEST_URI_TOO_LARGE</name></cpp:macro>           <cpp:value>414</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HTTP_UNSUPPORTED_MEDIA_TYPE</name></cpp:macro>          <cpp:value>415</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HTTP_RANGE_NOT_SATISFIABLE</name></cpp:macro>           <cpp:value>416</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HTTP_EXPECTATION_FAILED</name></cpp:macro>              <cpp:value>417</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HTTP_MISDIRECTED_REQUEST</name></cpp:macro>             <cpp:value>421</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HTTP_UNPROCESSABLE_ENTITY</name></cpp:macro>            <cpp:value>422</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HTTP_LOCKED</name></cpp:macro>                          <cpp:value>423</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HTTP_FAILED_DEPENDENCY</name></cpp:macro>               <cpp:value>424</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HTTP_UPGRADE_REQUIRED</name></cpp:macro>                <cpp:value>426</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HTTP_PRECONDITION_REQUIRED</name></cpp:macro>           <cpp:value>428</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HTTP_TOO_MANY_REQUESTS</name></cpp:macro>               <cpp:value>429</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HTTP_REQUEST_HEADER_FIELDS_TOO_LARGE</name></cpp:macro> <cpp:value>431</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HTTP_UNAVAILABLE_FOR_LEGAL_REASONS</name></cpp:macro>   <cpp:value>451</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HTTP_INTERNAL_SERVER_ERROR</name></cpp:macro>           <cpp:value>500</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HTTP_NOT_IMPLEMENTED</name></cpp:macro>                 <cpp:value>501</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HTTP_BAD_GATEWAY</name></cpp:macro>                     <cpp:value>502</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HTTP_SERVICE_UNAVAILABLE</name></cpp:macro>             <cpp:value>503</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HTTP_GATEWAY_TIME_OUT</name></cpp:macro>                <cpp:value>504</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HTTP_VERSION_NOT_SUPPORTED</name></cpp:macro>           <cpp:value>505</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HTTP_VARIANT_ALSO_VARIES</name></cpp:macro>             <cpp:value>506</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HTTP_INSUFFICIENT_STORAGE</name></cpp:macro>            <cpp:value>507</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HTTP_LOOP_DETECTED</name></cpp:macro>                   <cpp:value>508</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HTTP_NOT_EXTENDED</name></cpp:macro>                    <cpp:value>510</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HTTP_NETWORK_AUTHENTICATION_REQUIRED</name></cpp:macro> <cpp:value>511</cpp:value></cpp:define>

<comment type="block">/** is the status code informational */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ap_is_HTTP_INFO</name><parameter_list>(<param><type><name>x</name></type></param>)</parameter_list></cpp:macro>         <cpp:value>(((x) &gt;= 100)&amp;&amp;((x) &lt; 200))</cpp:value></cpp:define>
<comment type="block">/** is the status code OK ?*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ap_is_HTTP_SUCCESS</name><parameter_list>(<param><type><name>x</name></type></param>)</parameter_list></cpp:macro>      <cpp:value>(((x) &gt;= 200)&amp;&amp;((x) &lt; 300))</cpp:value></cpp:define>
<comment type="block">/** is the status code a redirect */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ap_is_HTTP_REDIRECT</name><parameter_list>(<param><type><name>x</name></type></param>)</parameter_list></cpp:macro>     <cpp:value>(((x) &gt;= 300)&amp;&amp;((x) &lt; 400))</cpp:value></cpp:define>
<comment type="block">/** is the status code a error (client or server) */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ap_is_HTTP_ERROR</name><parameter_list>(<param><type><name>x</name></type></param>)</parameter_list></cpp:macro>        <cpp:value>(((x) &gt;= 400)&amp;&amp;((x) &lt; 600))</cpp:value></cpp:define>
<comment type="block">/** is the status code a client error  */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ap_is_HTTP_CLIENT_ERROR</name><parameter_list>(<param><type><name>x</name></type></param>)</parameter_list></cpp:macro> <cpp:value>(((x) &gt;= 400)&amp;&amp;((x) &lt; 500))</cpp:value></cpp:define>
<comment type="block">/** is the status code a server error  */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ap_is_HTTP_SERVER_ERROR</name><parameter_list>(<param><type><name>x</name></type></param>)</parameter_list></cpp:macro> <cpp:value>(((x) &gt;= 500)&amp;&amp;((x) &lt; 600))</cpp:value></cpp:define>
<comment type="block">/** is the status code a (potentially) valid response code?  */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ap_is_HTTP_VALID_RESPONSE</name><parameter_list>(<param><type><name>x</name></type></param>)</parameter_list></cpp:macro> <cpp:value>(((x) &gt;= 100)&amp;&amp;((x) &lt; 600))</cpp:value></cpp:define>

<comment type="block">/** should the status code drop the connection */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ap_status_drops_connection</name><parameter_list>(<param><type><name>x</name></type></param>)</parameter_list></cpp:macro> \
                                   <cpp:value>(((x) == HTTP_BAD_REQUEST)           || \
                                    ((x) == HTTP_REQUEST_TIME_OUT)      || \
                                    ((x) == HTTP_LENGTH_REQUIRED)       || \
                                    ((x) == HTTP_REQUEST_ENTITY_TOO_LARGE) || \
                                    ((x) == HTTP_REQUEST_URI_TOO_LARGE) || \
                                    ((x) == HTTP_INTERNAL_SERVER_ERROR) || \
                                    ((x) == HTTP_SERVICE_UNAVAILABLE) || \
                                    ((x) == HTTP_NOT_IMPLEMENTED))</cpp:value></cpp:define>
<comment type="block">/** @} */</comment>

<comment type="block">/**
 * @defgroup Methods List of Methods recognized by the server
 * @ingroup APACHE_CORE_DAEMON
 * @{
 *
 * @brief Methods recognized (but not necessarily handled) by the server.
 *
 * These constants are used in bit shifting masks of size int, so it is
 * unsafe to have more methods than bits in an int.  HEAD == M_GET.
 * This list must be tracked by the list in http_protocol.c in routine
 * ap_method_name_of().
 *
 */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>M_GET</name></cpp:macro>                   <cpp:value>0</cpp:value></cpp:define>       <comment type="block">/** RFC 2616: HTTP */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>M_PUT</name></cpp:macro>                   <cpp:value>1</cpp:value></cpp:define>       <comment type="block">/*  :             */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>M_POST</name></cpp:macro>                  <cpp:value>2</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>M_DELETE</name></cpp:macro>                <cpp:value>3</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>M_CONNECT</name></cpp:macro>               <cpp:value>4</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>M_OPTIONS</name></cpp:macro>               <cpp:value>5</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>M_TRACE</name></cpp:macro>                 <cpp:value>6</cpp:value></cpp:define>       <comment type="block">/** RFC 2616: HTTP */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>M_PATCH</name></cpp:macro>                 <cpp:value>7</cpp:value></cpp:define>       <comment type="block">/** no rfc(!)  ### remove this one? */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>M_PROPFIND</name></cpp:macro>              <cpp:value>8</cpp:value></cpp:define>       <comment type="block">/** RFC 2518: WebDAV */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>M_PROPPATCH</name></cpp:macro>             <cpp:value>9</cpp:value></cpp:define>       <comment type="block">/*  :               */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>M_MKCOL</name></cpp:macro>                 <cpp:value>10</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>M_COPY</name></cpp:macro>                  <cpp:value>11</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>M_MOVE</name></cpp:macro>                  <cpp:value>12</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>M_LOCK</name></cpp:macro>                  <cpp:value>13</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>M_UNLOCK</name></cpp:macro>                <cpp:value>14</cpp:value></cpp:define>      <comment type="block">/** RFC 2518: WebDAV */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>M_VERSION_CONTROL</name></cpp:macro>       <cpp:value>15</cpp:value></cpp:define>      <comment type="block">/** RFC 3253: WebDAV Versioning */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>M_CHECKOUT</name></cpp:macro>              <cpp:value>16</cpp:value></cpp:define>      <comment type="block">/*  :                          */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>M_UNCHECKOUT</name></cpp:macro>            <cpp:value>17</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>M_CHECKIN</name></cpp:macro>               <cpp:value>18</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>M_UPDATE</name></cpp:macro>                <cpp:value>19</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>M_LABEL</name></cpp:macro>                 <cpp:value>20</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>M_REPORT</name></cpp:macro>                <cpp:value>21</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>M_MKWORKSPACE</name></cpp:macro>           <cpp:value>22</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>M_MKACTIVITY</name></cpp:macro>            <cpp:value>23</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>M_BASELINE_CONTROL</name></cpp:macro>      <cpp:value>24</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>M_MERGE</name></cpp:macro>                 <cpp:value>25</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>M_INVALID</name></cpp:macro>               <cpp:value>26</cpp:value></cpp:define>      <comment type="block">/** no valid method */</comment>

<comment type="block">/**
 * METHODS needs to be equal to the number of bits
 * we are using for limit masks.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>METHODS</name></cpp:macro>     <cpp:value>64</cpp:value></cpp:define>

<comment type="block">/**
 * The method mask bit to shift for anding with a bitmask.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AP_METHOD_BIT</name></cpp:macro> <cpp:value>((apr_int64_t)1)</cpp:value></cpp:define>
<comment type="block">/** @} */</comment>


<comment type="block">/** @see ap_method_list_t */</comment>
<typedef>typedef <type>struct <name>ap_method_list_t</name></type> <name>ap_method_list_t</name>;</typedef>

<comment type="block">/**
 * @struct ap_method_list_t
 * @brief  Structure for handling HTTP methods.
 *
 * Methods known to the server are accessed via a bitmask shortcut;
 * extension methods are handled by an array.
 */</comment>
<struct>struct <name>ap_method_list_t</name> <block>{
    <comment type="block">/** The bitmask used for known methods */</comment>
    <decl_stmt><decl><type><name>apr_int64_t</name></type> <name>method_mask</name></decl>;</decl_stmt>
    <comment type="block">/** the array used for extension methods */</comment>
    <decl_stmt><decl><type><name>apr_array_header_t</name> *</type><name>method_list</name></decl>;</decl_stmt>
}</block>;</struct>

<comment type="block">/**
 * @defgroup module_magic Module Magic mime types
 * @{
 */</comment>
<comment type="block">/** Magic for mod_cgi[d] */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CGI_MAGIC_TYPE</name></cpp:macro> <cpp:value>"application/x-httpd-cgi"</cpp:value></cpp:define>
<comment type="block">/** Magic for mod_include */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INCLUDES_MAGIC_TYPE</name></cpp:macro> <cpp:value>"text/x-server-parsed-html"</cpp:value></cpp:define>
<comment type="block">/** Magic for mod_include */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INCLUDES_MAGIC_TYPE3</name></cpp:macro> <cpp:value>"text/x-server-parsed-html3"</cpp:value></cpp:define>
<comment type="block">/** Magic for mod_dir */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DIR_MAGIC_TYPE</name></cpp:macro> <cpp:value>"httpd/unix-directory"</cpp:value></cpp:define>
<comment type="block">/** Default for r-&gt;handler if no content-type set by type_checker */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AP_DEFAULT_HANDLER_NAME</name></cpp:macro> <cpp:value>""</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AP_IS_DEFAULT_HANDLER_NAME</name><parameter_list>(<param><type><name>x</name></type></param>)</parameter_list></cpp:macro> <cpp:value>(*x == '\0')</cpp:value></cpp:define>

<comment type="block">/** @} */</comment>
<comment type="block">/* Just in case your linefeed isn't the one the other end is expecting. */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<name>APR_CHARSET_EBCDIC</name></expr></cpp:if>
<comment type="block">/** linefeed */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LF</name></cpp:macro> <cpp:value>10</cpp:value></cpp:define>
<comment type="block">/** carrige return */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CR</name></cpp:macro> <cpp:value>13</cpp:value></cpp:define>
<comment type="block">/** carrige return /Line Feed Combo */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CRLF</name></cpp:macro> <cpp:value>"\015\012"</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else> <comment type="block">/* APR_CHARSET_EBCDIC */</comment>
<comment type="block">/* For platforms using the EBCDIC charset, the transition ASCII-&gt;EBCDIC is done
 * in the buff package (bread/bputs/bwrite).  Everywhere else, we use
 * "native EBCDIC" CR and NL characters. These are therefore
 * defined as
 * '\r' and '\n'.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CR</name></cpp:macro> <cpp:value>'\r'</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LF</name></cpp:macro> <cpp:value>'\n'</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CRLF</name></cpp:macro> <cpp:value>"\r\n"</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* APR_CHARSET_EBCDIC */</comment>
<comment type="block">/** Useful for common code with either platform charset. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CRLF_ASCII</name></cpp:macro> <cpp:value>"\015\012"</cpp:value></cpp:define>

<comment type="block">/**
 * @defgroup values_request_rec_body Possible values for request_rec.read_body
 * @{
 * Possible values for request_rec.read_body (set by handling module):
 */</comment>

<comment type="block">/** Send 413 error if message has any body */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>REQUEST_NO_BODY</name></cpp:macro>          <cpp:value>0</cpp:value></cpp:define>
<comment type="block">/** Send 411 error if body without Content-Length */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>REQUEST_CHUNKED_ERROR</name></cpp:macro>    <cpp:value>1</cpp:value></cpp:define>
<comment type="block">/** If chunked, remove the chunks for me. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>REQUEST_CHUNKED_DECHUNK</name></cpp:macro>  <cpp:value>2</cpp:value></cpp:define>
<comment type="block">/** @} // values_request_rec_body */</comment>

<comment type="block">/**
 * @defgroup values_request_rec_used_path_info Possible values for request_rec.used_path_info
 * @ingroup APACHE_CORE_DAEMON
 * @{
 * Possible values for request_rec.used_path_info:
 */</comment>

<comment type="block">/** Accept the path_info from the request */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AP_REQ_ACCEPT_PATH_INFO</name></cpp:macro>    <cpp:value>0</cpp:value></cpp:define>
<comment type="block">/** Return a 404 error if path_info was given */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AP_REQ_REJECT_PATH_INFO</name></cpp:macro>    <cpp:value>1</cpp:value></cpp:define>
<comment type="block">/** Module may chose to use the given path_info */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AP_REQ_DEFAULT_PATH_INFO</name></cpp:macro>   <cpp:value>2</cpp:value></cpp:define>

<comment type="block">/** @} // values_request_rec_used_path_info */</comment>


<comment type="block">/*
 * Things which may vary per file-lookup WITHIN a request ---
 * e.g., state of MIME config.  Basically, the name of an object, info
 * about the object, and any other info we may ahve which may need to
 * change as we go poking around looking for it (e.g., overridden by
 * .htaccess files).
 *
 * Note how the default state of almost all these things is properly
 * zero, so that allocating it with pcalloc does the right thing without
 * a whole lot of hairy initialization... so long as we are willing to
 * make the (fairly) portable assumption that the bit pattern of a NULL
 * pointer is, in fact, zero.
 */</comment>

<comment type="block">/**
 * @brief This represents the result of calling htaccess; these are cached for
 * each request.
 */</comment>
<struct>struct <name>htaccess_result</name> <block>{
    <comment type="block">/** the directory to which this applies */</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>dir</name></decl>;</decl_stmt>
    <comment type="block">/** the overrides allowed for the .htaccess file */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>override</name></decl>;</decl_stmt>
    <comment type="block">/** the override options allowed for the .htaccess file */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>override_opts</name></decl>;</decl_stmt>
    <comment type="block">/** Table of allowed directives for override */</comment>
    <decl_stmt><decl><type><name>apr_table_t</name> *</type><name>override_list</name></decl>;</decl_stmt>
    <comment type="block">/** the configuration directives */</comment>
    <decl_stmt><decl><type>struct <name>ap_conf_vector_t</name> *</type><name>htaccess</name></decl>;</decl_stmt>
    <comment type="block">/** the next one, or NULL if no more; N.B. never change this */</comment>
    <decl_stmt><decl><type><specifier>const</specifier> struct <name>htaccess_result</name> *</type><name>next</name></decl>;</decl_stmt>
}</block>;</struct>

<comment type="block">/* The following four types define a hierarchy of activities, so that
 * given a request_rec r you can write r-&gt;connection-&gt;server-&gt;process
 * to get to the process_rec.  While this reduces substantially the
 * number of arguments that various hooks require beware that in
 * threaded versions of the server you must consider multiplexing
 * issues.  */</comment>


<comment type="block">/** A structure that represents one process */</comment>
<typedef>typedef <type>struct <name>process_rec</name></type> <name>process_rec</name>;</typedef>
<comment type="block">/** A structure that represents a virtual server */</comment>
<typedef>typedef <type>struct <name>server_rec</name></type> <name>server_rec</name>;</typedef>
<comment type="block">/** A structure that represents one connection */</comment>
<typedef>typedef <type>struct <name>conn_rec</name></type> <name>conn_rec</name>;</typedef>
<comment type="block">/** A structure that represents the current request */</comment>
<typedef>typedef <type>struct <name>request_rec</name></type> <name>request_rec</name>;</typedef>
<comment type="block">/** A structure that represents the status of the current connection */</comment>
<typedef>typedef <type>struct <name>conn_state_t</name></type> <name>conn_state_t</name>;</typedef>

<comment type="block">/* ### would be nice to not include this from httpd.h ... */</comment>
<comment type="block">/* This comes after we have defined the request_rec type */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"apr_uri.h"</cpp:file></cpp:include>

<comment type="block">/**
 * @brief A structure that represents one process
 */</comment>
<struct>struct <name>process_rec</name> <block>{
    <comment type="block">/** Global pool. Cleared upon normal exit */</comment>
    <decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl>;</decl_stmt>
    <comment type="block">/** Configuration pool. Cleared upon restart */</comment>
    <decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>pconf</name></decl>;</decl_stmt>
    <comment type="block">/** The program name used to execute the program */</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>short_name</name></decl>;</decl_stmt>
    <comment type="block">/** The command line arguments */</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> * <specifier>const</specifier> *</type><name>argv</name></decl>;</decl_stmt>
    <comment type="block">/** Number of command line arguments passed to the program */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>argc</name></decl>;</decl_stmt>
}</block>;</struct>

<comment type="block">/**
 * @brief A structure that represents the current request
 */</comment>
<struct>struct <name>request_rec</name> <block>{
    <comment type="block">/** The pool associated with the request */</comment>
    <decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl>;</decl_stmt>
    <comment type="block">/** The connection to the client */</comment>
    <decl_stmt><decl><type><name>conn_rec</name> *</type><name>connection</name></decl>;</decl_stmt>
    <comment type="block">/** The virtual host for this request */</comment>
    <decl_stmt><decl><type><name>server_rec</name> *</type><name>server</name></decl>;</decl_stmt>

    <comment type="block">/** Pointer to the redirected request if this is an external redirect */</comment>
    <decl_stmt><decl><type><name>request_rec</name> *</type><name>next</name></decl>;</decl_stmt>
    <comment type="block">/** Pointer to the previous request if this is an internal redirect */</comment>
    <decl_stmt><decl><type><name>request_rec</name> *</type><name>prev</name></decl>;</decl_stmt>

    <comment type="block">/** Pointer to the main request if this is a sub-request
     * (see http_request.h) */</comment>
    <decl_stmt><decl><type><name>request_rec</name> *</type>main</decl>;</decl_stmt>

    <comment type="block">/* Info about the request itself... we begin with stuff that only
     * protocol.c should ever touch...
     */</comment>
    <comment type="block">/** First line of request */</comment>
    <decl_stmt><decl><type><name>char</name> *</type><name>the_request</name></decl>;</decl_stmt>
    <comment type="block">/** HTTP/0.9, "simple" request (e.g. GET /foo\n w/no headers) */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>assbackwards</name></decl>;</decl_stmt>
    <comment type="block">/** A proxy request (calculated during post_read_request/translate_name)
     *  possible values PROXYREQ_NONE, PROXYREQ_PROXY, PROXYREQ_REVERSE,
     *                  PROXYREQ_RESPONSE
     */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>proxyreq</name></decl>;</decl_stmt>
    <comment type="block">/** HEAD request, as opposed to GET */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>header_only</name></decl>;</decl_stmt>
    <comment type="block">/** Protocol version number of protocol; 1.1 = 1001 */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>proto_num</name></decl>;</decl_stmt>
    <comment type="block">/** Protocol string, as given to us, or HTTP/0.9 */</comment>
    <decl_stmt><decl><type><name>char</name> *</type><name>protocol</name></decl>;</decl_stmt>
    <comment type="block">/** Host, as set by full URI or Host: */</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>hostname</name></decl>;</decl_stmt>

    <comment type="block">/** Time when the request started */</comment>
    <decl_stmt><decl><type><name>apr_time_t</name></type> <name>request_time</name></decl>;</decl_stmt>

    <comment type="block">/** Status line, if set by script */</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>status_line</name></decl>;</decl_stmt>
    <comment type="block">/** Status line */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>status</name></decl>;</decl_stmt>

    <comment type="block">/* Request method, two ways; also, protocol, etc..  Outside of protocol.c,
     * look, but don't touch.
     */</comment>

    <comment type="block">/** M_GET, M_POST, etc. */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>method_number</name></decl>;</decl_stmt>
    <comment type="block">/** Request method (eg. GET, HEAD, POST, etc.) */</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>method</name></decl>;</decl_stmt>

    <comment type="block">/**
     *  'allowed' is a bitvector of the allowed methods.
     *
     *  A handler must ensure that the request method is one that
     *  it is capable of handling.  Generally modules should DECLINE
     *  any request methods they do not handle.  Prior to aborting the
     *  handler like this the handler should set r-&gt;allowed to the list
     *  of methods that it is willing to handle.  This bitvector is used
     *  to construct the "Allow:" header required for OPTIONS requests,
     *  and HTTP_METHOD_NOT_ALLOWED and HTTP_NOT_IMPLEMENTED status codes.
     *
     *  Since the default_handler deals with OPTIONS, all modules can
     *  usually decline to deal with OPTIONS.  TRACE is always allowed,
     *  modules don't need to set it explicitly.
     *
     *  Since the default_handler will always handle a GET, a
     *  module which does *not* implement GET should probably return
     *  HTTP_METHOD_NOT_ALLOWED.  Unfortunately this means that a Script GET
     *  handler can't be installed by mod_actions.
     */</comment>
    <decl_stmt><decl><type><name>apr_int64_t</name></type> <name>allowed</name></decl>;</decl_stmt>
    <comment type="block">/** Array of extension methods */</comment>
    <decl_stmt><decl><type><name>apr_array_header_t</name> *</type><name>allowed_xmethods</name></decl>;</decl_stmt>
    <comment type="block">/** List of allowed methods */</comment>
    <decl_stmt><decl><type><name>ap_method_list_t</name> *</type><name>allowed_methods</name></decl>;</decl_stmt>

    <comment type="block">/** byte count in stream is for body */</comment>
    <decl_stmt><decl><type><name>apr_off_t</name></type> <name>sent_bodyct</name></decl>;</decl_stmt>
    <comment type="block">/** body byte count, for easy access */</comment>
    <decl_stmt><decl><type><name>apr_off_t</name></type> <name>bytes_sent</name></decl>;</decl_stmt>
    <comment type="block">/** Last modified time of the requested resource */</comment>
    <decl_stmt><decl><type><name>apr_time_t</name></type> <name>mtime</name></decl>;</decl_stmt>

    <comment type="block">/* HTTP/1.1 connection-level features */</comment>

    <comment type="block">/** The Range: header */</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>range</name></decl>;</decl_stmt>
    <comment type="block">/** The "real" content length */</comment>
    <decl_stmt><decl><type><name>apr_off_t</name></type> <name>clength</name></decl>;</decl_stmt>
    <comment type="block">/** sending chunked transfer-coding */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>chunked</name></decl>;</decl_stmt>

    <comment type="block">/** Method for reading the request body
     * (eg. REQUEST_CHUNKED_ERROR, REQUEST_NO_BODY,
     *  REQUEST_CHUNKED_DECHUNK, etc...) */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>read_body</name></decl>;</decl_stmt>
    <comment type="block">/** reading chunked transfer-coding */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>read_chunked</name></decl>;</decl_stmt>
    <comment type="block">/** is client waiting for a 100 response? */</comment>
    <decl_stmt><decl><type><name>unsigned</name></type> <name>expecting_100</name></decl>;</decl_stmt>
    <comment type="block">/** The optional kept body of the request. */</comment>
    <decl_stmt><decl><type><name>apr_bucket_brigade</name> *</type><name>kept_body</name></decl>;</decl_stmt>
    <comment type="block">/** For ap_body_to_table(): parsed body */</comment>
    <comment type="block">/* XXX: ap_body_to_table has been removed. Remove body_table too or
     * XXX: keep it to reintroduce ap_body_to_table without major bump? */</comment>
    <decl_stmt><decl><type><name>apr_table_t</name> *</type><name>body_table</name></decl>;</decl_stmt>
    <comment type="block">/** Remaining bytes left to read from the request body */</comment>
    <decl_stmt><decl><type><name>apr_off_t</name></type> <name>remaining</name></decl>;</decl_stmt>
    <comment type="block">/** Number of bytes that have been read  from the request body */</comment>
    <decl_stmt><decl><type><name>apr_off_t</name></type> <name>read_length</name></decl>;</decl_stmt>

    <comment type="block">/* MIME header environments, in and out.  Also, an array containing
     * environment variables to be passed to subprocesses, so people can
     * write modules to add to that environment.
     *
     * The difference between headers_out and err_headers_out is that the
     * latter are printed even on error, and persist across internal redirects
     * (so the headers printed for ErrorDocument handlers will have them).
     *
     * The 'notes' apr_table_t is for notes from one module to another, with no
     * other set purpose in mind...
     */</comment>

    <comment type="block">/** MIME header environment from the request */</comment>
    <decl_stmt><decl><type><name>apr_table_t</name> *</type><name>headers_in</name></decl>;</decl_stmt>
    <comment type="block">/** MIME header environment for the response */</comment>
    <decl_stmt><decl><type><name>apr_table_t</name> *</type><name>headers_out</name></decl>;</decl_stmt>
    <comment type="block">/** MIME header environment for the response, printed even on errors and
     * persist across internal redirects */</comment>
    <decl_stmt><decl><type><name>apr_table_t</name> *</type><name>err_headers_out</name></decl>;</decl_stmt>
    <comment type="block">/** Array of environment variables to be used for sub processes */</comment>
    <decl_stmt><decl><type><name>apr_table_t</name> *</type><name>subprocess_env</name></decl>;</decl_stmt>
    <comment type="block">/** Notes from one module to another */</comment>
    <decl_stmt><decl><type><name>apr_table_t</name> *</type><name>notes</name></decl>;</decl_stmt>

    <comment type="block">/* content_type, handler, content_encoding, and all content_languages
     * MUST be lowercased strings.  They may be pointers to static strings;
     * they should not be modified in place.
     */</comment>
    <comment type="block">/** The content-type for the current request */</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>content_type</name></decl>;</decl_stmt>   <comment type="block">/* Break these out --- we dispatch on 'em */</comment>
    <comment type="block">/** The handler string that we use to call a handler function */</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>handler</name></decl>;</decl_stmt>        <comment type="block">/* What we *really* dispatch on */</comment>

    <comment type="block">/** How to encode the data */</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>content_encoding</name></decl>;</decl_stmt>
    <comment type="block">/** Array of strings representing the content languages */</comment>
    <decl_stmt><decl><type><name>apr_array_header_t</name> *</type><name>content_languages</name></decl>;</decl_stmt>

    <comment type="block">/** variant list validator (if negotiated) */</comment>
    <decl_stmt><decl><type><name>char</name> *</type><name>vlist_validator</name></decl>;</decl_stmt>

    <comment type="block">/** If an authentication check was made, this gets set to the user name. */</comment>
    <decl_stmt><decl><type><name>char</name> *</type><name>user</name></decl>;</decl_stmt>
    <comment type="block">/** If an authentication check was made, this gets set to the auth type. */</comment>
    <decl_stmt><decl><type><name>char</name> *</type><name>ap_auth_type</name></decl>;</decl_stmt>

    <comment type="block">/* What object is being requested (either directly, or via include
     * or content-negotiation mapping).
     */</comment>

    <comment type="block">/** The URI without any parsing performed */</comment>
    <decl_stmt><decl><type><name>char</name> *</type><name>unparsed_uri</name></decl>;</decl_stmt>
    <comment type="block">/** The path portion of the URI, or "/" if no path provided */</comment>
    <decl_stmt><decl><type><name>char</name> *</type><name>uri</name></decl>;</decl_stmt>
    <comment type="block">/** The filename on disk corresponding to this response */</comment>
    <decl_stmt><decl><type><name>char</name> *</type><name>filename</name></decl>;</decl_stmt>
    <comment type="block">/** The true filename stored in the filesystem, as in the true alpha case
     *  and alias correction, e.g. "Image.jpeg" not "IMAGE$1.JPE" on Windows.
     *  The core map_to_storage canonicalizes r-&gt;filename when they mismatch */</comment>
    <decl_stmt><decl><type><name>char</name> *</type><name>canonical_filename</name></decl>;</decl_stmt>
    <comment type="block">/** The PATH_INFO extracted from this request */</comment>
    <decl_stmt><decl><type><name>char</name> *</type><name>path_info</name></decl>;</decl_stmt>
    <comment type="block">/** The QUERY_ARGS extracted from this request */</comment>
    <decl_stmt><decl><type><name>char</name> *</type><name>args</name></decl>;</decl_stmt>

    <comment type="block">/**
     * Flag for the handler to accept or reject path_info on
     * the current request.  All modules should respect the
     * AP_REQ_ACCEPT_PATH_INFO and AP_REQ_REJECT_PATH_INFO
     * values, while AP_REQ_DEFAULT_PATH_INFO indicates they
     * may follow existing conventions.  This is set to the
     * user's preference upon HOOK_VERY_FIRST of the fixups.
     */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>used_path_info</name></decl>;</decl_stmt>

    <comment type="block">/** A flag to determine if the eos bucket has been sent yet */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>eos_sent</name></decl>;</decl_stmt>

    <comment type="block">/* Various other config info which may change with .htaccess files
     * These are config vectors, with one void* pointer for each module
     * (the thing pointed to being the module's business).
     */</comment>

    <comment type="block">/** Options set in config files, etc. */</comment>
    <decl_stmt><decl><type>struct <name>ap_conf_vector_t</name> *</type><name>per_dir_config</name></decl>;</decl_stmt>
    <comment type="block">/** Notes on *this* request */</comment>
    <decl_stmt><decl><type>struct <name>ap_conf_vector_t</name> *</type><name>request_config</name></decl>;</decl_stmt>

    <comment type="block">/** Optional request log level configuration. Will usually point
     *  to a server or per_dir config, i.e. must be copied before
     *  modifying */</comment>
    <decl_stmt><decl><type><specifier>const</specifier> struct <name>ap_logconf</name> *</type><name>log</name></decl>;</decl_stmt>

    <comment type="block">/** Id to identify request in access and error log. Set when the first
     *  error log entry for this request is generated.
     */</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>log_id</name></decl>;</decl_stmt>

    <comment type="block">/**
     * A linked list of the .htaccess configuration directives
     * accessed by this request.
     * N.B. always add to the head of the list, _never_ to the end.
     * that way, a sub request's list can (temporarily) point to a parent's list
     */</comment>
    <decl_stmt><decl><type><specifier>const</specifier> struct <name>htaccess_result</name> *</type><name>htaccess</name></decl>;</decl_stmt>

    <comment type="block">/** A list of output filters to be used for this request */</comment>
    <decl_stmt><decl><type>struct <name>ap_filter_t</name> *</type><name>output_filters</name></decl>;</decl_stmt>
    <comment type="block">/** A list of input filters to be used for this request */</comment>
    <decl_stmt><decl><type>struct <name>ap_filter_t</name> *</type><name>input_filters</name></decl>;</decl_stmt>

    <comment type="block">/** A list of protocol level output filters to be used for this
     *  request */</comment>
    <decl_stmt><decl><type>struct <name>ap_filter_t</name> *</type><name>proto_output_filters</name></decl>;</decl_stmt>
    <comment type="block">/** A list of protocol level input filters to be used for this
     *  request */</comment>
    <decl_stmt><decl><type>struct <name>ap_filter_t</name> *</type><name>proto_input_filters</name></decl>;</decl_stmt>

    <comment type="block">/** This response can not be cached */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>no_cache</name></decl>;</decl_stmt>
    <comment type="block">/** There is no local copy of this response */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>no_local_copy</name></decl>;</decl_stmt>

    <comment type="block">/** Mutex protect callbacks registered with ap_mpm_register_timed_callback
     * from being run before the original handler finishes running
     */</comment>
    <decl_stmt><decl><type><name>apr_thread_mutex_t</name> *</type><name>invoke_mtx</name></decl>;</decl_stmt>

    <comment type="block">/** A struct containing the components of URI */</comment>
    <decl_stmt><decl><type><name>apr_uri_t</name></type> <name>parsed_uri</name></decl>;</decl_stmt>
    <comment type="block">/**  finfo.protection (st_mode) set to zero if no such file */</comment>
    <decl_stmt><decl><type><name>apr_finfo_t</name></type> <name>finfo</name></decl>;</decl_stmt>

    <comment type="block">/** remote address information from conn_rec, can be overridden if
     * necessary by a module.
     * This is the address that originated the request.
     */</comment>
    <decl_stmt><decl><type><name>apr_sockaddr_t</name> *</type><name>useragent_addr</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> *</type><name>useragent_ip</name></decl>;</decl_stmt>

    <comment type="block">/** MIME trailer environment from the request */</comment>
    <decl_stmt><decl><type><name>apr_table_t</name> *</type><name>trailers_in</name></decl>;</decl_stmt>
    <comment type="block">/** MIME trailer environment from the response */</comment>
    <decl_stmt><decl><type><name>apr_table_t</name> *</type><name>trailers_out</name></decl>;</decl_stmt>

    <comment type="block">/** Originator's DNS name, if known.  NULL if DNS hasn't been checked,
     *  "" if it has and no address was found.  N.B. Only access this though
     *  ap_get_useragent_host() */</comment>
    <decl_stmt><decl><type><name>char</name> *</type><name>useragent_host</name></decl>;</decl_stmt>
    <comment type="block">/** have we done double-reverse DNS? -1 yes/failure, 0 not yet,
     *  1 yes/success
     */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>double_reverse</name></decl>;</decl_stmt>
}</block>;</struct>

<comment type="block">/**
 * @defgroup ProxyReq Proxy request types
 *
 * Possible values of request_rec-&gt;proxyreq. A request could be normal,
 *  proxied or reverse proxied. Normally proxied and reverse proxied are
 *  grouped together as just "proxied", but sometimes it's necessary to
 *  tell the difference between the two, such as for authentication.
 * @{
 */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PROXYREQ_NONE</name></cpp:macro>     <cpp:value>0</cpp:value></cpp:define>     <comment type="block">/**&lt; No proxy */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PROXYREQ_PROXY</name></cpp:macro>    <cpp:value>1</cpp:value></cpp:define>     <comment type="block">/**&lt; Standard proxy */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PROXYREQ_REVERSE</name></cpp:macro>  <cpp:value>2</cpp:value></cpp:define>     <comment type="block">/**&lt; Reverse proxy */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PROXYREQ_RESPONSE</name></cpp:macro> <cpp:value>3</cpp:value></cpp:define>     <comment type="block">/**&lt; Origin response */</comment>

<comment type="block">/* @} */</comment>

<comment type="block">/**
 * @brief Enumeration of connection keepalive options
 */</comment>
<typedef>typedef <type><enum>enum <block>{
    <decl><name>AP_CONN_UNKNOWN</name></decl>,
    <decl><name>AP_CONN_CLOSE</name></decl>,
    <decl><name>AP_CONN_KEEPALIVE</name></decl>
}</block></enum></type> <name>ap_conn_keepalive_e</name>;</typedef>

<comment type="block">/**
 * @brief Structure to store things which are per connection
 */</comment>
<struct>struct <name>conn_rec</name> <block>{
    <comment type="block">/** Pool associated with this connection */</comment>
    <decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl>;</decl_stmt>
    <comment type="block">/** Physical vhost this conn came in on */</comment>
    <decl_stmt><decl><type><name>server_rec</name> *</type><name>base_server</name></decl>;</decl_stmt>
    <comment type="block">/** used by http_vhost.c */</comment>
    <decl_stmt><decl><type><name>void</name> *</type><name>vhost_lookup_data</name></decl>;</decl_stmt>

    <comment type="block">/* Information about the connection itself */</comment>
    <comment type="block">/** local address */</comment>
    <decl_stmt><decl><type><name>apr_sockaddr_t</name> *</type><name>local_addr</name></decl>;</decl_stmt>
    <comment type="block">/** remote address; this is the end-point of the next hop, for the address
     *  of the request creator, see useragent_addr in request_rec
     */</comment>
    <decl_stmt><decl><type><name>apr_sockaddr_t</name> *</type><name>client_addr</name></decl>;</decl_stmt>

    <comment type="block">/** Client's IP address; this is the end-point of the next hop, for the
     *  IP of the request creator, see useragent_ip in request_rec
     */</comment>
    <decl_stmt><decl><type><name>char</name> *</type><name>client_ip</name></decl>;</decl_stmt>
    <comment type="block">/** Client's DNS name, if known.  NULL if DNS hasn't been checked,
     *  "" if it has and no address was found.  N.B. Only access this though
     * get_remote_host() */</comment>
    <decl_stmt><decl><type><name>char</name> *</type><name>remote_host</name></decl>;</decl_stmt>
    <comment type="block">/** Only ever set if doing rfc1413 lookups.  N.B. Only access this through
     *  get_remote_logname() */</comment>
    <decl_stmt><decl><type><name>char</name> *</type><name>remote_logname</name></decl>;</decl_stmt>

    <comment type="block">/** server IP address */</comment>
    <decl_stmt><decl><type><name>char</name> *</type><name>local_ip</name></decl>;</decl_stmt>
    <comment type="block">/** used for ap_get_server_name when UseCanonicalName is set to DNS
     *  (ignores setting of HostnameLookups) */</comment>
    <decl_stmt><decl><type><name>char</name> *</type><name>local_host</name></decl>;</decl_stmt>

    <comment type="block">/** ID of this connection; unique at any point in time */</comment>
    <decl_stmt><decl><type><name>long</name></type> <name>id</name></decl>;</decl_stmt>
    <comment type="block">/** Config vector containing pointers to connections per-server
     *  config structures. */</comment>
    <decl_stmt><decl><type>struct <name>ap_conf_vector_t</name> *</type><name>conn_config</name></decl>;</decl_stmt>
    <comment type="block">/** Notes on *this* connection: send note from one module to
     *  another. must remain valid for all requests on this conn */</comment>
    <decl_stmt><decl><type><name>apr_table_t</name> *</type><name>notes</name></decl>;</decl_stmt>
    <comment type="block">/** A list of input filters to be used for this connection */</comment>
    <decl_stmt><decl><type>struct <name>ap_filter_t</name> *</type><name>input_filters</name></decl>;</decl_stmt>
    <comment type="block">/** A list of output filters to be used for this connection */</comment>
    <decl_stmt><decl><type>struct <name>ap_filter_t</name> *</type><name>output_filters</name></decl>;</decl_stmt>
    <comment type="block">/** handle to scoreboard information for this connection */</comment>
    <decl_stmt><decl><type><name>void</name> *</type><name>sbh</name></decl>;</decl_stmt>
    <comment type="block">/** The bucket allocator to use for all bucket/brigade creations */</comment>
    <decl_stmt><decl><type>struct <name>apr_bucket_alloc_t</name> *</type><name>bucket_alloc</name></decl>;</decl_stmt>
    <comment type="block">/** The current state of this connection; may be NULL if not used by MPM */</comment>
    <decl_stmt><decl><type><name>conn_state_t</name> *</type><name>cs</name></decl>;</decl_stmt>
    <comment type="block">/** Is there data pending in the input filters? */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>data_in_input_filters</name></decl>;</decl_stmt>
    <comment type="block">/** Is there data pending in the output filters? */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>data_in_output_filters</name></decl>;</decl_stmt>

    <comment type="block">/** Are there any filters that clogg/buffer the input stream, breaking
     *  the event mpm.
     */</comment>
    <expr_stmt><expr><name>unsigned</name> <name>int</name> <name>clogging_input_filters</name>:1</expr>;</expr_stmt>

    <comment type="block">/** have we done double-reverse DNS? -1 yes/failure, 0 not yet,
     *  1 yes/success */</comment>
    <expr_stmt><expr><name>signed</name> <name>int</name> <name>double_reverse</name>:2</expr>;</expr_stmt>

    <comment type="block">/** Are we still talking? */</comment>
    <decl_stmt><decl><type><name>unsigned</name></type> <name>aborted</name></decl>;</decl_stmt>

    <comment type="block">/** Are we going to keep the connection alive for another request?
     * @see ap_conn_keepalive_e */</comment>
    <decl_stmt><decl><type><name>ap_conn_keepalive_e</name></type> <name>keepalive</name></decl>;</decl_stmt>

    <comment type="block">/** How many times have we used it? */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>keepalives</name></decl>;</decl_stmt>

    <comment type="block">/** Optional connection log level configuration. May point to a server or
     *  per_dir config, i.e. must be copied before modifying */</comment>
    <decl_stmt><decl><type><specifier>const</specifier> struct <name>ap_logconf</name> *</type><name>log</name></decl>;</decl_stmt>

    <comment type="block">/** Id to identify this connection in error log. Set when the first
     *  error log entry for this connection is generated.
     */</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>log_id</name></decl>;</decl_stmt>


    <comment type="block">/** This points to the current thread being used to process this request,
     * over the lifetime of a request, the value may change. Users of the connection
     * record should not rely upon it staying the same between calls that involve
     * the MPM.
     */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>APR_HAS_THREADS</name></expr></cpp:if>
    <decl_stmt><decl><type><name>apr_thread_t</name> *</type><name>current_thread</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/** The "real" master connection. NULL if I am the master. */</comment>
    <decl_stmt><decl><type><name>conn_rec</name> *</type><name>master</name></decl>;</decl_stmt>
}</block>;</struct>

<comment type="block">/**
 * Enumeration of connection states
 * The two states CONN_STATE_LINGER_NORMAL and CONN_STATE_LINGER_SHORT may
 * only be set by the MPM. Use CONN_STATE_LINGER outside of the MPM.
 */</comment>
<typedef>typedef <type><enum>enum  <block>{
    <decl><name>CONN_STATE_CHECK_REQUEST_LINE_READABLE</name></decl>,
    <decl><name>CONN_STATE_READ_REQUEST_LINE</name></decl>,
    <decl><name>CONN_STATE_HANDLER</name></decl>,
    <decl><name>CONN_STATE_WRITE_COMPLETION</name></decl>,
    <decl><name>CONN_STATE_SUSPENDED</name></decl>,
    <decl><name>CONN_STATE_LINGER</name></decl>,          <comment type="block">/* connection may be closed with lingering */</comment>
    <decl><name>CONN_STATE_LINGER_NORMAL</name></decl>,   <comment type="block">/* MPM has started lingering close with normal timeout */</comment>
    <decl><name>CONN_STATE_LINGER_SHORT</name></decl>     <comment type="block">/* MPM has started lingering close with short timeout */</comment>
}</block></enum></type> <name>conn_state_e</name>;</typedef>

<typedef>typedef <type><enum>enum  <block>{
    <decl><name>CONN_SENSE_DEFAULT</name></decl>,
    <decl><name>CONN_SENSE_WANT_READ</name></decl>,       <comment type="block">/* next event must be read */</comment>
    <decl><name>CONN_SENSE_WANT_WRITE</name></decl>       <comment type="block">/* next event must be write */</comment>
}</block></enum></type> <name>conn_sense_e</name>;</typedef>

<comment type="block">/**
 * @brief A structure to contain connection state information
 */</comment>
<struct>struct <name>conn_state_t</name> <block>{
    <comment type="block">/** Current state of the connection */</comment>
    <decl_stmt><decl><type><name>conn_state_e</name></type> <name>state</name></decl>;</decl_stmt>
    <comment type="block">/** Whether to read instead of write, or write instead of read */</comment>
    <decl_stmt><decl><type><name>conn_sense_e</name></type> <name>sense</name></decl>;</decl_stmt>
}</block>;</struct>

<comment type="block">/* Per-vhost config... */</comment>

<comment type="block">/**
 * The address 255.255.255.255, when used as a virtualhost address,
 * will become the "default" server when the ip doesn't match other vhosts.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DEFAULT_VHOST_ADDR</name></cpp:macro> <cpp:value>0xfffffffful</cpp:value></cpp:define>


<comment type="block">/**
 * @struct server_addr_rec
 * @brief  A structure to be used for Per-vhost config
 */</comment>
<typedef>typedef <type>struct <name>server_addr_rec</name></type> <name>server_addr_rec</name>;</typedef>
<struct>struct <name>server_addr_rec</name> <block>{
    <comment type="block">/** The next server in the list */</comment>
    <decl_stmt><decl><type><name>server_addr_rec</name> *</type><name>next</name></decl>;</decl_stmt>
    <comment type="block">/** The name given in "&lt;VirtualHost&gt;" */</comment>
    <decl_stmt><decl><type><name>char</name> *</type><name>virthost</name></decl>;</decl_stmt>
    <comment type="block">/** The bound address, for this server */</comment>
    <decl_stmt><decl><type><name>apr_sockaddr_t</name> *</type><name>host_addr</name></decl>;</decl_stmt>
    <comment type="block">/** The bound port, for this server */</comment>
    <decl_stmt><decl><type><name>apr_port_t</name></type> <name>host_port</name></decl>;</decl_stmt>
}</block>;</struct>

<struct>struct <name>ap_logconf</name> <block>{
    <comment type="block">/** The per-module log levels */</comment>
    <decl_stmt><decl><type><name>signed</name> <name>char</name> *</type><name>module_levels</name></decl>;</decl_stmt>

    <comment type="block">/** The log level for this server */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>level</name></decl>;</decl_stmt>
}</block>;</struct>
<comment type="block">/**
 * @brief A structure to store information for each virtual server
 */</comment>
<struct>struct <name>server_rec</name> <block>{
    <comment type="block">/** The process this server is running in */</comment>
    <decl_stmt><decl><type><name>process_rec</name> *</type><name>process</name></decl>;</decl_stmt>
    <comment type="block">/** The next server in the list */</comment>
    <decl_stmt><decl><type><name>server_rec</name> *</type><name>next</name></decl>;</decl_stmt>

    <comment type="block">/* Log files --- note that transfer log is now in the modules... */</comment>

    <comment type="block">/** The name of the error log */</comment>
    <decl_stmt><decl><type><name>char</name> *</type><name>error_fname</name></decl>;</decl_stmt>
    <comment type="block">/** A file descriptor that references the error log */</comment>
    <decl_stmt><decl><type><name>apr_file_t</name> *</type><name>error_log</name></decl>;</decl_stmt>
    <comment type="block">/** The log level configuration */</comment>
    <decl_stmt><decl><type>struct <name>ap_logconf</name></type> <name>log</name></decl>;</decl_stmt>

    <comment type="block">/* Module-specific configuration for server, and defaults... */</comment>

    <comment type="block">/** Config vector containing pointers to modules' per-server config
     *  structures. */</comment>
    <decl_stmt><decl><type>struct <name>ap_conf_vector_t</name> *</type><name>module_config</name></decl>;</decl_stmt>
    <comment type="block">/** MIME type info, etc., before we start checking per-directory info */</comment>
    <decl_stmt><decl><type>struct <name>ap_conf_vector_t</name> *</type><name>lookup_defaults</name></decl>;</decl_stmt>

    <comment type="block">/** The name of the server */</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>defn_name</name></decl>;</decl_stmt>
    <comment type="block">/** The line of the config file that the server was defined on */</comment>
    <decl_stmt><decl><type><name>unsigned</name></type> <name>defn_line_number</name></decl>;</decl_stmt>
    <comment type="block">/** true if this is the virtual server */</comment>
    <decl_stmt><decl><type><name>char</name></type> <name>is_virtual</name></decl>;</decl_stmt>


    <comment type="block">/* Information for redirects */</comment>

    <comment type="block">/** for redirects, etc. */</comment>
    <decl_stmt><decl><type><name>apr_port_t</name></type> <name>port</name></decl>;</decl_stmt>
    <comment type="block">/** The server request scheme for redirect responses */</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>server_scheme</name></decl>;</decl_stmt>

    <comment type="block">/* Contact information */</comment>

    <comment type="block">/** The admin's contact information */</comment>
    <decl_stmt><decl><type><name>char</name> *</type><name>server_admin</name></decl>;</decl_stmt>
    <comment type="block">/** The server hostname */</comment>
    <decl_stmt><decl><type><name>char</name> *</type><name>server_hostname</name></decl>;</decl_stmt>

    <comment type="block">/* Transaction handling */</comment>

    <comment type="block">/** I haven't got a clue */</comment>
    <decl_stmt><decl><type><name>server_addr_rec</name> *</type><name>addrs</name></decl>;</decl_stmt>
    <comment type="block">/** Timeout, as an apr interval, before we give up */</comment>
    <decl_stmt><decl><type><name>apr_interval_time_t</name></type> <name>timeout</name></decl>;</decl_stmt>
    <comment type="block">/** The apr interval we will wait for another request */</comment>
    <decl_stmt><decl><type><name>apr_interval_time_t</name></type> <name>keep_alive_timeout</name></decl>;</decl_stmt>
    <comment type="block">/** Maximum requests per connection */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>keep_alive_max</name></decl>;</decl_stmt>
    <comment type="block">/** Use persistent connections? */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>keep_alive</name></decl>;</decl_stmt>

    <comment type="block">/** Normal names for ServerAlias servers */</comment>
    <decl_stmt><decl><type><name>apr_array_header_t</name> *</type><name>names</name></decl>;</decl_stmt>
    <comment type="block">/** Wildcarded names for ServerAlias servers */</comment>
    <decl_stmt><decl><type><name>apr_array_header_t</name> *</type><name>wild_names</name></decl>;</decl_stmt>

    <comment type="block">/** Pathname for ServerPath */</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl>;</decl_stmt>
    <comment type="block">/** Length of path */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>pathlen</name></decl>;</decl_stmt>

    <comment type="block">/** limit on size of the HTTP request line    */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>limit_req_line</name></decl>;</decl_stmt>
    <comment type="block">/** limit on size of any request header field */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>limit_req_fieldsize</name></decl>;</decl_stmt>
    <comment type="block">/** limit on number of request header fields  */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>limit_req_fields</name></decl>;</decl_stmt>

    <comment type="block">/** Opaque storage location */</comment>
    <decl_stmt><decl><type><name>void</name> *</type><name>context</name></decl>;</decl_stmt>

    <comment type="block">/** Whether the keepalive timeout is explicit (1) or
     *  inherited (0) from the base server (either first
     *  server on the same IP:port or main server) */</comment>
    <expr_stmt><expr><name>unsigned</name> <name>int</name> <name>keep_alive_timeout_set</name>:1</expr>;</expr_stmt>
}</block>;</struct>

<comment type="block">/**
 * @struct ap_sload_t
 * @brief  A structure to hold server load params
 */</comment>
<typedef>typedef <type>struct <name>ap_sload_t</name></type> <name>ap_sload_t</name>;</typedef>
<struct>struct <name>ap_sload_t</name> <block>{
    <comment type="block">/* percentage of process/threads ready/idle (0-&gt;100)*/</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>idle</name></decl>;</decl_stmt>
    <comment type="block">/* percentage of process/threads busy (0-&gt;100) */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>busy</name></decl>;</decl_stmt>
    <comment type="block">/* total bytes served */</comment>
    <decl_stmt><decl><type><name>apr_off_t</name></type> <name>bytes_served</name></decl>;</decl_stmt>
    <comment type="block">/* total access count */</comment>
    <decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>access_count</name></decl>;</decl_stmt>
}</block>;</struct>

<comment type="block">/**
 * @struct ap_loadavg_t
 * @brief  A structure to hold various server loadavg
 */</comment>
<typedef>typedef <type>struct <name>ap_loadavg_t</name></type> <name>ap_loadavg_t</name>;</typedef>
<struct>struct <name>ap_loadavg_t</name> <block>{
    <comment type="block">/* current loadavg, ala getloadavg() */</comment>
    <decl_stmt><decl><type><name>float</name></type> <name>loadavg</name></decl>;</decl_stmt>
    <comment type="block">/* 5 min loadavg */</comment>
    <decl_stmt><decl><type><name>float</name></type> <name>loadavg5</name></decl>;</decl_stmt>
    <comment type="block">/* 15 min loadavg */</comment>
    <decl_stmt><decl><type><name>float</name></type> <name>loadavg15</name></decl>;</decl_stmt>
}</block>;</struct>

<comment type="block">/**
 * Get the context_document_root for a request. This is a generalization of
 * the document root, which is too limited in the presence of mappers like
 * mod_userdir and mod_alias. The context_document_root is the directory
 * on disk that maps to the context_prefix URI prefix.
 * @param r The request
 * @note For resources that do not map to the file system or for very complex
 * mappings, this information may still be wrong.
 */</comment>
<macro><name>AP_DECLARE</name><argument_list>(<argument>const char *</argument>)</argument_list></macro> <expr_stmt><expr><call><name>ap_context_document_root</name><argument_list>(<argument><expr><name>request_rec</name> *<name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/**
 * Get the context_prefix for a request. The context_prefix URI prefix
 * maps to the context_document_root on disk.
 * @param r The request
 */</comment>
<macro><name>AP_DECLARE</name><argument_list>(<argument>const char *</argument>)</argument_list></macro> <expr_stmt><expr><call><name>ap_context_prefix</name><argument_list>(<argument><expr><name>request_rec</name> *<name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/** Set context_prefix and context_document_root for a request.
 * @param r The request
 * @param prefix the URI prefix, without trailing slash
 * @param document_root the corresponding directory on disk, without trailing
 * slash
 * @note If one of prefix of document_root is NULL, the corrsponding
 * property will not be changed.
 */</comment>
<macro><name>AP_DECLARE</name><argument_list>(<argument>void</argument>)</argument_list></macro> <expr_stmt><expr><call><name>ap_set_context_info</name><argument_list>(<argument><expr><name>request_rec</name> *<name>r</name></expr></argument>, <argument><expr>const <name>char</name> *<name>prefix</name></expr></argument>,
                                     <argument><expr>const <name>char</name> *<name>document_root</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/** Set per-request document root. This is for mass virtual hosting modules
 * that want to provide the correct DOCUMENT_ROOT value to scripts.
 * @param r The request
 * @param document_root the document root for the request.
 */</comment>
<macro><name>AP_DECLARE</name><argument_list>(<argument>void</argument>)</argument_list></macro> <expr_stmt><expr><call><name>ap_set_document_root</name><argument_list>(<argument><expr><name>request_rec</name> *<name>r</name></expr></argument>, <argument><expr>const <name>char</name> *<name>document_root</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/**
 * Examine a field value (such as a media-/content-type) string and return
 * it sans any parameters; e.g., strip off any ';charset=foo' and the like.
 * @param p Pool to allocate memory from
 * @param intype The field to examine
 * @return A copy of the field minus any parameters
 */</comment>
<macro><name>AP_DECLARE</name><argument_list>(<argument>char *</argument>)</argument_list></macro> <expr_stmt><expr><call><name>ap_field_noparam</name><argument_list>(<argument><expr><name>apr_pool_t</name> *<name>p</name></expr></argument>, <argument><expr>const <name>char</name> *<name>intype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/**
 * Convert a time from an integer into a string in a specified format
 * @param p The pool to allocate memory from
 * @param t The time to convert
 * @param fmt The format to use for the conversion
 * @param gmt Convert the time for GMT?
 * @return The string that represents the specified time
 */</comment>
<macro><name>AP_DECLARE</name><argument_list>(<argument>char *</argument>)</argument_list></macro> <macro><name>ap_ht_time</name><argument_list>(<argument>apr_pool_t *p</argument>, <argument>apr_time_t t</argument>, <argument>const char *fmt</argument>, <argument>int gmt</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

<comment type="block">/* String handling. The *_nc variants allow you to use non-const char **s as
   arguments (unfortunately C won't automatically convert a char ** to a const
   char **) */</comment>

<comment type="block">/**
 * Get the characters until the first occurrence of a specified character
 * @param p The pool to allocate memory from
 * @param line The string to get the characters from
 * @param stop The character to stop at
 * @return A copy of the characters up to the first stop character
 */</comment>
<macro><name>AP_DECLARE</name><argument_list>(<argument>char *</argument>)</argument_list></macro> <macro><name>ap_getword</name><argument_list>(<argument>apr_pool_t *p</argument>, <argument>const char **line</argument>, <argument>char stop</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

<comment type="block">/**
 * Get the characters until the first occurrence of a specified character
 * @param p The pool to allocate memory from
 * @param line The string to get the characters from
 * @param stop The character to stop at
 * @return A copy of the characters up to the first stop character
 * @note This is the same as ap_getword(), except it doesn't use const char **.
 */</comment>
<macro><name>AP_DECLARE</name><argument_list>(<argument>char *</argument>)</argument_list></macro> <macro><name>ap_getword_nc</name><argument_list>(<argument>apr_pool_t *p</argument>, <argument>char **line</argument>, <argument>char stop</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

<comment type="block">/**
 * Get the first word from a given string.  A word is defined as all characters
 * up to the first whitespace.
 * @param p The pool to allocate memory from
 * @param line The string to traverse
 * @return The first word in the line
 */</comment>
<macro><name>AP_DECLARE</name><argument_list>(<argument>char *</argument>)</argument_list></macro> <expr_stmt><expr><call><name>ap_getword_white</name><argument_list>(<argument><expr><name>apr_pool_t</name> *<name>p</name></expr></argument>, <argument><expr>const <name>char</name> **<name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/**
 * Get the first word from a given string.  A word is defined as all characters
 * up to the first whitespace.
 * @param p The pool to allocate memory from
 * @param line The string to traverse
 * @return The first word in the line
 * @note The same as ap_getword_white(), except it doesn't use const char**
 */</comment>
<macro><name>AP_DECLARE</name><argument_list>(<argument>char *</argument>)</argument_list></macro> <expr_stmt><expr><call><name>ap_getword_white_nc</name><argument_list>(<argument><expr><name>apr_pool_t</name> *<name>p</name></expr></argument>, <argument><expr><name>char</name> **<name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/**
 * Get all characters from the first occurrence of @a stop to the first "\0"
 * @param p The pool to allocate memory from
 * @param line The line to traverse
 * @param stop The character to start at
 * @return A copy of all characters after the first occurrence of the specified
 *         character
 */</comment>
<macro><name>AP_DECLARE</name><argument_list>(<argument>char *</argument>)</argument_list></macro> <macro><name>ap_getword_nulls</name><argument_list>(<argument>apr_pool_t *p</argument>, <argument>const char **line</argument>,
                                    <argument>char stop</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

<comment type="block">/**
 * Get all characters from the first occurrence of @a stop to the first "\0"
 * @param p The pool to allocate memory from
 * @param line The line to traverse
 * @param stop The character to start at
 * @return A copy of all characters after the first occurrence of the specified
 *         character
 * @note The same as ap_getword_nulls(), except it doesn't use const char **.
 */</comment>
<macro><name>AP_DECLARE</name><argument_list>(<argument>char *</argument>)</argument_list></macro> <macro><name>ap_getword_nulls_nc</name><argument_list>(<argument>apr_pool_t *p</argument>, <argument>char **line</argument>, <argument>char stop</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

<comment type="block">/**
 * Get the second word in the string paying attention to quoting
 * @param p The pool to allocate from
 * @param line The line to traverse
 * @return A copy of the string
 */</comment>
<macro><name>AP_DECLARE</name><argument_list>(<argument>char *</argument>)</argument_list></macro> <expr_stmt><expr><call><name>ap_getword_conf</name><argument_list>(<argument><expr><name>apr_pool_t</name> *<name>p</name></expr></argument>, <argument><expr>const <name>char</name> **<name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/**
 * Get the second word in the string paying attention to quoting
 * @param p The pool to allocate from
 * @param line The line to traverse
 * @return A copy of the string
 * @note The same as ap_getword_conf(), except it doesn't use const char **.
 */</comment>
<macro><name>AP_DECLARE</name><argument_list>(<argument>char *</argument>)</argument_list></macro> <expr_stmt><expr><call><name>ap_getword_conf_nc</name><argument_list>(<argument><expr><name>apr_pool_t</name> *<name>p</name></expr></argument>, <argument><expr><name>char</name> **<name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/**
 * Get the second word in the string paying attention to quoting,
 * with {...} supported as well as "..." and '...'
 * @param p The pool to allocate from
 * @param line The line to traverse
 * @return A copy of the string
 */</comment>
<macro><name>AP_DECLARE</name><argument_list>(<argument>char *</argument>)</argument_list></macro> <expr_stmt><expr><call><name>ap_getword_conf2</name><argument_list>(<argument><expr><name>apr_pool_t</name> *<name>p</name></expr></argument>, <argument><expr>const <name>char</name> **<name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/**
 * Get the second word in the string paying attention to quoting,
 * with {...} supported as well as "..." and '...'
 * @param p The pool to allocate from
 * @param line The line to traverse
 * @return A copy of the string
 * @note The same as ap_getword_conf2(), except it doesn't use const char **.
 */</comment>
<macro><name>AP_DECLARE</name><argument_list>(<argument>char *</argument>)</argument_list></macro> <expr_stmt><expr><call><name>ap_getword_conf2_nc</name><argument_list>(<argument><expr><name>apr_pool_t</name> *<name>p</name></expr></argument>, <argument><expr><name>char</name> **<name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/**
 * Check a string for any config define or environment variable construct
 * and replace each of them by the value of that variable, if it exists.
 * The default syntax of the constructs is ${ENV} but can be changed by
 * setting the define::* config defines. If the variable does not exist,
 * leave the ${ENV} construct alone but print a warning.
 * @param p The pool to allocate from
 * @param word The string to check
 * @return The string with the replaced environment variables
 */</comment>
<macro><name>AP_DECLARE</name><argument_list>(<argument>const char *</argument>)</argument_list></macro> <expr_stmt><expr><call><name>ap_resolve_env</name><argument_list>(<argument><expr><name>apr_pool_t</name> *<name>p</name></expr></argument>, <argument><expr>const <name>char</name> * <name>word</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/**
 * Size an HTTP header field list item, as separated by a comma.
 * @param field The field to size
 * @param len The length of the field
 * @return The return value is a pointer to the beginning of the non-empty
 * list item within the original string (or NULL if there is none) and the
 * address of field is shifted to the next non-comma, non-whitespace
 * character.  len is the length of the item excluding any beginning whitespace.
 */</comment>
<macro><name>AP_DECLARE</name><argument_list>(<argument>const char *</argument>)</argument_list></macro> <expr_stmt><expr><call><name>ap_size_list_item</name><argument_list>(<argument><expr>const <name>char</name> **<name>field</name></expr></argument>, <argument><expr><name>int</name> *<name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/**
 * Retrieve an HTTP header field list item, as separated by a comma,
 * while stripping insignificant whitespace and lowercasing anything not in
 * a quoted string or comment.
 * @param p The pool to allocate from
 * @param field The field to retrieve
 * @return The return value is a new string containing the converted list
 *         item (or NULL if none) and the address pointed to by field is
 *         shifted to the next non-comma, non-whitespace.
 */</comment>
<macro><name>AP_DECLARE</name><argument_list>(<argument>char *</argument>)</argument_list></macro> <expr_stmt><expr><call><name>ap_get_list_item</name><argument_list>(<argument><expr><name>apr_pool_t</name> *<name>p</name></expr></argument>, <argument><expr>const <name>char</name> **<name>field</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/**
 * Find an item in canonical form (lowercase, no extra spaces) within
 * an HTTP field value list.
 * @param p The pool to allocate from
 * @param line The field value list to search
 * @param tok The token to search for
 * @return 1 if found, 0 if not found.
 */</comment>
<macro><name>AP_DECLARE</name><argument_list>(<argument>int</argument>)</argument_list></macro> <expr_stmt><expr><call><name>ap_find_list_item</name><argument_list>(<argument><expr><name>apr_pool_t</name> *<name>p</name></expr></argument>, <argument><expr>const <name>char</name> *<name>line</name></expr></argument>, <argument><expr>const <name>char</name> *<name>tok</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/**
 * Do a weak ETag comparison within an HTTP field value list.
 * @param p The pool to allocate from
 * @param line The field value list to search
 * @param tok The token to search for
 * @return 1 if found, 0 if not found.
 */</comment>
<macro><name>AP_DECLARE</name><argument_list>(<argument>int</argument>)</argument_list></macro> <expr_stmt><expr><call><name>ap_find_etag_weak</name><argument_list>(<argument><expr><name>apr_pool_t</name> *<name>p</name></expr></argument>, <argument><expr>const <name>char</name> *<name>line</name></expr></argument>, <argument><expr>const <name>char</name> *<name>tok</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/**
 * Do a strong ETag comparison within an HTTP field value list.
 * @param p The pool to allocate from
 * @param line The field value list to search
 * @param tok The token to search for
 * @return 1 if found, 0 if not found.
 */</comment>
<macro><name>AP_DECLARE</name><argument_list>(<argument>int</argument>)</argument_list></macro> <expr_stmt><expr><call><name>ap_find_etag_strong</name><argument_list>(<argument><expr><name>apr_pool_t</name> *<name>p</name></expr></argument>, <argument><expr>const <name>char</name> *<name>line</name></expr></argument>, <argument><expr>const <name>char</name> *<name>tok</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/* Scan a string for field content chars, as defined by RFC7230 section 3.2
 * including VCHAR/obs-text, as well as HT and SP
 * @param ptr The string to scan
 * @return A pointer to the first (non-HT) ASCII ctrl character.
 * @note lws and trailing whitespace are scanned, the caller is responsible
 * for trimming leading and trailing whitespace
 */</comment>
<macro><name>AP_DECLARE</name><argument_list>(<argument>const char *</argument>)</argument_list></macro> <expr_stmt><expr><call><name>ap_scan_http_field_content</name><argument_list>(<argument><expr>const <name>char</name> *<name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/* Scan a string for token characters, as defined by RFC7230 section 3.2.6 
 * @param ptr The string to scan
 * @return A pointer to the first non-token character.
 */</comment>
<macro><name>AP_DECLARE</name><argument_list>(<argument>const char *</argument>)</argument_list></macro> <expr_stmt><expr><call><name>ap_scan_http_token</name><argument_list>(<argument><expr>const <name>char</name> *<name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/* Scan a string for visible ASCII (0x21-0x7E) or obstext (0x80+)
 * and return a pointer to the first SP/CTL/NUL character encountered.
 * @param ptr The string to scan
 * @return A pointer to the first SP/CTL character.
 */</comment>
<macro><name>AP_DECLARE</name><argument_list>(<argument>const char *</argument>)</argument_list></macro> <expr_stmt><expr><call><name>ap_scan_vchar_obstext</name><argument_list>(<argument><expr>const <name>char</name> *<name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/**
 * Retrieve an array of tokens in the format "1#token" defined in RFC2616. Only
 * accepts ',' as a delimiter, does not accept quoted strings, and errors on
 * any separator.
 * @param p The pool to allocate from
 * @param tok The line to read tokens from
 * @param tokens Pointer to an array of tokens. If not NULL, must be an array
 *    of char*, otherwise it will be allocated on @a p when a token is found
 * @param skip_invalid If true, when an invalid separator is encountered, it
 *    will be ignored.
 * @return NULL on success, an error string otherwise.
 * @remark *tokens may be NULL on output if NULL in input and no token is found
 */</comment>
<macro><name>AP_DECLARE</name><argument_list>(<argument>const char *</argument>)</argument_list></macro> <macro><name>ap_parse_token_list_strict</name><argument_list>(<argument>apr_pool_t *p</argument>, <argument>const char *tok</argument>,
                                                    <argument>apr_array_header_t **tokens</argument>,
                                                    <argument>int skip_invalid</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

<comment type="block">/**
 * Retrieve a token, spacing over it and adjusting the pointer to
 * the first non-white byte afterwards.  Note that these tokens
 * are delimited by semis and commas and can also be delimited
 * by whitespace at the caller's option.
 * @param p The pool to allocate from
 * @param accept_line The line to retrieve the token from (adjusted afterwards)
 * @param accept_white Is it delimited by whitespace
 * @return the token
 */</comment>
<macro><name>AP_DECLARE</name><argument_list>(<argument>char *</argument>)</argument_list></macro> <macro><name>ap_get_token</name><argument_list>(<argument>apr_pool_t *p</argument>, <argument>const char **accept_line</argument>, <argument>int accept_white</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

<comment type="block">/**
 * Find http tokens, see the definition of token from RFC2068
 * @param p The pool to allocate from
 * @param line The line to find the token
 * @param tok The token to find
 * @return 1 if the token is found, 0 otherwise
 */</comment>
<macro><name>AP_DECLARE</name><argument_list>(<argument>int</argument>)</argument_list></macro> <expr_stmt><expr><call><name>ap_find_token</name><argument_list>(<argument><expr><name>apr_pool_t</name> *<name>p</name></expr></argument>, <argument><expr>const <name>char</name> *<name>line</name></expr></argument>, <argument><expr>const <name>char</name> *<name>tok</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/**
 * find http tokens from the end of the line
 * @param p The pool to allocate from
 * @param line The line to find the token
 * @param tok The token to find
 * @return 1 if the token is found, 0 otherwise
 */</comment>
<macro><name>AP_DECLARE</name><argument_list>(<argument>int</argument>)</argument_list></macro> <expr_stmt><expr><call><name>ap_find_last_token</name><argument_list>(<argument><expr><name>apr_pool_t</name> *<name>p</name></expr></argument>, <argument><expr>const <name>char</name> *<name>line</name></expr></argument>, <argument><expr>const <name>char</name> *<name>tok</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/**
 * Check for an Absolute URI syntax
 * @param u The string to check
 * @return 1 if URI, 0 otherwise
 */</comment>
<macro><name>AP_DECLARE</name><argument_list>(<argument>int</argument>)</argument_list></macro> <expr_stmt><expr><call><name>ap_is_url</name><argument_list>(<argument><expr>const <name>char</name> *<name>u</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/**
 * Unescape a string
 * @param url The string to unescape
 * @return 0 on success, non-zero otherwise
 */</comment>
<macro><name>AP_DECLARE</name><argument_list>(<argument>int</argument>)</argument_list></macro> <expr_stmt><expr><call><name>ap_unescape_all</name><argument_list>(<argument><expr><name>char</name> *<name>url</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/**
 * Unescape a URL
 * @param url The url to unescape
 * @return 0 on success, non-zero otherwise
 */</comment>
<macro><name>AP_DECLARE</name><argument_list>(<argument>int</argument>)</argument_list></macro> <expr_stmt><expr><call><name>ap_unescape_url</name><argument_list>(<argument><expr><name>char</name> *<name>url</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/**
 * Unescape a URL, but leaving %2f (slashes) escaped
 * @param url The url to unescape
 * @param decode_slashes Whether or not slashes should be decoded
 * @return 0 on success, non-zero otherwise
 */</comment>
<macro><name>AP_DECLARE</name><argument_list>(<argument>int</argument>)</argument_list></macro> <macro><name>ap_unescape_url_keep2f</name><argument_list>(<argument>char *url</argument>, <argument>int decode_slashes</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

<comment type="block">/**
 * Unescape an application/x-www-form-urlencoded string
 * @param query The query to unescape
 * @return 0 on success, non-zero otherwise
 */</comment>
<macro><name>AP_DECLARE</name><argument_list>(<argument>int</argument>)</argument_list></macro> <expr_stmt><expr><call><name>ap_unescape_urlencoded</name><argument_list>(<argument><expr><name>char</name> *<name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/**
 * Convert all double slashes to single slashes
 * @param name The string to convert
 */</comment>
<macro><name>AP_DECLARE</name><argument_list>(<argument>void</argument>)</argument_list></macro> <expr_stmt><expr><call><name>ap_no2slash</name><argument_list>(<argument><expr><name>char</name> *<name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/**
 * Remove all ./ and xx/../ substrings from a file name. Also remove
 * any leading ../ or /../ substrings.
 * @param name the file name to parse
 */</comment>
<macro><name>AP_DECLARE</name><argument_list>(<argument>void</argument>)</argument_list></macro> <expr_stmt><expr><call><name>ap_getparents</name><argument_list>(<argument><expr><name>char</name> *<name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/**
 * Escape a path segment, as defined in RFC 1808
 * @param p The pool to allocate from
 * @param s The path to convert
 * @return The converted URL
 */</comment>
<macro><name>AP_DECLARE</name><argument_list>(<argument>char *</argument>)</argument_list></macro> <expr_stmt><expr><call><name>ap_escape_path_segment</name><argument_list>(<argument><expr><name>apr_pool_t</name> *<name>p</name></expr></argument>, <argument><expr>const <name>char</name> *<name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/**
 * Escape a path segment, as defined in RFC 1808, to a preallocated buffer.
 * @param c The preallocated buffer to write to
 * @param s The path to convert
 * @return The converted URL (c)
 */</comment>
<macro><name>AP_DECLARE</name><argument_list>(<argument>char *</argument>)</argument_list></macro> <expr_stmt><expr><call><name>ap_escape_path_segment_buffer</name><argument_list>(<argument><expr><name>char</name> *<name>c</name></expr></argument>, <argument><expr>const <name>char</name> *<name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/**
 * convert an OS path to a URL in an OS dependent way.
 * @param p The pool to allocate from
 * @param path The path to convert
 * @param partial if set, assume that the path will be appended to something
 *        with a '/' in it (and thus does not prefix "./")
 * @return The converted URL
 */</comment>
<macro><name>AP_DECLARE</name><argument_list>(<argument>char *</argument>)</argument_list></macro> <macro><name>ap_os_escape_path</name><argument_list>(<argument>apr_pool_t *p</argument>, <argument>const char *path</argument>, <argument>int partial</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

<comment type="block">/** @see ap_os_escape_path */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ap_escape_uri</name><parameter_list>(<param><type><name>ppool</name></type></param>,<param><type><name>path</name></type></param>)</parameter_list></cpp:macro> <cpp:value>ap_os_escape_path(ppool,path,1)</cpp:value></cpp:define>

<comment type="block">/**
 * Escape a string as application/x-www-form-urlencoded
 * @param p The pool to allocate from
 * @param s The path to convert
 * @return The converted URL
 */</comment>
<macro><name>AP_DECLARE</name><argument_list>(<argument>char *</argument>)</argument_list></macro> <expr_stmt><expr><call><name>ap_escape_urlencoded</name><argument_list>(<argument><expr><name>apr_pool_t</name> *<name>p</name></expr></argument>, <argument><expr>const <name>char</name> *<name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/**
 * Escape a string as application/x-www-form-urlencoded, to a preallocated buffer
 * @param c The preallocated buffer to write to
 * @param s The path to convert
 * @return The converted URL (c)
 */</comment>
<macro><name>AP_DECLARE</name><argument_list>(<argument>char *</argument>)</argument_list></macro> <expr_stmt><expr><call><name>ap_escape_urlencoded_buffer</name><argument_list>(<argument><expr><name>char</name> *<name>c</name></expr></argument>, <argument><expr>const <name>char</name> *<name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/**
 * Escape an html string
 * @param p The pool to allocate from
 * @param s The html to escape
 * @return The escaped string
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ap_escape_html</name><parameter_list>(<param><type><name>p</name></type></param>,<param><type><name>s</name></type></param>)</parameter_list></cpp:macro> <cpp:value>ap_escape_html2(p,s,0)</cpp:value></cpp:define>
<comment type="block">/**
 * Escape an html string
 * @param p The pool to allocate from
 * @param s The html to escape
 * @param toasc Whether to escape all non-ASCII chars to \&amp;\#nnn;
 * @return The escaped string
 */</comment>
<macro><name>AP_DECLARE</name><argument_list>(<argument>char *</argument>)</argument_list></macro> <macro><name>ap_escape_html2</name><argument_list>(<argument>apr_pool_t *p</argument>, <argument>const char *s</argument>, <argument>int toasc</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

<comment type="block">/**
 * Escape a string for logging
 * @param p The pool to allocate from
 * @param str The string to escape
 * @return The escaped string
 */</comment>
<macro><name>AP_DECLARE</name><argument_list>(<argument>char *</argument>)</argument_list></macro> <expr_stmt><expr><call><name>ap_escape_logitem</name><argument_list>(<argument><expr><name>apr_pool_t</name> *<name>p</name></expr></argument>, <argument><expr>const <name>char</name> *<name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/**
 * Escape a string for logging into the error log (without a pool)
 * @param dest The buffer to write to
 * @param source The string to escape
 * @param buflen The buffer size for the escaped string (including "\0")
 * @return The len of the escaped string (always &lt; maxlen)
 */</comment>
<macro><name>AP_DECLARE</name><argument_list>(<argument>apr_size_t</argument>)</argument_list></macro> <macro><name>ap_escape_errorlog_item</name><argument_list>(<argument>char *dest</argument>, <argument>const char *source</argument>,
                                               <argument>apr_size_t buflen</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

<comment type="block">/**
 * Construct a full hostname
 * @param p The pool to allocate from
 * @param hostname The hostname of the server
 * @param port The port the server is running on
 * @param r The current request
 * @return The server's hostname
 */</comment>
<macro><name>AP_DECLARE</name><argument_list>(<argument>char *</argument>)</argument_list></macro> <macro><name>ap_construct_server</name><argument_list>(<argument>apr_pool_t *p</argument>, <argument>const char *hostname</argument>,
                                    <argument>apr_port_t port</argument>, <argument>const request_rec *r</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

<comment type="block">/**
 * Escape a shell command
 * @param p The pool to allocate from
 * @param s The command to escape
 * @return The escaped shell command
 */</comment>
<macro><name>AP_DECLARE</name><argument_list>(<argument>char *</argument>)</argument_list></macro> <expr_stmt><expr><call><name>ap_escape_shell_cmd</name><argument_list>(<argument><expr><name>apr_pool_t</name> *<name>p</name></expr></argument>, <argument><expr>const <name>char</name> *<name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/**
 * Count the number of directories in a path
 * @param path The path to count
 * @return The number of directories
 */</comment>
<macro><name>AP_DECLARE</name><argument_list>(<argument>int</argument>)</argument_list></macro> <expr_stmt><expr><call><name>ap_count_dirs</name><argument_list>(<argument><expr>const <name>char</name> *<name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/**
 * Copy at most @a n leading directories of @a s into @a d. @a d
 * should be at least as large as @a s plus 1 extra byte
 *
 * @param d The location to copy to
 * @param s The location to copy from
 * @param n The number of directories to copy
 * @return value is the ever useful pointer to the trailing "\0" of d
 * @note on platforms with drive letters, n = 0 returns the "/" root,
 * whereas n = 1 returns the "d:/" root.  On all other platforms, n = 0
 * returns the empty string.  */</comment>
<macro><name>AP_DECLARE</name><argument_list>(<argument>char *</argument>)</argument_list></macro> <macro><name>ap_make_dirstr_prefix</name><argument_list>(<argument>char *d</argument>, <argument>const char *s</argument>, <argument>int n</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

<comment type="block">/**
 * Return the parent directory name (including trailing /) of the file
 * @a s
 * @param p The pool to allocate from
 * @param s The file to get the parent of
 * @return A copy of the file's parent directory
 */</comment>
<macro><name>AP_DECLARE</name><argument_list>(<argument>char *</argument>)</argument_list></macro> <expr_stmt><expr><call><name>ap_make_dirstr_parent</name><argument_list>(<argument><expr><name>apr_pool_t</name> *<name>p</name></expr></argument>, <argument><expr>const <name>char</name> *<name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/**
 * Given a directory and filename, create a single path from them.  This
 * function is smart enough to ensure that there is a single '/' between the
 * directory and file names
 * @param a The pool to allocate from
 * @param dir The directory name
 * @param f The filename
 * @return A copy of the full path
 * @note Never consider using this function if you are dealing with filesystem
 * names that need to remain canonical, unless you are merging an apr_dir_read
 * path and returned filename.  Otherwise, the result is not canonical.
 */</comment>
<macro><name>AP_DECLARE</name><argument_list>(<argument>char *</argument>)</argument_list></macro> <expr_stmt><expr><call><name>ap_make_full_path</name><argument_list>(<argument><expr><name>apr_pool_t</name> *<name>a</name></expr></argument>, <argument><expr>const <name>char</name> *<name>dir</name></expr></argument>, <argument><expr>const <name>char</name> *<name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/**
 * Test if the given path has an absolute path.
 * @param p The pool to allocate from
 * @param dir The directory name
 * @note The converse is not necessarily true, some OS's (Win32/OS2/Netware) have
 * multiple forms of absolute paths.  This only reports if the path is absolute
 * in a canonical sense.
 */</comment>
<macro><name>AP_DECLARE</name><argument_list>(<argument>int</argument>)</argument_list></macro> <expr_stmt><expr><call><name>ap_os_is_path_absolute</name><argument_list>(<argument><expr><name>apr_pool_t</name> *<name>p</name></expr></argument>, <argument><expr>const <name>char</name> *<name>dir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/**
 * Does the provided string contain wildcard characters?  This is useful
 * for determining if the string should be passed to strcmp_match or to strcmp.
 * The only wildcard characters recognized are '?' and '*'
 * @param str The string to check
 * @return 1 if the string has wildcards, 0 otherwise
 */</comment>
<macro><name>AP_DECLARE</name><argument_list>(<argument>int</argument>)</argument_list></macro> <expr_stmt><expr><call><name>ap_is_matchexp</name><argument_list>(<argument><expr>const <name>char</name> *<name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/**
 * Determine if a string matches a pattern containing the wildcards '?' or '*'
 * @param str The string to check
 * @param expected The pattern to match against
 * @return 0 if the two strings match, 1 otherwise
 */</comment>
<macro><name>AP_DECLARE</name><argument_list>(<argument>int</argument>)</argument_list></macro> <expr_stmt><expr><call><name>ap_strcmp_match</name><argument_list>(<argument><expr>const <name>char</name> *<name>str</name></expr></argument>, <argument><expr>const <name>char</name> *<name>expected</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/**
 * Determine if a string matches a pattern containing the wildcards '?' or '*',
 * ignoring case
 * @param str The string to check
 * @param expected The pattern to match against
 * @return 0 if the two strings match, 1 otherwise
 */</comment>
<macro><name>AP_DECLARE</name><argument_list>(<argument>int</argument>)</argument_list></macro> <expr_stmt><expr><call><name>ap_strcasecmp_match</name><argument_list>(<argument><expr>const <name>char</name> *<name>str</name></expr></argument>, <argument><expr>const <name>char</name> *<name>expected</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/**
 * Find the first occurrence of the substring s2 in s1, regardless of case
 * @param s1 The string to search
 * @param s2 The substring to search for
 * @return A pointer to the beginning of the substring
 * @remark See apr_strmatch() for a faster alternative
 */</comment>
<macro><name>AP_DECLARE</name><argument_list>(<argument>char *</argument>)</argument_list></macro> <expr_stmt><expr><call><name>ap_strcasestr</name><argument_list>(<argument><expr>const <name>char</name> *<name>s1</name></expr></argument>, <argument><expr>const <name>char</name> *<name>s2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/**
 * Return a pointer to the location inside of bigstring immediately after prefix
 * @param bigstring The input string
 * @param prefix The prefix to strip away
 * @return A pointer relative to bigstring after prefix
 */</comment>
<macro><name>AP_DECLARE</name><argument_list>(<argument>const char *</argument>)</argument_list></macro> <expr_stmt><expr><call><name>ap_stripprefix</name><argument_list>(<argument><expr>const <name>char</name> *<name>bigstring</name></expr></argument>,
                                        <argument><expr>const <name>char</name> *<name>prefix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/**
 * Decode a base64 encoded string into memory allocated from a pool
 * @param p The pool to allocate from
 * @param bufcoded The encoded string
 * @return The decoded string
 */</comment>
<macro><name>AP_DECLARE</name><argument_list>(<argument>char *</argument>)</argument_list></macro> <expr_stmt><expr><call><name>ap_pbase64decode</name><argument_list>(<argument><expr><name>apr_pool_t</name> *<name>p</name></expr></argument>, <argument><expr>const <name>char</name> *<name>bufcoded</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/**
 * Encode a string into memory allocated from a pool in base 64 format
 * @param p The pool to allocate from
 * @param string The plaintext string
 * @return The encoded string
 */</comment>
<macro><name>AP_DECLARE</name><argument_list>(<argument>char *</argument>)</argument_list></macro> <expr_stmt><expr><call><name>ap_pbase64encode</name><argument_list>(<argument><expr><name>apr_pool_t</name> *<name>p</name></expr></argument>, <argument><expr><name>char</name> *<name>string</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/**
 * Compile a regular expression to be used later. The regex is freed when
 * the pool is destroyed.
 * @param p The pool to allocate from
 * @param pattern the regular expression to compile
 * @param cflags The bitwise or of one or more of the following:
 *   @li REG_EXTENDED - Use POSIX extended Regular Expressions
 *   @li REG_ICASE    - Ignore case
 *   @li REG_NOSUB    - Support for substring addressing of matches
 *       not required
 *   @li REG_NEWLINE  - Match-any-character operators don't match new-line
 * @return The compiled regular expression
 */</comment>
<macro><name>AP_DECLARE</name><argument_list>(<argument>ap_regex_t *</argument>)</argument_list></macro> <macro><name>ap_pregcomp</name><argument_list>(<argument>apr_pool_t *p</argument>, <argument>const char *pattern</argument>,
                                     <argument>int cflags</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

<comment type="block">/**
 * Free the memory associated with a compiled regular expression
 * @param p The pool the regex was allocated from
 * @param reg The regular expression to free
 * @note This function is only necessary if the regex should be cleaned
 * up before the pool
 */</comment>
<macro><name>AP_DECLARE</name><argument_list>(<argument>void</argument>)</argument_list></macro> <expr_stmt><expr><call><name>ap_pregfree</name><argument_list>(<argument><expr><name>apr_pool_t</name> *<name>p</name></expr></argument>, <argument><expr><name>ap_regex_t</name> *<name>reg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/**
 * After performing a successful regex match, you may use this function to
 * perform a series of string substitutions based on subexpressions that were
 * matched during the call to ap_regexec. This function is limited to
 * result strings of 64K. Consider using ap_pregsub_ex() instead.
 * @param p The pool to allocate from
 * @param input An arbitrary string containing $1 through $9.  These are
 *              replaced with the corresponding matched sub-expressions
 * @param source The string that was originally matched to the regex
 * @param nmatch the nmatch returned from ap_pregex
 * @param pmatch the pmatch array returned from ap_pregex
 * @return The substituted string, or NULL on error
 */</comment>
<macro><name>AP_DECLARE</name><argument_list>(<argument>char *</argument>)</argument_list></macro> <macro><name>ap_pregsub</name><argument_list>(<argument>apr_pool_t *p</argument>, <argument>const char *input</argument>,
                              <argument>const char *source</argument>, <argument>apr_size_t nmatch</argument>,
                              <argument>ap_regmatch_t pmatch[]</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

<comment type="block">/**
 * After performing a successful regex match, you may use this function to
 * perform a series of string substitutions based on subexpressions that were
 * matched during the call to ap_regexec
 * @param p The pool to allocate from
 * @param result where to store the result, will be set to NULL on error
 * @param input An arbitrary string containing $1 through $9.  These are
 *              replaced with the corresponding matched sub-expressions
 * @param source The string that was originally matched to the regex
 * @param nmatch the nmatch returned from ap_pregex
 * @param pmatch the pmatch array returned from ap_pregex
 * @param maxlen the maximum string length to return, 0 for unlimited
 * @return APR_SUCCESS if successful, APR_ENOMEM or other error code otherwise.
 */</comment>
<macro><name>AP_DECLARE</name><argument_list>(<argument>apr_status_t</argument>)</argument_list></macro> <macro><name>ap_pregsub_ex</name><argument_list>(<argument>apr_pool_t *p</argument>, <argument>char **result</argument>,
                                       <argument>const char *input</argument>, <argument>const char *source</argument>,
                                       <argument>apr_size_t nmatch</argument>,
                                       <argument>ap_regmatch_t pmatch[]</argument>,
                                       <argument>apr_size_t maxlen</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

<comment type="block">/**
 * We want to downcase the type/subtype for comparison purposes
 * but nothing else because ;parameter=foo values are case sensitive.
 * @param s The content-type to convert to lowercase
 */</comment>
<macro><name>AP_DECLARE</name><argument_list>(<argument>void</argument>)</argument_list></macro> <expr_stmt><expr><call><name>ap_content_type_tolower</name><argument_list>(<argument><expr><name>char</name> *<name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/**
 * convert a string to all lowercase
 * @param s The string to convert to lowercase
 */</comment>
<macro><name>AP_DECLARE</name><argument_list>(<argument>void</argument>)</argument_list></macro> <expr_stmt><expr><call><name>ap_str_tolower</name><argument_list>(<argument><expr><name>char</name> *<name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/**
 * convert a string to all uppercase
 * @param s The string to convert to uppercase
 */</comment>
<macro><name>AP_DECLARE</name><argument_list>(<argument>void</argument>)</argument_list></macro> <expr_stmt><expr><call><name>ap_str_toupper</name><argument_list>(<argument><expr><name>char</name> *<name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/**
 * Search a string from left to right for the first occurrence of a
 * specific character
 * @param str The string to search
 * @param c The character to search for
 * @return The index of the first occurrence of c in str
 */</comment>
<macro><name>AP_DECLARE</name><argument_list>(<argument>int</argument>)</argument_list></macro> <macro><name>ap_ind</name><argument_list>(<argument>const char *str</argument>, <argument>char c</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>        <comment type="block">/* Sigh... */</comment>

<comment type="block">/**
 * Search a string from right to left for the first occurrence of a
 * specific character
 * @param str The string to search
 * @param c The character to search for
 * @return The index of the first occurrence of c in str
 */</comment>
<macro><name>AP_DECLARE</name><argument_list>(<argument>int</argument>)</argument_list></macro> <macro><name>ap_rind</name><argument_list>(<argument>const char *str</argument>, <argument>char c</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

<comment type="block">/**
 * Given a string, replace any bare &amp;quot; with \\&amp;quot; .
 * @param p The pool to allocate memory from
 * @param instring The string to search for &amp;quot;
 * @return A copy of the string with escaped quotes
 */</comment>
<macro><name>AP_DECLARE</name><argument_list>(<argument>char *</argument>)</argument_list></macro> <expr_stmt><expr><call><name>ap_escape_quotes</name><argument_list>(<argument><expr><name>apr_pool_t</name> *<name>p</name></expr></argument>, <argument><expr>const <name>char</name> *<name>instring</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/**
 * Given a string, append the PID deliminated by delim.
 * Usually used to create a pid-appended filepath name
 * (eg: /a/b/foo -&gt; /a/b/foo.6726). A function, and not
 * a macro, to avoid unistd.h dependency
 * @param p The pool to allocate memory from
 * @param string The string to append the PID to
 * @param delim The string to use to deliminate the string from the PID
 * @return A copy of the string with the PID appended
 */</comment>
<macro><name>AP_DECLARE</name><argument_list>(<argument>char *</argument>)</argument_list></macro> <expr_stmt><expr><call><name>ap_append_pid</name><argument_list>(<argument><expr><name>apr_pool_t</name> *<name>p</name></expr></argument>, <argument><expr>const <name>char</name> *<name>string</name></expr></argument>,
                                 <argument><expr>const <name>char</name> *<name>delim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/**
 * Parse a given timeout parameter string into an apr_interval_time_t value.
 * The unit of the time interval is given as postfix string to the numeric
 * string. Currently the following units are understood:
 *
 * ms    : milliseconds
 * s     : seconds
 * mi[n] : minutes
 * h     : hours
 *
 * If no unit is contained in the given timeout parameter the default_time_unit
 * will be used instead.
 * @param timeout_parameter The string containing the timeout parameter.
 * @param timeout The timeout value to be returned.
 * @param default_time_unit The default time unit to use if none is specified
 * in timeout_parameter.
 * @return Status value indicating whether the parsing was successful or not.
 */</comment>
<macro><name>AP_DECLARE</name><argument_list>(<argument>apr_status_t</argument>)</argument_list></macro> <expr_stmt><expr><call><name>ap_timeout_parameter_parse</name><argument_list>(
                                               <argument><expr>const <name>char</name> *<name>timeout_parameter</name></expr></argument>,
                                               <argument><expr><name>apr_interval_time_t</name> *<name>timeout</name></expr></argument>,
                                               <argument><expr>const <name>char</name> *<name>default_time_unit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/**
 * Determine if a request has a request body or not.
 *
 * @param r the request_rec of the request
 * @return truth value
 */</comment>
<macro><name>AP_DECLARE</name><argument_list>(<argument>int</argument>)</argument_list></macro> <expr_stmt><expr><call><name>ap_request_has_body</name><argument_list>(<argument><expr><name>request_rec</name> *<name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/**
 * Cleanup a string (mainly to be filesystem safe)
 * We only allow '_' and alphanumeric chars. Non-printable
 * map to 'x' and all others map to '_'
 *
 * @param  p pool to use to allocate dest
 * @param  src string to clean up
 * @param  dest cleaned up, allocated string
 * @return Status value indicating whether the cleaning was successful or not.
 */</comment>
<macro><name>AP_DECLARE</name><argument_list>(<argument>apr_status_t</argument>)</argument_list></macro> <expr_stmt><expr><call><name>ap_pstr2_alnum</name><argument_list>(<argument><expr><name>apr_pool_t</name> *<name>p</name></expr></argument>, <argument><expr>const <name>char</name> *<name>src</name></expr></argument>,
                                        <argument><expr>const <name>char</name> **<name>dest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/**
 * Cleanup a string (mainly to be filesystem safe)
 * We only allow '_' and alphanumeric chars. Non-printable
 * map to 'x' and all others map to '_'
 *
 * @param  src string to clean up
 * @param  dest cleaned up, pre-allocated string
 * @return Status value indicating whether the cleaning was successful or not.
 */</comment>
<macro><name>AP_DECLARE</name><argument_list>(<argument>apr_status_t</argument>)</argument_list></macro> <expr_stmt><expr><call><name>ap_str2_alnum</name><argument_list>(<argument><expr>const <name>char</name> *<name>src</name></expr></argument>, <argument><expr><name>char</name> *<name>dest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/**
 * Structure to store the contents of an HTTP form of the type
 * application/x-www-form-urlencoded.
 *
 * Currently it contains the name as a char* of maximum length
 * HUGE_STRING_LEN, and a value in the form of a bucket brigade
 * of arbitrary length.
 */</comment>
<typedef>typedef <type><struct>struct <block>{
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>name</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_bucket_brigade</name> *</type><name>value</name></decl>;</decl_stmt>
}</block></struct></type> <name>ap_form_pair_t</name>;</typedef>

<comment type="block">/**
 * Read the body and parse any form found, which must be of the
 * type application/x-www-form-urlencoded.
 * @param r request containing POSTed form data
 * @param f filter
 * @param ptr returned array of ap_form_pair_t
 * @param num max num of params or -1 for unlimited
 * @param size max size allowed for parsed data
 * @return OK or HTTP error
 */</comment>
<macro><name>AP_DECLARE</name><argument_list>(<argument>int</argument>)</argument_list></macro> <macro><name>ap_parse_form_data</name><argument_list>(<argument>request_rec *r</argument>, <argument>struct ap_filter_t *f</argument>,
                                   <argument>apr_array_header_t **ptr</argument>,
                                   <argument>apr_size_t num</argument>, <argument>apr_size_t size</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

<comment type="block">/* Misc system hackery */</comment>
<comment type="block">/**
 * Given the name of an object in the file system determine if it is a directory
 * @param p The pool to allocate from
 * @param name The name of the object to check
 * @return 1 if it is a directory, 0 otherwise
 */</comment>
<macro><name>AP_DECLARE</name><argument_list>(<argument>int</argument>)</argument_list></macro> <expr_stmt><expr><call><name>ap_is_rdirectory</name><argument_list>(<argument><expr><name>apr_pool_t</name> *<name>p</name></expr></argument>, <argument><expr>const <name>char</name> *<name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/**
 * Given the name of an object in the file system determine if it is a directory - this version is symlink aware
 * @param p The pool to allocate from
 * @param name The name of the object to check
 * @return 1 if it is a directory, 0 otherwise
 */</comment>
<macro><name>AP_DECLARE</name><argument_list>(<argument>int</argument>)</argument_list></macro> <expr_stmt><expr><call><name>ap_is_directory</name><argument_list>(<argument><expr><name>apr_pool_t</name> *<name>p</name></expr></argument>, <argument><expr>const <name>char</name> *<name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_OSD_POSIX</name></cpp:ifdef>
<function_decl><type><specifier>extern</specifier> <name>int</name></type> <name>os_init_job_environment</name><parameter_list>(<param><decl><type><name>server_rec</name> *</type><name>s</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>user_name</name></decl></param>, <param><decl><type><name>int</name></type> <name>one_process</name></decl></param>)</parameter_list>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* _OSD_POSIX */</comment>

<comment type="block">/**
 * Determine the local host name for the current machine
 * @param p The pool to allocate from
 * @return A copy of the local host name
 */</comment>
<function_decl><type><name>char</name> *</type><name>ap_get_local_host</name><parameter_list>(<param><decl><type><name>apr_pool_t</name> *</type><name>p</name></decl></param>)</parameter_list>;</function_decl>

<comment type="block">/**
 * Log an assertion to the error log
 * @param szExp The assertion that failed
 * @param szFile The file the assertion is in
 * @param nLine The line the assertion is defined on
 */</comment>
<macro><name>AP_DECLARE</name><argument_list>(<argument>void</argument>)</argument_list></macro> <macro><name>ap_log_assert</name><argument_list>(<argument>const char *szExp</argument>, <argument>const char *szFile</argument>, <argument>int nLine</argument>)</argument_list></macro>
                            <expr_stmt><expr><call><name>__attribute__</name><argument_list>(<argument><expr>(<name>noreturn</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/**
 * @internal Internal Assert function
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ap_assert</name><parameter_list>(<param><type><name>exp</name></type></param>)</parameter_list></cpp:macro> <cpp:value>((exp) ? (void)0 : ap_log_assert(#exp,__FILE__,__LINE__))</cpp:value></cpp:define>

<comment type="block">/**
 * Redefine assert() to something more useful for an Apache...
 *
 * Use ap_assert() if the condition should always be checked.
 * Use AP_DEBUG_ASSERT() if the condition should only be checked when AP_DEBUG
 * is defined.
 */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>AP_DEBUG</name></cpp:ifdef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AP_DEBUG_ASSERT</name><parameter_list>(<param><type><name>exp</name></type></param>)</parameter_list></cpp:macro> <cpp:value>ap_assert(exp)</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AP_DEBUG_ASSERT</name><parameter_list>(<param><type><name>exp</name></type></param>)</parameter_list></cpp:macro> <cpp:value>((void)0)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/**
 * @defgroup stopsignal Flags which indicate places where the server should stop for debugging.
 * @{
 * A set of flags which indicate places where the server should raise(SIGSTOP).
 * This is useful for debugging, because you can then attach to that process
 * with gdb and continue.  This is important in cases where one_process
 * debugging isn't possible.
 */</comment>
<comment type="block">/** stop on a Detach */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SIGSTOP_DETACH</name></cpp:macro>                  <cpp:value>1</cpp:value></cpp:define>
<comment type="block">/** stop making a child process */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SIGSTOP_MAKE_CHILD</name></cpp:macro>              <cpp:value>2</cpp:value></cpp:define>
<comment type="block">/** stop spawning a child process */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SIGSTOP_SPAWN_CHILD</name></cpp:macro>             <cpp:value>4</cpp:value></cpp:define>
<comment type="block">/** stop spawning a child process with a piped log */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SIGSTOP_PIPED_LOG_SPAWN</name></cpp:macro>         <cpp:value>8</cpp:value></cpp:define>
<comment type="block">/** stop spawning a CGI child process */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SIGSTOP_CGI_CHILD</name></cpp:macro>               <cpp:value>16</cpp:value></cpp:define>

<comment type="block">/** Macro to get GDB started */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG_SIGSTOP</name></cpp:ifdef>
<decl_stmt><decl><type><specifier>extern</specifier> <name>int</name></type> <name>raise_sigstop_flags</name></decl>;</decl_stmt>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RAISE_SIGSTOP</name><parameter_list>(<param><type><name>x</name></type></param>)</parameter_list></cpp:macro>        <cpp:value>do { \
        if (raise_sigstop_flags &amp; SIGSTOP_##x) raise(SIGSTOP);\
    } while (0)</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RAISE_SIGSTOP</name><parameter_list>(<param><type><name>x</name></type></param>)</parameter_list></cpp:macro></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<comment type="block">/** @} */</comment>
<comment type="block">/**
 * Get HTML describing the address and (optionally) admin of the server.
 * @param prefix Text which is prepended to the return value
 * @param r The request_rec
 * @return HTML describing the server, allocated in @a r's pool.
 */</comment>
<macro><name>AP_DECLARE</name><argument_list>(<argument>const char *</argument>)</argument_list></macro> <expr_stmt><expr><call><name>ap_psignature</name><argument_list>(<argument><expr>const <name>char</name> *<name>prefix</name></expr></argument>, <argument><expr><name>request_rec</name> *<name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* The C library has functions that allow const to be silently dropped ...
     these macros detect the drop in maintainer mode, but use the native
     methods for normal builds

     Note that on some platforms (e.g., AIX with gcc, Solaris with gcc), string.h needs
     to be included before the macros are defined or compilation will fail.
  */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string.h&gt;</cpp:file></cpp:include>

<macro><name>AP_DECLARE</name><argument_list>(<argument>char *</argument>)</argument_list></macro> <macro><name>ap_strchr</name><argument_list>(<argument>char *s</argument>, <argument>int c</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
<macro><name>AP_DECLARE</name><argument_list>(<argument>const char *</argument>)</argument_list></macro> <macro><name>ap_strchr_c</name><argument_list>(<argument>const char *s</argument>, <argument>int c</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
<macro><name>AP_DECLARE</name><argument_list>(<argument>char *</argument>)</argument_list></macro> <macro><name>ap_strrchr</name><argument_list>(<argument>char *s</argument>, <argument>int c</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
<macro><name>AP_DECLARE</name><argument_list>(<argument>const char *</argument>)</argument_list></macro> <macro><name>ap_strrchr_c</name><argument_list>(<argument>const char *s</argument>, <argument>int c</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
<macro><name>AP_DECLARE</name><argument_list>(<argument>char *</argument>)</argument_list></macro> <expr_stmt><expr><call><name>ap_strstr</name><argument_list>(<argument><expr><name>char</name> *<name>s</name></expr></argument>, <argument><expr>const <name>char</name> *<name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<macro><name>AP_DECLARE</name><argument_list>(<argument>const char *</argument>)</argument_list></macro> <expr_stmt><expr><call><name>ap_strstr_c</name><argument_list>(<argument><expr>const <name>char</name> *<name>s</name></expr></argument>, <argument><expr>const <name>char</name> *<name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>AP_DEBUG</name></cpp:ifdef>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>strchr</name></cpp:undef>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>strchr</name><parameter_list>(<param><type><name>s</name></type></param>, <param><type><name>c</name></type></param>)</parameter_list></cpp:macro>  <cpp:value>ap_strchr(s,c)</cpp:value></cpp:define>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>strrchr</name></cpp:undef>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>strrchr</name><parameter_list>(<param><type><name>s</name></type></param>, <param><type><name>c</name></type></param>)</parameter_list></cpp:macro> <cpp:value>ap_strrchr(s,c)</cpp:value></cpp:define>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>strstr</name></cpp:undef>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>strstr</name><parameter_list>(<param><type><name>s</name></type></param>, <param><type><name>c</name></type></param>)</parameter_list></cpp:macro>  <cpp:value>ap_strstr(s,c)</cpp:value></cpp:define>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<comment type="block">/** use this instead of strchr */</comment>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>ap_strchr</name><parameter_list>(<param><type><name>s</name></type></param>, <param><type><name>c</name></type></param>)</parameter_list></cpp:macro>     <cpp:value>strchr(s, c)</cpp:value></cpp:define>
<comment type="block">/** use this instead of strchr */</comment>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>ap_strchr_c</name><parameter_list>(<param><type><name>s</name></type></param>, <param><type><name>c</name></type></param>)</parameter_list></cpp:macro>   <cpp:value>strchr(s, c)</cpp:value></cpp:define>
<comment type="block">/** use this instead of strrchr */</comment>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>ap_strrchr</name><parameter_list>(<param><type><name>s</name></type></param>, <param><type><name>c</name></type></param>)</parameter_list></cpp:macro>    <cpp:value>strrchr(s, c)</cpp:value></cpp:define>
<comment type="block">/** use this instead of strrchr */</comment>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>ap_strrchr_c</name><parameter_list>(<param><type><name>s</name></type></param>, <param><type><name>c</name></type></param>)</parameter_list></cpp:macro>  <cpp:value>strrchr(s, c)</cpp:value></cpp:define>
<comment type="block">/** use this instead of strrstr*/</comment>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>ap_strstr</name><parameter_list>(<param><type><name>s</name></type></param>, <param><type><name>c</name></type></param>)</parameter_list></cpp:macro>     <cpp:value>strstr(s, c)</cpp:value></cpp:define>
<comment type="block">/** use this instead of strrstr*/</comment>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>ap_strstr_c</name><parameter_list>(<param><type><name>s</name></type></param>, <param><type><name>c</name></type></param>)</parameter_list></cpp:macro>   <cpp:value>strstr(s, c)</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/**
 * Generate pseudo random bytes.
 * This is a convenience interface to apr_random. It is cheaper but less
 * secure than apr_generate_random_bytes().
 * @param buf where to store the bytes
 * @param size number of bytes to generate
 * @note ap_random_insecure_bytes() is thread-safe, it uses a mutex on
 *       threaded MPMs.
 */</comment>
<macro><name>AP_DECLARE</name><argument_list>(<argument>void</argument>)</argument_list></macro> <macro><name>ap_random_insecure_bytes</name><argument_list>(<argument>void *buf</argument>, <argument>apr_size_t size</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

<comment type="block">/**
 * Get a pseudo random number in a range.
 * @param min low end of range
 * @param max high end of range
 * @return a number in the range
 */</comment>
<macro><name>AP_DECLARE</name><argument_list>(<argument>apr_uint32_t</argument>)</argument_list></macro> <macro><name>ap_random_pick</name><argument_list>(<argument>apr_uint32_t min</argument>, <argument>apr_uint32_t max</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

<comment type="block">/**
 * Abort with a error message signifying out of memory
 */</comment>
<macro><name>AP_DECLARE</name><argument_list>(<argument>void</argument>)</argument_list></macro> <macro><name>ap_abort_on_oom</name><argument_list>(<argument>void</argument>)</argument_list></macro> <expr_stmt><expr><call><name>__attribute__</name><argument_list>(<argument><expr>(<name>noreturn</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/**
 * Wrapper for malloc() that calls ap_abort_on_oom() if out of memory
 * @param size size of the memory block
 * @return pointer to the allocated memory
 * @note ap_malloc may be implemented as a macro
 */</comment>
<macro><name>AP_DECLARE</name><argument_list>(<argument>void *</argument>)</argument_list></macro> <macro><name>ap_malloc</name><argument_list>(<argument>size_t size</argument>)</argument_list></macro>
                    <macro><name>__attribute__</name><argument_list>(<argument>(malloc)</argument>)</argument_list></macro>
                    <expr_stmt><expr><call><name>AP_FN_ATTR_ALLOC_SIZE</name><argument_list>(<argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/**
 * Wrapper for calloc() that calls ap_abort_on_oom() if out of memory
 * @param nelem number of elements to allocate memory for
 * @param size size of a single element
 * @return pointer to the allocated memory
 * @note ap_calloc may be implemented as a macro
 */</comment>
<macro><name>AP_DECLARE</name><argument_list>(<argument>void *</argument>)</argument_list></macro> <macro><name>ap_calloc</name><argument_list>(<argument>size_t nelem</argument>, <argument>size_t size</argument>)</argument_list></macro>
                   <macro><name>__attribute__</name><argument_list>(<argument>(malloc)</argument>)</argument_list></macro>
                   <expr_stmt><expr><call><name>AP_FN_ATTR_ALLOC_SIZE2</name><argument_list>(<argument><expr>1</expr></argument>,<argument><expr>2</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/**
 * Wrapper for realloc() that calls ap_abort_on_oom() if out of memory
 * @param ptr pointer to the old memory block (or NULL)
 * @param size new size of the memory block
 * @return pointer to the reallocated memory
 * @note ap_realloc may be implemented as a macro
 */</comment>
<macro><name>AP_DECLARE</name><argument_list>(<argument>void *</argument>)</argument_list></macro> <macro><name>ap_realloc</name><argument_list>(<argument>void *ptr</argument>, <argument>size_t size</argument>)</argument_list></macro>
                   <decl_stmt><decl><type><name>AP_FN_ATTR_WARN_UNUSED_RESULT</name></type>
                   <name>AP_FN_ATTR_ALLOC_SIZE</name><argument_list>(<argument><expr>2</expr></argument>)</argument_list></decl>;</decl_stmt>

<comment type="block">/**
 * Get server load params
 * @param ld struct to populate: -1 in fields means error
 */</comment>
<macro><name>AP_DECLARE</name><argument_list>(<argument>void</argument>)</argument_list></macro> <expr_stmt><expr><call><name>ap_get_sload</name><argument_list>(<argument><expr><name>ap_sload_t</name> *<name>ld</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/**
 * Get server load averages (ala getloadavg)
 * @param ld struct to populate: -1 in fields means error
 */</comment>
<macro><name>AP_DECLARE</name><argument_list>(<argument>void</argument>)</argument_list></macro> <expr_stmt><expr><call><name>ap_get_loadavg</name><argument_list>(<argument><expr><name>ap_loadavg_t</name> *<name>ld</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/**
 * Convert binary data into a hex string
 * @param src pointer to the data
 * @param srclen length of the data
 * @param dest pointer to buffer of length (2 * srclen + 1). The resulting
 *        string will be NUL-terminated.
 */</comment>
<macro><name>AP_DECLARE</name><argument_list>(<argument>void</argument>)</argument_list></macro> <macro><name>ap_bin2hex</name><argument_list>(<argument>const void *src</argument>, <argument>apr_size_t srclen</argument>, <argument>char *dest</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

<comment type="block">/**
 * Short function to execute a command and return the first line of
 * output minus \r \n. Useful for "obscuring" passwords via exec calls
 * @param p the pool to allocate from
 * @param cmd the command to execute
 * @param argv the arguments to pass to the cmd
 * @return ptr to characters or NULL on any error
 */</comment>
<macro><name>AP_DECLARE</name><argument_list>(<argument>char *</argument>)</argument_list></macro> <expr_stmt><expr><call><name>ap_get_exec_line</name><argument_list>(<argument><expr><name>apr_pool_t</name> *<name>p</name></expr></argument>,
                                    <argument><expr>const <name>char</name> *<name>cmd</name></expr></argument>,
                                    <argument><expr>const <name>char</name> * const *<name>argv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AP_NORESTART</name></cpp:macro> <cpp:value>APR_OS_START_USEERR + 1</cpp:value></cpp:define>

<comment type="block">/**
 * Get the first index of the string in the array or -1 if not found. Start
 * searching a start. 
 * @param array The array the check
 * @param s The string to find
 * @param start Start index for search. If start is out of bounds (negative or  
                equal to array length or greater), -1 will be returned.
 * @return index of string in array or -1
 */</comment>
<macro><name>AP_DECLARE</name><argument_list>(<argument>int</argument>)</argument_list></macro> <macro><name>ap_array_str_index</name><argument_list>(<argument>const apr_array_header_t *array</argument>, 
                                   <argument>const char *s</argument>,
                                   <argument>int start</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

<comment type="block">/**
 * Check if the string is member of the given array by strcmp.
 * @param array The array the check
 * @param s The string to find
 * @return !=0 iff string is member of array (via strcmp)
 */</comment>
<macro><name>AP_DECLARE</name><argument_list>(<argument>int</argument>)</argument_list></macro> <expr_stmt><expr><call><name>ap_array_str_contains</name><argument_list>(<argument><expr>const <name>apr_array_header_t</name> *<name>array</name></expr></argument>, 
                                      <argument><expr>const <name>char</name> *<name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/**
 * Perform a case-insensitive comparison of two strings @a atr1 and @a atr2,
 * treating upper and lower case values of the 26 standard C/POSIX alphabetic
 * characters as equivalent. Extended latin characters outside of this set
 * are treated as unique octets, irrespective of the current locale.
 *
 * Returns in integer greater than, equal to, or less than 0,
 * according to whether @a str1 is considered greater than, equal to,
 * or less than @a str2.
 *
 * @note Same code as apr_cstr_casecmp, which arrives in APR 1.6
 */</comment>
<macro><name>AP_DECLARE</name><argument_list>(<argument>int</argument>)</argument_list></macro> <expr_stmt><expr><call><name>ap_cstr_casecmp</name><argument_list>(<argument><expr>const <name>char</name> *<name>s1</name></expr></argument>, <argument><expr>const <name>char</name> *<name>s2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/**
 * Perform a case-insensitive comparison of two strings @a atr1 and @a atr2,
 * treating upper and lower case values of the 26 standard C/POSIX alphabetic
 * characters as equivalent. Extended latin characters outside of this set
 * are treated as unique octets, irrespective of the current locale.
 *
 * Returns in integer greater than, equal to, or less than 0,
 * according to whether @a str1 is considered greater than, equal to,
 * or less than @a str2.
 *
 * @note Same code as apr_cstr_casecmpn, which arrives in APR 1.6
 */</comment>
<macro><name>AP_DECLARE</name><argument_list>(<argument>int</argument>)</argument_list></macro> <macro><name>ap_cstr_casecmpn</name><argument_list>(<argument>const char *s1</argument>, <argument>const char *s2</argument>, <argument>apr_size_t n</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__cplusplus</name></cpp:ifdef>
}</block></extern>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>  <comment type="block">/* !APACHE_HTTPD_H */</comment>

<comment type="block">/** @} //APACHE Daemon      */</comment>
<comment type="block">/** @} //APACHE Core        */</comment>
<comment type="block">/** @} //APACHE super group */</comment>

</unit>
