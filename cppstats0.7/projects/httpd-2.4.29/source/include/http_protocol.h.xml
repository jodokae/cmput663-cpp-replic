<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C" filename="projects/httpd-2.4.29/include/http_protocol.h"><comment type="block">/* Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */</comment>

<comment type="block">/**
 * @file  http_protocol.h
 * @brief HTTP protocol handling
 *
 * @defgroup APACHE_CORE_PROTO HTTP Protocol Handling
 * @ingroup  APACHE_CORE
 * @{
 */</comment>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>APACHE_HTTP_PROTOCOL_H</name></cpp:ifndef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>APACHE_HTTP_PROTOCOL_H</name></cpp:macro></cpp:define>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"httpd.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"apr_portable.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"apr_mmap.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"apr_buckets.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"util_filter.h"</cpp:file></cpp:include>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__cplusplus</name></cpp:ifdef>
<extern>extern "C" <block>{
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/**
 * This hook allows modules to insert filters for the current error response
 * @param r the current request
 * @ingroup hooks
 */</comment>
<macro><name>AP_DECLARE_HOOK</name><argument_list>(<argument>void</argument>,<argument>insert_error_filter</argument>,<argument>(request_rec *r)</argument>)</argument_list></macro>

<comment type="block">/** This is an optimization.  We keep a record of the filter_rec that
 * stores the old_write filter, so that we can avoid strcmp's later.
 */</comment>
<decl_stmt><decl><type><name>AP_DECLARE_DATA</name> <specifier>extern</specifier> <name>ap_filter_rec_t</name> *</type><name>ap_old_write_func</name></decl>;</decl_stmt>

<comment type="block">/*
 * Prototypes for routines which either talk directly back to the user,
 * or control the ones that eventually do.
 */</comment>

<comment type="block">/**
 * Read a request and fill in the fields.
 * @param c The current connection
 * @return The new request_rec
 */</comment>
<function_decl><type><name>request_rec</name> *</type><name>ap_read_request</name><parameter_list>(<param><decl><type><name>conn_rec</name> *</type><name>c</name></decl></param>)</parameter_list>;</function_decl>

<comment type="block">/**
 * Read the mime-encoded headers.
 * @param r The current request
 */</comment>
<macro><name>AP_DECLARE</name><argument_list>(<argument>void</argument>)</argument_list></macro> <expr_stmt><expr><call><name>ap_get_mime_headers</name><argument_list>(<argument><expr><name>request_rec</name> *<name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/**
 * Optimized version of ap_get_mime_headers() that requires a
 * temporary brigade to work with
 * @param r The current request
 * @param bb temp brigade
 */</comment>
<macro><name>AP_DECLARE</name><argument_list>(<argument>void</argument>)</argument_list></macro> <expr_stmt><expr><call><name>ap_get_mime_headers_core</name><argument_list>(<argument><expr><name>request_rec</name> *<name>r</name></expr></argument>,
                                          <argument><expr><name>apr_bucket_brigade</name> *<name>bb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/* Finish up stuff after a request */</comment>

<comment type="block">/**
 * Called at completion of sending the response.  It sends the terminating
 * protocol information.
 * @param r The current request
 */</comment>
<macro><name>AP_DECLARE</name><argument_list>(<argument>void</argument>)</argument_list></macro> <expr_stmt><expr><call><name>ap_finalize_request_protocol</name><argument_list>(<argument><expr><name>request_rec</name> *<name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/**
 * Send error back to client.
 * @param r The current request
 * @param recursive_error last arg indicates error status in case we get
 *      an error in the process of trying to deal with an ErrorDocument
 *      to handle some other error.  In that case, we print the default
 *      report for the first thing that went wrong, and more briefly report
 *      on the problem with the ErrorDocument.
 */</comment>
<macro><name>AP_DECLARE</name><argument_list>(<argument>void</argument>)</argument_list></macro> <macro><name>ap_send_error_response</name><argument_list>(<argument>request_rec *r</argument>, <argument>int recursive_error</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

<comment type="block">/* Set last modified header line from the lastmod date of the associated file.
 * Also, set content length.
 *
 * May return an error status, typically HTTP_NOT_MODIFIED (that when the
 * permit_cache argument is set to one).
 */</comment>

<comment type="block">/**
 * Set the content length for this request
 * @param r The current request
 * @param length The new content length
 */</comment>
<macro><name>AP_DECLARE</name><argument_list>(<argument>void</argument>)</argument_list></macro> <macro><name>ap_set_content_length</name><argument_list>(<argument>request_rec *r</argument>, <argument>apr_off_t length</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

<comment type="block">/**
 * Set the keepalive status for this request
 * @param r The current request
 * @return 1 if keepalive can be set, 0 otherwise
 */</comment>
<macro><name>AP_DECLARE</name><argument_list>(<argument>int</argument>)</argument_list></macro> <expr_stmt><expr><call><name>ap_set_keepalive</name><argument_list>(<argument><expr><name>request_rec</name> *<name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/**
 * Return the latest rational time from a request/mtime pair.  Mtime is
 * returned unless it's in the future, in which case we return the current time.
 * @param r The current request
 * @param mtime The last modified time
 * @return the latest rational time.
 */</comment>
<macro><name>AP_DECLARE</name><argument_list>(<argument>apr_time_t</argument>)</argument_list></macro> <macro><name>ap_rationalize_mtime</name><argument_list>(<argument>request_rec *r</argument>, <argument>apr_time_t mtime</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

<comment type="block">/**
 * Build the content-type that should be sent to the client from the
 * content-type specified.  The following rules are followed:
 *    - if type is NULL or "", return NULL (do not set content-type).
 *    - if charset adding is disabled, stop processing and return type.
 *    - then, if there are no parameters on type, add the default charset
 *    - return type
 * @param r The current request
 * @param type The content type
 * @return The content-type
 */</comment>
<macro><name>AP_DECLARE</name><argument_list>(<argument>const char *</argument>)</argument_list></macro> <expr_stmt><expr><call><name>ap_make_content_type</name><argument_list>(<argument><expr><name>request_rec</name> *<name>r</name></expr></argument>,
                                              <argument><expr>const <name>char</name> *<name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/**
 * Precompile metadata structures used by ap_make_content_type()
 * @param pool The pool to use for allocations
 */</comment>
<macro><name>AP_DECLARE</name><argument_list>(<argument>void</argument>)</argument_list></macro> <expr_stmt><expr><call><name>ap_setup_make_content_type</name><argument_list>(<argument><expr><name>apr_pool_t</name> *<name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/**
 * Construct an entity tag from the resource information.  If it's a real
 * file, build in some of the file characteristics.
 * @param r The current request
 * @param force_weak Force the entity tag to be weak - it could be modified
 *                   again in as short an interval.
 * @return The entity tag
 */</comment>
<macro><name>AP_DECLARE</name><argument_list>(<argument>char *</argument>)</argument_list></macro> <macro><name>ap_make_etag</name><argument_list>(<argument>request_rec *r</argument>, <argument>int force_weak</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

<comment type="block">/**
 * Set the E-tag outgoing header
 * @param r The current request
 */</comment>
<macro><name>AP_DECLARE</name><argument_list>(<argument>void</argument>)</argument_list></macro> <expr_stmt><expr><call><name>ap_set_etag</name><argument_list>(<argument><expr><name>request_rec</name> *<name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/**
 * Set the last modified time for the file being sent
 * @param r The current request
 */</comment>
<macro><name>AP_DECLARE</name><argument_list>(<argument>void</argument>)</argument_list></macro> <expr_stmt><expr><call><name>ap_set_last_modified</name><argument_list>(<argument><expr><name>request_rec</name> *<name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<typedef>typedef <type><enum>enum <block>{
    <decl><name>AP_CONDITION_NONE</name></decl>,
    <decl><name>AP_CONDITION_NOMATCH</name></decl>,
    <decl><name>AP_CONDITION_WEAK</name></decl>,
    <decl><name>AP_CONDITION_STRONG</name></decl>
}</block></enum></type> <name>ap_condition_e</name>;</typedef>

<comment type="block">/**
 * Tests conditional request rules for the If-Match header.
 * @param r The current request
 * @param headers The response headers to check against
 * @return AP_CONDITION_NONE if the header is missing, AP_CONDITION_NOMATCH
 *         if the header does not match, AP_CONDITION_STRONG for a strong
 *         match. Weak matches are not permitted for the If-Match header.
 */</comment>
<macro><name>AP_DECLARE</name><argument_list>(<argument>ap_condition_e</argument>)</argument_list></macro> <expr_stmt><expr><call><name>ap_condition_if_match</name><argument_list>(<argument><expr><name>request_rec</name> *<name>r</name></expr></argument>,
        <argument><expr><name>apr_table_t</name> *<name>headers</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/**
 * Tests conditional request rules for the If-Unmodified-Since header.
 * @param r The current request
 * @param headers The response headers to check against
 * @return AP_CONDITION_NONE if the header is missing, AP_CONDITION_NOMATCH
 *         if the header does not match, AP_CONDITION_WEAK if a weak match
 *         was present and allowed by RFC2616, AP_CONDITION_STRONG for a
 *         strong match.
 */</comment>
<macro><name>AP_DECLARE</name><argument_list>(<argument>ap_condition_e</argument>)</argument_list></macro> <expr_stmt><expr><call><name>ap_condition_if_unmodified_since</name><argument_list>(<argument><expr><name>request_rec</name> *<name>r</name></expr></argument>,
        <argument><expr><name>apr_table_t</name> *<name>headers</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/**
 * Tests conditional request rules for the If-None-Match header.
 * @param r The current request
 * @param headers The response headers to check against
 * @return AP_CONDITION_NONE if the header is missing, AP_CONDITION_NOMATCH
 *         if the header does not match, AP_CONDITION_WEAK if a weak match
 *         was present and allowed by RFC2616, AP_CONDITION_STRONG for a
 *         strong match.
 */</comment>
<macro><name>AP_DECLARE</name><argument_list>(<argument>ap_condition_e</argument>)</argument_list></macro> <expr_stmt><expr><call><name>ap_condition_if_none_match</name><argument_list>(<argument><expr><name>request_rec</name> *<name>r</name></expr></argument>,
        <argument><expr><name>apr_table_t</name> *<name>headers</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/**
 * Tests conditional request rules for the If-Modified-Since header.
 * @param r The current request
 * @param headers The response headers to check against
 * @return AP_CONDITION_NONE if the header is missing, AP_CONDITION_NOMATCH
 *         if the header does not match, AP_CONDITION_WEAK if a weak match
 *         was present and allowed by RFC2616, AP_CONDITION_STRONG for a
 *         strong match.
 */</comment>
<macro><name>AP_DECLARE</name><argument_list>(<argument>ap_condition_e</argument>)</argument_list></macro> <expr_stmt><expr><call><name>ap_condition_if_modified_since</name><argument_list>(<argument><expr><name>request_rec</name> *<name>r</name></expr></argument>,
        <argument><expr><name>apr_table_t</name> *<name>headers</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/**
 * Tests conditional request rules for the If-Range header.
 * @param r The current request
 * @param headers The response headers to check against
 * @return AP_CONDITION_NONE if either the If-Range or Range header is
 *         missing, AP_CONDITION_NOMATCH if the header does not match,
 *         AP_CONDITION_STRONG for a strong match. Weak matches are not
 *         permitted for the If-Range header.
 */</comment>
<macro><name>AP_DECLARE</name><argument_list>(<argument>ap_condition_e</argument>)</argument_list></macro> <expr_stmt><expr><call><name>ap_condition_if_range</name><argument_list>(<argument><expr><name>request_rec</name> *<name>r</name></expr></argument>,
        <argument><expr><name>apr_table_t</name> *<name>headers</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/**
 * Implements condition GET rules for HTTP/1.1 specification.  This function
 * inspects the client headers and determines if the response fulfills
 * the requirements specified.
 * @param r The current request
 * @return OK if the response fulfills the condition GET rules, some
 *         other status code otherwise
 */</comment>
<macro><name>AP_DECLARE</name><argument_list>(<argument>int</argument>)</argument_list></macro> <expr_stmt><expr><call><name>ap_meets_conditions</name><argument_list>(<argument><expr><name>request_rec</name> *<name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/* Other ways to send stuff at the client.  All of these keep track
 * of bytes_sent automatically.  This indirection is intended to make
 * it a little more painless to slide things like HTTP-NG packetization
 * underneath the main body of the code later.  In the meantime, it lets
 * us centralize a bit of accounting (bytes_sent).
 *
 * These also return the number of bytes written by the call.
 * They should only be called with a timeout registered, for obvious reaasons.
 * (Ditto the send_header stuff).
 */</comment>

<comment type="block">/**
 * Send an entire file to the client, using sendfile if supported by the
 * current platform
 * @param fd The file to send.
 * @param r The current request
 * @param offset Offset into the file to start sending.
 * @param length Amount of data to send
 * @param nbytes Amount of data actually sent
 */</comment>
<macro><name>AP_DECLARE</name><argument_list>(<argument>apr_status_t</argument>)</argument_list></macro> <macro><name>ap_send_fd</name><argument_list>(<argument>apr_file_t *fd</argument>, <argument>request_rec *r</argument>, <argument>apr_off_t offset</argument>,
                                   <argument>apr_size_t length</argument>, <argument>apr_size_t *nbytes</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>APR_HAS_MMAP</name></expr></cpp:if>
<comment type="block">/**
 * Send an MMAP'ed file to the client
 * @param mm The MMAP'ed file to send
 * @param r The current request
 * @param offset The offset into the MMAP to start sending
 * @param length The amount of data to send
 * @return The number of bytes sent
 */</comment>
<macro><name>AP_DECLARE</name><argument_list>(<argument>apr_size_t</argument>)</argument_list></macro> <macro><name>ap_send_mmap</name><argument_list>(<argument>apr_mmap_t *mm</argument>,
                                    <argument>request_rec *r</argument>,
                                    <argument>apr_size_t offset</argument>,
                                    <argument>apr_size_t length</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<comment type="block">/**
 * Register a new request method, and return the offset that will be
 * associated with that method.
 *
 * @param p        The pool to create registered method numbers from.
 * @param methname The name of the new method to register.
 * @return         An int value representing an offset into a bitmask.
 */</comment>
<macro><name>AP_DECLARE</name><argument_list>(<argument>int</argument>)</argument_list></macro> <expr_stmt><expr><call><name>ap_method_register</name><argument_list>(<argument><expr><name>apr_pool_t</name> *<name>p</name></expr></argument>, <argument><expr>const <name>char</name> *<name>methname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/**
 * Initialize the method_registry and allocate memory for it.
 *
 * @param p Pool to allocate memory for the registry from.
 */</comment>
<macro><name>AP_DECLARE</name><argument_list>(<argument>void</argument>)</argument_list></macro> <expr_stmt><expr><call><name>ap_method_registry_init</name><argument_list>(<argument><expr><name>apr_pool_t</name> *<name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/**
 * This is a convenience macro to ease with checking a mask
 * against a method name.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AP_METHOD_CHECK_ALLOWED</name><parameter_list>(<param><type><name>mask</name></type></param>, <param><type><name>methname</name></type></param>)</parameter_list></cpp:macro> \
    <cpp:value>((mask) &amp; (AP_METHOD_BIT &lt;&lt; ap_method_number_of((methname))))</cpp:value></cpp:define>

<comment type="block">/**
 * Create a new method list with the specified number of preallocated
 * slots for extension methods.
 *
 * @param   p       Pointer to a pool in which the structure should be
 *                  allocated.
 * @param   nelts   Number of preallocated extension slots
 * @return  Pointer to the newly created structure.
 */</comment>
<macro><name>AP_DECLARE</name><argument_list>(<argument>ap_method_list_t *</argument>)</argument_list></macro> <macro><name>ap_make_method_list</name><argument_list>(<argument>apr_pool_t *p</argument>, <argument>int nelts</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>


<comment type="block">/**
 * Copy a method list
 *
 * @param   dest List to copy to
 * @param   src  List to copy from
 */</comment>
<macro><name>AP_DECLARE</name><argument_list>(<argument>void</argument>)</argument_list></macro> <expr_stmt><expr><call><name>ap_copy_method_list</name><argument_list>(<argument><expr><name>ap_method_list_t</name> *<name>dest</name></expr></argument>,
                                     <argument><expr><name>ap_method_list_t</name> *<name>src</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/**
 * Search for an HTTP method name in an ap_method_list_t structure, and
 * return true if found.
 *
 * @param   method  String containing the name of the method to check.
 * @param   l       Pointer to a method list, such as r-&gt;allowed_methods.
 * @return  1 if method is in the list, otherwise 0
 */</comment>
<macro><name>AP_DECLARE</name><argument_list>(<argument>int</argument>)</argument_list></macro> <expr_stmt><expr><call><name>ap_method_in_list</name><argument_list>(<argument><expr><name>ap_method_list_t</name> *<name>l</name></expr></argument>, <argument><expr>const <name>char</name> *<name>method</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/**
 * Add an HTTP method name to an ap_method_list_t structure if it isn't
 * already listed.
 *
 * @param   method  String containing the name of the method to check.
 * @param   l       Pointer to a method list, such as r-&gt;allowed_methods.
 * @return  None.
 */</comment>
<macro><name>AP_DECLARE</name><argument_list>(<argument>void</argument>)</argument_list></macro> <expr_stmt><expr><call><name>ap_method_list_add</name><argument_list>(<argument><expr><name>ap_method_list_t</name> *<name>l</name></expr></argument>, <argument><expr>const <name>char</name> *<name>method</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/**
 * Remove an HTTP method name from an ap_method_list_t structure.
 *
 * @param   l       Pointer to a method list, such as r-&gt;allowed_methods.
 * @param   method  String containing the name of the method to remove.
 * @return  None.
 */</comment>
<macro><name>AP_DECLARE</name><argument_list>(<argument>void</argument>)</argument_list></macro> <expr_stmt><expr><call><name>ap_method_list_remove</name><argument_list>(<argument><expr><name>ap_method_list_t</name> *<name>l</name></expr></argument>,
                                       <argument><expr>const <name>char</name> *<name>method</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/**
 * Reset a method list to be completely empty.
 *
 * @param   l       Pointer to a method list, such as r-&gt;allowed_methods.
 * @return  None.
 */</comment>
<macro><name>AP_DECLARE</name><argument_list>(<argument>void</argument>)</argument_list></macro> <expr_stmt><expr><call><name>ap_clear_method_list</name><argument_list>(<argument><expr><name>ap_method_list_t</name> *<name>l</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/**
 * Set the content type for this request (r-&gt;content_type).
 * @param r The current request
 * @param ct The new content type
 * @warning This function must be called to set r-&gt;content_type in order
 * for the AddOutputFilterByType directive to work correctly.
 */</comment>
<macro><name>AP_DECLARE</name><argument_list>(<argument>void</argument>)</argument_list></macro> <expr_stmt><expr><call><name>ap_set_content_type</name><argument_list>(<argument><expr><name>request_rec</name> *<name>r</name></expr></argument>, <argument><expr>const <name>char</name> *<name>ct</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/**
 * Set the Accept-Ranges header for this response
 * @param r The current request
 */</comment>
<macro><name>AP_DECLARE</name><argument_list>(<argument>void</argument>)</argument_list></macro> <expr_stmt><expr><call><name>ap_set_accept_ranges</name><argument_list>(<argument><expr><name>request_rec</name> *<name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<comment type="block">/* Hmmm... could macrofy these for now, and maybe forever, though the
 * definitions of the macros would get a whole lot hairier.
 */</comment>

<comment type="block">/**
 * Output one character for this request
 * @param c the character to output
 * @param r the current request
 * @return The number of bytes sent
 */</comment>
<macro><name>AP_DECLARE</name><argument_list>(<argument>int</argument>)</argument_list></macro> <macro><name>ap_rputc</name><argument_list>(<argument>int c</argument>, <argument>request_rec *r</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

<comment type="block">/**
 * Write a buffer for the current request
 * @param buf The buffer to write
 * @param nbyte The number of bytes to send from the buffer
 * @param r The current request
 * @return The number of bytes sent
 */</comment>
<macro><name>AP_DECLARE</name><argument_list>(<argument>int</argument>)</argument_list></macro> <macro><name>ap_rwrite</name><argument_list>(<argument>const void *buf</argument>, <argument>int nbyte</argument>, <argument>request_rec *r</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

<comment type="block">/**
 * Output a string for the current request
 * @param str The string to output
 * @param r The current request
 * @return The number of bytes sent
 * @note ap_rputs may be implemented as macro or inline function
 */</comment>
<function><type><specifier>static</specifier> <name>APR_INLINE</name> <name>int</name></type> <name>ap_rputs</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>str</name></decl></param>, <param><decl><type><name>request_rec</name> *</type><name>r</name></decl></param>)</parameter_list>
<block>{
    <return>return <expr><call><name>ap_rwrite</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr>(<name>int</name>)<call><name>strlen</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<comment type="block">/**
 * Write an unspecified number of strings to the request
 * @param r The current request
 * @param ... The strings to write
 * @return The number of bytes sent
 */</comment>
<macro><name>AP_DECLARE_NONSTD</name><argument_list>(<argument>int</argument>)</argument_list></macro> <macro><name>ap_rvputs</name><argument_list>(<argument>request_rec *r</argument>,<argument>...</argument>)</argument_list></macro>
                       <expr_stmt><expr><name>AP_FN_ATTR_SENTINEL</name></expr>;</expr_stmt>

<comment type="block">/**
 * Output data to the client in a printf format
 * @param r The current request
 * @param fmt The format string
 * @param vlist The arguments to use to fill out the format string
 * @return The number of bytes sent
 */</comment>
<macro><name>AP_DECLARE</name><argument_list>(<argument>int</argument>)</argument_list></macro> <macro><name>ap_vrprintf</name><argument_list>(<argument>request_rec *r</argument>, <argument>const char *fmt</argument>, <argument>va_list vlist</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

<comment type="block">/**
 * Output data to the client in a printf format
 * @param r The current request
 * @param fmt The format string
 * @param ... The arguments to use to fill out the format string
 * @return The number of bytes sent
 */</comment>
<macro><name>AP_DECLARE_NONSTD</name><argument_list>(<argument>int</argument>)</argument_list></macro> <macro><name>ap_rprintf</name><argument_list>(<argument>request_rec *r</argument>, <argument>const char *fmt</argument>,<argument>...</argument>)</argument_list></macro>
                                <expr_stmt><expr><call><name>__attribute__</name><argument_list>(<argument><expr>(<call><name>format</name><argument_list>(<argument><expr><name>printf</name></expr></argument>,<argument><expr>2</expr></argument>,<argument><expr>3</expr></argument>)</argument_list></call>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/**
 * Flush all of the data for the current request to the client
 * @param r The current request
 * @return 0 on success, -1 if an error occurred
 */</comment>
<macro><name>AP_DECLARE</name><argument_list>(<argument>int</argument>)</argument_list></macro> <expr_stmt><expr><call><name>ap_rflush</name><argument_list>(<argument><expr><name>request_rec</name> *<name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/**
 * Index used in custom_responses array for a specific error code
 * (only use outside protocol.c is in getting them configured).
 * @param status HTTP status code
 * @return The index of the response
 */</comment>
<macro><name>AP_DECLARE</name><argument_list>(<argument>int</argument>)</argument_list></macro> <macro><name>ap_index_of_response</name><argument_list>(<argument>int status</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

<comment type="block">/**
 * Return the Status-Line for a given status code (excluding the
 * HTTP-Version field). If an invalid or unknown status code is
 * passed, "500 Internal Server Error" will be returned.
 * @param status The HTTP status code
 * @return The Status-Line
 */</comment>
<macro><name>AP_DECLARE</name><argument_list>(<argument>const char *</argument>)</argument_list></macro> <macro><name>ap_get_status_line</name><argument_list>(<argument>int status</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

<comment type="block">/* Reading a block of data from the client connection (e.g., POST arg) */</comment>

<comment type="block">/**
 * Setup the client to allow Apache to read the request body.
 * @param r The current request
 * @param read_policy How the server should interpret a chunked
 *                    transfer-encoding.  One of: &lt;pre&gt;
 *    REQUEST_NO_BODY          Send 413 error if message has any body
 *    REQUEST_CHUNKED_ERROR    Send 411 error if body without Content-Length
 *    REQUEST_CHUNKED_DECHUNK  If chunked, remove the chunks for me.
 * &lt;/pre&gt;
 * @return either OK or an error code
 */</comment>
<macro><name>AP_DECLARE</name><argument_list>(<argument>int</argument>)</argument_list></macro> <macro><name>ap_setup_client_block</name><argument_list>(<argument>request_rec *r</argument>, <argument>int read_policy</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

<comment type="block">/**
 * Determine if the client has sent any data.  This also sends a
 * 100 Continue response to HTTP/1.1 clients, so modules should not be called
 * until the module is ready to read content.
 * @warning Never call this function more than once.
 * @param r The current request
 * @return 0 if there is no message to read, 1 otherwise
 */</comment>
<macro><name>AP_DECLARE</name><argument_list>(<argument>int</argument>)</argument_list></macro> <expr_stmt><expr><call><name>ap_should_client_block</name><argument_list>(<argument><expr><name>request_rec</name> *<name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/**
 * Call this in a loop.  It will put data into a buffer and return the length
 * of the input block
 * @param r The current request
 * @param buffer The buffer in which to store the data
 * @param bufsiz The size of the buffer
 * @return Number of bytes inserted into the buffer.  When done reading, 0
 *         if EOF, or -1 if there was an error
 */</comment>
<macro><name>AP_DECLARE</name><argument_list>(<argument>long</argument>)</argument_list></macro> <macro><name>ap_get_client_block</name><argument_list>(<argument>request_rec *r</argument>, <argument>char *buffer</argument>, <argument>apr_size_t bufsiz</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

<comment type="block">/**
 * Map specific APR codes returned by the filter stack to HTTP error
 * codes, or the default status code provided. Use it as follows:
 *
 * return ap_map_http_request_error(rv, HTTP_BAD_REQUEST);
 *
 * If the filter has already handled the error, AP_FILTER_ERROR will
 * be returned, which is cleanly passed through.
 *
 * These mappings imply that the filter stack is reading from the
 * downstream client, the proxy will map these codes differently.
 * @param rv APR status code
 * @param status Default HTTP code should the APR code not be recognised
 * @return Mapped HTTP status code
 */</comment>
<macro><name>AP_DECLARE</name><argument_list>(<argument>int</argument>)</argument_list></macro> <macro><name>ap_map_http_request_error</name><argument_list>(<argument>apr_status_t rv</argument>, <argument>int status</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

<comment type="block">/**
 * In HTTP/1.1, any method can have a body.  However, most GET handlers
 * wouldn't know what to do with a request body if they received one.
 * This helper routine tests for and reads any message body in the request,
 * simply discarding whatever it receives.  We need to do this because
 * failing to read the request body would cause it to be interpreted
 * as the next request on a persistent connection.
 * @param r The current request
 * @return error status if request is malformed, OK otherwise
 */</comment>
<macro><name>AP_DECLARE</name><argument_list>(<argument>int</argument>)</argument_list></macro> <expr_stmt><expr><call><name>ap_discard_request_body</name><argument_list>(<argument><expr><name>request_rec</name> *<name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/**
 * Setup the output headers so that the client knows how to authenticate
 * itself the next time, if an authentication request failed.
 * @param r The current request
 */</comment>
<macro><name>AP_DECLARE</name><argument_list>(<argument>void</argument>)</argument_list></macro> <expr_stmt><expr><call><name>ap_note_auth_failure</name><argument_list>(<argument><expr><name>request_rec</name> *<name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/**
 * @deprecated @see ap_note_auth_failure
 */</comment>
<macro><name>AP_DECLARE</name><argument_list>(<argument>void</argument>)</argument_list></macro> <expr_stmt><expr><call><name>ap_note_basic_auth_failure</name><argument_list>(<argument><expr><name>request_rec</name> *<name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/**
 * @deprecated @see ap_note_auth_failure
 */</comment>
<macro><name>AP_DECLARE</name><argument_list>(<argument>void</argument>)</argument_list></macro> <expr_stmt><expr><call><name>ap_note_digest_auth_failure</name><argument_list>(<argument><expr><name>request_rec</name> *<name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/**
 * This hook allows modules to add support for a specific auth type to
 * ap_note_auth_failure
 * @param r the current request
 * @param auth_type the configured auth_type
 * @return OK, DECLINED
 */</comment>
<macro><name>AP_DECLARE_HOOK</name><argument_list>(<argument>int</argument>, <argument>note_auth_failure</argument>, <argument>(request_rec *r, const char *auth_type)</argument>)</argument_list></macro>

<comment type="block">/**
 * Get the password from the request headers. This function has multiple side
 * effects due to its prior use in the old authentication framework.
 * ap_get_basic_auth_components() should be preferred.
 *
 * @deprecated @see ap_get_basic_auth_components
 * @param r The current request
 * @param pw The password as set in the headers
 * @return 0 (OK) if it set the 'pw' argument (and assured
 *         a correct value in r-&gt;user); otherwise it returns
 *         an error code, either HTTP_INTERNAL_SERVER_ERROR if things are
 *         really confused, HTTP_UNAUTHORIZED if no authentication at all
 *         seemed to be in use, or DECLINED if there was authentication but
 *         it wasn't Basic (in which case, the caller should presumably
 *         decline as well).
 */</comment>
<macro><name>AP_DECLARE</name><argument_list>(<argument>int</argument>)</argument_list></macro> <expr_stmt><expr><call><name>ap_get_basic_auth_pw</name><argument_list>(<argument><expr><name>request_rec</name> *<name>r</name></expr></argument>, <argument><expr>const <name>char</name> **<name>pw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AP_GET_BASIC_AUTH_PW_NOTE</name></cpp:macro> <cpp:value>"AP_GET_BASIC_AUTH_PW_NOTE"</cpp:value></cpp:define>

<comment type="block">/**
 * Get the username and/or password from the request's Basic authentication
 * headers. Unlike ap_get_basic_auth_pw(), calling this function has no side
 * effects on the passed request_rec.
 *
 * @param r The current request
 * @param username If not NULL, set to the username sent by the client
 * @param password If not NULL, set to the password sent by the client
 * @return APR_SUCCESS if the credentials were successfully parsed and returned;
 *         APR_EINVAL if there was no authentication header sent or if the
 *         client was not using the Basic authentication scheme. username and
 *         password are unchanged on failure.
 */</comment>
<macro><name>AP_DECLARE</name><argument_list>(<argument>apr_status_t</argument>)</argument_list></macro> <expr_stmt><expr><call><name>ap_get_basic_auth_components</name><argument_list>(<argument><expr>const <name>request_rec</name> *<name>r</name></expr></argument>,
                                                      <argument><expr>const <name>char</name> **<name>username</name></expr></argument>,
                                                      <argument><expr>const <name>char</name> **<name>password</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/**
 * parse_uri: break apart the uri
 * @warning Side Effects:
 *    @li sets r-&gt;args to rest after '?' (or NULL if no '?')
 *    @li sets r-&gt;uri to request uri (without r-&gt;args part)
 *    @li sets r-&gt;hostname (if not set already) from request (scheme://host:port)
 * @param r The current request
 * @param uri The uri to break apart
 */</comment>
<macro><name>AP_CORE_DECLARE</name><argument_list>(<argument>void</argument>)</argument_list></macro> <expr_stmt><expr><call><name>ap_parse_uri</name><argument_list>(<argument><expr><name>request_rec</name> *<name>r</name></expr></argument>, <argument><expr>const <name>char</name> *<name>uri</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AP_GETLINE_FOLD</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define> <comment type="block">/* Whether to merge continuation lines */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AP_GETLINE_CRLF</name></cpp:macro> <cpp:value>2</cpp:value></cpp:define> <comment type="block">/*Whether line ends must be in the form CR LF */</comment>

<comment type="block">/**
 * Get the next line of input for the request
 * @param s The buffer into which to read the line
 * @param n The size of the buffer
 * @param r The request
 * @param flags Bit flag of multiple parsing options
 *              AP_GETLINE_FOLD Whether to merge continuation lines
 *              AP_GETLINE_CRLF Whether line ends must be in the form CR LF
 * @return The length of the line, if successful
 *         n, if the line is too big to fit in the buffer
 *         -1 for miscellaneous errors
 */</comment>
<macro><name>AP_DECLARE</name><argument_list>(<argument>int</argument>)</argument_list></macro> <macro><name>ap_getline</name><argument_list>(<argument>char *s</argument>, <argument>int n</argument>, <argument>request_rec *r</argument>, <argument>int flags</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

<comment type="block">/**
 * Get the next line of input for the request
 *
 * Note: on ASCII boxes, ap_rgetline is a macro which simply calls
 *       ap_rgetline_core to get the line of input.
 *
 *       on EBCDIC boxes, ap_rgetline is a wrapper function which
 *       translates ASCII protocol lines to the local EBCDIC code page
 *       after getting the line of input.
 *
 * @param s Pointer to the pointer to the buffer into which the line
 *          should be read; if *s==NULL, a buffer of the necessary size
 *          to hold the data will be allocated from the request pool
 * @param n The size of the buffer
 * @param read The length of the line.
 * @param r The request
 * @param flags Bit flag of multiple parsing options
 *              AP_GETLINE_FOLD Whether to merge continuation lines
 *              AP_GETLINE_CRLF Whether line ends must be in the form CR LF
 * @param bb Working brigade to use when reading buckets
 * @return APR_SUCCESS, if successful
 *         APR_ENOSPC, if the line is too big to fit in the buffer
 *         Other errors where appropriate
 */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>APR_CHARSET_EBCDIC</name></expr></cpp:if>
<macro><name>AP_DECLARE</name><argument_list>(<argument>apr_status_t</argument>)</argument_list></macro> <macro><name>ap_rgetline</name><argument_list>(<argument>char **s</argument>, <argument>apr_size_t n</argument>,
                                     <argument>apr_size_t *read</argument>,
                                     <argument>request_rec *r</argument>, <argument>int flags</argument>,
                                     <argument>apr_bucket_brigade *bb</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else> <comment type="block">/* ASCII box */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ap_rgetline</name><parameter_list>(<param><type><name>s</name></type></param>, <param><type><name>n</name></type></param>, <param><type><name>read</name></type></param>, <param><type><name>r</name></type></param>, <param><type><name>fold</name></type></param>, <param><type><name>bb</name></type></param>)</parameter_list></cpp:macro> \
        <cpp:value>ap_rgetline_core((s), (n), (read), (r), (fold), (bb))</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/** @see ap_rgetline */</comment>
<macro><name>AP_DECLARE</name><argument_list>(<argument>apr_status_t</argument>)</argument_list></macro> <macro><name>ap_rgetline_core</name><argument_list>(<argument>char **s</argument>, <argument>apr_size_t n</argument>,
                                          <argument>apr_size_t *read</argument>,
                                          <argument>request_rec *r</argument>, <argument>int flags</argument>,
                                          <argument>apr_bucket_brigade *bb</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

<comment type="block">/**
 * Get the method number associated with the given string, assumed to
 * contain an HTTP method.  Returns M_INVALID if not recognized.
 * @param method A string containing a valid HTTP method
 * @return The method number
 */</comment>
<macro><name>AP_DECLARE</name><argument_list>(<argument>int</argument>)</argument_list></macro> <expr_stmt><expr><call><name>ap_method_number_of</name><argument_list>(<argument><expr>const <name>char</name> *<name>method</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/**
 * Get the method name associated with the given internal method
 * number.  Returns NULL if not recognized.
 * @param p A pool to use for temporary allocations.
 * @param methnum An integer value corresponding to an internal method number
 * @return The name corresponding to the method number
 */</comment>
<macro><name>AP_DECLARE</name><argument_list>(<argument>const char *</argument>)</argument_list></macro> <macro><name>ap_method_name_of</name><argument_list>(<argument>apr_pool_t *p</argument>, <argument>int methnum</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>


<comment type="block">/* Hooks */</comment>
<comment type="block">/*
 * pre_read_request --- run right before read_request_line(),
 *                  and not run during any subrequests.
 */</comment>
<comment type="block">/**
 * This hook allows modules to affect the request or connection immediately before
 * the request has been read, and before any other phases have been processes.
 * @param r The current request of the soon-to-be-read request
 * @param c The connection
 * @return None/void
 */</comment>
<macro><name>AP_DECLARE_HOOK</name><argument_list>(<argument>void</argument>,<argument>pre_read_request</argument>,<argument>(request_rec *r, conn_rec *c)</argument>)</argument_list></macro>

<comment type="block">/*
 * post_read_request --- run right after read_request or internal_redirect,
 *                  and not run during any subrequests.
 */</comment>
<comment type="block">/**
 * This hook allows modules to affect the request immediately after the request
 * has been read, and before any other phases have been processes.  This allows
 * modules to make decisions based upon the input header fields
 * @param r The current request
 * @return OK or DECLINED
 */</comment>
<macro><name>AP_DECLARE_HOOK</name><argument_list>(<argument>int</argument>,<argument>post_read_request</argument>,<argument>(request_rec *r)</argument>)</argument_list></macro>

<comment type="block">/**
 * This hook allows modules to perform any module-specific logging activities
 * over and above the normal server things.
 * @param r The current request
 * @return OK, DECLINED, or HTTP_...
 */</comment>
<macro><name>AP_DECLARE_HOOK</name><argument_list>(<argument>int</argument>,<argument>log_transaction</argument>,<argument>(request_rec *r)</argument>)</argument_list></macro>

<comment type="block">/**
 * This hook allows modules to retrieve the http scheme for a request.  This
 * allows Apache modules to easily extend the schemes that Apache understands
 * @param r The current request
 * @return The http scheme from the request
 */</comment>
<macro><name>AP_DECLARE_HOOK</name><argument_list>(<argument>const char *</argument>,<argument>http_scheme</argument>,<argument>(const request_rec *r)</argument>)</argument_list></macro>

<comment type="block">/**
 * Return the default port from the current request
 * @param r The current request
 * @return The current port
 */</comment>
<macro><name>AP_DECLARE_HOOK</name><argument_list>(<argument>apr_port_t</argument>,<argument>default_port</argument>,<argument>(const request_rec *r)</argument>)</argument_list></macro>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AP_PROTOCOL_HTTP1</name></cpp:macro>		<cpp:value>"http/1.1"</cpp:value></cpp:define>

<comment type="block">/**
 * Determine the list of protocols available for a connection/request. This may
 * be collected with or without any request sent, in which case the request is 
 * NULL. Or it may be triggered by the request received, e.g. through the 
 * "Upgrade" header.
 *
 * This hook will be run whenever protocols are being negotiated (ALPN as
 * one example). It may also be invoked at other times, e.g. when the server
 * wants to advertise protocols it is capable of switching to.
 * 
 * The identifiers for protocols are taken from the TLS extension type ALPN:
 * https://www.iana.org/assignments/tls-extensiontype-values/tls-extensiontype-values.xml
 *
 * If no protocols are added to the proposals, the server not perform any
 * switch. If the protocol selected from the proposals is the protocol
 * already in place, also no protocol switch will be invoked.
 *
 * The client may already have announced the protocols it is willing to
 * accept. These will then be listed as offers. This parameter may also
 * be NULL, indicating that offers from the client are not known and
 * the hooks should propose all protocols that are valid for the
 * current connection/request.
 *
 * All hooks are run, unless one returns an error. Proposals may contain
 * duplicates. The order in which proposals are added is usually ignored.
 * 
 * @param c The current connection
 * @param r The current request or NULL
 * @param s The server/virtual host selected
 * @param offers A list of protocol identifiers offered by the client or
 *               NULL to indicated that the hooks are free to propose 
 * @param proposals The list of protocol identifiers proposed by the hooks
 * @return OK or DECLINED
 * @bug This API or implementation and order of operations should be considered
 * experimental and will continue to evolve in future 2.4 releases, with
 * a corresponding minor module magic number (MMN) bump to indicate the
 * API revision level.
 */</comment>
<macro><name>AP_DECLARE_HOOK</name><argument_list>(<argument>int</argument>,<argument>protocol_propose</argument>,<argument>(conn_rec *c, request_rec *r,
                                      server_rec *s,
                                      const apr_array_header_t *offers,
                                      apr_array_header_t *proposals)</argument>)</argument_list></macro>

<comment type="block">/**
 * Perform a protocol switch on the connection. The exact requirements for
 * that depend on the protocol in place and the one switched to. The first 
 * protocol module to handle the switch is the last module run.
 * 
 * For a connection level switch (r == NULL), the handler must on return
 * leave the conn_rec in a state suitable for processing the switched
 * protocol, e.g. correct filters in place.
 *
 * For a request triggered switch (r != NULL), the protocol switch is done
 * before the response is sent out. When switching from "http/1.1" via Upgrade
 * header, the 101 intermediate response will have been sent. The
 * hook needs then to process the connection until it can be closed. Which
 * the server will enforce on hook return.
 * Any error the hook might encounter must already be sent by the hook itself
 * to the client in whatever form the new protocol requires.
 *
 * @param c The current connection
 * @param r The current request or NULL
 * @param s The server/virtual host selected
 * @param choices A list of protocol identifiers, normally the clients whishes
 * @param proposals the list of protocol identifiers proposed by the hooks
 * @return OK or DECLINED
 * @bug This API or implementation and order of operations should be considered
 * experimental and will continue to evolve in future 2.4 releases, with
 * a corresponding minor module magic number (MMN) bump to indicate the
 * API revision level.
 */</comment>
<macro><name>AP_DECLARE_HOOK</name><argument_list>(<argument>int</argument>,<argument>protocol_switch</argument>,<argument>(conn_rec *c, request_rec *r,
                                     server_rec *s,
                                     const char *protocol)</argument>)</argument_list></macro>

<comment type="block">/**
 * Return the protocol used on the connection. Modules implementing
 * protocol switching must register here and return the correct protocol
 * identifier for connections they switched.
 *
 * To find out the protocol for the current connection, better call
 * @see ap_get_protocol which internally uses this hook.
 *
 * @param c The current connection
 * @return The identifier of the protocol in place or NULL
 * @bug This API or implementation and order of operations should be considered
 * experimental and will continue to evolve in future 2.4 releases, with
 * a corresponding minor module magic number (MMN) bump to indicate the
 * API revision level.
 */</comment>
<macro><name>AP_DECLARE_HOOK</name><argument_list>(<argument>const char *</argument>,<argument>protocol_get</argument>,<argument>(const conn_rec *c)</argument>)</argument_list></macro>

<comment type="block">/**
 * Get the protocols that the connection and optional request may
 * upgrade to - besides the protocol currently active on the connection. These
 * values may be used to announce to a client what choices it has.
 *
 * If report_all == 0, only protocols more preferable than the one currently
 * being used, are reported. Otherwise, all available protocols beside the
 * current one are being reported.
 *
 * @param c The current connection
 * @param r The current request or NULL
 * @param s The server/virtual host selected or NULL
 * @param report_all include also protocols less preferred than the current one
 * @param pupgrades on return, possible protocols to upgrade to in descending order 
 *                 of preference. Maybe NULL if none are available.    
 * @bug This API or implementation and order of operations should be considered
 * experimental and will continue to evolve in future 2.4 releases, with
 * a corresponding minor module magic number (MMN) bump to indicate the
 * API revision level.
 */</comment>
<macro><name>AP_DECLARE</name><argument_list>(<argument>apr_status_t</argument>)</argument_list></macro> <macro><name>ap_get_protocol_upgrades</name><argument_list>(<argument>conn_rec *c</argument>, <argument>request_rec *r</argument>, 
                                                  <argument>server_rec *s</argument>, <argument>int report_all</argument>, 
                                                  <argument>const apr_array_header_t **pupgrades</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
                                                  
<comment type="block">/**
 * Select a protocol for the given connection and optional request. Will return
 * the protocol identifier selected which may be the protocol already in place
 * on the connection. The selected protocol will be NULL if non of the given
 * choices could be agreed upon (e.g. no proposal as made).
 *
 * A special case is where the choices itself is NULL (instead of empty). In
 * this case there are no restrictions imposed on protocol selection.
 *
 * @param c The current connection
 * @param r The current request or NULL
 * @param s The server/virtual host selected
 * @param choices A list of protocol identifiers, normally the clients whishes
 * @return The selected protocol or NULL if no protocol could be agreed upon
 * @bug This API or implementation and order of operations should be considered
 * experimental and will continue to evolve in future 2.4 releases, with
 * a corresponding minor module magic number (MMN) bump to indicate the
 * API revision level.
 */</comment>
<macro><name>AP_DECLARE</name><argument_list>(<argument>const char *</argument>)</argument_list></macro> <expr_stmt><expr><call><name>ap_select_protocol</name><argument_list>(<argument><expr><name>conn_rec</name> *<name>c</name></expr></argument>, <argument><expr><name>request_rec</name> *<name>r</name></expr></argument>, 
                                            <argument><expr><name>server_rec</name> *<name>s</name></expr></argument>,
                                            <argument><expr>const <name>apr_array_header_t</name> *<name>choices</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/**
 * Perform the actual protocol switch. The protocol given must have been
 * selected before on the very same connection and request pair.
 *
 * @param c The current connection
 * @param r The current request or NULL
 * @param s The server/virtual host selected
 * @param protocol the protocol to switch to
 * @return APR_SUCCESS, if caller may continue processing as usual
 *         APR_EOF,     if caller needs to stop processing the connection
 *         APR_EINVAL,  if the protocol is already in place
 *         APR_NOTIMPL, if no module performed the switch
 *         Other errors where appropriate
 * @bug This API or implementation and order of operations should be considered
 * experimental and will continue to evolve in future 2.4 releases, with
 * a corresponding minor module magic number (MMN) bump to indicate the
 * API revision level.
 */</comment>
<macro><name>AP_DECLARE</name><argument_list>(<argument>apr_status_t</argument>)</argument_list></macro> <expr_stmt><expr><call><name>ap_switch_protocol</name><argument_list>(<argument><expr><name>conn_rec</name> *<name>c</name></expr></argument>, <argument><expr><name>request_rec</name> *<name>r</name></expr></argument>, 
                                            <argument><expr><name>server_rec</name> *<name>s</name></expr></argument>,
                                            <argument><expr>const <name>char</name> *<name>protocol</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/**
 * Call the protocol_get hook to determine the protocol currently in use
 * for the given connection.
 *
 * Unless another protocol has been switch to, will default to
 * @see AP_PROTOCOL_HTTP1 and modules implementing a  new protocol must
 * report a switched connection via the protocol_get hook.
 *
 * @param c The connection to determine the protocol for
 * @return the protocol in use, never NULL
 * @bug This API or implementation and order of operations should be considered
 * experimental and will continue to evolve in future 2.4 releases, with
 * a corresponding minor module magic number (MMN) bump to indicate the
 * API revision level.
 */</comment>
<macro><name>AP_DECLARE</name><argument_list>(<argument>const char *</argument>)</argument_list></macro> <expr_stmt><expr><call><name>ap_get_protocol</name><argument_list>(<argument><expr><name>conn_rec</name> *<name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/**
 * Check if the given protocol is an allowed choice on the given
 * combination of connection, request and server. 
 *
 * When server is NULL, it is taken from request_rec, unless
 * request_rec is NULL. Then it is taken from the connection base
 * server.
 *
 * @param c The current connection
 * @param r The current request or NULL
 * @param s The server/virtual host selected or NULL
 * @param protocol the protocol to switch to
 * @return != 0 iff protocol is allowed
 * @bug This API or implementation and order of operations should be considered
 * experimental and will continue to evolve in future 2.4 releases, with
 * a corresponding minor module magic number (MMN) bump to indicate the
 * API revision level.
 */</comment>
<macro><name>AP_DECLARE</name><argument_list>(<argument>int</argument>)</argument_list></macro> <expr_stmt><expr><call><name>ap_is_allowed_protocol</name><argument_list>(<argument><expr><name>conn_rec</name> *<name>c</name></expr></argument>, <argument><expr><name>request_rec</name> *<name>r</name></expr></argument>,
                                       <argument><expr><name>server_rec</name> *<name>s</name></expr></argument>, <argument><expr>const <name>char</name> *<name>protocol</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/** @see ap_bucket_type_error */</comment>
<typedef>typedef <type>struct <name>ap_bucket_error</name></type> <name>ap_bucket_error</name>;</typedef>

<comment type="block">/**
 * @struct ap_bucket_error
 * @brief  A bucket referring to an HTTP error
 *
 * This bucket can be passed down the filter stack to indicate that an
 * HTTP error occurred while running a filter.  In order for this bucket
 * to be used successfully, it MUST be sent as the first bucket in the
 * first brigade to be sent from a given filter.
 */</comment>
<struct>struct <name>ap_bucket_error</name> <block>{
    <comment type="block">/** Number of buckets using this memory */</comment>
    <decl_stmt><decl><type><name>apr_bucket_refcount</name></type> <name>refcount</name></decl>;</decl_stmt>
    <comment type="block">/** The error code */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>status</name></decl>;</decl_stmt>
    <comment type="block">/** The error string */</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name>    *</type><name>data</name></decl>;</decl_stmt>
}</block>;</struct>

<comment type="block">/** @see ap_bucket_type_error */</comment>
<decl_stmt><decl><type><name>AP_DECLARE_DATA</name> <specifier>extern</specifier> <specifier>const</specifier> <name>apr_bucket_type_t</name></type> <name>ap_bucket_type_error</name></decl>;</decl_stmt>

<comment type="block">/**
 * Determine if a bucket is an error bucket
 * @param e The bucket to inspect
 * @return true or false
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AP_BUCKET_IS_ERROR</name><parameter_list>(<param><type><name>e</name></type></param>)</parameter_list></cpp:macro>         <cpp:value>(e-&gt;type == &amp;ap_bucket_type_error)</cpp:value></cpp:define>

<comment type="block">/**
 * Make the bucket passed in an error bucket
 * @param b The bucket to make into an error bucket
 * @param error The HTTP error code to put in the bucket.
 * @param buf An optional error string to put in the bucket.
 * @param p A pool to allocate out of.
 * @return The new bucket, or NULL if allocation failed
 */</comment>
<macro><name>AP_DECLARE</name><argument_list>(<argument>apr_bucket *</argument>)</argument_list></macro> <macro><name>ap_bucket_error_make</name><argument_list>(<argument>apr_bucket *b</argument>, <argument>int error</argument>,
                <argument>const char *buf</argument>, <argument>apr_pool_t *p</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

<comment type="block">/**
 * Create a bucket referring to an HTTP error.
 * @param error The HTTP error code to put in the bucket.
 * @param buf An optional error string to put in the bucket.
 * @param p A pool to allocate the error string out of.
 * @param list The bucket allocator from which to allocate the bucket
 * @return The new bucket, or NULL if allocation failed
 */</comment>
<macro><name>AP_DECLARE</name><argument_list>(<argument>apr_bucket *</argument>)</argument_list></macro> <macro><name>ap_bucket_error_create</name><argument_list>(<argument>int error</argument>, <argument>const char *buf</argument>,
                                                <argument>apr_pool_t *p</argument>,
                                                <argument>apr_bucket_alloc_t *list</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

<macro><name>AP_DECLARE_NONSTD</name><argument_list>(<argument>apr_status_t</argument>)</argument_list></macro> <expr_stmt><expr><call><name>ap_byterange_filter</name><argument_list>(<argument><expr><name>ap_filter_t</name> *<name>f</name></expr></argument>, <argument><expr><name>apr_bucket_brigade</name> *<name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<macro><name>AP_DECLARE_NONSTD</name><argument_list>(<argument>apr_status_t</argument>)</argument_list></macro> <expr_stmt><expr><call><name>ap_http_header_filter</name><argument_list>(<argument><expr><name>ap_filter_t</name> *<name>f</name></expr></argument>, <argument><expr><name>apr_bucket_brigade</name> *<name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<macro><name>AP_DECLARE_NONSTD</name><argument_list>(<argument>apr_status_t</argument>)</argument_list></macro> <expr_stmt><expr><call><name>ap_content_length_filter</name><argument_list>(<argument><expr><name>ap_filter_t</name> *</expr></argument>,
                                                              <argument><expr><name>apr_bucket_brigade</name> *</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<macro><name>AP_DECLARE_NONSTD</name><argument_list>(<argument>apr_status_t</argument>)</argument_list></macro> <expr_stmt><expr><call><name>ap_old_write_filter</name><argument_list>(<argument><expr><name>ap_filter_t</name> *<name>f</name></expr></argument>, <argument><expr><name>apr_bucket_brigade</name> *<name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/**
 * Sett up the protocol fields for subsidiary requests
 * @param rnew New Sub Request
 * @param r current request
 */</comment>
<macro><name>AP_DECLARE</name><argument_list>(<argument>void</argument>)</argument_list></macro> <expr_stmt><expr><call><name>ap_set_sub_req_protocol</name><argument_list>(<argument><expr><name>request_rec</name> *<name>rnew</name></expr></argument>, <argument><expr>const <name>request_rec</name> *<name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/**
 * A wrapup function to keep the internal accounting straight.
 * Indicates that there is no more content coming.
 * @param sub_r Subrequest that is now compete
 */</comment>
<macro><name>AP_DECLARE</name><argument_list>(<argument>void</argument>)</argument_list></macro> <expr_stmt><expr><call><name>ap_finalize_sub_req_protocol</name><argument_list>(<argument><expr><name>request_rec</name> *<name>sub_r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/**
 * Send an interim (HTTP 1xx) response immediately.
 * @param r The request
 * @param send_headers Whether to send&amp;clear headers in r-&gt;headers_out
 */</comment>
<macro><name>AP_DECLARE</name><argument_list>(<argument>void</argument>)</argument_list></macro> <macro><name>ap_send_interim_response</name><argument_list>(<argument>request_rec *r</argument>, <argument>int send_headers</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__cplusplus</name></cpp:ifdef>
}</block></extern>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>  <comment type="block">/* !APACHE_HTTP_PROTOCOL_H */</comment>
<comment type="block">/** @} */</comment>
</unit>
