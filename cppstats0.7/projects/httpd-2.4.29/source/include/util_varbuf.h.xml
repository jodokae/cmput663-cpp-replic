<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C" filename="projects/httpd-2.4.29/include/util_varbuf.h"><comment type="block">/* Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */</comment>

<comment type="block">/**
 * @file util_varbuf.h
 * @brief Apache resizable variable length buffer library
 *
 * @defgroup APACHE_CORE_VARBUF Variable length buffer library
 * @ingroup APACHE_CORE
 *
 * This set of functions provides resizable buffers. While the primary
 * usage is with NUL-terminated strings, most functions also work with
 * arbitrary binary data.
 * 
 * @{
 */</comment>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>AP_VARBUF_H</name></cpp:ifndef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AP_VARBUF_H</name></cpp:macro></cpp:define>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"apr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"apr_allocator.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"httpd.h"</cpp:file></cpp:include>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__cplusplus</name></cpp:ifdef>
<extern>extern "C" <block>{
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AP_VARBUF_UNKNOWN</name></cpp:macro> <cpp:value>APR_SIZE_MAX</cpp:value></cpp:define>
<struct_decl>struct <name>ap_varbuf_info</name>;</struct_decl>

<comment type="block">/** A resizable buffer. */</comment>
<struct>struct <name>ap_varbuf</name> <block>{
    <comment type="block">/** The actual buffer; will point to a const '\\0' if avail == 0 and
     *  to memory of the same lifetime as the pool otherwise. */</comment>
    <decl_stmt><decl><type><name>char</name> *</type><name>buf</name></decl>;</decl_stmt>

    <comment type="block">/** Allocated size of the buffer (minus one for the final \\0);
     *  must only be changed using ap_varbuf_grow(). */</comment>
    <decl_stmt><decl><type><name>apr_size_t</name></type> <name>avail</name></decl>;</decl_stmt>

    <comment type="block">/** Length of string in buffer, or AP_VARBUF_UNKNOWN. This determines how
     *  much memory is copied by ap_varbuf_grow() and where
     *  ap_varbuf_strmemcat() will append to the buffer. */</comment>
    <decl_stmt><decl><type><name>apr_size_t</name></type> <name>strlen</name></decl>;</decl_stmt>

    <comment type="block">/** The pool for memory allocations and for registering the cleanup;
     *  the buffer memory will be released when this pool is cleared. */</comment>
    <decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl>;</decl_stmt>

    <comment type="block">/** Opaque info for memory allocation. */</comment>
    <decl_stmt><decl><type>struct <name>ap_varbuf_info</name> *</type><name>info</name></decl>;</decl_stmt>
}</block>;</struct>

<comment type="block">/**
 * Initialize a resizable buffer. It is safe to re-initialize a previously
 * used ap_varbuf. The old buffer will be released when the corresponding
 * pool is cleared. The buffer remains usable until the pool is cleared,
 * even if the ap_varbuf was located on the stack and has gone out of scope.
 * @param   pool        The pool to allocate small buffers from and to register
 *                      the cleanup with
 * @param   vb          Pointer to the ap_varbuf struct
 * @param   init_size   The initial size of the buffer (see ap_varbuf_grow() for
 *                      details)
 */</comment>
<macro><name>AP_DECLARE</name><argument_list>(<argument>void</argument>)</argument_list></macro> <macro><name>ap_varbuf_init</name><argument_list>(<argument>apr_pool_t *pool</argument>, <argument>struct ap_varbuf *vb</argument>,
                                <argument>apr_size_t init_size</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

<comment type="block">/**
 * Grow a resizable buffer. If the vb-&gt;buf cannot be grown in place, it will
 * be reallocated and the first vb-&gt;strlen + 1 bytes of memory will be copied
 * to the new location. If vb-&gt;strlen == AP_VARBUF_UNKNOWN, the whole buffer
 * is copied.
 * @param   vb          Pointer to the ap_varbuf struct
 * @param   new_size    The minimum new size of the buffer
 * @note ap_varbuf_grow() will usually at least double vb-&gt;buf's size with
 *       every invocation in order to reduce reallocations.
 * @note ap_varbuf_grow() will use pool memory for small and allocator
 *       mem nodes for larger allocations.
 * @note ap_varbuf_grow() will call vb-&gt;pool's abort function if out of memory.
 */</comment>
<macro><name>AP_DECLARE</name><argument_list>(<argument>void</argument>)</argument_list></macro> <macro><name>ap_varbuf_grow</name><argument_list>(<argument>struct ap_varbuf *vb</argument>, <argument>apr_size_t new_size</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

<comment type="block">/**
 * Release memory from a ap_varbuf immediately, if possible.
 * This allows to free large buffers before the corresponding pool is
 * cleared. Only larger allocations using mem nodes will be freed.
 * @param   vb          Pointer to the ap_varbuf struct
 * @note After ap_varbuf_free(), vb must not be used unless ap_varbuf_init()
 *       is called again.
 */</comment>
<macro><name>AP_DECLARE</name><argument_list>(<argument>void</argument>)</argument_list></macro> <expr_stmt><expr><call><name>ap_varbuf_free</name><argument_list>(<argument>struct <expr><name>ap_varbuf</name> *<name>vb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/**
 * Concatenate a string to an ap_varbuf. vb-&gt;strlen determines where
 * the string is appended in the buffer. If vb-&gt;strlen == AP_VARBUF_UNKNOWN,
 * the string will be appended at the first NUL byte in the buffer.
 * If len == 0, ap_varbuf_strmemcat() does nothing.
 * @param   vb      Pointer to the ap_varbuf struct
 * @param   str     The string to append; must be at least len bytes long
 * @param   len     The number of characters of *str to concatenate to the buf
 * @note vb-&gt;strlen will be set to the length of the new string
 * @note if len != 0, vb-&gt;buf will always be NUL-terminated
 */</comment>
<macro><name>AP_DECLARE</name><argument_list>(<argument>void</argument>)</argument_list></macro> <macro><name>ap_varbuf_strmemcat</name><argument_list>(<argument>struct ap_varbuf *vb</argument>, <argument>const char *str</argument>,
                                     <argument>int len</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

<comment type="block">/**
 * Duplicate an ap_varbuf's content into pool memory.
 * @param   p           The pool to allocate from
 * @param   vb          The ap_varbuf to copy from
 * @param   prepend     An optional buffer to prepend (may be NULL)
 * @param   prepend_len Length of prepend
 * @param   append      An optional buffer to append (may be NULL)
 * @param   append_len  Length of append
 * @param   new_len     Where to store the length of the resulting string
 *                      (may be NULL)
 * @return The new string
 * @note ap_varbuf_pdup() uses vb-&gt;strlen to determine how much memory to
 *       copy. It works even if 0-bytes are embedded in vb-&gt;buf, prepend, or
 *       append.
 * @note If vb-&gt;strlen equals AP_VARBUF_UNKNOWN, it will be set to
 *       strlen(vb-&gt;buf).
 */</comment>
<macro><name>AP_DECLARE</name><argument_list>(<argument>char *</argument>)</argument_list></macro> <macro><name>ap_varbuf_pdup</name><argument_list>(<argument>apr_pool_t *p</argument>, <argument>struct ap_varbuf *vb</argument>,
                                  <argument>const char *prepend</argument>, <argument>apr_size_t prepend_len</argument>,
                                  <argument>const char *append</argument>, <argument>apr_size_t append_len</argument>,
                                  <argument>apr_size_t *new_len</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>


<comment type="block">/**
 * Concatenate a string to an ap_varbuf.
 * @param   vb      Pointer to the ap_varbuf struct
 * @param   str     The string to append
 * @note vb-&gt;strlen will be set to the length of the new string
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ap_varbuf_strcat</name><parameter_list>(<param><type><name>vb</name></type></param>, <param><type><name>str</name></type></param>)</parameter_list></cpp:macro> <cpp:value>ap_varbuf_strmemcat(vb, str, strlen(str))</cpp:value></cpp:define>

<comment type="block">/**
 * Perform string substitutions based on regexp match, using an ap_varbuf.
 * This function behaves like ap_pregsub(), but appends to an ap_varbuf
 * instead of allocating the result from a pool.
 * @param   vb      The ap_varbuf to which the string will be appended
 * @param   input   An arbitrary string containing $1 through $9. These are
 *                  replaced with the corresponding matched sub-expressions
 * @param   source  The string that was originally matched to the regex
 * @param   nmatch  The nmatch returned from ap_pregex
 * @param   pmatch  The pmatch array returned from ap_pregex
 * @param   maxlen  The maximum string length to append to vb, 0 for unlimited
 * @return APR_SUCCESS if successful
 * @note Just like ap_pregsub(), this function does not copy the part of
 *       *source before the matching part (i.e. the first pmatch[0].rm_so
 *       characters).
 * @note If vb-&gt;strlen equals AP_VARBUF_UNKNOWN, it will be set to
 *       strlen(vb-&gt;buf) first.
 */</comment>
<macro><name>AP_DECLARE</name><argument_list>(<argument>apr_status_t</argument>)</argument_list></macro> <macro><name>ap_varbuf_regsub</name><argument_list>(<argument>struct ap_varbuf *vb</argument>,
                                          <argument>const char *input</argument>,
                                          <argument>const char *source</argument>,
                                          <argument>apr_size_t nmatch</argument>,
                                          <argument>ap_regmatch_t pmatch[]</argument>,
                                          <argument>apr_size_t maxlen</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

<comment type="block">/**
 * Read a line from an ap_configfile_t and append it to an ap_varbuf.
 * @param   vb      Pointer to the ap_varbuf struct
 * @param   cfp     Pointer to the ap_configfile_t
 * @param   max_len Maximum line length, including leading/trailing whitespace
 * @return See ap_cfg_getline()
 * @note vb-&gt;strlen will be set to the length of the line
 * @note If vb-&gt;strlen equals AP_VARBUF_UNKNOWN, it will be set to
 *       strlen(vb-&gt;buf) first.
 */</comment>
<macro><name>AP_DECLARE</name><argument_list>(<argument>apr_status_t</argument>)</argument_list></macro> <macro><name>ap_varbuf_cfg_getline</name><argument_list>(<argument>struct ap_varbuf *vb</argument>,
                                               <argument>ap_configfile_t *cfp</argument>,
                                               <argument>apr_size_t max_len</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__cplusplus</name></cpp:ifdef>
}</block></extern>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>  <comment type="block">/* !AP_VARBUF_H */</comment>
<comment type="block">/** @} */</comment>
</unit>
