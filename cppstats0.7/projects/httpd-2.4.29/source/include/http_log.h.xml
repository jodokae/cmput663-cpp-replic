<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C" filename="projects/httpd-2.4.29/include/http_log.h"><comment type="block">/* Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */</comment>

<comment type="block">/**
 * @file  http_log.h
 * @brief Apache Logging library
 *
 * @defgroup APACHE_CORE_LOG Logging library
 * @ingroup  APACHE_CORE
 * @{
 */</comment>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>APACHE_HTTP_LOG_H</name></cpp:ifndef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>APACHE_HTTP_LOG_H</name></cpp:macro></cpp:define>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__cplusplus</name></cpp:ifdef>
<extern>extern "C" <block>{
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"apr_thread_proc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"http_config.h"</cpp:file></cpp:include>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_SYSLOG</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;syslog.h&gt;</cpp:file></cpp:include>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>LOG_PRIMASK</name></cpp:ifndef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LOG_PRIMASK</name></cpp:macro> <cpp:value>7</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>APLOG_EMERG</name></cpp:macro>     <cpp:value>LOG_EMERG</cpp:value></cpp:define>       <comment type="block">/* system is unusable */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>APLOG_ALERT</name></cpp:macro>     <cpp:value>LOG_ALERT</cpp:value></cpp:define>       <comment type="block">/* action must be taken immediately */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>APLOG_CRIT</name></cpp:macro>      <cpp:value>LOG_CRIT</cpp:value></cpp:define>        <comment type="block">/* critical conditions */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>APLOG_ERR</name></cpp:macro>       <cpp:value>LOG_ERR</cpp:value></cpp:define>         <comment type="block">/* error conditions */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>APLOG_WARNING</name></cpp:macro>   <cpp:value>LOG_WARNING</cpp:value></cpp:define>     <comment type="block">/* warning conditions */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>APLOG_NOTICE</name></cpp:macro>    <cpp:value>LOG_NOTICE</cpp:value></cpp:define>      <comment type="block">/* normal but significant condition */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>APLOG_INFO</name></cpp:macro>      <cpp:value>LOG_INFO</cpp:value></cpp:define>        <comment type="block">/* informational */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>APLOG_DEBUG</name></cpp:macro>     <cpp:value>LOG_DEBUG</cpp:value></cpp:define>       <comment type="block">/* debug-level messages */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>APLOG_TRACE1</name></cpp:macro>   <cpp:value>(LOG_DEBUG + 1)</cpp:value></cpp:define>  <comment type="block">/* trace-level 1 messages */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>APLOG_TRACE2</name></cpp:macro>   <cpp:value>(LOG_DEBUG + 2)</cpp:value></cpp:define>  <comment type="block">/* trace-level 2 messages */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>APLOG_TRACE3</name></cpp:macro>   <cpp:value>(LOG_DEBUG + 3)</cpp:value></cpp:define>  <comment type="block">/* trace-level 3 messages */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>APLOG_TRACE4</name></cpp:macro>   <cpp:value>(LOG_DEBUG + 4)</cpp:value></cpp:define>  <comment type="block">/* trace-level 4 messages */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>APLOG_TRACE5</name></cpp:macro>   <cpp:value>(LOG_DEBUG + 5)</cpp:value></cpp:define>  <comment type="block">/* trace-level 5 messages */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>APLOG_TRACE6</name></cpp:macro>   <cpp:value>(LOG_DEBUG + 6)</cpp:value></cpp:define>  <comment type="block">/* trace-level 6 messages */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>APLOG_TRACE7</name></cpp:macro>   <cpp:value>(LOG_DEBUG + 7)</cpp:value></cpp:define>  <comment type="block">/* trace-level 7 messages */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>APLOG_TRACE8</name></cpp:macro>   <cpp:value>(LOG_DEBUG + 8)</cpp:value></cpp:define>  <comment type="block">/* trace-level 8 messages */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>APLOG_LEVELMASK</name></cpp:macro> <cpp:value>15</cpp:value></cpp:define>     <comment type="block">/* mask off the level value */</comment>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>APLOG_EMERG</name></cpp:macro>      <cpp:value>0</cpp:value></cpp:define>     <comment type="block">/* system is unusable */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>APLOG_ALERT</name></cpp:macro>      <cpp:value>1</cpp:value></cpp:define>     <comment type="block">/* action must be taken immediately */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>APLOG_CRIT</name></cpp:macro>       <cpp:value>2</cpp:value></cpp:define>     <comment type="block">/* critical conditions */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>APLOG_ERR</name></cpp:macro>        <cpp:value>3</cpp:value></cpp:define>     <comment type="block">/* error conditions */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>APLOG_WARNING</name></cpp:macro>    <cpp:value>4</cpp:value></cpp:define>     <comment type="block">/* warning conditions */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>APLOG_NOTICE</name></cpp:macro>     <cpp:value>5</cpp:value></cpp:define>     <comment type="block">/* normal but significant condition */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>APLOG_INFO</name></cpp:macro>       <cpp:value>6</cpp:value></cpp:define>     <comment type="block">/* informational */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>APLOG_DEBUG</name></cpp:macro>      <cpp:value>7</cpp:value></cpp:define>     <comment type="block">/* debug-level messages */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>APLOG_TRACE1</name></cpp:macro>     <cpp:value>8</cpp:value></cpp:define>     <comment type="block">/* trace-level 1 messages */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>APLOG_TRACE2</name></cpp:macro>     <cpp:value>9</cpp:value></cpp:define>     <comment type="block">/* trace-level 2 messages */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>APLOG_TRACE3</name></cpp:macro>    <cpp:value>10</cpp:value></cpp:define>     <comment type="block">/* trace-level 3 messages */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>APLOG_TRACE4</name></cpp:macro>    <cpp:value>11</cpp:value></cpp:define>     <comment type="block">/* trace-level 4 messages */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>APLOG_TRACE5</name></cpp:macro>    <cpp:value>12</cpp:value></cpp:define>     <comment type="block">/* trace-level 5 messages */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>APLOG_TRACE6</name></cpp:macro>    <cpp:value>13</cpp:value></cpp:define>     <comment type="block">/* trace-level 6 messages */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>APLOG_TRACE7</name></cpp:macro>    <cpp:value>14</cpp:value></cpp:define>     <comment type="block">/* trace-level 7 messages */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>APLOG_TRACE8</name></cpp:macro>    <cpp:value>15</cpp:value></cpp:define>     <comment type="block">/* trace-level 8 messages */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>APLOG_LEVELMASK</name></cpp:macro> <cpp:value>15</cpp:value></cpp:define>     <comment type="block">/* mask off the level value */</comment>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* APLOG_NOERRNO is ignored and should not be used.  It will be
 * removed in a future release of Apache.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>APLOG_NOERRNO</name></cpp:macro>           <cpp:value>(APLOG_LEVELMASK + 1)</cpp:value></cpp:define>

<comment type="block">/** Use APLOG_TOCLIENT on ap_log_rerror() to give content
 * handlers the option of including the error text in the
 * ErrorDocument sent back to the client. Setting APLOG_TOCLIENT
 * will cause the error text to be saved in the request_rec-&gt;notes
 * table, keyed to the string "error-notes", if and only if:
 * - the severity level of the message is APLOG_WARNING or greater
 * - there are no other "error-notes" set in request_rec-&gt;notes
 * Once error-notes is set, it is up to the content handler to
 * determine whether this text should be sent back to the client.
 * Note: Client generated text streams sent back to the client MUST
 * be escaped to prevent CSS attacks.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>APLOG_TOCLIENT</name></cpp:macro>          <cpp:value>((APLOG_LEVELMASK + 1) * 2)</cpp:value></cpp:define>

<comment type="block">/* normal but significant condition on startup, usually printed to stderr */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>APLOG_STARTUP</name></cpp:macro>           <cpp:value>((APLOG_LEVELMASK + 1) * 4)</cpp:value></cpp:define>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>DEFAULT_LOGLEVEL</name></cpp:ifndef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DEFAULT_LOGLEVEL</name></cpp:macro>        <cpp:value>APLOG_WARNING</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/**
 * APLOGNO() should be used at the start of the format string passed
 * to ap_log_error() and friends. The argument must be a 5 digit decimal
 * number. It creates a tag of the form "AH02182: "
 * See docs/log-message-tags/README for details.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>APLOGNO</name><parameter_list>(<param><type><name>n</name></type></param>)</parameter_list></cpp:macro>              <cpp:value>"AH" #n ": "</cpp:value></cpp:define>

<comment type="block">/**
 * APLOG_NO_MODULE may be passed as module_index to ap_log_error() and related
 * functions if the module causing the log message is not known. Normally this
 * should not be used directly. Use ::APLOG_MARK or ::APLOG_MODULE_INDEX
 * instead.
 *
 * @see APLOG_MARK
 * @see APLOG_MODULE_INDEX
 * @see ap_log_error
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>APLOG_NO_MODULE</name></cpp:macro>         <cpp:value>-1</cpp:value></cpp:define>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__cplusplus</name></cpp:ifdef>
<comment type="block">/**
 * C++ modules must invoke ::APLOG_USE_MODULE or ::AP_DECLARE_MODULE in
 * every file which uses ap_log_* before the first use of ::APLOG_MARK
 * or ::APLOG_MODULE_INDEX.
 * (C modules *should* do that as well, to enable module-specific log
 * levels. C modules need not obey the ordering, though).
 */</comment>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else> <comment type="block">/* __cplusplus */</comment>
<comment type="block">/**
 * Constant to store module_index for the current file.
 * Objects with static storage duration are set to NULL if not
 * initialized explicitly. This means that if aplog_module_index
 * is not initialized using the ::APLOG_USE_MODULE or the
 * ::AP_DECLARE_MODULE macro, we can safely fall back to
 * use ::APLOG_NO_MODULE. This variable will usually be optimized away.
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name> * <specifier>const</specifier></type> <name>aplog_module_index</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* __cplusplus */</comment>

<comment type="block">/**
 * APLOG_MODULE_INDEX contains the module_index of the current module if
 * it has been set via the ::APLOG_USE_MODULE or ::AP_DECLARE_MODULE macro.
 * Otherwise it contains ::APLOG_NO_MODULE (for example in unmodified httpd
 * 2.2 modules).
 *
 * If ::APLOG_MARK is used in ap_log_error() and related functions,
 * ::APLOG_MODULE_INDEX will be passed as module_index. In cases where
 * ::APLOG_MARK cannot be used, ::APLOG_MODULE_INDEX should normally be passed
 * as module_index.
 *
 * @see APLOG_MARK
 * @see ap_log_error
 */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__cplusplus</name></cpp:ifdef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>APLOG_MODULE_INDEX</name></cpp:macro> <cpp:value>(*aplog_module_index)</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else> <comment type="block">/* __cplusplus */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>APLOG_MODULE_INDEX</name></cpp:macro>  \
    <cpp:value>(aplog_module_index ? *aplog_module_index : APLOG_NO_MODULE)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* __cplusplus */</comment>

<comment type="block">/**
 * APLOG_MAX_LOGLEVEL can be defined to remove logging above some
 * specified level at compile time.
 *
 * This requires a C99 compiler.
 */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DOXYGEN</name></cpp:ifdef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>APLOG_MAX_LOGLEVEL</name></cpp:macro></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>APLOG_MAX_LOGLEVEL</name></cpp:ifndef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>APLOG_MODULE_IS_LEVEL</name><parameter_list>(<param><type><name>s</name></type></param>,<param><type><name>module_index</name></type></param>,<param><type><name>level</name></type></param>)</parameter_list></cpp:macro>              \
          <cpp:value>( (((level)&amp;APLOG_LEVELMASK) &lt;= APLOG_NOTICE) ||       \
            (s == NULL) ||                                       \
            (ap_get_server_module_loglevel(s, module_index)      \
             &gt;= ((level)&amp;APLOG_LEVELMASK) ) )</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>APLOG_C_MODULE_IS_LEVEL</name><parameter_list>(<param><type><name>c</name></type></param>,<param><type><name>module_index</name></type></param>,<param><type><name>level</name></type></param>)</parameter_list></cpp:macro>            \
          <cpp:value>( (((level)&amp;APLOG_LEVELMASK) &lt;= APLOG_NOTICE) ||       \
            (ap_get_conn_module_loglevel(c, module_index)        \
             &gt;= ((level)&amp;APLOG_LEVELMASK) ) )</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>APLOG_CS_MODULE_IS_LEVEL</name><parameter_list>(<param><type><name>c</name></type></param>,<param><type><name>s</name></type></param>,<param><type><name>module_index</name></type></param>,<param><type><name>level</name></type></param>)</parameter_list></cpp:macro>            \
          <cpp:value>( (((level)&amp;APLOG_LEVELMASK) &lt;= APLOG_NOTICE) ||          \
            (ap_get_conn_server_module_loglevel(c, s, module_index) \
             &gt;= ((level)&amp;APLOG_LEVELMASK) ) )</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>APLOG_R_MODULE_IS_LEVEL</name><parameter_list>(<param><type><name>r</name></type></param>,<param><type><name>module_index</name></type></param>,<param><type><name>level</name></type></param>)</parameter_list></cpp:macro>            \
          <cpp:value>( (((level)&amp;APLOG_LEVELMASK) &lt;= APLOG_NOTICE) ||       \
            (ap_get_request_module_loglevel(r, module_index)     \
             &gt;= ((level)&amp;APLOG_LEVELMASK) ) )</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>APLOG_MODULE_IS_LEVEL</name><parameter_list>(<param><type><name>s</name></type></param>,<param><type><name>module_index</name></type></param>,<param><type><name>level</name></type></param>)</parameter_list></cpp:macro>              \
        <cpp:value>( (((level)&amp;APLOG_LEVELMASK) &lt;= APLOG_MAX_LOGLEVEL) &amp;&amp;   \
          ( (((level)&amp;APLOG_LEVELMASK) &lt;= APLOG_NOTICE) ||       \
            (s == NULL) ||                                       \
            (ap_get_server_module_loglevel(s, module_index)      \
             &gt;= ((level)&amp;APLOG_LEVELMASK) ) ) )</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>APLOG_CS_MODULE_IS_LEVEL</name><parameter_list>(<param><type><name>c</name></type></param>,<param><type><name>s</name></type></param>,<param><type><name>module_index</name></type></param>,<param><type><name>level</name></type></param>)</parameter_list></cpp:macro>            \
        <cpp:value>( (((level)&amp;APLOG_LEVELMASK) &lt;= APLOG_MAX_LOGLEVEL) &amp;&amp;      \
          ( (((level)&amp;APLOG_LEVELMASK) &lt;= APLOG_NOTICE) ||          \
            (ap_get_conn_server_module_loglevel(c, s, module_index) \
             &gt;= ((level)&amp;APLOG_LEVELMASK) ) ) )</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>APLOG_C_MODULE_IS_LEVEL</name><parameter_list>(<param><type><name>c</name></type></param>,<param><type><name>module_index</name></type></param>,<param><type><name>level</name></type></param>)</parameter_list></cpp:macro>            \
        <cpp:value>( (((level)&amp;APLOG_LEVELMASK) &lt;= APLOG_MAX_LOGLEVEL) &amp;&amp;   \
          ( (((level)&amp;APLOG_LEVELMASK) &lt;= APLOG_NOTICE) ||       \
            (ap_get_conn_module_loglevel(c, module_index)        \
             &gt;= ((level)&amp;APLOG_LEVELMASK) ) ) )</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>APLOG_R_MODULE_IS_LEVEL</name><parameter_list>(<param><type><name>r</name></type></param>,<param><type><name>module_index</name></type></param>,<param><type><name>level</name></type></param>)</parameter_list></cpp:macro>            \
        <cpp:value>( (((level)&amp;APLOG_LEVELMASK) &lt;= APLOG_MAX_LOGLEVEL) &amp;&amp;   \
          ( (((level)&amp;APLOG_LEVELMASK) &lt;= APLOG_NOTICE) ||       \
            (ap_get_request_module_loglevel(r, module_index)     \
             &gt;= ((level)&amp;APLOG_LEVELMASK) ) ) )</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>APLOG_IS_LEVEL</name><parameter_list>(<param><type><name>s</name></type></param>,<param><type><name>level</name></type></param>)</parameter_list></cpp:macro>     \
    <cpp:value>APLOG_MODULE_IS_LEVEL(s,APLOG_MODULE_INDEX,level)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>APLOG_C_IS_LEVEL</name><parameter_list>(<param><type><name>c</name></type></param>,<param><type><name>level</name></type></param>)</parameter_list></cpp:macro>   \
    <cpp:value>APLOG_C_MODULE_IS_LEVEL(c,APLOG_MODULE_INDEX,level)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>APLOG_CS_IS_LEVEL</name><parameter_list>(<param><type><name>c</name></type></param>,<param><type><name>s</name></type></param>,<param><type><name>level</name></type></param>)</parameter_list></cpp:macro> \
    <cpp:value>APLOG_CS_MODULE_IS_LEVEL(c,s,APLOG_MODULE_INDEX,level)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>APLOG_R_IS_LEVEL</name><parameter_list>(<param><type><name>r</name></type></param>,<param><type><name>level</name></type></param>)</parameter_list></cpp:macro>   \
    <cpp:value>APLOG_R_MODULE_IS_LEVEL(r,APLOG_MODULE_INDEX,level)</cpp:value></cpp:define>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>APLOGinfo</name><parameter_list>(<param><type><name>s</name></type></param>)</parameter_list></cpp:macro>                <cpp:value>APLOG_IS_LEVEL(s,APLOG_INFO)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>APLOGdebug</name><parameter_list>(<param><type><name>s</name></type></param>)</parameter_list></cpp:macro>               <cpp:value>APLOG_IS_LEVEL(s,APLOG_DEBUG)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>APLOGtrace1</name><parameter_list>(<param><type><name>s</name></type></param>)</parameter_list></cpp:macro>              <cpp:value>APLOG_IS_LEVEL(s,APLOG_TRACE1)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>APLOGtrace2</name><parameter_list>(<param><type><name>s</name></type></param>)</parameter_list></cpp:macro>              <cpp:value>APLOG_IS_LEVEL(s,APLOG_TRACE2)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>APLOGtrace3</name><parameter_list>(<param><type><name>s</name></type></param>)</parameter_list></cpp:macro>              <cpp:value>APLOG_IS_LEVEL(s,APLOG_TRACE3)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>APLOGtrace4</name><parameter_list>(<param><type><name>s</name></type></param>)</parameter_list></cpp:macro>              <cpp:value>APLOG_IS_LEVEL(s,APLOG_TRACE4)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>APLOGtrace5</name><parameter_list>(<param><type><name>s</name></type></param>)</parameter_list></cpp:macro>              <cpp:value>APLOG_IS_LEVEL(s,APLOG_TRACE5)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>APLOGtrace6</name><parameter_list>(<param><type><name>s</name></type></param>)</parameter_list></cpp:macro>              <cpp:value>APLOG_IS_LEVEL(s,APLOG_TRACE6)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>APLOGtrace7</name><parameter_list>(<param><type><name>s</name></type></param>)</parameter_list></cpp:macro>              <cpp:value>APLOG_IS_LEVEL(s,APLOG_TRACE7)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>APLOGtrace8</name><parameter_list>(<param><type><name>s</name></type></param>)</parameter_list></cpp:macro>              <cpp:value>APLOG_IS_LEVEL(s,APLOG_TRACE8)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>APLOGrinfo</name><parameter_list>(<param><type><name>r</name></type></param>)</parameter_list></cpp:macro>               <cpp:value>APLOG_R_IS_LEVEL(r,APLOG_INFO)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>APLOGrdebug</name><parameter_list>(<param><type><name>r</name></type></param>)</parameter_list></cpp:macro>              <cpp:value>APLOG_R_IS_LEVEL(r,APLOG_DEBUG)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>APLOGrtrace1</name><parameter_list>(<param><type><name>r</name></type></param>)</parameter_list></cpp:macro>             <cpp:value>APLOG_R_IS_LEVEL(r,APLOG_TRACE1)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>APLOGrtrace2</name><parameter_list>(<param><type><name>r</name></type></param>)</parameter_list></cpp:macro>             <cpp:value>APLOG_R_IS_LEVEL(r,APLOG_TRACE2)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>APLOGrtrace3</name><parameter_list>(<param><type><name>r</name></type></param>)</parameter_list></cpp:macro>             <cpp:value>APLOG_R_IS_LEVEL(r,APLOG_TRACE3)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>APLOGrtrace4</name><parameter_list>(<param><type><name>r</name></type></param>)</parameter_list></cpp:macro>             <cpp:value>APLOG_R_IS_LEVEL(r,APLOG_TRACE4)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>APLOGrtrace5</name><parameter_list>(<param><type><name>r</name></type></param>)</parameter_list></cpp:macro>             <cpp:value>APLOG_R_IS_LEVEL(r,APLOG_TRACE5)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>APLOGrtrace6</name><parameter_list>(<param><type><name>r</name></type></param>)</parameter_list></cpp:macro>             <cpp:value>APLOG_R_IS_LEVEL(r,APLOG_TRACE6)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>APLOGrtrace7</name><parameter_list>(<param><type><name>r</name></type></param>)</parameter_list></cpp:macro>             <cpp:value>APLOG_R_IS_LEVEL(r,APLOG_TRACE7)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>APLOGrtrace8</name><parameter_list>(<param><type><name>r</name></type></param>)</parameter_list></cpp:macro>             <cpp:value>APLOG_R_IS_LEVEL(r,APLOG_TRACE8)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>APLOGcinfo</name><parameter_list>(<param><type><name>c</name></type></param>)</parameter_list></cpp:macro>               <cpp:value>APLOG_C_IS_LEVEL(c,APLOG_INFO)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>APLOGcdebug</name><parameter_list>(<param><type><name>c</name></type></param>)</parameter_list></cpp:macro>              <cpp:value>APLOG_C_IS_LEVEL(c,APLOG_DEBUG)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>APLOGctrace1</name><parameter_list>(<param><type><name>c</name></type></param>)</parameter_list></cpp:macro>             <cpp:value>APLOG_C_IS_LEVEL(c,APLOG_TRACE1)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>APLOGctrace2</name><parameter_list>(<param><type><name>c</name></type></param>)</parameter_list></cpp:macro>             <cpp:value>APLOG_C_IS_LEVEL(c,APLOG_TRACE2)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>APLOGctrace3</name><parameter_list>(<param><type><name>c</name></type></param>)</parameter_list></cpp:macro>             <cpp:value>APLOG_C_IS_LEVEL(c,APLOG_TRACE3)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>APLOGctrace4</name><parameter_list>(<param><type><name>c</name></type></param>)</parameter_list></cpp:macro>             <cpp:value>APLOG_C_IS_LEVEL(c,APLOG_TRACE4)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>APLOGctrace5</name><parameter_list>(<param><type><name>c</name></type></param>)</parameter_list></cpp:macro>             <cpp:value>APLOG_C_IS_LEVEL(c,APLOG_TRACE5)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>APLOGctrace6</name><parameter_list>(<param><type><name>c</name></type></param>)</parameter_list></cpp:macro>             <cpp:value>APLOG_C_IS_LEVEL(c,APLOG_TRACE6)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>APLOGctrace7</name><parameter_list>(<param><type><name>c</name></type></param>)</parameter_list></cpp:macro>             <cpp:value>APLOG_C_IS_LEVEL(c,APLOG_TRACE7)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>APLOGctrace8</name><parameter_list>(<param><type><name>c</name></type></param>)</parameter_list></cpp:macro>             <cpp:value>APLOG_C_IS_LEVEL(c,APLOG_TRACE8)</cpp:value></cpp:define>

<decl_stmt><decl><type><name>AP_DECLARE_DATA</name> <specifier>extern</specifier> <name>int</name></type> <name>ap_default_loglevel</name></decl>;</decl_stmt>

<comment type="block">/**
 * APLOG_MARK is a convenience macro for use as the first three parameters in
 * ap_log_error() and related functions, i.e. file, line, and module_index.
 *
 * The module_index parameter was introduced in version 2.3.6. Before that
 * version, APLOG_MARK only replaced the file and line parameters.
 * This means that APLOG_MARK can be used with ap_log_*error in all versions
 * of Apache httpd.
 *
 * @see APLOG_MODULE_INDEX
 * @see ap_log_error
 * @see ap_log_cerror
 * @see ap_log_rerror
 * @see ap_log_cserror
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>APLOG_MARK</name></cpp:macro>     <cpp:value>__FILE__,__LINE__,APLOG_MODULE_INDEX</cpp:value></cpp:define>

<comment type="block">/**
 * Set up for logging to stderr.
 * @param p The pool to allocate out of
 */</comment>
<macro><name>AP_DECLARE</name><argument_list>(<argument>void</argument>)</argument_list></macro> <expr_stmt><expr><call><name>ap_open_stderr_log</name><argument_list>(<argument><expr><name>apr_pool_t</name> *<name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/**
 * Replace logging to stderr with logging to the given file.
 * @param p The pool to allocate out of
 * @param file Name of the file to log stderr output
 */</comment>
<macro><name>AP_DECLARE</name><argument_list>(<argument>apr_status_t</argument>)</argument_list></macro> <expr_stmt><expr><call><name>ap_replace_stderr_log</name><argument_list>(<argument><expr><name>apr_pool_t</name> *<name>p</name></expr></argument>,
                                               <argument><expr>const <name>char</name> *<name>file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/**
 * Open the error log and replace stderr with it.
 * @param pconf Not used
 * @param plog  The pool to allocate the logs from
 * @param ptemp Pool used for temporary allocations
 * @param s_main The main server
 * @note ap_open_logs isn't expected to be used by modules, it is
 * an internal core function
 */</comment>
<function_decl><type><name>int</name></type> <name>ap_open_logs</name><parameter_list>(<param><decl><type><name>apr_pool_t</name> *</type><name>pconf</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>plog</name></decl></param>,
                 <param><decl><type><name>apr_pool_t</name> *</type><name>ptemp</name></decl></param>, <param><decl><type><name>server_rec</name> *</type><name>s_main</name></decl></param>)</parameter_list>;</function_decl>

<comment type="block">/**
 * Perform special processing for piped loggers in MPM child
 * processes.
 * @param p Not used
 * @param s Not used
 * @note ap_logs_child_init is not for use by modules; it is an
 * internal core function
 */</comment>
<function_decl><type><name>void</name></type> <name>ap_logs_child_init</name><parameter_list>(<param><decl><type><name>apr_pool_t</name> *</type><name>p</name></decl></param>, <param><decl><type><name>server_rec</name> *</type><name>s</name></decl></param>)</parameter_list>;</function_decl>

<comment type="block">/*
 * The primary logging functions, ap_log_error, ap_log_rerror, ap_log_cerror,
 * and ap_log_perror use a printf style format string to build the log message.
 * It is VERY IMPORTANT that you not include any raw data from the network,
 * such as the request-URI or request header fields, within the format
 * string.  Doing so makes the server vulnerable to a denial-of-service
 * attack and other messy behavior.  Instead, use a simple format string
 * like "%s", followed by the string containing the untrusted data.
 */</comment>

<comment type="block">/**
 * ap_log_error() - log messages which are not related to a particular
 * request or connection.  This uses a printf-like format to log messages
 * to the error_log.
 * @param file The file in which this function is called
 * @param line The line number on which this function is called
 * @param module_index The module_index of the module generating this message
 * @param level The level of this error message
 * @param status The status code from the previous command
 * @param s The server on which we are logging
 * @param fmt The format string
 * @param ... The arguments to use to fill out fmt.
 * @note ap_log_error is implemented as a macro
 * @note Use APLOG_MARK to fill out file and line
 * @note If a request_rec is available, use that with ap_log_rerror()
 * in preference to calling this function.  Otherwise, if a conn_rec is
 * available, use that with ap_log_cerror() in preference to calling
 * this function.
 * @warning It is VERY IMPORTANT that you not include any raw data from
 * the network, such as the request-URI or request header fields, within
 * the format string.  Doing so makes the server vulnerable to a
 * denial-of-service attack and other messy behavior.  Instead, use a
 * simple format string like "%s", followed by the string containing the
 * untrusted data.
 */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DOXYGEN</name></cpp:ifdef>
<macro><name>AP_DECLARE</name><argument_list>(<argument>void</argument>)</argument_list></macro> <macro><name>ap_log_error</name><argument_list>(<argument>const char *file</argument>, <argument>int line</argument>, <argument>int module_index</argument>,
                              <argument>int level</argument>, <argument>apr_status_t status</argument>,
                              <argument>const server_rec *s</argument>, <argument>const char *fmt</argument>, <argument>...</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>AP_HAVE_C99</name></cpp:ifdef>
<comment type="block">/* need additional step to expand APLOG_MARK first */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ap_log_error</name><parameter_list>(<param><type>...</type></param>)</parameter_list></cpp:macro> <cpp:value>ap_log_error__(__VA_ARGS__)</cpp:value></cpp:define>
<comment type="block">/* need server_rec *sr = ... for the case if s is verbatim NULL */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ap_log_error__</name><parameter_list>(<param><type><name>file</name></type></param>, <param><type><name>line</name></type></param>, <param><type><name>mi</name></type></param>, <param><type><name>level</name></type></param>, <param><type><name>status</name></type></param>, <param><type><name>s</name></type></param>, <param><type>...</type></param>)</parameter_list></cpp:macro>           \
    <cpp:value>do { const server_rec *sr__ = s; if (APLOG_MODULE_IS_LEVEL(sr__, mi, level)) \
             ap_log_error_(file, line, mi, level, status, sr__, __VA_ARGS__);    \
    } while(0)</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ap_log_error</name></cpp:macro> <cpp:value>ap_log_error_</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<macro><name>AP_DECLARE</name><argument_list>(<argument>void</argument>)</argument_list></macro> <macro><name>ap_log_error_</name><argument_list>(<argument>const char *file</argument>, <argument>int line</argument>, <argument>int module_index</argument>,
                               <argument>int level</argument>, <argument>apr_status_t status</argument>,
                               <argument>const server_rec *s</argument>, <argument>const char *fmt</argument>, <argument>...</argument>)</argument_list></macro>
                              <expr_stmt><expr><call><name>__attribute__</name><argument_list>(<argument><expr>(<call><name>format</name><argument_list>(<argument><expr><name>printf</name></expr></argument>,<argument><expr>7</expr></argument>,<argument><expr>8</expr></argument>)</argument_list></call>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/**
 * ap_log_perror() - log messages which are not related to a particular
 * request, connection, or virtual server.  This uses a printf-like
 * format to log messages to the error_log.
 * @param file The file in which this function is called
 * @param line The line number on which this function is called
 * @param module_index ignored dummy value for use by APLOG_MARK
 * @param level The level of this error message
 * @param status The status code from the previous command
 * @param p The pool which we are logging for
 * @param fmt The format string
 * @param ... The arguments to use to fill out fmt.
 * @note ap_log_perror is implemented as a macro
 * @note Use APLOG_MARK to fill out file, line, and module_index
 * @warning It is VERY IMPORTANT that you not include any raw data from
 * the network, such as the request-URI or request header fields, within
 * the format string.  Doing so makes the server vulnerable to a
 * denial-of-service attack and other messy behavior.  Instead, use a
 * simple format string like "%s", followed by the string containing the
 * untrusted data.
 */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DOXYGEN</name></cpp:ifdef>
<macro><name>AP_DECLARE</name><argument_list>(<argument>void</argument>)</argument_list></macro> <macro><name>ap_log_perror</name><argument_list>(<argument>const char *file</argument>, <argument>int line</argument>, <argument>int module_index</argument>,
                               <argument>int level</argument>, <argument>apr_status_t status</argument>, <argument>apr_pool_t *p</argument>,
                               <argument>const char *fmt</argument>, <argument>...</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>AP_HAVE_C99</name></expr></argument>)</argument_list></call> &amp;&amp; <call><name>defined</name><argument_list>(<argument><expr><name>APLOG_MAX_LOGLEVEL</name></expr></argument>)</argument_list></call></expr></cpp:if>
<comment type="block">/* need additional step to expand APLOG_MARK first */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ap_log_perror</name><parameter_list>(<param><type>...</type></param>)</parameter_list></cpp:macro> <cpp:value>ap_log_perror__(__VA_ARGS__)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ap_log_perror__</name><parameter_list>(<param><type><name>file</name></type></param>, <param><type><name>line</name></type></param>, <param><type><name>mi</name></type></param>, <param><type><name>level</name></type></param>, <param><type><name>status</name></type></param>, <param><type><name>p</name></type></param>, <param><type>...</type></param>)</parameter_list></cpp:macro>            \
    <cpp:value>do { if ((level) &lt;= APLOG_MAX_LOGLEVEL )                              \
             ap_log_perror_(file, line, mi, level, status, p,             \
                            __VA_ARGS__); } while(0)</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ap_log_perror</name></cpp:macro> <cpp:value>ap_log_perror_</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<macro><name>AP_DECLARE</name><argument_list>(<argument>void</argument>)</argument_list></macro> <macro><name>ap_log_perror_</name><argument_list>(<argument>const char *file</argument>, <argument>int line</argument>, <argument>int module_index</argument>,
                                <argument>int level</argument>, <argument>apr_status_t status</argument>, <argument>apr_pool_t *p</argument>,
                                <argument>const char *fmt</argument>, <argument>...</argument>)</argument_list></macro>
                               <expr_stmt><expr><call><name>__attribute__</name><argument_list>(<argument><expr>(<call><name>format</name><argument_list>(<argument><expr><name>printf</name></expr></argument>,<argument><expr>7</expr></argument>,<argument><expr>8</expr></argument>)</argument_list></call>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/**
 * ap_log_rerror() - log messages which are related to a particular
 * request.  This uses a printf-like format to log messages to the
 * error_log.
 * @param file The file in which this function is called
 * @param line The line number on which this function is called
 * @param module_index The module_index of the module generating this message
 * @param level The level of this error message
 * @param status The status code from the previous command
 * @param r The request which we are logging for
 * @param fmt The format string
 * @param ... The arguments to use to fill out fmt.
 * @note ap_log_rerror is implemented as a macro
 * @note Use APLOG_MARK to fill out file, line, and module_index
 * @warning It is VERY IMPORTANT that you not include any raw data from
 * the network, such as the request-URI or request header fields, within
 * the format string.  Doing so makes the server vulnerable to a
 * denial-of-service attack and other messy behavior.  Instead, use a
 * simple format string like "%s", followed by the string containing the
 * untrusted data.
 */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DOXYGEN</name></cpp:ifdef>
<macro><name>AP_DECLARE</name><argument_list>(<argument>void</argument>)</argument_list></macro> <macro><name>ap_log_rerror</name><argument_list>(<argument>const char *file</argument>, <argument>int line</argument>, <argument>int module_index</argument>,
                               <argument>int level</argument>, <argument>apr_status_t status</argument>,
                               <argument>const request_rec *r</argument>, <argument>const char *fmt</argument>, <argument>...</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>AP_HAVE_C99</name></cpp:ifdef>
<comment type="block">/* need additional step to expand APLOG_MARK first */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ap_log_rerror</name><parameter_list>(<param><type>...</type></param>)</parameter_list></cpp:macro> <cpp:value>ap_log_rerror__(__VA_ARGS__)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ap_log_rerror__</name><parameter_list>(<param><type><name>file</name></type></param>, <param><type><name>line</name></type></param>, <param><type><name>mi</name></type></param>, <param><type><name>level</name></type></param>, <param><type><name>status</name></type></param>, <param><type><name>r</name></type></param>, <param><type>...</type></param>)</parameter_list></cpp:macro>              \
    <cpp:value>do { if (APLOG_R_MODULE_IS_LEVEL(r, mi, level))                         \
             ap_log_rerror_(file, line, mi, level, status, r, __VA_ARGS__); \
    } while(0)</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ap_log_rerror</name></cpp:macro> <cpp:value>ap_log_rerror_</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<macro><name>AP_DECLARE</name><argument_list>(<argument>void</argument>)</argument_list></macro> <macro><name>ap_log_rerror_</name><argument_list>(<argument>const char *file</argument>, <argument>int line</argument>, <argument>int module_index</argument>,
                                <argument>int level</argument>, <argument>apr_status_t status</argument>,
                                <argument>const request_rec *r</argument>, <argument>const char *fmt</argument>, <argument>...</argument>)</argument_list></macro>
                                <expr_stmt><expr><call><name>__attribute__</name><argument_list>(<argument><expr>(<call><name>format</name><argument_list>(<argument><expr><name>printf</name></expr></argument>,<argument><expr>7</expr></argument>,<argument><expr>8</expr></argument>)</argument_list></call>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/**
 * ap_log_cerror() - log messages which are related to a particular
 * connection.  This uses a printf-like format to log messages to the
 * error_log.
 * @param file The file in which this function is called
 * @param line The line number on which this function is called
 * @param level The level of this error message
 * @param module_index The module_index of the module generating this message
 * @param status The status code from the previous command
 * @param c The connection which we are logging for
 * @param fmt The format string
 * @param ... The arguments to use to fill out fmt.
 * @note ap_log_cerror is implemented as a macro
 * @note Use APLOG_MARK to fill out file, line, and module_index
 * @note If a request_rec is available, use that with ap_log_rerror()
 * in preference to calling this function.
 * @warning It is VERY IMPORTANT that you not include any raw data from
 * the network, such as the request-URI or request header fields, within
 * the format string.  Doing so makes the server vulnerable to a
 * denial-of-service attack and other messy behavior.  Instead, use a
 * simple format string like "%s", followed by the string containing the
 * untrusted data.
 */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DOXYGEN</name></cpp:ifdef>
<macro><name>AP_DECLARE</name><argument_list>(<argument>void</argument>)</argument_list></macro> <macro><name>ap_log_cerror</name><argument_list>(<argument>const char *file</argument>, <argument>int line</argument>, <argument>int module_index</argument>,
                               <argument>int level</argument>, <argument>apr_status_t status</argument>,
                               <argument>const conn_rec *c</argument>, <argument>const char *fmt</argument>, <argument>...</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>AP_HAVE_C99</name></cpp:ifdef>
<comment type="block">/* need additional step to expand APLOG_MARK first */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ap_log_cerror</name><parameter_list>(<param><type>...</type></param>)</parameter_list></cpp:macro> <cpp:value>ap_log_cerror__(__VA_ARGS__)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ap_log_cerror__</name><parameter_list>(<param><type><name>file</name></type></param>, <param><type><name>line</name></type></param>, <param><type><name>mi</name></type></param>, <param><type><name>level</name></type></param>, <param><type><name>status</name></type></param>, <param><type><name>c</name></type></param>, <param><type>...</type></param>)</parameter_list></cpp:macro>              \
    <cpp:value>do { if (APLOG_C_MODULE_IS_LEVEL(c, mi, level))                         \
             ap_log_cerror_(file, line, mi, level, status, c, __VA_ARGS__); \
    } while(0)</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ap_log_cerror</name></cpp:macro> <cpp:value>ap_log_cerror_</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<macro><name>AP_DECLARE</name><argument_list>(<argument>void</argument>)</argument_list></macro> <macro><name>ap_log_cerror_</name><argument_list>(<argument>const char *file</argument>, <argument>int line</argument>, <argument>int module_index</argument>,
                                <argument>int level</argument>, <argument>apr_status_t status</argument>,
                                <argument>const conn_rec *c</argument>, <argument>const char *fmt</argument>, <argument>...</argument>)</argument_list></macro>
                                <expr_stmt><expr><call><name>__attribute__</name><argument_list>(<argument><expr>(<call><name>format</name><argument_list>(<argument><expr><name>printf</name></expr></argument>,<argument><expr>7</expr></argument>,<argument><expr>8</expr></argument>)</argument_list></call>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/**
 * ap_log_cserror() - log messages which are related to a particular
 * connection and to a vhost other than c-&gt;base_server.  This uses a
 * printf-like format to log messages to the error_log.
 * @param file The file in which this function is called
 * @param line The line number on which this function is called
 * @param level The level of this error message
 * @param module_index The module_index of the module generating this message
 * @param status The status code from the previous command
 * @param c The connection which we are logging for
 * @param s The server which we are logging for
 * @param fmt The format string
 * @param ... The arguments to use to fill out fmt.
 * @note ap_log_cserror is implemented as a macro
 * @note Use APLOG_MARK to fill out file, line, and module_index
 * @note If a request_rec is available, use that with ap_log_rerror()
 * in preference to calling this function. This function is mainly useful for
 * modules like mod_ssl to use before the request_rec is created.
 * @warning It is VERY IMPORTANT that you not include any raw data from
 * the network, such as the request-URI or request header fields, within
 * the format string.  Doing so makes the server vulnerable to a
 * denial-of-service attack and other messy behavior.  Instead, use a
 * simple format string like "%s", followed by the string containing the
 * untrusted data.
 */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DOXYGEN</name></cpp:ifdef>
<macro><name>AP_DECLARE</name><argument_list>(<argument>void</argument>)</argument_list></macro> <macro><name>ap_log_cserror</name><argument_list>(<argument>const char *file</argument>, <argument>int line</argument>, <argument>int module_index</argument>,
                                <argument>int level</argument>, <argument>apr_status_t status</argument>,
                                <argument>const conn_rec *c</argument>, <argument>const server_rec *s</argument>,
                                <argument>const char *fmt</argument>, <argument>...</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>AP_HAVE_C99</name></cpp:ifdef>
<comment type="block">/* need additional step to expand APLOG_MARK first */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ap_log_cserror</name><parameter_list>(<param><type>...</type></param>)</parameter_list></cpp:macro> <cpp:value>ap_log_cserror__(__VA_ARGS__)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ap_log_cserror__</name><parameter_list>(<param><type><name>file</name></type></param>, <param><type><name>line</name></type></param>, <param><type><name>mi</name></type></param>, <param><type><name>level</name></type></param>, <param><type><name>status</name></type></param>, <param><type><name>c</name></type></param>, <param><type><name>s</name></type></param>, <param><type>...</type></param>)</parameter_list></cpp:macro>  \
    <cpp:value>do { if (APLOG_CS_MODULE_IS_LEVEL(c, s, mi, level))             \
             ap_log_cserror_(file, line, mi, level, status, c, s,   \
                             __VA_ARGS__);                          \
    } while(0)</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ap_log_cserror</name></cpp:macro> <cpp:value>ap_log_cserror_</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<macro><name>AP_DECLARE</name><argument_list>(<argument>void</argument>)</argument_list></macro> <macro><name>ap_log_cserror_</name><argument_list>(<argument>const char *file</argument>, <argument>int line</argument>, <argument>int module_index</argument>,
                                 <argument>int level</argument>, <argument>apr_status_t status</argument>,
                                 <argument>const conn_rec *c</argument>, <argument>const server_rec *s</argument>,
                                 <argument>const char *fmt</argument>, <argument>...</argument>)</argument_list></macro>
                             <expr_stmt><expr><call><name>__attribute__</name><argument_list>(<argument><expr>(<call><name>format</name><argument_list>(<argument><expr><name>printf</name></expr></argument>,<argument><expr>8</expr></argument>,<argument><expr>9</expr></argument>)</argument_list></call>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
 * The buffer logging functions, ap_log_data, ap_log_rdata, ap_log_cdata,
 * and ap_log_csdata log a buffer in printable and hex format.  The exact
 * format is controlled by processing flags, described next.
 */</comment>

<comment type="block">/**
 * Processing flags for ap_log_data() et al
 *
 * AP_LOG_DATA_DEFAULT - default formatting, with printable chars and hex
 * AP_LOG_DATA_SHOW_OFFSET - prefix each line with hex offset from the start
 * of the buffer
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AP_LOG_DATA_DEFAULT</name></cpp:macro>       <cpp:value>0</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AP_LOG_DATA_SHOW_OFFSET</name></cpp:macro>   <cpp:value>1</cpp:value></cpp:define>

<comment type="block">/**
 * ap_log_data() - log buffers which are not related to a particular request
 * or connection.
 * @param file The file in which this function is called
 * @param line The line number on which this function is called
 * @param module_index The module_index of the module logging this buffer
 * @param level The log level
 * @param s The server on which we are logging
 * @param label A label for the buffer, to be logged preceding the buffer
 * @param data The buffer to be logged
 * @param len The length of the buffer
 * @param flags Special processing flags like AP_LOG_DATA_SHOW_OFFSET
 * @note ap_log_data is implemented as a macro.
 * @note Use APLOG_MARK to fill out file, line, and module_index
 * @note If a request_rec is available, use that with ap_log_rdata()
 * in preference to calling this function.  Otherwise, if a conn_rec is
 * available, use that with ap_log_cdata() in preference to calling
 * this function.
 */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DOXYGEN</name></cpp:ifdef>
<macro><name>AP_DECLARE</name><argument_list>(<argument>void</argument>)</argument_list></macro> <macro><name>ap_log_data</name><argument_list>(<argument>const char *file</argument>, <argument>int line</argument>, <argument>int module_index</argument>,
                             <argument>int level</argument>, <argument>const server_rec *s</argument>, <argument>const char *label</argument>,
                             <argument>const void *data</argument>, <argument>apr_size_t len</argument>, <argument>unsigned int flags</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>AP_HAVE_C99</name></cpp:ifdef>
<comment type="block">/* need additional step to expand APLOG_MARK first */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ap_log_data</name><parameter_list>(<param><type>...</type></param>)</parameter_list></cpp:macro> <cpp:value>ap_log_data__(__VA_ARGS__)</cpp:value></cpp:define>
<comment type="block">/* need server_rec *sr = ... for the case if s is verbatim NULL */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ap_log_data__</name><parameter_list>(<param><type><name>file</name></type></param>, <param><type><name>line</name></type></param>, <param><type><name>mi</name></type></param>, <param><type><name>level</name></type></param>, <param><type><name>s</name></type></param>, <param><type>...</type></param>)</parameter_list></cpp:macro>           \
    <cpp:value>do { const server_rec *sr__ = s; if (APLOG_MODULE_IS_LEVEL(sr__, mi, level)) \
             ap_log_data_(file, line, mi, level, sr__, __VA_ARGS__);    \
    } while(0)</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ap_log_data</name></cpp:macro> <cpp:value>ap_log_data_</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<macro><name>AP_DECLARE</name><argument_list>(<argument>void</argument>)</argument_list></macro> <macro><name>ap_log_data_</name><argument_list>(<argument>const char *file</argument>, <argument>int line</argument>, <argument>int module_index</argument>,
                              <argument>int level</argument>, <argument>const server_rec *s</argument>, <argument>const char *label</argument>,
                              <argument>const void *data</argument>, <argument>apr_size_t len</argument>, <argument>unsigned int flags</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/**
 * ap_log_rdata() - log buffers which are related to a particular request.
 * @param file The file in which this function is called
 * @param line The line number on which this function is called
 * @param module_index The module_index of the module logging this buffer
 * @param level The log level
 * @param r The request which we are logging for
 * @param label A label for the buffer, to be logged preceding the buffer
 * @param data The buffer to be logged
 * @param len The length of the buffer
 * @param flags Special processing flags like AP_LOG_DATA_SHOW_OFFSET
 * @note ap_log_rdata is implemented as a macro.
 * @note Use APLOG_MARK to fill out file, line, and module_index
 * @note If a request_rec is available, use that with ap_log_rerror()
 * in preference to calling this function.  Otherwise, if a conn_rec is
 * available, use that with ap_log_cerror() in preference to calling
 * this function.
 */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DOXYGEN</name></cpp:ifdef>
<macro><name>AP_DECLARE</name><argument_list>(<argument>void</argument>)</argument_list></macro> <macro><name>ap_log_rdata</name><argument_list>(<argument>const char *file</argument>, <argument>int line</argument>, <argument>int module_index</argument>,
                              <argument>int level</argument>, <argument>const request_rec *r</argument>, <argument>const char *label</argument>,
                              <argument>const void *data</argument>, <argument>apr_size_t len</argument>, <argument>unsigned int flags</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>AP_HAVE_C99</name></cpp:ifdef>
<comment type="block">/* need additional step to expand APLOG_MARK first */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ap_log_rdata</name><parameter_list>(<param><type>...</type></param>)</parameter_list></cpp:macro> <cpp:value>ap_log_rdata__(__VA_ARGS__)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ap_log_rdata__</name><parameter_list>(<param><type><name>file</name></type></param>, <param><type><name>line</name></type></param>, <param><type><name>mi</name></type></param>, <param><type><name>level</name></type></param>, <param><type><name>r</name></type></param>, <param><type>...</type></param>)</parameter_list></cpp:macro>           \
    <cpp:value>do { if (APLOG_R_MODULE_IS_LEVEL(r, mi, level)) \
             ap_log_rdata_(file, line, mi, level, r, __VA_ARGS__);    \
    } while(0)</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ap_log_rdata</name></cpp:macro> <cpp:value>ap_log_rdata_</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<macro><name>AP_DECLARE</name><argument_list>(<argument>void</argument>)</argument_list></macro> <macro><name>ap_log_rdata_</name><argument_list>(<argument>const char *file</argument>, <argument>int line</argument>, <argument>int module_index</argument>,
                               <argument>int level</argument>, <argument>const request_rec *r</argument>, <argument>const char *label</argument>,
                               <argument>const void *data</argument>, <argument>apr_size_t len</argument>, <argument>unsigned int flags</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/**
 * ap_log_cdata() - log buffers which are related to a particular connection.
 * @param file The file in which this function is called
 * @param line The line number on which this function is called
 * @param module_index The module_index of the module logging this buffer
 * @param level The log level
 * @param c The connection which we are logging for
 * @param label A label for the buffer, to be logged preceding the buffer
 * @param data The buffer to be logged
 * @param len The length of the buffer
 * @param flags Special processing flags like AP_LOG_DATA_SHOW_OFFSET
 * @note ap_log_cdata is implemented as a macro
 * @note Use APLOG_MARK to fill out file, line, and module_index
 * @note If a request_rec is available, use that with ap_log_rerror()
 * in preference to calling this function.  Otherwise, if a conn_rec is
 * available, use that with ap_log_cerror() in preference to calling
 * this function.
 */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DOXYGEN</name></cpp:ifdef>
<macro><name>AP_DECLARE</name><argument_list>(<argument>void</argument>)</argument_list></macro> <macro><name>ap_log_cdata</name><argument_list>(<argument>const char *file</argument>, <argument>int line</argument>, <argument>int module_index</argument>,
                              <argument>int level</argument>, <argument>const conn_rec *c</argument>, <argument>const char *label</argument>,
                              <argument>const void *data</argument>, <argument>apr_size_t len</argument>, <argument>unsigned int flags</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>AP_HAVE_C99</name></cpp:ifdef>
<comment type="block">/* need additional step to expand APLOG_MARK first */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ap_log_cdata</name><parameter_list>(<param><type>...</type></param>)</parameter_list></cpp:macro> <cpp:value>ap_log_cdata__(__VA_ARGS__)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ap_log_cdata__</name><parameter_list>(<param><type><name>file</name></type></param>, <param><type><name>line</name></type></param>, <param><type><name>mi</name></type></param>, <param><type><name>level</name></type></param>, <param><type><name>c</name></type></param>, <param><type>...</type></param>)</parameter_list></cpp:macro>           \
    <cpp:value>do { if (APLOG_C_MODULE_IS_LEVEL(c, mi, level)) \
             ap_log_cdata_(file, line, mi, level, c, __VA_ARGS__);    \
    } while(0)</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ap_log_cdata</name></cpp:macro> <cpp:value>ap_log_cdata_</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<macro><name>AP_DECLARE</name><argument_list>(<argument>void</argument>)</argument_list></macro> <macro><name>ap_log_cdata_</name><argument_list>(<argument>const char *file</argument>, <argument>int line</argument>, <argument>int module_index</argument>,
                               <argument>int level</argument>, <argument>const conn_rec *c</argument>, <argument>const char *label</argument>,
                               <argument>const void *data</argument>, <argument>apr_size_t len</argument>, <argument>unsigned int flags</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/**
 * ap_log_csdata() - log buffers which are related to a particular connection
 * and to a vhost other than c-&gt;base_server.
 * @param file The file in which this function is called
 * @param line The line number on which this function is called
 * @param module_index The module_index of the module logging this buffer
 * @param level The log level
 * @param c The connection which we are logging for
 * @param s The server which we are logging for
 * @param label A label for the buffer, to be logged preceding the buffer
 * @param data The buffer to be logged
 * @param len The length of the buffer
 * @param flags Special processing flags like AP_LOG_DATA_SHOW_OFFSET
 * @note ap_log_csdata is implemented as a macro
 * @note Use APLOG_MARK to fill out file, line, and module_index
 * @note If a request_rec is available, use that with ap_log_rerror()
 * in preference to calling this function.  Otherwise, if a conn_rec is
 * available, use that with ap_log_cerror() in preference to calling
 * this function.
 */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DOXYGEN</name></cpp:ifdef>
<macro><name>AP_DECLARE</name><argument_list>(<argument>void</argument>)</argument_list></macro> <macro><name>ap_log_csdata</name><argument_list>(<argument>const char *file</argument>, <argument>int line</argument>, <argument>int module_index</argument>,
                               <argument>int level</argument>, <argument>const conn_rec *c</argument>, <argument>const server_rec *s</argument>,
                               <argument>const char *label</argument>, <argument>const void *data</argument>,
                               <argument>apr_size_t len</argument>, <argument>unsigned int flags</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>AP_HAVE_C99</name></cpp:ifdef>
<comment type="block">/* need additional step to expand APLOG_MARK first */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ap_log_csdata</name><parameter_list>(<param><type>...</type></param>)</parameter_list></cpp:macro> <cpp:value>ap_log_csdata__(__VA_ARGS__)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ap_log_csdata__</name><parameter_list>(<param><type><name>file</name></type></param>, <param><type><name>line</name></type></param>, <param><type><name>mi</name></type></param>, <param><type><name>level</name></type></param>, <param><type><name>c</name></type></param>, <param><type><name>s</name></type></param>, <param><type>...</type></param>)</parameter_list></cpp:macro>              \
    <cpp:value>do { if (APLOG_CS_MODULE_IS_LEVEL(c, s, mi, level))                \
             ap_log_csdata_(file, line, mi, level, c, s, __VA_ARGS__); \
    } while(0)</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ap_log_cdata</name></cpp:macro> <cpp:value>ap_log_cdata_</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<macro><name>AP_DECLARE</name><argument_list>(<argument>void</argument>)</argument_list></macro> <macro><name>ap_log_csdata_</name><argument_list>(<argument>const char *file</argument>, <argument>int line</argument>, <argument>int module_index</argument>,
                                <argument>int level</argument>, <argument>const conn_rec *c</argument>, <argument>const server_rec *s</argument>,
                                <argument>const char *label</argument>, <argument>const void *data</argument>,
                                <argument>apr_size_t len</argument>, <argument>unsigned int flags</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/**
 * Convert stderr to the error log
 * @param s The current server
 */</comment>
<macro><name>AP_DECLARE</name><argument_list>(<argument>void</argument>)</argument_list></macro> <expr_stmt><expr><call><name>ap_error_log2stderr</name><argument_list>(<argument><expr><name>server_rec</name> *<name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/**
 * Log the command line used to start the server.
 * @param p The pool to use for logging
 * @param s The server_rec whose process's command line we want to log.
 * The command line is logged to that server's error log.
 */</comment>
<macro><name>AP_DECLARE</name><argument_list>(<argument>void</argument>)</argument_list></macro> <expr_stmt><expr><call><name>ap_log_command_line</name><argument_list>(<argument><expr><name>apr_pool_t</name> *<name>p</name></expr></argument>, <argument><expr><name>server_rec</name> *<name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/**
 * Log common (various) MPM shared data at startup.
 * @param s The server_rec of the error log we want to log to.
 * Misc commonly logged data is logged to that server's error log.
 */</comment>
<macro><name>AP_DECLARE</name><argument_list>(<argument>void</argument>)</argument_list></macro> <expr_stmt><expr><call><name>ap_log_mpm_common</name><argument_list>(<argument><expr><name>server_rec</name> *<name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/**
 * Log the current pid of the parent process
 * @param p The pool to use for processing
 * @param fname The name of the file to log to.  If the filename is not
 * absolute then it is assumed to be relative to ServerRoot.
 */</comment>
<macro><name>AP_DECLARE</name><argument_list>(<argument>void</argument>)</argument_list></macro> <expr_stmt><expr><call><name>ap_log_pid</name><argument_list>(<argument><expr><name>apr_pool_t</name> *<name>p</name></expr></argument>, <argument><expr>const <name>char</name> *<name>fname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/**
 * Remove the pidfile.
 * @param p The pool to use for processing
 * @param fname The name of the pid file to remove.  If the filename is not
 * absolute then it is assumed to be relative to ServerRoot.
 */</comment>
<macro><name>AP_DECLARE</name><argument_list>(<argument>void</argument>)</argument_list></macro> <expr_stmt><expr><call><name>ap_remove_pid</name><argument_list>(<argument><expr><name>apr_pool_t</name> *<name>p</name></expr></argument>, <argument><expr>const <name>char</name> *<name>fname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/**
 * Retrieve the pid from a pidfile.
 * @param p The pool to use for processing
 * @param filename The name of the file containing the pid.  If the filename is not
 * absolute then it is assumed to be relative to ServerRoot.
 * @param mypid Pointer to pid_t (valid only if return APR_SUCCESS)
 */</comment>
<macro><name>AP_DECLARE</name><argument_list>(<argument>apr_status_t</argument>)</argument_list></macro> <expr_stmt><expr><call><name>ap_read_pid</name><argument_list>(<argument><expr><name>apr_pool_t</name> *<name>p</name></expr></argument>, <argument><expr>const <name>char</name> *<name>filename</name></expr></argument>, <argument><expr><name>pid_t</name> *<name>mypid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/** @see piped_log */</comment>
<typedef>typedef <type>struct <name>piped_log</name></type> <name>piped_log</name>;</typedef>

<comment type="block">/**
 * Open the piped log process
 * @param p The pool to allocate out of
 * @param program The program to run in the logging process
 * @return The piped log structure
 * @note The log program is invoked as @p APR_PROGRAM_ENV,
 *      @see ap_open_piped_log_ex to modify this behavior
 */</comment>
<macro><name>AP_DECLARE</name><argument_list>(<argument>piped_log *</argument>)</argument_list></macro> <expr_stmt><expr><call><name>ap_open_piped_log</name><argument_list>(<argument><expr><name>apr_pool_t</name> *<name>p</name></expr></argument>, <argument><expr>const <name>char</name> *<name>program</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/**
 * Open the piped log process specifying the execution choice for program
 * @param p The pool to allocate out of
 * @param program The program to run in the logging process
 * @param cmdtype How to invoke program, e.g. APR_PROGRAM, APR_SHELLCMD_ENV, etc
 * @return The piped log structure
 */</comment>
<macro><name>AP_DECLARE</name><argument_list>(<argument>piped_log *</argument>)</argument_list></macro> <macro><name>ap_open_piped_log_ex</name><argument_list>(<argument>apr_pool_t *p</argument>,
                                             <argument>const char *program</argument>,
                                             <argument>apr_cmdtype_e cmdtype</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

<comment type="block">/**
 * Close the piped log and kill the logging process
 * @param pl The piped log structure
 */</comment>
<macro><name>AP_DECLARE</name><argument_list>(<argument>void</argument>)</argument_list></macro> <expr_stmt><expr><call><name>ap_close_piped_log</name><argument_list>(<argument><expr><name>piped_log</name> *<name>pl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/**
 * A function to return the read side of the piped log pipe
 * @param pl The piped log structure
 * @return The native file descriptor
 */</comment>
<macro><name>AP_DECLARE</name><argument_list>(<argument>apr_file_t *</argument>)</argument_list></macro> <expr_stmt><expr><call><name>ap_piped_log_read_fd</name><argument_list>(<argument><expr><name>piped_log</name> *<name>pl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/**
 * A function to return the write side of the piped log pipe
 * @param pl The piped log structure
 * @return The native file descriptor
 */</comment>
<macro><name>AP_DECLARE</name><argument_list>(<argument>apr_file_t *</argument>)</argument_list></macro> <expr_stmt><expr><call><name>ap_piped_log_write_fd</name><argument_list>(<argument><expr><name>piped_log</name> *<name>pl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/**
 * hook method to generate unique id for connection or request
 * @ingroup hooks
 * @param c the conn_rec of the connections
 * @param r the request_req (may be NULL)
 * @param id the place where to store the unique id
 * @return OK or DECLINE
 */</comment>
<macro><name>AP_DECLARE_HOOK</name><argument_list>(<argument>int</argument>, <argument>generate_log_id</argument>,
                <argument>(const conn_rec *c, const request_rec *r, const char **id)</argument>)</argument_list></macro>


<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__cplusplus</name></cpp:ifdef>
}</block></extern>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>  <comment type="block">/* !APACHE_HTTP_LOG_H */</comment>
<comment type="block">/** @} */</comment>
</unit>
