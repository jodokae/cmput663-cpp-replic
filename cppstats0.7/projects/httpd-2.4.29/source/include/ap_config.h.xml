<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C" filename="projects/httpd-2.4.29/include/ap_config.h"><comment type="block">/* Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */</comment>

<comment type="block">/**
 * @file ap_config.h
 * @brief Symbol export macros and hook functions
 */</comment>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>AP_CONFIG_H</name></cpp:ifndef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AP_CONFIG_H</name></cpp:macro></cpp:define>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ap_hooks.h"</cpp:file></cpp:include>

<comment type="block">/* Although this file doesn't declare any hooks, declare the exports group here */</comment>
<comment type="block">/**
 * @defgroup exports Apache exports
 * @ingroup  APACHE_CORE
 */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DOXYGEN</name></cpp:ifdef>
<comment type="block">/* define these just so doxygen documents them */</comment>

<comment type="block">/**
 * AP_DECLARE_STATIC is defined when including Apache's Core headers,
 * to provide static linkage when the dynamic library may be unavailable.
 *
 * @see AP_DECLARE_EXPORT
 *
 * AP_DECLARE_STATIC and AP_DECLARE_EXPORT are left undefined when
 * including Apache's Core headers, to import and link the symbols from the
 * dynamic Apache Core library and assure appropriate indirection and calling
 * conventions at compile time.
 */</comment>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>AP_DECLARE_STATIC</name></cpp:macro></cpp:define>
<comment type="block">/**
 * AP_DECLARE_EXPORT is defined when building the Apache Core dynamic
 * library, so that all public symbols are exported.
 *
 * @see AP_DECLARE_STATIC
 */</comment>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>AP_DECLARE_EXPORT</name></cpp:macro></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* def DOXYGEN */</comment>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>WIN32</name></expr></argument>)</argument_list></call></expr></cpp:if>
<comment type="block">/**
 * Apache Core dso functions are declared with AP_DECLARE(), so they may
 * use the most appropriate calling convention.  Hook functions and other
 * Core functions with variable arguments must use AP_DECLARE_NONSTD().
 * @code
 * AP_DECLARE(rettype) ap_func(args)
 * @endcode
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AP_DECLARE</name><parameter_list>(<param><type><name>type</name></type></param>)</parameter_list></cpp:macro>            <cpp:value>type</cpp:value></cpp:define>

<comment type="block">/**
 * Apache Core dso variable argument and hook functions are declared with
 * AP_DECLARE_NONSTD(), as they must use the C language calling convention.
 * @see AP_DECLARE
 * @code
 * AP_DECLARE_NONSTD(rettype) ap_func(args [...])
 * @endcode
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AP_DECLARE_NONSTD</name><parameter_list>(<param><type><name>type</name></type></param>)</parameter_list></cpp:macro>     <cpp:value>type</cpp:value></cpp:define>

<comment type="block">/**
 * Apache Core dso variables are declared with AP_MODULE_DECLARE_DATA.
 * This assures the appropriate indirection is invoked at compile time.
 *
 * @note AP_DECLARE_DATA extern type apr_variable; syntax is required for
 * declarations within headers to properly import the variable.
 * @code
 * AP_DECLARE_DATA type apr_variable
 * @endcode
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AP_DECLARE_DATA</name></cpp:macro></cpp:define>

<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>AP_DECLARE_STATIC</name></expr></argument>)</argument_list></call></expr></cpp:elif>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AP_DECLARE</name><parameter_list>(<param><type><name>type</name></type></param>)</parameter_list></cpp:macro>            <cpp:value>type __stdcall</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AP_DECLARE_NONSTD</name><parameter_list>(<param><type><name>type</name></type></param>)</parameter_list></cpp:macro>     <cpp:value>type</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AP_DECLARE_DATA</name></cpp:macro></cpp:define>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>AP_DECLARE_EXPORT</name></expr></argument>)</argument_list></call></expr></cpp:elif>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AP_DECLARE</name><parameter_list>(<param><type><name>type</name></type></param>)</parameter_list></cpp:macro>            <cpp:value>__declspec(dllexport) type __stdcall</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AP_DECLARE_NONSTD</name><parameter_list>(<param><type><name>type</name></type></param>)</parameter_list></cpp:macro>     <cpp:value>__declspec(dllexport) type</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AP_DECLARE_DATA</name></cpp:macro>             <cpp:value>__declspec(dllexport)</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AP_DECLARE</name><parameter_list>(<param><type><name>type</name></type></param>)</parameter_list></cpp:macro>            <cpp:value>__declspec(dllimport) type __stdcall</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AP_DECLARE_NONSTD</name><parameter_list>(<param><type><name>type</name></type></param>)</parameter_list></cpp:macro>     <cpp:value>__declspec(dllimport) type</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AP_DECLARE_DATA</name></cpp:macro>             <cpp:value>__declspec(dllimport)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>WIN32</name></expr></argument>)</argument_list></call> || <call><name>defined</name><argument_list>(<argument><expr><name>AP_MODULE_DECLARE_STATIC</name></expr></argument>)</argument_list></call></expr></cpp:if>
<comment type="block">/**
 * Declare a dso module's exported module structure as AP_MODULE_DECLARE_DATA.
 *
 * Unless AP_MODULE_DECLARE_STATIC is defined at compile time, symbols
 * declared with AP_MODULE_DECLARE_DATA are always exported.
 * @code
 * module AP_MODULE_DECLARE_DATA mod_tag
 * @endcode
 */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>WIN32</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AP_MODULE_DECLARE</name><parameter_list>(<param><type><name>type</name></type></param>)</parameter_list></cpp:macro>            <cpp:value>type __stdcall</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AP_MODULE_DECLARE</name><parameter_list>(<param><type><name>type</name></type></param>)</parameter_list></cpp:macro>            <cpp:value>type</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AP_MODULE_DECLARE_NONSTD</name><parameter_list>(<param><type><name>type</name></type></param>)</parameter_list></cpp:macro>     <cpp:value>type</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AP_MODULE_DECLARE_DATA</name></cpp:macro></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<comment type="block">/**
 * AP_MODULE_DECLARE_EXPORT is a no-op.  Unless contradicted by the
 * AP_MODULE_DECLARE_STATIC compile-time symbol, it is assumed and defined.
 *
 * The old SHARED_MODULE compile-time symbol is now the default behavior,
 * so it is no longer referenced anywhere with Apache 2.0.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AP_MODULE_DECLARE_EXPORT</name></cpp:macro></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AP_MODULE_DECLARE</name><parameter_list>(<param><type><name>type</name></type></param>)</parameter_list></cpp:macro>          <cpp:value>__declspec(dllexport) type __stdcall</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AP_MODULE_DECLARE_NONSTD</name><parameter_list>(<param><type><name>type</name></type></param>)</parameter_list></cpp:macro>   <cpp:value>__declspec(dllexport) type</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AP_MODULE_DECLARE_DATA</name></cpp:macro>           <cpp:value>__declspec(dllexport)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"os.h"</cpp:file></cpp:include>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>(!<call><name>defined</name><argument_list>(<argument><expr><name>WIN32</name></expr></argument>)</argument_list></call> &amp;&amp; !<call><name>defined</name><argument_list>(<argument><expr><name>NETWARE</name></expr></argument>)</argument_list></call>) || <call><name>defined</name><argument_list>(<argument><expr><name>__MINGW32__</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ap_config_auto.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ap_config_layout.h"</cpp:file></cpp:include>

<comment type="block">/* Where the main/parent process's pid is logged */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>DEFAULT_PIDLOG</name></cpp:ifndef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DEFAULT_PIDLOG</name></cpp:macro> <cpp:value>DEFAULT_REL_RUNTIMEDIR "/httpd.pid"</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>NETWARE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AP_NONBLOCK_WHEN_MULTI_LISTEN</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>AP_ENABLE_DTRACE</name></expr></argument>)</argument_list></call> &amp;&amp; <name>HAVE_SYS_SDT_H</name></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/sdt.h&gt;</cpp:file></cpp:include>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>_DTRACE_VERSION</name></cpp:undef>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_DTRACE_VERSION</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"apache_probes.h"</cpp:file></cpp:include>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"apache_noprobes.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* If APR has OTHER_CHILD logic, use reliable piped logs. */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>APR_HAS_OTHER_CHILD</name></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AP_HAVE_RELIABLE_PIPED_LOGS</name></cpp:macro> <cpp:value>TRUE</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__STDC_VERSION__</name></expr></argument>)</argument_list></call> &amp;&amp; <name>__STDC_VERSION__</name> &gt;= 199901L</expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AP_HAVE_C99</name></cpp:macro></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* Presume that the compiler supports C99-style designated
 * initializers if using GCC (but not G++), or for any other compiler
 * which claims C99 support. */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>(<call><name>defined</name><argument_list>(<argument><expr><name>__GNUC__</name></expr></argument>)</argument_list></call> &amp;&amp; !<call><name>defined</name><argument_list>(<argument><expr><name>__cplusplus</name></expr></argument>)</argument_list></call>) || <call><name>defined</name><argument_list>(<argument><expr><name>AP_HAVE_C99</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AP_HAVE_DESIGNATED_INITIALIZER</name></cpp:macro></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>__has_attribute</name></cpp:ifndef>         <comment type="block">/* check for supported attributes on clang */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>__has_attribute</name><parameter_list>(<param><type><name>x</name></type></param>)</parameter_list></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>(<call><name>defined</name><argument_list>(<argument><expr><name>__GNUC__</name></expr></argument>)</argument_list></call> &amp;&amp; <name>__GNUC__</name> &gt;= 4) || <call><name>__has_attribute</name><argument_list>(<argument><expr><name>sentinel</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AP_FN_ATTR_SENTINEL</name></cpp:macro> <cpp:value>__attribute__((sentinel))</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AP_FN_ATTR_SENTINEL</name></cpp:macro></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr>( <call><name>defined</name><argument_list>(<argument><expr><name>__GNUC__</name></expr></argument>)</argument_list></call> &amp;&amp;                                        \
      (<name>__GNUC__</name> &gt;= 4 || ( <name>__GNUC__</name> == 3 &amp;&amp; <name>__GNUC_MINOR__</name> &gt;= 4))) \
    || <call><name>__has_attribute</name><argument_list>(<argument><expr><name>warn_unused_result</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AP_FN_ATTR_WARN_UNUSED_RESULT</name></cpp:macro>   <cpp:value>__attribute__((warn_unused_result))</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AP_FN_ATTR_WARN_UNUSED_RESULT</name></cpp:macro></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr>( <call><name>defined</name><argument_list>(<argument><expr><name>__GNUC__</name></expr></argument>)</argument_list></call> &amp;&amp;                                        \
      (<name>__GNUC__</name> &gt;= 4 &amp;&amp; <name>__GNUC_MINOR__</name> &gt;= 3))                     \
    || <call><name>__has_attribute</name><argument_list>(<argument><expr><name>alloc_size</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AP_FN_ATTR_ALLOC_SIZE</name><parameter_list>(<param><type><name>x</name></type></param>)</parameter_list></cpp:macro>     <cpp:value>__attribute__((alloc_size(x)))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AP_FN_ATTR_ALLOC_SIZE2</name><parameter_list>(<param><type><name>x</name></type></param>,<param><type><name>y</name></type></param>)</parameter_list></cpp:macro>  <cpp:value>__attribute__((alloc_size(x,y)))</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AP_FN_ATTR_ALLOC_SIZE</name><parameter_list>(<param><type><name>x</name></type></param>)</parameter_list></cpp:macro></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AP_FN_ATTR_ALLOC_SIZE2</name><parameter_list>(<param><type><name>x</name></type></param>,<param><type><name>y</name></type></param>)</parameter_list></cpp:macro></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* AP_CONFIG_H */</comment>
</unit>
