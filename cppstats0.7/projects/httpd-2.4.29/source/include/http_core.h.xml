<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C" filename="projects/httpd-2.4.29/include/http_core.h"><comment type="block">/* Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */</comment>

<comment type="block">/**
 * @file  http_core.h
 * @brief CORE HTTP Daemon
 *
 * @defgroup APACHE_CORE_HTTPD Core HTTP Daemon
 * @ingroup  APACHE_CORE
 * @{
 */</comment>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>APACHE_HTTP_CORE_H</name></cpp:ifndef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>APACHE_HTTP_CORE_H</name></cpp:macro></cpp:define>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"apr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"apr_hash.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"apr_optional.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"util_filter.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ap_expr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"apr_tables.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"http_config.h"</cpp:file></cpp:include>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>APR_HAVE_STRUCT_RLIMIT</name></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/time.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/resource.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__cplusplus</name></cpp:ifdef>
<extern>extern "C" <block>{
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* ****************************************************************
 *
 * The most basic server code is encapsulated in a single module
 * known as the core, which is just *barely* functional enough to
 * serve documents, though not terribly well.
 *
 * Largely for NCSA back-compatibility reasons, the core needs to
 * make pieces of its config structures available to other modules.
 * The accessors are declared here, along with the interpretation
 * of one of them (allow_options).
 */</comment>

<comment type="block">/**
 * @defgroup APACHE_CORE_HTTPD_ACESSORS Acessors
 *
 * @brief File/Directory Accessor directives
 *
 * @{
 */</comment>

<comment type="block">/** No directives */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>OPT_NONE</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<comment type="block">/** Indexes directive */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>OPT_INDEXES</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<comment type="block">/** SSI is enabled without exec= permission  */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>OPT_INCLUDES</name></cpp:macro> <cpp:value>2</cpp:value></cpp:define>
<comment type="block">/**  FollowSymLinks directive */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>OPT_SYM_LINKS</name></cpp:macro> <cpp:value>4</cpp:value></cpp:define>
<comment type="block">/**  ExecCGI directive */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>OPT_EXECCGI</name></cpp:macro> <cpp:value>8</cpp:value></cpp:define>
<comment type="block">/**  directive unset */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>OPT_UNSET</name></cpp:macro> <cpp:value>16</cpp:value></cpp:define>
<comment type="block">/**  SSI exec= permission is permitted, iff OPT_INCLUDES is also set */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>OPT_INC_WITH_EXEC</name></cpp:macro> <cpp:value>32</cpp:value></cpp:define>
<comment type="block">/** SymLinksIfOwnerMatch directive */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>OPT_SYM_OWNER</name></cpp:macro> <cpp:value>64</cpp:value></cpp:define>
<comment type="block">/** MultiViews directive */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>OPT_MULTI</name></cpp:macro> <cpp:value>128</cpp:value></cpp:define>
<comment type="block">/**  All directives */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>OPT_ALL</name></cpp:macro> <cpp:value>(OPT_INDEXES|OPT_INCLUDES|OPT_INC_WITH_EXEC|OPT_SYM_LINKS|OPT_EXECCGI)</cpp:value></cpp:define>
<comment type="block">/** @} */</comment>

<comment type="block">/**
 * @defgroup get_remote_host Remote Host Resolution
 * @ingroup APACHE_CORE_HTTPD
 * @{
 */</comment>
<comment type="block">/** REMOTE_HOST returns the hostname, or NULL if the hostname
 * lookup fails.  It will force a DNS lookup according to the
 * HostnameLookups setting.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>REMOTE_HOST</name></cpp:macro> <cpp:value>(0)</cpp:value></cpp:define>

<comment type="block">/** REMOTE_NAME returns the hostname, or the dotted quad if the
 * hostname lookup fails.  It will force a DNS lookup according
 * to the HostnameLookups setting.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>REMOTE_NAME</name></cpp:macro> <cpp:value>(1)</cpp:value></cpp:define>

<comment type="block">/** REMOTE_NOLOOKUP is like REMOTE_NAME except that a DNS lookup is
 * never forced.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>REMOTE_NOLOOKUP</name></cpp:macro> <cpp:value>(2)</cpp:value></cpp:define>

<comment type="block">/** REMOTE_DOUBLE_REV will always force a DNS lookup, and also force
 * a double reverse lookup, regardless of the HostnameLookups
 * setting.  The result is the (double reverse checked) hostname,
 * or NULL if any of the lookups fail.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>REMOTE_DOUBLE_REV</name></cpp:macro> <cpp:value>(3)</cpp:value></cpp:define>

<comment type="block">/** @} // get_remote_host */</comment>

<comment type="block">/** all of the requirements must be met */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SATISFY_ALL</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<comment type="block">/**  any of the requirements must be met */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SATISFY_ANY</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<comment type="block">/** There are no applicable satisfy lines */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SATISFY_NOSPEC</name></cpp:macro> <cpp:value>2</cpp:value></cpp:define>

<comment type="block">/** Make sure we don't write less than 8000 bytes at any one time.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AP_MIN_BYTES_TO_WRITE</name></cpp:macro>  <cpp:value>8000</cpp:value></cpp:define>

<comment type="block">/** default maximum of internal redirects */</comment>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>AP_DEFAULT_MAX_INTERNAL_REDIRECTS</name></cpp:macro> <cpp:value>10</cpp:value></cpp:define>

<comment type="block">/** default maximum subrequest nesting level */</comment>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>AP_DEFAULT_MAX_SUBREQ_DEPTH</name></cpp:macro> <cpp:value>10</cpp:value></cpp:define>

<comment type="block">/**
 * Retrieve the value of Options for this request
 * @param r The current request
 * @return the Options bitmask
 */</comment>
<macro><name>AP_DECLARE</name><argument_list>(<argument>int</argument>)</argument_list></macro> <expr_stmt><expr><call><name>ap_allow_options</name><argument_list>(<argument><expr><name>request_rec</name> *<name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/**
 * Retrieve the value of the AllowOverride for this request
 * @param r The current request
 * @return the overrides bitmask
 */</comment>
<macro><name>AP_DECLARE</name><argument_list>(<argument>int</argument>)</argument_list></macro> <expr_stmt><expr><call><name>ap_allow_overrides</name><argument_list>(<argument><expr><name>request_rec</name> *<name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/**
 * Retrieve the document root for this server
 * @param r The current request
 * @warning Don't use this!  If your request went through a Userdir, or
 * something like that, it'll screw you.  But it's back-compatible...
 * @return The document root
 */</comment>
<macro><name>AP_DECLARE</name><argument_list>(<argument>const char *</argument>)</argument_list></macro> <expr_stmt><expr><call><name>ap_document_root</name><argument_list>(<argument><expr><name>request_rec</name> *<name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/**
 * Lookup the remote user agent's DNS name or IP address
 * @ingroup get_remote_hostname
 * @param req The current request
 * @param type The type of lookup to perform.  One of:
 * &lt;pre&gt;
 *     REMOTE_HOST returns the hostname, or NULL if the hostname
 *                 lookup fails.  It will force a DNS lookup according to the
 *                 HostnameLookups setting.
 *     REMOTE_NAME returns the hostname, or the dotted quad if the
 *                 hostname lookup fails.  It will force a DNS lookup according
 *                 to the HostnameLookups setting.
 *     REMOTE_NOLOOKUP is like REMOTE_NAME except that a DNS lookup is
 *                     never forced.
 *     REMOTE_DOUBLE_REV will always force a DNS lookup, and also force
 *                   a double reverse lookup, regardless of the HostnameLookups
 *                   setting.  The result is the (double reverse checked)
 *                   hostname, or NULL if any of the lookups fail.
 * &lt;/pre&gt;
 * @param str_is_ip unless NULL is passed, this will be set to non-zero on
 *        output when an IP address string is returned
 * @return The remote hostname (based on the request useragent_ip)
 */</comment>
<macro><name>AP_DECLARE</name><argument_list>(<argument>const char *</argument>)</argument_list></macro> <macro><name>ap_get_useragent_host</name><argument_list>(<argument>request_rec *req</argument>, <argument>int type</argument>,
                                               <argument>int *str_is_ip</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

<comment type="block">/**
 * Lookup the remote client's DNS name or IP address
 * @ingroup get_remote_host
 * @param conn The current connection
 * @param dir_config The directory config vector from the request
 * @param type The type of lookup to perform.  One of:
 * &lt;pre&gt;
 *     REMOTE_HOST returns the hostname, or NULL if the hostname
 *                 lookup fails.  It will force a DNS lookup according to the
 *                 HostnameLookups setting.
 *     REMOTE_NAME returns the hostname, or the dotted quad if the
 *                 hostname lookup fails.  It will force a DNS lookup according
 *                 to the HostnameLookups setting.
 *     REMOTE_NOLOOKUP is like REMOTE_NAME except that a DNS lookup is
 *                     never forced.
 *     REMOTE_DOUBLE_REV will always force a DNS lookup, and also force
 *                   a double reverse lookup, regardless of the HostnameLookups
 *                   setting.  The result is the (double reverse checked)
 *                   hostname, or NULL if any of the lookups fail.
 * &lt;/pre&gt;
 * @param str_is_ip unless NULL is passed, this will be set to non-zero on output when an IP address
 *        string is returned
 * @return The remote hostname (based on the connection client_ip)
 */</comment>
<macro><name>AP_DECLARE</name><argument_list>(<argument>const char *</argument>)</argument_list></macro> <macro><name>ap_get_remote_host</name><argument_list>(<argument>conn_rec *conn</argument>, <argument>void *dir_config</argument>, <argument>int type</argument>, <argument>int *str_is_ip</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

<comment type="block">/**
 * Retrieve the login name of the remote user.  Undef if it could not be
 * determined
 * @param r The current request
 * @return The user logged in to the client machine
 */</comment>
<macro><name>AP_DECLARE</name><argument_list>(<argument>const char *</argument>)</argument_list></macro> <expr_stmt><expr><call><name>ap_get_remote_logname</name><argument_list>(<argument><expr><name>request_rec</name> *<name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/* Used for constructing self-referencing URLs, and things like SERVER_PORT,
 * and SERVER_NAME.
 */</comment>
<comment type="block">/**
 * build a fully qualified URL from the uri and information in the request rec
 * @param p The pool to allocate the URL from
 * @param uri The path to the requested file
 * @param r The current request
 * @return A fully qualified URL
 */</comment>
<macro><name>AP_DECLARE</name><argument_list>(<argument>char *</argument>)</argument_list></macro> <expr_stmt><expr><call><name>ap_construct_url</name><argument_list>(<argument><expr><name>apr_pool_t</name> *<name>p</name></expr></argument>, <argument><expr>const <name>char</name> *<name>uri</name></expr></argument>, <argument><expr><name>request_rec</name> *<name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/**
 * Get the current server name from the request
 * @param r The current request
 * @return the server name
 */</comment>
<macro><name>AP_DECLARE</name><argument_list>(<argument>const char *</argument>)</argument_list></macro> <expr_stmt><expr><call><name>ap_get_server_name</name><argument_list>(<argument><expr><name>request_rec</name> *<name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/**
 * Get the current server name from the request for the purposes
 * of using in a URL.  If the server name is an IPv6 literal
 * address, it will be returned in URL format (e.g., "[fe80::1]").
 * @param r The current request
 * @return the server name
 */</comment>
<macro><name>AP_DECLARE</name><argument_list>(<argument>const char *</argument>)</argument_list></macro> <expr_stmt><expr><call><name>ap_get_server_name_for_url</name><argument_list>(<argument><expr><name>request_rec</name> *<name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/**
 * Get the current server port
 * @param r The current request
 * @return The server's port
 */</comment>
<macro><name>AP_DECLARE</name><argument_list>(<argument>apr_port_t</argument>)</argument_list></macro> <expr_stmt><expr><call><name>ap_get_server_port</name><argument_list>(<argument><expr>const <name>request_rec</name> *<name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/**
 * Return the limit on bytes in request msg body
 * @param r The current request
 * @return the maximum number of bytes in the request msg body
 */</comment>
<macro><name>AP_DECLARE</name><argument_list>(<argument>apr_off_t</argument>)</argument_list></macro> <expr_stmt><expr><call><name>ap_get_limit_req_body</name><argument_list>(<argument><expr>const <name>request_rec</name> *<name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/**
 * Return the limit on bytes in XML request msg body
 * @param r The current request
 * @return the maximum number of bytes in XML request msg body
 */</comment>
<macro><name>AP_DECLARE</name><argument_list>(<argument>apr_size_t</argument>)</argument_list></macro> <expr_stmt><expr><call><name>ap_get_limit_xml_body</name><argument_list>(<argument><expr>const <name>request_rec</name> *<name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/**
 * Install a custom response handler for a given status
 * @param r The current request
 * @param status The status for which the custom response should be used
 * @param string The custom response.  This can be a static string, a file
 *               or a URL
 */</comment>
<macro><name>AP_DECLARE</name><argument_list>(<argument>void</argument>)</argument_list></macro> <macro><name>ap_custom_response</name><argument_list>(<argument>request_rec *r</argument>, <argument>int status</argument>, <argument>const char *string</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

<comment type="block">/**
 * Check if the current request is beyond the configured max. number of redirects or subrequests
 * @param r The current request
 * @return true (is exceeded) or false
 */</comment>
<macro><name>AP_DECLARE</name><argument_list>(<argument>int</argument>)</argument_list></macro> <expr_stmt><expr><call><name>ap_is_recursion_limit_exceeded</name><argument_list>(<argument><expr>const <name>request_rec</name> *<name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/**
 * Check for a definition from the server command line
 * @param name The define to check for
 * @return 1 if defined, 0 otherwise
 */</comment>
<macro><name>AP_DECLARE</name><argument_list>(<argument>int</argument>)</argument_list></macro> <expr_stmt><expr><call><name>ap_exists_config_define</name><argument_list>(<argument><expr>const <name>char</name> *<name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<comment type="block">/* FIXME! See STATUS about how */</comment>
<macro><name>AP_DECLARE_NONSTD</name><argument_list>(<argument>int</argument>)</argument_list></macro> <expr_stmt><expr><call><name>ap_core_translate</name><argument_list>(<argument><expr><name>request_rec</name> *<name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/* Authentication stuff.  This is one of the places where compatibility
 * with the old config files *really* hurts; they don't discriminate at
 * all between different authentication schemes, meaning that we need
 * to maintain common state for all of them in the core, and make it
 * available to the other modules through interfaces.
 */</comment>

<comment type="block">/** @see require_line */</comment>
<typedef>typedef <type>struct <name>require_line</name></type> <name>require_line</name>;</typedef>

<comment type="block">/**
 * @brief A structure to keep track of authorization requirements
*/</comment>
<struct>struct <name>require_line</name> <block>{
    <comment type="block">/** Where the require line is in the config file. */</comment>
    <decl_stmt><decl><type><name>apr_int64_t</name></type> <name>method_mask</name></decl>;</decl_stmt>
    <comment type="block">/** The complete string from the command line */</comment>
    <decl_stmt><decl><type><name>char</name> *</type><name>requirement</name></decl>;</decl_stmt>
}</block>;</struct>

<comment type="block">/**
 * Return the type of authorization required for this request
 * @param r The current request
 * @return The authorization required
 */</comment>
<macro><name>AP_DECLARE</name><argument_list>(<argument>const char *</argument>)</argument_list></macro> <expr_stmt><expr><call><name>ap_auth_type</name><argument_list>(<argument><expr><name>request_rec</name> *<name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/**
 * Return the current Authorization realm
 * @param r The current request
 * @return The current authorization realm
 */</comment>
<macro><name>AP_DECLARE</name><argument_list>(<argument>const char *</argument>)</argument_list></macro> <expr_stmt><expr><call><name>ap_auth_name</name><argument_list>(<argument><expr><name>request_rec</name> *<name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/**
 * How the requires lines must be met.
 * @param r The current request
 * @return How the requirements must be met.  One of:
 * &lt;pre&gt;
 *      SATISFY_ANY    -- any of the requirements must be met.
 *      SATISFY_ALL    -- all of the requirements must be met.
 *      SATISFY_NOSPEC -- There are no applicable satisfy lines
 * &lt;/pre&gt;
 */</comment>
<macro><name>AP_DECLARE</name><argument_list>(<argument>int</argument>)</argument_list></macro> <expr_stmt><expr><call><name>ap_satisfies</name><argument_list>(<argument><expr><name>request_rec</name> *<name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/**
 * Core is also unlike other modules in being implemented in more than
 * one file... so, data structures are declared here, even though most of
 * the code that cares really is in http_core.c.  Also, another accessor.
 */</comment>
<decl_stmt><decl><type><name>AP_DECLARE_DATA</name> <specifier>extern</specifier> <name>module</name></type> <name>core_module</name></decl>;</decl_stmt>

<comment type="block">/**
 * Accessor for core_module's specific data. Equivalent to
 * ap_get_module_config(cv, &amp;core_module) but more efficient.
 * @param cv The vector in which the modules configuration is stored.
 *        usually r-&gt;per_dir_config or s-&gt;module_config
 * @return The module-specific data
 */</comment>
<macro><name>AP_DECLARE</name><argument_list>(<argument>void *</argument>)</argument_list></macro> <expr_stmt><expr><call><name>ap_get_core_module_config</name><argument_list>(<argument><expr>const <name>ap_conf_vector_t</name> *<name>cv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/**
 * Accessor to set core_module's specific data. Equivalent to
 * ap_set_module_config(cv, &amp;core_module, val) but more efficient.
 * @param cv The vector in which the modules configuration is stored.
 *        usually r-&gt;per_dir_config or s-&gt;module_config
 * @param val The module-specific data to set
 */</comment>
<macro><name>AP_DECLARE</name><argument_list>(<argument>void</argument>)</argument_list></macro> <expr_stmt><expr><call><name>ap_set_core_module_config</name><argument_list>(<argument><expr><name>ap_conf_vector_t</name> *<name>cv</name></expr></argument>, <argument><expr><name>void</name> *<name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/** Get the socket from the core network filter. This should be used instead of
 * accessing the core connection config directly.
 * @param c The connection record
 * @return The socket
 */</comment>
<macro><name>AP_DECLARE</name><argument_list>(<argument>apr_socket_t *</argument>)</argument_list></macro> <expr_stmt><expr><call><name>ap_get_conn_socket</name><argument_list>(<argument><expr><name>conn_rec</name> *<name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>AP_DEBUG</name></cpp:ifndef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AP_CORE_MODULE_INDEX</name></cpp:macro>  <cpp:value>0</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ap_get_core_module_config</name><parameter_list>(<param><type><name>v</name></type></param>)</parameter_list></cpp:macro> \
    <cpp:value>(((void **)(v))[AP_CORE_MODULE_INDEX])</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ap_set_core_module_config</name><parameter_list>(<param><type><name>v</name></type></param>, <param><type><name>val</name></type></param>)</parameter_list></cpp:macro> \
    <cpp:value>((((void **)(v))[AP_CORE_MODULE_INDEX]) = (val))</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AP_CORE_MODULE_INDEX</name></cpp:macro>  <cpp:value>(AP_DEBUG_ASSERT(core_module.module_index == 0), 0)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/**
 * @brief  Per-request configuration
*/</comment>
<typedef>typedef <type><struct>struct <block>{
    <comment type="block">/** bucket brigade used by getline for look-ahead and
     * ap_get_client_block for holding left-over request body */</comment>
    <decl_stmt><decl><type>struct <name>apr_bucket_brigade</name> *</type><name>bb</name></decl>;</decl_stmt>

    <comment type="block">/** an array of per-request working data elements, accessed
     * by ID using ap_get_request_note()
     * (Use ap_register_request_note() during initialization
     * to add elements)
     */</comment>
    <decl_stmt><decl><type><name>void</name> **</type><name>notes</name></decl>;</decl_stmt>

    <comment type="block">/** Custom response strings registered via ap_custom_response(),
     * or NULL; check per-dir config if nothing found here
     */</comment>
    <decl_stmt><decl><type><name>char</name> **</type><name>response_code_strings</name></decl>;</decl_stmt> <comment type="block">/* from ap_custom_response(), not from
                                   * ErrorDocument
                                   */</comment>

    <comment type="block">/** per-request document root of the server. This allows mass vhosting
     * modules better compatibility with some scripts. Normally the
     * context_* info should be used instead */</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>document_root</name></decl>;</decl_stmt>

    <comment type="block">/*
     * more fine-grained context information which is set by modules like
     * mod_alias and mod_userdir
     */</comment>
    <comment type="block">/** the context root directory on disk for the current resource,
     *  without trailing slash
     */</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>context_document_root</name></decl>;</decl_stmt>
    <comment type="block">/** the URI prefix that corresponds to the context_document_root directory,
     *  without trailing slash
     */</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>context_prefix</name></decl>;</decl_stmt>

    <comment type="block">/** There is a script processor installed on the output filter chain,
     * so it needs the default_handler to deliver a (script) file into
     * the chain so it can process it. Normally, default_handler only
     * serves files on a GET request (assuming the file is actual content),
     * since other methods are not content-retrieval. This flag overrides
     * that behavior, stating that the "content" is actually a script and
     * won't actually be delivered as the response for the non-GET method.
     */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>deliver_script</name></decl>;</decl_stmt>

    <comment type="block">/** Should addition of charset= be suppressed for this request?
     */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>suppress_charset</name></decl>;</decl_stmt>
}</block></struct></type> <name>core_request_config</name>;</typedef>

<comment type="block">/* Standard entries that are guaranteed to be accessible via
 * ap_get_request_note() for each request (additional entries
 * can be added with ap_register_request_note())
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AP_NOTE_DIRECTORY_WALK</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AP_NOTE_LOCATION_WALK</name></cpp:macro>  <cpp:value>1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AP_NOTE_FILE_WALK</name></cpp:macro>      <cpp:value>2</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AP_NOTE_IF_WALK</name></cpp:macro>        <cpp:value>3</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AP_NUM_STD_NOTES</name></cpp:macro>       <cpp:value>4</cpp:value></cpp:define>

<comment type="block">/**
 * Reserve an element in the core_request_config-&gt;notes array
 * for some application-specific data
 * @return An integer key that can be passed to ap_get_request_note()
 *         during request processing to access this element for the
 *         current request.
 */</comment>
<macro><name>AP_DECLARE</name><argument_list>(<argument>apr_size_t</argument>)</argument_list></macro> <expr_stmt><expr><call><name>ap_register_request_note</name><argument_list>(<argument><expr><name>void</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/**
 * Retrieve a pointer to an element in the core_request_config-&gt;notes array
 * @param r The request
 * @param note_num  A key for the element: either a value obtained from
 *        ap_register_request_note() or one of the predefined AP_NOTE_*
 *        values.
 * @return NULL if the note_num is invalid, otherwise a pointer to the
 *         requested note element.
 * @remark At the start of a request, each note element is NULL.  The
 *         handle provided by ap_get_request_note() is a pointer-to-pointer
 *         so that the caller can point the element to some app-specific
 *         data structure.  The caller should guarantee that any such
 *         structure will last as long as the request itself.
 */</comment>
<macro><name>AP_DECLARE</name><argument_list>(<argument>void **</argument>)</argument_list></macro> <macro><name>ap_get_request_note</name><argument_list>(<argument>request_rec *r</argument>, <argument>apr_size_t note_num</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>


<typedef>typedef <type><name>unsigned</name> <name>char</name></type> <name>allow_options_t</name>;</typedef>
<typedef>typedef <type><name>unsigned</name> <name>int</name></type> <name>overrides_t</name>;</typedef>

<comment type="block">/*
 * Bits of info that go into making an ETag for a file
 * document.  Why a long?  Because char historically
 * proved too short for Options, and int can be different
 * sizes on different platforms.
 */</comment>
<typedef>typedef <type><name>unsigned</name> <name>long</name></type> <name>etag_components_t</name>;</typedef>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ETAG_UNSET</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ETAG_NONE</name></cpp:macro>  <cpp:value>(1 &lt;&lt; 0)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ETAG_MTIME</name></cpp:macro> <cpp:value>(1 &lt;&lt; 1)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ETAG_INODE</name></cpp:macro> <cpp:value>(1 &lt;&lt; 2)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ETAG_SIZE</name></cpp:macro>  <cpp:value>(1 &lt;&lt; 3)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ETAG_ALL</name></cpp:macro>   <cpp:value>(ETAG_MTIME | ETAG_INODE | ETAG_SIZE)</cpp:value></cpp:define>
<comment type="block">/* This is the default value used */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ETAG_BACKWARD</name></cpp:macro> <cpp:value>(ETAG_MTIME | ETAG_SIZE)</cpp:value></cpp:define>

<comment type="block">/* Generic ON/OFF/UNSET for unsigned int foo :2 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AP_CORE_CONFIG_OFF</name></cpp:macro>   <cpp:value>(0)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AP_CORE_CONFIG_ON</name></cpp:macro>    <cpp:value>(1)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AP_CORE_CONFIG_UNSET</name></cpp:macro> <cpp:value>(2)</cpp:value></cpp:define>

<comment type="block">/* Generic merge of flag */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AP_CORE_MERGE_FLAG</name><parameter_list>(<param><type><name>field</name></type></param>, <param><type><name>to</name></type></param>, <param><type><name>base</name></type></param>, <param><type><name>over</name></type></param>)</parameter_list></cpp:macro> <cpp:value>to-&gt;field = \
               over-&gt;field != AP_CORE_CONFIG_UNSET            \
               ? over-&gt;field                                  \
               : base-&gt;field</cpp:value></cpp:define>                                   

<comment type="block">/**
 * @brief Server Signature Enumeration
 */</comment>
<typedef>typedef <type><enum>enum <block>{
    <decl><name>srv_sig_unset</name></decl>,
    <decl><name>srv_sig_off</name></decl>,
    <decl><name>srv_sig_on</name></decl>,
    <decl><name>srv_sig_withmail</name></decl>
}</block></enum></type> <name>server_signature_e</name>;</typedef>

<comment type="block">/**
 * @brief Per-directory configuration
 */</comment>
<typedef>typedef <type><struct>struct <block>{
    <comment type="block">/** path of the directory/regex/etc. see also d_is_fnmatch/absolute below */</comment>
    <decl_stmt><decl><type><name>char</name> *</type><name>d</name></decl>;</decl_stmt>
    <comment type="block">/** the number of slashes in d */</comment>
    <decl_stmt><decl><type><name>unsigned</name></type> <name>d_components</name></decl>;</decl_stmt>

    <comment type="block">/** If (opts &amp; OPT_UNSET) then no absolute assignment to options has
     * been made.
     * invariant: (opts_add &amp; opts_remove) == 0
     * Which said another way means that the last relative (options + or -)
     * assignment made to each bit is recorded in exactly one of opts_add
     * or opts_remove.
     */</comment>
    <decl_stmt><decl><type><name>allow_options_t</name></type> <name>opts</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>allow_options_t</name></type> <name>opts_add</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>allow_options_t</name></type> <name>opts_remove</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>overrides_t</name></type> <name>override</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>allow_options_t</name></type> <name>override_opts</name></decl>;</decl_stmt>

    <comment type="block">/* Used to be the custom response config. No longer used. */</comment>
    <decl_stmt><decl><type><name>char</name> **</type><name>response_code_strings</name></decl>;</decl_stmt> <comment type="block">/* from ErrorDocument, not from
                                   * ap_custom_response() */</comment>

    <comment type="block">/* Hostname resolution etc */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HOSTNAME_LOOKUP_OFF</name></cpp:macro>     <cpp:value>0</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HOSTNAME_LOOKUP_ON</name></cpp:macro>      <cpp:value>1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HOSTNAME_LOOKUP_DOUBLE</name></cpp:macro>  <cpp:value>2</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HOSTNAME_LOOKUP_UNSET</name></cpp:macro>   <cpp:value>3</cpp:value></cpp:define>
    <expr_stmt><expr><name>unsigned</name> <name>int</name> <name>hostname_lookups</name> : 4</expr>;</expr_stmt>

    <expr_stmt><expr><name>unsigned</name> <name>int</name> <name>content_md5</name> : 2</expr>;</expr_stmt>  <comment type="block">/* calculate Content-MD5? */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>USE_CANONICAL_NAME_OFF</name></cpp:macro>   <cpp:value>(0)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>USE_CANONICAL_NAME_ON</name></cpp:macro>    <cpp:value>(1)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>USE_CANONICAL_NAME_DNS</name></cpp:macro>   <cpp:value>(2)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>USE_CANONICAL_NAME_UNSET</name></cpp:macro> <cpp:value>(3)</cpp:value></cpp:define>
    <expr_stmt><expr><name>unsigned</name> <name>use_canonical_name</name> : 2</expr>;</expr_stmt>

    <comment type="block">/* since is_fnmatch(conf-&gt;d) was being called so frequently in
     * directory_walk() and its relatives, this field was created and
     * is set to the result of that call.
     */</comment>
    <expr_stmt><expr><name>unsigned</name> <name>d_is_fnmatch</name> : 1</expr>;</expr_stmt>

    <comment type="block">/* should we force a charset on any outgoing parameterless content-type?
     * if so, which charset?
     */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ADD_DEFAULT_CHARSET_OFF</name></cpp:macro>   <cpp:value>(0)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ADD_DEFAULT_CHARSET_ON</name></cpp:macro>    <cpp:value>(1)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ADD_DEFAULT_CHARSET_UNSET</name></cpp:macro> <cpp:value>(2)</cpp:value></cpp:define>
    <expr_stmt><expr><name>unsigned</name> <name>add_default_charset</name> : 2</expr>;</expr_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>add_default_charset_name</name></decl>;</decl_stmt>

    <comment type="block">/* System Resource Control */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>RLIMIT_CPU</name></cpp:ifdef>
    <decl_stmt><decl><type>struct <name>rlimit</name> *</type><name>limit_cpu</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name> <argument_list>(<argument><expr><name>RLIMIT_DATA</name></expr></argument>)</argument_list></call> || <call><name>defined</name> <argument_list>(<argument><expr><name>RLIMIT_VMEM</name></expr></argument>)</argument_list></call> || <call><name>defined</name><argument_list>(<argument><expr><name>RLIMIT_AS</name></expr></argument>)</argument_list></call></expr></cpp:if>
    <decl_stmt><decl><type>struct <name>rlimit</name> *</type><name>limit_mem</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>RLIMIT_NPROC</name></cpp:ifdef>
    <decl_stmt><decl><type>struct <name>rlimit</name> *</type><name>limit_nproc</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <decl_stmt><decl><type><name>apr_off_t</name></type> <name>limit_req_body</name></decl>;</decl_stmt>      <comment type="block">/* limit on bytes in request msg body */</comment>
    <decl_stmt><decl><type><name>long</name></type> <name>limit_xml_body</name></decl>;</decl_stmt>           <comment type="block">/* limit on bytes in XML request msg body */</comment>

    <comment type="block">/* logging options */</comment>

    <decl_stmt><decl><type><name>server_signature_e</name></type> <name>server_signature</name></decl>;</decl_stmt>

    <comment type="block">/* Access control */</comment>
    <decl_stmt><decl><type><name>apr_array_header_t</name> *</type><name>sec_file</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_array_header_t</name> *</type><name>sec_if</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ap_regex_t</name> *</type><name>r</name></decl>;</decl_stmt>

    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>mime_type</name></decl>;</decl_stmt>       <comment type="block">/* forced with ForceType  */</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>handler</name></decl>;</decl_stmt>         <comment type="block">/* forced by something other than SetHandler */</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>output_filters</name></decl>;</decl_stmt>  <comment type="block">/* forced with SetOutputFilters */</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>input_filters</name></decl>;</decl_stmt>   <comment type="block">/* forced with SetInputFilters */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>accept_path_info</name></decl>;</decl_stmt>        <comment type="block">/* forced with AcceptPathInfo */</comment>

    <comment type="block">/*
     * What attributes/data should be included in ETag generation?
     */</comment>
    <decl_stmt><decl><type><name>etag_components_t</name></type> <name>etag_bits</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>etag_components_t</name></type> <name>etag_add</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>etag_components_t</name></type> <name>etag_remove</name></decl>;</decl_stmt>

    <comment type="block">/*
     * Run-time performance tuning
     */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ENABLE_MMAP_OFF</name></cpp:macro>    <cpp:value>(0)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ENABLE_MMAP_ON</name></cpp:macro>     <cpp:value>(1)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ENABLE_MMAP_UNSET</name></cpp:macro>  <cpp:value>(2)</cpp:value></cpp:define>
    <expr_stmt><expr><name>unsigned</name> <name>int</name> <name>enable_mmap</name> : 2</expr>;</expr_stmt>  <comment type="block">/* whether files in this dir can be mmap'ed */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ENABLE_SENDFILE_OFF</name></cpp:macro>    <cpp:value>(0)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ENABLE_SENDFILE_ON</name></cpp:macro>     <cpp:value>(1)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ENABLE_SENDFILE_UNSET</name></cpp:macro>  <cpp:value>(2)</cpp:value></cpp:define>
    <expr_stmt><expr><name>unsigned</name> <name>int</name> <name>enable_sendfile</name> : 2</expr>;</expr_stmt>  <comment type="block">/* files in this dir can be sendfile'ed */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>USE_CANONICAL_PHYS_PORT_OFF</name></cpp:macro>   <cpp:value>(0)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>USE_CANONICAL_PHYS_PORT_ON</name></cpp:macro>    <cpp:value>(1)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>USE_CANONICAL_PHYS_PORT_UNSET</name></cpp:macro> <cpp:value>(2)</cpp:value></cpp:define>
    <expr_stmt><expr><name>unsigned</name> <name>int</name> <name>use_canonical_phys_port</name> : 2</expr>;</expr_stmt>

    <expr_stmt><expr><name>unsigned</name> <name>int</name> <name>allow_encoded_slashes</name> : 1</expr>;</expr_stmt> <comment type="block">/* URLs may contain %2f w/o being
                                             * pitched indiscriminately */</comment>
    <expr_stmt><expr><name>unsigned</name> <name>int</name> <name>decode_encoded_slashes</name> : 1</expr>;</expr_stmt> <comment type="block">/* whether to decode encoded slashes in URLs */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AP_CONDITION_IF</name></cpp:macro>        <cpp:value>1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AP_CONDITION_ELSE</name></cpp:macro>      <cpp:value>2</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AP_CONDITION_ELSEIF</name></cpp:macro>    <cpp:value>(AP_CONDITION_ELSE|AP_CONDITION_IF)</cpp:value></cpp:define>
    <expr_stmt><expr><name>unsigned</name> <name>int</name> <name>condition_ifelse</name> : 2</expr>;</expr_stmt> <comment type="block">/* is this an &lt;If&gt;, &lt;ElseIf&gt;, or &lt;Else&gt; */</comment>

    <decl_stmt><decl><type><name>ap_expr_info_t</name> *</type><name>condition</name></decl>;</decl_stmt>   <comment type="block">/* Conditionally merge &lt;If&gt; sections */</comment>

    <comment type="block">/** per-dir log config */</comment>
    <decl_stmt><decl><type>struct <name>ap_logconf</name> *</type><name>log</name></decl>;</decl_stmt>

    <comment type="block">/** Table of directives allowed per AllowOverrideList */</comment>
    <decl_stmt><decl><type><name>apr_table_t</name> *</type><name>override_list</name></decl>;</decl_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AP_MAXRANGES_UNSET</name></cpp:macro>     <cpp:value>-1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AP_MAXRANGES_DEFAULT</name></cpp:macro>   <cpp:value>-2</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AP_MAXRANGES_UNLIMITED</name></cpp:macro> <cpp:value>-3</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AP_MAXRANGES_NORANGES</name></cpp:macro>   <cpp:value>0</cpp:value></cpp:define>
    <comment type="block">/** Number of Ranges before returning HTTP_OK. **/</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>max_ranges</name></decl>;</decl_stmt>
    <comment type="block">/** Max number of Range overlaps (merges) allowed **/</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>max_overlaps</name></decl>;</decl_stmt>
    <comment type="block">/** Max number of Range reversals (eg: 200-300, 100-125) allowed **/</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>max_reversals</name></decl>;</decl_stmt>

    <comment type="block">/** Named back references */</comment>
    <decl_stmt><decl><type><name>apr_array_header_t</name> *</type><name>refs</name></decl>;</decl_stmt>

    <comment type="block">/** Custom response config with expression support. The hash table
     * contains compiled expressions keyed against the custom response
     * code.
     */</comment>
    <decl_stmt><decl><type><name>apr_hash_t</name> *</type><name>response_code_exprs</name></decl>;</decl_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AP_CGI_PASS_AUTH_OFF</name></cpp:macro>     <cpp:value>(0)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AP_CGI_PASS_AUTH_ON</name></cpp:macro>      <cpp:value>(1)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AP_CGI_PASS_AUTH_UNSET</name></cpp:macro>   <cpp:value>(2)</cpp:value></cpp:define>
    <comment type="block">/** CGIPassAuth: Whether HTTP authorization headers will be passed to
     * scripts as CGI variables; affects all modules calling
     * ap_add_common_vars(), as well as any others using this field as 
     * advice
     */</comment>
    <expr_stmt><expr><name>unsigned</name> <name>int</name> <name>cgi_pass_auth</name> : 2</expr>;</expr_stmt>
    <expr_stmt><expr><name>unsigned</name> <name>int</name> <name>qualify_redirect_url</name> :2</expr>;</expr_stmt>
    <decl_stmt><decl><type><name>ap_expr_info_t</name>  *</type><name>expr_handler</name></decl>;</decl_stmt>         <comment type="block">/* forced with SetHandler */</comment>

    <comment type="block">/** Table of rules for building CGI variables, NULL if none configured */</comment>
    <decl_stmt><decl><type><name>apr_hash_t</name> *</type><name>cgi_var_rules</name></decl>;</decl_stmt>
}</block></struct></type> <name>core_dir_config</name>;</typedef>

<comment type="block">/* macro to implement off by default behaviour */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AP_SENDFILE_ENABLED</name><parameter_list>(<param><type><name>x</name></type></param>)</parameter_list></cpp:macro> \
    <cpp:value>((x) == ENABLE_SENDFILE_ON ? APR_SENDFILE_ENABLED : 0)</cpp:value></cpp:define>

<comment type="block">/* Per-server core configuration */</comment>

<typedef>typedef <type><struct>struct <block>{

    <decl_stmt><decl><type><name>char</name> *</type><name>gprof_dir</name></decl>;</decl_stmt>

    <comment type="block">/* Name translations --- we want the core to be able to do *something*
     * so it's at least a minimally functional web server on its own (and
     * can be tested that way).  But let's keep it to the bare minimum:
     */</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>ap_document_root</name></decl>;</decl_stmt>

    <comment type="block">/* Access control */</comment>

    <decl_stmt><decl><type><name>char</name> *</type><name>access_name</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_array_header_t</name> *</type><name>sec_dir</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_array_header_t</name> *</type><name>sec_url</name></decl>;</decl_stmt>

    <comment type="block">/* recursion backstopper */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>redirect_limit</name></decl>;</decl_stmt> <comment type="block">/* maximum number of internal redirects */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>subreq_limit</name></decl>;</decl_stmt>   <comment type="block">/* maximum nesting level of subrequests */</comment>

    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>protocol</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_table_t</name> *</type><name>accf_map</name></decl>;</decl_stmt>

    <comment type="block">/* array of ap_errorlog_format_item for error log format string */</comment>
    <decl_stmt><decl><type><name>apr_array_header_t</name> *</type><name>error_log_format</name></decl>;</decl_stmt>
    <comment type="block">/*
     * two arrays of arrays of ap_errorlog_format_item for additional information
     * logged to the error log once per connection/request
     */</comment>
    <decl_stmt><decl><type><name>apr_array_header_t</name> *</type><name>error_log_conn</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_array_header_t</name> *</type><name>error_log_req</name></decl>;</decl_stmt>

    <comment type="block">/* TRACE control */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AP_TRACE_UNSET</name></cpp:macro>    <cpp:value>-1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AP_TRACE_DISABLE</name></cpp:macro>   <cpp:value>0</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AP_TRACE_ENABLE</name></cpp:macro>    <cpp:value>1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AP_TRACE_EXTENDED</name></cpp:macro>  <cpp:value>2</cpp:value></cpp:define>
    <decl_stmt><decl><type><name>int</name></type> <name>trace_enable</name></decl>;</decl_stmt>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AP_MERGE_TRAILERS_UNSET</name></cpp:macro>    <cpp:value>0</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AP_MERGE_TRAILERS_ENABLE</name></cpp:macro>   <cpp:value>1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AP_MERGE_TRAILERS_DISABLE</name></cpp:macro>  <cpp:value>2</cpp:value></cpp:define>
    <decl_stmt><decl><type><name>int</name></type> <name>merge_trailers</name></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>apr_array_header_t</name> *</type><name>protocols</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>protocols_honor_order</name></decl>;</decl_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AP_HTTP09_UNSET</name></cpp:macro>   <cpp:value>0</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AP_HTTP09_ENABLE</name></cpp:macro>  <cpp:value>1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AP_HTTP09_DISABLE</name></cpp:macro> <cpp:value>2</cpp:value></cpp:define>
    <decl_stmt><decl><type><name>char</name></type> <name>http09_enable</name></decl>;</decl_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AP_HTTP_CONFORMANCE_UNSET</name></cpp:macro>     <cpp:value>0</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AP_HTTP_CONFORMANCE_UNSAFE</name></cpp:macro>    <cpp:value>1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AP_HTTP_CONFORMANCE_STRICT</name></cpp:macro>    <cpp:value>2</cpp:value></cpp:define>
    <decl_stmt><decl><type><name>char</name></type> <name>http_conformance</name></decl>;</decl_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AP_HTTP_METHODS_UNSET</name></cpp:macro>         <cpp:value>0</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AP_HTTP_METHODS_LENIENT</name></cpp:macro>       <cpp:value>1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AP_HTTP_METHODS_REGISTERED</name></cpp:macro>    <cpp:value>2</cpp:value></cpp:define>
    <decl_stmt><decl><type><name>char</name></type> <name>http_methods</name></decl>;</decl_stmt>

}</block></struct></type> <name>core_server_config</name>;</typedef>

<comment type="block">/* for AddOutputFiltersByType in core.c */</comment>
<function_decl><type><name>void</name></type> <name>ap_add_output_filters_by_type</name><parameter_list>(<param><decl><type><name>request_rec</name> *</type><name>r</name></decl></param>)</parameter_list>;</function_decl>

<comment type="block">/* for http_config.c */</comment>
<function_decl><type><name>void</name></type> <name>ap_core_reorder_directories</name><parameter_list>(<param><decl><type><name>apr_pool_t</name> *</type></decl></param>, <param><decl><type><name>server_rec</name> *</type></decl></param>)</parameter_list>;</function_decl>

<comment type="block">/* for mod_perl */</comment>
<macro><name>AP_CORE_DECLARE</name><argument_list>(<argument>void</argument>)</argument_list></macro> <expr_stmt><expr><call><name>ap_add_per_dir_conf</name><argument_list>(<argument><expr><name>server_rec</name> *<name>s</name></expr></argument>, <argument><expr><name>void</name> *<name>dir_config</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<macro><name>AP_CORE_DECLARE</name><argument_list>(<argument>void</argument>)</argument_list></macro> <expr_stmt><expr><call><name>ap_add_per_url_conf</name><argument_list>(<argument><expr><name>server_rec</name> *<name>s</name></expr></argument>, <argument><expr><name>void</name> *<name>url_config</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<macro><name>AP_CORE_DECLARE</name><argument_list>(<argument>void</argument>)</argument_list></macro> <expr_stmt><expr><call><name>ap_add_file_conf</name><argument_list>(<argument><expr><name>apr_pool_t</name> *<name>p</name></expr></argument>, <argument><expr><name>core_dir_config</name> *<name>conf</name></expr></argument>, <argument><expr><name>void</name> *<name>url_config</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<macro><name>AP_CORE_DECLARE</name><argument_list>(<argument>const char *</argument>)</argument_list></macro> <expr_stmt><expr><call><name>ap_add_if_conf</name><argument_list>(<argument><expr><name>apr_pool_t</name> *<name>p</name></expr></argument>, <argument><expr><name>core_dir_config</name> *<name>conf</name></expr></argument>, <argument><expr><name>void</name> *<name>url_config</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<macro><name>AP_CORE_DECLARE_NONSTD</name><argument_list>(<argument>const char *</argument>)</argument_list></macro> <expr_stmt><expr><call><name>ap_limit_section</name><argument_list>(<argument><expr><name>cmd_parms</name> *<name>cmd</name></expr></argument>, <argument><expr><name>void</name> *<name>dummy</name></expr></argument>, <argument><expr>const <name>char</name> *<name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/* Core filters; not exported. */</comment>
<function_decl><type><name>apr_status_t</name></type> <name>ap_core_input_filter</name><parameter_list>(<param><decl><type><name>ap_filter_t</name> *</type><name>f</name></decl></param>, <param><decl><type><name>apr_bucket_brigade</name> *</type><name>b</name></decl></param>,
                                  <param><decl><type><name>ap_input_mode_t</name></type> <name>mode</name></decl></param>, <param><decl><type><name>apr_read_type_e</name></type> <name>block</name></decl></param>,
                                  <param><decl><type><name>apr_off_t</name></type> <name>readbytes</name></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><name>apr_status_t</name></type> <name>ap_core_output_filter</name><parameter_list>(<param><decl><type><name>ap_filter_t</name> *</type><name>f</name></decl></param>, <param><decl><type><name>apr_bucket_brigade</name> *</type><name>b</name></decl></param>)</parameter_list>;</function_decl>


<macro><name>AP_DECLARE</name><argument_list>(<argument>const char*</argument>)</argument_list></macro> <expr_stmt><expr><call><name>ap_get_server_protocol</name><argument_list>(<argument><expr><name>server_rec</name>* <name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<macro><name>AP_DECLARE</name><argument_list>(<argument>void</argument>)</argument_list></macro> <expr_stmt><expr><call><name>ap_set_server_protocol</name><argument_list>(<argument><expr><name>server_rec</name>* <name>s</name></expr></argument>, <argument><expr>const <name>char</name>* <name>proto</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<typedef>typedef <type>struct <name>core_output_filter_ctx</name></type> <name>core_output_filter_ctx_t</name>;</typedef>
<typedef>typedef <type>struct <name>core_filter_ctx</name></type>        <name>core_ctx_t</name>;</typedef>

<typedef>typedef <type><struct>struct <name>core_net_rec</name> <block>{
    <comment type="block">/** Connection to the client */</comment>
    <decl_stmt><decl><type><name>apr_socket_t</name> *</type><name>client_socket</name></decl>;</decl_stmt>

    <comment type="block">/** connection record */</comment>
    <decl_stmt><decl><type><name>conn_rec</name> *</type><name>c</name></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>core_output_filter_ctx_t</name> *</type><name>out_ctx</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>core_ctx_t</name> *</type><name>in_ctx</name></decl>;</decl_stmt>
}</block></struct></type> <name>core_net_rec</name>;</typedef>

<comment type="block">/**
 * Insert the network bucket into the core input filter's input brigade.
 * This hook is intended for MPMs or protocol modules that need to do special
 * socket setup.
 * @param c The connection
 * @param bb The brigade to insert the bucket into
 * @param socket The socket to put into a bucket
 * @return AP_DECLINED if the current function does not handle this connection,
 *         APR_SUCCESS or an error otherwise.
 */</comment>
<macro><name>AP_DECLARE_HOOK</name><argument_list>(<argument>apr_status_t</argument>, <argument>insert_network_bucket</argument>,
                <argument>(conn_rec *c, apr_bucket_brigade *bb, apr_socket_t *socket)</argument>)</argument_list></macro>

<comment type="block">/* ----------------------------------------------------------------------
 *
 * Runtime status/management
 */</comment>

<typedef>typedef <type><enum>enum <block>{
    <decl><name>ap_mgmt_type_string</name></decl>,
    <decl><name>ap_mgmt_type_long</name></decl>,
    <decl><name>ap_mgmt_type_hash</name></decl>
}</block></enum></type> <name>ap_mgmt_type_e</name>;</typedef>

<typedef>typedef <type><union>union <block>{
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>s_value</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>long</name></type> <name>i_value</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_hash_t</name> *</type><name>h_value</name></decl>;</decl_stmt>
}</block></union></type> <name>ap_mgmt_value</name>;</typedef>

<typedef>typedef <type><struct>struct <block>{
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>description</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>name</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ap_mgmt_type_e</name></type> <name>vtype</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ap_mgmt_value</name></type> <name>v</name></decl>;</decl_stmt>
}</block></struct></type> <name>ap_mgmt_item_t</name>;</typedef>

<comment type="block">/* Handles for core filters */</comment>
<decl_stmt><decl><type><name>AP_DECLARE_DATA</name> <specifier>extern</specifier> <name>ap_filter_rec_t</name> *</type><name>ap_subreq_core_filter_handle</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>AP_DECLARE_DATA</name> <specifier>extern</specifier> <name>ap_filter_rec_t</name> *</type><name>ap_core_output_filter_handle</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>AP_DECLARE_DATA</name> <specifier>extern</specifier> <name>ap_filter_rec_t</name> *</type><name>ap_content_length_filter_handle</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>AP_DECLARE_DATA</name> <specifier>extern</specifier> <name>ap_filter_rec_t</name> *</type><name>ap_core_input_filter_handle</name></decl>;</decl_stmt>

<comment type="block">/**
 * This hook provdes a way for modules to provide metrics/statistics about
 * their operational status.
 *
 * @param p A pool to use to create entries in the hash table
 * @param val The name of the parameter(s) that is wanted. This is
 *            tree-structured would be in the form ('*' is all the tree,
 *            'module.*' all of the module , 'module.foo.*', or
 *            'module.foo.bar' )
 * @param ht The hash table to store the results. Keys are item names, and
 *           the values point to ap_mgmt_item_t structures.
 * @ingroup hooks
 */</comment>
<macro><name>AP_DECLARE_HOOK</name><argument_list>(<argument>int</argument>, <argument>get_mgmt_items</argument>,
                <argument>(apr_pool_t *p, const char * val, apr_hash_t *ht)</argument>)</argument_list></macro>

<comment type="block">/* ---------------------------------------------------------------------- */</comment>

<comment type="block">/* ----------------------------------------------------------------------
 *
 * I/O logging with mod_logio
 */</comment>

<expr_stmt><expr><call><name>APR_DECLARE_OPTIONAL_FN</name><argument_list>(<argument><expr><name>void</name></expr></argument>, <argument><expr><name>ap_logio_add_bytes_out</name></expr></argument>,
                        <argument><expr>(<name>conn_rec</name> *<name>c</name>, <name>apr_off_t</name> <name>bytes</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>APR_DECLARE_OPTIONAL_FN</name><argument_list>(<argument><expr><name>void</name></expr></argument>, <argument><expr><name>ap_logio_add_bytes_in</name></expr></argument>,
                        <argument><expr>(<name>conn_rec</name> *<name>c</name>, <name>apr_off_t</name> <name>bytes</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>APR_DECLARE_OPTIONAL_FN</name><argument_list>(<argument><expr><name>apr_off_t</name></expr></argument>, <argument><expr><name>ap_logio_get_last_bytes</name></expr></argument>, <argument><expr>(<name>conn_rec</name> *<name>c</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/* ----------------------------------------------------------------------
 *
 * Error log formats
 */</comment>

<comment type="block">/**
 * The info structure passed to callback functions of errorlog handlers.
 * Not all information is available in all contexts. In particular, all
 * pointers may be NULL.
 */</comment>
<typedef>typedef <type><struct>struct <name>ap_errorlog_info</name> <block>{
    <comment type="block">/** current server_rec.
     *  Should be preferred over c-&gt;base_server and r-&gt;server
     */</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>server_rec</name> *</type><name>s</name></decl>;</decl_stmt>

    <comment type="block">/** current conn_rec.
     *  Should be preferred over r-&gt;connection
     */</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>conn_rec</name> *</type><name>c</name></decl>;</decl_stmt>

    <comment type="block">/** current request_rec. */</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>request_rec</name> *</type><name>r</name></decl>;</decl_stmt>
    <comment type="block">/** r-&gt;main if r is a subrequest, otherwise equal to r */</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>request_rec</name> *</type><name>rmain</name></decl>;</decl_stmt>

    <comment type="block">/** pool passed to ap_log_perror, NULL otherwise */</comment>
    <decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl>;</decl_stmt>

    <comment type="block">/** name of source file where the log message was produced, NULL if N/A. */</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>file</name></decl>;</decl_stmt>
    <comment type="block">/** line number in the source file, 0 if N/A */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>line</name></decl>;</decl_stmt>

    <comment type="block">/** module index of module that produced the log message, APLOG_NO_MODULE if N/A. */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>module_index</name></decl>;</decl_stmt>
    <comment type="block">/** log level of error message (flags like APLOG_STARTUP have been removed), -1 if N/A */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>level</name></decl>;</decl_stmt>

    <comment type="block">/** apr error status related to the log message, 0 if no error */</comment>
    <decl_stmt><decl><type><name>apr_status_t</name></type> <name>status</name></decl>;</decl_stmt>

    <comment type="block">/** 1 if logging to syslog, 0 otherwise */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>using_syslog</name></decl>;</decl_stmt>
    <comment type="block">/** 1 if APLOG_STARTUP was set for the log message, 0 otherwise */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>startup</name></decl>;</decl_stmt>

    <comment type="block">/** message format */</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>format</name></decl>;</decl_stmt>
}</block></struct></type> <name>ap_errorlog_info</name>;</typedef>

<comment type="block">/**
 * callback function prototype for a external errorlog handler
 * @note To avoid unbounded memory usage, these functions must not allocate
 * memory from the server, connection, or request pools. If an errorlog
 * handler absolutely needs a pool to pass to other functions, it must create
 * and destroy a sub-pool.
 */</comment>
<typedef>typedef <function_decl><type><name>int</name></type> <name>ap_errorlog_handler_fn_t</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>ap_errorlog_info</name> *</type><name>info</name></decl></param>,
                                     <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>arg</name></decl></param>, <param><decl><type><name>char</name> *</type><name>buf</name></decl></param>, <param><decl><type><name>int</name></type> <name>buflen</name></decl></param>)</parameter_list>;</function_decl></typedef>

<comment type="block">/**
 * Register external errorlog handler
 * @param p config pool to use
 * @param tag the new format specifier (i.e. the letter after the %)
 * @param handler the handler function
 * @param flags flags (reserved, set to 0)
 */</comment>
<macro><name>AP_DECLARE</name><argument_list>(<argument>void</argument>)</argument_list></macro> <macro><name>ap_register_errorlog_handler</name><argument_list>(<argument>apr_pool_t *p</argument>, <argument>char *tag</argument>,
                                              <argument>ap_errorlog_handler_fn_t *handler</argument>,
                                              <argument>int flags</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

<typedef>typedef <type><struct>struct <name>ap_errorlog_handler</name> <block>{
    <decl_stmt><decl><type><name>ap_errorlog_handler_fn_t</name> *</type><name>func</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>flags</name></decl>;</decl_stmt> <comment type="block">/* for future extensions */</comment>
}</block></struct></type> <name>ap_errorlog_handler</name>;</typedef>

  <comment type="block">/** item starts a new field */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AP_ERRORLOG_FLAG_FIELD_SEP</name></cpp:macro>       <cpp:value>1</cpp:value></cpp:define>
  <comment type="block">/** item is the actual error message */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AP_ERRORLOG_FLAG_MESSAGE</name></cpp:macro>         <cpp:value>2</cpp:value></cpp:define>
  <comment type="block">/** skip whole line if item is zero-length */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AP_ERRORLOG_FLAG_REQUIRED</name></cpp:macro>        <cpp:value>4</cpp:value></cpp:define>
  <comment type="block">/** log zero-length item as '-' */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AP_ERRORLOG_FLAG_NULL_AS_HYPHEN</name></cpp:macro>  <cpp:value>8</cpp:value></cpp:define>

<typedef>typedef <type><struct>struct <block>{
    <comment type="block">/** ap_errorlog_handler function */</comment>
    <decl_stmt><decl><type><name>ap_errorlog_handler_fn_t</name> *</type><name>func</name></decl>;</decl_stmt>
    <comment type="block">/** argument passed to item in {} */</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>arg</name></decl>;</decl_stmt>
    <comment type="block">/** a combination of the AP_ERRORLOG_* flags */</comment>
    <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>flags</name></decl>;</decl_stmt>
    <comment type="block">/** only log item if the message's log level is higher than this */</comment>
    <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>min_loglevel</name></decl>;</decl_stmt>
}</block></struct></type> <name>ap_errorlog_format_item</name>;</typedef>

<comment type="block">/**
 * hook method to log error messages
 * @ingroup hooks
 * @param info pointer to ap_errorlog_info struct which contains all
 *        the details
 * @param errstr the (unformatted) message to log
 * @warning Allocating from the usual pools (pool, info-&gt;c-&gt;pool, info-&gt;p-&gt;pool)
 *          must be avoided because it can cause memory leaks.
 *          Use a subpool if necessary.
 */</comment>
<macro><name>AP_DECLARE_HOOK</name><argument_list>(<argument>void</argument>, <argument>error_log</argument>, <argument>(const ap_errorlog_info *info,
                                  const char *errstr)</argument>)</argument_list></macro>

<macro><name>AP_CORE_DECLARE</name><argument_list>(<argument>void</argument>)</argument_list></macro> <expr_stmt><expr><call><name>ap_register_log_hooks</name><argument_list>(<argument><expr><name>apr_pool_t</name> *<name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<macro><name>AP_CORE_DECLARE</name><argument_list>(<argument>void</argument>)</argument_list></macro> <expr_stmt><expr><call><name>ap_register_config_hooks</name><argument_list>(<argument><expr><name>apr_pool_t</name> *<name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/* ----------------------------------------------------------------------
 *
 * ident lookups with mod_ident
 */</comment>

<expr_stmt><expr><call><name>APR_DECLARE_OPTIONAL_FN</name><argument_list>(<argument><expr>const <name>char</name> *</expr></argument>, <argument><expr><name>ap_ident_lookup</name></expr></argument>,
                        <argument><expr>(<name>request_rec</name> *<name>r</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/* ----------------------------------------------------------------------
 *
 * authorization values with mod_authz_core
 */</comment>

<expr_stmt><expr><call><name>APR_DECLARE_OPTIONAL_FN</name><argument_list>(<argument><expr><name>int</name></expr></argument>, <argument><expr><name>authz_some_auth_required</name></expr></argument>, <argument><expr>(<name>request_rec</name> *<name>r</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>APR_DECLARE_OPTIONAL_FN</name><argument_list>(<argument><expr>const <name>char</name> *</expr></argument>, <argument><expr><name>authn_ap_auth_type</name></expr></argument>, <argument><expr>(<name>request_rec</name> *<name>r</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>APR_DECLARE_OPTIONAL_FN</name><argument_list>(<argument><expr>const <name>char</name> *</expr></argument>, <argument><expr><name>authn_ap_auth_name</name></expr></argument>, <argument><expr>(<name>request_rec</name> *<name>r</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/* ----------------------------------------------------------------------
 *
 * authorization values with mod_access_compat
 */</comment>

<expr_stmt><expr><call><name>APR_DECLARE_OPTIONAL_FN</name><argument_list>(<argument><expr><name>int</name></expr></argument>, <argument><expr><name>access_compat_ap_satisfies</name></expr></argument>, <argument><expr>(<name>request_rec</name> *<name>r</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/* ---------------------------------------------------------------------- */</comment>

<comment type="block">/** Query the server for some state information
 * @param query_code Which information is requested
 * @return the requested state information
 */</comment>
<macro><name>AP_DECLARE</name><argument_list>(<argument>int</argument>)</argument_list></macro> <macro><name>ap_state_query</name><argument_list>(<argument>int query_code</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

<comment type="block">/*
 * possible values for query_code in ap_state_query()
 */</comment>

  <comment type="block">/** current status of the server */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AP_SQ_MAIN_STATE</name></cpp:macro>        <cpp:value>0</cpp:value></cpp:define>
  <comment type="block">/** are we going to serve requests or are we just testing/dumping config */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AP_SQ_RUN_MODE</name></cpp:macro>          <cpp:value>1</cpp:value></cpp:define>
    <comment type="block">/** generation of the top-level apache parent */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AP_SQ_CONFIG_GEN</name></cpp:macro>        <cpp:value>2</cpp:value></cpp:define>

<comment type="block">/*
 * return values for ap_state_query()
 */</comment>

  <comment type="block">/** return value for unknown query_code */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AP_SQ_NOT_SUPPORTED</name></cpp:macro>       <cpp:value>-1</cpp:value></cpp:define>

<comment type="block">/* values returned for AP_SQ_MAIN_STATE */</comment>
  <comment type="block">/** before the config preflight */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AP_SQ_MS_INITIAL_STARTUP</name></cpp:macro>   <cpp:value>1</cpp:value></cpp:define>
  <comment type="block">/** initial configuration run for setting up log config, etc. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AP_SQ_MS_CREATE_PRE_CONFIG</name></cpp:macro> <cpp:value>2</cpp:value></cpp:define>
  <comment type="block">/** tearing down configuration */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AP_SQ_MS_DESTROY_CONFIG</name></cpp:macro>    <cpp:value>3</cpp:value></cpp:define>
  <comment type="block">/** normal configuration run */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AP_SQ_MS_CREATE_CONFIG</name></cpp:macro>     <cpp:value>4</cpp:value></cpp:define>
  <comment type="block">/** running the MPM */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AP_SQ_MS_RUN_MPM</name></cpp:macro>           <cpp:value>5</cpp:value></cpp:define>
  <comment type="block">/** cleaning up for exit */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AP_SQ_MS_EXITING</name></cpp:macro>           <cpp:value>6</cpp:value></cpp:define>

<comment type="block">/* values returned for AP_SQ_RUN_MODE */</comment>
  <comment type="block">/** command line not yet parsed */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AP_SQ_RM_UNKNOWN</name></cpp:macro>           <cpp:value>1</cpp:value></cpp:define>
  <comment type="block">/** normal operation (server requests or signal server) */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AP_SQ_RM_NORMAL</name></cpp:macro>            <cpp:value>2</cpp:value></cpp:define>
  <comment type="block">/** config test only */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AP_SQ_RM_CONFIG_TEST</name></cpp:macro>       <cpp:value>3</cpp:value></cpp:define>
  <comment type="block">/** only dump some parts of the config */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AP_SQ_RM_CONFIG_DUMP</name></cpp:macro>       <cpp:value>4</cpp:value></cpp:define>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__cplusplus</name></cpp:ifdef>
}</block></extern>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>  <comment type="block">/* !APACHE_HTTP_CORE_H */</comment>
<comment type="block">/** @} */</comment>
</unit>
