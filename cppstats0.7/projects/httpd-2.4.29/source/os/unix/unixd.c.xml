<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C" filename="projects/httpd-2.4.29/os/unix/unixd.c"><comment type="block">/* Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ap_config.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"httpd.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"http_config.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"http_main.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"http_log.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"unixd.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"mpm_common.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"os.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ap_mpm.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"apr_thread_proc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"apr_strings.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"apr_portable.h"</cpp:file></cpp:include>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_PWD_H</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;pwd.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_SYS_RESOURCE_H</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/resource.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<comment type="block">/* XXX */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/stat.h&gt;</cpp:file></cpp:include>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_UNISTD_H</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;unistd.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_GRP_H</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;grp.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_STRINGS_H</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;strings.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_SYS_SEM_H</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/sem.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_SYS_PRCTL_H</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/prctl.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<decl_stmt><decl><type><name>unixd_config_rec</name></type> <name>ap_unixd_config</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>APLOG_USE_MODULE</name><argument_list>(<argument><expr><name>core</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<macro><name>AP_DECLARE</name><argument_list>(<argument>void</argument>)</argument_list></macro> <macro><name>ap_unixd_set_rlimit</name><argument_list>(<argument>cmd_parms *cmd</argument>, <argument>struct rlimit **plimit</argument>,
                                     <argument>const char *arg</argument>,
                                     <argument>const char * arg2</argument>, <argument>int type</argument>)</argument_list></macro>
<block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>(<call><name>defined</name><argument_list>(<argument><expr><name>RLIMIT_CPU</name></expr></argument>)</argument_list></call> || <call><name>defined</name><argument_list>(<argument><expr><name>RLIMIT_DATA</name></expr></argument>)</argument_list></call> || <call><name>defined</name><argument_list>(<argument><expr><name>RLIMIT_VMEM</name></expr></argument>)</argument_list></call> || <call><name>defined</name><argument_list>(<argument><expr><name>RLIMIT_NPROC</name></expr></argument>)</argument_list></call> || <call><name>defined</name><argument_list>(<argument><expr><name>RLIMIT_AS</name></expr></argument>)</argument_list></call>) &amp;&amp; <name>APR_HAVE_STRUCT_RLIMIT</name> &amp;&amp; <name>APR_HAVE_GETRLIMIT</name></expr></cpp:if>
    <decl_stmt><decl><type><name>char</name> *</type><name>str</name></decl>;</decl_stmt>
    <decl_stmt><decl><type>struct <name>rlimit</name> *</type><name>limit</name></decl>;</decl_stmt>
    <comment type="block">/* If your platform doesn't define rlim_t then typedef it in ap_config.h */</comment>
    <decl_stmt><decl><type><name>rlim_t</name></type> <name>cur</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>rlim_t</name></type> <name>max</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>

    <expr_stmt><expr>*<name>plimit</name> = (struct <name>rlimit</name> *)<call><name>apr_pcalloc</name><argument_list>(<argument><expr><name><name>cmd</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>**<name>plimit</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>limit</name> = *<name>plimit</name></expr>;</expr_stmt>
    <if>if <condition>(<expr>(<call><name>getrlimit</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><name>limit</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then>  <block>{
        <expr_stmt><expr>*<name>plimit</name> = <name>NULL</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_ERR</name></expr></argument>, <argument><expr><name>errno</name></expr></argument>, <argument><expr><name><name>cmd</name>-&gt;<name>server</name></name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>02172</expr></argument>)</argument_list></call>
                     "%s: getrlimit failed"</expr></argument>, <argument><expr><name><name>cmd</name>-&gt;<name>cmd</name>-&gt;<name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return;</return>
    }</block></then></if>

    <if>if <condition>(<expr>*(<name>str</name> = <call><name>ap_getword_conf</name><argument_list>(<argument><expr><name><name>cmd</name>-&gt;<name>temp_pool</name></name></expr></argument>, <argument><expr>&amp;<name>arg</name></expr></argument>)</argument_list></call>) != '\0'</expr>)</condition><then> <block>{
        <if>if <condition>(<expr>!<call><name>strcasecmp</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr>"max"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>cur</name> = <name><name>limit</name>-&gt;<name>rlim_max</name></name></expr>;</expr_stmt>
        }</block></then>
        <else>else <block>{
            <expr_stmt><expr><name>cur</name> = <call><name>atol</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></else></if>
    }</block></then>
    <else>else <block>{
        <expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_ERR</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name><name>cmd</name>-&gt;<name>server</name></name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>02173</expr></argument>)</argument_list></call>
                     "Invalid parameters for %s"</expr></argument>, <argument><expr><name><name>cmd</name>-&gt;<name>cmd</name>-&gt;<name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return;</return>
    }</block></else></if>

    <if>if <condition>(<expr><name>arg2</name> &amp;&amp; (*(<name>str</name> = <call><name>ap_getword_conf</name><argument_list>(<argument><expr><name><name>cmd</name>-&gt;<name>temp_pool</name></name></expr></argument>, <argument><expr>&amp;<name>arg2</name></expr></argument>)</argument_list></call>) != '\0')</expr>)</condition><then> <block>{
        <expr_stmt><expr><name>max</name> = <call><name>atol</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

    <comment type="block">/* if we aren't running as root, cannot increase max */</comment>
    <if>if <condition>(<expr><call><name>geteuid</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><name><name>limit</name>-&gt;<name>rlim_cur</name></name> = <name>cur</name></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>max</name> &amp;&amp; (<name>max</name> &gt; <name><name>limit</name>-&gt;<name>rlim_max</name></name>)</expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_ERR</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name><name>cmd</name>-&gt;<name>server</name></name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>02174</expr></argument>)</argument_list></call>
                         "Must be uid 0 to raise maximum %s"</expr></argument>, <argument><expr><name><name>cmd</name>-&gt;<name>cmd</name>-&gt;<name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then>
        <else>else <if>if <condition>(<expr><name>max</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name><name>limit</name>-&gt;<name>rlim_max</name></name> = <name>max</name></expr>;</expr_stmt>
        }</block></then></if></else></if>
    }</block></then>
    <else>else <block>{
        <if>if <condition>(<expr><name>cur</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name><name>limit</name>-&gt;<name>rlim_cur</name></name> = <name>cur</name></expr>;</expr_stmt>
        }</block></then></if>
        <if>if <condition>(<expr><name>max</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name><name>limit</name>-&gt;<name>rlim_max</name></name> = <name>max</name></expr>;</expr_stmt>
        }</block></then></if>
    }</block></else></if>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

    <expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_ERR</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name><name>cmd</name>-&gt;<name>server</name></name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>02175</expr></argument>)</argument_list></call>
                 "Platform does not support rlimit for %s"</expr></argument>, <argument><expr><name><name>cmd</name>-&gt;<name>cmd</name>-&gt;<name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block>

<macro><name>APR_HOOK_STRUCT</name><argument_list>(
               <argument>APR_HOOK_LINK(get_suexec_identity)</argument>
)</argument_list></macro>

<macro><name>AP_IMPLEMENT_HOOK_RUN_FIRST</name><argument_list>(<argument>ap_unix_identity_t *</argument>, <argument>get_suexec_identity</argument>,
                         <argument>(const request_rec *r)</argument>, <argument>(r)</argument>, <argument>NULL</argument>)</argument_list></macro>

<function><type><specifier>static</specifier> <name>apr_status_t</name></type> <name>ap_unix_create_privileged_process</name><parameter_list>(
                              <param><decl><type><name>apr_proc_t</name> *</type><name>newproc</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>progname</name></decl></param>,
                              <param><decl><type><specifier>const</specifier> <name>char</name> * <specifier>const</specifier> *</type><name>args</name></decl></param>,
                              <param><decl><type><specifier>const</specifier> <name>char</name> * <specifier>const</specifier> *</type><name>env</name></decl></param>,
                              <param><decl><type><name>apr_procattr_t</name> *</type><name>attr</name></decl></param>, <param><decl><type><name>ap_unix_identity_t</name> *</type><name>ugid</name></decl></param>,
                              <param><decl><type><name>apr_pool_t</name> *</type><name>p</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> **</type><name>newargs</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> *</type><name>newprogname</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> *</type><name>execuser</name></decl>, *<decl><type ref="prev"/><name>execgroup</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>argv0</name></decl>;</decl_stmt>

    <if>if <condition>(<expr>!<name><name>ap_unixd_config</name>.<name>suexec_enabled</name></name></expr>)</condition><then> <block>{
        <return>return <expr><call><name>apr_proc_create</name><argument_list>(<argument><expr><name>newproc</name></expr></argument>, <argument><expr><name>progname</name></expr></argument>, <argument><expr><name>args</name></expr></argument>, <argument><expr><name>env</name></expr></argument>, <argument><expr><name>attr</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></then></if>

    <expr_stmt><expr><name>argv0</name> = <call><name>ap_strrchr_c</name><argument_list>(<argument><expr><name>progname</name></expr></argument>, <argument><expr>'/'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* Allow suexec's "/" check to succeed */</comment>
    <if>if <condition>(<expr><name>argv0</name> != <name>NULL</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>argv0</name>++</expr>;</expr_stmt>
    }</block></then>
    <else>else <block>{
        <expr_stmt><expr><name>argv0</name> = <name>progname</name></expr>;</expr_stmt>
    }</block></else></if>


    <if>if <condition>(<expr><name><name>ugid</name>-&gt;<name>userdir</name></name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>execuser</name> = <call><name>apr_psprintf</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr>"~%ld"</expr></argument>, <argument><expr>(<name>long</name>) <name><name>ugid</name>-&gt;<name>uid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then>
    <else>else <block>{
        <expr_stmt><expr><name>execuser</name> = <call><name>apr_psprintf</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr>"%ld"</expr></argument>, <argument><expr>(<name>long</name>) <name><name>ugid</name>-&gt;<name>uid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>
    <expr_stmt><expr><name>execgroup</name> = <call><name>apr_psprintf</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr>"%ld"</expr></argument>, <argument><expr>(<name>long</name>) <name><name>ugid</name>-&gt;<name>gid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr>!<name>execuser</name> || !<name>execgroup</name></expr>)</condition><then> <block>{
        <return>return <expr><name>APR_ENOMEM</name></expr>;</return>
    }</block></then></if>

    <expr_stmt><expr><name>i</name> = 0</expr>;</expr_stmt>
    <while>while <condition>(<expr><name><name>args</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition>
        <expr_stmt><expr><name>i</name>++</expr>;</expr_stmt></while>
    <comment type="block">/* allocate space for 4 new args, the input args, and a null terminator */</comment>
    <expr_stmt><expr><name>newargs</name> = <call><name>apr_palloc</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>char</name> *</expr></argument>)</argument_list></sizeof> * (<name>i</name> + 4)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>newprogname</name> = <name>SUEXEC_BIN</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>newargs</name><index>[<expr>0</expr>]</index></name> = <name>SUEXEC_BIN</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>newargs</name><index>[<expr>1</expr>]</index></name> = <name>execuser</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>newargs</name><index>[<expr>2</expr>]</index></name> = <name>execgroup</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>newargs</name><index>[<expr>3</expr>]</index></name> = <call><name>apr_pstrdup</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>argv0</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
    ** using a shell to execute suexec makes no sense thus
    ** we force everything to be APR_PROGRAM, and never
    ** APR_SHELLCMD
    */</comment>
    <if>if<condition>(<expr><call><name>apr_procattr_cmdtype_set</name><argument_list>(<argument><expr><name>attr</name></expr></argument>, <argument><expr><name>APR_PROGRAM</name></expr></argument>)</argument_list></call> != <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
        <return>return <expr><name>APR_EGENERAL</name></expr>;</return>
    }</block></then></if>

    <expr_stmt><expr><name>i</name> = 1</expr>;</expr_stmt>
    <do>do <block>{
        <expr_stmt><expr><name><name>newargs</name><index>[<expr><name>i</name> + 3</expr>]</index></name> = <name><name>args</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
    }</block> while <condition>(<expr><name><name>args</name><index>[<expr><name>i</name>++</expr>]</index></name></expr>)</condition>;</do>

    <return>return <expr><call><name>apr_proc_create</name><argument_list>(<argument><expr><name>newproc</name></expr></argument>, <argument><expr><name>newprogname</name></expr></argument>, <argument><expr><name>newargs</name></expr></argument>, <argument><expr><name>env</name></expr></argument>, <argument><expr><name>attr</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<macro><name>AP_DECLARE</name><argument_list>(<argument>apr_status_t</argument>)</argument_list></macro> <macro><name>ap_os_create_privileged_process</name><argument_list>(
    <argument>const request_rec *r</argument>,
    <argument>apr_proc_t *newproc</argument>, <argument>const char *progname</argument>,
    <argument>const char * const *args</argument>,
    <argument>const char * const *env</argument>,
    <argument>apr_procattr_t *attr</argument>, <argument>apr_pool_t *p</argument>)</argument_list></macro>
<block>{
    <decl_stmt><decl><type><name>ap_unix_identity_t</name> *</type><name>ugid</name> <init>= <expr><call><name>ap_run_get_suexec_identity</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr><name>ugid</name> == <name>NULL</name></expr>)</condition><then> <block>{
        <return>return <expr><call><name>apr_proc_create</name><argument_list>(<argument><expr><name>newproc</name></expr></argument>, <argument><expr><name>progname</name></expr></argument>, <argument><expr><name>args</name></expr></argument>, <argument><expr><name>env</name></expr></argument>, <argument><expr><name>attr</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></then></if>

    <return>return <expr><call><name>ap_unix_create_privileged_process</name><argument_list>(<argument><expr><name>newproc</name></expr></argument>, <argument><expr><name>progname</name></expr></argument>, <argument><expr><name>args</name></expr></argument>, <argument><expr><name>env</name></expr></argument>,
                                              <argument><expr><name>attr</name></expr></argument>, <argument><expr><name>ugid</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<comment type="block">/* XXX move to APR and externalize (but implement differently :) ) */</comment>
<function><type><specifier>static</specifier> <name>apr_lockmech_e</name></type> <name>proc_mutex_mech</name><parameter_list>(<param><decl><type><name>apr_proc_mutex_t</name> *</type><name>pmutex</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>mechname</name> <init>= <expr><call><name>apr_proc_mutex_name</name><argument_list>(<argument><expr><name>pmutex</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr>!<call><name>strcmp</name><argument_list>(<argument><expr><name>mechname</name></expr></argument>, <argument><expr>"sysvsem"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <return>return <expr><name>APR_LOCK_SYSVSEM</name></expr>;</return>
    }</block></then>
    <else>else <if>if <condition>(<expr>!<call><name>strcmp</name><argument_list>(<argument><expr><name>mechname</name></expr></argument>, <argument><expr>"flock"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <return>return <expr><name>APR_LOCK_FLOCK</name></expr>;</return>
    }</block></then></if></else></if>
    <return>return <expr><name>APR_LOCK_DEFAULT</name></expr>;</return>
}</block></function>

<macro><name>AP_DECLARE</name><argument_list>(<argument>apr_status_t</argument>)</argument_list></macro> <macro><name>ap_unixd_set_proc_mutex_perms</name><argument_list>(<argument>apr_proc_mutex_t *pmutex</argument>)</argument_list></macro>
<block>{
    <if>if <condition>(<expr>!<call><name>geteuid</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name>apr_lockmech_e</name></type> <name>mech</name> <init>= <expr><call><name>proc_mutex_mech</name><argument_list>(<argument><expr><name>pmutex</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <switch>switch<condition>(<expr><name>mech</name></expr>)</condition> <block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>APR_HAS_SYSVSEM_SERIALIZE</name></expr></cpp:if>
        <case>case <expr><name>APR_LOCK_SYSVSEM</name></expr>:
        <block>{
            <decl_stmt><decl><type><name>apr_os_proc_mutex_t</name></type> <name>ospmutex</name></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<name>APR_HAVE_UNION_SEMUN</name></expr></cpp:if>
            <union>union <name>semun</name> <block>{
                <decl_stmt><decl><type><name>long</name></type> <name>val</name></decl>;</decl_stmt>
                <decl_stmt><decl><type>struct <name>semid_ds</name> *</type><name>buf</name></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>unsigned</name> <name>short</name> *</type><name>array</name></decl>;</decl_stmt>
            }</block>;</union>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
            <decl_stmt><decl><type>union <name>semun</name></type> <name>ick</name></decl>;</decl_stmt>
            <decl_stmt><decl><type>struct <name>semid_ds</name></type> <name>buf</name> <init>= <expr><block>{ <expr><block>{ <expr>0</expr> }</block></expr> }</block></expr></init></decl>;</decl_stmt>

            <expr_stmt><expr><call><name>apr_os_proc_mutex_get</name><argument_list>(<argument><expr>&amp;<name>ospmutex</name></expr></argument>, <argument><expr><name>pmutex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>buf</name>.<name>sem_perm</name>.<name>uid</name></name> = <name><name>ap_unixd_config</name>.<name>user_id</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>buf</name>.<name>sem_perm</name>.<name>gid</name></name> = <name><name>ap_unixd_config</name>.<name>group_id</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>buf</name>.<name>sem_perm</name>.<name>mode</name></name> = 0600</expr>;</expr_stmt>
            <expr_stmt><expr><name><name>ick</name>.<name>buf</name></name> = &amp;<name>buf</name></expr>;</expr_stmt>
            <if>if <condition>(<expr><call><name>semctl</name><argument_list>(<argument><expr><name><name>ospmutex</name>.<name>crossproc</name></name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>IPC_SET</name></expr></argument>, <argument><expr><name>ick</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then> <block>{
                <return>return <expr><name>errno</name></expr>;</return>
            }</block></then></if>
        }</block>
        <break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>APR_HAS_FLOCK_SERIALIZE</name></expr></cpp:if>
        </case><case>case <expr><name>APR_LOCK_FLOCK</name></expr>:
        <block>{
            <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>lockfile</name> <init>= <expr><call><name>apr_proc_mutex_lockfile</name><argument_list>(<argument><expr><name>pmutex</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <if>if <condition>(<expr><name>lockfile</name></expr>)</condition><then> <block>{
                <if>if <condition>(<expr><call><name>chown</name><argument_list>(<argument><expr><name>lockfile</name></expr></argument>, <argument><expr><name><name>ap_unixd_config</name>.<name>user_id</name></name></expr></argument>,
                          <argument><expr>-1</expr></argument> <comment type="block">/* no gid change */</comment>)</argument_list></call> &lt; 0</expr>)</condition><then> <block>{
                    <return>return <expr><name>errno</name></expr>;</return>
                }</block></then></if>
            }</block></then></if>
        }</block>
        <break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        </case><default>default:
            <comment type="block">/* do nothing */</comment>
            <break>break;</break>
        </default>}</block></switch>
    }</block></then></if>
    <return>return <expr><name>APR_SUCCESS</name></expr>;</return>
}</block>

<macro><name>AP_DECLARE</name><argument_list>(<argument>apr_status_t</argument>)</argument_list></macro> <macro><name>ap_unixd_set_global_mutex_perms</name><argument_list>(<argument>apr_global_mutex_t *gmutex</argument>)</argument_list></macro>
<block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<name>APR_PROC_MUTEX_IS_GLOBAL</name></expr></cpp:if>
    <decl_stmt><decl><type><name>apr_os_global_mutex_t</name></type> <name>osgmutex</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>apr_os_global_mutex_get</name><argument_list>(<argument><expr>&amp;<name>osgmutex</name></expr></argument>, <argument><expr><name>gmutex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><call><name>ap_unixd_set_proc_mutex_perms</name><argument_list>(<argument><expr><name><name>osgmutex</name>.<name>proc_mutex</name></name></expr></argument>)</argument_list></call></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>  <comment type="block">/* APR_PROC_MUTEX_IS_GLOBAL */</comment>
    <comment type="block">/* In this case, apr_proc_mutex_t and apr_global_mutex_t are the same. */</comment>
    <return>return <expr><call><name>ap_unixd_set_proc_mutex_perms</name><argument_list>(<argument><expr><name>gmutex</name></expr></argument>)</argument_list></call></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* APR_PROC_MUTEX_IS_GLOBAL */</comment>
}</block>

<macro><name>AP_DECLARE</name><argument_list>(<argument>apr_status_t</argument>)</argument_list></macro> <macro><name>ap_unixd_accept</name><argument_list>(<argument>void **accepted</argument>, <argument>ap_listen_rec *lr</argument>,
                                         <argument>apr_pool_t *ptrans</argument>)</argument_list></macro>
<block>{
    <decl_stmt><decl><type><name>apr_socket_t</name> *</type><name>csd</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_status_t</name></type> <name>status</name></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_OSD_POSIX</name></cpp:ifdef>
    <decl_stmt><decl><type><name>int</name></type> <name>sockdes</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <expr_stmt><expr>*<name>accepted</name> = <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>status</name> = <call><name>apr_socket_accept</name><argument_list>(<argument><expr>&amp;<name>csd</name></expr></argument>, <argument><expr><name><name>lr</name>-&gt;<name>sd</name></name></expr></argument>, <argument><expr><name>ptrans</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>status</name> == <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
        <expr_stmt><expr>*<name>accepted</name> = <name>csd</name></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_OSD_POSIX</name></cpp:ifdef>
        <expr_stmt><expr><call><name>apr_os_sock_get</name><argument_list>(<argument><expr>&amp;<name>sockdes</name></expr></argument>, <argument><expr><name>csd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>sockdes</name> &gt;= <name>FD_SETSIZE</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_WARNING</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>ap_server_conf</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>02176</expr></argument>)</argument_list></call>
                         "new file descriptor %d is too large; you probably need "
                         "to rebuild Apache with a larger FD_SETSIZE "
                         "(currently %d)"</expr></argument>,
                         <argument><expr><name>sockdes</name></expr></argument>, <argument><expr><name>FD_SETSIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>apr_socket_close</name><argument_list>(<argument><expr><name>csd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>APR_EINTR</name></expr>;</return>
        }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <return>return <expr><name>APR_SUCCESS</name></expr>;</return>
    }</block></then></if>

    <if>if <condition>(<expr><call><name>APR_STATUS_IS_EINTR</name><argument_list>(<argument><expr><name>status</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <return>return <expr><name>status</name></expr>;</return>
    }</block></then></if>
    <comment type="block">/* Our old behaviour here was to continue after accept()
     * errors.  But this leads us into lots of troubles
     * because most of the errors are quite fatal.  For
     * example, EMFILE can be caused by slow descriptor
     * leaks (say in a 3rd party module, or libc).  It's
     * foolish for us to continue after an EMFILE.  We also
     * seem to tickle kernel bugs on some platforms which
     * lead to never-ending loops here.  So it seems best
     * to just exit in most cases.
     */</comment>
    <switch>switch <condition>(<expr><name>status</name></expr>)</condition> <block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HPUX11</name></expr></argument>)</argument_list></call> &amp;&amp; <call><name>defined</name><argument_list>(<argument><expr><name>ENOBUFS</name></expr></argument>)</argument_list></call></expr></cpp:if>
        <comment type="block">/* On HPUX 11.x, the 'ENOBUFS, No buffer space available'
         * error occurs because the accept() cannot complete.
         * You will not see ENOBUFS with 10.20 because the kernel
         * hides any occurrence from being returned to user space.
         * ENOBUFS with 11.x's TCP/IP stack is possible, and could
         * occur intermittently. As a work-around, we are going to
         * ignore ENOBUFS.
         */</comment>
        <case>case <expr><name>ENOBUFS</name></expr>:
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>EPROTO</name></cpp:ifdef>
        <comment type="block">/* EPROTO on certain older kernels really means
         * ECONNABORTED, so we need to ignore it for them.
         * See discussion in new-httpd archives nh.9701
         * search for EPROTO.
         *
         * Also see nh.9603, search for EPROTO:
         * There is potentially a bug in Solaris 2.x x&lt;6,
         * and other boxes that implement tcp sockets in
         * userland (i.e. on top of STREAMS).  On these
         * systems, EPROTO can actually result in a fatal
         * loop.  See PR#981 for example.  It's hard to
         * handle both uses of EPROTO.
         */</comment>
        </case><case>case <expr><name>EPROTO</name></expr>:
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>ECONNABORTED</name></cpp:ifdef>
        </case><case>case <expr><name>ECONNABORTED</name></expr>:
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <comment type="block">/* Linux generates the rest of these, other tcp
         * stacks (i.e. bsd) tend to hide them behind
         * getsockopt() interfaces.  They occur when
         * the net goes sour or the client disconnects
         * after the three-way handshake has been done
         * in the kernel but before userland has picked
         * up the socket.
         */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>ECONNRESET</name></cpp:ifdef>
        </case><case>case <expr><name>ECONNRESET</name></expr>:
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>ETIMEDOUT</name></cpp:ifdef>
        </case><case>case <expr><name>ETIMEDOUT</name></expr>:
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>EHOSTUNREACH</name></cpp:ifdef>
        </case><case>case <expr><name>EHOSTUNREACH</name></expr>:
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>ENETUNREACH</name></cpp:ifdef>
        </case><case>case <expr><name>ENETUNREACH</name></expr>:
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <comment type="block">/* EAGAIN/EWOULDBLOCK can be returned on BSD-derived
         * TCP stacks when the connection is aborted before
         * we call connect, but only because our listener
         * sockets are non-blocking (AP_NONBLOCK_WHEN_MULTI_LISTEN)
         */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>EAGAIN</name></cpp:ifdef>
        </case><case>case <expr><name>EAGAIN</name></expr>:
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>EWOULDBLOCK</name></cpp:ifdef>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>EAGAIN</name></expr></argument>)</argument_list></call> || <name>EAGAIN</name> != <name>EWOULDBLOCK</name></expr></cpp:if>
        </case><case>case <expr><name>EWOULDBLOCK</name></expr>:
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
            <break>break;</break>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>ENETDOWN</name></cpp:ifdef>
        </case><case>case <expr><name>ENETDOWN</name></expr>:
            <comment type="block">/*
             * When the network layer has been shut down, there
             * is not much use in simply exiting: the parent
             * would simply re-create us (and we'd fail again).
             * Use the CHILDFATAL code to tear the server down.
             * @@@ Martin's idea for possible improvement:
             * A different approach would be to define
             * a new APEXIT_NETDOWN exit code, the reception
             * of which would make the parent shutdown all
             * children, then idle-loop until it detected that
             * the network is up again, and restart the children.
             * Ben Hyde noted that temporary ENETDOWN situations
             * occur in mobile IP.
             */</comment>
            <expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_EMERG</name></expr></argument>, <argument><expr><name>status</name></expr></argument>, <argument><expr><name>ap_server_conf</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>02177</expr></argument>)</argument_list></call>
                         "apr_socket_accept: giving up."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>APR_EGENERAL</name></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/*ENETDOWN*/</comment>

        </case><default>default:
            <comment type="block">/* If the socket has been closed in ap_close_listeners()
             * by the restart/stop action, we may get EBADF.
             * Do not print an error in this case.
             */</comment>
            <if>if <condition>(<expr>!<name><name>lr</name>-&gt;<name>active</name></name></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_DEBUG</name></expr></argument>, <argument><expr><name>status</name></expr></argument>, <argument><expr><name>ap_server_conf</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>02178</expr></argument>)</argument_list></call>
                             "apr_socket_accept failed for inactive listener"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return <expr><name>status</name></expr>;</return>
            }</block></then></if>
            <expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_ERR</name></expr></argument>, <argument><expr><name>status</name></expr></argument>, <argument><expr><name>ap_server_conf</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>02179</expr></argument>)</argument_list></call>
                         "apr_socket_accept: (client socket)"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>APR_EGENERAL</name></expr>;</return>
    </default>}</block></switch>
    <return>return <expr><name>status</name></expr>;</return>
}</block>


<comment type="block">/* Unixes MPMs' */</comment>

<decl_stmt><decl><type><specifier>static</specifier> <name>ap_unixd_mpm_retained_data</name> *</type><name>retained_data</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<macro><name>AP_DECLARE</name><argument_list>(<argument>ap_unixd_mpm_retained_data *</argument>)</argument_list></macro> <macro><name>ap_unixd_mpm_get_retained_data</name><argument_list>()</argument_list></macro>
<block>{
    <if>if <condition>(<expr>!<name>retained_data</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>retained_data</name> = <call><name>ap_retained_data_create</name><argument_list>(<argument><expr>"ap_unixd_mpm_retained_data"</expr></argument>,
                                                <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>*<name>retained_data</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>retained_data</name>-&gt;<name>mpm_state</name></name> = <name>AP_MPMQ_STARTING</name></expr>;</expr_stmt>
    }</block></then></if>
    <return>return <expr><name>retained_data</name></expr>;</return>
}</block>

<function><type><specifier>static</specifier> <name>void</name></type> <name>sig_term</name><parameter_list>(<param><decl><type><name>int</name></type> <name>sig</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><name><name>retained_data</name>-&gt;<name>mpm_state</name></name> = <name>AP_MPMQ_STOPPING</name></expr>;</expr_stmt>
    <if>if <condition>(<expr><name><name>retained_data</name>-&gt;<name>shutdown_pending</name></name>
            &amp;&amp; (<name><name>retained_data</name>-&gt;<name>is_ungraceful</name></name>
                || <name>sig</name> == <name>AP_SIG_GRACEFUL_STOP</name>)</expr>)</condition><then> <block>{
        <comment type="block">/* Already handled */</comment>
        <return>return;</return>
    }</block></then></if>

    <expr_stmt><expr><name><name>retained_data</name>-&gt;<name>shutdown_pending</name></name> = 1</expr>;</expr_stmt>
    <if>if <condition>(<expr><name>sig</name> != <name>AP_SIG_GRACEFUL_STOP</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name><name>retained_data</name>-&gt;<name>is_ungraceful</name></name> = 1</expr>;</expr_stmt>
    }</block></then></if>
}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>sig_restart</name><parameter_list>(<param><decl><type><name>int</name></type> <name>sig</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><name><name>retained_data</name>-&gt;<name>mpm_state</name></name> = <name>AP_MPMQ_STOPPING</name></expr>;</expr_stmt>
    <if>if <condition>(<expr><name><name>retained_data</name>-&gt;<name>restart_pending</name></name>
            &amp;&amp; (<name><name>retained_data</name>-&gt;<name>is_ungraceful</name></name>
                || <name>sig</name> == <name>AP_SIG_GRACEFUL</name>)</expr>)</condition><then> <block>{
        <comment type="block">/* Already handled */</comment>
        <return>return;</return>
    }</block></then></if>

    <expr_stmt><expr><name><name>retained_data</name>-&gt;<name>restart_pending</name></name> = 1</expr>;</expr_stmt>
    <if>if <condition>(<expr><name>sig</name> != <name>AP_SIG_GRACEFUL</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name><name>retained_data</name>-&gt;<name>is_ungraceful</name></name> = 1</expr>;</expr_stmt>
    }</block></then></if>
}</block></function>

<function><type><specifier>static</specifier> <name>apr_status_t</name></type> <name>unset_signals</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>unused</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><name><name>retained_data</name>-&gt;<name>shutdown_pending</name></name> = <name><name>retained_data</name>-&gt;<name>restart_pending</name></name> = 0</expr>;</expr_stmt>
    <expr_stmt><expr><name><name>retained_data</name>-&gt;<name>was_graceful</name></name> = !<name><name>retained_data</name>-&gt;<name>is_ungraceful</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>retained_data</name>-&gt;<name>is_ungraceful</name></name> = 0</expr>;</expr_stmt>

    <return>return <expr><name>APR_SUCCESS</name></expr>;</return>
}</block></function>

<macro><name>AP_DECLARE</name><argument_list>(<argument>void</argument>)</argument_list></macro> <macro><name>ap_unixd_mpm_set_signals</name><argument_list>(<argument>apr_pool_t *pconf</argument>, <argument>int one_process</argument>)</argument_list></macro>
<block>{
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>NO_USE_SIGACTION</name></cpp:ifndef>
    <decl_stmt><decl><type>struct <name>sigaction</name></type> <name>sa</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/* Signals' handlers depend on retained data */</comment>
    <expr_stmt><expr>(<name>void</name>)<call><name>ap_unixd_mpm_get_retained_data</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>NO_USE_SIGACTION</name></cpp:ifndef>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr>&amp;<name>sa</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>sizeof <name>sa</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sigemptyset</name><argument_list>(<argument><expr>&amp;<name><name>sa</name>.<name>sa_mask</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SIGPIPE</name></cpp:ifdef>
    <expr_stmt><expr><name><name>sa</name>.<name>sa_handler</name></name> = <name>SIG_IGN</name></expr>;</expr_stmt>
    <if>if <condition>(<expr><call><name>sigaction</name><argument_list>(<argument><expr><name>SIGPIPE</name></expr></argument>, <argument><expr>&amp;<name>sa</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
        <expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_WARNING</name></expr></argument>, <argument><expr><name>errno</name></expr></argument>, <argument><expr><name>ap_server_conf</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00269</expr></argument>)</argument_list></call>
                     "sigaction(SIGPIPE)"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SIGXCPU</name></cpp:ifdef>
    <expr_stmt><expr><name><name>sa</name>.<name>sa_handler</name></name> = <name>SIG_DFL</name></expr>;</expr_stmt>
    <if>if <condition>(<expr><call><name>sigaction</name><argument_list>(<argument><expr><name>SIGXCPU</name></expr></argument>, <argument><expr>&amp;<name>sa</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
        <expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_WARNING</name></expr></argument>, <argument><expr><name>errno</name></expr></argument>, <argument><expr><name>ap_server_conf</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00267</expr></argument>)</argument_list></call>
                     "sigaction(SIGXCPU)"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SIGXFSZ</name></cpp:ifdef>
    <comment type="block">/* For systems following the LFS standard, ignoring SIGXFSZ allows
     * a write() beyond the 2GB limit to fail gracefully with E2BIG
     * rather than terminate the process. */</comment>
    <expr_stmt><expr><name><name>sa</name>.<name>sa_handler</name></name> = <name>SIG_IGN</name></expr>;</expr_stmt>
    <if>if <condition>(<expr><call><name>sigaction</name><argument_list>(<argument><expr><name>SIGXFSZ</name></expr></argument>, <argument><expr>&amp;<name>sa</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
        <expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_WARNING</name></expr></argument>, <argument><expr><name>errno</name></expr></argument>, <argument><expr><name>ap_server_conf</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00268</expr></argument>)</argument_list></call>
                     "sigaction(SIGXFSZ)"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <expr_stmt><expr><name><name>sa</name>.<name>sa_handler</name></name> = <name>sig_term</name></expr>;</expr_stmt>
    <if>if <condition>(<expr><call><name>sigaction</name><argument_list>(<argument><expr><name>SIGTERM</name></expr></argument>, <argument><expr>&amp;<name>sa</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
        <expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_WARNING</name></expr></argument>, <argument><expr><name>errno</name></expr></argument>, <argument><expr><name>ap_server_conf</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00264</expr></argument>)</argument_list></call>
                     "sigaction(SIGTERM)"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SIGINT</name></cpp:ifdef>
    <if>if <condition>(<expr><call><name>sigaction</name><argument_list>(<argument><expr><name>SIGINT</name></expr></argument>, <argument><expr>&amp;<name>sa</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
        <expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_WARNING</name></expr></argument>, <argument><expr><name>errno</name></expr></argument>, <argument><expr><name>ap_server_conf</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00266</expr></argument>)</argument_list></call>
                     "sigaction(SIGINT)"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>AP_SIG_GRACEFUL_STOP</name></cpp:ifdef>
    <if>if <condition>(<expr><call><name>sigaction</name><argument_list>(<argument><expr><name>AP_SIG_GRACEFUL_STOP</name></expr></argument>, <argument><expr>&amp;<name>sa</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
        <expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_WARNING</name></expr></argument>, <argument><expr><name>errno</name></expr></argument>, <argument><expr><name>ap_server_conf</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00265</expr></argument>)</argument_list></call>
                     "sigaction(" <name>AP_SIG_GRACEFUL_STOP_STRING</name> ")"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/* Don't catch restart signals in ONE_PROCESS mode :) */</comment>
    <if>if <condition>(<expr>!<name>one_process</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name><name>sa</name>.<name>sa_handler</name></name> = <name>sig_restart</name></expr>;</expr_stmt>
        <if>if <condition>(<expr><call><name>sigaction</name><argument_list>(<argument><expr><name>SIGHUP</name></expr></argument>, <argument><expr>&amp;<name>sa</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
            <expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_WARNING</name></expr></argument>, <argument><expr><name>errno</name></expr></argument>, <argument><expr><name>ap_server_conf</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00270</expr></argument>)</argument_list></call>
                         "sigaction(SIGHUP)"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
        <if>if <condition>(<expr><call><name>sigaction</name><argument_list>(<argument><expr><name>AP_SIG_GRACEFUL</name></expr></argument>, <argument><expr>&amp;<name>sa</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
            <expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_WARNING</name></expr></argument>, <argument><expr><name>errno</name></expr></argument>, <argument><expr><name>ap_server_conf</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00271</expr></argument>)</argument_list></call>
                         "sigaction(" <name>AP_SIG_GRACEFUL_STRING</name> ")"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
    }</block></then></if>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>  <comment type="block">/* NO_USE_SIGACTION */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SIGPIPE</name></cpp:ifdef>
    <expr_stmt><expr><call><name>apr_signal</name><argument_list>(<argument><expr><name>SIGPIPE</name></expr></argument>, <argument><expr><name>SIG_IGN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SIGPIPE */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SIGXCPU</name></cpp:ifdef>
    <expr_stmt><expr><call><name>apr_signal</name><argument_list>(<argument><expr><name>SIGXCPU</name></expr></argument>, <argument><expr><name>SIG_DFL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SIGXCPU */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SIGXFSZ</name></cpp:ifdef>
    <expr_stmt><expr><call><name>apr_signal</name><argument_list>(<argument><expr><name>SIGXFSZ</name></expr></argument>, <argument><expr><name>SIG_IGN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SIGXFSZ */</comment>

    <expr_stmt><expr><call><name>apr_signal</name><argument_list>(<argument><expr><name>SIGTERM</name></expr></argument>, <argument><expr><name>sig_term</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>AP_SIG_GRACEFUL_STOP</name></cpp:ifdef>
    <expr_stmt><expr><call><name>apr_signal</name><argument_list>(<argument><expr><name>AP_SIG_GRACEFUL_STOP</name></expr></argument>, <argument><expr><name>sig_term</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* AP_SIG_GRACEFUL_STOP */</comment>

    <if>if <condition>(<expr>!<name>one_process</name></expr>)</condition><then> <block>{
        <comment type="block">/* Don't restart in ONE_PROCESS mode :) */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SIGHUP</name></cpp:ifdef>
        <expr_stmt><expr><call><name>apr_signal</name><argument_list>(<argument><expr><name>SIGHUP</name></expr></argument>, <argument><expr><name>sig_restart</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SIGHUP */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>AP_SIG_GRACEFUL</name></cpp:ifdef>
        <expr_stmt><expr><call><name>apr_signal</name><argument_list>(<argument><expr><name>AP_SIG_GRACEFUL</name></expr></argument>, <argument><expr><name>sig_restart</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* AP_SIG_GRACEFUL */</comment>
    }</block></then></if>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* NO_USE_SIGACTION */</comment>

    <expr_stmt><expr><call><name>apr_pool_cleanup_register</name><argument_list>(<argument><expr><name>pconf</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>unset_signals</name></expr></argument>,
                              <argument><expr><name>apr_pool_cleanup_null</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block>


<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_OSD_POSIX</name></cpp:ifdef>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"apr_lib.h"</cpp:file></cpp:include>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>USER_LEN</name></cpp:macro> <cpp:value>8</cpp:value></cpp:define>

<typedef>typedef <type><enum>enum
<block>{
    <decl><name>bs2_unknown</name></decl>,     <comment type="block">/* not initialized yet. */</comment>
    <decl><name>bs2_noFORK</name></decl>,      <comment type="block">/* no fork() because -X flag was specified */</comment>
    <decl><name>bs2_FORK</name></decl>,        <comment type="block">/* only fork() because uid != 0 */</comment>
    <decl><name>bs2_UFORK</name></decl>        <comment type="block">/* Normally, ufork() is used to switch identities. */</comment>
}</block></enum></type> <name>bs2_ForkType</name>;</typedef>

<decl_stmt><decl><type><specifier>static</specifier> <name>bs2_ForkType</name></type> <name>forktype</name> <init>= <expr><name>bs2_unknown</name></expr></init></decl>;</decl_stmt>

<comment type="block">/* Determine the method for forking off a child in such a way as to
 * set both the POSIX and BS2000 user id's to the unprivileged user.
 */</comment>
<function><type><specifier>static</specifier> <name>bs2_ForkType</name></type> <name>os_forktype</name><parameter_list>(<param><decl><type><name>int</name></type> <name>one_process</name></decl></param>)</parameter_list>
<block>{
    <comment type="block">/* have we checked the OS version before? If yes return the previous
     * result - the OS release isn't going to change suddenly!
     */</comment>
    <if>if <condition>(<expr><name>forktype</name> == <name>bs2_unknown</name></expr>)</condition><then> <block>{
        <comment type="block">/* not initialized yet */</comment>

        <comment type="block">/* No fork if the one_process option was set */</comment>
        <if>if <condition>(<expr><name>one_process</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>forktype</name> = <name>bs2_noFORK</name></expr>;</expr_stmt>
        }</block></then>
        <comment type="block">/* If the user is unprivileged, use the normal fork() only. */</comment>
        <else>else <if>if <condition>(<expr><call><name>getuid</name><argument_list>()</argument_list></call> != 0</expr>)</condition><then> <block>{
            <expr_stmt><expr><name>forktype</name> = <name>bs2_FORK</name></expr>;</expr_stmt>
        }</block></then>
        <else>else
            <expr_stmt><expr><name>forktype</name> = <name>bs2_UFORK</name></expr>;</expr_stmt></else></if></else></if>
    }</block></then></if>
    <return>return <expr><name>forktype</name></expr>;</return>
}</block></function>



<comment type="block">/* This routine complements the setuid() call: it causes the BS2000 job
 * environment to be switched to the target user's user id.
 * That is important if CGI scripts try to execute native BS2000 commands.
 */</comment>
<function><type><name>int</name></type> <name>os_init_job_environment</name><parameter_list>(<param><decl><type><name>server_rec</name> *</type><name>server</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>user_name</name></decl></param>, <param><decl><type><name>int</name></type> <name>one_process</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>bs2_ForkType</name></type>            <name>type</name> <init>= <expr><call><name>os_forktype</name><argument_list>(<argument><expr><name>one_process</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="block">/* We can be sure that no change to uid==0 is possible because of
     * the checks in http_core.c:set_user()
     */</comment>

    <if>if <condition>(<expr><name>one_process</name></expr>)</condition><then> <block>{

        <expr_stmt><expr><name>type</name> = <name>forktype</name> = <name>bs2_noFORK</name></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_ERR</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>server</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>02180</expr></argument>)</argument_list></call>
                     "The debug mode of Apache should only "
                     "be started by an unprivileged user!"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr>0</expr>;</return>
    }</block></then></if>

    <return>return <expr>0</expr>;</return>
}</block></function>

<comment type="block">/* BS2000 requires a "special" version of fork() before a setuid() call */</comment>
<function><type><name>pid_t</name></type> <name>os_fork</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>user</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>pid_t</name></type> <name>pid</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type>  <name><name>username</name><index>[<expr><name>USER_LEN</name>+1</expr>]</index></name></decl>;</decl_stmt>

    <switch>switch <condition>(<expr><call><name>os_forktype</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>)</condition> <block>{

      <case>case <expr><name>bs2_FORK</name></expr>:
        <expr_stmt><expr><name>pid</name> = <call><name>fork</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>

      </case><case>case <expr><name>bs2_UFORK</name></expr>:
        <expr_stmt><expr><call><name>apr_cpystrn</name><argument_list>(<argument><expr><name>username</name></expr></argument>, <argument><expr><name>user</name></expr></argument>, <argument><expr>sizeof <name>username</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Make user name all upper case - for some versions of ufork() */</comment>
        <expr_stmt><expr><call><name>ap_str_toupper</name><argument_list>(<argument><expr><name>username</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>pid</name> = <call><name>ufork</name><argument_list>(<argument><expr><name>username</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>pid</name> == -1 &amp;&amp; <name>errno</name> == <name>EPERM</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_EMERG</name></expr></argument>, <argument><expr><name>errno</name></expr></argument>, <argument><expr><name>ap_server_conf</name></expr></argument>,
                         <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>02181</expr></argument>)</argument_list></call> "ufork: Possible mis-configuration "
                         "for user %s - Aborting."</expr></argument>, <argument><expr><name>user</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
        <break>break;</break>

      </case><default>default:
        <expr_stmt><expr><name>pid</name> = 0</expr>;</expr_stmt>
        <break>break;</break>
    </default>}</block></switch>

    <return>return <expr><name>pid</name></expr>;</return>
}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* _OSD_POSIX */</comment>

</unit>
