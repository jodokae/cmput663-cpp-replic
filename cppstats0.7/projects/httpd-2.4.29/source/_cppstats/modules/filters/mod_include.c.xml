<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C" filename="projects/httpd-2.4.29/_cppstats/modules/filters/mod_include.c"><cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"apr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"apr_strings.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"apr_thread_proc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"apr_hash.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"apr_user.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"apr_lib.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"apr_optional.h"</cpp:file></cpp:include>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>APR_WANT_STRFUNC</name></cpp:macro></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>APR_WANT_MEMFUNC</name></cpp:macro></cpp:define>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"apr_want.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ap_config.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"util_filter.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"httpd.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"http_config.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"http_core.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"http_request.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"http_core.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"http_protocol.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"http_log.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"http_main.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"util_script.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"http_core.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"mod_include.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ap_expr.h"</cpp:file></cpp:include>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>APR_CHARSET_EBCDIC</name></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"util_ebcdic.h"</cpp:file></cpp:include>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RAW_ASCII_CHAR</name><parameter_list>(<param><type><name>ch</name></type></param>)</parameter_list></cpp:macro> <cpp:value>apr_xlate_conv_byte(ap_hdrs_from_ascii, (unsigned char)ch)</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RAW_ASCII_CHAR</name><parameter_list>(<param><type><name>ch</name></type></param>)</parameter_list></cpp:macro> <cpp:value>(ch)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<typedef>typedef <type><struct>struct <name>result_item</name> <block>{
<decl_stmt><decl><type>struct <name>result_item</name> *</type><name>next</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>apr_size_t</name></type> <name>len</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>string</name></decl>;</decl_stmt>
}</block></struct></type> <name>result_item_t</name>;</typedef>
<typedef>typedef <type><enum>enum <block>{
<decl><name>TOKEN_STRING</name></decl>,
<decl><name>TOKEN_RE</name></decl>,
<decl><name>TOKEN_AND</name></decl>,
<decl><name>TOKEN_OR</name></decl>,
<decl><name>TOKEN_NOT</name></decl>,
<decl><name>TOKEN_EQ</name></decl>,
<decl><name>TOKEN_NE</name></decl>,
<decl><name>TOKEN_RBRACE</name></decl>,
<decl><name>TOKEN_LBRACE</name></decl>,
<decl><name>TOKEN_GROUP</name></decl>,
<decl><name>TOKEN_GE</name></decl>,
<decl><name>TOKEN_LE</name></decl>,
<decl><name>TOKEN_GT</name></decl>,
<decl><name>TOKEN_LT</name></decl>,
<decl><name>TOKEN_ACCESS</name></decl>
}</block></enum></type> <name>token_type_t</name>;</typedef>
<typedef>typedef <type><struct>struct <block>{
<decl_stmt><decl><type><name>token_type_t</name></type> <name>type</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>value</name></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>DEBUG_INCLUDE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>s</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></struct></type> <name>token_t</name>;</typedef>
<typedef>typedef <type><struct>struct <name>parse_node</name> <block>{
<decl_stmt><decl><type>struct <name>parse_node</name> *</type><name>parent</name></decl>;</decl_stmt>
<decl_stmt><decl><type>struct <name>parse_node</name> *</type><name>left</name></decl>;</decl_stmt>
<decl_stmt><decl><type>struct <name>parse_node</name> *</type><name>right</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>token_t</name></type> <name>token</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>value</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>done</name></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>DEBUG_INCLUDE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>int</name></type> <name>dump_done</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></struct></type> <name>parse_node_t</name>;</typedef>
<typedef>typedef <type><enum>enum <block>{
<decl><name>XBITHACK_OFF</name></decl>,
<decl><name>XBITHACK_ON</name></decl>,
<decl><name>XBITHACK_FULL</name></decl>,
<decl><name>XBITHACK_UNSET</name></decl>
}</block></enum></type> <name>xbithack_t</name>;</typedef>
<typedef>typedef <type><struct>struct <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>default_error_msg</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>default_time_fmt</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>undefined_echo</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>xbithack_t</name></type> <name>xbithack</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>signed</name> <name>char</name></type> <name>lastmodified</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>signed</name> <name>char</name></type> <name>etag</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>signed</name> <name>char</name></type> <name>legacy_expr</name></decl>;</decl_stmt>
}</block></struct></type> <name>include_dir_config</name>;</typedef>
<typedef>typedef <type><struct>struct <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>default_start_tag</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>default_end_tag</name></decl>;</decl_stmt>
}</block></struct></type> <name>include_server_config</name>;</typedef>
<typedef>typedef <type><enum>enum <block>{
<decl><name>PARSE_PRE_HEAD</name></decl>,
<decl><name>PARSE_HEAD</name></decl>,
<decl><name>PARSE_DIRECTIVE</name></decl>,
<decl><name>PARSE_DIRECTIVE_POSTNAME</name></decl>,
<decl><name>PARSE_DIRECTIVE_TAIL</name></decl>,
<decl><name>PARSE_DIRECTIVE_POSTTAIL</name></decl>,
<decl><name>PARSE_PRE_ARG</name></decl>,
<decl><name>PARSE_ARG</name></decl>,
<decl><name>PARSE_ARG_NAME</name></decl>,
<decl><name>PARSE_ARG_POSTNAME</name></decl>,
<decl><name>PARSE_ARG_EQ</name></decl>,
<decl><name>PARSE_ARG_PREVAL</name></decl>,
<decl><name>PARSE_ARG_VAL</name></decl>,
<decl><name>PARSE_ARG_VAL_ESC</name></decl>,
<decl><name>PARSE_ARG_POSTVAL</name></decl>,
<decl><name>PARSE_TAIL</name></decl>,
<decl><name>PARSE_TAIL_SEQ</name></decl>,
<decl><name>PARSE_EXECUTE</name></decl>
}</block></enum></type> <name>parse_state_t</name>;</typedef>
<typedef>typedef <type><struct>struct <name>arg_item</name> <block>{
<decl_stmt><decl><type>struct <name>arg_item</name> *</type><name>next</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>name</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>apr_size_t</name></type> <name>name_len</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>value</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>apr_size_t</name></type> <name>value_len</name></decl>;</decl_stmt>
}</block></struct></type> <name>arg_item_t</name>;</typedef>
<typedef>typedef <type><struct>struct <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>source</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>rexp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>apr_size_t</name></type> <name>nsub</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ap_regmatch_t</name></type> <name><name>match</name><index>[<expr><name>AP_MAX_REG_MATCH</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>have_match</name></decl>;</decl_stmt>
}</block></struct></type> <name>backref_t</name>;</typedef>
<typedef>typedef <type><struct>struct <block>{
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name><name>T</name><index>[<expr>256</expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>x</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>apr_size_t</name></type> <name>pattern_len</name></decl>;</decl_stmt>
}</block></struct></type> <name>bndm_t</name>;</typedef>
<struct>struct <name>ssi_internal_ctx</name> <block>{
<decl_stmt><decl><type><name>parse_state_t</name></type> <name>state</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>seen_eos</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>error</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name>quote</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>apr_size_t</name></type> <name>parse_pos</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>apr_size_t</name></type> <name>bytes_read</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>apr_bucket_brigade</name> *</type><name>tmp_bb</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>start_seq</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bndm_t</name> *</type><name>start_seq_pat</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>end_seq</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>apr_size_t</name></type> <name>end_seq_len</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>directive</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>apr_size_t</name></type> <name>directive_len</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>arg_item_t</name> *</type><name>current_arg</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>arg_item_t</name> *</type><name>argv</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>backref_t</name> *</type><name>re</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>undefined_echo</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>apr_size_t</name></type> <name>undefined_echo_len</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name>legacy_expr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ap_expr_eval_ctx_t</name> *</type><name>expr_eval_ctx</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>expr_vary_this</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>expr_err</name></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>DEBUG_INCLUDE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<struct>struct <block>{
<decl_stmt><decl><type><name>ap_filter_t</name> *</type><name>f</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>apr_bucket_brigade</name> *</type><name>bb</name></decl>;</decl_stmt>
}</block> <decl><name>debug</name></decl>;</struct>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block>;</struct>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>DEBUG_INCLUDE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TYPE_TOKEN</name><parameter_list>(<param><type><name>token</name></type></param>, <param><type><name>ttype</name></type></param>)</parameter_list></cpp:macro> <cpp:value>do { (token)-&gt;type = ttype; (token)-&gt;s = #ttype; } while(0)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CREATE_NODE</name><parameter_list>(<param><type><name>ctx</name></type></param>, <param><type><name>name</name></type></param>)</parameter_list></cpp:macro> <cpp:value>do { (name) = apr_palloc((ctx)-&gt;dpool, sizeof(*(name))); (name)-&gt;parent = (name)-&gt;left = (name)-&gt;right = NULL; (name)-&gt;done = 0; (name)-&gt;dump_done = 0; } while(0)</cpp:value></cpp:define>
<function><type><specifier>static</specifier> <name>void</name></type> <name>debug_printf</name><parameter_list>(<param><decl><type><name>include_ctx_t</name> *</type><name>ctx</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>fmt</name></decl></param>, <param><decl><type>...</type></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>va_list</name></type> <name>ap</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>debug__str</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>debug__str</name> = <call><name>apr_pvsprintf</name><argument_list>(<argument><expr><name><name>ctx</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>, <argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>APR_BRIGADE_INSERT_TAIL</name><argument_list>(<argument><expr><name><name>ctx</name>-&gt;<name>intern</name>-&gt;<name>debug</name>.<name>bb</name></name></expr></argument>, <argument><expr><call><name>apr_bucket_pool_create</name><argument_list>(
<argument><expr><name>debug__str</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>debug__str</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>ctx</name>-&gt;<name>pool</name></name></expr></argument>,
<argument><expr><name><name>ctx</name>-&gt;<name>intern</name>-&gt;<name>debug</name>.<name>f</name>-&gt;<name>c</name>-&gt;<name>bucket_alloc</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DUMP__CHILD</name><parameter_list>(<param><type><name>ctx</name></type></param>, <param><type><name>is</name></type></param>, <param><type><name>node</name></type></param>, <param><type><name>child</name></type></param>)</parameter_list></cpp:macro> <cpp:value>if (1) { parse_node_t *d__c = node-&gt;child; if (d__c) { if (!d__c-&gt;dump_done) { if (d__c-&gt;parent != node) { debug_printf(ctx, "!!! Parse tree is not consistent !!!\n"); if (!d__c-&gt;parent) { debug_printf(ctx, "Parent of " #child " child node is " "NULL.\n"); } else { debug_printf(ctx, "Parent of " #child " child node " "points to another node (of type %s)!\n", d__c-&gt;parent-&gt;token.s); } return; } node = d__c; continue; } } else { debug_printf(ctx, "%s(missing)\n", is); } }</cpp:value></cpp:define>
<function><type><specifier>static</specifier> <name>void</name></type> <name>debug_dump_tree</name><parameter_list>(<param><decl><type><name>include_ctx_t</name> *</type><name>ctx</name></decl></param>, <param><decl><type><name>parse_node_t</name> *</type><name>root</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>parse_node_t</name> *</type><name>current</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>is</name></decl>;</decl_stmt>
<if>if <condition>(<expr>!<name>root</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>debug_printf</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr>" -- Parse Tree empty --\n\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
}</block></then></if>
<expr_stmt><expr><call><name>debug_printf</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr>" ----- Parse Tree -----\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>current</name> = <name>root</name></expr>;</expr_stmt>
<expr_stmt><expr><name>is</name> = " "</expr>;</expr_stmt>
<while>while <condition>(<expr><name>current</name></expr>)</condition> <block>{
<switch>switch <condition>(<expr><name><name>current</name>-&gt;<name>token</name>.<name>type</name></name></expr>)</condition> <block>{
<case>case <expr><name>TOKEN_STRING</name></expr>:
</case><case>case <expr><name>TOKEN_RE</name></expr>:
<expr_stmt><expr><call><name>debug_printf</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr>"%s%s (%s)\n"</expr></argument>, <argument><expr><name>is</name></expr></argument>, <argument><expr><name><name>current</name>-&gt;<name>token</name>.<name>s</name></name></expr></argument>,
<argument><expr><name><name>current</name>-&gt;<name>token</name>.<name>value</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>current</name>-&gt;<name>dump_done</name></name> = 1</expr>;</expr_stmt>
<expr_stmt><expr><name>current</name> = <name><name>current</name>-&gt;<name>parent</name></name></expr>;</expr_stmt>
<continue>continue;</continue>
</case><case>case <expr><name>TOKEN_NOT</name></expr>:
</case><case>case <expr><name>TOKEN_GROUP</name></expr>:
</case><case>case <expr><name>TOKEN_RBRACE</name></expr>:
</case><case>case <expr><name>TOKEN_LBRACE</name></expr>:
<if>if <condition>(<expr>!<name><name>current</name>-&gt;<name>dump_done</name></name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>debug_printf</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr>"%s%s\n"</expr></argument>, <argument><expr><name>is</name></expr></argument>, <argument><expr><name><name>current</name>-&gt;<name>token</name>.<name>s</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>is</name> = <call><name>apr_pstrcat</name><argument_list>(<argument><expr><name><name>ctx</name>-&gt;<name>dpool</name></name></expr></argument>, <argument><expr><name>is</name></expr></argument>, <argument><expr>" "</expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>current</name>-&gt;<name>dump_done</name></name> = 1</expr>;</expr_stmt>
}</block></then></if>
<macro><name>DUMP__CHILD</name><argument_list>(<argument>ctx</argument>, <argument>is</argument>, <argument>current</argument>, <argument>right</argument>)</argument_list></macro>
<if>if <condition>(<expr>!<name><name>current</name>-&gt;<name>right</name></name> || <name><name>current</name>-&gt;<name>right</name>-&gt;<name>dump_done</name></name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>is</name> = <call><name>apr_pstrmemdup</name><argument_list>(<argument><expr><name><name>ctx</name>-&gt;<name>dpool</name></name></expr></argument>, <argument><expr><name>is</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>is</name></expr></argument>)</argument_list></call> - 4</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>current</name>-&gt;<name>right</name></name></expr>)</condition><then> <expr_stmt><expr><name><name>current</name>-&gt;<name>right</name>-&gt;<name>dump_done</name></name> = 0</expr>;</expr_stmt></then></if>
<expr_stmt><expr><name>current</name> = <name><name>current</name>-&gt;<name>parent</name></name></expr>;</expr_stmt>
}</block></then></if>
<continue>continue;</continue>
</case><default>default:
<if>if <condition>(<expr>!<name><name>current</name>-&gt;<name>dump_done</name></name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>debug_printf</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr>"%s%s\n"</expr></argument>, <argument><expr><name>is</name></expr></argument>, <argument><expr><name><name>current</name>-&gt;<name>token</name>.<name>s</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>is</name> = <call><name>apr_pstrcat</name><argument_list>(<argument><expr><name><name>ctx</name>-&gt;<name>dpool</name></name></expr></argument>, <argument><expr><name>is</name></expr></argument>, <argument><expr>" "</expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>current</name>-&gt;<name>dump_done</name></name> = 1</expr>;</expr_stmt>
}</block></then></if>
<macro><name>DUMP__CHILD</name><argument_list>(<argument>ctx</argument>, <argument>is</argument>, <argument>current</argument>, <argument>left</argument>)</argument_list></macro>
<macro><name>DUMP__CHILD</name><argument_list>(<argument>ctx</argument>, <argument>is</argument>, <argument>current</argument>, <argument>right</argument>)</argument_list></macro>
<if>if <condition>(<expr>(!<name><name>current</name>-&gt;<name>left</name></name> || <name><name>current</name>-&gt;<name>left</name>-&gt;<name>dump_done</name></name>) &amp;&amp;
(!<name><name>current</name>-&gt;<name>right</name></name> || <name><name>current</name>-&gt;<name>right</name>-&gt;<name>dump_done</name></name>)</expr>)</condition><then> <block>{
<expr_stmt><expr><name>is</name> = <call><name>apr_pstrmemdup</name><argument_list>(<argument><expr><name><name>ctx</name>-&gt;<name>dpool</name></name></expr></argument>, <argument><expr><name>is</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>is</name></expr></argument>)</argument_list></call> - 4</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>current</name>-&gt;<name>left</name></name></expr>)</condition><then> <expr_stmt><expr><name><name>current</name>-&gt;<name>left</name>-&gt;<name>dump_done</name></name> = 0</expr>;</expr_stmt></then></if>
<if>if <condition>(<expr><name><name>current</name>-&gt;<name>right</name></name></expr>)</condition><then> <expr_stmt><expr><name><name>current</name>-&gt;<name>right</name>-&gt;<name>dump_done</name></name> = 0</expr>;</expr_stmt></then></if>
<expr_stmt><expr><name>current</name> = <name><name>current</name>-&gt;<name>parent</name></name></expr>;</expr_stmt>
}</block></then></if>
<continue>continue;</continue>
</default>}</block></switch>
}</block></while>
<expr_stmt><expr><name><name>root</name>-&gt;<name>dump_done</name></name> = 0</expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>root</name>-&gt;<name>left</name></name></expr>)</condition><then> <expr_stmt><expr><name><name>root</name>-&gt;<name>left</name>-&gt;<name>dump_done</name></name> = 0</expr>;</expr_stmt></then></if>
<if>if <condition>(<expr><name><name>root</name>-&gt;<name>right</name></name></expr>)</condition><then> <expr_stmt><expr><name><name>root</name>-&gt;<name>right</name>-&gt;<name>dump_done</name></name> = 0</expr>;</expr_stmt></then></if>
<expr_stmt><expr><call><name>debug_printf</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr>" --- End Parse Tree ---\n\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DEBUG_INIT</name><parameter_list>(<param><type><name>ctx</name></type></param>, <param><type><name>filter</name></type></param>, <param><type><name>brigade</name></type></param>)</parameter_list></cpp:macro> <cpp:value>do { (ctx)-&gt;intern-&gt;debug.f = filter; (ctx)-&gt;intern-&gt;debug.bb = brigade; } while(0)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DEBUG_PRINTF</name><parameter_list>(<param><type><name>arg</name></type></param>)</parameter_list></cpp:macro> <cpp:value>debug_printf arg</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DEBUG_DUMP_TOKEN</name><parameter_list>(<param><type><name>ctx</name></type></param>, <param><type><name>token</name></type></param>)</parameter_list></cpp:macro> <cpp:value>do { token_t *d__t = (token); if (d__t-&gt;type == TOKEN_STRING || d__t-&gt;type == TOKEN_RE) { DEBUG_PRINTF(((ctx), " Found: %s (%s)\n", d__t-&gt;s, d__t-&gt;value)); } else { DEBUG_PRINTF((ctx, " Found: %s\n", d__t-&gt;s)); } } while(0)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DEBUG_DUMP_EVAL</name><parameter_list>(<param><type><name>ctx</name></type></param>, <param><type><name>node</name></type></param>)</parameter_list></cpp:macro> <cpp:value>do { char c = '"'; switch ((node)-&gt;token.type) { case TOKEN_STRING: debug_printf((ctx), " Evaluate: %s (%s) -&gt; %c\n", (node)-&gt;token.s,(node)-&gt;token.value, ((node)-&gt;value) ? '1':'0'); break; case TOKEN_AND: case TOKEN_OR: debug_printf((ctx), " Evaluate: %s (Left: %s; Right: %s) -&gt; %c\n",(node)-&gt;token.s, (((node)-&gt;left-&gt;done) ? ((node)-&gt;left-&gt;value ?"1":"0") : "short circuited"), (((node)-&gt;right-&gt;done) ? ((node)-&gt;right-&gt;value?"1":"0") : "short circuited"), (node)-&gt;value ? '1' : '0'); break; case TOKEN_EQ: case TOKEN_NE: case TOKEN_GT: case TOKEN_GE: case TOKEN_LT: case TOKEN_LE: if ((node)-&gt;right-&gt;token.type == TOKEN_RE) c = '/'; debug_printf((ctx), " Compare: %s (\"%s\" with %c%s%c) -&gt; %c\n", (node)-&gt;token.s, (node)-&gt;left-&gt;token.value, c, (node)-&gt;right-&gt;token.value, c, (node)-&gt;value ? '1' : '0'); break; default: debug_printf((ctx), " Evaluate: %s -&gt; %c\n", (node)-&gt;token.s, (node)-&gt;value ? '1' : '0'); break; } } while(0)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DEBUG_DUMP_UNMATCHED</name><parameter_list>(<param><type><name>ctx</name></type></param>, <param><type><name>unmatched</name></type></param>)</parameter_list></cpp:macro> <cpp:value>do { if (unmatched) { DEBUG_PRINTF(((ctx), " Unmatched %c\n", (char)(unmatched))); } } while(0)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DEBUG_DUMP_COND</name><parameter_list>(<param><type><name>ctx</name></type></param>, <param><type><name>text</name></type></param>)</parameter_list></cpp:macro> <cpp:value>DEBUG_PRINTF(((ctx), "**** %s cond status=\"%c\"\n", (text), ((ctx)-&gt;flags &amp; SSI_FLAG_COND_TRUE) ? '1' : '0'))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DEBUG_DUMP_TREE</name><parameter_list>(<param><type><name>ctx</name></type></param>, <param><type><name>root</name></type></param>)</parameter_list></cpp:macro> <cpp:value>debug_dump_tree(ctx, root)</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TYPE_TOKEN</name><parameter_list>(<param><type><name>token</name></type></param>, <param><type><name>ttype</name></type></param>)</parameter_list></cpp:macro> <cpp:value>(token)-&gt;type = ttype</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CREATE_NODE</name><parameter_list>(<param><type><name>ctx</name></type></param>, <param><type><name>name</name></type></param>)</parameter_list></cpp:macro> <cpp:value>do { (name) = apr_palloc((ctx)-&gt;dpool, sizeof(*(name))); (name)-&gt;parent = (name)-&gt;left = (name)-&gt;right = NULL; (name)-&gt;done = 0; } while(0)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DEBUG_INIT</name><parameter_list>(<param><type><name>ctx</name></type></param>, <param><type><name>f</name></type></param>, <param><type><name>bb</name></type></param>)</parameter_list></cpp:macro></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DEBUG_PRINTF</name><parameter_list>(<param><type><name>arg</name></type></param>)</parameter_list></cpp:macro></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DEBUG_DUMP_TOKEN</name><parameter_list>(<param><type><name>ctx</name></type></param>, <param><type><name>token</name></type></param>)</parameter_list></cpp:macro></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DEBUG_DUMP_EVAL</name><parameter_list>(<param><type><name>ctx</name></type></param>, <param><type><name>node</name></type></param>)</parameter_list></cpp:macro></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DEBUG_DUMP_UNMATCHED</name><parameter_list>(<param><type><name>ctx</name></type></param>, <param><type><name>unmatched</name></type></param>)</parameter_list></cpp:macro></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DEBUG_DUMP_COND</name><parameter_list>(<param><type><name>ctx</name></type></param>, <param><type><name>text</name></type></param>)</parameter_list></cpp:macro></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DEBUG_DUMP_TREE</name><parameter_list>(<param><type><name>ctx</name></type></param>, <param><type><name>root</name></type></param>)</parameter_list></cpp:macro></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<decl_stmt><decl><type><name>module</name> <name>AP_MODULE_DECLARE_DATA</name></type> <name>include_module</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>apr_hash_t</name> *</type><name>include_handlers</name></decl>;</decl_stmt>
<expr_stmt><expr>static <call><name>APR_OPTIONAL_FN_TYPE</name><argument_list>(<argument><expr><name>ap_register_include_handler</name></expr></argument>)</argument_list></call> *<name>ssi_pfn_register</name></expr>;</expr_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name></type> <name>lazy_eval_sentinel</name> <init>= <expr>'\0'</expr></init></decl>;</decl_stmt>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LAZY_VALUE</name></cpp:macro> <cpp:value>(&amp;lazy_eval_sentinel)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DEFAULT_START_SEQUENCE</name></cpp:macro> <cpp:value>"&lt;!--#"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DEFAULT_END_SEQUENCE</name></cpp:macro> <cpp:value>"--&gt;"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DEFAULT_ERROR_MSG</name></cpp:macro> <cpp:value>"[an error occurred while processing this directive]"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DEFAULT_TIME_FORMAT</name></cpp:macro> <cpp:value>"%A, %d-%b-%Y %H:%M:%S %Z"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DEFAULT_UNDEFINED_ECHO</name></cpp:macro> <cpp:value>"(none)"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>UNSET</name></cpp:macro> <cpp:value>-1</cpp:value></cpp:define>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>XBITHACK</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DEFAULT_XBITHACK</name></cpp:macro> <cpp:value>XBITHACK_FULL</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DEFAULT_XBITHACK</name></cpp:macro> <cpp:value>XBITHACK_OFF</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAXENTLEN</name></cpp:macro> <cpp:value>(6)</cpp:value></cpp:define>
<function><type><specifier>static</specifier> <name>void</name></type> <name>decodehtml</name><parameter_list>(<param><decl><type><name>char</name> *</type><name>s</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>val</name></decl>, <decl><type ref="prev"/><name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>p</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>ents</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> * <specifier>const</specifier></type> <name><name>entlist</name><index>[<expr><name>MAXENTLEN</name> + 1</expr>]</index></name> <init>= <expr><block>{
<expr><name>NULL</name></expr>,
<expr><name>NULL</name></expr>,
<expr>"lt\074gt\076"</expr>,
<expr>"amp\046ETH\320eth\360"</expr>,
<expr>"quot\042Auml\304Euml\313Iuml\317Ouml\326Uuml\334auml\344euml"
"\353iuml\357ouml\366uuml\374yuml\377"</expr>,
<expr>"Acirc\302Aring\305AElig\306Ecirc\312Icirc\316Ocirc\324Ucirc"
"\333THORN\336szlig\337acirc\342aring\345aelig\346ecirc\352"
"icirc\356ocirc\364ucirc\373thorn\376"</expr>,
<expr>"Agrave\300Aacute\301Atilde\303Ccedil\307Egrave\310Eacute\311"
"Igrave\314Iacute\315Ntilde\321Ograve\322Oacute\323Otilde"
"\325Oslash\330Ugrave\331Uacute\332Yacute\335agrave\340"
"aacute\341atilde\343ccedil\347egrave\350eacute\351igrave"
"\354iacute\355ntilde\361ograve\362oacute\363otilde\365"
"oslash\370ugrave\371uacute\372yacute\375"</expr>
}</block></expr></init></decl>;</decl_stmt>
<for>for (<init>;</init> <condition><expr>*<name>s</name> != '&amp;'</expr>;</condition> <incr><expr><name>s</name>++</expr></incr>) <block>{
<if>if <condition>(<expr>*<name>s</name> == '\0'</expr>)</condition><then> <block>{
<return>return;</return>
}</block></then></if>
}</block></for>
<for>for (<init><expr><name>p</name> = <name>s</name></expr>;</init> <condition><expr>*<name>s</name> != '\0'</expr>;</condition> <incr><expr><name>s</name>++</expr>, <expr><name>p</name>++</expr></incr>) <block>{
<if>if <condition>(<expr>*<name>s</name> != '&amp;'</expr>)</condition><then> <block>{
<expr_stmt><expr>*<name>p</name> = *<name>s</name></expr>;</expr_stmt>
<continue>continue;</continue>
}</block></then></if>
<for>for (<init><expr><name>i</name> = 1</expr>;</init> <condition><expr><name><name>s</name><index>[<expr><name>i</name></expr>]</index></name> != ';' &amp;&amp; <name><name>s</name><index>[<expr><name>i</name></expr>]</index></name> != '\0'</expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
<continue>continue;</continue>
}</block></for>
<if>if <condition>(<expr><name><name>s</name><index>[<expr><name>i</name></expr>]</index></name> == '\0'</expr>)</condition><then> <block>{
<expr_stmt><expr>*<name>p</name> = *<name>s</name></expr>;</expr_stmt>
<continue>continue;</continue>
}</block></then></if>
<if>if <condition>(<expr><name><name>s</name><index>[<expr>1</expr>]</index></name> == '#'</expr>)</condition><then> <block>{
<for>for (<init><expr><name>j</name> = 2</expr>, <expr><name>val</name> = 0</expr>;</init> <condition><expr><name>j</name> &lt; <name>i</name> &amp;&amp; <call><name>apr_isdigit</name><argument_list>(<argument><expr><name><name>s</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>j</name>++</expr></incr>) <block>{
<expr_stmt><expr><name>val</name> = <name>val</name> * 10 + <name><name>s</name><index>[<expr><name>j</name></expr>]</index></name> - '0'</expr>;</expr_stmt>
}</block></for>
<expr_stmt><expr><name>s</name> += <name>i</name></expr>;</expr_stmt>
<if>if <condition>(<expr><name>j</name> &lt; <name>i</name> || <name>val</name> &lt;= 8 || (<name>val</name> &gt;= 11 &amp;&amp; <name>val</name> &lt;= 31) ||
(<name>val</name> &gt;= 127 &amp;&amp; <name>val</name> &lt;= 160) || <name>val</name> &gt;= 256</expr>)</condition><then> <block>{
<expr_stmt><expr><name>p</name>--</expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr>*<name>p</name> = <call><name>RAW_ASCII_CHAR</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></else></if>
}</block></then> <else>else <block>{
<expr_stmt><expr><name>j</name> = <name>i</name> - 1</expr>;</expr_stmt>
<if>if <condition>(<expr><name>j</name> &gt; <name>MAXENTLEN</name> || <name><name>entlist</name><index>[<expr><name>j</name></expr>]</index></name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr>*<name>p</name> = '&amp;'</expr>;</expr_stmt>
<continue>continue;</continue>
}</block></then></if>
<for>for (<init><expr><name>ents</name> = <name><name>entlist</name><index>[<expr><name>j</name></expr>]</index></name></expr>;</init> <condition><expr>*<name>ents</name> != '\0'</expr>;</condition> <incr><expr><name>ents</name> += <name>i</name></expr></incr>) <block>{
<if>if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><name>s</name> + 1</expr></argument>, <argument><expr><name>ents</name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call> == 0</expr>)</condition><then> <block>{
<break>break;</break>
}</block></then></if>
}</block></for>
<if>if <condition>(<expr>*<name>ents</name> == '\0'</expr>)</condition><then> <block>{
<expr_stmt><expr>*<name>p</name> = '&amp;'</expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr>*<name>p</name> = <call><name>RAW_ASCII_CHAR</name><argument_list>(<argument><expr>((const <name>unsigned</name> <name>char</name> *) <name>ents</name>)<index>[<expr><name>j</name></expr>]</index></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>s</name> += <name>i</name></expr>;</expr_stmt>
}</block></else></if>
}</block></else></if>
}</block></for>
<expr_stmt><expr>*<name>p</name> = '\0'</expr>;</expr_stmt>
}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>add_include_vars</name><parameter_list>(<param><decl><type><name>request_rec</name> *</type><name>r</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>apr_table_t</name> *</type><name>e</name> <init>= <expr><name><name>r</name>-&gt;<name>subprocess_env</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>t</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>apr_table_setn</name><argument_list>(<argument><expr><name>e</name></expr></argument>, <argument><expr>"DATE_LOCAL"</expr></argument>, <argument><expr><name>LAZY_VALUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>apr_table_setn</name><argument_list>(<argument><expr><name>e</name></expr></argument>, <argument><expr>"DATE_GMT"</expr></argument>, <argument><expr><name>LAZY_VALUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>apr_table_setn</name><argument_list>(<argument><expr><name>e</name></expr></argument>, <argument><expr>"LAST_MODIFIED"</expr></argument>, <argument><expr><name>LAZY_VALUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>apr_table_setn</name><argument_list>(<argument><expr><name>e</name></expr></argument>, <argument><expr>"DOCUMENT_URI"</expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>uri</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>apr_table_setn</name><argument_list>(<argument><expr><name>e</name></expr></argument>, <argument><expr>"DOCUMENT_ARGS"</expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>args</name></name> ? <name><name>r</name>-&gt;<name>args</name></name> : ""</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>r</name>-&gt;<name>path_info</name></name> &amp;&amp; *<name><name>r</name>-&gt;<name>path_info</name></name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>apr_table_setn</name><argument_list>(<argument><expr><name>e</name></expr></argument>, <argument><expr>"DOCUMENT_PATH_INFO"</expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>path_info</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><call><name>apr_table_setn</name><argument_list>(<argument><expr><name>e</name></expr></argument>, <argument><expr>"USER_NAME"</expr></argument>, <argument><expr><name>LAZY_VALUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>r</name>-&gt;<name>filename</name></name> &amp;&amp; (<name>t</name> = <call><name>strrchr</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>filename</name></name></expr></argument>, <argument><expr>'/'</expr></argument>)</argument_list></call>)</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>apr_table_setn</name><argument_list>(<argument><expr><name>e</name></expr></argument>, <argument><expr>"DOCUMENT_NAME"</expr></argument>, <argument><expr>++<name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr><call><name>apr_table_setn</name><argument_list>(<argument><expr><name>e</name></expr></argument>, <argument><expr>"DOCUMENT_NAME"</expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>uri</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></else></if>
<if>if <condition>(<expr><name><name>r</name>-&gt;<name>args</name></name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>char</name> *</type><name>arg_copy</name> <init>= <expr><call><name>apr_pstrdup</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>args</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>ap_unescape_url</name><argument_list>(<argument><expr><name>arg_copy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>apr_table_setn</name><argument_list>(<argument><expr><name>e</name></expr></argument>, <argument><expr>"QUERY_STRING_UNESCAPED"</expr></argument>,
<argument><expr><call><name>ap_escape_shell_cmd</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>arg_copy</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
}</block></function>
<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> *</type><name>add_include_vars_lazy</name><parameter_list>(<param><decl><type><name>request_rec</name> *</type><name>r</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>var</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>timefmt</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>char</name> *</type><name>val</name></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>strcasecmp</name><argument_list>(<argument><expr><name>var</name></expr></argument>, <argument><expr>"DATE_LOCAL"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><name>val</name> = <call><name>ap_ht_time</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>request_time</name></name></expr></argument>, <argument><expr><name>timefmt</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else <if>if <condition>(<expr>!<call><name>strcasecmp</name><argument_list>(<argument><expr><name>var</name></expr></argument>, <argument><expr>"DATE_GMT"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><name>val</name> = <call><name>ap_ht_time</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>request_time</name></name></expr></argument>, <argument><expr><name>timefmt</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else <if>if <condition>(<expr>!<call><name>strcasecmp</name><argument_list>(<argument><expr><name>var</name></expr></argument>, <argument><expr>"LAST_MODIFIED"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><name>val</name> = <call><name>ap_ht_time</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>finfo</name>.<name>mtime</name></name></expr></argument>, <argument><expr><name>timefmt</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else <if>if <condition>(<expr>!<call><name>strcasecmp</name><argument_list>(<argument><expr><name>var</name></expr></argument>, <argument><expr>"USER_NAME"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<if>if <condition>(<expr><call><name>apr_uid_name_get</name><argument_list>(<argument><expr>&amp;<name>val</name></expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>finfo</name>.<name>user</name></name></expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call> != <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>val</name> = "&lt;unknown&gt;"</expr>;</expr_stmt>
}</block></then></if>
}</block></then> <else>else <block>{
<expr_stmt><expr><name>val</name> = <name>NULL</name></expr>;</expr_stmt>
}</block></else></if></else></if></else></if></else></if>
<if>if <condition>(<expr><name>val</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>apr_table_setn</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>subprocess_env</name></name></expr></argument>, <argument><expr><name>var</name></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<return>return <expr><name>val</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> *</type><name>get_include_var</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>var</name></decl></param>, <param><decl><type><name>include_ctx_t</name> *</type><name>ctx</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>val</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>request_rec</name> *</type><name>r</name> <init>= <expr><name><name>ctx</name>-&gt;<name>r</name></name></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><call><name>apr_isdigit</name><argument_list>(<argument><expr>*<name>var</name></expr></argument>)</argument_list></call> &amp;&amp; !<name><name>var</name><index>[<expr>1</expr>]</index></name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>apr_size_t</name></type> <name>idx</name> <init>= <expr>*<name>var</name> - '0'</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>backref_t</name> *</type><name>re</name> <init>= <expr><name><name>ctx</name>-&gt;<name>intern</name>-&gt;<name>re</name></name></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr>!<name>re</name> || !<name><name>re</name>-&gt;<name>have_match</name></name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>ap_log_rerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_WARNING</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>01329</expr></argument>)</argument_list></call>
"regex capture $%" <name>APR_SIZE_T_FMT</name> " refers to no regex in %s"</expr></argument>,
<argument><expr><name>idx</name></expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>filename</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then> <else>else <if>if <condition>(<expr><name><name>re</name>-&gt;<name>nsub</name></name> &lt; <name>idx</name> || <name>idx</name> &gt;= <name>AP_MAX_REG_MATCH</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>ap_log_rerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_WARNING</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>01330</expr></argument>)</argument_list></call>
"regex capture $%" <name>APR_SIZE_T_FMT</name>
" is out of range (last regex was: '%s') in %s"</expr></argument>,
<argument><expr><name>idx</name></expr></argument>, <argument><expr><name><name>re</name>-&gt;<name>rexp</name></name></expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>filename</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then> <else>else <if>if <condition>(<expr><name><name>re</name>-&gt;<name>match</name><index>[<expr><name>idx</name></expr>]</index></name>.<name>rm_so</name> &lt; 0 || <name><name>re</name>-&gt;<name>match</name><index>[<expr><name>idx</name></expr>]</index></name>.<name>rm_eo</name> &lt; 0</expr>)</condition><then> <block>{
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then> <else>else <block>{
<expr_stmt><expr><name>val</name> = <call><name>apr_pstrmemdup</name><argument_list>(<argument><expr><name><name>ctx</name>-&gt;<name>dpool</name></name></expr></argument>, <argument><expr><name><name>re</name>-&gt;<name>source</name></name> + <name><name>re</name>-&gt;<name>match</name><index>[<expr><name>idx</name></expr>]</index></name>.<name>rm_so</name></expr></argument>,
<argument><expr><name><name>re</name>-&gt;<name>match</name><index>[<expr><name>idx</name></expr>]</index></name>.<name>rm_eo</name> - <name><name>re</name>-&gt;<name>match</name><index>[<expr><name>idx</name></expr>]</index></name>.<name>rm_so</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></else></if></else></if></else></if>
}</block></then> <else>else <block>{
<expr_stmt><expr><name>val</name> = <call><name>apr_table_get</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>subprocess_env</name></name></expr></argument>, <argument><expr><name>var</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>val</name> == <name>LAZY_VALUE</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>val</name> = <call><name>add_include_vars_lazy</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>var</name></expr></argument>, <argument><expr><name><name>ctx</name>-&gt;<name>time_str</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
}</block></else></if>
<return>return <expr><name>val</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> *</type><name>include_expr_var_fn</name><parameter_list>(<param><decl><type><name>ap_expr_eval_ctx_t</name> *</type><name>eval_ctx</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>void</name> *</type><name>data</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>arg</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>res</name></decl>, *<decl><type ref="prev"/><name>name</name> <init>= <expr><name>data</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>include_ctx_t</name> *</type><name>ctx</name> <init>= <expr><name><name>eval_ctx</name>-&gt;<name>data</name></name></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr>(<name><name>name</name><index>[<expr>0</expr>]</index></name> == 'e') || (<name><name>name</name><index>[<expr>0</expr>]</index></name> == 'E')</expr>)</condition><then> <block>{
<if>if <condition>(<expr>(<name>res</name> = <call><name>apr_table_get</name><argument_list>(<argument><expr><name><name>ctx</name>-&gt;<name>r</name>-&gt;<name>notes</name></name></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call>) != <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>res</name></expr>;</return></then>
<else>else <if>if <condition>(<expr>(<name>res</name> = <call><name>get_include_var</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><name>ctx</name></expr></argument>)</argument_list></call>) != <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>res</name></expr>;</return></then>
<else>else
<return>return <expr><call><name>getenv</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</return></else></if></else></if>
}</block></then> <else>else <block>{
<return>return <expr><call><name>get_include_var</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></else></if>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>include_expr_lookup</name><parameter_list>(<param><decl><type><name>ap_expr_lookup_parms</name> *</type><name>parms</name></decl></param>)</parameter_list> <block>{
<switch>switch <condition>(<expr><name><name>parms</name>-&gt;<name>type</name></name></expr>)</condition> <block>{
<case>case <expr><name>AP_EXPR_FUNC_STRING</name></expr>:
<if>if <condition>(<expr><call><name>strcasecmp</name><argument_list>(<argument><expr><name><name>parms</name>-&gt;<name>name</name></name></expr></argument>, <argument><expr>"v"</expr></argument>)</argument_list></call> == 0 ||
<call><name>strcasecmp</name><argument_list>(<argument><expr><name><name>parms</name>-&gt;<name>name</name></name></expr></argument>, <argument><expr>"reqenv"</expr></argument>)</argument_list></call> == 0 ||
<call><name>strcasecmp</name><argument_list>(<argument><expr><name><name>parms</name>-&gt;<name>name</name></name></expr></argument>, <argument><expr>"env"</expr></argument>)</argument_list></call> == 0</expr>)</condition><then> <block>{
<expr_stmt><expr>*<name><name>parms</name>-&gt;<name>func</name></name> = <name>include_expr_var_fn</name></expr>;</expr_stmt>
<expr_stmt><expr>*<name><name>parms</name>-&gt;<name>data</name></name> = <name><name>parms</name>-&gt;<name>name</name></name></expr>;</expr_stmt>
<return>return <expr><name>OK</name></expr>;</return>
}</block></then></if>
<break>break;</break>
</case>}</block></switch>
<return>return <expr><call><name>ap_run_expr_lookup</name><argument_list>(<argument><expr><name>parms</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>char</name> *</type><name>ap_ssi_parse_string</name><parameter_list>(<param><decl><type><name>include_ctx_t</name> *</type><name>ctx</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>in</name></decl></param>, <param><decl><type><name>char</name> *</type><name>out</name></decl></param>,
<param><decl><type><name>apr_size_t</name></type> <name>length</name></decl></param>, <param><decl><type><name>int</name></type> <name>leave_name</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>request_rec</name> *</type><name>r</name> <init>= <expr><name><name>ctx</name>-&gt;<name>r</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>result_item_t</name> *</type><name>result</name> <init>= <expr><name>NULL</name></expr></init>, *<name>current</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>apr_size_t</name></type> <name>outlen</name> <init>= <expr>0</expr></init>, <name>inlen</name></decl>, <decl><type ref="prev"/><name>span</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>ret</name> <init>= <expr><name>NULL</name></expr></init>, *<name>eout</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>p</name></decl>;</decl_stmt>
<if>if <condition>(<expr><name>out</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>ap_assert</name><argument_list>(<argument><expr><name>out</name> &amp;&amp; <name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ret</name> = <name>out</name></expr>;</expr_stmt>
<expr_stmt><expr><name>eout</name> = <name>out</name> + <name>length</name> - 1</expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><name>span</name> = <call><name>strcspn</name><argument_list>(<argument><expr><name>in</name></expr></argument>, <argument><expr>"\\$"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>inlen</name> = <call><name>strlen</name><argument_list>(<argument><expr><name>in</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>inlen</name> == <name>span</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr><name>out</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>apr_cpystrn</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><name>in</name></expr></argument>, <argument><expr><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr><name>ret</name> = <call><name>apr_pstrmemdup</name><argument_list>(<argument><expr><name><name>ctx</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>in</name></expr></argument>, <argument><expr>(<name>length</name> &amp;&amp; <name>length</name> &lt;= <name>inlen</name>)
? <name>length</name> - 1 : <name>inlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></else></if>
<return>return <expr><name>ret</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>p</name> = <name>in</name> + <name>span</name></expr>;</expr_stmt>
<if>if <condition>(<expr><name>out</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr><name>span</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><name>in</name></expr></argument>, <argument><expr>(<name>out</name>+<name>span</name> &lt;= <name>eout</name>) ? <name>span</name> : (<name>eout</name>-<name>out</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>out</name> += <name>span</name></expr>;</expr_stmt>
}</block></then></if>
}</block></then> <else>else <block>{
<expr_stmt><expr><name>current</name> = <name>result</name> = <call><name>apr_palloc</name><argument_list>(<argument><expr><name><name>ctx</name>-&gt;<name>dpool</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>*<name>result</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>current</name>-&gt;<name>next</name></name> = <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>current</name>-&gt;<name>string</name></name> = <name>in</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>current</name>-&gt;<name>len</name></name> = <name>span</name></expr>;</expr_stmt>
<expr_stmt><expr><name>outlen</name> = <name>span</name></expr>;</expr_stmt>
}</block></else></if>
<do>do <block>{
<if>if <condition>(<expr>(<name>out</name> &amp;&amp; <name>out</name> &gt;= <name>eout</name>) || (<name>length</name> &amp;&amp; <name>outlen</name> &gt;= <name>length</name>)</expr>)</condition><then> <block>{
<break>break;</break>
}</block></then></if>
<if>if <condition>(<expr>!<name>out</name> &amp;&amp; <name><name>current</name>-&gt;<name>len</name></name></expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>current</name>-&gt;<name>next</name></name> = <call><name>apr_palloc</name><argument_list>(<argument><expr><name><name>ctx</name>-&gt;<name>dpool</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>*<name><name>current</name>-&gt;<name>next</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>current</name> = <name><name>current</name>-&gt;<name>next</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>current</name>-&gt;<name>next</name></name> = <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>current</name>-&gt;<name>len</name></name> = 0</expr>;</expr_stmt>
}</block></then></if>
<if>if <condition>(<expr>*<name>p</name> == '\\'</expr>)</condition><then> <block>{
<if>if <condition>(<expr><name>out</name></expr>)</condition><then> <block>{
<expr_stmt><expr>*<name>out</name>++ = (<name><name>p</name><index>[<expr>1</expr>]</index></name> == '$') ? *++<name>p</name> : *<name>p</name></expr>;</expr_stmt>
<expr_stmt><expr>++<name>p</name></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr><name><name>current</name>-&gt;<name>len</name></name> = 1</expr>;</expr_stmt>
<expr_stmt><expr><name><name>current</name>-&gt;<name>string</name></name> = (<name><name>p</name><index>[<expr>1</expr>]</index></name> == '$') ? ++<name>p</name> : <name>p</name></expr>;</expr_stmt>
<expr_stmt><expr>++<name>p</name></expr>;</expr_stmt>
<expr_stmt><expr>++<name>outlen</name></expr>;</expr_stmt>
}</block></else></if>
}</block></then>
<else>else <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>newp</name> <init>= <expr><name>NULL</name></expr></init>, *<name>ep</name></decl>, *<decl><type ref="prev"/><name>key</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr>*++<name>p</name> == '{'</expr>)</condition><then> <block>{
<expr_stmt><expr><name>ep</name> = <call><name>ap_strchr_c</name><argument_list>(<argument><expr>++<name>p</name></expr></argument>, <argument><expr>'}'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>ep</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>ap_log_rerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_ERR</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>01331</expr></argument>)</argument_list></call> "Missing '}' on "
"variable \"%s\" in %s"</expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>filename</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
}</block></then></if>
<if>if <condition>(<expr><name>p</name> &lt; <name>ep</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>key</name> = <call><name>apr_pstrmemdup</name><argument_list>(<argument><expr><name><name>ctx</name>-&gt;<name>dpool</name></name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>ep</name> - <name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>newp</name> = <name>ep</name> + 1</expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><name>p</name> -= 2</expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr><name>ep</name> = <name>p</name></expr>;</expr_stmt>
<while>while <condition>(<expr>*<name>ep</name> == '_' || <call><name>apr_isalnum</name><argument_list>(<argument><expr>*<name>ep</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{
<expr_stmt><expr>++<name>ep</name></expr>;</expr_stmt>
}</block></while>
<if>if <condition>(<expr><name>p</name> &lt; <name>ep</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>key</name> = <call><name>apr_pstrmemdup</name><argument_list>(<argument><expr><name><name>ctx</name>-&gt;<name>dpool</name></name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>ep</name> - <name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>newp</name> = <name>ep</name></expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr>--<name>p</name></expr>;</expr_stmt>
}</block></else></if>
<if>if <condition>(<expr>!<name>key</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr><name>out</name></expr>)</condition><then> <block>{
<expr_stmt><expr>*<name>out</name>++ = *<name>p</name>++</expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr><name><name>current</name>-&gt;<name>len</name></name> = 1</expr>;</expr_stmt>
<expr_stmt><expr><name><name>current</name>-&gt;<name>string</name></name> = <name>p</name>++</expr>;</expr_stmt>
<expr_stmt><expr>++<name>outlen</name></expr>;</expr_stmt>
}</block></else></if>
}</block></then> <else>else <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>val</name> <init>= <expr><call><name>get_include_var</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>apr_size_t</name></type> <name>len</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>val</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>len</name> = <call><name>strlen</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else <if>if <condition>(<expr><name>leave_name</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>val</name> = <name>p</name></expr>;</expr_stmt>
<expr_stmt><expr><name>len</name> = <name>ep</name> - <name>p</name></expr>;</expr_stmt>
}</block></then></if></else></if>
<if>if <condition>(<expr><name>val</name> &amp;&amp; <name>len</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr><name>out</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><name>val</name></expr></argument>, <argument><expr>(<name>out</name>+<name>len</name> &lt;= <name>eout</name>) ? <name>len</name> : (<name>eout</name>-<name>out</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>out</name> += <name>len</name></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr><name><name>current</name>-&gt;<name>len</name></name> = <name>len</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>current</name>-&gt;<name>string</name></name> = <name>val</name></expr>;</expr_stmt>
<expr_stmt><expr><name>outlen</name> += <name>len</name></expr>;</expr_stmt>
}</block></else></if>
}</block></then></if>
<expr_stmt><expr><name>p</name> = <name>newp</name></expr>;</expr_stmt>
}</block></else></if>
}</block></else></if>
<if>if <condition>(<expr>(<name>out</name> &amp;&amp; <name>out</name> &gt;= <name>eout</name>) || (<name>length</name> &amp;&amp; <name>outlen</name> &gt;= <name>length</name>)</expr>)</condition><then> <block>{
<break>break;</break>
}</block></then></if>
<if>if <condition>(<expr>*<name>p</name> &amp;&amp; (<name>span</name> = <call><name>strcspn</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr>"\\$"</expr></argument>)</argument_list></call>) &gt; 0</expr>)</condition><then> <block>{
<if>if <condition>(<expr>!<name>out</name> &amp;&amp; <name><name>current</name>-&gt;<name>len</name></name></expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>current</name>-&gt;<name>next</name></name> = <call><name>apr_palloc</name><argument_list>(<argument><expr><name><name>ctx</name>-&gt;<name>dpool</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>*<name><name>current</name>-&gt;<name>next</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>current</name> = <name><name>current</name>-&gt;<name>next</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>current</name>-&gt;<name>next</name></name> = <name>NULL</name></expr>;</expr_stmt>
}</block></then></if>
<if>if <condition>(<expr><name>out</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr>(<name>out</name>+<name>span</name> &lt;= <name>eout</name>) ? <name>span</name> : (<name>eout</name>-<name>out</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>out</name> += <name>span</name></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr><name><name>current</name>-&gt;<name>len</name></name> = <name>span</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>current</name>-&gt;<name>string</name></name> = <name>p</name></expr>;</expr_stmt>
<expr_stmt><expr><name>outlen</name> += <name>span</name></expr>;</expr_stmt>
}</block></else></if>
<expr_stmt><expr><name>p</name> += <name>span</name></expr>;</expr_stmt>
}</block></then></if>
}</block> while <condition>(<expr><name>p</name> &lt; <name>in</name>+<name>inlen</name></expr>)</condition>;</do>
<if>if <condition>(<expr><name>out</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr><name>out</name> &gt; <name>eout</name></expr>)</condition><then> <block>{
<expr_stmt><expr>*<name>eout</name> = '\0'</expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr>*<name>out</name> = '\0'</expr>;</expr_stmt>
}</block></else></if>
}</block></then> <else>else <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>ep</name></decl>;</decl_stmt>
<if>if <condition>(<expr><name>length</name> &amp;&amp; <name>outlen</name> &gt; <name>length</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>outlen</name> = <name>length</name> - 1</expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><name>ret</name> = <name>out</name> = <call><name>apr_palloc</name><argument_list>(<argument><expr><name><name>ctx</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>outlen</name> + 1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ep</name> = <name>ret</name> + <name>outlen</name></expr>;</expr_stmt>
<do>do <block>{
<if>if <condition>(<expr><name><name>result</name>-&gt;<name>len</name></name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><name><name>result</name>-&gt;<name>string</name></name></expr></argument>, <argument><expr>(<name>out</name>+<name><name>result</name>-&gt;<name>len</name></name> &lt;= <name>ep</name>)
? <name><name>result</name>-&gt;<name>len</name></name> : (<name>ep</name>-<name>out</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>out</name> += <name><name>result</name>-&gt;<name>len</name></name></expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><name>result</name> = <name><name>result</name>-&gt;<name>next</name></name></expr>;</expr_stmt>
}</block> while <condition>(<expr><name>result</name> &amp;&amp; <name>out</name> &lt; <name>ep</name></expr>)</condition>;</do>
<expr_stmt><expr><name><name>ret</name><index>[<expr><name>outlen</name></expr>]</index></name> = '\0'</expr>;</expr_stmt>
}</block></else></if>
<return>return <expr><name>ret</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>APR_INLINE</name> <name>int</name></type> <name>re_check</name><parameter_list>(<param><decl><type><name>include_ctx_t</name> *</type><name>ctx</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>string</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>rexp</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>ap_regex_t</name> *</type><name>compiled</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>backref_t</name> *</type><name>re</name> <init>= <expr><name><name>ctx</name>-&gt;<name>intern</name>-&gt;<name>re</name></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>compiled</name> = <call><name>ap_pregcomp</name><argument_list>(<argument><expr><name><name>ctx</name>-&gt;<name>dpool</name></name></expr></argument>, <argument><expr><name>rexp</name></expr></argument>, <argument><expr><name>AP_REG_EXTENDED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>compiled</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>ap_log_rerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_ERR</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name><name>ctx</name>-&gt;<name>r</name></name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>02667</expr></argument>)</argument_list></call>
"unable to compile pattern \"%s\""</expr></argument>, <argument><expr><name>rexp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>-1</expr>;</return>
}</block></then></if>
<if>if <condition>(<expr>!<name>re</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>re</name> = <name><name>ctx</name>-&gt;<name>intern</name>-&gt;<name>re</name></name> = <call><name>apr_palloc</name><argument_list>(<argument><expr><name><name>ctx</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>*<name>re</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><name><name>re</name>-&gt;<name>source</name></name> = <call><name>apr_pstrdup</name><argument_list>(<argument><expr><name><name>ctx</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>string</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>re</name>-&gt;<name>rexp</name></name> = <call><name>apr_pstrdup</name><argument_list>(<argument><expr><name><name>ctx</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>rexp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>re</name>-&gt;<name>nsub</name></name> = <name><name>compiled</name>-&gt;<name>re_nsub</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>re</name>-&gt;<name>have_match</name></name> = !<call><name>ap_regexec</name><argument_list>(<argument><expr><name>compiled</name></expr></argument>, <argument><expr><name>string</name></expr></argument>, <argument><expr><name>AP_MAX_REG_MATCH</name></expr></argument>,
<argument><expr><name><name>re</name>-&gt;<name>match</name></name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ap_pregfree</name><argument_list>(<argument><expr><name><name>ctx</name>-&gt;<name>dpool</name></name></expr></argument>, <argument><expr><name>compiled</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name><name>re</name>-&gt;<name>have_match</name></name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>get_ptoken</name><parameter_list>(<param><decl><type><name>include_ctx_t</name> *</type><name>ctx</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> **</type><name>parse</name></decl></param>, <param><decl><type><name>token_t</name> *</type><name>token</name></decl></param>, <param><decl><type><name>token_t</name> *</type><name>previous</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>p</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>apr_size_t</name></type> <name>shift</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>unmatched</name></decl>;</decl_stmt>
<expr_stmt><expr><name><name>token</name>-&gt;<name>value</name></name> = <name>NULL</name></expr>;</expr_stmt>
<if>if <condition>(<expr>!*<name>parse</name></expr>)</condition><then> <block>{
<return>return <expr>0</expr>;</return>
}</block></then></if>
<while>while <condition>(<expr><call><name>apr_isspace</name><argument_list>(<argument><expr>**<name>parse</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{
<expr_stmt><expr>++*<name>parse</name></expr>;</expr_stmt>
}</block></while>
<if>if <condition>(<expr>!**<name>parse</name></expr>)</condition><then> <block>{
<expr_stmt><expr>*<name>parse</name> = <name>NULL</name></expr>;</expr_stmt>
<return>return <expr>0</expr>;</return>
}</block></then></if>
<expr_stmt><expr><call><name>TYPE_TOKEN</name><argument_list>(<argument><expr><name>token</name></expr></argument>, <argument><expr><name>TOKEN_STRING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>p</name> = *<name>parse</name></expr>;</expr_stmt>
<expr_stmt><expr><name>unmatched</name> = 0</expr>;</expr_stmt>
<switch>switch <condition>(<expr>*(*<name>parse</name>)++</expr>)</condition> <block>{
<case>case <expr>'('</expr>:
<expr_stmt><expr><call><name>TYPE_TOKEN</name><argument_list>(<argument><expr><name>token</name></expr></argument>, <argument><expr><name>TOKEN_LBRACE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>0</expr>;</return>
</case><case>case <expr>')'</expr>:
<expr_stmt><expr><call><name>TYPE_TOKEN</name><argument_list>(<argument><expr><name>token</name></expr></argument>, <argument><expr><name>TOKEN_RBRACE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>0</expr>;</return>
</case><case>case <expr>'='</expr>:
<if>if <condition>(<expr>**<name>parse</name> == '='</expr>)</condition><then> <expr_stmt><expr>++*<name>parse</name></expr>;</expr_stmt></then></if>
<expr_stmt><expr><call><name>TYPE_TOKEN</name><argument_list>(<argument><expr><name>token</name></expr></argument>, <argument><expr><name>TOKEN_EQ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>0</expr>;</return>
</case><case>case <expr>'!'</expr>:
<if>if <condition>(<expr>**<name>parse</name> == '='</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>TYPE_TOKEN</name><argument_list>(<argument><expr><name>token</name></expr></argument>, <argument><expr><name>TOKEN_NE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr>++*<name>parse</name></expr>;</expr_stmt>
<return>return <expr>0</expr>;</return>
}</block></then></if>
<expr_stmt><expr><call><name>TYPE_TOKEN</name><argument_list>(<argument><expr><name>token</name></expr></argument>, <argument><expr><name>TOKEN_NOT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>0</expr>;</return>
</case><case>case <expr>'\''</expr>:
<expr_stmt><expr><name>unmatched</name> = '\''</expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr>'/'</expr>:
<if>if <condition>(<expr><name>previous</name> != <name>NULL</name> &amp;&amp; <name>TOKEN_ACCESS</name> == <name><name>previous</name>-&gt;<name>type</name></name></expr>)</condition><then> <block>{
<break>break;</break>
}</block></then></if>
<expr_stmt><expr><call><name>TYPE_TOKEN</name><argument_list>(<argument><expr><name>token</name></expr></argument>, <argument><expr><name>TOKEN_RE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>unmatched</name> = '/'</expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr>'|'</expr>:
<if>if <condition>(<expr>**<name>parse</name> == '|'</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>TYPE_TOKEN</name><argument_list>(<argument><expr><name>token</name></expr></argument>, <argument><expr><name>TOKEN_OR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr>++*<name>parse</name></expr>;</expr_stmt>
<return>return <expr>0</expr>;</return>
}</block></then></if>
<break>break;</break>
</case><case>case <expr>'&amp;'</expr>:
<if>if <condition>(<expr>**<name>parse</name> == '&amp;'</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>TYPE_TOKEN</name><argument_list>(<argument><expr><name>token</name></expr></argument>, <argument><expr><name>TOKEN_AND</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr>++*<name>parse</name></expr>;</expr_stmt>
<return>return <expr>0</expr>;</return>
}</block></then></if>
<break>break;</break>
</case><case>case <expr>'&gt;'</expr>:
<if>if <condition>(<expr>**<name>parse</name> == '='</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>TYPE_TOKEN</name><argument_list>(<argument><expr><name>token</name></expr></argument>, <argument><expr><name>TOKEN_GE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr>++*<name>parse</name></expr>;</expr_stmt>
<return>return <expr>0</expr>;</return>
}</block></then></if>
<expr_stmt><expr><call><name>TYPE_TOKEN</name><argument_list>(<argument><expr><name>token</name></expr></argument>, <argument><expr><name>TOKEN_GT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>0</expr>;</return>
</case><case>case <expr>'&lt;'</expr>:
<if>if <condition>(<expr>**<name>parse</name> == '='</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>TYPE_TOKEN</name><argument_list>(<argument><expr><name>token</name></expr></argument>, <argument><expr><name>TOKEN_LE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr>++*<name>parse</name></expr>;</expr_stmt>
<return>return <expr>0</expr>;</return>
}</block></then></if>
<expr_stmt><expr><call><name>TYPE_TOKEN</name><argument_list>(<argument><expr><name>token</name></expr></argument>, <argument><expr><name>TOKEN_LT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>0</expr>;</return>
</case><case>case <expr>'-'</expr>:
<if>if <condition>(<expr>**<name>parse</name> == 'A'</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>TYPE_TOKEN</name><argument_list>(<argument><expr><name>token</name></expr></argument>, <argument><expr><name>TOKEN_ACCESS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr>++*<name>parse</name></expr>;</expr_stmt>
<return>return <expr>0</expr>;</return>
}</block></then></if>
<break>break;</break>
</case>}</block></switch>
<expr_stmt><expr><name>shift</name> = 0</expr>;</expr_stmt>
<expr_stmt><expr><name>p</name> = *<name>parse</name> = <name><name>token</name>-&gt;<name>value</name></name> = <name>unmatched</name> ? *<name>parse</name> : <name>p</name></expr>;</expr_stmt>
<for>for (<init>;</init> <condition><expr>**<name>parse</name></expr>;</condition> <incr><expr><name>p</name> = ++*<name>parse</name></expr></incr>) <block>{
<if>if <condition>(<expr>**<name>parse</name> == '\\'</expr>)</condition><then> <block>{
<if>if <condition>(<expr>!*(++*<name>parse</name>)</expr>)</condition><then> <block>{
<expr_stmt><expr><name>p</name> = *<name>parse</name></expr>;</expr_stmt>
<break>break;</break>
}</block></then></if>
<expr_stmt><expr>++<name>shift</name></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<if>if <condition>(<expr><name>unmatched</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr>**<name>parse</name> == <name>unmatched</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>unmatched</name> = 0</expr>;</expr_stmt>
<expr_stmt><expr>++*<name>parse</name></expr>;</expr_stmt>
<break>break;</break>
}</block></then></if>
}</block></then> <else>else <if>if <condition>(<expr><call><name>apr_isspace</name><argument_list>(<argument><expr>**<name>parse</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<break>break;</break>
}</block></then> <else>else <block>{
<decl_stmt><decl><type><name>int</name></type> <name>found</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<switch>switch <condition>(<expr>**<name>parse</name></expr>)</condition> <block>{
<case>case <expr>'('</expr>:
</case><case>case <expr>')'</expr>:
</case><case>case <expr>'='</expr>:
</case><case>case <expr>'!'</expr>:
</case><case>case <expr>'&lt;'</expr>:
</case><case>case <expr>'&gt;'</expr>:
<expr_stmt><expr>++<name>found</name></expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr>'|'</expr>:
</case><case>case <expr>'&amp;'</expr>:
<if>if <condition>(<expr>(*<name>parse</name>)<index>[<expr>1</expr>]</index> == **<name>parse</name></expr>)</condition><then> <block>{
<expr_stmt><expr>++<name>found</name></expr>;</expr_stmt>
}</block></then></if>
<break>break;</break>
</case>}</block></switch>
<if>if <condition>(<expr><name>found</name></expr>)</condition><then> <block>{
<break>break;</break>
}</block></then></if>
}</block></else></if></else></if>
}</block></else></if>
}</block></for>
<if>if <condition>(<expr><name>unmatched</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>token</name>-&gt;<name>value</name></name> = <call><name>apr_pstrdup</name><argument_list>(<argument><expr><name><name>ctx</name>-&gt;<name>dpool</name></name></expr></argument>, <argument><expr>""</expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<decl_stmt><decl><type><name>apr_size_t</name></type> <name>len</name> <init>= <expr><name>p</name> - <name><name>token</name>-&gt;<name>value</name></name> - <name>shift</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>c</name> <init>= <expr><call><name>apr_palloc</name><argument_list>(<argument><expr><name><name>ctx</name>-&gt;<name>dpool</name></name></expr></argument>, <argument><expr><name>len</name> + 1</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>p</name> = <name><name>token</name>-&gt;<name>value</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>token</name>-&gt;<name>value</name></name> = <name>c</name></expr>;</expr_stmt>
<while>while <condition>(<expr><name>shift</name>--</expr>)</condition> <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>e</name> <init>= <expr><call><name>ap_strchr_c</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr>'\\'</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>e</name>-<name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>c</name> += <name>e</name>-<name>p</name></expr>;</expr_stmt>
<expr_stmt><expr>*<name>c</name>++ = *++<name>e</name></expr>;</expr_stmt>
<expr_stmt><expr><name>len</name> -= <name>e</name>-<name>p</name></expr>;</expr_stmt>
<expr_stmt><expr><name>p</name> = <name>e</name>+1</expr>;</expr_stmt>
}</block></while>
<if>if <condition>(<expr><name>len</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><name><name>c</name><index>[<expr><name>len</name></expr>]</index></name> = '\0'</expr>;</expr_stmt>
}</block></else></if>
<return>return <expr><name>unmatched</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>parse_expr</name><parameter_list>(<param><decl><type><name>include_ctx_t</name> *</type><name>ctx</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>expr</name></decl></param>, <param><decl><type><name>int</name> *</type><name>was_error</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>parse_node_t</name> *</type><name>new</name></decl>, *<decl><type ref="prev"/><name>root</name> <init>= <expr><name>NULL</name></expr></init>, *<name>current</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>request_rec</name> *</type><name>r</name> <init>= <expr><name><name>ctx</name>-&gt;<name>r</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>request_rec</name> *</type><name>rr</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>error</name> <init>= <expr><call><name>APLOGNO</name><argument_list>(<argument><expr>03188</expr></argument>)</argument_list></call> "Invalid expression \"%s\" in file %s"</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>parse</name> <init>= <expr><name>expr</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name></type> <name>regex</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<expr_stmt><expr>*<name>was_error</name> = 0</expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>parse</name></expr>)</condition><then> <block>{
<return>return <expr>0</expr>;</return>
}</block></then></if>
<while>while <condition>(<expr>1</expr>)</condition> <block>{
<expr_stmt><expr><call><name>CREATE_NODE</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>new</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>DEBUG_INCLUDE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>int</name></type> <name>was_unmatched</name> <init>=
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr><call><name>get_ptoken</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr>&amp;<name>parse</name></expr></argument>, <argument><expr>&amp;<name><name>new</name>-&gt;<name>token</name></name></expr></argument>,
<argument><expr>(<name>current</name> != <name>NULL</name> ? &amp;<name><name>current</name>-&gt;<name>token</name></name> : <name>NULL</name>)</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr>!<name>parse</name></expr>)</condition><then>
<break>break;</break></then></if>
<expr_stmt><expr><call><name>DEBUG_DUMP_UNMATCHED</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>was_unmatched</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>DEBUG_DUMP_TOKEN</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr>&amp;<name><name>new</name>-&gt;<name>token</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block>
<if>if <condition>(<expr>!<name>current</name></expr>)</condition><then> <block>{
<switch>switch <condition>(<expr><name><name>new</name>-&gt;<name>token</name>.<name>type</name></name></expr>)</condition> <block>{
<case>case <expr><name>TOKEN_STRING</name></expr>:
</case><case>case <expr><name>TOKEN_NOT</name></expr>:
</case><case>case <expr><name>TOKEN_ACCESS</name></expr>:
</case><case>case <expr><name>TOKEN_LBRACE</name></expr>:
<expr_stmt><expr><name>root</name> = <name>current</name> = <name>new</name></expr>;</expr_stmt>
<continue>continue;</continue>
</case><default>default:
<expr_stmt><expr><call><name>ap_log_rerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_ERR</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><name>error</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>,
<argument><expr><name><name>r</name>-&gt;<name>filename</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr>*<name>was_error</name> = 1</expr>;</expr_stmt>
<return>return <expr>0</expr>;</return>
</default>}</block></switch>
}</block></then></if>
<switch>switch <condition>(<expr><name><name>new</name>-&gt;<name>token</name>.<name>type</name></name></expr>)</condition> <block>{
<case>case <expr><name>TOKEN_STRING</name></expr>:
<switch>switch <condition>(<expr><name><name>current</name>-&gt;<name>token</name>.<name>type</name></name></expr>)</condition> <block>{
<case>case <expr><name>TOKEN_STRING</name></expr>:
<expr_stmt><expr><name><name>current</name>-&gt;<name>token</name>.<name>value</name></name> =
<call><name>apr_pstrcat</name><argument_list>(<argument><expr><name><name>ctx</name>-&gt;<name>dpool</name></name></expr></argument>, <argument><expr><name><name>current</name>-&gt;<name>token</name>.<name>value</name></name></expr></argument>,
<argument><expr>*<name><name>current</name>-&gt;<name>token</name>.<name>value</name></name> ? " " : ""</expr></argument>,
<argument><expr><name><name>new</name>-&gt;<name>token</name>.<name>value</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<continue>continue;</continue>
</case><case>case <expr><name>TOKEN_RE</name></expr>:
</case><case>case <expr><name>TOKEN_RBRACE</name></expr>:
</case><case>case <expr><name>TOKEN_GROUP</name></expr>:
<break>break;</break>
</case><default>default:
<expr_stmt><expr><name><name>new</name>-&gt;<name>parent</name></name> = <name>current</name></expr>;</expr_stmt>
<expr_stmt><expr><name>current</name> = <name><name>current</name>-&gt;<name>right</name></name> = <name>new</name></expr>;</expr_stmt>
<continue>continue;</continue>
</default>}</block></switch>
<break>break;</break>
</case><case>case <expr><name>TOKEN_RE</name></expr>:
<switch>switch <condition>(<expr><name><name>current</name>-&gt;<name>token</name>.<name>type</name></name></expr>)</condition> <block>{
<case>case <expr><name>TOKEN_EQ</name></expr>:
</case><case>case <expr><name>TOKEN_NE</name></expr>:
<expr_stmt><expr><name><name>new</name>-&gt;<name>parent</name></name> = <name>current</name></expr>;</expr_stmt>
<expr_stmt><expr><name>current</name> = <name><name>current</name>-&gt;<name>right</name></name> = <name>new</name></expr>;</expr_stmt>
<expr_stmt><expr>++<name>regex</name></expr>;</expr_stmt>
<continue>continue;</continue>
</case><default>default:
<break>break;</break>
</default>}</block></switch>
<break>break;</break>
</case><case>case <expr><name>TOKEN_AND</name></expr>:
</case><case>case <expr><name>TOKEN_OR</name></expr>:
<switch>switch <condition>(<expr><name><name>current</name>-&gt;<name>token</name>.<name>type</name></name></expr>)</condition> <block>{
<case>case <expr><name>TOKEN_STRING</name></expr>:
</case><case>case <expr><name>TOKEN_RE</name></expr>:
</case><case>case <expr><name>TOKEN_GROUP</name></expr>:
<expr_stmt><expr><name>current</name> = <name><name>current</name>-&gt;<name>parent</name></name></expr>;</expr_stmt>
<while>while <condition>(<expr><name>current</name></expr>)</condition> <block>{
<switch>switch <condition>(<expr><name><name>current</name>-&gt;<name>token</name>.<name>type</name></name></expr>)</condition> <block>{
<case>case <expr><name>TOKEN_AND</name></expr>:
</case><case>case <expr><name>TOKEN_OR</name></expr>:
</case><case>case <expr><name>TOKEN_LBRACE</name></expr>:
<break>break;</break>
</case><default>default:
<expr_stmt><expr><name>current</name> = <name><name>current</name>-&gt;<name>parent</name></name></expr>;</expr_stmt>
<continue>continue;</continue>
</default>}</block></switch>
<break>break;</break>
}</block></while>
<if>if <condition>(<expr>!<name>current</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>new</name>-&gt;<name>left</name></name> = <name>root</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>root</name>-&gt;<name>parent</name></name> = <name>new</name></expr>;</expr_stmt>
<expr_stmt><expr><name>current</name> = <name>root</name> = <name>new</name></expr>;</expr_stmt>
<continue>continue;</continue>
}</block></then></if>
<expr_stmt><expr><name><name>new</name>-&gt;<name>left</name></name> = <name><name>current</name>-&gt;<name>right</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>new</name>-&gt;<name>left</name>-&gt;<name>parent</name></name> = <name>new</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>new</name>-&gt;<name>parent</name></name> = <name>current</name></expr>;</expr_stmt>
<expr_stmt><expr><name>current</name> = <name><name>current</name>-&gt;<name>right</name></name> = <name>new</name></expr>;</expr_stmt>
<continue>continue;</continue>
</case><default>default:
<break>break;</break>
</default>}</block></switch>
<break>break;</break>
</case><case>case <expr><name>TOKEN_EQ</name></expr>:
</case><case>case <expr><name>TOKEN_NE</name></expr>:
</case><case>case <expr><name>TOKEN_GE</name></expr>:
</case><case>case <expr><name>TOKEN_GT</name></expr>:
</case><case>case <expr><name>TOKEN_LE</name></expr>:
</case><case>case <expr><name>TOKEN_LT</name></expr>:
<if>if <condition>(<expr><name><name>current</name>-&gt;<name>token</name>.<name>type</name></name> == <name>TOKEN_STRING</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>current</name> = <name><name>current</name>-&gt;<name>parent</name></name></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>current</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>new</name>-&gt;<name>left</name></name> = <name>root</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>root</name>-&gt;<name>parent</name></name> = <name>new</name></expr>;</expr_stmt>
<expr_stmt><expr><name>current</name> = <name>root</name> = <name>new</name></expr>;</expr_stmt>
<continue>continue;</continue>
}</block></then></if>
<switch>switch <condition>(<expr><name><name>current</name>-&gt;<name>token</name>.<name>type</name></name></expr>)</condition> <block>{
<case>case <expr><name>TOKEN_LBRACE</name></expr>:
</case><case>case <expr><name>TOKEN_AND</name></expr>:
</case><case>case <expr><name>TOKEN_OR</name></expr>:
<expr_stmt><expr><name><name>new</name>-&gt;<name>left</name></name> = <name><name>current</name>-&gt;<name>right</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>new</name>-&gt;<name>left</name>-&gt;<name>parent</name></name> = <name>new</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>new</name>-&gt;<name>parent</name></name> = <name>current</name></expr>;</expr_stmt>
<expr_stmt><expr><name>current</name> = <name><name>current</name>-&gt;<name>right</name></name> = <name>new</name></expr>;</expr_stmt>
<continue>continue;</continue>
</case><default>default:
<break>break;</break>
</default>}</block></switch>
}</block></then></if>
<break>break;</break>
</case><case>case <expr><name>TOKEN_RBRACE</name></expr>:
<while>while <condition>(<expr><name>current</name> &amp;&amp; <name><name>current</name>-&gt;<name>token</name>.<name>type</name></name> != <name>TOKEN_LBRACE</name></expr>)</condition> <block>{
<expr_stmt><expr><name>current</name> = <name><name>current</name>-&gt;<name>parent</name></name></expr>;</expr_stmt>
}</block></while>
<if>if <condition>(<expr><name>current</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>TYPE_TOKEN</name><argument_list>(<argument><expr>&amp;<name><name>current</name>-&gt;<name>token</name></name></expr></argument>, <argument><expr><name>TOKEN_GROUP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<continue>continue;</continue>
}</block></then></if>
<expr_stmt><expr><name>error</name> = <call><name>APLOGNO</name><argument_list>(<argument><expr>03189</expr></argument>)</argument_list></call> "Unmatched ')' in \"%s\" in file %s"</expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr><name>TOKEN_NOT</name></expr>:
</case><case>case <expr><name>TOKEN_ACCESS</name></expr>:
</case><case>case <expr><name>TOKEN_LBRACE</name></expr>:
<switch>switch <condition>(<expr><name><name>current</name>-&gt;<name>token</name>.<name>type</name></name></expr>)</condition> <block>{
<case>case <expr><name>TOKEN_STRING</name></expr>:
</case><case>case <expr><name>TOKEN_RE</name></expr>:
</case><case>case <expr><name>TOKEN_RBRACE</name></expr>:
</case><case>case <expr><name>TOKEN_GROUP</name></expr>:
<break>break;</break>
</case><default>default:
<expr_stmt><expr><name><name>current</name>-&gt;<name>right</name></name> = <name>new</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>new</name>-&gt;<name>parent</name></name> = <name>current</name></expr>;</expr_stmt>
<expr_stmt><expr><name>current</name> = <name>new</name></expr>;</expr_stmt>
<continue>continue;</continue>
</default>}</block></switch>
<break>break;</break>
</case><default>default:
<break>break;</break>
</default>}</block></switch>
<expr_stmt><expr><call><name>ap_log_rerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_ERR</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><name>error</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>filename</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr>*<name>was_error</name> = 1</expr>;</expr_stmt>
<return>return <expr>0</expr>;</return>
}</block></while>
<expr_stmt><expr><call><name>DEBUG_DUMP_TREE</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>current</name> = <name>root</name></expr>;</expr_stmt>
<expr_stmt><expr><name>error</name> = <name>NULL</name></expr>;</expr_stmt>
<while>while <condition>(<expr><name>current</name></expr>)</condition> <block>{
<switch>switch <condition>(<expr><name><name>current</name>-&gt;<name>token</name>.<name>type</name></name></expr>)</condition> <block>{
<case>case <expr><name>TOKEN_STRING</name></expr>:
<expr_stmt><expr><name><name>current</name>-&gt;<name>token</name>.<name>value</name></name> =
<call><name>ap_ssi_parse_string</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name><name>current</name>-&gt;<name>token</name>.<name>value</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr>0</expr></argument>,
<argument><expr><name>SSI_EXPAND_DROP_NAME</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>current</name>-&gt;<name>value</name></name> = !!*<name><name>current</name>-&gt;<name>token</name>.<name>value</name></name></expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr><name>TOKEN_AND</name></expr>:
</case><case>case <expr><name>TOKEN_OR</name></expr>:
<if>if <condition>(<expr>!<name><name>current</name>-&gt;<name>left</name></name> || !<name><name>current</name>-&gt;<name>right</name></name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>ap_log_rerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_ERR</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>01332</expr></argument>)</argument_list></call>
"Invalid expression \"%s\" in file %s"</expr></argument>,
<argument><expr><name>expr</name></expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>filename</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr>*<name>was_error</name> = 1</expr>;</expr_stmt>
<return>return <expr>0</expr>;</return>
}</block></then></if>
<if>if <condition>(<expr>!<name><name>current</name>-&gt;<name>left</name>-&gt;<name>done</name></name></expr>)</condition><then> <block>{
<switch>switch <condition>(<expr><name><name>current</name>-&gt;<name>left</name>-&gt;<name>token</name>.<name>type</name></name></expr>)</condition> <block>{
<case>case <expr><name>TOKEN_STRING</name></expr>:
<expr_stmt><expr><name><name>current</name>-&gt;<name>left</name>-&gt;<name>token</name>.<name>value</name></name> =
<call><name>ap_ssi_parse_string</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name><name>current</name>-&gt;<name>left</name>-&gt;<name>token</name>.<name>value</name></name></expr></argument>,
<argument><expr><name>NULL</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>SSI_EXPAND_DROP_NAME</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>current</name>-&gt;<name>left</name>-&gt;<name>value</name></name> = !!*<name><name>current</name>-&gt;<name>left</name>-&gt;<name>token</name>.<name>value</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>DEBUG_DUMP_EVAL</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name><name>current</name>-&gt;<name>left</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>current</name>-&gt;<name>left</name>-&gt;<name>done</name></name> = 1</expr>;</expr_stmt>
<break>break;</break>
</case><default>default:
<expr_stmt><expr><name>current</name> = <name><name>current</name>-&gt;<name>left</name></name></expr>;</expr_stmt>
<continue>continue;</continue>
</default>}</block></switch>
}</block></then></if>
<if>if <condition>(<expr>!<name><name>current</name>-&gt;<name>right</name>-&gt;<name>done</name></name> &amp;&amp; !<name>regex</name> &amp;&amp;
((<name><name>current</name>-&gt;<name>token</name>.<name>type</name></name> == <name>TOKEN_AND</name> &amp;&amp; !<name><name>current</name>-&gt;<name>left</name>-&gt;<name>value</name></name>) ||
(<name><name>current</name>-&gt;<name>token</name>.<name>type</name></name> == <name>TOKEN_OR</name> &amp;&amp; <name><name>current</name>-&gt;<name>left</name>-&gt;<name>value</name></name>))</expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>current</name>-&gt;<name>value</name></name> = <name><name>current</name>-&gt;<name>left</name>-&gt;<name>value</name></name></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<if>if <condition>(<expr>!<name><name>current</name>-&gt;<name>right</name>-&gt;<name>done</name></name></expr>)</condition><then> <block>{
<switch>switch <condition>(<expr><name><name>current</name>-&gt;<name>right</name>-&gt;<name>token</name>.<name>type</name></name></expr>)</condition> <block>{
<case>case <expr><name>TOKEN_STRING</name></expr>:
<expr_stmt><expr><name><name>current</name>-&gt;<name>right</name>-&gt;<name>token</name>.<name>value</name></name> =
<call><name>ap_ssi_parse_string</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>,<argument><expr><name><name>current</name>-&gt;<name>right</name>-&gt;<name>token</name>.<name>value</name></name></expr></argument>,
<argument><expr><name>NULL</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>SSI_EXPAND_DROP_NAME</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>current</name>-&gt;<name>right</name>-&gt;<name>value</name></name> = !!*<name><name>current</name>-&gt;<name>right</name>-&gt;<name>token</name>.<name>value</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>DEBUG_DUMP_EVAL</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name><name>current</name>-&gt;<name>right</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>current</name>-&gt;<name>right</name>-&gt;<name>done</name></name> = 1</expr>;</expr_stmt>
<break>break;</break>
</case><default>default:
<expr_stmt><expr><name>current</name> = <name><name>current</name>-&gt;<name>right</name></name></expr>;</expr_stmt>
<continue>continue;</continue>
</default>}</block></switch>
}</block></then></if>
<if>if <condition>(<expr><name><name>current</name>-&gt;<name>token</name>.<name>type</name></name> == <name>TOKEN_AND</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>current</name>-&gt;<name>value</name></name> = <name><name>current</name>-&gt;<name>left</name>-&gt;<name>value</name></name> &amp;&amp;
<name><name>current</name>-&gt;<name>right</name>-&gt;<name>value</name></name></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr><name><name>current</name>-&gt;<name>value</name></name> = <name><name>current</name>-&gt;<name>left</name>-&gt;<name>value</name></name> ||
<name><name>current</name>-&gt;<name>right</name>-&gt;<name>value</name></name></expr>;</expr_stmt>
}</block></else></if>
}</block></else></if>
<break>break;</break>
</case><case>case <expr><name>TOKEN_EQ</name></expr>:
</case><case>case <expr><name>TOKEN_NE</name></expr>:
<if>if <condition>(<expr>!<name><name>current</name>-&gt;<name>left</name></name> || !<name><name>current</name>-&gt;<name>right</name></name> ||
<name><name>current</name>-&gt;<name>left</name>-&gt;<name>token</name>.<name>type</name></name> != <name>TOKEN_STRING</name> ||
(<name><name>current</name>-&gt;<name>right</name>-&gt;<name>token</name>.<name>type</name></name> != <name>TOKEN_STRING</name> &amp;&amp;
<name><name>current</name>-&gt;<name>right</name>-&gt;<name>token</name>.<name>type</name></name> != <name>TOKEN_RE</name>)</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>ap_log_rerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_ERR</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>01333</expr></argument>)</argument_list></call>
"Invalid expression \"%s\" in file %s"</expr></argument>,
<argument><expr><name>expr</name></expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>filename</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr>*<name>was_error</name> = 1</expr>;</expr_stmt>
<return>return <expr>0</expr>;</return>
}</block></then></if>
<expr_stmt><expr><name><name>current</name>-&gt;<name>left</name>-&gt;<name>token</name>.<name>value</name></name> =
<call><name>ap_ssi_parse_string</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name><name>current</name>-&gt;<name>left</name>-&gt;<name>token</name>.<name>value</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr>0</expr></argument>,
<argument><expr><name>SSI_EXPAND_DROP_NAME</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>current</name>-&gt;<name>right</name>-&gt;<name>token</name>.<name>value</name></name> =
<call><name>ap_ssi_parse_string</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name><name>current</name>-&gt;<name>right</name>-&gt;<name>token</name>.<name>value</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr>0</expr></argument>,
<argument><expr><name>SSI_EXPAND_DROP_NAME</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>current</name>-&gt;<name>right</name>-&gt;<name>token</name>.<name>type</name></name> == <name>TOKEN_RE</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>current</name>-&gt;<name>value</name></name> = <call><name>re_check</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name><name>current</name>-&gt;<name>left</name>-&gt;<name>token</name>.<name>value</name></name></expr></argument>,
<argument><expr><name><name>current</name>-&gt;<name>right</name>-&gt;<name>token</name>.<name>value</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr>--<name>regex</name></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr><name><name>current</name>-&gt;<name>value</name></name> = !<call><name>strcmp</name><argument_list>(<argument><expr><name><name>current</name>-&gt;<name>left</name>-&gt;<name>token</name>.<name>value</name></name></expr></argument>,
<argument><expr><name><name>current</name>-&gt;<name>right</name>-&gt;<name>token</name>.<name>value</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></else></if>
<if>if <condition>(<expr><name><name>current</name>-&gt;<name>token</name>.<name>type</name></name> == <name>TOKEN_NE</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>current</name>-&gt;<name>value</name></name> = !<name><name>current</name>-&gt;<name>value</name></name></expr>;</expr_stmt>
}</block></then></if>
<break>break;</break>
</case><case>case <expr><name>TOKEN_GE</name></expr>:
</case><case>case <expr><name>TOKEN_GT</name></expr>:
</case><case>case <expr><name>TOKEN_LE</name></expr>:
</case><case>case <expr><name>TOKEN_LT</name></expr>:
<if>if <condition>(<expr>!<name><name>current</name>-&gt;<name>left</name></name> || !<name><name>current</name>-&gt;<name>right</name></name> ||
<name><name>current</name>-&gt;<name>left</name>-&gt;<name>token</name>.<name>type</name></name> != <name>TOKEN_STRING</name> ||
<name><name>current</name>-&gt;<name>right</name>-&gt;<name>token</name>.<name>type</name></name> != <name>TOKEN_STRING</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>ap_log_rerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_ERR</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>01334</expr></argument>)</argument_list></call>
"Invalid expression \"%s\" in file %s"</expr></argument>,
<argument><expr><name>expr</name></expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>filename</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr>*<name>was_error</name> = 1</expr>;</expr_stmt>
<return>return <expr>0</expr>;</return>
}</block></then></if>
<expr_stmt><expr><name><name>current</name>-&gt;<name>left</name>-&gt;<name>token</name>.<name>value</name></name> =
<call><name>ap_ssi_parse_string</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name><name>current</name>-&gt;<name>left</name>-&gt;<name>token</name>.<name>value</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr>0</expr></argument>,
<argument><expr><name>SSI_EXPAND_DROP_NAME</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>current</name>-&gt;<name>right</name>-&gt;<name>token</name>.<name>value</name></name> =
<call><name>ap_ssi_parse_string</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name><name>current</name>-&gt;<name>right</name>-&gt;<name>token</name>.<name>value</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr>0</expr></argument>,
<argument><expr><name>SSI_EXPAND_DROP_NAME</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>current</name>-&gt;<name>value</name></name> = <call><name>strcmp</name><argument_list>(<argument><expr><name><name>current</name>-&gt;<name>left</name>-&gt;<name>token</name>.<name>value</name></name></expr></argument>,
<argument><expr><name><name>current</name>-&gt;<name>right</name>-&gt;<name>token</name>.<name>value</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<switch>switch <condition>(<expr><name><name>current</name>-&gt;<name>token</name>.<name>type</name></name></expr>)</condition> <block>{
<case>case <expr><name>TOKEN_GE</name></expr>:
<expr_stmt><expr><name><name>current</name>-&gt;<name>value</name></name> = <name><name>current</name>-&gt;<name>value</name></name> &gt;= 0</expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr><name>TOKEN_GT</name></expr>:
<expr_stmt><expr><name><name>current</name>-&gt;<name>value</name></name> = <name><name>current</name>-&gt;<name>value</name></name> &gt; 0</expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr><name>TOKEN_LE</name></expr>:
<expr_stmt><expr><name><name>current</name>-&gt;<name>value</name></name> = <name><name>current</name>-&gt;<name>value</name></name> &lt;= 0</expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr><name>TOKEN_LT</name></expr>:
<expr_stmt><expr><name><name>current</name>-&gt;<name>value</name></name> = <name><name>current</name>-&gt;<name>value</name></name> &lt; 0</expr>;</expr_stmt>
<break>break;</break>
</case><default>default:
<expr_stmt><expr><name><name>current</name>-&gt;<name>value</name></name> = 0</expr>;</expr_stmt>
<break>break;</break>
</default>}</block></switch>
<break>break;</break>
</case><case>case <expr><name>TOKEN_NOT</name></expr>:
</case><case>case <expr><name>TOKEN_GROUP</name></expr>:
<if>if <condition>(<expr><name><name>current</name>-&gt;<name>right</name></name></expr>)</condition><then> <block>{
<if>if <condition>(<expr>!<name><name>current</name>-&gt;<name>right</name>-&gt;<name>done</name></name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>current</name> = <name><name>current</name>-&gt;<name>right</name></name></expr>;</expr_stmt>
<continue>continue;</continue>
}</block></then></if>
<expr_stmt><expr><name><name>current</name>-&gt;<name>value</name></name> = <name><name>current</name>-&gt;<name>right</name>-&gt;<name>value</name></name></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr><name><name>current</name>-&gt;<name>value</name></name> = 1</expr>;</expr_stmt>
}</block></else></if>
<if>if <condition>(<expr><name><name>current</name>-&gt;<name>token</name>.<name>type</name></name> == <name>TOKEN_NOT</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>current</name>-&gt;<name>value</name></name> = !<name><name>current</name>-&gt;<name>value</name></name></expr>;</expr_stmt>
}</block></then></if>
<break>break;</break>
</case><case>case <expr><name>TOKEN_ACCESS</name></expr>:
<if>if <condition>(<expr><name><name>current</name>-&gt;<name>left</name></name> || !<name><name>current</name>-&gt;<name>right</name></name> ||
(<name><name>current</name>-&gt;<name>right</name>-&gt;<name>token</name>.<name>type</name></name> != <name>TOKEN_STRING</name> &amp;&amp;
<name><name>current</name>-&gt;<name>right</name>-&gt;<name>token</name>.<name>type</name></name> != <name>TOKEN_RE</name>)</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>ap_log_rerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_ERR</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>01335</expr></argument>)</argument_list></call>
"Invalid expression \"%s\" in file %s: Token '-A' must be followed by a URI string."</expr></argument>,
<argument><expr><name>expr</name></expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>filename</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr>*<name>was_error</name> = 1</expr>;</expr_stmt>
<return>return <expr>0</expr>;</return>
}</block></then></if>
<expr_stmt><expr><name><name>current</name>-&gt;<name>right</name>-&gt;<name>token</name>.<name>value</name></name> =
<call><name>ap_ssi_parse_string</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name><name>current</name>-&gt;<name>right</name>-&gt;<name>token</name>.<name>value</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr>0</expr></argument>,
<argument><expr><name>SSI_EXPAND_DROP_NAME</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>rr</name> = <call><name>ap_sub_req_lookup_uri</name><argument_list>(<argument><expr><name><name>current</name>-&gt;<name>right</name>-&gt;<name>token</name>.<name>value</name></name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>rr</name>-&gt;<name>status</name></name> &lt; <name>HTTP_BAD_REQUEST</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>current</name>-&gt;<name>value</name></name> = 1</expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr><name><name>current</name>-&gt;<name>value</name></name> = 0</expr>;</expr_stmt>
<expr_stmt><expr><call><name>ap_log_rerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_DEBUG</name></expr></argument>, <argument><expr><name><name>rr</name>-&gt;<name>status</name></name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>01336</expr></argument>)</argument_list></call>
"mod_include: The tested "
"subrequest -A \"%s\" returned an error code."</expr></argument>,
<argument><expr><name><name>current</name>-&gt;<name>right</name>-&gt;<name>token</name>.<name>value</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></else></if>
<expr_stmt><expr><call><name>ap_destroy_sub_req</name><argument_list>(<argument><expr><name>rr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr><name>TOKEN_RE</name></expr>:
<if>if <condition>(<expr>!<name>error</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>error</name> = <call><name>APLOGNO</name><argument_list>(<argument><expr>03190</expr></argument>)</argument_list></call> "No operator before regex in expr \"%s\" in file %s"</expr>;</expr_stmt>
}</block></then></if>
</case><case>case <expr><name>TOKEN_LBRACE</name></expr>:
<if>if <condition>(<expr>!<name>error</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>error</name> = <call><name>APLOGNO</name><argument_list>(<argument><expr>03191</expr></argument>)</argument_list></call> "Unmatched '(' in \"%s\" in file %s"</expr>;</expr_stmt>
}</block></then></if>
</case><default>default:
<if>if <condition>(<expr>!<name>error</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>error</name> = <call><name>APLOGNO</name><argument_list>(<argument><expr>03192</expr></argument>)</argument_list></call> "internal parser error in \"%s\" in file %s"</expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><call><name>ap_log_rerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_ERR</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><name>error</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>filename</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr>*<name>was_error</name> = 1</expr>;</expr_stmt>
<return>return <expr>0</expr>;</return>
</default>}</block></switch>
<expr_stmt><expr><call><name>DEBUG_DUMP_EVAL</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>current</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>current</name>-&gt;<name>done</name></name> = 1</expr>;</expr_stmt>
<expr_stmt><expr><name>current</name> = <name><name>current</name>-&gt;<name>parent</name></name></expr>;</expr_stmt>
}</block></while>
<return>return <expr>(<name>root</name> ? <name><name>root</name>-&gt;<name>value</name></name> : 0)</expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>parse_ap_expr</name><parameter_list>(<param><decl><type><name>include_ctx_t</name> *</type><name>ctx</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>expr</name></decl></param>, <param><decl><type><name>int</name> *</type><name>was_error</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>ap_expr_info_t</name> *</type><name>expr_info</name> <init>= <expr><call><name>apr_pcalloc</name><argument_list>(<argument><expr><name><name>ctx</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr>*<name>expr_info</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>err</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>backref_t</name> *</type><name>re</name> <init>= <expr><name><name>ctx</name>-&gt;<name>intern</name>-&gt;<name>re</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ap_expr_eval_ctx_t</name> *</type><name>eval_ctx</name> <init>= <expr><name><name>ctx</name>-&gt;<name>intern</name>-&gt;<name>expr_eval_ctx</name></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>expr_info</name>-&gt;<name>filename</name></name> = <name><name>ctx</name>-&gt;<name>r</name>-&gt;<name>filename</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>expr_info</name>-&gt;<name>line_number</name></name> = 0</expr>;</expr_stmt>
<expr_stmt><expr><name><name>expr_info</name>-&gt;<name>module_index</name></name> = <name>APLOG_MODULE_INDEX</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>expr_info</name>-&gt;<name>flags</name></name> = <name>AP_EXPR_FLAG_RESTRICTED</name></expr>;</expr_stmt>
<expr_stmt><expr><name>err</name> = <call><name>ap_expr_parse</name><argument_list>(<argument><expr><name><name>ctx</name>-&gt;<name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name><name>ctx</name>-&gt;<name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>expr_info</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>,
<argument><expr><name>include_expr_lookup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>err</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>ap_log_rerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_ERR</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name><name>ctx</name>-&gt;<name>r</name></name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>01337</expr></argument>)</argument_list></call>
"Could not parse expr \"%s\" in %s: %s"</expr></argument>, <argument><expr><name>expr</name></expr></argument>,
<argument><expr><name><name>ctx</name>-&gt;<name>r</name>-&gt;<name>filename</name></name></expr></argument>, <argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr>*<name>was_error</name> = 1</expr>;</expr_stmt>
<return>return <expr>0</expr>;</return>
}</block></then></if>
<if>if <condition>(<expr>!<name>re</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>ctx</name>-&gt;<name>intern</name>-&gt;<name>re</name></name> = <name>re</name> = <call><name>apr_pcalloc</name><argument_list>(<argument><expr><name><name>ctx</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>*<name>re</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<if>if <condition>(<expr>!<name><name>re</name>-&gt;<name>have_match</name></name></expr>)</condition><then>
<expr_stmt><expr><name><name>re</name>-&gt;<name>source</name></name> = <name>NULL</name></expr>;</expr_stmt></then></if>
}</block></else></if>
<if>if <condition>(<expr>!<name>eval_ctx</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>eval_ctx</name> = <call><name>apr_pcalloc</name><argument_list>(<argument><expr><name><name>ctx</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>*<name>eval_ctx</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ctx</name>-&gt;<name>intern</name>-&gt;<name>expr_eval_ctx</name></name> = <name>eval_ctx</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>eval_ctx</name>-&gt;<name>r</name></name> = <name><name>ctx</name>-&gt;<name>r</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>eval_ctx</name>-&gt;<name>c</name></name> = <name><name>ctx</name>-&gt;<name>r</name>-&gt;<name>connection</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>eval_ctx</name>-&gt;<name>s</name></name> = <name><name>ctx</name>-&gt;<name>r</name>-&gt;<name>server</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>eval_ctx</name>-&gt;<name>p</name></name> = <name><name>ctx</name>-&gt;<name>r</name>-&gt;<name>pool</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>eval_ctx</name>-&gt;<name>data</name></name> = <name>ctx</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>eval_ctx</name>-&gt;<name>err</name></name> = &amp;<name><name>ctx</name>-&gt;<name>intern</name>-&gt;<name>expr_err</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>eval_ctx</name>-&gt;<name>vary_this</name></name> = &amp;<name><name>ctx</name>-&gt;<name>intern</name>-&gt;<name>expr_vary_this</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>eval_ctx</name>-&gt;<name>re_nmatch</name></name> = <name>AP_MAX_REG_MATCH</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>eval_ctx</name>-&gt;<name>re_pmatch</name></name> = <name><name>re</name>-&gt;<name>match</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>eval_ctx</name>-&gt;<name>re_source</name></name> = &amp;<name><name>re</name>-&gt;<name>source</name></name></expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><name><name>eval_ctx</name>-&gt;<name>info</name></name> = <name>expr_info</name></expr>;</expr_stmt>
<expr_stmt><expr><name>ret</name> = <call><name>ap_expr_exec_ctx</name><argument_list>(<argument><expr><name>eval_ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>ret</name> &lt; 0</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>ap_log_rerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_ERR</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name><name>ctx</name>-&gt;<name>r</name></name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>01338</expr></argument>)</argument_list></call>
"Could not evaluate expr \"%s\" in %s: %s"</expr></argument>, <argument><expr><name>expr</name></expr></argument>,
<argument><expr><name><name>ctx</name>-&gt;<name>r</name>-&gt;<name>filename</name></name></expr></argument>, <argument><expr><name><name>ctx</name>-&gt;<name>intern</name>-&gt;<name>expr_err</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr>*<name>was_error</name> = 1</expr>;</expr_stmt>
<return>return <expr>0</expr>;</return>
}</block></then></if>
<expr_stmt><expr>*<name>was_error</name> = 0</expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>re</name>-&gt;<name>source</name></name></expr>)</condition><then>
<expr_stmt><expr><name><name>re</name>-&gt;<name>have_match</name></name> = 1</expr>;</expr_stmt></then></if>
<return>return <expr><name>ret</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>ap_ssi_get_tag_and_value</name><parameter_list>(<param><decl><type><name>include_ctx_t</name> *</type><name>ctx</name></decl></param>, <param><decl><type><name>char</name> **</type><name>tag</name></decl></param>,
<param><decl><type><name>char</name> **</type><name>tag_val</name></decl></param>, <param><decl><type><name>int</name></type> <name>dodecode</name></decl></param>)</parameter_list> <block>{
<if>if <condition>(<expr>!<name><name>ctx</name>-&gt;<name>intern</name>-&gt;<name>argv</name></name></expr>)</condition><then> <block>{
<expr_stmt><expr>*<name>tag</name> = <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr>*<name>tag_val</name> = <name>NULL</name></expr>;</expr_stmt>
<return>return;</return>
}</block></then></if>
<expr_stmt><expr>*<name>tag_val</name> = <name><name>ctx</name>-&gt;<name>intern</name>-&gt;<name>argv</name>-&gt;<name>value</name></name></expr>;</expr_stmt>
<expr_stmt><expr>*<name>tag</name> = <name><name>ctx</name>-&gt;<name>intern</name>-&gt;<name>argv</name>-&gt;<name>name</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ctx</name>-&gt;<name>intern</name>-&gt;<name>argv</name></name> = <name><name>ctx</name>-&gt;<name>intern</name>-&gt;<name>argv</name>-&gt;<name>next</name></name></expr>;</expr_stmt>
<if>if <condition>(<expr><name>dodecode</name> &amp;&amp; *<name>tag_val</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>decodehtml</name><argument_list>(<argument><expr>*<name>tag_val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>find_file</name><parameter_list>(<param><decl><type><name>request_rec</name> *</type><name>r</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>directive</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>tag</name></decl></param>,
<param><decl><type><name>char</name> *</type><name>tag_val</name></decl></param>, <param><decl><type><name>apr_finfo_t</name> *</type><name>finfo</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>char</name> *</type><name>to_send</name> <init>= <expr><name>tag_val</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>request_rec</name> *</type><name>rr</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>ret</name><init>=<expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>error_fmt</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>apr_status_t</name></type> <name>rv</name> <init>= <expr><name>APR_SUCCESS</name></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>strcmp</name><argument_list>(<argument><expr><name>tag</name></expr></argument>, <argument><expr>"file"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>char</name> *</type><name>newpath</name></decl>;</decl_stmt>
<expr_stmt><expr><name>rv</name> = <call><name>apr_filepath_merge</name><argument_list>(<argument><expr>&amp;<name>newpath</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>tag_val</name></expr></argument>,
<argument><expr><name>APR_FILEPATH_SECUREROOTTEST</name> |
<name>APR_FILEPATH_NOTABSOLUTE</name></expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>rv</name> != <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>error_fmt</name> = <call><name>APLOGNO</name><argument_list>(<argument><expr>02668</expr></argument>)</argument_list></call> "unable to access file \"%s\" "
"in parsed file %s"</expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr><name>rr</name> = <call><name>ap_sub_req_lookup_file</name><argument_list>(<argument><expr><name>newpath</name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>rr</name>-&gt;<name>status</name></name> == <name>HTTP_OK</name> &amp;&amp; <name><name>rr</name>-&gt;<name>finfo</name>.<name>filetype</name></name> != <name>APR_NOFILE</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>to_send</name> = <name><name>rr</name>-&gt;<name>filename</name></name></expr>;</expr_stmt>
<if>if <condition>(<expr>(<name>rv</name> = <call><name>apr_stat</name><argument_list>(<argument><expr><name>finfo</name></expr></argument>, <argument><expr><name>to_send</name></expr></argument>,
<argument><expr><name>APR_FINFO_GPROT</name> | <name>APR_FINFO_MIN</name></expr></argument>, <argument><expr><name><name>rr</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call>) != <name>APR_SUCCESS</name>
&amp;&amp; <name>rv</name> != <name>APR_INCOMPLETE</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>error_fmt</name> = <call><name>APLOGNO</name><argument_list>(<argument><expr>02669</expr></argument>)</argument_list></call> "unable to get information "
"about \"%s\" in parsed file %s"</expr>;</expr_stmt>
}</block></then></if>
}</block></then> <else>else <block>{
<expr_stmt><expr><name>error_fmt</name> = <call><name>APLOGNO</name><argument_list>(<argument><expr>02670</expr></argument>)</argument_list></call> "unable to lookup information "
"about \"%s\" in parsed file %s"</expr>;</expr_stmt>
}</block></else></if>
}</block></else></if>
<if>if <condition>(<expr><name>error_fmt</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>ret</name> = -1</expr>;</expr_stmt>
<expr_stmt><expr><call><name>ap_log_rerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_ERR</name></expr></argument>,
<argument><expr><name>rv</name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><name>error_fmt</name></expr></argument>, <argument><expr><name>to_send</name></expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>filename</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<if>if <condition>(<expr><name>rr</name></expr>)</condition><then> <expr_stmt><expr><call><name>ap_destroy_sub_req</name><argument_list>(<argument><expr><name>rr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<return>return <expr><name>ret</name></expr>;</return>
}</block></then> <else>else <if>if <condition>(<expr>!<call><name>strcmp</name><argument_list>(<argument><expr><name>tag</name></expr></argument>, <argument><expr>"virtual"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><name>rr</name> = <call><name>ap_sub_req_lookup_uri</name><argument_list>(<argument><expr><name>tag_val</name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>rr</name>-&gt;<name>status</name></name> == <name>HTTP_OK</name> &amp;&amp; <name><name>rr</name>-&gt;<name>finfo</name>.<name>filetype</name></name> != <name>APR_NOFILE</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>(<name>char</name> *) <name>finfo</name></expr></argument>, <argument><expr>(const <name>char</name> *) &amp;<name><name>rr</name>-&gt;<name>finfo</name></name></expr></argument>,
<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>rr</name>-&gt;<name>finfo</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ap_destroy_sub_req</name><argument_list>(<argument><expr><name>rr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>0</expr>;</return>
}</block></then> <else>else <block>{
<expr_stmt><expr><call><name>ap_log_rerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_ERR</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>01339</expr></argument>)</argument_list></call> "unable to get "
"information about \"%s\" in parsed file %s"</expr></argument>,
<argument><expr><name>tag_val</name></expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>filename</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ap_destroy_sub_req</name><argument_list>(<argument><expr><name>rr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>-1</expr>;</return>
}</block></else></if>
}</block></then> <else>else <block>{
<expr_stmt><expr><call><name>ap_log_rerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_ERR</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>01340</expr></argument>)</argument_list></call> "unknown parameter \"%s\" "
"to tag %s in %s"</expr></argument>, <argument><expr><name>tag</name></expr></argument>, <argument><expr><name>directive</name></expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>filename</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>-1</expr>;</return>
}</block></else></if></else></if>
}</block></function>
<function><type><specifier>static</specifier> <name>apr_status_t</name></type> <name>handle_comment</name><parameter_list>(<param><decl><type><name>include_ctx_t</name> *</type><name>ctx</name></decl></param>, <param><decl><type><name>ap_filter_t</name> *</type><name>f</name></decl></param>,
<param><decl><type><name>apr_bucket_brigade</name> *</type><name>bb</name></decl></param>)</parameter_list> <block>{
<return>return <expr><name>APR_SUCCESS</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>apr_status_t</name></type> <name>handle_include</name><parameter_list>(<param><decl><type><name>include_ctx_t</name> *</type><name>ctx</name></decl></param>, <param><decl><type><name>ap_filter_t</name> *</type><name>f</name></decl></param>,
<param><decl><type><name>apr_bucket_brigade</name> *</type><name>bb</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>request_rec</name> *</type><name>r</name> <init>= <expr><name><name>f</name>-&gt;<name>r</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>last_error</name></decl>;</decl_stmt>
<if>if <condition>(<expr>!<name><name>ctx</name>-&gt;<name>argc</name></name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>ap_log_rerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>,
<argument><expr>(<name><name>ctx</name>-&gt;<name>flags</name></name> &amp; <name>SSI_FLAG_PRINTING</name>)
? <name>APLOG_ERR</name> : <name>APLOG_WARNING</name></expr></argument>,
<argument><expr>0</expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>01341</expr></argument>)</argument_list></call>
"missing argument for include element in %s"</expr></argument>,
<argument><expr><name><name>r</name>-&gt;<name>filename</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<if>if <condition>(<expr>!(<name><name>ctx</name>-&gt;<name>flags</name></name> &amp; <name>SSI_FLAG_PRINTING</name>)</expr>)</condition><then> <block>{
<return>return <expr><name>APR_SUCCESS</name></expr>;</return>
}</block></then></if>
<if>if <condition>(<expr>!<name><name>ctx</name>-&gt;<name>argc</name></name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>SSI_CREATE_ERROR_BUCKET</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>f</name></expr></argument>, <argument><expr><name>bb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>APR_SUCCESS</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>last_error</name> = <name>NULL</name></expr>;</expr_stmt>
<while>while <condition>(<expr>1</expr>)</condition> <block>{
<decl_stmt><decl><type><name>char</name> *</type><name>tag</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>tag_val</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>request_rec</name> *</type><name>rr</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>error_fmt</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>parsed_string</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>apr_status_t</name></type> <name>rv</name> <init>= <expr><name>APR_SUCCESS</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>status</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>ap_ssi_get_tag_and_value</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr>&amp;<name>tag</name></expr></argument>, <argument><expr>&amp;<name>tag_val</name></expr></argument>, <argument><expr><name>SSI_VALUE_DECODED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>tag</name> || !<name>tag_val</name></expr>)</condition><then> <block>{
<break>break;</break>
}</block></then></if>
<if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>tag</name></expr></argument>, <argument><expr>"virtual"</expr></argument>)</argument_list></call> &amp;&amp; <call><name>strcmp</name><argument_list>(<argument><expr><name>tag</name></expr></argument>, <argument><expr>"file"</expr></argument>)</argument_list></call> &amp;&amp; <call><name>strcmp</name><argument_list>(<argument><expr><name>tag</name></expr></argument>,
<argument><expr>"onerror"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>ap_log_rerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_ERR</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>01342</expr></argument>)</argument_list></call> "unknown parameter "
"\"%s\" to tag include in %s"</expr></argument>, <argument><expr><name>tag</name></expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>filename</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SSI_CREATE_ERROR_BUCKET</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>f</name></expr></argument>, <argument><expr><name>bb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
}</block></then></if>
<expr_stmt><expr><name>parsed_string</name> = <call><name>ap_ssi_parse_string</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>tag_val</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr>0</expr></argument>,
<argument><expr><name>SSI_EXPAND_DROP_NAME</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>tag</name><index>[<expr>0</expr>]</index></name> == 'f'</expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>char</name> *</type><name>newpath</name></decl>;</decl_stmt>
<expr_stmt><expr><name>rv</name> = <call><name>apr_filepath_merge</name><argument_list>(<argument><expr>&amp;<name>newpath</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>parsed_string</name></expr></argument>,
<argument><expr><name>APR_FILEPATH_SECUREROOTTEST</name> |
<name>APR_FILEPATH_NOTABSOLUTE</name></expr></argument>, <argument><expr><name><name>ctx</name>-&gt;<name>dpool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>rv</name> != <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>error_fmt</name> = "unable to include file \"%s\" in parsed file %s"</expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr><name>rr</name> = <call><name>ap_sub_req_lookup_file</name><argument_list>(<argument><expr><name>newpath</name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><name><name>f</name>-&gt;<name>next</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></else></if>
}</block></then> <else>else <if>if <condition>(<expr>(<name><name>tag</name><index>[<expr>0</expr>]</index></name> == 'v' &amp;&amp; !<name>last_error</name>)
|| (<name><name>tag</name><index>[<expr>0</expr>]</index></name> == 'o' &amp;&amp; <name>last_error</name>)</expr>)</condition><then> <block>{
<if>if <condition>(<expr><name><name>r</name>-&gt;<name>kept_body</name></name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>rr</name> = <call><name>ap_sub_req_method_uri</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>method</name></name></expr></argument>, <argument><expr><name>parsed_string</name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><name><name>f</name>-&gt;<name>next</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr><name>rr</name> = <call><name>ap_sub_req_lookup_uri</name><argument_list>(<argument><expr><name>parsed_string</name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><name><name>f</name>-&gt;<name>next</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></else></if>
}</block></then> <else>else <block>{
<continue>continue;</continue>
}</block></else></if></else></if>
<if>if <condition>(<expr>!<name>error_fmt</name> &amp;&amp; <name><name>rr</name>-&gt;<name>status</name></name> != <name>HTTP_OK</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>error_fmt</name> = "unable to include \"%s\" in parsed file %s, subrequest setup returned %d"</expr>;</expr_stmt>
}</block></then></if>
<if>if <condition>(<expr>!<name>error_fmt</name> &amp;&amp; (<name><name>ctx</name>-&gt;<name>flags</name></name> &amp; <name>SSI_FLAG_NO_EXEC</name>) &amp;&amp;
<name><name>rr</name>-&gt;<name>content_type</name></name> &amp;&amp; <call><name>strncmp</name><argument_list>(<argument><expr><name><name>rr</name>-&gt;<name>content_type</name></name></expr></argument>, <argument><expr>"text/"</expr></argument>, <argument><expr>5</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><name>error_fmt</name> = "unable to include potential exec \"%s\" in parsed "
"file %s, content type not text/*"</expr>;</expr_stmt>
}</block></then></if>
<if>if <condition>(<expr><name>rr</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>ap_set_module_config</name><argument_list>(<argument><expr><name><name>rr</name>-&gt;<name>request_config</name></name></expr></argument>, <argument><expr>&amp;<name>include_module</name></expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<if>if <condition>(<expr>!<name>error_fmt</name> &amp;&amp; ((<name>status</name> = <call><name>ap_run_sub_req</name><argument_list>(<argument><expr><name>rr</name></expr></argument>)</argument_list></call>))</expr>)</condition><then> <block>{
<expr_stmt><expr><name>error_fmt</name> = "unable to include \"%s\" in parsed file %s, subrequest returned %d"</expr>;</expr_stmt>
}</block></then></if>
<if>if <condition>(<expr><name>error_fmt</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>ap_log_rerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_ERR</name></expr></argument>, <argument><expr><name>rv</name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><name>error_fmt</name></expr></argument>, <argument><expr><name>tag_val</name></expr></argument>,
<argument><expr><name><name>r</name>-&gt;<name>filename</name></name></expr></argument>, <argument><expr><name>status</name> ? <name>status</name> : <name>rr</name> ? <name><name>rr</name>-&gt;<name>status</name></name> : 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>last_error</name></expr>)</condition><then> <block>{
<break>break;</break>
}</block></then></if>
<expr_stmt><expr><name>last_error</name> = <name>error_fmt</name></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr><name>last_error</name> = <name>NULL</name></expr>;</expr_stmt>
}</block></else></if>
}</block></while>
<if>if <condition>(<expr><name>last_error</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>SSI_CREATE_ERROR_BUCKET</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>f</name></expr></argument>, <argument><expr><name>bb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<return>return <expr><name>APR_SUCCESS</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>apr_status_t</name></type> <name>handle_echo</name><parameter_list>(<param><decl><type><name>include_ctx_t</name> *</type><name>ctx</name></decl></param>, <param><decl><type><name>ap_filter_t</name> *</type><name>f</name></decl></param>,
<param><decl><type><name>apr_bucket_brigade</name> *</type><name>bb</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>encoding</name> <init>= <expr>"entity"</expr></init>, *<name>decoding</name> <init>= <expr>"none"</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>request_rec</name> *</type><name>r</name> <init>= <expr><name><name>f</name>-&gt;<name>r</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>error</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr>!<name><name>ctx</name>-&gt;<name>argc</name></name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>ap_log_rerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>,
<argument><expr>(<name><name>ctx</name>-&gt;<name>flags</name></name> &amp; <name>SSI_FLAG_PRINTING</name>)
? <name>APLOG_ERR</name> : <name>APLOG_WARNING</name></expr></argument>,
<argument><expr>0</expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>01343</expr></argument>)</argument_list></call>
"missing argument for echo element in %s"</expr></argument>,
<argument><expr><name><name>r</name>-&gt;<name>filename</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<if>if <condition>(<expr>!(<name><name>ctx</name>-&gt;<name>flags</name></name> &amp; <name>SSI_FLAG_PRINTING</name>)</expr>)</condition><then> <block>{
<return>return <expr><name>APR_SUCCESS</name></expr>;</return>
}</block></then></if>
<if>if <condition>(<expr>!<name><name>ctx</name>-&gt;<name>argc</name></name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>SSI_CREATE_ERROR_BUCKET</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>f</name></expr></argument>, <argument><expr><name>bb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>APR_SUCCESS</name></expr>;</return>
}</block></then></if>
<while>while <condition>(<expr>1</expr>)</condition> <block>{
<decl_stmt><decl><type><name>char</name> *</type><name>tag</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>tag_val</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>ap_ssi_get_tag_and_value</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr>&amp;<name>tag</name></expr></argument>, <argument><expr>&amp;<name>tag_val</name></expr></argument>, <argument><expr><name>SSI_VALUE_DECODED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>tag</name> || !<name>tag_val</name></expr>)</condition><then> <block>{
<break>break;</break>
}</block></then></if>
<if>if <condition>(<expr>!<call><name>strcmp</name><argument_list>(<argument><expr><name>tag</name></expr></argument>, <argument><expr>"var"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>val</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>echo_text</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>apr_size_t</name></type> <name>e_len</name></decl>;</decl_stmt>
<expr_stmt><expr><name>val</name> = <call><name>get_include_var</name><argument_list>(<argument><expr><call><name>ap_ssi_parse_string</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>tag_val</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
<argument><expr>0</expr></argument>, <argument><expr><name>SSI_EXPAND_DROP_NAME</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>val</name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>char</name> *</type><name>last</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>e</name></decl>, *<decl><type ref="prev"/><name>d</name></decl>, *<decl><type ref="prev"/><name>token</name></decl>;</decl_stmt>
<expr_stmt><expr><name>echo_text</name> = <name>val</name></expr>;</expr_stmt>
<expr_stmt><expr><name>d</name> = <call><name>apr_pstrdup</name><argument_list>(<argument><expr><name><name>ctx</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>decoding</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>token</name> = <call><name>apr_strtok</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr>", \t"</expr></argument>, <argument><expr>&amp;<name>last</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<while>while <condition>(<expr><name>token</name></expr>)</condition> <block>{
<if>if <condition>(<expr>!<call><name>strcasecmp</name><argument_list>(<argument><expr><name>token</name></expr></argument>, <argument><expr>"none"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
}</block></then> <else>else <if>if <condition>(<expr>!<call><name>strcasecmp</name><argument_list>(<argument><expr><name>token</name></expr></argument>, <argument><expr>"url"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>char</name> *</type><name>buf</name> <init>= <expr><call><name>apr_pstrdup</name><argument_list>(<argument><expr><name><name>ctx</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>echo_text</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>ap_unescape_url</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>echo_text</name> = <name>buf</name></expr>;</expr_stmt>
}</block></then> <else>else <if>if <condition>(<expr>!<call><name>strcasecmp</name><argument_list>(<argument><expr><name>token</name></expr></argument>, <argument><expr>"urlencoded"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>char</name> *</type><name>buf</name> <init>= <expr><call><name>apr_pstrdup</name><argument_list>(<argument><expr><name><name>ctx</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>echo_text</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>ap_unescape_urlencoded</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>echo_text</name> = <name>buf</name></expr>;</expr_stmt>
}</block></then> <else>else <if>if <condition>(<expr>!<call><name>strcasecmp</name><argument_list>(<argument><expr><name>token</name></expr></argument>, <argument><expr>"entity"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>char</name> *</type><name>buf</name> <init>= <expr><call><name>apr_pstrdup</name><argument_list>(<argument><expr><name><name>ctx</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>echo_text</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>decodehtml</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>echo_text</name> = <name>buf</name></expr>;</expr_stmt>
}</block></then> <else>else <if>if <condition>(<expr>!<call><name>strcasecmp</name><argument_list>(<argument><expr><name>token</name></expr></argument>, <argument><expr>"base64"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><name>echo_text</name> = <call><name>ap_pbase64decode</name><argument_list>(<argument><expr><name><name>ctx</name>-&gt;<name>dpool</name></name></expr></argument>, <argument><expr><name>echo_text</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr><call><name>ap_log_rerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_ERR</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>01344</expr></argument>)</argument_list></call> "unknown value "
"\"%s\" to parameter \"decoding\" of tag echo in "
"%s"</expr></argument>, <argument><expr><name>token</name></expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>filename</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SSI_CREATE_ERROR_BUCKET</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>f</name></expr></argument>, <argument><expr><name>bb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>error</name> = 1</expr>;</expr_stmt>
<break>break;</break>
}</block></else></if></else></if></else></if></else></if></else></if>
<expr_stmt><expr><name>token</name> = <call><name>apr_strtok</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr>", \t"</expr></argument>, <argument><expr>&amp;<name>last</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></while>
<expr_stmt><expr><name>e</name> = <call><name>apr_pstrdup</name><argument_list>(<argument><expr><name><name>ctx</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>encoding</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>token</name> = <call><name>apr_strtok</name><argument_list>(<argument><expr><name>e</name></expr></argument>, <argument><expr>", \t"</expr></argument>, <argument><expr>&amp;<name>last</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<while>while <condition>(<expr><name>token</name></expr>)</condition> <block>{
<if>if <condition>(<expr>!<call><name>strcasecmp</name><argument_list>(<argument><expr><name>token</name></expr></argument>, <argument><expr>"none"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
}</block></then> <else>else <if>if <condition>(<expr>!<call><name>strcasecmp</name><argument_list>(<argument><expr><name>token</name></expr></argument>, <argument><expr>"url"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><name>echo_text</name> = <call><name>ap_escape_uri</name><argument_list>(<argument><expr><name><name>ctx</name>-&gt;<name>dpool</name></name></expr></argument>, <argument><expr><name>echo_text</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else <if>if <condition>(<expr>!<call><name>strcasecmp</name><argument_list>(<argument><expr><name>token</name></expr></argument>, <argument><expr>"urlencoded"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><name>echo_text</name> = <call><name>ap_escape_urlencoded</name><argument_list>(<argument><expr><name><name>ctx</name>-&gt;<name>dpool</name></name></expr></argument>, <argument><expr><name>echo_text</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else <if>if <condition>(<expr>!<call><name>strcasecmp</name><argument_list>(<argument><expr><name>token</name></expr></argument>, <argument><expr>"entity"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><name>echo_text</name> = <call><name>ap_escape_html2</name><argument_list>(<argument><expr><name><name>ctx</name>-&gt;<name>dpool</name></name></expr></argument>, <argument><expr><name>echo_text</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else <if>if <condition>(<expr>!<call><name>strcasecmp</name><argument_list>(<argument><expr><name>token</name></expr></argument>, <argument><expr>"base64"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>char</name> *</type><name>buf</name></decl>;</decl_stmt>
<expr_stmt><expr><name>buf</name> = <call><name>ap_pbase64encode</name><argument_list>(<argument><expr><name><name>ctx</name>-&gt;<name>dpool</name></name></expr></argument>, <argument><expr>(<name>char</name> *)<name>echo_text</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>echo_text</name> = <name>buf</name></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr><call><name>ap_log_rerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_ERR</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>01345</expr></argument>)</argument_list></call> "unknown value "
"\"%s\" to parameter \"encoding\" of tag echo in "
"%s"</expr></argument>, <argument><expr><name>token</name></expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>filename</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SSI_CREATE_ERROR_BUCKET</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>f</name></expr></argument>, <argument><expr><name>bb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>error</name> = 1</expr>;</expr_stmt>
<break>break;</break>
}</block></else></if></else></if></else></if></else></if></else></if>
<expr_stmt><expr><name>token</name> = <call><name>apr_strtok</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr>", \t"</expr></argument>, <argument><expr>&amp;<name>last</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></while>
<expr_stmt><expr><name>e_len</name> = <call><name>strlen</name><argument_list>(<argument><expr><name>echo_text</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr><name>echo_text</name> = <name><name>ctx</name>-&gt;<name>intern</name>-&gt;<name>undefined_echo</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>e_len</name> = <name><name>ctx</name>-&gt;<name>intern</name>-&gt;<name>undefined_echo_len</name></name></expr>;</expr_stmt>
}</block></else></if>
<if>if <condition>(<expr><name>error</name></expr>)</condition><then> <block>{
<break>break;</break>
}</block></then></if>
<expr_stmt><expr><call><name>APR_BRIGADE_INSERT_TAIL</name><argument_list>(<argument><expr><name>bb</name></expr></argument>, <argument><expr><call><name>apr_bucket_pool_create</name><argument_list>(
<argument><expr><call><name>apr_pmemdup</name><argument_list>(<argument><expr><name><name>ctx</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>echo_text</name></expr></argument>, <argument><expr><name>e_len</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>e_len</name></expr></argument>, <argument><expr><name><name>ctx</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name><name>f</name>-&gt;<name>c</name>-&gt;<name>bucket_alloc</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else <if>if <condition>(<expr>!<call><name>strcmp</name><argument_list>(<argument><expr><name>tag</name></expr></argument>, <argument><expr>"decoding"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><name>decoding</name> = <name>tag_val</name></expr>;</expr_stmt>
}</block></then> <else>else <if>if <condition>(<expr>!<call><name>strcmp</name><argument_list>(<argument><expr><name>tag</name></expr></argument>, <argument><expr>"encoding"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><name>encoding</name> = <name>tag_val</name></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr><call><name>ap_log_rerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_ERR</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>01346</expr></argument>)</argument_list></call> "unknown parameter "
"\"%s\" in tag echo of %s"</expr></argument>, <argument><expr><name>tag</name></expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>filename</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SSI_CREATE_ERROR_BUCKET</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>f</name></expr></argument>, <argument><expr><name>bb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
}</block></else></if></else></if></else></if>
}</block></while>
<return>return <expr><name>APR_SUCCESS</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>apr_status_t</name></type> <name>handle_config</name><parameter_list>(<param><decl><type><name>include_ctx_t</name> *</type><name>ctx</name></decl></param>, <param><decl><type><name>ap_filter_t</name> *</type><name>f</name></decl></param>,
<param><decl><type><name>apr_bucket_brigade</name> *</type><name>bb</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>request_rec</name> *</type><name>r</name> <init>= <expr><name><name>f</name>-&gt;<name>r</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>apr_table_t</name> *</type><name>env</name> <init>= <expr><name><name>r</name>-&gt;<name>subprocess_env</name></name></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr>!<name><name>ctx</name>-&gt;<name>argc</name></name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>ap_log_rerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>,
<argument><expr>(<name><name>ctx</name>-&gt;<name>flags</name></name> &amp; <name>SSI_FLAG_PRINTING</name>)
? <name>APLOG_ERR</name> : <name>APLOG_WARNING</name></expr></argument>,
<argument><expr>0</expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>01347</expr></argument>)</argument_list></call>
"missing argument for config element in %s"</expr></argument>,
<argument><expr><name><name>r</name>-&gt;<name>filename</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<if>if <condition>(<expr>!(<name><name>ctx</name>-&gt;<name>flags</name></name> &amp; <name>SSI_FLAG_PRINTING</name>)</expr>)</condition><then> <block>{
<return>return <expr><name>APR_SUCCESS</name></expr>;</return>
}</block></then></if>
<if>if <condition>(<expr>!<name><name>ctx</name>-&gt;<name>argc</name></name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>SSI_CREATE_ERROR_BUCKET</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>f</name></expr></argument>, <argument><expr><name>bb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>APR_SUCCESS</name></expr>;</return>
}</block></then></if>
<while>while <condition>(<expr>1</expr>)</condition> <block>{
<decl_stmt><decl><type><name>char</name> *</type><name>tag</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>tag_val</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>ap_ssi_get_tag_and_value</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr>&amp;<name>tag</name></expr></argument>, <argument><expr>&amp;<name>tag_val</name></expr></argument>, <argument><expr><name>SSI_VALUE_RAW</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>tag</name> || !<name>tag_val</name></expr>)</condition><then> <block>{
<break>break;</break>
}</block></then></if>
<if>if <condition>(<expr>!<call><name>strcmp</name><argument_list>(<argument><expr><name>tag</name></expr></argument>, <argument><expr>"errmsg"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>ctx</name>-&gt;<name>error_str</name></name> = <call><name>ap_ssi_parse_string</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>tag_val</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr>0</expr></argument>,
<argument><expr><name>SSI_EXPAND_DROP_NAME</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else <if>if <condition>(<expr>!<call><name>strcmp</name><argument_list>(<argument><expr><name>tag</name></expr></argument>, <argument><expr>"echomsg"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>ctx</name>-&gt;<name>intern</name>-&gt;<name>undefined_echo</name></name> =
<call><name>ap_ssi_parse_string</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>tag_val</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr>0</expr></argument>,<argument><expr><name>SSI_EXPAND_DROP_NAME</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ctx</name>-&gt;<name>intern</name>-&gt;<name>undefined_echo_len</name></name>=<call><name>strlen</name><argument_list>(<argument><expr><name><name>ctx</name>-&gt;<name>intern</name>-&gt;<name>undefined_echo</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else <if>if <condition>(<expr>!<call><name>strcmp</name><argument_list>(<argument><expr><name>tag</name></expr></argument>, <argument><expr>"timefmt"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>apr_time_t</name></type> <name>date</name> <init>= <expr><name><name>r</name>-&gt;<name>request_time</name></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>ctx</name>-&gt;<name>time_str</name></name> = <call><name>ap_ssi_parse_string</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>tag_val</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr>0</expr></argument>,
<argument><expr><name>SSI_EXPAND_DROP_NAME</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>apr_table_setn</name><argument_list>(<argument><expr><name>env</name></expr></argument>, <argument><expr>"DATE_LOCAL"</expr></argument>, <argument><expr><call><name>ap_ht_time</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>date</name></expr></argument>,
<argument><expr><name><name>ctx</name>-&gt;<name>time_str</name></name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>apr_table_setn</name><argument_list>(<argument><expr><name>env</name></expr></argument>, <argument><expr>"DATE_GMT"</expr></argument>, <argument><expr><call><name>ap_ht_time</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>date</name></expr></argument>,
<argument><expr><name><name>ctx</name>-&gt;<name>time_str</name></name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>apr_table_setn</name><argument_list>(<argument><expr><name>env</name></expr></argument>, <argument><expr>"LAST_MODIFIED"</expr></argument>,
<argument><expr><call><name>ap_ht_time</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>finfo</name>.<name>mtime</name></name></expr></argument>,
<argument><expr><name><name>ctx</name>-&gt;<name>time_str</name></name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else <if>if <condition>(<expr>!<call><name>strcmp</name><argument_list>(<argument><expr><name>tag</name></expr></argument>, <argument><expr>"sizefmt"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>char</name> *</type><name>parsed_string</name></decl>;</decl_stmt>
<expr_stmt><expr><name>parsed_string</name> = <call><name>ap_ssi_parse_string</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>tag_val</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr>0</expr></argument>,
<argument><expr><name>SSI_EXPAND_DROP_NAME</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<call><name>strcmp</name><argument_list>(<argument><expr><name>parsed_string</name></expr></argument>, <argument><expr>"bytes"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>ctx</name>-&gt;<name>flags</name></name> |= <name>SSI_FLAG_SIZE_IN_BYTES</name></expr>;</expr_stmt>
}</block></then> <else>else <if>if <condition>(<expr>!<call><name>strcmp</name><argument_list>(<argument><expr><name>parsed_string</name></expr></argument>, <argument><expr>"abbrev"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>ctx</name>-&gt;<name>flags</name></name> &amp;= <name>SSI_FLAG_SIZE_ABBREV</name></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr><call><name>ap_log_rerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_ERR</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>01348</expr></argument>)</argument_list></call> "unknown value "
"\"%s\" to parameter \"sizefmt\" of tag config "
"in %s"</expr></argument>, <argument><expr><name>parsed_string</name></expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>filename</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SSI_CREATE_ERROR_BUCKET</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>f</name></expr></argument>, <argument><expr><name>bb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
}</block></else></if></else></if>
}</block></then> <else>else <block>{
<expr_stmt><expr><call><name>ap_log_rerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_ERR</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>01349</expr></argument>)</argument_list></call> "unknown parameter "
"\"%s\" to tag config in %s"</expr></argument>, <argument><expr><name>tag</name></expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>filename</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SSI_CREATE_ERROR_BUCKET</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>f</name></expr></argument>, <argument><expr><name>bb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
}</block></else></if></else></if></else></if></else></if>
}</block></while>
<return>return <expr><name>APR_SUCCESS</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>apr_status_t</name></type> <name>handle_fsize</name><parameter_list>(<param><decl><type><name>include_ctx_t</name> *</type><name>ctx</name></decl></param>, <param><decl><type><name>ap_filter_t</name> *</type><name>f</name></decl></param>,
<param><decl><type><name>apr_bucket_brigade</name> *</type><name>bb</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>request_rec</name> *</type><name>r</name> <init>= <expr><name><name>f</name>-&gt;<name>r</name></name></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr>!<name><name>ctx</name>-&gt;<name>argc</name></name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>ap_log_rerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>,
<argument><expr>(<name><name>ctx</name>-&gt;<name>flags</name></name> &amp; <name>SSI_FLAG_PRINTING</name>)
? <name>APLOG_ERR</name> : <name>APLOG_WARNING</name></expr></argument>,
<argument><expr>0</expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>01350</expr></argument>)</argument_list></call>
"missing argument for fsize element in %s"</expr></argument>,
<argument><expr><name><name>r</name>-&gt;<name>filename</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<if>if <condition>(<expr>!(<name><name>ctx</name>-&gt;<name>flags</name></name> &amp; <name>SSI_FLAG_PRINTING</name>)</expr>)</condition><then> <block>{
<return>return <expr><name>APR_SUCCESS</name></expr>;</return>
}</block></then></if>
<if>if <condition>(<expr>!<name><name>ctx</name>-&gt;<name>argc</name></name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>SSI_CREATE_ERROR_BUCKET</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>f</name></expr></argument>, <argument><expr><name>bb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>APR_SUCCESS</name></expr>;</return>
}</block></then></if>
<while>while <condition>(<expr>1</expr>)</condition> <block>{
<decl_stmt><decl><type><name>char</name> *</type><name>tag</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>tag_val</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>apr_finfo_t</name></type> <name>finfo</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>parsed_string</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>ap_ssi_get_tag_and_value</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr>&amp;<name>tag</name></expr></argument>, <argument><expr>&amp;<name>tag_val</name></expr></argument>, <argument><expr><name>SSI_VALUE_DECODED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>tag</name> || !<name>tag_val</name></expr>)</condition><then> <block>{
<break>break;</break>
}</block></then></if>
<expr_stmt><expr><name>parsed_string</name> = <call><name>ap_ssi_parse_string</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>tag_val</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr>0</expr></argument>,
<argument><expr><name>SSI_EXPAND_DROP_NAME</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<call><name>find_file</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr>"fsize"</expr></argument>, <argument><expr><name>tag</name></expr></argument>, <argument><expr><name>parsed_string</name></expr></argument>, <argument><expr>&amp;<name>finfo</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>char</name> *</type><name>buf</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>apr_size_t</name></type> <name>len</name></decl>;</decl_stmt>
<if>if <condition>(<expr>!(<name><name>ctx</name>-&gt;<name>flags</name></name> &amp; <name>SSI_FLAG_SIZE_IN_BYTES</name>)</expr>)</condition><then> <block>{
<expr_stmt><expr><name>buf</name> = <call><name>apr_strfsize</name><argument_list>(<argument><expr><name><name>finfo</name>.<name>size</name></name></expr></argument>, <argument><expr><call><name>apr_palloc</name><argument_list>(<argument><expr><name><name>ctx</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr>5</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>len</name> = 4</expr>;</expr_stmt>
}</block></then> <else>else <block>{
<decl_stmt><decl><type><name>apr_size_t</name></type> <name>l</name></decl>, <decl><type ref="prev"/><name>x</name></decl>, <decl><type ref="prev"/><name>pos</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>tmp</name></decl>;</decl_stmt>
<expr_stmt><expr><name>tmp</name> = <call><name>apr_psprintf</name><argument_list>(<argument><expr><name><name>ctx</name>-&gt;<name>dpool</name></name></expr></argument>, <argument><expr>"%" <name>APR_OFF_T_FMT</name></expr></argument>, <argument><expr><name><name>finfo</name>.<name>size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>len</name> = <name>l</name> = <call><name>strlen</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for (<init><expr><name>x</name> = 0</expr>;</init> <condition><expr><name>x</name> &lt; <name>l</name></expr>;</condition> <incr><expr>++<name>x</name></expr></incr>) <block>{
<if>if <condition>(<expr><name>x</name> &amp;&amp; !((<name>l</name> - <name>x</name>) % 3)</expr>)</condition><then> <block>{
<expr_stmt><expr>++<name>len</name></expr>;</expr_stmt>
}</block></then></if>
}</block></for>
<if>if <condition>(<expr><name>len</name> == <name>l</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>buf</name> = <call><name>apr_pstrmemdup</name><argument_list>(<argument><expr><name><name>ctx</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>tmp</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr><name>buf</name> = <call><name>apr_palloc</name><argument_list>(<argument><expr><name><name>ctx</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for (<init><expr><name>pos</name> = <name>x</name> = 0</expr>;</init> <condition><expr><name>x</name> &lt; <name>l</name></expr>;</condition> <incr><expr>++<name>x</name></expr></incr>) <block>{
<if>if <condition>(<expr><name>x</name> &amp;&amp; !((<name>l</name> - <name>x</name>) % 3)</expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>buf</name><index>[<expr><name>pos</name>++</expr>]</index></name> = ','</expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><name><name>buf</name><index>[<expr><name>pos</name>++</expr>]</index></name> = <name><name>tmp</name><index>[<expr><name>x</name></expr>]</index></name></expr>;</expr_stmt>
}</block></for>
}</block></else></if>
}</block></else></if>
<expr_stmt><expr><call><name>APR_BRIGADE_INSERT_TAIL</name><argument_list>(<argument><expr><name>bb</name></expr></argument>, <argument><expr><call><name>apr_bucket_pool_create</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>len</name></expr></argument>,
<argument><expr><name><name>ctx</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name><name>f</name>-&gt;<name>c</name>-&gt;<name>bucket_alloc</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr><call><name>SSI_CREATE_ERROR_BUCKET</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>f</name></expr></argument>, <argument><expr><name>bb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
}</block></else></if>
}</block></while>
<return>return <expr><name>APR_SUCCESS</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>apr_status_t</name></type> <name>handle_flastmod</name><parameter_list>(<param><decl><type><name>include_ctx_t</name> *</type><name>ctx</name></decl></param>, <param><decl><type><name>ap_filter_t</name> *</type><name>f</name></decl></param>,
<param><decl><type><name>apr_bucket_brigade</name> *</type><name>bb</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>request_rec</name> *</type><name>r</name> <init>= <expr><name><name>f</name>-&gt;<name>r</name></name></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr>!<name><name>ctx</name>-&gt;<name>argc</name></name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>ap_log_rerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>,
<argument><expr>(<name><name>ctx</name>-&gt;<name>flags</name></name> &amp; <name>SSI_FLAG_PRINTING</name>)
? <name>APLOG_ERR</name> : <name>APLOG_WARNING</name></expr></argument>,
<argument><expr>0</expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>01351</expr></argument>)</argument_list></call>
"missing argument for flastmod element in %s"</expr></argument>,
<argument><expr><name><name>r</name>-&gt;<name>filename</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<if>if <condition>(<expr>!(<name><name>ctx</name>-&gt;<name>flags</name></name> &amp; <name>SSI_FLAG_PRINTING</name>)</expr>)</condition><then> <block>{
<return>return <expr><name>APR_SUCCESS</name></expr>;</return>
}</block></then></if>
<if>if <condition>(<expr>!<name><name>ctx</name>-&gt;<name>argc</name></name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>SSI_CREATE_ERROR_BUCKET</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>f</name></expr></argument>, <argument><expr><name>bb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>APR_SUCCESS</name></expr>;</return>
}</block></then></if>
<while>while <condition>(<expr>1</expr>)</condition> <block>{
<decl_stmt><decl><type><name>char</name> *</type><name>tag</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>tag_val</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>apr_finfo_t</name></type> <name>finfo</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>parsed_string</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>ap_ssi_get_tag_and_value</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr>&amp;<name>tag</name></expr></argument>, <argument><expr>&amp;<name>tag_val</name></expr></argument>, <argument><expr><name>SSI_VALUE_DECODED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>tag</name> || !<name>tag_val</name></expr>)</condition><then> <block>{
<break>break;</break>
}</block></then></if>
<expr_stmt><expr><name>parsed_string</name> = <call><name>ap_ssi_parse_string</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>tag_val</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr>0</expr></argument>,
<argument><expr><name>SSI_EXPAND_DROP_NAME</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<call><name>find_file</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr>"flastmod"</expr></argument>, <argument><expr><name>tag</name></expr></argument>, <argument><expr><name>parsed_string</name></expr></argument>, <argument><expr>&amp;<name>finfo</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>char</name> *</type><name>t_val</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>apr_size_t</name></type> <name>t_len</name></decl>;</decl_stmt>
<expr_stmt><expr><name>t_val</name> = <call><name>ap_ht_time</name><argument_list>(<argument><expr><name><name>ctx</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name><name>finfo</name>.<name>mtime</name></name></expr></argument>, <argument><expr><name><name>ctx</name>-&gt;<name>time_str</name></name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>t_len</name> = <call><name>strlen</name><argument_list>(<argument><expr><name>t_val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>APR_BRIGADE_INSERT_TAIL</name><argument_list>(<argument><expr><name>bb</name></expr></argument>, <argument><expr><call><name>apr_bucket_pool_create</name><argument_list>(<argument><expr><name>t_val</name></expr></argument>, <argument><expr><name>t_len</name></expr></argument>,
<argument><expr><name><name>ctx</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name><name>f</name>-&gt;<name>c</name>-&gt;<name>bucket_alloc</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr><call><name>SSI_CREATE_ERROR_BUCKET</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>f</name></expr></argument>, <argument><expr><name>bb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
}</block></else></if>
}</block></while>
<return>return <expr><name>APR_SUCCESS</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>apr_status_t</name></type> <name>handle_if</name><parameter_list>(<param><decl><type><name>include_ctx_t</name> *</type><name>ctx</name></decl></param>, <param><decl><type><name>ap_filter_t</name> *</type><name>f</name></decl></param>,
<param><decl><type><name>apr_bucket_brigade</name> *</type><name>bb</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>char</name> *</type><name>tag</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>expr</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>request_rec</name> *</type><name>r</name> <init>= <expr><name><name>f</name>-&gt;<name>r</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>expr_ret</name></decl>, <decl><type ref="prev"/><name>was_error</name></decl>;</decl_stmt>
<if>if <condition>(<expr><name><name>ctx</name>-&gt;<name>argc</name></name> != 1</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>ap_log_rerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>,
<argument><expr>(<name><name>ctx</name>-&gt;<name>flags</name></name> &amp; <name>SSI_FLAG_PRINTING</name>)
? <name>APLOG_ERR</name> : <name>APLOG_WARNING</name></expr></argument>,
<argument><expr>0</expr></argument>, <argument><expr><name>r</name></expr></argument>,
<argument><expr>(<name><name>ctx</name>-&gt;<name>argc</name></name>)
? <call><name>APLOGNO</name><argument_list>(<argument><expr>01352</expr></argument>)</argument_list></call> "too many arguments for if element in %s"
: <call><name>APLOGNO</name><argument_list>(<argument><expr>01353</expr></argument>)</argument_list></call> "missing expr argument for if element in %s"</expr></argument>,
<argument><expr><name><name>r</name>-&gt;<name>filename</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<if>if <condition>(<expr>!(<name><name>ctx</name>-&gt;<name>flags</name></name> &amp; <name>SSI_FLAG_PRINTING</name>)</expr>)</condition><then> <block>{
<expr_stmt><expr>++(<name><name>ctx</name>-&gt;<name>if_nesting_level</name></name>)</expr>;</expr_stmt>
<return>return <expr><name>APR_SUCCESS</name></expr>;</return>
}</block></then></if>
<if>if <condition>(<expr><name><name>ctx</name>-&gt;<name>argc</name></name> != 1</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>SSI_CREATE_ERROR_BUCKET</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>f</name></expr></argument>, <argument><expr><name>bb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>APR_SUCCESS</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><call><name>ap_ssi_get_tag_and_value</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr>&amp;<name>tag</name></expr></argument>, <argument><expr>&amp;<name>expr</name></expr></argument>, <argument><expr><name>SSI_VALUE_RAW</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>tag</name></expr></argument>, <argument><expr>"expr"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>ap_log_rerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_ERR</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>01354</expr></argument>)</argument_list></call> "unknown parameter \"%s\" "
"to tag if in %s"</expr></argument>, <argument><expr><name>tag</name></expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>filename</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SSI_CREATE_ERROR_BUCKET</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>f</name></expr></argument>, <argument><expr><name>bb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>APR_SUCCESS</name></expr>;</return>
}</block></then></if>
<if>if <condition>(<expr>!<name>expr</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>ap_log_rerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_ERR</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>01355</expr></argument>)</argument_list></call> "missing expr value for if "
"element in %s"</expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>filename</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SSI_CREATE_ERROR_BUCKET</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>f</name></expr></argument>, <argument><expr><name>bb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>APR_SUCCESS</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><call><name>DEBUG_PRINTF</name><argument_list>(<argument><expr>(<name>ctx</name>, "**** if expr=\"%s\"\n", <name>expr</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>ctx</name>-&gt;<name>intern</name>-&gt;<name>legacy_expr</name></name></expr>)</condition><then>
<expr_stmt><expr><name>expr_ret</name> = <call><name>parse_expr</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>, <argument><expr>&amp;<name>was_error</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
<else>else
<expr_stmt><expr><name>expr_ret</name> = <call><name>parse_ap_expr</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>, <argument><expr>&amp;<name>was_error</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
<if>if <condition>(<expr><name>was_error</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>SSI_CREATE_ERROR_BUCKET</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>f</name></expr></argument>, <argument><expr><name>bb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>APR_SUCCESS</name></expr>;</return>
}</block></then></if>
<if>if <condition>(<expr><name>expr_ret</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>ctx</name>-&gt;<name>flags</name></name> |= (<name>SSI_FLAG_PRINTING</name> | <name>SSI_FLAG_COND_TRUE</name>)</expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr><name><name>ctx</name>-&gt;<name>flags</name></name> &amp;= <name>SSI_FLAG_CLEAR_PRINT_COND</name></expr>;</expr_stmt>
}</block></else></if>
<expr_stmt><expr><call><name>DEBUG_DUMP_COND</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr>" if"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ctx</name>-&gt;<name>if_nesting_level</name></name> = 0</expr>;</expr_stmt>
<return>return <expr><name>APR_SUCCESS</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>apr_status_t</name></type> <name>handle_elif</name><parameter_list>(<param><decl><type><name>include_ctx_t</name> *</type><name>ctx</name></decl></param>, <param><decl><type><name>ap_filter_t</name> *</type><name>f</name></decl></param>,
<param><decl><type><name>apr_bucket_brigade</name> *</type><name>bb</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>char</name> *</type><name>tag</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>expr</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>request_rec</name> *</type><name>r</name> <init>= <expr><name><name>f</name>-&gt;<name>r</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>expr_ret</name></decl>, <decl><type ref="prev"/><name>was_error</name></decl>;</decl_stmt>
<if>if <condition>(<expr><name><name>ctx</name>-&gt;<name>argc</name></name> != 1</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>ap_log_rerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>,
<argument><expr>(!(<name><name>ctx</name>-&gt;<name>if_nesting_level</name></name>)) ? <name>APLOG_ERR</name> : <name>APLOG_WARNING</name></expr></argument>,
<argument><expr>0</expr></argument>, <argument><expr><name>r</name></expr></argument>,
<argument><expr>(<name><name>ctx</name>-&gt;<name>argc</name></name>)
? <call><name>APLOGNO</name><argument_list>(<argument><expr>01356</expr></argument>)</argument_list></call> "too many arguments for if element in %s"
: <call><name>APLOGNO</name><argument_list>(<argument><expr>01357</expr></argument>)</argument_list></call> "missing expr argument for if element in %s"</expr></argument>,
<argument><expr><name><name>r</name>-&gt;<name>filename</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<if>if <condition>(<expr><name><name>ctx</name>-&gt;<name>if_nesting_level</name></name></expr>)</condition><then> <block>{
<return>return <expr><name>APR_SUCCESS</name></expr>;</return>
}</block></then></if>
<if>if <condition>(<expr><name><name>ctx</name>-&gt;<name>argc</name></name> != 1</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>SSI_CREATE_ERROR_BUCKET</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>f</name></expr></argument>, <argument><expr><name>bb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>APR_SUCCESS</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><call><name>ap_ssi_get_tag_and_value</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr>&amp;<name>tag</name></expr></argument>, <argument><expr>&amp;<name>expr</name></expr></argument>, <argument><expr><name>SSI_VALUE_RAW</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>tag</name></expr></argument>, <argument><expr>"expr"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>ap_log_rerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_ERR</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>01358</expr></argument>)</argument_list></call> "unknown parameter \"%s\" "
"to tag if in %s"</expr></argument>, <argument><expr><name>tag</name></expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>filename</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SSI_CREATE_ERROR_BUCKET</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>f</name></expr></argument>, <argument><expr><name>bb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>APR_SUCCESS</name></expr>;</return>
}</block></then></if>
<if>if <condition>(<expr>!<name>expr</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>ap_log_rerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_ERR</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>01359</expr></argument>)</argument_list></call> "missing expr in elif "
"statement: %s"</expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>filename</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SSI_CREATE_ERROR_BUCKET</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>f</name></expr></argument>, <argument><expr><name>bb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>APR_SUCCESS</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><call><name>DEBUG_PRINTF</name><argument_list>(<argument><expr>(<name>ctx</name>, "**** elif expr=\"%s\"\n", <name>expr</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>DEBUG_DUMP_COND</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr>" elif"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>ctx</name>-&gt;<name>flags</name></name> &amp; <name>SSI_FLAG_COND_TRUE</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>ctx</name>-&gt;<name>flags</name></name> &amp;= <name>SSI_FLAG_CLEAR_PRINTING</name></expr>;</expr_stmt>
<return>return <expr><name>APR_SUCCESS</name></expr>;</return>
}</block></then></if>
<if>if <condition>(<expr><name><name>ctx</name>-&gt;<name>intern</name>-&gt;<name>legacy_expr</name></name></expr>)</condition><then>
<expr_stmt><expr><name>expr_ret</name> = <call><name>parse_expr</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>, <argument><expr>&amp;<name>was_error</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
<else>else
<expr_stmt><expr><name>expr_ret</name> = <call><name>parse_ap_expr</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>, <argument><expr>&amp;<name>was_error</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
<if>if <condition>(<expr><name>was_error</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>SSI_CREATE_ERROR_BUCKET</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>f</name></expr></argument>, <argument><expr><name>bb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>APR_SUCCESS</name></expr>;</return>
}</block></then></if>
<if>if <condition>(<expr><name>expr_ret</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>ctx</name>-&gt;<name>flags</name></name> |= (<name>SSI_FLAG_PRINTING</name> | <name>SSI_FLAG_COND_TRUE</name>)</expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr><name><name>ctx</name>-&gt;<name>flags</name></name> &amp;= <name>SSI_FLAG_CLEAR_PRINT_COND</name></expr>;</expr_stmt>
}</block></else></if>
<expr_stmt><expr><call><name>DEBUG_DUMP_COND</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr>" elif"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>APR_SUCCESS</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>apr_status_t</name></type> <name>handle_else</name><parameter_list>(<param><decl><type><name>include_ctx_t</name> *</type><name>ctx</name></decl></param>, <param><decl><type><name>ap_filter_t</name> *</type><name>f</name></decl></param>,
<param><decl><type><name>apr_bucket_brigade</name> *</type><name>bb</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>request_rec</name> *</type><name>r</name> <init>= <expr><name><name>f</name>-&gt;<name>r</name></name></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name><name>ctx</name>-&gt;<name>argc</name></name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>ap_log_rerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>,
<argument><expr>(!(<name><name>ctx</name>-&gt;<name>if_nesting_level</name></name>)) ? <name>APLOG_ERR</name> : <name>APLOG_WARNING</name></expr></argument>,
<argument><expr>0</expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>01360</expr></argument>)</argument_list></call>
"else directive does not take tags in %s"</expr></argument>,
<argument><expr><name><name>r</name>-&gt;<name>filename</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<if>if <condition>(<expr><name><name>ctx</name>-&gt;<name>if_nesting_level</name></name></expr>)</condition><then> <block>{
<return>return <expr><name>APR_SUCCESS</name></expr>;</return>
}</block></then></if>
<if>if <condition>(<expr><name><name>ctx</name>-&gt;<name>argc</name></name></expr>)</condition><then> <block>{
<if>if <condition>(<expr><name><name>ctx</name>-&gt;<name>flags</name></name> &amp; <name>SSI_FLAG_PRINTING</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>SSI_CREATE_ERROR_BUCKET</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>f</name></expr></argument>, <argument><expr><name>bb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<return>return <expr><name>APR_SUCCESS</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><call><name>DEBUG_DUMP_COND</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr>" else"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>ctx</name>-&gt;<name>flags</name></name> &amp; <name>SSI_FLAG_COND_TRUE</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>ctx</name>-&gt;<name>flags</name></name> &amp;= <name>SSI_FLAG_CLEAR_PRINTING</name></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr><name><name>ctx</name>-&gt;<name>flags</name></name> |= (<name>SSI_FLAG_PRINTING</name> | <name>SSI_FLAG_COND_TRUE</name>)</expr>;</expr_stmt>
}</block></else></if>
<return>return <expr><name>APR_SUCCESS</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>apr_status_t</name></type> <name>handle_endif</name><parameter_list>(<param><decl><type><name>include_ctx_t</name> *</type><name>ctx</name></decl></param>, <param><decl><type><name>ap_filter_t</name> *</type><name>f</name></decl></param>,
<param><decl><type><name>apr_bucket_brigade</name> *</type><name>bb</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>request_rec</name> *</type><name>r</name> <init>= <expr><name><name>f</name>-&gt;<name>r</name></name></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name><name>ctx</name>-&gt;<name>argc</name></name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>ap_log_rerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>,
<argument><expr>(!(<name><name>ctx</name>-&gt;<name>if_nesting_level</name></name>)) ? <name>APLOG_ERR</name> : <name>APLOG_WARNING</name></expr></argument>,
<argument><expr>0</expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>01361</expr></argument>)</argument_list></call>
"endif directive does not take tags in %s"</expr></argument>,
<argument><expr><name><name>r</name>-&gt;<name>filename</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<if>if <condition>(<expr><name><name>ctx</name>-&gt;<name>if_nesting_level</name></name></expr>)</condition><then> <block>{
<expr_stmt><expr>--(<name><name>ctx</name>-&gt;<name>if_nesting_level</name></name>)</expr>;</expr_stmt>
<return>return <expr><name>APR_SUCCESS</name></expr>;</return>
}</block></then></if>
<if>if <condition>(<expr><name><name>ctx</name>-&gt;<name>argc</name></name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>SSI_CREATE_ERROR_BUCKET</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>f</name></expr></argument>, <argument><expr><name>bb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>APR_SUCCESS</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><call><name>DEBUG_DUMP_COND</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr>"endif"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ctx</name>-&gt;<name>flags</name></name> |= (<name>SSI_FLAG_PRINTING</name> | <name>SSI_FLAG_COND_TRUE</name>)</expr>;</expr_stmt>
<return>return <expr><name>APR_SUCCESS</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>apr_status_t</name></type> <name>handle_set</name><parameter_list>(<param><decl><type><name>include_ctx_t</name> *</type><name>ctx</name></decl></param>, <param><decl><type><name>ap_filter_t</name> *</type><name>f</name></decl></param>,
<param><decl><type><name>apr_bucket_brigade</name> *</type><name>bb</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>encoding</name> <init>= <expr>"none"</expr></init>, *<name>decoding</name> <init>= <expr>"none"</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>var</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>request_rec</name> *</type><name>r</name> <init>= <expr><name><name>f</name>-&gt;<name>r</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>request_rec</name> *</type><name>sub</name> <init>= <expr><name><name>r</name>-&gt;<name/></name>main</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>p</name> <init>= <expr><name><name>r</name>-&gt;<name>pool</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>error</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name><name>ctx</name>-&gt;<name>argc</name></name> &lt; 2</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>ap_log_rerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>,
<argument><expr>(<name><name>ctx</name>-&gt;<name>flags</name></name> &amp; <name>SSI_FLAG_PRINTING</name>)
? <name>APLOG_ERR</name> : <name>APLOG_WARNING</name></expr></argument>,
<argument><expr>0</expr></argument>, <argument><expr><name>r</name></expr></argument>,
<argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>01362</expr></argument>)</argument_list></call> "missing argument for set element in %s"</expr></argument>,
<argument><expr><name><name>r</name>-&gt;<name>filename</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<if>if <condition>(<expr>!(<name><name>ctx</name>-&gt;<name>flags</name></name> &amp; <name>SSI_FLAG_PRINTING</name>)</expr>)</condition><then> <block>{
<return>return <expr><name>APR_SUCCESS</name></expr>;</return>
}</block></then></if>
<if>if <condition>(<expr><name><name>ctx</name>-&gt;<name>argc</name></name> &lt; 2</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>SSI_CREATE_ERROR_BUCKET</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>f</name></expr></argument>, <argument><expr><name>bb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>APR_SUCCESS</name></expr>;</return>
}</block></then></if>
<while>while <condition>(<expr><name>sub</name></expr>)</condition> <block>{
<expr_stmt><expr><name>p</name> = <name><name>sub</name>-&gt;<name>pool</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>sub</name> = <name><name>sub</name>-&gt;<name/></name>main</expr>;</expr_stmt>
}</block></while>
<while>while <condition>(<expr>1</expr>)</condition> <block>{
<decl_stmt><decl><type><name>char</name> *</type><name>tag</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>tag_val</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>ap_ssi_get_tag_and_value</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr>&amp;<name>tag</name></expr></argument>, <argument><expr>&amp;<name>tag_val</name></expr></argument>, <argument><expr><name>SSI_VALUE_RAW</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>tag</name> || !<name>tag_val</name></expr>)</condition><then> <block>{
<break>break;</break>
}</block></then></if>
<if>if <condition>(<expr>!<call><name>strcmp</name><argument_list>(<argument><expr><name>tag</name></expr></argument>, <argument><expr>"var"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>decodehtml</name><argument_list>(<argument><expr><name>tag_val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>var</name> = <call><name>ap_ssi_parse_string</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>tag_val</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr>0</expr></argument>,
<argument><expr><name>SSI_EXPAND_DROP_NAME</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else <if>if <condition>(<expr>!<call><name>strcmp</name><argument_list>(<argument><expr><name>tag</name></expr></argument>, <argument><expr>"decoding"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><name>decoding</name> = <name>tag_val</name></expr>;</expr_stmt>
}</block></then> <else>else <if>if <condition>(<expr>!<call><name>strcmp</name><argument_list>(<argument><expr><name>tag</name></expr></argument>, <argument><expr>"encoding"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><name>encoding</name> = <name>tag_val</name></expr>;</expr_stmt>
}</block></then> <else>else <if>if <condition>(<expr>!<call><name>strcmp</name><argument_list>(<argument><expr><name>tag</name></expr></argument>, <argument><expr>"value"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>char</name> *</type><name>parsed_string</name></decl>;</decl_stmt>
<if>if <condition>(<expr>!<name>var</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>ap_log_rerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_ERR</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>01363</expr></argument>)</argument_list></call> "variable must "
"precede value in set directive in %s"</expr></argument>,
<argument><expr><name><name>r</name>-&gt;<name>filename</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SSI_CREATE_ERROR_BUCKET</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>f</name></expr></argument>, <argument><expr><name>bb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
}</block></then></if>
<expr_stmt><expr><name>parsed_string</name> = <call><name>ap_ssi_parse_string</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>tag_val</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr>0</expr></argument>,
<argument><expr><name>SSI_EXPAND_DROP_NAME</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>parsed_string</name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>char</name> *</type><name>last</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>e</name></decl>, *<decl><type ref="prev"/><name>d</name></decl>, *<decl><type ref="prev"/><name>token</name></decl>;</decl_stmt>
<expr_stmt><expr><name>d</name> = <call><name>apr_pstrdup</name><argument_list>(<argument><expr><name><name>ctx</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>decoding</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>token</name> = <call><name>apr_strtok</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr>", \t"</expr></argument>, <argument><expr>&amp;<name>last</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<while>while <condition>(<expr><name>token</name></expr>)</condition> <block>{
<if>if <condition>(<expr>!<call><name>strcasecmp</name><argument_list>(<argument><expr><name>token</name></expr></argument>, <argument><expr>"none"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
}</block></then> <else>else <if>if <condition>(<expr>!<call><name>strcasecmp</name><argument_list>(<argument><expr><name>token</name></expr></argument>, <argument><expr>"url"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>char</name> *</type><name>buf</name> <init>= <expr><call><name>apr_pstrdup</name><argument_list>(<argument><expr><name><name>ctx</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>parsed_string</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>ap_unescape_url</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>parsed_string</name> = <name>buf</name></expr>;</expr_stmt>
}</block></then> <else>else <if>if <condition>(<expr>!<call><name>strcasecmp</name><argument_list>(<argument><expr><name>token</name></expr></argument>, <argument><expr>"urlencoded"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>char</name> *</type><name>buf</name> <init>= <expr><call><name>apr_pstrdup</name><argument_list>(<argument><expr><name><name>ctx</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>parsed_string</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>ap_unescape_urlencoded</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>parsed_string</name> = <name>buf</name></expr>;</expr_stmt>
}</block></then> <else>else <if>if <condition>(<expr>!<call><name>strcasecmp</name><argument_list>(<argument><expr><name>token</name></expr></argument>, <argument><expr>"entity"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>char</name> *</type><name>buf</name> <init>= <expr><call><name>apr_pstrdup</name><argument_list>(<argument><expr><name><name>ctx</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>parsed_string</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>decodehtml</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>parsed_string</name> = <name>buf</name></expr>;</expr_stmt>
}</block></then> <else>else <if>if <condition>(<expr>!<call><name>strcasecmp</name><argument_list>(<argument><expr><name>token</name></expr></argument>, <argument><expr>"base64"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><name>parsed_string</name> = <call><name>ap_pbase64decode</name><argument_list>(<argument><expr><name><name>ctx</name>-&gt;<name>dpool</name></name></expr></argument>, <argument><expr><name>parsed_string</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr><call><name>ap_log_rerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_ERR</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>01364</expr></argument>)</argument_list></call> "unknown value "
"\"%s\" to parameter \"decoding\" of tag set in "
"%s"</expr></argument>, <argument><expr><name>token</name></expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>filename</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SSI_CREATE_ERROR_BUCKET</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>f</name></expr></argument>, <argument><expr><name>bb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>error</name> = 1</expr>;</expr_stmt>
<break>break;</break>
}</block></else></if></else></if></else></if></else></if></else></if>
<expr_stmt><expr><name>token</name> = <call><name>apr_strtok</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr>", \t"</expr></argument>, <argument><expr>&amp;<name>last</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></while>
<expr_stmt><expr><name>e</name> = <call><name>apr_pstrdup</name><argument_list>(<argument><expr><name><name>ctx</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>encoding</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>token</name> = <call><name>apr_strtok</name><argument_list>(<argument><expr><name>e</name></expr></argument>, <argument><expr>", \t"</expr></argument>, <argument><expr>&amp;<name>last</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<while>while <condition>(<expr><name>token</name></expr>)</condition> <block>{
<if>if <condition>(<expr>!<call><name>strcasecmp</name><argument_list>(<argument><expr><name>token</name></expr></argument>, <argument><expr>"none"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
}</block></then> <else>else <if>if <condition>(<expr>!<call><name>strcasecmp</name><argument_list>(<argument><expr><name>token</name></expr></argument>, <argument><expr>"url"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><name>parsed_string</name> = <call><name>ap_escape_uri</name><argument_list>(<argument><expr><name><name>ctx</name>-&gt;<name>dpool</name></name></expr></argument>, <argument><expr><name>parsed_string</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else <if>if <condition>(<expr>!<call><name>strcasecmp</name><argument_list>(<argument><expr><name>token</name></expr></argument>, <argument><expr>"urlencoded"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><name>parsed_string</name> = <call><name>ap_escape_urlencoded</name><argument_list>(<argument><expr><name><name>ctx</name>-&gt;<name>dpool</name></name></expr></argument>, <argument><expr><name>parsed_string</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else <if>if <condition>(<expr>!<call><name>strcasecmp</name><argument_list>(<argument><expr><name>token</name></expr></argument>, <argument><expr>"entity"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><name>parsed_string</name> = <call><name>ap_escape_html2</name><argument_list>(<argument><expr><name><name>ctx</name>-&gt;<name>dpool</name></name></expr></argument>, <argument><expr><name>parsed_string</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else <if>if <condition>(<expr>!<call><name>strcasecmp</name><argument_list>(<argument><expr><name>token</name></expr></argument>, <argument><expr>"base64"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>char</name> *</type><name>buf</name></decl>;</decl_stmt>
<expr_stmt><expr><name>buf</name> = <call><name>ap_pbase64encode</name><argument_list>(<argument><expr><name><name>ctx</name>-&gt;<name>dpool</name></name></expr></argument>, <argument><expr>(<name>char</name> *)<name>parsed_string</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>parsed_string</name> = <name>buf</name></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr><call><name>ap_log_rerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_ERR</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>01365</expr></argument>)</argument_list></call> "unknown value "
"\"%s\" to parameter \"encoding\" of tag set in "
"%s"</expr></argument>, <argument><expr><name>token</name></expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>filename</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SSI_CREATE_ERROR_BUCKET</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>f</name></expr></argument>, <argument><expr><name>bb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>error</name> = 1</expr>;</expr_stmt>
<break>break;</break>
}</block></else></if></else></if></else></if></else></if></else></if>
<expr_stmt><expr><name>token</name> = <call><name>apr_strtok</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr>", \t"</expr></argument>, <argument><expr>&amp;<name>last</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></while>
}</block></then></if>
<if>if <condition>(<expr><name>error</name></expr>)</condition><then> <block>{
<break>break;</break>
}</block></then></if>
<expr_stmt><expr><call><name>apr_table_setn</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>subprocess_env</name></name></expr></argument>, <argument><expr><call><name>apr_pstrdup</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>var</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name>apr_pstrdup</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>parsed_string</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr><call><name>ap_log_rerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_ERR</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>01366</expr></argument>)</argument_list></call> "Invalid tag for set "
"directive in %s"</expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>filename</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SSI_CREATE_ERROR_BUCKET</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>f</name></expr></argument>, <argument><expr><name>bb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
}</block></else></if></else></if></else></if></else></if>
}</block></while>
<return>return <expr><name>APR_SUCCESS</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>apr_status_t</name></type> <name>handle_printenv</name><parameter_list>(<param><decl><type><name>include_ctx_t</name> *</type><name>ctx</name></decl></param>, <param><decl><type><name>ap_filter_t</name> *</type><name>f</name></decl></param>,
<param><decl><type><name>apr_bucket_brigade</name> *</type><name>bb</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>request_rec</name> *</type><name>r</name> <init>= <expr><name><name>f</name>-&gt;<name>r</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>apr_array_header_t</name> *</type><name>arr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>apr_table_entry_t</name> *</type><name>elts</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<if>if <condition>(<expr><name><name>ctx</name>-&gt;<name>argc</name></name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>ap_log_rerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>,
<argument><expr>(<name><name>ctx</name>-&gt;<name>flags</name></name> &amp; <name>SSI_FLAG_PRINTING</name>)
? <name>APLOG_ERR</name> : <name>APLOG_WARNING</name></expr></argument>,
<argument><expr>0</expr></argument>, <argument><expr><name>r</name></expr></argument>,
<argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>01367</expr></argument>)</argument_list></call> "printenv directive does not take tags in %s"</expr></argument>,
<argument><expr><name><name>r</name>-&gt;<name>filename</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<if>if <condition>(<expr>!(<name><name>ctx</name>-&gt;<name>flags</name></name> &amp; <name>SSI_FLAG_PRINTING</name>)</expr>)</condition><then> <block>{
<return>return <expr><name>APR_SUCCESS</name></expr>;</return>
}</block></then></if>
<if>if <condition>(<expr><name><name>ctx</name>-&gt;<name>argc</name></name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>SSI_CREATE_ERROR_BUCKET</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>f</name></expr></argument>, <argument><expr><name>bb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>APR_SUCCESS</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>arr</name> = <call><name>apr_table_elts</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>subprocess_env</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>elts</name> = (<name>apr_table_entry_t</name> *)<name><name>arr</name>-&gt;<name>elts</name></name></expr>;</expr_stmt>
<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name><name>arr</name>-&gt;<name>nelts</name></name></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>) <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>key_text</name></decl>, *<decl><type ref="prev"/><name>val_text</name></decl>;</decl_stmt>
<expr_stmt><expr><name>key_text</name> = <call><name>ap_escape_html</name><argument_list>(<argument><expr><name><name>ctx</name>-&gt;<name>dpool</name></name></expr></argument>, <argument><expr><name><name>elts</name><index>[<expr><name>i</name></expr>]</index></name>.<name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>val_text</name> = <name><name>elts</name><index>[<expr><name>i</name></expr>]</index></name>.<name>val</name></expr>;</expr_stmt>
<if>if <condition>(<expr><name>val_text</name> == <name>LAZY_VALUE</name></expr>)</condition><then>
<expr_stmt><expr><name>val_text</name> = <call><name>add_include_vars_lazy</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name><name>elts</name><index>[<expr><name>i</name></expr>]</index></name>.<name>key</name></expr></argument>, <argument><expr><name><name>ctx</name>-&gt;<name>time_str</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<expr_stmt><expr><name>val_text</name> = <call><name>ap_escape_html</name><argument_list>(<argument><expr><name><name>ctx</name>-&gt;<name>dpool</name></name></expr></argument>, <argument><expr><name>val_text</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>apr_brigade_putstrs</name><argument_list>(<argument><expr><name>bb</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>key_text</name></expr></argument>, <argument><expr>"="</expr></argument>, <argument><expr><name>val_text</name></expr></argument>, <argument><expr>"\n"</expr></argument>,
<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></for>
<expr_stmt><expr><name><name>ctx</name>-&gt;<name>flush_now</name></name> = 1</expr>;</expr_stmt>
<return>return <expr><name>APR_SUCCESS</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>bndm_t</name> *</type><name>bndm_compile</name><parameter_list>(<param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>n</name></decl></param>, <param><decl><type><name>apr_size_t</name></type> <name>nl</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>x</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>ne</name> <init>= <expr><name>n</name> + <name>nl</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bndm_t</name> *</type><name>t</name> <init>= <expr><call><name>apr_palloc</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>*<name>t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>t</name>-&gt;<name>T</name></name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>sizeof(<name>unsigned</name> <name>int</name>) * 256</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>t</name>-&gt;<name>pattern_len</name></name> = <name>nl</name></expr>;</expr_stmt>
<for>for (<init><expr><name>x</name> = 1</expr>;</init> <condition><expr><name>n</name> &lt; <name>ne</name></expr>;</condition> <incr><expr><name>x</name> &lt;&lt;= 1</expr></incr>) <block>{
<expr_stmt><expr><name><name>t</name>-&gt;<name>T</name><index>[<expr>(<name>unsigned</name> <name>char</name>) *<name>n</name>++</expr>]</index></name> |= <name>x</name></expr>;</expr_stmt>
}</block></for>
<expr_stmt><expr><name><name>t</name>-&gt;<name>x</name></name> = <name>x</name> - 1</expr>;</expr_stmt>
<return>return <expr><name>t</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>apr_size_t</name></type> <name>bndm</name><parameter_list>(<param><decl><type><name>bndm_t</name> *</type><name>t</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>h</name></decl></param>, <param><decl><type><name>apr_size_t</name></type> <name>hl</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>skip</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>he</name></decl>, *<decl><type ref="prev"/><name>p</name></decl>, *<decl><type ref="prev"/><name>pi</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name> *</type><name>T</name></decl>, <decl><type ref="prev"/><name>x</name></decl>, <decl><type ref="prev"/><name>d</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>apr_size_t</name></type> <name>nl</name></decl>;</decl_stmt>
<expr_stmt><expr><name>he</name> = <name>h</name> + <name>hl</name></expr>;</expr_stmt>
<expr_stmt><expr><name>T</name> = <name><name>t</name>-&gt;<name>T</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>x</name> = <name><name>t</name>-&gt;<name>x</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>nl</name> = <name><name>t</name>-&gt;<name>pattern_len</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>pi</name> = <name>h</name> - 1</expr>;</expr_stmt>
<expr_stmt><expr><name>p</name> = <name>pi</name> + <name>nl</name></expr>;</expr_stmt>
<while>while <condition>(<expr><name>p</name> &lt; <name>he</name></expr>)</condition> <block>{
<expr_stmt><expr><name>skip</name> = <name>p</name></expr>;</expr_stmt>
<expr_stmt><expr><name>d</name> = <name>x</name></expr>;</expr_stmt>
<do>do <block>{
<expr_stmt><expr><name>d</name> &amp;= <name><name>T</name><index>[<expr>(<name>unsigned</name> <name>char</name>) *<name>p</name>--</expr>]</index></name></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>d</name></expr>)</condition><then> <block>{
<break>break;</break>
}</block></then></if>
<if>if <condition>(<expr>(<name>d</name> &amp; 1)</expr>)</condition><then> <block>{
<if>if <condition>(<expr><name>p</name> != <name>pi</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>skip</name> = <name>p</name></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<return>return <expr><name>p</name> - <name>h</name> + 1</expr>;</return>
}</block></else></if>
}</block></then></if>
<expr_stmt><expr><name>d</name> &gt;&gt;= 1</expr>;</expr_stmt>
}</block> while <condition>(<expr><name>d</name></expr>)</condition>;</do>
<expr_stmt><expr><name>pi</name> = <name>skip</name></expr>;</expr_stmt>
<expr_stmt><expr><name>p</name> = <name>pi</name> + <name>nl</name></expr>;</expr_stmt>
}</block></while>
<return>return <expr><name>hl</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>apr_size_t</name></type> <name>find_start_sequence</name><parameter_list>(<param><decl><type><name>include_ctx_t</name> *</type><name>ctx</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>data</name></decl></param>,
<param><decl><type><name>apr_size_t</name></type> <name>len</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type>struct <name>ssi_internal_ctx</name> *</type><name>intern</name> <init>= <expr><name><name>ctx</name>-&gt;<name>intern</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>apr_size_t</name></type> <name>slen</name> <init>= <expr><name><name>intern</name>-&gt;<name>start_seq_pat</name>-&gt;<name>pattern_len</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>apr_size_t</name></type> <name>index</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>p</name></decl>, *<decl><type ref="prev"/><name>ep</name></decl>;</decl_stmt>
<if>if <condition>(<expr><name>len</name> &lt; <name>slen</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>p</name> = <name>data</name></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr><name>index</name> = <call><name>bndm</name><argument_list>(<argument><expr><name><name>intern</name>-&gt;<name>start_seq_pat</name></name></expr></argument>, <argument><expr><name>data</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>index</name> &lt; <name>len</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>intern</name>-&gt;<name>state</name></name> = <name>PARSE_DIRECTIVE</name></expr>;</expr_stmt>
<return>return <expr><name>index</name></expr>;</return>
}</block></then> <else>else <block>{
<expr_stmt><expr><name>p</name> = <name>data</name> + <name>len</name> - <name>slen</name> + 1</expr>;</expr_stmt>
}</block></else></if>
}</block></else></if>
<expr_stmt><expr><name>ep</name> = <name>data</name> + <name>len</name></expr>;</expr_stmt>
<do>do <block>{
<while>while <condition>(<expr><name>p</name> &lt; <name>ep</name> &amp;&amp; *<name>p</name> != *<name><name>intern</name>-&gt;<name>start_seq</name></name></expr>)</condition> <block>{
<expr_stmt><expr>++<name>p</name></expr>;</expr_stmt>
}</block></while>
<expr_stmt><expr><name>index</name> = <name>p</name> - <name>data</name></expr>;</expr_stmt>
<if>if <condition>(<expr><name>p</name> &lt; <name>ep</name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>apr_size_t</name></type> <name>pos</name> <init>= <expr>1</expr></init></decl>;</decl_stmt>
<expr_stmt><expr>++<name>p</name></expr>;</expr_stmt>
<while>while <condition>(<expr><name>p</name> &lt; <name>ep</name> &amp;&amp; *<name>p</name> == <name><name>intern</name>-&gt;<name>start_seq</name><index>[<expr><name>pos</name></expr>]</index></name></expr>)</condition> <block>{
<expr_stmt><expr>++<name>p</name></expr>;</expr_stmt>
<expr_stmt><expr>++<name>pos</name></expr>;</expr_stmt>
}</block></while>
<if>if <condition>(<expr><name>p</name> == <name>ep</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>intern</name>-&gt;<name>state</name></name> = <name>PARSE_HEAD</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>intern</name>-&gt;<name>parse_pos</name></name> = <name>pos</name></expr>;</expr_stmt>
<return>return <expr><name>index</name></expr>;</return>
}</block></then></if>
}</block></then></if>
<expr_stmt><expr><name>p</name> = <name>data</name> + <name>index</name> + 1</expr>;</expr_stmt>
}</block> while <condition>(<expr><name>p</name> &lt; <name>ep</name></expr>)</condition>;</do>
<return>return <expr><name>len</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>apr_size_t</name></type> <name>find_partial_start_sequence</name><parameter_list>(<param><decl><type><name>include_ctx_t</name> *</type><name>ctx</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>data</name></decl></param>,
<param><decl><type><name>apr_size_t</name></type> <name>len</name></decl></param>,
<param><decl><type><name>apr_size_t</name> *</type><name>release</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type>struct <name>ssi_internal_ctx</name> *</type><name>intern</name> <init>= <expr><name><name>ctx</name>-&gt;<name>intern</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>apr_size_t</name></type> <name>pos</name></decl>, <decl><type ref="prev"/><name>spos</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>apr_size_t</name></type> <name>slen</name> <init>= <expr><name><name>intern</name>-&gt;<name>start_seq_pat</name>-&gt;<name>pattern_len</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>p</name></decl>, *<decl><type ref="prev"/><name>ep</name></decl>;</decl_stmt>
<expr_stmt><expr><name>pos</name> = <name><name>intern</name>-&gt;<name>parse_pos</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>ep</name> = <name>data</name> + <name>len</name></expr>;</expr_stmt>
<expr_stmt><expr>*<name>release</name> = 0</expr>;</expr_stmt>
<do>do <block>{
<expr_stmt><expr><name>p</name> = <name>data</name></expr>;</expr_stmt>
<while>while <condition>(<expr><name>p</name> &lt; <name>ep</name> &amp;&amp; <name>pos</name> &lt; <name>slen</name> &amp;&amp; *<name>p</name> == <name><name>intern</name>-&gt;<name>start_seq</name><index>[<expr><name>pos</name></expr>]</index></name></expr>)</condition> <block>{
<expr_stmt><expr>++<name>p</name></expr>;</expr_stmt>
<expr_stmt><expr>++<name>pos</name></expr>;</expr_stmt>
}</block></while>
<if>if <condition>(<expr><name>pos</name> == <name>slen</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>intern</name>-&gt;<name>state</name></name> = <name>PARSE_DIRECTIVE</name></expr>;</expr_stmt>
<return>return <expr>(<name>p</name> - <name>data</name>)</expr>;</return>
}</block></then></if>
<if>if <condition>(<expr><name>p</name> == <name>ep</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>intern</name>-&gt;<name>parse_pos</name></name> = <name>pos</name></expr>;</expr_stmt>
<return>return <expr>(<name>p</name> - <name>data</name>)</expr>;</return>
}</block></then></if>
<if>if <condition>(<expr><name>spos</name> &lt; <name><name>intern</name>-&gt;<name>parse_pos</name></name></expr>)</condition><then> <block>{
<do>do <block>{
<expr_stmt><expr>++<name>spos</name></expr>;</expr_stmt>
<expr_stmt><expr>++*<name>release</name></expr>;</expr_stmt>
<expr_stmt><expr><name>p</name> = <name><name>intern</name>-&gt;<name>start_seq</name></name> + <name>spos</name></expr>;</expr_stmt>
<expr_stmt><expr><name>pos</name> = <name><name>intern</name>-&gt;<name>parse_pos</name></name> - <name>spos</name></expr>;</expr_stmt>
<while>while <condition>(<expr><name>pos</name> &amp;&amp; *<name>p</name> != *<name><name>intern</name>-&gt;<name>start_seq</name></name></expr>)</condition> <block>{
<expr_stmt><expr>++<name>p</name></expr>;</expr_stmt>
<expr_stmt><expr>++<name>spos</name></expr>;</expr_stmt>
<expr_stmt><expr>++*<name>release</name></expr>;</expr_stmt>
<expr_stmt><expr>--<name>pos</name></expr>;</expr_stmt>
}</block></while>
<if>if <condition>(<expr><name>pos</name> &gt; 1</expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>apr_size_t</name></type> <name>t</name> <init>= <expr>1</expr></init></decl>;</decl_stmt>
<expr_stmt><expr>++<name>p</name></expr>;</expr_stmt>
<while>while <condition>(<expr><name>t</name> &lt; <name>pos</name> &amp;&amp; *<name>p</name> == <name><name>intern</name>-&gt;<name>start_seq</name><index>[<expr><name>t</name></expr>]</index></name></expr>)</condition> <block>{
<expr_stmt><expr>++<name>p</name></expr>;</expr_stmt>
<expr_stmt><expr>++<name>t</name></expr>;</expr_stmt>
}</block></while>
<if>if <condition>(<expr><name>t</name> == <name>pos</name></expr>)</condition><then> <block>{
<break>break;</break>
}</block></then></if>
}</block></then></if>
}</block> while <condition>(<expr><name>pos</name> &gt; 1</expr>)</condition>;</do>
<if>if <condition>(<expr><name>pos</name></expr>)</condition><then> <block>{
<continue>continue;</continue>
}</block></then></if>
}</block></then></if>
<break>break;</break>
}</block> while <condition>(<expr>1</expr>)</condition>;</do>
<expr_stmt><expr>*<name>release</name> = <name><name>intern</name>-&gt;<name>parse_pos</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>intern</name>-&gt;<name>state</name></name> = <name>PARSE_PRE_HEAD</name></expr>;</expr_stmt>
<return>return <expr>0</expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>apr_size_t</name></type> <name>find_directive</name><parameter_list>(<param><decl><type><name>include_ctx_t</name> *</type><name>ctx</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>data</name></decl></param>,
<param><decl><type><name>apr_size_t</name></type> <name>len</name></decl></param>, <param><decl><type><name>char</name> ***</type><name>store</name></decl></param>,
<param><decl><type><name>apr_size_t</name> **</type><name>store_len</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type>struct <name>ssi_internal_ctx</name> *</type><name>intern</name> <init>= <expr><name><name>ctx</name>-&gt;<name>intern</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>p</name> <init>= <expr><name>data</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>ep</name> <init>= <expr><name>data</name> + <name>len</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>apr_size_t</name></type> <name>pos</name></decl>;</decl_stmt>
<switch>switch <condition>(<expr><name><name>intern</name>-&gt;<name>state</name></name></expr>)</condition> <block>{
<case>case <expr><name>PARSE_DIRECTIVE</name></expr>:
<while>while <condition>(<expr><name>p</name> &lt; <name>ep</name> &amp;&amp; !<call><name>apr_isspace</name><argument_list>(<argument><expr>*<name>p</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{
<if>if <condition>(<expr>*<name>p</name> == *<name><name>intern</name>-&gt;<name>end_seq</name></name></expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>intern</name>-&gt;<name>state</name></name> = <name>PARSE_DIRECTIVE_TAIL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>intern</name>-&gt;<name>parse_pos</name></name> = 1</expr>;</expr_stmt>
<expr_stmt><expr>++<name>p</name></expr>;</expr_stmt>
<return>return <expr>(<name>p</name> - <name>data</name>)</expr>;</return>
}</block></then></if>
<expr_stmt><expr>++<name>p</name></expr>;</expr_stmt>
}</block></while>
<if>if <condition>(<expr><name>p</name> &lt; <name>ep</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>intern</name>-&gt;<name>state</name></name> = <name>PARSE_DIRECTIVE_POSTNAME</name></expr>;</expr_stmt>
<expr_stmt><expr>*<name>store</name> = &amp;<name><name>intern</name>-&gt;<name>directive</name></name></expr>;</expr_stmt>
<expr_stmt><expr>*<name>store_len</name> = &amp;<name><name>intern</name>-&gt;<name>directive_len</name></name></expr>;</expr_stmt>
}</block></then></if>
<break>break;</break>
</case><case>case <expr><name>PARSE_DIRECTIVE_TAIL</name></expr>:
<expr_stmt><expr><name>pos</name> = <name><name>intern</name>-&gt;<name>parse_pos</name></name></expr>;</expr_stmt>
<while>while <condition>(<expr><name>p</name> &lt; <name>ep</name> &amp;&amp; <name>pos</name> &lt; <name><name>intern</name>-&gt;<name>end_seq_len</name></name> &amp;&amp;
*<name>p</name> == <name><name>intern</name>-&gt;<name>end_seq</name><index>[<expr><name>pos</name></expr>]</index></name></expr>)</condition> <block>{
<expr_stmt><expr>++<name>p</name></expr>;</expr_stmt>
<expr_stmt><expr>++<name>pos</name></expr>;</expr_stmt>
}</block></while>
<if>if <condition>(<expr><name>pos</name> == <name><name>intern</name>-&gt;<name>end_seq_len</name></name></expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>intern</name>-&gt;<name>state</name></name> = <name>PARSE_DIRECTIVE_POSTTAIL</name></expr>;</expr_stmt>
<expr_stmt><expr>*<name>store</name> = &amp;<name><name>intern</name>-&gt;<name>directive</name></name></expr>;</expr_stmt>
<expr_stmt><expr>*<name>store_len</name> = &amp;<name><name>intern</name>-&gt;<name>directive_len</name></name></expr>;</expr_stmt>
<break>break;</break>
}</block></then></if>
<if>if <condition>(<expr><name>p</name> == <name>ep</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>intern</name>-&gt;<name>parse_pos</name></name> = <name>pos</name></expr>;</expr_stmt>
<break>break;</break>
}</block></then></if>
<expr_stmt><expr><name><name>intern</name>-&gt;<name>state</name></name> = <name>PARSE_DIRECTIVE</name></expr>;</expr_stmt>
<return>return <expr>0</expr>;</return>
</case><case>case <expr><name>PARSE_DIRECTIVE_POSTTAIL</name></expr>:
<expr_stmt><expr><name><name>intern</name>-&gt;<name>state</name></name> = <name>PARSE_EXECUTE</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>intern</name>-&gt;<name>directive_len</name></name> -= <name><name>intern</name>-&gt;<name>end_seq_len</name></name></expr>;</expr_stmt>
</case><case>case <expr><name>PARSE_DIRECTIVE_POSTNAME</name></expr>:
<if>if <condition>(<expr><name>PARSE_DIRECTIVE_POSTNAME</name> == <name><name>intern</name>-&gt;<name>state</name></name></expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>intern</name>-&gt;<name>state</name></name> = <name>PARSE_PRE_ARG</name></expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><name><name>ctx</name>-&gt;<name>argc</name></name> = 0</expr>;</expr_stmt>
<expr_stmt><expr><name><name>intern</name>-&gt;<name>argv</name></name> = <name>NULL</name></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name><name>intern</name>-&gt;<name>directive_len</name></name></expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>intern</name>-&gt;<name>error</name></name> = 1</expr>;</expr_stmt>
<expr_stmt><expr><call><name>ap_log_rerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_ERR</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name><name>ctx</name>-&gt;<name>r</name></name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>01368</expr></argument>)</argument_list></call> "missing "
"directive name in parsed document %s"</expr></argument>,
<argument><expr><name><name>ctx</name>-&gt;<name>r</name>-&gt;<name>filename</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<decl_stmt><decl><type><name>char</name> *</type><name>sp</name> <init>= <expr><name><name>intern</name>-&gt;<name>directive</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>sep</name> <init>= <expr><name><name>intern</name>-&gt;<name>directive</name></name> + <name><name>intern</name>-&gt;<name>directive_len</name></name></expr></init></decl>;</decl_stmt>
<for>for (<init>;</init> <condition><expr><name>sp</name> &lt; <name>sep</name></expr>;</condition> <incr><expr>++<name>sp</name></expr></incr>) <block>{
<expr_stmt><expr>*<name>sp</name> = <call><name>apr_tolower</name><argument_list>(<argument><expr>*<name>sp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></for>
}</block></else></if>
<return>return <expr>0</expr>;</return>
</case><default>default:
<break>break;</break>
</default>}</block></switch>
<return>return <expr>(<name>p</name> - <name>data</name>)</expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>apr_size_t</name></type> <name>find_arg_or_tail</name><parameter_list>(<param><decl><type><name>include_ctx_t</name> *</type><name>ctx</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>data</name></decl></param>,
<param><decl><type><name>apr_size_t</name></type> <name>len</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type>struct <name>ssi_internal_ctx</name> *</type><name>intern</name> <init>= <expr><name><name>ctx</name>-&gt;<name>intern</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>p</name> <init>= <expr><name>data</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>ep</name> <init>= <expr><name>data</name> + <name>len</name></expr></init></decl>;</decl_stmt>
<while>while <condition>(<expr><name>p</name> &lt; <name>ep</name> &amp;&amp; <call><name>apr_isspace</name><argument_list>(<argument><expr>*<name>p</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{
<expr_stmt><expr>++<name>p</name></expr>;</expr_stmt>
}</block></while>
<if>if <condition>(<expr><name>p</name> &lt; <name>ep</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>intern</name>-&gt;<name>state</name></name> = (*<name>p</name> == *<name><name>intern</name>-&gt;<name>end_seq</name></name>) ? <name>PARSE_TAIL</name> : <name>PARSE_ARG</name></expr>;</expr_stmt>
}</block></then></if>
<return>return <expr>(<name>p</name> - <name>data</name>)</expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>apr_size_t</name></type> <name>find_tail</name><parameter_list>(<param><decl><type><name>include_ctx_t</name> *</type><name>ctx</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>data</name></decl></param>,
<param><decl><type><name>apr_size_t</name></type> <name>len</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type>struct <name>ssi_internal_ctx</name> *</type><name>intern</name> <init>= <expr><name><name>ctx</name>-&gt;<name>intern</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>p</name> <init>= <expr><name>data</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>ep</name> <init>= <expr><name>data</name> + <name>len</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>apr_size_t</name></type> <name>pos</name> <init>= <expr><name><name>intern</name>-&gt;<name>parse_pos</name></name></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>PARSE_TAIL</name> == <name><name>intern</name>-&gt;<name>state</name></name></expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>intern</name>-&gt;<name>state</name></name> = <name>PARSE_TAIL_SEQ</name></expr>;</expr_stmt>
<expr_stmt><expr><name>pos</name> = <name><name>intern</name>-&gt;<name>parse_pos</name></name> = 0</expr>;</expr_stmt>
}</block></then></if>
<while>while <condition>(<expr><name>p</name> &lt; <name>ep</name> &amp;&amp; <name>pos</name> &lt; <name><name>intern</name>-&gt;<name>end_seq_len</name></name> &amp;&amp; *<name>p</name> == <name><name>intern</name>-&gt;<name>end_seq</name><index>[<expr><name>pos</name></expr>]</index></name></expr>)</condition> <block>{
<expr_stmt><expr>++<name>p</name></expr>;</expr_stmt>
<expr_stmt><expr>++<name>pos</name></expr>;</expr_stmt>
}</block></while>
<if>if <condition>(<expr><name>pos</name> == <name><name>intern</name>-&gt;<name>end_seq_len</name></name></expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>intern</name>-&gt;<name>state</name></name> = <name>PARSE_EXECUTE</name></expr>;</expr_stmt>
<return>return <expr>(<name>p</name> - <name>data</name>)</expr>;</return>
}</block></then></if>
<if>if <condition>(<expr><name>p</name> == <name>ep</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>intern</name>-&gt;<name>parse_pos</name></name> = <name>pos</name></expr>;</expr_stmt>
<return>return <expr>(<name>p</name> - <name>data</name>)</expr>;</return>
}</block></then></if>
<expr_stmt><expr><name><name>intern</name>-&gt;<name>state</name></name> = <name>PARSE_ARG</name></expr>;</expr_stmt>
<return>return <expr>0</expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>apr_size_t</name></type> <name>find_argument</name><parameter_list>(<param><decl><type><name>include_ctx_t</name> *</type><name>ctx</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>data</name></decl></param>,
<param><decl><type><name>apr_size_t</name></type> <name>len</name></decl></param>, <param><decl><type><name>char</name> ***</type><name>store</name></decl></param>,
<param><decl><type><name>apr_size_t</name> **</type><name>store_len</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type>struct <name>ssi_internal_ctx</name> *</type><name>intern</name> <init>= <expr><name><name>ctx</name>-&gt;<name>intern</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>p</name> <init>= <expr><name>data</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>ep</name> <init>= <expr><name>data</name> + <name>len</name></expr></init></decl>;</decl_stmt>
<switch>switch <condition>(<expr><name><name>intern</name>-&gt;<name>state</name></name></expr>)</condition> <block>{
<case>case <expr><name>PARSE_ARG</name></expr>:
<expr_stmt><expr><name><name>intern</name>-&gt;<name>current_arg</name></name> = <call><name>apr_palloc</name><argument_list>(<argument><expr><name><name>ctx</name>-&gt;<name>dpool</name></name></expr></argument>,
<argument><expr><sizeof>sizeof<argument_list>(<argument><expr>*<name><name>intern</name>-&gt;<name>current_arg</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>intern</name>-&gt;<name>current_arg</name>-&gt;<name>next</name></name> = <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr>++(<name><name>ctx</name>-&gt;<name>argc</name></name>)</expr>;</expr_stmt>
<if>if <condition>(<expr>!<name><name>intern</name>-&gt;<name>argv</name></name></expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>intern</name>-&gt;<name>argv</name></name> = <name><name>intern</name>-&gt;<name>current_arg</name></name></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<decl_stmt><decl><type><name>arg_item_t</name> *</type><name>newarg</name> <init>= <expr><name><name>intern</name>-&gt;<name>argv</name></name></expr></init></decl>;</decl_stmt>
<while>while <condition>(<expr><name><name>newarg</name>-&gt;<name>next</name></name></expr>)</condition> <block>{
<expr_stmt><expr><name>newarg</name> = <name><name>newarg</name>-&gt;<name>next</name></name></expr>;</expr_stmt>
}</block></while>
<expr_stmt><expr><name><name>newarg</name>-&gt;<name>next</name></name> = <name><name>intern</name>-&gt;<name>current_arg</name></name></expr>;</expr_stmt>
}</block></else></if>
<switch>switch <condition>(<expr>*<name>p</name></expr>)</condition> <block>{
<case>case <expr>'"'</expr>:
</case><case>case <expr>'\''</expr>:
</case><case>case <expr>'`'</expr>:
<expr_stmt><expr>*<name>store</name> = <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>intern</name>-&gt;<name>state</name></name> = <name>PARSE_ARG_VAL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>intern</name>-&gt;<name>quote</name></name> = *<name>p</name>++</expr>;</expr_stmt>
<expr_stmt><expr><name><name>intern</name>-&gt;<name>current_arg</name>-&gt;<name>name</name></name> = <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>intern</name>-&gt;<name>current_arg</name>-&gt;<name>name_len</name></name> = 0</expr>;</expr_stmt>
<expr_stmt><expr><name><name>intern</name>-&gt;<name>error</name></name> = 1</expr>;</expr_stmt>
<expr_stmt><expr><call><name>ap_log_rerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_ERR</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name><name>ctx</name>-&gt;<name>r</name></name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>01369</expr></argument>)</argument_list></call> "missing "
"argument name for value to tag %s in %s"</expr></argument>,
<argument><expr><call><name>apr_pstrmemdup</name><argument_list>(<argument><expr><name><name>ctx</name>-&gt;<name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name><name>intern</name>-&gt;<name>directive</name></name></expr></argument>,
<argument><expr><name><name>intern</name>-&gt;<name>directive_len</name></name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name><name>ctx</name>-&gt;<name>r</name>-&gt;<name>filename</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>(<name>p</name> - <name>data</name>)</expr>;</return>
</case><default>default:
<expr_stmt><expr><name><name>intern</name>-&gt;<name>state</name></name> = <name>PARSE_ARG_NAME</name></expr>;</expr_stmt>
</default>}</block></switch>
</case><case>case <expr><name>PARSE_ARG_NAME</name></expr>:
<while>while <condition>(<expr><name>p</name> &lt; <name>ep</name> &amp;&amp; !<call><name>apr_isspace</name><argument_list>(<argument><expr>*<name>p</name></expr></argument>)</argument_list></call> &amp;&amp; *<name>p</name> != '='</expr>)</condition> <block>{
<expr_stmt><expr>++<name>p</name></expr>;</expr_stmt>
}</block></while>
<if>if <condition>(<expr><name>p</name> &lt; <name>ep</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>intern</name>-&gt;<name>state</name></name> = <name>PARSE_ARG_POSTNAME</name></expr>;</expr_stmt>
<expr_stmt><expr>*<name>store</name> = &amp;<name><name>intern</name>-&gt;<name>current_arg</name>-&gt;<name>name</name></name></expr>;</expr_stmt>
<expr_stmt><expr>*<name>store_len</name> = &amp;<name><name>intern</name>-&gt;<name>current_arg</name>-&gt;<name>name_len</name></name></expr>;</expr_stmt>
<return>return <expr>(<name>p</name> - <name>data</name>)</expr>;</return>
}</block></then></if>
<break>break;</break>
</case><case>case <expr><name>PARSE_ARG_POSTNAME</name></expr>:
<expr_stmt><expr><name><name>intern</name>-&gt;<name>current_arg</name>-&gt;<name>name</name></name> = <call><name>apr_pstrmemdup</name><argument_list>(<argument><expr><name><name>ctx</name>-&gt;<name>dpool</name></name></expr></argument>,
<argument><expr><name><name>intern</name>-&gt;<name>current_arg</name>-&gt;<name>name</name></name></expr></argument>,
<argument><expr><name><name>intern</name>-&gt;<name>current_arg</name>-&gt;<name>name_len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name><name>intern</name>-&gt;<name>current_arg</name>-&gt;<name>name_len</name></name></expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>intern</name>-&gt;<name>error</name></name> = 1</expr>;</expr_stmt>
<expr_stmt><expr><call><name>ap_log_rerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_ERR</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name><name>ctx</name>-&gt;<name>r</name></name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>01370</expr></argument>)</argument_list></call> "missing "
"argument name for value to tag %s in %s"</expr></argument>,
<argument><expr><call><name>apr_pstrmemdup</name><argument_list>(<argument><expr><name><name>ctx</name>-&gt;<name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name><name>intern</name>-&gt;<name>directive</name></name></expr></argument>,
<argument><expr><name><name>intern</name>-&gt;<name>directive_len</name></name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name><name>ctx</name>-&gt;<name>r</name>-&gt;<name>filename</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr><call><name>ap_str_tolower</name><argument_list>(<argument><expr><name><name>intern</name>-&gt;<name>current_arg</name>-&gt;<name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></else></if>
<expr_stmt><expr><name><name>intern</name>-&gt;<name>state</name></name> = <name>PARSE_ARG_EQ</name></expr>;</expr_stmt>
</case><case>case <expr><name>PARSE_ARG_EQ</name></expr>:
<expr_stmt><expr>*<name>store</name> = <name>NULL</name></expr>;</expr_stmt>
<while>while <condition>(<expr><name>p</name> &lt; <name>ep</name> &amp;&amp; <call><name>apr_isspace</name><argument_list>(<argument><expr>*<name>p</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{
<expr_stmt><expr>++<name>p</name></expr>;</expr_stmt>
}</block></while>
<if>if <condition>(<expr><name>p</name> &lt; <name>ep</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr>*<name>p</name> == '='</expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>intern</name>-&gt;<name>state</name></name> = <name>PARSE_ARG_PREVAL</name></expr>;</expr_stmt>
<expr_stmt><expr>++<name>p</name></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr><name><name>intern</name>-&gt;<name>current_arg</name>-&gt;<name>value</name></name> = <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>intern</name>-&gt;<name>state</name></name> = <name>PARSE_PRE_ARG</name></expr>;</expr_stmt>
}</block></else></if>
<return>return <expr>(<name>p</name> - <name>data</name>)</expr>;</return>
}</block></then></if>
<break>break;</break>
</case><case>case <expr><name>PARSE_ARG_PREVAL</name></expr>:
<expr_stmt><expr>*<name>store</name> = <name>NULL</name></expr>;</expr_stmt>
<while>while <condition>(<expr><name>p</name> &lt; <name>ep</name> &amp;&amp; <call><name>apr_isspace</name><argument_list>(<argument><expr>*<name>p</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{
<expr_stmt><expr>++<name>p</name></expr>;</expr_stmt>
}</block></while>
<if>if <condition>(<expr><name>p</name> &lt; <name>ep</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>intern</name>-&gt;<name>state</name></name> = <name>PARSE_ARG_VAL</name></expr>;</expr_stmt>
<switch>switch <condition>(<expr>*<name>p</name></expr>)</condition> <block>{
<case>case <expr>'"'</expr>:
</case><case>case <expr>'\''</expr>:
</case><case>case <expr>'`'</expr>:
<expr_stmt><expr><name><name>intern</name>-&gt;<name>quote</name></name> = *<name>p</name>++</expr>;</expr_stmt>
<break>break;</break>
</case><default>default:
<expr_stmt><expr><name><name>intern</name>-&gt;<name>quote</name></name> = '\0'</expr>;</expr_stmt>
<break>break;</break>
</default>}</block></switch>
<return>return <expr>(<name>p</name> - <name>data</name>)</expr>;</return>
}</block></then></if>
<break>break;</break>
</case><case>case <expr><name>PARSE_ARG_VAL_ESC</name></expr>:
<if>if <condition>(<expr>*<name>p</name> == <name><name>intern</name>-&gt;<name>quote</name></name></expr>)</condition><then> <block>{
<expr_stmt><expr>++<name>p</name></expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><name><name>intern</name>-&gt;<name>state</name></name> = <name>PARSE_ARG_VAL</name></expr>;</expr_stmt>
</case><case>case <expr><name>PARSE_ARG_VAL</name></expr>:
<for>for (<init>;</init> <condition><expr><name>p</name> &lt; <name>ep</name></expr>;</condition> <incr><expr>++<name>p</name></expr></incr>) <block>{
<if>if <condition>(<expr><name><name>intern</name>-&gt;<name>quote</name></name> &amp;&amp; *<name>p</name> == '\\'</expr>)</condition><then> <block>{
<expr_stmt><expr>++<name>p</name></expr>;</expr_stmt>
<if>if <condition>(<expr><name>p</name> == <name>ep</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>intern</name>-&gt;<name>state</name></name> = <name>PARSE_ARG_VAL_ESC</name></expr>;</expr_stmt>
<break>break;</break>
}</block></then></if>
<if>if <condition>(<expr>*<name>p</name> != <name><name>intern</name>-&gt;<name>quote</name></name></expr>)</condition><then> <block>{
<expr_stmt><expr>--<name>p</name></expr>;</expr_stmt>
}</block></then></if>
}</block></then> <else>else <if>if <condition>(<expr><name><name>intern</name>-&gt;<name>quote</name></name> &amp;&amp; *<name>p</name> == <name><name>intern</name>-&gt;<name>quote</name></name></expr>)</condition><then> <block>{
<expr_stmt><expr>++<name>p</name></expr>;</expr_stmt>
<expr_stmt><expr>*<name>store</name> = &amp;<name><name>intern</name>-&gt;<name>current_arg</name>-&gt;<name>value</name></name></expr>;</expr_stmt>
<expr_stmt><expr>*<name>store_len</name> = &amp;<name><name>intern</name>-&gt;<name>current_arg</name>-&gt;<name>value_len</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>intern</name>-&gt;<name>state</name></name> = <name>PARSE_ARG_POSTVAL</name></expr>;</expr_stmt>
<break>break;</break>
}</block></then> <else>else <if>if <condition>(<expr>!<name><name>intern</name>-&gt;<name>quote</name></name> &amp;&amp; <call><name>apr_isspace</name><argument_list>(<argument><expr>*<name>p</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr>++<name>p</name></expr>;</expr_stmt>
<expr_stmt><expr>*<name>store</name> = &amp;<name><name>intern</name>-&gt;<name>current_arg</name>-&gt;<name>value</name></name></expr>;</expr_stmt>
<expr_stmt><expr>*<name>store_len</name> = &amp;<name><name>intern</name>-&gt;<name>current_arg</name>-&gt;<name>value_len</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>intern</name>-&gt;<name>state</name></name> = <name>PARSE_ARG_POSTVAL</name></expr>;</expr_stmt>
<break>break;</break>
}</block></then></if></else></if></else></if>
}</block></for>
<return>return <expr>(<name>p</name> - <name>data</name>)</expr>;</return>
</case><case>case <expr><name>PARSE_ARG_POSTVAL</name></expr>:
<expr_stmt><expr>--(<name><name>intern</name>-&gt;<name>current_arg</name>-&gt;<name>value_len</name></name>)</expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>intern</name>-&gt;<name>quote</name></name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>apr_size_t</name></type> <name>shift</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>sp</name></decl>;</decl_stmt>
<expr_stmt><expr><name>sp</name> = <name><name>intern</name>-&gt;<name>current_arg</name>-&gt;<name>value</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>ep</name> = <name><name>intern</name>-&gt;<name>current_arg</name>-&gt;<name>value</name></name> + <name><name>intern</name>-&gt;<name>current_arg</name>-&gt;<name>value_len</name></name></expr>;</expr_stmt>
<while>while <condition>(<expr><name>sp</name> &lt; <name>ep</name> &amp;&amp; *<name>sp</name> != '\\'</expr>)</condition> <block>{
<expr_stmt><expr>++<name>sp</name></expr>;</expr_stmt>
}</block></while>
<for>for (<init>;</init> <condition><expr><name>sp</name> &lt; <name>ep</name></expr>;</condition> <incr><expr>++<name>sp</name></expr></incr>) <block>{
<if>if <condition>(<expr>*<name>sp</name> == '\\' &amp;&amp; <name><name>sp</name><index>[<expr>1</expr>]</index></name> == <name><name>intern</name>-&gt;<name>quote</name></name></expr>)</condition><then> <block>{
<expr_stmt><expr>++<name>sp</name></expr>;</expr_stmt>
<expr_stmt><expr>++<name>shift</name></expr>;</expr_stmt>
}</block></then></if>
<if>if <condition>(<expr><name>shift</name></expr>)</condition><then> <block>{
<expr_stmt><expr>*(<name>sp</name>-<name>shift</name>) = *<name>sp</name></expr>;</expr_stmt>
}</block></then></if>
}</block></for>
<expr_stmt><expr><name><name>intern</name>-&gt;<name>current_arg</name>-&gt;<name>value_len</name></name> -= <name>shift</name></expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><name><name>intern</name>-&gt;<name>current_arg</name>-&gt;<name>value</name><index>[<expr><name><name>intern</name>-&gt;<name>current_arg</name>-&gt;<name>value_len</name></name></expr>]</index></name> = '\0'</expr>;</expr_stmt>
<expr_stmt><expr><name><name>intern</name>-&gt;<name>state</name></name> = <name>PARSE_PRE_ARG</name></expr>;</expr_stmt>
<return>return <expr>0</expr>;</return>
</case><default>default:
<break>break;</break>
</default>}</block></switch>
<return>return <expr><name>len</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>apr_status_t</name></type> <name>send_parsed_content</name><parameter_list>(<param><decl><type><name>ap_filter_t</name> *</type><name>f</name></decl></param>, <param><decl><type><name>apr_bucket_brigade</name> *</type><name>bb</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>include_ctx_t</name> *</type><name>ctx</name> <init>= <expr><name><name>f</name>-&gt;<name>ctx</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type>struct <name>ssi_internal_ctx</name> *</type><name>intern</name> <init>= <expr><name><name>ctx</name>-&gt;<name>intern</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>request_rec</name> *</type><name>r</name> <init>= <expr><name><name>f</name>-&gt;<name>r</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>apr_bucket</name> *</type><name>b</name> <init>= <expr><call><name>APR_BRIGADE_FIRST</name><argument_list>(<argument><expr><name>bb</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>apr_bucket_brigade</name> *</type><name>pass_bb</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>apr_status_t</name></type> <name>rv</name> <init>= <expr><name>APR_SUCCESS</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>magic</name></decl>;</decl_stmt>
<if>if <condition>(<expr><call><name>APR_BRIGADE_EMPTY</name><argument_list>(<argument><expr><name>bb</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<return>return <expr><name>APR_SUCCESS</name></expr>;</return>
}</block></then></if>
<if>if <condition>(<expr><name><name>intern</name>-&gt;<name>seen_eos</name></name></expr>)</condition><then> <block>{
<return>return <expr><call><name>ap_pass_brigade</name><argument_list>(<argument><expr><name><name>f</name>-&gt;<name>next</name></name></expr></argument>, <argument><expr><name>bb</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>pass_bb</name> = <call><name>apr_brigade_create</name><argument_list>(<argument><expr><name><name>ctx</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name><name>f</name>-&gt;<name>c</name>-&gt;<name>bucket_alloc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>intern</name>-&gt;<name>bytes_read</name></name> = 0</expr>;</expr_stmt>
<expr_stmt><expr><name><name>intern</name>-&gt;<name>error</name></name> = 0</expr>;</expr_stmt>
<expr_stmt><expr><name><name>ctx</name>-&gt;<name>flush_now</name></name> = 0</expr>;</expr_stmt>
<while>while <condition>(<expr><name>b</name> != <call><name>APR_BRIGADE_SENTINEL</name><argument_list>(<argument><expr><name>bb</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>data</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>apr_size_t</name></type> <name>len</name></decl>, <decl><type ref="prev"/><name>index</name></decl>, <decl><type ref="prev"/><name>release</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>apr_bucket</name> *</type><name>newb</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> **</type><name>store</name> <init>= <expr>&amp;<name>magic</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>apr_size_t</name> *</type><name>store_len</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><call><name>APR_BUCKET_IS_METADATA</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><name>newb</name> = <call><name>APR_BUCKET_NEXT</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>APR_BUCKET_REMOVE</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>APR_BUCKET_IS_EOS</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>intern</name>-&gt;<name>seen_eos</name></name> = 1</expr>;</expr_stmt>
<if>if <condition>(<expr><name>PARSE_EXECUTE</name> == <name><name>intern</name>-&gt;<name>state</name></name> ||
<name>PARSE_DIRECTIVE_POSTTAIL</name> == <name><name>intern</name>-&gt;<name>state</name></name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>APR_BUCKET_INSERT_BEFORE</name><argument_list>(<argument><expr><name>newb</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<break>break;</break>
}</block></else></if>
}</block></then> <else>else <block>{
<expr_stmt><expr><call><name>APR_BRIGADE_INSERT_TAIL</name><argument_list>(<argument><expr><name>pass_bb</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>APR_BUCKET_IS_FLUSH</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>ctx</name>-&gt;<name>flush_now</name></name> = 1</expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><name>b</name> = <name>newb</name></expr>;</expr_stmt>
<continue>continue;</continue>
}</block></else></if>
}</block></then></if>
<if>if <condition>(<expr><name><name>ctx</name>-&gt;<name>flush_now</name></name> ||
<name><name>intern</name>-&gt;<name>bytes_read</name></name> &gt; <name>AP_MIN_BYTES_TO_WRITE</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr>!<call><name>APR_BRIGADE_EMPTY</name><argument_list>(<argument><expr><name>pass_bb</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><name>rv</name> = <call><name>ap_pass_brigade</name><argument_list>(<argument><expr><name><name>f</name>-&gt;<name>next</name></name></expr></argument>, <argument><expr><name>pass_bb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>rv</name> != <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>apr_brigade_destroy</name><argument_list>(<argument><expr><name>pass_bb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>rv</name></expr>;</return>
}</block></then></if>
}</block></then></if>
<expr_stmt><expr><name><name>ctx</name>-&gt;<name>flush_now</name></name> = 0</expr>;</expr_stmt>
<expr_stmt><expr><name><name>intern</name>-&gt;<name>bytes_read</name></name> = 0</expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><name>len</name> = 0</expr>;</expr_stmt>
<if>if <condition>(<expr>!<name><name>intern</name>-&gt;<name>seen_eos</name></name></expr>)</condition><then> <block>{
<if>if <condition>(<expr><name><name>intern</name>-&gt;<name>bytes_read</name></name> &gt; 0</expr>)</condition><then> <block>{
<expr_stmt><expr><name>rv</name> = <call><name>apr_bucket_read</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr>&amp;<name>data</name></expr></argument>, <argument><expr>&amp;<name>len</name></expr></argument>, <argument><expr><name>APR_NONBLOCK_READ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>APR_STATUS_IS_EAGAIN</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>ctx</name>-&gt;<name>flush_now</name></name> = 1</expr>;</expr_stmt>
<continue>continue;</continue>
}</block></then></if>
}</block></then></if>
<if>if <condition>(<expr>!<name>len</name> || <name>rv</name> != <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>rv</name> = <call><name>apr_bucket_read</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr>&amp;<name>data</name></expr></argument>, <argument><expr>&amp;<name>len</name></expr></argument>, <argument><expr><name>APR_BLOCK_READ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<if>if <condition>(<expr><name>rv</name> != <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>apr_brigade_destroy</name><argument_list>(<argument><expr><name>pass_bb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>rv</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name><name>intern</name>-&gt;<name>bytes_read</name></name> += <name>len</name></expr>;</expr_stmt>
}</block></then></if>
<if>if <condition>(<expr>!<name>len</name> &amp;&amp; !<name><name>intern</name>-&gt;<name>seen_eos</name></name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>b</name> = <call><name>APR_BUCKET_NEXT</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<continue>continue;</continue>
}</block></then></if>
<switch>switch <condition>(<expr><name><name>intern</name>-&gt;<name>state</name></name></expr>)</condition> <block>{
<case>case <expr><name>PARSE_PRE_HEAD</name></expr>:
<expr_stmt><expr><name>index</name> = <call><name>find_start_sequence</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>data</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>index</name> &lt; <name>len</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>apr_bucket_split</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name>index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><name>newb</name> = <call><name>APR_BUCKET_NEXT</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>ctx</name>-&gt;<name>flags</name></name> &amp; <name>SSI_FLAG_PRINTING</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>APR_BUCKET_REMOVE</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>APR_BRIGADE_INSERT_TAIL</name><argument_list>(<argument><expr><name>pass_bb</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr><call><name>apr_bucket_delete</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></else></if>
<if>if <condition>(<expr><name>index</name> &lt; <name>len</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr><name>PARSE_DIRECTIVE</name> == <name><name>intern</name>-&gt;<name>state</name></name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>apr_bucket_split</name><argument_list>(<argument><expr><name>newb</name></expr></argument>, <argument><expr><name><name>intern</name>-&gt;<name>start_seq_pat</name>-&gt;<name>pattern_len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ctx</name>-&gt;<name>flush_now</name></name> = 1</expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><name>b</name> = <call><name>APR_BUCKET_NEXT</name><argument_list>(<argument><expr><name>newb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>apr_bucket_delete</name><argument_list>(<argument><expr><name>newb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr><name>b</name> = <name>newb</name></expr>;</expr_stmt>
}</block></else></if>
<break>break;</break>
</case><case>case <expr><name>PARSE_HEAD</name></expr>:
<expr_stmt><expr><name>index</name> = <call><name>find_partial_start_sequence</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>data</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr>&amp;<name>release</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>release</name> &amp;&amp; (<name><name>ctx</name>-&gt;<name>flags</name></name> &amp; <name>SSI_FLAG_PRINTING</name>)</expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>char</name> *</type><name>to_release</name> <init>= <expr><call><name>apr_pmemdup</name><argument_list>(<argument><expr><name><name>ctx</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name><name>intern</name>-&gt;<name>start_seq</name></name></expr></argument>, <argument><expr><name>release</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>newb</name> = <call><name>apr_bucket_pool_create</name><argument_list>(<argument><expr><name>to_release</name></expr></argument>, <argument><expr><name>release</name></expr></argument>, <argument><expr><name><name>ctx</name>-&gt;<name>pool</name></name></expr></argument>,
<argument><expr><name><name>f</name>-&gt;<name>c</name>-&gt;<name>bucket_alloc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>APR_BRIGADE_INSERT_TAIL</name><argument_list>(<argument><expr><name>pass_bb</name></expr></argument>, <argument><expr><name>newb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<if>if <condition>(<expr><name>index</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr><name>PARSE_DIRECTIVE</name> == <name><name>intern</name>-&gt;<name>state</name></name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>apr_bucket_split</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name>index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ctx</name>-&gt;<name>flush_now</name></name> = 1</expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><name>newb</name> = <call><name>APR_BUCKET_NEXT</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>apr_bucket_delete</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>b</name> = <name>newb</name></expr>;</expr_stmt>
}</block></then></if>
<break>break;</break>
</case><case>case <expr><name>PARSE_DIRECTIVE</name></expr>:
</case><case>case <expr><name>PARSE_DIRECTIVE_POSTNAME</name></expr>:
</case><case>case <expr><name>PARSE_DIRECTIVE_TAIL</name></expr>:
</case><case>case <expr><name>PARSE_DIRECTIVE_POSTTAIL</name></expr>:
<expr_stmt><expr><name>index</name> = <call><name>find_directive</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>data</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr>&amp;<name>store</name></expr></argument>, <argument><expr>&amp;<name>store_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>index</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>apr_bucket_split</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name>index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>newb</name> = <call><name>APR_BUCKET_NEXT</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<if>if <condition>(<expr><name>store</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr><name>index</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>APR_BUCKET_REMOVE</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>apr_bucket_setaside</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>APR_BRIGADE_INSERT_TAIL</name><argument_list>(<argument><expr><name><name>intern</name>-&gt;<name>tmp_bb</name></name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>b</name> = <name>newb</name></expr>;</expr_stmt>
}</block></then></if>
<if>if <condition>(<expr><name>store</name> != &amp;<name>magic</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>apr_brigade_pflatten</name><argument_list>(<argument><expr><name><name>intern</name>-&gt;<name>tmp_bb</name></name></expr></argument>, <argument><expr><name>store</name></expr></argument>, <argument><expr><name>store_len</name></expr></argument>,
<argument><expr><name><name>ctx</name>-&gt;<name>dpool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>apr_brigade_cleanup</name><argument_list>(<argument><expr><name><name>intern</name>-&gt;<name>tmp_bb</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
}</block></then> <else>else <if>if <condition>(<expr><name>index</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>apr_bucket_delete</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>b</name> = <name>newb</name></expr>;</expr_stmt>
}</block></then></if></else></if>
<break>break;</break>
</case><case>case <expr><name>PARSE_PRE_ARG</name></expr>:
<expr_stmt><expr><name>index</name> = <call><name>find_arg_or_tail</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>data</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>index</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr><name>index</name> &lt; <name>len</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>apr_bucket_split</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name>index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><name>newb</name> = <call><name>APR_BUCKET_NEXT</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>apr_bucket_delete</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>b</name> = <name>newb</name></expr>;</expr_stmt>
}</block></then></if>
<break>break;</break>
</case><case>case <expr><name>PARSE_ARG</name></expr>:
</case><case>case <expr><name>PARSE_ARG_NAME</name></expr>:
</case><case>case <expr><name>PARSE_ARG_POSTNAME</name></expr>:
</case><case>case <expr><name>PARSE_ARG_EQ</name></expr>:
</case><case>case <expr><name>PARSE_ARG_PREVAL</name></expr>:
</case><case>case <expr><name>PARSE_ARG_VAL</name></expr>:
</case><case>case <expr><name>PARSE_ARG_VAL_ESC</name></expr>:
</case><case>case <expr><name>PARSE_ARG_POSTVAL</name></expr>:
<expr_stmt><expr><name>index</name> = <call><name>find_argument</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>data</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr>&amp;<name>store</name></expr></argument>, <argument><expr>&amp;<name>store_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>index</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>apr_bucket_split</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name>index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>newb</name> = <call><name>APR_BUCKET_NEXT</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<if>if <condition>(<expr><name>store</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr><name>index</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>APR_BUCKET_REMOVE</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>apr_bucket_setaside</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>APR_BRIGADE_INSERT_TAIL</name><argument_list>(<argument><expr><name><name>intern</name>-&gt;<name>tmp_bb</name></name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>b</name> = <name>newb</name></expr>;</expr_stmt>
}</block></then></if>
<if>if <condition>(<expr><name>store</name> != &amp;<name>magic</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>apr_brigade_pflatten</name><argument_list>(<argument><expr><name><name>intern</name>-&gt;<name>tmp_bb</name></name></expr></argument>, <argument><expr><name>store</name></expr></argument>, <argument><expr><name>store_len</name></expr></argument>,
<argument><expr><name><name>ctx</name>-&gt;<name>dpool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>apr_brigade_cleanup</name><argument_list>(<argument><expr><name><name>intern</name>-&gt;<name>tmp_bb</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
}</block></then> <else>else <if>if <condition>(<expr><name>index</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>apr_bucket_delete</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>b</name> = <name>newb</name></expr>;</expr_stmt>
}</block></then></if></else></if>
<break>break;</break>
</case><case>case <expr><name>PARSE_TAIL</name></expr>:
</case><case>case <expr><name>PARSE_TAIL_SEQ</name></expr>:
<expr_stmt><expr><name>index</name> = <call><name>find_tail</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>data</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<switch>switch <condition>(<expr><name><name>intern</name>-&gt;<name>state</name></name></expr>)</condition> <block>{
<case>case <expr><name>PARSE_EXECUTE</name></expr>:
<expr_stmt><expr><call><name>apr_bucket_split</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name>index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>newb</name> = <call><name>APR_BUCKET_NEXT</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>apr_bucket_delete</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>b</name> = <name>newb</name></expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr><name>PARSE_ARG</name></expr>:
<expr_stmt><expr><call><name>APR_BRIGADE_PREPEND</name><argument_list>(<argument><expr><name>bb</name></expr></argument>, <argument><expr><name><name>intern</name>-&gt;<name>tmp_bb</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>b</name> = <call><name>APR_BRIGADE_FIRST</name><argument_list>(<argument><expr><name>bb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</case><default>default:
<expr_stmt><expr><name>newb</name> = <call><name>APR_BUCKET_NEXT</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>APR_BUCKET_REMOVE</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>apr_bucket_setaside</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>APR_BRIGADE_INSERT_TAIL</name><argument_list>(<argument><expr><name><name>intern</name>-&gt;<name>tmp_bb</name></name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>b</name> = <name>newb</name></expr>;</expr_stmt>
<break>break;</break>
</default>}</block></switch>
<break>break;</break>
</case><case>case <expr><name>PARSE_EXECUTE</name></expr>:
<if>if <condition>(<expr><name><name>intern</name>-&gt;<name>error</name></name></expr>)</condition><then> <block>{
<if>if <condition>(<expr><name><name>ctx</name>-&gt;<name>flags</name></name> &amp; <name>SSI_FLAG_PRINTING</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>SSI_CREATE_ERROR_BUCKET</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>f</name></expr></argument>, <argument><expr><name>pass_bb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>intern</name>-&gt;<name>error</name></name> = 0</expr>;</expr_stmt>
}</block></then></if>
}</block></then> <else>else <block>{
<decl_stmt><decl><type><name>include_handler_fn_t</name> *</type><name>handle_func</name></decl>;</decl_stmt>
<expr_stmt><expr><name>handle_func</name> =
(<name>include_handler_fn_t</name> *)<call><name>apr_hash_get</name><argument_list>(<argument><expr><name>include_handlers</name></expr></argument>, <argument><expr><name><name>intern</name>-&gt;<name>directive</name></name></expr></argument>,
<argument><expr><name><name>intern</name>-&gt;<name>directive_len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>handle_func</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>DEBUG_INIT</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>f</name></expr></argument>, <argument><expr><name>pass_bb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>rv</name> = <call><name>handle_func</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>f</name></expr></argument>, <argument><expr><name>pass_bb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>rv</name> != <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>apr_brigade_destroy</name><argument_list>(<argument><expr><name>pass_bb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>rv</name></expr>;</return>
}</block></then></if>
}</block></then> <else>else <block>{
<expr_stmt><expr><call><name>ap_log_rerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_ERR</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>01371</expr></argument>)</argument_list></call>
"unknown directive \"%s\" in parsed doc %s"</expr></argument>,
<argument><expr><call><name>apr_pstrmemdup</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name><name>intern</name>-&gt;<name>directive</name></name></expr></argument>,
<argument><expr><name><name>intern</name>-&gt;<name>directive_len</name></name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name><name>r</name>-&gt;<name>filename</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>ctx</name>-&gt;<name>flags</name></name> &amp; <name>SSI_FLAG_PRINTING</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>SSI_CREATE_ERROR_BUCKET</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>f</name></expr></argument>, <argument><expr><name>pass_bb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
}</block></else></if>
}</block></else></if>
<expr_stmt><expr><call><name>apr_pool_clear</name><argument_list>(<argument><expr><name><name>ctx</name>-&gt;<name>dpool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>apr_brigade_cleanup</name><argument_list>(<argument><expr><name><name>intern</name>-&gt;<name>tmp_bb</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>intern</name>-&gt;<name>state</name></name> = <name>PARSE_PRE_HEAD</name></expr>;</expr_stmt>
<break>break;</break>
</case>}</block></switch>
}</block></while>
<if>if <condition>(<expr><name><name>intern</name>-&gt;<name>seen_eos</name></name></expr>)</condition><then> <block>{
<if>if <condition>(<expr><name>PARSE_HEAD</name> == <name><name>intern</name>-&gt;<name>state</name></name></expr>)</condition><then> <block>{
<if>if <condition>(<expr><name><name>ctx</name>-&gt;<name>flags</name></name> &amp; <name>SSI_FLAG_PRINTING</name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>char</name> *</type><name>to_release</name> <init>= <expr><call><name>apr_pmemdup</name><argument_list>(<argument><expr><name><name>ctx</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name><name>intern</name>-&gt;<name>start_seq</name></name></expr></argument>,
<argument><expr><name><name>intern</name>-&gt;<name>parse_pos</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>APR_BRIGADE_INSERT_TAIL</name><argument_list>(<argument><expr><name>pass_bb</name></expr></argument>,
<argument><expr><call><name>apr_bucket_pool_create</name><argument_list>(<argument><expr><name>to_release</name></expr></argument>,
<argument><expr><name><name>intern</name>-&gt;<name>parse_pos</name></name></expr></argument>, <argument><expr><name><name>ctx</name>-&gt;<name>pool</name></name></expr></argument>,
<argument><expr><name><name>f</name>-&gt;<name>c</name>-&gt;<name>bucket_alloc</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
}</block></then> <else>else <if>if <condition>(<expr><name>PARSE_PRE_HEAD</name> != <name><name>intern</name>-&gt;<name>state</name></name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>ap_log_rerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_ERR</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>01372</expr></argument>)</argument_list></call>
"SSI directive was not properly finished at the end "
"of parsed document %s"</expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>filename</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>ctx</name>-&gt;<name>flags</name></name> &amp; <name>SSI_FLAG_PRINTING</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>SSI_CREATE_ERROR_BUCKET</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>f</name></expr></argument>, <argument><expr><name>pass_bb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
}</block></then></if></else></if>
<if>if <condition>(<expr>!(<name><name>ctx</name>-&gt;<name>flags</name></name> &amp; <name>SSI_FLAG_PRINTING</name>)</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>ap_log_rerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_WARNING</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>01373</expr></argument>)</argument_list></call>
"missing closing endif directive in parsed document"
" %s"</expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>filename</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><call><name>apr_brigade_destroy</name><argument_list>(<argument><expr><name><name>intern</name>-&gt;<name>tmp_bb</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>apr_pool_destroy</name><argument_list>(<argument><expr><name><name>ctx</name>-&gt;<name>dpool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>APR_BRIGADE_INSERT_TAIL</name><argument_list>(<argument><expr><name>pass_bb</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<if>if <condition>(<expr>!<call><name>APR_BRIGADE_EMPTY</name><argument_list>(<argument><expr><name>pass_bb</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><name>rv</name> = <call><name>ap_pass_brigade</name><argument_list>(<argument><expr><name><name>f</name>-&gt;<name>next</name></name></expr></argument>, <argument><expr><name>pass_bb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr><name>rv</name> = <name>APR_SUCCESS</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>apr_brigade_destroy</name><argument_list>(<argument><expr><name>pass_bb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></else></if>
<return>return <expr><name>rv</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>includes_setup</name><parameter_list>(<param><decl><type><name>ap_filter_t</name> *</type><name>f</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>include_dir_config</name> *</type><name>conf</name> <init>= <expr><call><name>ap_get_module_config</name><argument_list>(<argument><expr><name><name>f</name>-&gt;<name>r</name>-&gt;<name>per_dir_config</name></name></expr></argument>,
<argument><expr>&amp;<name>include_module</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr>(<name><name>conf</name>-&gt;<name>xbithack</name></name> != <name>XBITHACK_FULL</name>)
|| !(<name><name>f</name>-&gt;<name>r</name>-&gt;<name>finfo</name>.<name>valid</name></name> &amp; <name>APR_FINFO_GPROT</name>)
|| !(<name><name>f</name>-&gt;<name>r</name>-&gt;<name>finfo</name>.<name>protection</name></name> &amp; <name>APR_GEXECUTE</name>)</expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>f</name>-&gt;<name>r</name>-&gt;<name>no_local_copy</name></name> = 1</expr>;</expr_stmt>
}</block></then></if>
<if>if <condition>(<expr><name><name>conf</name>-&gt;<name>etag</name></name> &lt;= 0</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>apr_table_setn</name><argument_list>(<argument><expr><name><name>f</name>-&gt;<name>r</name>-&gt;<name>notes</name></name></expr></argument>, <argument><expr>"no-etag"</expr></argument>, <argument><expr>""</expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<return>return <expr><name>OK</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>apr_status_t</name></type> <name>includes_filter</name><parameter_list>(<param><decl><type><name>ap_filter_t</name> *</type><name>f</name></decl></param>, <param><decl><type><name>apr_bucket_brigade</name> *</type><name>b</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>request_rec</name> *</type><name>r</name> <init>= <expr><name><name>f</name>-&gt;<name>r</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>request_rec</name> *</type><name>parent</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>include_dir_config</name> *</type><name>conf</name> <init>= <expr><call><name>ap_get_module_config</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>per_dir_config</name></name></expr></argument>,
<argument><expr>&amp;<name>include_module</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>include_server_config</name> *</type><name>sconf</name><init>= <expr><call><name>ap_get_module_config</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>server</name>-&gt;<name>module_config</name></name></expr></argument>,
<argument><expr>&amp;<name>include_module</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr>!(<call><name>ap_allow_options</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call> &amp; <name>OPT_INCLUDES</name>)</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>ap_log_rerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_WARNING</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>01374</expr></argument>)</argument_list></call>
"mod_include: Options +Includes (or IncludesNoExec) "
"wasn't set, INCLUDES filter removed: %s"</expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>uri</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ap_remove_output_filter</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>ap_pass_brigade</name><argument_list>(<argument><expr><name><name>f</name>-&gt;<name>next</name></name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></then></if>
<if>if <condition>(<expr>!<name><name>f</name>-&gt;<name>ctx</name></name></expr>)</condition><then> <block>{
<decl_stmt><decl><type>struct <name>ssi_internal_ctx</name> *</type><name>intern</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>include_ctx_t</name> *</type><name>ctx</name></decl>;</decl_stmt>
<expr_stmt><expr><name><name>f</name>-&gt;<name>ctx</name></name> = <name>ctx</name> = <call><name>apr_palloc</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>*<name>ctx</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ctx</name>-&gt;<name>r</name></name> = <name>r</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ctx</name>-&gt;<name>intern</name></name> = <name>intern</name> = <call><name>apr_palloc</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>*<name><name>ctx</name>-&gt;<name>intern</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ctx</name>-&gt;<name>pool</name></name> = <name><name>r</name>-&gt;<name>pool</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>apr_pool_create</name><argument_list>(<argument><expr>&amp;<name><name>ctx</name>-&gt;<name>dpool</name></name></expr></argument>, <argument><expr><name><name>ctx</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>intern</name>-&gt;<name>tmp_bb</name></name> = <call><name>apr_brigade_create</name><argument_list>(<argument><expr><name><name>ctx</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name><name>f</name>-&gt;<name>c</name>-&gt;<name>bucket_alloc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>intern</name>-&gt;<name>seen_eos</name></name> = 0</expr>;</expr_stmt>
<expr_stmt><expr><name><name>intern</name>-&gt;<name>state</name></name> = <name>PARSE_PRE_HEAD</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ctx</name>-&gt;<name>flags</name></name> = (<name>SSI_FLAG_PRINTING</name> | <name>SSI_FLAG_COND_TRUE</name>)</expr>;</expr_stmt>
<if>if <condition>(<expr>(<call><name>ap_allow_options</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call> &amp; <name>OPT_INC_WITH_EXEC</name>) == 0</expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>ctx</name>-&gt;<name>flags</name></name> |= <name>SSI_FLAG_NO_EXEC</name></expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><name><name>intern</name>-&gt;<name>legacy_expr</name></name> = (<name><name>conf</name>-&gt;<name>legacy_expr</name></name> &gt; 0)</expr>;</expr_stmt>
<expr_stmt><expr><name><name>intern</name>-&gt;<name>expr_eval_ctx</name></name> = <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>intern</name>-&gt;<name>expr_err</name></name> = <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>intern</name>-&gt;<name>expr_vary_this</name></name> = <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ctx</name>-&gt;<name>if_nesting_level</name></name> = 0</expr>;</expr_stmt>
<expr_stmt><expr><name><name>intern</name>-&gt;<name>re</name></name> = <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ctx</name>-&gt;<name>error_str</name></name> = <name><name>conf</name>-&gt;<name>default_error_msg</name></name> ? <name><name>conf</name>-&gt;<name>default_error_msg</name></name> :
<name>DEFAULT_ERROR_MSG</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ctx</name>-&gt;<name>time_str</name></name> = <name><name>conf</name>-&gt;<name>default_time_fmt</name></name> ? <name><name>conf</name>-&gt;<name>default_time_fmt</name></name> :
<name>DEFAULT_TIME_FORMAT</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>intern</name>-&gt;<name>start_seq</name></name> = <name><name>sconf</name>-&gt;<name>default_start_tag</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>intern</name>-&gt;<name>start_seq_pat</name></name> = <call><name>bndm_compile</name><argument_list>(<argument><expr><name><name>ctx</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name><name>intern</name>-&gt;<name>start_seq</name></name></expr></argument>,
<argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name><name>intern</name>-&gt;<name>start_seq</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>intern</name>-&gt;<name>end_seq</name></name> = <name><name>sconf</name>-&gt;<name>default_end_tag</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>intern</name>-&gt;<name>end_seq_len</name></name> = <call><name>strlen</name><argument_list>(<argument><expr><name><name>intern</name>-&gt;<name>end_seq</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>intern</name>-&gt;<name>undefined_echo</name></name> = <name><name>conf</name>-&gt;<name>undefined_echo</name></name> ? <name><name>conf</name>-&gt;<name>undefined_echo</name></name> :
<name>DEFAULT_UNDEFINED_ECHO</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>intern</name>-&gt;<name>undefined_echo_len</name></name> = <call><name>strlen</name><argument_list>(<argument><expr><name><name>intern</name>-&gt;<name>undefined_echo</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<if>if <condition>(<expr>(<name>parent</name> = <call><name>ap_get_module_config</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>request_config</name></name></expr></argument>, <argument><expr>&amp;<name>include_module</name></expr></argument>)</argument_list></call>)</expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>r</name>-&gt;<name>subprocess_env</name></name> = <name><name>r</name>-&gt;<name/></name>main-&gt;<name>subprocess_env</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>apr_pool_join</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name/></name>main-&gt;<name>pool</name></expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>r</name>-&gt;<name>finfo</name>.<name>mtime</name></name> = <name><name>r</name>-&gt;<name/></name>main-&gt;<name><name>finfo</name>.<name>mtime</name></name></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr><call><name>ap_add_common_vars</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ap_add_cgi_vars</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>add_include_vars</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></else></if>
<expr_stmt><expr><call><name>apr_table_unset</name><argument_list>(<argument><expr><name><name>f</name>-&gt;<name>r</name>-&gt;<name>headers_out</name></name></expr></argument>, <argument><expr>"Content-Length"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>conf</name>-&gt;<name>lastmodified</name></name> &gt; 0</expr>)</condition><then> <block>{
<if>if <condition>(<expr><name><name>r</name>-&gt;<name>finfo</name>.<name>valid</name></name> &amp; <name>APR_FINFO_MTIME</name>
&amp;&amp; !<call><name>apr_table_get</name><argument_list>(<argument><expr><name><name>f</name>-&gt;<name>r</name>-&gt;<name>headers_out</name></name></expr></argument>, <argument><expr>"Last-Modified"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>ap_update_mtime</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>finfo</name>.<name>mtime</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ap_set_last_modified</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
}</block></then>
<else>else <if>if <condition>(<expr>((<name><name>conf</name>-&gt;<name>xbithack</name></name> == <name>XBITHACK_FULL</name> ||
(<name><name>conf</name>-&gt;<name>xbithack</name></name> == <name>XBITHACK_UNSET</name> &amp;&amp;
<name>DEFAULT_XBITHACK</name> == <name>XBITHACK_FULL</name>))
&amp;&amp; (<name><name>r</name>-&gt;<name>finfo</name>.<name>valid</name></name> &amp; <name>APR_FINFO_GPROT</name>)
&amp;&amp; (<name><name>r</name>-&gt;<name>finfo</name>.<name>protection</name></name> &amp; <name>APR_GEXECUTE</name>))</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>ap_update_mtime</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>finfo</name>.<name>mtime</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ap_set_last_modified</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr><call><name>apr_table_unset</name><argument_list>(<argument><expr><name><name>f</name>-&gt;<name>r</name>-&gt;<name>headers_out</name></name></expr></argument>, <argument><expr>"Last-Modified"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></else></if></else></if>
<if>if <condition>(<expr><name><name>r</name>-&gt;<name>args</name></name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>char</name> *</type><name>arg_copy</name> <init>= <expr><call><name>apr_pstrdup</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>args</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>apr_table_setn</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>subprocess_env</name></name></expr></argument>, <argument><expr>"QUERY_STRING"</expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>args</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ap_unescape_url</name><argument_list>(<argument><expr><name>arg_copy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>apr_table_setn</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>subprocess_env</name></name></expr></argument>, <argument><expr>"QUERY_STRING_UNESCAPED"</expr></argument>,
<argument><expr><call><name>ap_escape_shell_cmd</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>arg_copy</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<return>return <expr><call><name>send_parsed_content</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>include_fixup</name><parameter_list>(<param><decl><type><name>request_rec</name> *</type><name>r</name></decl></param>)</parameter_list> <block>{
<if>if <condition>(<expr><name><name>r</name>-&gt;<name>handler</name></name> &amp;&amp; (<call><name>strcmp</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>handler</name></name></expr></argument>, <argument><expr>"server-parsed"</expr></argument>)</argument_list></call> == 0)</expr>)</condition><then> <block>{
<if>if <condition>(<expr>!<name><name>r</name>-&gt;<name>content_type</name></name> || !*<name><name>r</name>-&gt;<name>content_type</name></name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>ap_set_content_type</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr>"text/html"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><name><name>r</name>-&gt;<name>handler</name></name> = "default-handler"</expr>;</expr_stmt>
}</block></then> <else>else
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>OS2</name></expr></argument>)</argument_list></call> || <call><name>defined</name><argument_list>(<argument><expr><name>WIN32</name></expr></argument>)</argument_list></call> || <call><name>defined</name><argument_list>(<argument><expr><name>NETWARE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<block>{
<return>return <expr><name>DECLINED</name></expr>;</return>
}</block></else></if>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<block>{
<decl_stmt><decl><type><name>include_dir_config</name> *</type><name>conf</name> <init>= <expr><call><name>ap_get_module_config</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>per_dir_config</name></name></expr></argument>,
<argument><expr>&amp;<name>include_module</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name><name>conf</name>-&gt;<name>xbithack</name></name> == <name>XBITHACK_OFF</name> ||
(<name>DEFAULT_XBITHACK</name> == <name>XBITHACK_OFF</name> &amp;&amp;
<name><name>conf</name>-&gt;<name>xbithack</name></name> == <name>XBITHACK_UNSET</name>)</expr>)</condition><then> <block>{
<return>return <expr><name>DECLINED</name></expr>;</return>
}</block></then></if>
<if>if <condition>(<expr>!(<name><name>r</name>-&gt;<name>finfo</name>.<name>protection</name></name> &amp; <name>APR_UEXECUTE</name>)</expr>)</condition><then> <block>{
<return>return <expr><name>DECLINED</name></expr>;</return>
}</block></then></if>
<if>if <condition>(<expr>!<name><name>r</name>-&gt;<name>content_type</name></name> || <call><name>strncmp</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>content_type</name></name></expr></argument>, <argument><expr>"text/html"</expr></argument>, <argument><expr>9</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<return>return <expr><name>DECLINED</name></expr>;</return>
}</block></then></if>
}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><call><name>ap_add_output_filter</name><argument_list>(<argument><expr>"INCLUDES"</expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>connection</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>DECLINED</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>void</name> *</type><name>create_includes_dir_config</name><parameter_list>(<param><decl><type><name>apr_pool_t</name> *</type><name>p</name></decl></param>, <param><decl><type><name>char</name> *</type><name>dummy</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>include_dir_config</name> *</type><name>result</name> <init>= <expr><call><name>apr_pcalloc</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>include_dir_config</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>result</name>-&gt;<name>xbithack</name></name> = <name>XBITHACK_UNSET</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>result</name>-&gt;<name>lastmodified</name></name> = <name>UNSET</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>result</name>-&gt;<name>etag</name></name> = <name>UNSET</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>result</name>-&gt;<name>legacy_expr</name></name> = <name>UNSET</name></expr>;</expr_stmt>
<return>return <expr><name>result</name></expr>;</return>
}</block></function>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MERGE</name><parameter_list>(<param><type><name>b</name></type></param>,<param><type><name>o</name></type></param>,<param><type><name>n</name></type></param>,<param><type><name>val</name></type></param>,<param><type><name>unset</name></type></param>)</parameter_list></cpp:macro> <cpp:value>n-&gt;val = o-&gt;val != unset ? o-&gt;val : b-&gt;val</cpp:value></cpp:define>
<function><type><specifier>static</specifier> <name>void</name> *</type><name>merge_includes_dir_config</name><parameter_list>(<param><decl><type><name>apr_pool_t</name> *</type><name>p</name></decl></param>, <param><decl><type><name>void</name> *</type><name>basev</name></decl></param>, <param><decl><type><name>void</name> *</type><name>overridesv</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>include_dir_config</name> *</type><name>base</name> <init>= <expr>(<name>include_dir_config</name> *)<name>basev</name></expr></init>,
*<name>over</name> <init>= <expr>(<name>include_dir_config</name> *)<name>overridesv</name></expr></init>,
*<name>new</name> <init>= <expr><call><name>apr_palloc</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>include_dir_config</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>MERGE</name><argument_list>(<argument><expr><name>base</name></expr></argument>, <argument><expr><name>over</name></expr></argument>, <argument><expr><name>new</name></expr></argument>, <argument><expr><name>default_error_msg</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>MERGE</name><argument_list>(<argument><expr><name>base</name></expr></argument>, <argument><expr><name>over</name></expr></argument>, <argument><expr><name>new</name></expr></argument>, <argument><expr><name>default_time_fmt</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>MERGE</name><argument_list>(<argument><expr><name>base</name></expr></argument>, <argument><expr><name>over</name></expr></argument>, <argument><expr><name>new</name></expr></argument>, <argument><expr><name>undefined_echo</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>MERGE</name><argument_list>(<argument><expr><name>base</name></expr></argument>, <argument><expr><name>over</name></expr></argument>, <argument><expr><name>new</name></expr></argument>, <argument><expr><name>xbithack</name></expr></argument>, <argument><expr><name>XBITHACK_UNSET</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>MERGE</name><argument_list>(<argument><expr><name>base</name></expr></argument>, <argument><expr><name>over</name></expr></argument>, <argument><expr><name>new</name></expr></argument>, <argument><expr><name>lastmodified</name></expr></argument>, <argument><expr><name>UNSET</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>MERGE</name><argument_list>(<argument><expr><name>base</name></expr></argument>, <argument><expr><name>over</name></expr></argument>, <argument><expr><name>new</name></expr></argument>, <argument><expr><name>etag</name></expr></argument>, <argument><expr><name>UNSET</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>MERGE</name><argument_list>(<argument><expr><name>base</name></expr></argument>, <argument><expr><name>over</name></expr></argument>, <argument><expr><name>new</name></expr></argument>, <argument><expr><name>legacy_expr</name></expr></argument>, <argument><expr><name>UNSET</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>new</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>void</name> *</type><name>create_includes_server_config</name><parameter_list>(<param><decl><type><name>apr_pool_t</name> *</type><name>p</name></decl></param>, <param><decl><type><name>server_rec</name> *</type><name>server</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>include_server_config</name> *</type><name>result</name></decl>;</decl_stmt>
<expr_stmt><expr><name>result</name> = <call><name>apr_palloc</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>include_server_config</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>result</name>-&gt;<name>default_end_tag</name></name> = <name>DEFAULT_END_SEQUENCE</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>result</name>-&gt;<name>default_start_tag</name></name> = <name>DEFAULT_START_SEQUENCE</name></expr>;</expr_stmt>
<return>return <expr><name>result</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> *</type><name>set_xbithack</name><parameter_list>(<param><decl><type><name>cmd_parms</name> *</type><name>cmd</name></decl></param>, <param><decl><type><name>void</name> *</type><name>mconfig</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>arg</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>include_dir_config</name> *</type><name>conf</name> <init>= <expr><name>mconfig</name></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>strcasecmp</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr>"off"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>conf</name>-&gt;<name>xbithack</name></name> = <name>XBITHACK_OFF</name></expr>;</expr_stmt>
}</block></then> <else>else <if>if <condition>(<expr>!<call><name>strcasecmp</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr>"on"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>conf</name>-&gt;<name>xbithack</name></name> = <name>XBITHACK_ON</name></expr>;</expr_stmt>
}</block></then> <else>else <if>if <condition>(<expr>!<call><name>strcasecmp</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr>"full"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>conf</name>-&gt;<name>xbithack</name></name> = <name>XBITHACK_FULL</name></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<return>return <expr>"XBitHack must be set to Off, On, or Full"</expr>;</return>
}</block></else></if></else></if></else></if>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> *</type><name>set_default_start_tag</name><parameter_list>(<param><decl><type><name>cmd_parms</name> *</type><name>cmd</name></decl></param>, <param><decl><type><name>void</name> *</type><name>mconfig</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>tag</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>include_server_config</name> *</type><name>conf</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>p</name> <init>= <expr><name>tag</name></expr></init></decl>;</decl_stmt>
<while>while <condition>(<expr>*<name>p</name></expr>)</condition> <block>{
<if>if <condition>(<expr><call><name>apr_isspace</name><argument_list>(<argument><expr>*<name>p</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<return>return <expr>"SSIStartTag may not contain any whitespaces"</expr>;</return>
}</block></then></if>
<expr_stmt><expr>++<name>p</name></expr>;</expr_stmt>
}</block></while>
<expr_stmt><expr><name>conf</name>= <call><name>ap_get_module_config</name><argument_list>(<argument><expr><name><name>cmd</name>-&gt;<name>server</name>-&gt;<name>module_config</name></name></expr></argument> , <argument><expr>&amp;<name>include_module</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>conf</name>-&gt;<name>default_start_tag</name></name> = <name>tag</name></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> *</type><name>set_default_end_tag</name><parameter_list>(<param><decl><type><name>cmd_parms</name> *</type><name>cmd</name></decl></param>, <param><decl><type><name>void</name> *</type><name>mconfig</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>tag</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>include_server_config</name> *</type><name>conf</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>p</name> <init>= <expr><name>tag</name></expr></init></decl>;</decl_stmt>
<while>while <condition>(<expr>*<name>p</name></expr>)</condition> <block>{
<if>if <condition>(<expr><call><name>apr_isspace</name><argument_list>(<argument><expr>*<name>p</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<return>return <expr>"SSIEndTag may not contain any whitespaces"</expr>;</return>
}</block></then></if>
<expr_stmt><expr>++<name>p</name></expr>;</expr_stmt>
}</block></while>
<expr_stmt><expr><name>conf</name>= <call><name>ap_get_module_config</name><argument_list>(<argument><expr><name><name>cmd</name>-&gt;<name>server</name>-&gt;<name>module_config</name></name></expr></argument> , <argument><expr>&amp;<name>include_module</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>conf</name>-&gt;<name>default_end_tag</name></name> = <name>tag</name></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> *</type><name>set_undefined_echo</name><parameter_list>(<param><decl><type><name>cmd_parms</name> *</type><name>cmd</name></decl></param>, <param><decl><type><name>void</name> *</type><name>mconfig</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>msg</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>include_dir_config</name> *</type><name>conf</name> <init>= <expr><name>mconfig</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>conf</name>-&gt;<name>undefined_echo</name></name> = <name>msg</name></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> *</type><name>set_default_error_msg</name><parameter_list>(<param><decl><type><name>cmd_parms</name> *</type><name>cmd</name></decl></param>, <param><decl><type><name>void</name> *</type><name>mconfig</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>msg</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>include_dir_config</name> *</type><name>conf</name> <init>= <expr><name>mconfig</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>conf</name>-&gt;<name>default_error_msg</name></name> = <name>msg</name></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> *</type><name>set_default_time_fmt</name><parameter_list>(<param><decl><type><name>cmd_parms</name> *</type><name>cmd</name></decl></param>, <param><decl><type><name>void</name> *</type><name>mconfig</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>fmt</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>include_dir_config</name> *</type><name>conf</name> <init>= <expr><name>mconfig</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>conf</name>-&gt;<name>default_time_fmt</name></name> = <name>fmt</name></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>include_post_config</name><parameter_list>(<param><decl><type><name>apr_pool_t</name> *</type><name>p</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>plog</name></decl></param>,
<param><decl><type><name>apr_pool_t</name> *</type><name>ptemp</name></decl></param>, <param><decl><type><name>server_rec</name> *</type><name>s</name></decl></param>)</parameter_list> <block>{
<expr_stmt><expr><name>include_handlers</name> = <call><name>apr_hash_make</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ssi_pfn_register</name> = <call><name>APR_RETRIEVE_OPTIONAL_FN</name><argument_list>(<argument><expr><name>ap_register_include_handler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>ssi_pfn_register</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>ssi_pfn_register</name><argument_list>(<argument><expr>"if"</expr></argument>, <argument><expr><name>handle_if</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ssi_pfn_register</name><argument_list>(<argument><expr>"set"</expr></argument>, <argument><expr><name>handle_set</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ssi_pfn_register</name><argument_list>(<argument><expr>"else"</expr></argument>, <argument><expr><name>handle_else</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ssi_pfn_register</name><argument_list>(<argument><expr>"elif"</expr></argument>, <argument><expr><name>handle_elif</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ssi_pfn_register</name><argument_list>(<argument><expr>"echo"</expr></argument>, <argument><expr><name>handle_echo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ssi_pfn_register</name><argument_list>(<argument><expr>"endif"</expr></argument>, <argument><expr><name>handle_endif</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ssi_pfn_register</name><argument_list>(<argument><expr>"fsize"</expr></argument>, <argument><expr><name>handle_fsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ssi_pfn_register</name><argument_list>(<argument><expr>"config"</expr></argument>, <argument><expr><name>handle_config</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ssi_pfn_register</name><argument_list>(<argument><expr>"comment"</expr></argument>, <argument><expr><name>handle_comment</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ssi_pfn_register</name><argument_list>(<argument><expr>"include"</expr></argument>, <argument><expr><name>handle_include</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ssi_pfn_register</name><argument_list>(<argument><expr>"flastmod"</expr></argument>, <argument><expr><name>handle_flastmod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ssi_pfn_register</name><argument_list>(<argument><expr>"printenv"</expr></argument>, <argument><expr><name>handle_printenv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<return>return <expr><name>OK</name></expr>;</return>
}</block></function>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>command_rec</name></type> <name><name>includes_cmds</name><index>[]</index></name> <init>= <expr><block>{
<expr><call><name>AP_INIT_TAKE1</name><argument_list>(<argument><expr>"XBitHack"</expr></argument>, <argument><expr><name>set_xbithack</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>OR_OPTIONS</name></expr></argument>,
<argument><expr>"Off, On, or Full"</expr></argument>)</argument_list></call></expr>,
<expr><call><name>AP_INIT_TAKE1</name><argument_list>(<argument><expr>"SSIErrorMsg"</expr></argument>, <argument><expr><name>set_default_error_msg</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>OR_ALL</name></expr></argument>,
<argument><expr>"a string"</expr></argument>)</argument_list></call></expr>,
<expr><call><name>AP_INIT_TAKE1</name><argument_list>(<argument><expr>"SSITimeFormat"</expr></argument>, <argument><expr><name>set_default_time_fmt</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>OR_ALL</name></expr></argument>,
<argument><expr>"a strftime(3) formatted string"</expr></argument>)</argument_list></call></expr>,
<expr><call><name>AP_INIT_TAKE1</name><argument_list>(<argument><expr>"SSIStartTag"</expr></argument>, <argument><expr><name>set_default_start_tag</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>RSRC_CONF</name></expr></argument>,
<argument><expr>"SSI Start String Tag"</expr></argument>)</argument_list></call></expr>,
<expr><call><name>AP_INIT_TAKE1</name><argument_list>(<argument><expr>"SSIEndTag"</expr></argument>, <argument><expr><name>set_default_end_tag</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>RSRC_CONF</name></expr></argument>,
<argument><expr>"SSI End String Tag"</expr></argument>)</argument_list></call></expr>,
<expr><call><name>AP_INIT_TAKE1</name><argument_list>(<argument><expr>"SSIUndefinedEcho"</expr></argument>, <argument><expr><name>set_undefined_echo</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>OR_ALL</name></expr></argument>,
<argument><expr>"String to be displayed if an echoed variable is undefined"</expr></argument>)</argument_list></call></expr>,
<expr><call><name>AP_INIT_FLAG</name><argument_list>(<argument><expr>"SSILegacyExprParser"</expr></argument>, <argument><expr><name>ap_set_flag_slot_char</name></expr></argument>,
<argument><expr>(<name>void</name> *)<call><name>APR_OFFSETOF</name><argument_list>(<argument><expr><name>include_dir_config</name></expr></argument>, <argument><expr><name>legacy_expr</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>OR_LIMIT</name></expr></argument>,
<argument><expr>"Whether to use the legacy expression parser compatible "
"with &lt;= 2.2.x. Limited to 'on' or 'off'"</expr></argument>)</argument_list></call></expr>,
<expr><call><name>AP_INIT_FLAG</name><argument_list>(<argument><expr>"SSILastModified"</expr></argument>, <argument><expr><name>ap_set_flag_slot_char</name></expr></argument>,
<argument><expr>(<name>void</name> *)<call><name>APR_OFFSETOF</name><argument_list>(<argument><expr><name>include_dir_config</name></expr></argument>, <argument><expr><name>lastmodified</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>OR_LIMIT</name></expr></argument>, <argument><expr>"Whether to set the last modified header or respect "
"an existing header. Limited to 'on' or 'off'"</expr></argument>)</argument_list></call></expr>,
<expr><call><name>AP_INIT_FLAG</name><argument_list>(<argument><expr>"SSIEtag"</expr></argument>, <argument><expr><name>ap_set_flag_slot_char</name></expr></argument>,
<argument><expr>(<name>void</name> *)<call><name>APR_OFFSETOF</name><argument_list>(<argument><expr><name>include_dir_config</name></expr></argument>, <argument><expr><name>etag</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>OR_LIMIT</name></expr></argument>, <argument><expr>"Whether to allow the generation of ETags within the server. "
"Existing ETags will be preserved. Limited to 'on' or 'off'"</expr></argument>)</argument_list></call></expr>,
<expr><block>{<expr><name>NULL</name></expr>}</block></expr>
}</block></expr></init></decl>;</decl_stmt>
<function><type><specifier>static</specifier> <name>void</name></type> <name>ap_register_include_handler</name><parameter_list>(<param><decl><type><name>char</name> *</type><name>tag</name></decl></param>, <param><decl><type><name>include_handler_fn_t</name> *</type><name>func</name></decl></param>)</parameter_list> <block>{
<expr_stmt><expr><call><name>apr_hash_set</name><argument_list>(<argument><expr><name>include_handlers</name></expr></argument>, <argument><expr><name>tag</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>tag</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>(const <name>void</name> *)<name>func</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>register_hooks</name><parameter_list>(<param><decl><type><name>apr_pool_t</name> *</type><name>p</name></decl></param>)</parameter_list> <block>{
<expr_stmt><expr><call><name>APR_REGISTER_OPTIONAL_FN</name><argument_list>(<argument><expr><name>ap_ssi_get_tag_and_value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>APR_REGISTER_OPTIONAL_FN</name><argument_list>(<argument><expr><name>ap_ssi_parse_string</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>APR_REGISTER_OPTIONAL_FN</name><argument_list>(<argument><expr><name>ap_register_include_handler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ap_hook_post_config</name><argument_list>(<argument><expr><name>include_post_config</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>APR_HOOK_REALLY_FIRST</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ap_hook_fixups</name><argument_list>(<argument><expr><name>include_fixup</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>APR_HOOK_LAST</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ap_register_output_filter</name><argument_list>(<argument><expr>"INCLUDES"</expr></argument>, <argument><expr><name>includes_filter</name></expr></argument>, <argument><expr><name>includes_setup</name></expr></argument>,
<argument><expr><name>AP_FTYPE_RESOURCE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>
<expr_stmt><expr><call><name>AP_DECLARE_MODULE</name><argument_list>(<argument><expr><name>include</name></expr></argument>)</argument_list></call> = <block>{
<expr><name>STANDARD20_MODULE_STUFF</name></expr>,
<expr><name>create_includes_dir_config</name></expr>,
<expr><name>merge_includes_dir_config</name></expr>,
<expr><name>create_includes_server_config</name></expr>,
<expr><name>NULL</name></expr>,
<expr><name>includes_cmds</name></expr>,
<expr><name>register_hooks</name></expr>
}</block></expr>;</expr_stmt>
</unit>
