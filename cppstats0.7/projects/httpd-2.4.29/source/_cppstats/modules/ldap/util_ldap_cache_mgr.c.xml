<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C" filename="projects/httpd-2.4.29/_cppstats/modules/ldap/util_ldap_cache_mgr.c"><cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"httpd.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"util_ldap.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"util_ldap_cache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;apr_strings.h&gt;</cpp:file></cpp:include>
<expr_stmt><expr><call><name>APLOG_USE_MODULE</name><argument_list>(<argument><expr><name>ldap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>APR_HAS_LDAP</name></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdlib.h&gt;</cpp:file></cpp:include>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>unsigned</name> <name>long</name></type> <name><name>primes</name><index>[]</index></name> <init>= <expr><block>{
<expr>11</expr>,
<expr>19</expr>,
<expr>37</expr>,
<expr>73</expr>,
<expr>109</expr>,
<expr>163</expr>,
<expr>251</expr>,
<expr>367</expr>,
<expr>557</expr>,
<expr>823</expr>,
<expr>1237</expr>,
<expr>1861</expr>,
<expr>2777</expr>,
<expr>4177</expr>,
<expr>6247</expr>,
<expr>9371</expr>,
<expr>14057</expr>,
<expr>21089</expr>,
<expr>31627</expr>,
<expr>47431</expr>,
<expr>71143</expr>,
<expr>106721</expr>,
<expr>160073</expr>,
<expr>240101</expr>,
<expr>360163</expr>,
<expr>540217</expr>,
<expr>810343</expr>,
<expr>1215497</expr>,
<expr>1823231</expr>,
<expr>2734867</expr>,
<expr>4102283</expr>,
<expr>6153409</expr>,
<expr>9230113</expr>,
<expr>13845163</expr>,
<expr>0</expr>
}</block></expr></init></decl>;</decl_stmt>
<function><type><name>void</name></type> <name>util_ald_free</name><parameter_list>(<param><decl><type><name>util_ald_cache_t</name> *</type><name>cache</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>void</name> *</type><name>ptr</name></decl></param>)</parameter_list> <block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>APR_HAS_SHARED_MEMORY</name></expr></cpp:if>
<if>if <condition>(<expr><name><name>cache</name>-&gt;<name>rmm_addr</name></name></expr>)</condition><then> <block>{
<if>if <condition>(<expr><name>ptr</name></expr>)</condition><then>
<expr_stmt><expr><call><name>apr_rmm_free</name><argument_list>(<argument><expr><name><name>cache</name>-&gt;<name>rmm_addr</name></name></expr></argument>, <argument><expr><call><name>apr_rmm_offset_get</name><argument_list>(<argument><expr><name><name>cache</name>-&gt;<name>rmm_addr</name></name></expr></argument>, <argument><expr>(<name>void</name> *)<name>ptr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
}</block></then> <else>else <block>{
<if>if <condition>(<expr><name>ptr</name></expr>)</condition><then>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr>(<name>void</name> *)<name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
}</block></else></if>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<if>if <condition>(<expr><name>ptr</name></expr>)</condition><then>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr>(<name>void</name> *)<name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></function>
<function><type><name>void</name> *</type><name>util_ald_alloc</name><parameter_list>(<param><decl><type><name>util_ald_cache_t</name> *</type><name>cache</name></decl></param>, <param><decl><type><name>unsigned</name> <name>long</name></type> <name>size</name></decl></param>)</parameter_list> <block>{
<if>if <condition>(<expr>0 == <name>size</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>APR_HAS_SHARED_MEMORY</name></expr></cpp:if>
<if>if <condition>(<expr><name><name>cache</name>-&gt;<name>rmm_addr</name></name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>apr_rmm_off_t</name></type> <name>block</name> <init>= <expr><call><name>apr_rmm_calloc</name><argument_list>(<argument><expr><name><name>cache</name>-&gt;<name>rmm_addr</name></name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<return>return <expr><name>block</name> ? (<name>void</name> *)<call><name>apr_rmm_addr_get</name><argument_list>(<argument><expr><name><name>cache</name>-&gt;<name>rmm_addr</name></name></expr></argument>, <argument><expr><name>block</name></expr></argument>)</argument_list></call> : <name>NULL</name></expr>;</return>
}</block></then> <else>else <block>{
<return>return <expr>(<name>void</name> *)<call><name>calloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>char</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></else></if>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<return>return <expr>(<name>void</name> *)<call><name>calloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>char</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></function>
<function><type><specifier>const</specifier> <name>char</name> *</type><name>util_ald_strdup</name><parameter_list>(<param><decl><type><name>util_ald_cache_t</name> *</type><name>cache</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>s</name></decl></param>)</parameter_list> <block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>APR_HAS_SHARED_MEMORY</name></expr></cpp:if>
<if>if <condition>(<expr><name><name>cache</name>-&gt;<name>rmm_addr</name></name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>apr_rmm_off_t</name></type> <name>block</name> <init>= <expr><call><name>apr_rmm_calloc</name><argument_list>(<argument><expr><name><name>cache</name>-&gt;<name>rmm_addr</name></name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call>+1</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>buf</name> <init>= <expr><name>block</name> ? (<name>char</name> *)<call><name>apr_rmm_addr_get</name><argument_list>(<argument><expr><name><name>cache</name>-&gt;<name>rmm_addr</name></name></expr></argument>, <argument><expr><name>block</name></expr></argument>)</argument_list></call> : <name>NULL</name></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>buf</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>buf</name></expr>;</return>
}</block></then> <else>else <block>{
<return>return <expr><name>NULL</name></expr>;</return>
}</block></else></if>
}</block></then> <else>else <block>{
<return>return <expr><call><name>strdup</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></else></if>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<return>return <expr><call><name>strdup</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></function>
<function><type><name>util_compare_subgroup_t</name> *</type><name>util_ald_sgl_dup</name><parameter_list>(<param><decl><type><name>util_ald_cache_t</name> *</type><name>cache</name></decl></param>, <param><decl><type><name>util_compare_subgroup_t</name> *</type><name>sgl_in</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>util_compare_subgroup_t</name> *</type><name>sgl_out</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr>!<name>sgl_in</name></expr>)</condition><then> <block>{
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>sgl_out</name> = (<name>util_compare_subgroup_t</name> *) <call><name>util_ald_alloc</name><argument_list>(<argument><expr><name>cache</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>util_compare_subgroup_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>sgl_out</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>sgl_out</name>-&gt;<name>subgroupDNs</name></name> = <call><name>util_ald_alloc</name><argument_list>(<argument><expr><name>cache</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>char</name> *</expr></argument>)</argument_list></sizeof> * <name><name>sgl_in</name>-&gt;<name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>sgl_out</name>-&gt;<name>subgroupDNs</name></name></expr>)</condition><then> <block>{
<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name><name>sgl_in</name>-&gt;<name>len</name></name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
<expr_stmt><expr><name><name>sgl_out</name>-&gt;<name>subgroupDNs</name><index>[<expr><name>i</name></expr>]</index></name> = <call><name>util_ald_strdup</name><argument_list>(<argument><expr><name>cache</name></expr></argument>, <argument><expr><name><name>sgl_in</name>-&gt;<name>subgroupDNs</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name><name>sgl_out</name>-&gt;<name>subgroupDNs</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><then> <block>{
<for>for (<init><expr><name>i</name> = (<name>i</name> - 1)</expr>;</init> <condition><expr><name>i</name> &gt;= 0</expr>;</condition> <incr><expr><name>i</name>--</expr></incr>) <block>{
<expr_stmt><expr><call><name>util_ald_free</name><argument_list>(<argument><expr><name>cache</name></expr></argument>, <argument><expr><name><name>sgl_out</name>-&gt;<name>subgroupDNs</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></for>
<expr_stmt><expr><call><name>util_ald_free</name><argument_list>(<argument><expr><name>cache</name></expr></argument>, <argument><expr><name><name>sgl_out</name>-&gt;<name>subgroupDNs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>util_ald_free</name><argument_list>(<argument><expr><name>cache</name></expr></argument>, <argument><expr><name>sgl_out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>sgl_out</name> = <name>NULL</name></expr>;</expr_stmt>
<break>break;</break>
}</block></then></if>
}</block></for>
<if>if <condition>(<expr><name>sgl_out</name> != <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>sgl_out</name>-&gt;<name>len</name></name> = <name><name>sgl_in</name>-&gt;<name>len</name></name></expr>;</expr_stmt>
}</block></then></if>
}</block></then></if>
}</block></then></if>
<return>return <expr><name>sgl_out</name></expr>;</return>
}</block></function>
<function><type><name>void</name></type> <name>util_ald_sgl_free</name><parameter_list>(<param><decl><type><name>util_ald_cache_t</name> *</type><name>cache</name></decl></param>, <param><decl><type><name>util_compare_subgroup_t</name> **</type><name>sgl</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>sgl</name> == <name>NULL</name> || *<name>sgl</name> == <name>NULL</name></expr>)</condition><then> <block>{
<return>return;</return>
}</block></then></if>
<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>(*<name>sgl</name>)-&gt;<name>len</name></name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
<expr_stmt><expr><call><name>util_ald_free</name><argument_list>(<argument><expr><name>cache</name></expr></argument>, <argument><expr><name>(*<name>sgl</name>)-&gt;<name>subgroupDNs</name></name><index>[<expr><name>i</name></expr>]</index></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></for>
<expr_stmt><expr><call><name>util_ald_free</name><argument_list>(<argument><expr><name>cache</name></expr></argument>, <argument><expr>*<name>sgl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>
<function><type><name>unsigned</name> <name>long</name></type> <name>util_ald_hash_string</name><parameter_list>(<param><decl><type><name>int</name></type> <name>nstr</name></decl></param>, <param><decl><type>...</type></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>va_list</name></type> <name>args</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>h</name><init>=<expr>0</expr></init>, <name>g</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>str</name></decl>, *<decl><type ref="prev"/><name>p</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>nstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for (<init><expr><name>i</name>=0</expr>;</init> <condition><expr><name>i</name> &lt; <name>nstr</name></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>) <block>{
<expr_stmt><expr><name>str</name> = <call><name>va_arg</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>char</name> *</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for (<init><expr><name>p</name> = <name>str</name></expr>;</init> <condition><expr>*<name>p</name></expr>;</condition> <incr><expr>++<name>p</name></expr></incr>) <block>{
<expr_stmt><expr><name>h</name> = ( <name>h</name> &lt;&lt; 4 ) + *<name>p</name></expr>;</expr_stmt>
<if>if <condition>( <expr>( <name>g</name> = <name>h</name> &amp; 0xf0000000 )</expr> )</condition><then> <block>{
<expr_stmt><expr><name>h</name> = <name>h</name> ^ (<name>g</name> &gt;&gt; 24)</expr>;</expr_stmt>
<expr_stmt><expr><name>h</name> = <name>h</name> ^ <name>g</name></expr>;</expr_stmt>
}</block></then></if>
}</block></for>
}</block></for>
<expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>h</name></expr>;</return>
}</block></function>
<function><type><name>void</name></type> <name>util_ald_cache_purge</name><parameter_list>(<param><decl><type><name>util_ald_cache_t</name> *</type><name>cache</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>util_cache_node_t</name> *</type><name>p</name></decl>, *<decl><type ref="prev"/><name>q</name></decl>, **<decl><type ref="prev"/><name>pp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>apr_time_t</name></type> <name>t</name></decl>;</decl_stmt>
<if>if <condition>(<expr>!<name>cache</name></expr>)</condition><then>
<return>return;</return></then></if>
<expr_stmt><expr><name><name>cache</name>-&gt;<name>last_purge</name></name> = <call><name>apr_time_now</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cache</name>-&gt;<name>npurged</name></name> = 0</expr>;</expr_stmt>
<expr_stmt><expr><name><name>cache</name>-&gt;<name>numpurges</name></name>++</expr>;</expr_stmt>
<for>for (<init><expr><name>i</name>=0</expr>;</init> <condition><expr><name>i</name> &lt; <name><name>cache</name>-&gt;<name>size</name></name></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>) <block>{
<expr_stmt><expr><name>pp</name> = <name><name>cache</name>-&gt;<name>nodes</name></name> + <name>i</name></expr>;</expr_stmt>
<expr_stmt><expr><name>p</name> = *<name>pp</name></expr>;</expr_stmt>
<while>while <condition>(<expr><name>p</name> != <name>NULL</name></expr>)</condition> <block>{
<if>if <condition>(<expr><name><name>p</name>-&gt;<name>add_time</name></name> &lt; <name><name>cache</name>-&gt;<name>marktime</name></name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>q</name> = <name><name>p</name>-&gt;<name>next</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call>(*<name><name>cache</name>-&gt;<name>free</name></name>)<argument_list>(<argument><expr><name>cache</name></expr></argument>, <argument><expr><name><name>p</name>-&gt;<name>payload</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>util_ald_free</name><argument_list>(<argument><expr><name>cache</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cache</name>-&gt;<name>numentries</name></name>--</expr>;</expr_stmt>
<expr_stmt><expr><name><name>cache</name>-&gt;<name>npurged</name></name>++</expr>;</expr_stmt>
<expr_stmt><expr><name>p</name> = *<name>pp</name> = <name>q</name></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr><name>pp</name> = &amp;(<name><name>p</name>-&gt;<name>next</name></name>)</expr>;</expr_stmt>
<expr_stmt><expr><name>p</name> = *<name>pp</name></expr>;</expr_stmt>
}</block></else></if>
}</block></while>
}</block></for>
<expr_stmt><expr><name>t</name> = <call><name>apr_time_now</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cache</name>-&gt;<name>avg_purgetime</name></name> =
((<name>t</name> - <name><name>cache</name>-&gt;<name>last_purge</name></name>) + (<name><name>cache</name>-&gt;<name>avg_purgetime</name></name> * (<name><name>cache</name>-&gt;<name>numpurges</name></name>-1))) /
<name><name>cache</name>-&gt;<name>numpurges</name></name></expr>;</expr_stmt>
}</block></function>
<function><type><name>util_url_node_t</name> *</type><name>util_ald_create_caches</name><parameter_list>(<param><decl><type><name>util_ldap_state_t</name> *</type><name>st</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>url</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>util_url_node_t</name></type> <name>curl</name></decl>, *<decl><type ref="prev"/><name>newcurl</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>util_ald_cache_t</name> *</type><name>search_cache</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>util_ald_cache_t</name> *</type><name>compare_cache</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>util_ald_cache_t</name> *</type><name>dn_compare_cache</name></decl>;</decl_stmt>
<expr_stmt><expr><name>search_cache</name> = <call><name>util_ald_create_cache</name><argument_list>(<argument><expr><name>st</name></expr></argument>,
<argument><expr><name><name>st</name>-&gt;<name>search_cache_size</name></name></expr></argument>,
<argument><expr><name>util_ldap_search_node_hash</name></expr></argument>,
<argument><expr><name>util_ldap_search_node_compare</name></expr></argument>,
<argument><expr><name>util_ldap_search_node_copy</name></expr></argument>,
<argument><expr><name>util_ldap_search_node_free</name></expr></argument>,
<argument><expr><name>util_ldap_search_node_display</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>compare_cache</name> = <call><name>util_ald_create_cache</name><argument_list>(<argument><expr><name>st</name></expr></argument>,
<argument><expr><name><name>st</name>-&gt;<name>compare_cache_size</name></name></expr></argument>,
<argument><expr><name>util_ldap_compare_node_hash</name></expr></argument>,
<argument><expr><name>util_ldap_compare_node_compare</name></expr></argument>,
<argument><expr><name>util_ldap_compare_node_copy</name></expr></argument>,
<argument><expr><name>util_ldap_compare_node_free</name></expr></argument>,
<argument><expr><name>util_ldap_compare_node_display</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>dn_compare_cache</name> = <call><name>util_ald_create_cache</name><argument_list>(<argument><expr><name>st</name></expr></argument>,
<argument><expr><name><name>st</name>-&gt;<name>compare_cache_size</name></name></expr></argument>,
<argument><expr><name>util_ldap_dn_compare_node_hash</name></expr></argument>,
<argument><expr><name>util_ldap_dn_compare_node_compare</name></expr></argument>,
<argument><expr><name>util_ldap_dn_compare_node_copy</name></expr></argument>,
<argument><expr><name>util_ldap_dn_compare_node_free</name></expr></argument>,
<argument><expr><name>util_ldap_dn_compare_node_display</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>search_cache</name> &amp;&amp; <name>compare_cache</name> &amp;&amp; <name>dn_compare_cache</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>memset</name> <argument_list>(<argument><expr>&amp;<name>curl</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>util_url_node_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>curl</name>.<name>url</name></name> = <name>url</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>curl</name>.<name>search_cache</name></name> = <name>search_cache</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>curl</name>.<name>compare_cache</name></name> = <name>compare_cache</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>curl</name>.<name>dn_compare_cache</name></name> = <name>dn_compare_cache</name></expr>;</expr_stmt>
<expr_stmt><expr><name>newcurl</name> = <call><name>util_ald_cache_insert</name><argument_list>(<argument><expr><name><name>st</name>-&gt;<name>util_ldap_cache</name></name></expr></argument>, <argument><expr>&amp;<name>curl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<return>return <expr><name>newcurl</name></expr>;</return>
}</block></function>
<decl_stmt><decl><type><name>util_ald_cache_t</name> *</type><name>util_ald_create_cache</name><argument_list>(<argument><expr><name>util_ldap_state_t</name> *<name>st</name></expr></argument>,
<argument><expr><name>long</name> <name>cache_size</name></expr></argument>,
<argument><expr><name>unsigned</name> <call><call><name>long</name> <argument_list>(<argument><expr>*<name>hashfunc</name></expr></argument>)</argument_list></call><argument_list>(<argument><expr><name>void</name> *</expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><call><name>int</name> <argument_list>(<argument><expr>*<name>comparefunc</name></expr></argument>)</argument_list></call><argument_list>(<argument><expr><name>void</name> *</expr></argument>, <argument><expr><name>void</name> *</expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><call><name>void</name> * <argument_list>(<argument><expr>*<name>copyfunc</name></expr></argument>)</argument_list></call><argument_list>(<argument><expr><name>util_ald_cache_t</name> *<name>cache</name></expr></argument>, <argument><expr><name>void</name> *</expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><call><name>void</name> <argument_list>(<argument><expr>*<name>freefunc</name></expr></argument>)</argument_list></call><argument_list>(<argument><expr><name>util_ald_cache_t</name> *<name>cache</name></expr></argument>, <argument><expr><name>void</name> *</expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><call><name>void</name> <argument_list>(<argument><expr>*<name>displayfunc</name></expr></argument>)</argument_list></call><argument_list>(<argument><expr><name>request_rec</name> *<name>r</name></expr></argument>, <argument><expr><name>util_ald_cache_t</name> *<name>cache</name></expr></argument>, <argument><expr><name>void</name> *</expr></argument>)</argument_list></call></expr></argument>)</argument_list> <block>{
<decl_stmt><decl><type><name>util_ald_cache_t</name> *</type><name>cache</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>i</name></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>APR_HAS_SHARED_MEMORY</name></expr></cpp:if>
<decl_stmt><decl><type><name>apr_rmm_off_t</name></type> <name>block</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<if>if <condition>(<expr><name>cache_size</name> &lt;= 0</expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>APR_HAS_SHARED_MEMORY</name></expr></cpp:if>
<if>if <condition>(<expr>!<name><name>st</name>-&gt;<name>cache_rmm</name></name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>cache</name> = (<name>util_ald_cache_t</name> *)<call><name>calloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>util_ald_cache_t</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr><name>block</name> = <call><name>apr_rmm_calloc</name><argument_list>(<argument><expr><name><name>st</name>-&gt;<name>cache_rmm</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>util_ald_cache_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>cache</name> = <name>block</name> ? (<name>util_ald_cache_t</name> *)<call><name>apr_rmm_addr_get</name><argument_list>(<argument><expr><name><name>st</name>-&gt;<name>cache_rmm</name></name></expr></argument>, <argument><expr><name>block</name></expr></argument>)</argument_list></call> : <name>NULL</name></expr>;</expr_stmt>
}</block></else></if>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<expr_stmt><expr><name>cache</name> = (<name>util_ald_cache_t</name> *)<call><name>calloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>util_ald_cache_t</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<if>if <condition>(<expr>!<name>cache</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>APR_HAS_SHARED_MEMORY</name></expr></cpp:if>
<expr_stmt><expr><name><name>cache</name>-&gt;<name>rmm_addr</name></name> = <name><name>st</name>-&gt;<name>cache_rmm</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cache</name>-&gt;<name>shm_addr</name></name> = <name><name>st</name>-&gt;<name>cache_shm</name></name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><name><name>cache</name>-&gt;<name>maxentries</name></name> = <name>cache_size</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cache</name>-&gt;<name>numentries</name></name> = 0</expr>;</expr_stmt>
<expr_stmt><expr><name><name>cache</name>-&gt;<name>size</name></name> = <name>cache_size</name> / 3</expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>cache</name>-&gt;<name>size</name></name> &lt; 64</expr>)</condition><then>
<expr_stmt><expr><name><name>cache</name>-&gt;<name>size</name></name> = 64</expr>;</expr_stmt></then></if>
<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name><name>primes</name><index>[<expr><name>i</name></expr>]</index></name> &amp;&amp; <name><name>primes</name><index>[<expr><name>i</name></expr>]</index></name> &lt; <name><name>cache</name>-&gt;<name>size</name></name></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>)
<empty_stmt>;</empty_stmt></for>
<expr_stmt><expr><name><name>cache</name>-&gt;<name>size</name></name> = <name><name>primes</name><index>[<expr><name>i</name></expr>]</index></name> ? <name><name>primes</name><index>[<expr><name>i</name></expr>]</index></name> : <name><name>primes</name><index>[<expr><name>i</name>-1</expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cache</name>-&gt;<name>nodes</name></name> = (<name>util_cache_node_t</name> **)<call><name>util_ald_alloc</name><argument_list>(<argument><expr><name>cache</name></expr></argument>, <argument><expr><name><name>cache</name>-&gt;<name>size</name></name> * <sizeof>sizeof<argument_list>(<argument><expr><name>util_cache_node_t</name> *</expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name><name>cache</name>-&gt;<name>nodes</name></name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>util_ald_free</name><argument_list>(<argument><expr><name>cache</name></expr></argument>, <argument><expr><name>cache</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<for>for (<init><expr><name>i</name>=0</expr>;</init> <condition><expr><name>i</name> &lt; <name><name>cache</name>-&gt;<name>size</name></name></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>)
<expr_stmt><expr><name><name>cache</name>-&gt;<name>nodes</name><index>[<expr><name>i</name></expr>]</index></name> = <name>NULL</name></expr>;</expr_stmt></for>
<expr_stmt><expr><name><name>cache</name>-&gt;<name>hash</name></name> = <name>hashfunc</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cache</name>-&gt;<name>compare</name></name> = <name>comparefunc</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cache</name>-&gt;<name>copy</name></name> = <name>copyfunc</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cache</name>-&gt;<name>free</name></name> = <name>freefunc</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cache</name>-&gt;<name>display</name></name> = <name>displayfunc</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cache</name>-&gt;<name>fullmark</name></name> = <name><name>cache</name>-&gt;<name>maxentries</name></name> / 4 * 3</expr>;</expr_stmt>
<expr_stmt><expr><name><name>cache</name>-&gt;<name>marktime</name></name> = 0</expr>;</expr_stmt>
<expr_stmt><expr><name><name>cache</name>-&gt;<name>avg_purgetime</name></name> = 0.0</expr>;</expr_stmt>
<expr_stmt><expr><name><name>cache</name>-&gt;<name>numpurges</name></name> = 0</expr>;</expr_stmt>
<expr_stmt><expr><name><name>cache</name>-&gt;<name>last_purge</name></name> = 0</expr>;</expr_stmt>
<expr_stmt><expr><name><name>cache</name>-&gt;<name>npurged</name></name> = 0</expr>;</expr_stmt>
<expr_stmt><expr><name><name>cache</name>-&gt;<name>fetches</name></name> = 0</expr>;</expr_stmt>
<expr_stmt><expr><name><name>cache</name>-&gt;<name>hits</name></name> = 0</expr>;</expr_stmt>
<expr_stmt><expr><name><name>cache</name>-&gt;<name>inserts</name></name> = 0</expr>;</expr_stmt>
<expr_stmt><expr><name><name>cache</name>-&gt;<name>removes</name></name> = 0</expr>;</expr_stmt>
<return>return <expr><name>cache</name></expr>;</return>
}</block></decl></decl_stmt>
<function><type><name>void</name></type> <name>util_ald_destroy_cache</name><parameter_list>(<param><decl><type><name>util_ald_cache_t</name> *</type><name>cache</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>util_cache_node_t</name> *</type><name>p</name></decl>, *<decl><type ref="prev"/><name>q</name></decl>;</decl_stmt>
<if>if <condition>(<expr><name>cache</name> == <name>NULL</name></expr>)</condition><then>
<return>return;</return></then></if>
<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name><name>cache</name>-&gt;<name>size</name></name></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>) <block>{
<expr_stmt><expr><name>p</name> = <name><name>cache</name>-&gt;<name>nodes</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name>q</name> = <name>NULL</name></expr>;</expr_stmt>
<while>while <condition>(<expr><name>p</name> != <name>NULL</name></expr>)</condition> <block>{
<expr_stmt><expr><name>q</name> = <name><name>p</name>-&gt;<name>next</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call>(*<name><name>cache</name>-&gt;<name>free</name></name>)<argument_list>(<argument><expr><name>cache</name></expr></argument>, <argument><expr><name><name>p</name>-&gt;<name>payload</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>util_ald_free</name><argument_list>(<argument><expr><name>cache</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>p</name> = <name>q</name></expr>;</expr_stmt>
}</block></while>
}</block></for>
<expr_stmt><expr><call><name>util_ald_free</name><argument_list>(<argument><expr><name>cache</name></expr></argument>, <argument><expr><name><name>cache</name>-&gt;<name>nodes</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>util_ald_free</name><argument_list>(<argument><expr><name>cache</name></expr></argument>, <argument><expr><name>cache</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>
<function><type><name>void</name> *</type><name>util_ald_cache_fetch</name><parameter_list>(<param><decl><type><name>util_ald_cache_t</name> *</type><name>cache</name></decl></param>, <param><decl><type><name>void</name> *</type><name>payload</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>hashval</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>util_cache_node_t</name> *</type><name>p</name></decl>;</decl_stmt>
<if>if <condition>(<expr><name>cache</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name><name>cache</name>-&gt;<name>fetches</name></name>++</expr>;</expr_stmt>
<expr_stmt><expr><name>hashval</name> = <call>(*<name><name>cache</name>-&gt;<name>hash</name></name>)<argument_list>(<argument><expr><name>payload</name></expr></argument>)</argument_list></call> % <name><name>cache</name>-&gt;<name>size</name></name></expr>;</expr_stmt>
<for>for (<init><expr><name>p</name> = <name><name>cache</name>-&gt;<name>nodes</name><index>[<expr><name>hashval</name></expr>]</index></name></expr>;</init>
<condition><expr><name>p</name> &amp;&amp; !<call>(*<name><name>cache</name>-&gt;<name>compare</name></name>)<argument_list>(<argument><expr><name><name>p</name>-&gt;<name>payload</name></name></expr></argument>, <argument><expr><name>payload</name></expr></argument>)</argument_list></call></expr>;</condition>
<incr><expr><name>p</name> = <name><name>p</name>-&gt;<name>next</name></name></expr></incr>) <empty_stmt>;</empty_stmt></for>
<if>if <condition>(<expr><name>p</name> != <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>cache</name>-&gt;<name>hits</name></name>++</expr>;</expr_stmt>
<return>return <expr><name><name>p</name>-&gt;<name>payload</name></name></expr>;</return>
}</block></then> <else>else <block>{
<return>return <expr><name>NULL</name></expr>;</return>
}</block></else></if>
}</block></function>
<function><type><name>void</name> *</type><name>util_ald_cache_insert</name><parameter_list>(<param><decl><type><name>util_ald_cache_t</name> *</type><name>cache</name></decl></param>, <param><decl><type><name>void</name> *</type><name>payload</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>hashval</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>void</name> *</type><name>tmp_payload</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>util_cache_node_t</name> *</type><name>node</name></decl>;</decl_stmt>
<if>if <condition>(<expr><name>cache</name> == <name>NULL</name> || <name>payload</name> == <name>NULL</name></expr>)</condition><then> <block>{
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<if>if <condition>(<expr><name><name>cache</name>-&gt;<name>numentries</name></name> &gt;= <name><name>cache</name>-&gt;<name>maxentries</name></name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>util_ald_cache_purge</name><argument_list>(<argument><expr><name>cache</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>cache</name>-&gt;<name>numentries</name></name> &gt;= <name><name>cache</name>-&gt;<name>maxentries</name></name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_ERR</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>01323</expr></argument>)</argument_list></call>
"Purge of LDAP cache failed"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
}</block></then></if>
<expr_stmt><expr><name>node</name> = (<name>util_cache_node_t</name> *)<call><name>util_ald_alloc</name><argument_list>(<argument><expr><name>cache</name></expr></argument>,
<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>util_cache_node_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>node</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_WARNING</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>01324</expr></argument>)</argument_list></call>
"LDAPSharedCacheSize is too small. Increase it or "
"reduce LDAPCacheEntries/LDAPOpCacheEntries!"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>cache</name>-&gt;<name>numentries</name></name> &lt; <name><name>cache</name>-&gt;<name>fullmark</name></name></expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>cache</name>-&gt;<name>marktime</name></name> = <call><name>apr_time_now</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><call><name>util_ald_cache_purge</name><argument_list>(<argument><expr><name>cache</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>node</name> = (<name>util_cache_node_t</name> *)<call><name>util_ald_alloc</name><argument_list>(<argument><expr><name>cache</name></expr></argument>,
<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>util_cache_node_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>node</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_ERR</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>01325</expr></argument>)</argument_list></call>
"Could not allocate memory for LDAP cache entry"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
}</block></then></if>
<expr_stmt><expr><name>tmp_payload</name> = <call>(*<name><name>cache</name>-&gt;<name>copy</name></name>)<argument_list>(<argument><expr><name>cache</name></expr></argument>, <argument><expr><name>payload</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>tmp_payload</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_WARNING</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>01326</expr></argument>)</argument_list></call>
"LDAPSharedCacheSize is too small. Increase it or "
"reduce LDAPCacheEntries/LDAPOpCacheEntries!"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>cache</name>-&gt;<name>numentries</name></name> &lt; <name><name>cache</name>-&gt;<name>fullmark</name></name></expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>cache</name>-&gt;<name>marktime</name></name> = <call><name>apr_time_now</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><call><name>util_ald_cache_purge</name><argument_list>(<argument><expr><name>cache</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>tmp_payload</name> = <call>(*<name><name>cache</name>-&gt;<name>copy</name></name>)<argument_list>(<argument><expr><name>cache</name></expr></argument>, <argument><expr><name>payload</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>tmp_payload</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_ERR</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>01327</expr></argument>)</argument_list></call>
"Could not allocate memory for LDAP cache value"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>util_ald_free</name><argument_list>(<argument><expr><name>cache</name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
}</block></then></if>
<expr_stmt><expr><name>payload</name> = <name>tmp_payload</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cache</name>-&gt;<name>inserts</name></name>++</expr>;</expr_stmt>
<expr_stmt><expr><name>hashval</name> = <call>(*<name><name>cache</name>-&gt;<name>hash</name></name>)<argument_list>(<argument><expr><name>payload</name></expr></argument>)</argument_list></call> % <name><name>cache</name>-&gt;<name>size</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>node</name>-&gt;<name>add_time</name></name> = <call><name>apr_time_now</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>node</name>-&gt;<name>payload</name></name> = <name>payload</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>node</name>-&gt;<name>next</name></name> = <name><name>cache</name>-&gt;<name>nodes</name><index>[<expr><name>hashval</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cache</name>-&gt;<name>nodes</name><index>[<expr><name>hashval</name></expr>]</index></name> = <name>node</name></expr>;</expr_stmt>
<if>if <condition>(<expr>++<name><name>cache</name>-&gt;<name>numentries</name></name> == <name><name>cache</name>-&gt;<name>fullmark</name></name></expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>cache</name>-&gt;<name>marktime</name></name>=<call><name>apr_time_now</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<return>return <expr><name><name>node</name>-&gt;<name>payload</name></name></expr>;</return>
}</block></function>
<function><type><name>void</name></type> <name>util_ald_cache_remove</name><parameter_list>(<param><decl><type><name>util_ald_cache_t</name> *</type><name>cache</name></decl></param>, <param><decl><type><name>void</name> *</type><name>payload</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>hashval</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>util_cache_node_t</name> *</type><name>p</name></decl>, *<decl><type ref="prev"/><name>q</name></decl>;</decl_stmt>
<if>if <condition>(<expr><name>cache</name> == <name>NULL</name></expr>)</condition><then>
<return>return;</return></then></if>
<expr_stmt><expr><name><name>cache</name>-&gt;<name>removes</name></name>++</expr>;</expr_stmt>
<expr_stmt><expr><name>hashval</name> = <call>(*<name><name>cache</name>-&gt;<name>hash</name></name>)<argument_list>(<argument><expr><name>payload</name></expr></argument>)</argument_list></call> % <name><name>cache</name>-&gt;<name>size</name></name></expr>;</expr_stmt>
<for>for (<init><expr><name>p</name> = <name><name>cache</name>-&gt;<name>nodes</name><index>[<expr><name>hashval</name></expr>]</index></name></expr>, <expr><name>q</name>=<name>NULL</name></expr>;</init>
<condition><expr><name>p</name> &amp;&amp; !<call>(*<name><name>cache</name>-&gt;<name>compare</name></name>)<argument_list>(<argument><expr><name><name>p</name>-&gt;<name>payload</name></name></expr></argument>, <argument><expr><name>payload</name></expr></argument>)</argument_list></call></expr>;</condition>
<incr><expr><name>p</name> = <name><name>p</name>-&gt;<name>next</name></name></expr></incr>) <block>{
<expr_stmt><expr><name>q</name> = <name>p</name></expr>;</expr_stmt>
}</block></for>
<if>if <condition>(<expr><name>p</name> == <name>NULL</name></expr>)</condition><then>
<return>return;</return></then></if>
<if>if <condition>(<expr><name>q</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>cache</name>-&gt;<name>nodes</name><index>[<expr><name>hashval</name></expr>]</index></name> = <name><name>p</name>-&gt;<name>next</name></name></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr><name><name>q</name>-&gt;<name>next</name></name> = <name><name>p</name>-&gt;<name>next</name></name></expr>;</expr_stmt>
}</block></else></if>
<expr_stmt><expr><call>(*<name><name>cache</name>-&gt;<name>free</name></name>)<argument_list>(<argument><expr><name>cache</name></expr></argument>, <argument><expr><name><name>p</name>-&gt;<name>payload</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>util_ald_free</name><argument_list>(<argument><expr><name>cache</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cache</name>-&gt;<name>numentries</name></name>--</expr>;</expr_stmt>
}</block></function>
<function><type><name>char</name> *</type><name>util_ald_cache_display_stats</name><parameter_list>(<param><decl><type><name>request_rec</name> *</type><name>r</name></decl></param>, <param><decl><type><name>util_ald_cache_t</name> *</type><name>cache</name></decl></param>, <param><decl><type><name>char</name> *</type><name>name</name></decl></param>, <param><decl><type><name>char</name> *</type><name>id</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>totchainlen</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>nchains</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>double</name></type> <name>chainlen</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>util_cache_node_t</name> *</type><name>n</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>buf</name></decl>, *<decl><type ref="prev"/><name>buf2</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>p</name> <init>= <expr><name><name>r</name>-&gt;<name>pool</name></name></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>cache</name> == <name>NULL</name></expr>)</condition><then> <block>{
<return>return <expr>""</expr>;</return>
}</block></then></if>
<for>for (<init><expr><name>i</name>=0</expr>;</init> <condition><expr><name>i</name> &lt; <name><name>cache</name>-&gt;<name>size</name></name></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>) <block>{
<if>if <condition>(<expr><name><name>cache</name>-&gt;<name>nodes</name><index>[<expr><name>i</name></expr>]</index></name> != <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>nchains</name>++</expr>;</expr_stmt>
<for>for (<init><expr><name>n</name> = <name><name>cache</name>-&gt;<name>nodes</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</init>
<condition><expr><name>n</name> != <name>NULL</name> &amp;&amp; <name>n</name> != <name><name>n</name>-&gt;<name>next</name></name></expr>;</condition>
<incr><expr><name>n</name> = <name><name>n</name>-&gt;<name>next</name></name></expr></incr>) <block>{
<expr_stmt><expr><name>totchainlen</name>++</expr>;</expr_stmt>
}</block></for>
}</block></then></if>
}</block></for>
<expr_stmt><expr><name>chainlen</name> = <name>nchains</name>? (<name>double</name>)<name>totchainlen</name> / (<name>double</name>)<name>nchains</name> : 0</expr>;</expr_stmt>
<if>if <condition>(<expr><name>id</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>buf2</name> = <call><name>apr_psprintf</name><argument_list>(<argument><expr><name>p</name></expr></argument>,
<argument><expr>"&lt;a href=\"%s?%s\"&gt;%s&lt;/a&gt;"</expr></argument>,
<argument><expr><call><name>ap_escape_html</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><call><name>ap_escape_uri</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>uri</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>id</name></expr></argument>,
<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr><name>buf2</name> = <name>name</name></expr>;</expr_stmt>
}</block></else></if>
<expr_stmt><expr><name>buf</name> = <call><name>apr_psprintf</name><argument_list>(<argument><expr><name>p</name></expr></argument>,
<argument><expr>"&lt;tr valign='top'&gt;"
"&lt;td nowrap&gt;%s&lt;/td&gt;"
"&lt;td align='right' nowrap&gt;%lu (%.0f%% full)&lt;/td&gt;"
"&lt;td align='right'&gt;%.1f&lt;/td&gt;"
"&lt;td align='right'&gt;%lu/%lu&lt;/td&gt;"
"&lt;td align='right'&gt;%.0f%%&lt;/td&gt;"
"&lt;td align='right'&gt;%lu/%lu&lt;/td&gt;"</expr></argument>,
<argument><expr><name>buf2</name></expr></argument>,
<argument><expr><name><name>cache</name>-&gt;<name>numentries</name></name></expr></argument>,
<argument><expr>(<name>double</name>)<name><name>cache</name>-&gt;<name>numentries</name></name> / (<name>double</name>)<name><name>cache</name>-&gt;<name>maxentries</name></name> * 100.0</expr></argument>,
<argument><expr><name>chainlen</name></expr></argument>,
<argument><expr><name><name>cache</name>-&gt;<name>hits</name></name></expr></argument>,
<argument><expr><name><name>cache</name>-&gt;<name>fetches</name></name></expr></argument>,
<argument><expr>(<name><name>cache</name>-&gt;<name>fetches</name></name> &gt; 0 ? <call>(<name>double</name>)<argument_list>(<argument><expr><name><name>cache</name>-&gt;<name>hits</name></name></expr></argument>)</argument_list></call> / <call>(<name>double</name>)<argument_list>(<argument><expr><name><name>cache</name>-&gt;<name>fetches</name></name></expr></argument>)</argument_list></call> * 100.0 : 100.0)</expr></argument>,
<argument><expr><name><name>cache</name>-&gt;<name>inserts</name></name></expr></argument>,
<argument><expr><name><name>cache</name>-&gt;<name>removes</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>cache</name>-&gt;<name>numpurges</name></name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>char</name></type> <name><name>str_ctime</name><index>[<expr><name>APR_CTIME_LEN</name></expr>]</index></name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>apr_ctime</name><argument_list>(<argument><expr><name>str_ctime</name></expr></argument>, <argument><expr><name><name>cache</name>-&gt;<name>last_purge</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>buf</name> = <call><name>apr_psprintf</name><argument_list>(<argument><expr><name>p</name></expr></argument>,
<argument><expr>"%s"
"&lt;td align='right'&gt;%lu&lt;/td&gt;\n"
"&lt;td align='right' nowrap&gt;%s&lt;/td&gt;\n"</expr></argument>,
<argument><expr><name>buf</name></expr></argument>,
<argument><expr><name><name>cache</name>-&gt;<name>numpurges</name></name></expr></argument>,
<argument><expr><name>str_ctime</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr><name>buf</name> = <call><name>apr_psprintf</name><argument_list>(<argument><expr><name>p</name></expr></argument>,
<argument><expr>"%s&lt;td colspan='2' align='center'&gt;(none)&lt;/td&gt;\n"</expr></argument>,
<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></else></if>
<expr_stmt><expr><name>buf</name> = <call><name>apr_psprintf</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr>"%s&lt;td align='right'&gt;%.2gms&lt;/td&gt;\n&lt;/tr&gt;"</expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name><name>cache</name>-&gt;<name>avg_purgetime</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>buf</name></expr>;</return>
}</block></function>
<function><type><name>char</name> *</type><name>util_ald_cache_display</name><parameter_list>(<param><decl><type><name>request_rec</name> *</type><name>r</name></decl></param>, <param><decl><type><name>util_ldap_state_t</name> *</type><name>st</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>i</name></decl>,<decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>buf</name></decl>, *<decl><type ref="prev"/><name>t1</name></decl>, *<decl><type ref="prev"/><name>t2</name></decl>, *<decl><type ref="prev"/><name>t3</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>id1</name></decl>, *<decl><type ref="prev"/><name>id2</name></decl>, *<decl><type ref="prev"/><name>id3</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>argfmt</name> <init>= <expr>"cache=%s&amp;id=%d&amp;off=%d"</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>scanfmt</name> <init>= <expr>"cache=%4s&amp;id=%u&amp;off=%u%1s"</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>pool</name> <init>= <expr><name><name>r</name>-&gt;<name>pool</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>util_cache_node_t</name> *</type><name>p</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>util_url_node_t</name> *</type><name>n</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>util_ald_cache_t</name> *</type><name>util_ldap_cache</name> <init>= <expr><name><name>st</name>-&gt;<name>util_ldap_cache</name></name></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr>!<name>util_ldap_cache</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>ap_rputs</name><argument_list>(<argument><expr>"&lt;tr valign='top'&gt;&lt;td nowrap colspan=7&gt;Cache has not been enabled/initialised.&lt;/td&gt;&lt;/tr&gt;"</expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<if>if <condition>(<expr><name><name>r</name>-&gt;<name>args</name></name> &amp;&amp; <call><name>strlen</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>args</name></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>char</name></type> <name><name>cachetype</name><index>[<expr>5</expr>]</index></name></decl>, <decl><type ref="prev"/><name><name>lint</name><index>[<expr>2</expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>id</name></decl>, <decl><type ref="prev"/><name>off</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name><name>date_str</name><index>[<expr><name>APR_CTIME_LEN</name></expr>]</index></name></decl>;</decl_stmt>
<if>if <condition>(<expr>(3 == <call><name>sscanf</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>args</name></name></expr></argument>, <argument><expr><name>scanfmt</name></expr></argument>, <argument><expr><name>cachetype</name></expr></argument>, <argument><expr>&amp;<name>id</name></expr></argument>, <argument><expr>&amp;<name>off</name></expr></argument>, <argument><expr><name>lint</name></expr></argument>)</argument_list></call>) &amp;&amp;
(<name>id</name> &lt; <name><name>util_ldap_cache</name>-&gt;<name>size</name></name>)</expr>)</condition><then> <block>{
<if>if <condition>(<expr>(<name>p</name> = <name><name>util_ldap_cache</name>-&gt;<name>nodes</name><index>[<expr><name>id</name></expr>]</index></name>) != <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>n</name> = (<name>util_url_node_t</name> *)<name><name>p</name>-&gt;<name>payload</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>buf</name> = (<name>char</name>*)<name><name>n</name>-&gt;<name>url</name></name></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr><name>buf</name> = ""</expr>;</expr_stmt>
}</block></else></if>
<expr_stmt><expr><call><name>ap_rprintf</name><argument_list>(<argument><expr><name>r</name></expr></argument>,
<argument><expr>"&lt;p&gt;\n"
"&lt;table border='0'&gt;\n"
"&lt;tr&gt;\n"
"&lt;td bgcolor='#000000'&gt;&lt;font size='-1' face='Arial,Helvetica' color='#ffffff'&gt;&lt;b&gt;Cache Name:&lt;/b&gt;&lt;/font&gt;&lt;/td&gt;"
"&lt;td bgcolor='#ffffff'&gt;&lt;font size='-1' face='Arial,Helvetica' color='#000000'&gt;&lt;b&gt;%s (%s)&lt;/b&gt;&lt;/font&gt;&lt;/td&gt;"
"&lt;/tr&gt;\n"
"&lt;/table&gt;\n&lt;/p&gt;\n"</expr></argument>,
<argument><expr><name>buf</name></expr></argument>,
<argument><expr><name><name>cachetype</name><index>[<expr>0</expr>]</index></name> == 'm'? "Main" :
(<name><name>cachetype</name><index>[<expr>0</expr>]</index></name> == 's' ? "Search" :
(<name><name>cachetype</name><index>[<expr>0</expr>]</index></name> == 'c' ? "Compares" : "DNCompares"))</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<switch>switch <condition>(<expr><name><name>cachetype</name><index>[<expr>0</expr>]</index></name></expr>)</condition> <block>{
<case>case <expr>'m'</expr>:
<if>if <condition>(<expr><name><name>util_ldap_cache</name>-&gt;<name>marktime</name></name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>apr_ctime</name><argument_list>(<argument><expr><name>date_str</name></expr></argument>, <argument><expr><name><name>util_ldap_cache</name>-&gt;<name>marktime</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else
<expr_stmt><expr><name><name>date_str</name><index>[<expr>0</expr>]</index></name> = 0</expr>;</expr_stmt></else></if>
<expr_stmt><expr><call><name>ap_rprintf</name><argument_list>(<argument><expr><name>r</name></expr></argument>,
<argument><expr>"&lt;p&gt;\n"
"&lt;table border='0'&gt;\n"
"&lt;tr&gt;\n"
"&lt;td bgcolor='#000000'&gt;&lt;font size='-1' face='Arial,Helvetica' color='#ffffff'&gt;&lt;b&gt;Size:&lt;/b&gt;&lt;/font&gt;&lt;/td&gt;"
"&lt;td bgcolor='#ffffff'&gt;&lt;font size='-1' face='Arial,Helvetica' color='#000000'&gt;&lt;b&gt;%ld&lt;/b&gt;&lt;/font&gt;&lt;/td&gt;"
"&lt;/tr&gt;\n"
"&lt;tr&gt;\n"
"&lt;td bgcolor='#000000'&gt;&lt;font size='-1' face='Arial,Helvetica' color='#ffffff'&gt;&lt;b&gt;Max Entries:&lt;/b&gt;&lt;/font&gt;&lt;/td&gt;"
"&lt;td bgcolor='#ffffff'&gt;&lt;font size='-1' face='Arial,Helvetica' color='#000000'&gt;&lt;b&gt;%ld&lt;/b&gt;&lt;/font&gt;&lt;/td&gt;"
"&lt;/tr&gt;\n"
"&lt;tr&gt;\n"
"&lt;td bgcolor='#000000'&gt;&lt;font size='-1' face='Arial,Helvetica' color='#ffffff'&gt;&lt;b&gt;#Entries:&lt;/b&gt;&lt;/font&gt;&lt;/td&gt;"
"&lt;td bgcolor='#ffffff'&gt;&lt;font size='-1' face='Arial,Helvetica' color='#000000'&gt;&lt;b&gt;%ld&lt;/b&gt;&lt;/font&gt;&lt;/td&gt;"
"&lt;/tr&gt;\n"
"&lt;tr&gt;\n"
"&lt;td bgcolor='#000000'&gt;&lt;font size='-1' face='Arial,Helvetica' color='#ffffff'&gt;&lt;b&gt;Full Mark:&lt;/b&gt;&lt;/font&gt;&lt;/td&gt;"
"&lt;td bgcolor='#ffffff'&gt;&lt;font size='-1' face='Arial,Helvetica' color='#000000'&gt;&lt;b&gt;%ld&lt;/b&gt;&lt;/font&gt;&lt;/td&gt;"
"&lt;/tr&gt;\n"
"&lt;tr&gt;\n"
"&lt;td bgcolor='#000000'&gt;&lt;font size='-1' face='Arial,Helvetica' color='#ffffff'&gt;&lt;b&gt;Full Mark Time:&lt;/b&gt;&lt;/font&gt;&lt;/td&gt;"
"&lt;td bgcolor='#ffffff'&gt;&lt;font size='-1' face='Arial,Helvetica' color='#000000'&gt;&lt;b&gt;%s&lt;/b&gt;&lt;/font&gt;&lt;/td&gt;"
"&lt;/tr&gt;\n"
"&lt;/table&gt;\n&lt;/p&gt;\n"</expr></argument>,
<argument><expr><name><name>util_ldap_cache</name>-&gt;<name>size</name></name></expr></argument>,
<argument><expr><name><name>util_ldap_cache</name>-&gt;<name>maxentries</name></name></expr></argument>,
<argument><expr><name><name>util_ldap_cache</name>-&gt;<name>numentries</name></name></expr></argument>,
<argument><expr><name><name>util_ldap_cache</name>-&gt;<name>fullmark</name></name></expr></argument>,
<argument><expr><name>date_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ap_rputs</name><argument_list>(<argument><expr>"&lt;p&gt;\n"
"&lt;table border='0'&gt;\n"
"&lt;tr bgcolor='#000000'&gt;\n"
"&lt;td&gt;&lt;font size='-1' face='Arial,Helvetica' color='#ffffff'&gt;&lt;b&gt;LDAP URL&lt;/b&gt;&lt;/font&gt;&lt;/td&gt;"
"&lt;td&gt;&lt;font size='-1' face='Arial,Helvetica' color='#ffffff'&gt;&lt;b&gt;Size&lt;/b&gt;&lt;/font&gt;&lt;/td&gt;"
"&lt;td&gt;&lt;font size='-1' face='Arial,Helvetica' color='#ffffff'&gt;&lt;b&gt;Max Entries&lt;/b&gt;&lt;/font&gt;&lt;/td&gt;"
"&lt;td&gt;&lt;font size='-1' face='Arial,Helvetica' color='#ffffff'&gt;&lt;b&gt;#Entries&lt;/b&gt;&lt;/font&gt;&lt;/td&gt;"
"&lt;td&gt;&lt;font size='-1' face='Arial,Helvetica' color='#ffffff'&gt;&lt;b&gt;Full Mark&lt;/b&gt;&lt;/font&gt;&lt;/td&gt;"
"&lt;td&gt;&lt;font size='-1' face='Arial,Helvetica' color='#ffffff'&gt;&lt;b&gt;Full Mark Time&lt;/b&gt;&lt;/font&gt;&lt;/td&gt;"
"&lt;/tr&gt;\n"</expr></argument>, <argument><expr><name>r</name></expr></argument>
)</argument_list></call></expr>;</expr_stmt>
<for>for (<init><expr><name>i</name>=0</expr>;</init> <condition><expr><name>i</name> &lt; <name><name>util_ldap_cache</name>-&gt;<name>size</name></name></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>) <block>{
<for>for (<init><expr><name>p</name> = <name><name>util_ldap_cache</name>-&gt;<name>nodes</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</init> <condition><expr><name>p</name> != <name>NULL</name></expr>;</condition> <incr><expr><name>p</name> = <name><name>p</name>-&gt;<name>next</name></name></expr></incr>) <block>{
<expr_stmt><expr><call>(*<name><name>util_ldap_cache</name>-&gt;<name>display</name></name>)<argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>util_ldap_cache</name></expr></argument>, <argument><expr><name><name>p</name>-&gt;<name>payload</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></for>
}</block></for>
<expr_stmt><expr><call><name>ap_rputs</name><argument_list>(<argument><expr>"&lt;/table&gt;\n&lt;/p&gt;\n"</expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr>'s'</expr>:
<expr_stmt><expr><call><name>ap_rputs</name><argument_list>(<argument><expr>"&lt;p&gt;\n"
"&lt;table border='0'&gt;\n"
"&lt;tr bgcolor='#000000'&gt;\n"
"&lt;td&gt;&lt;font size='-1' face='Arial,Helvetica' color='#ffffff'&gt;&lt;b&gt;LDAP Filter&lt;/b&gt;&lt;/font&gt;&lt;/td&gt;"
"&lt;td&gt;&lt;font size='-1' face='Arial,Helvetica' color='#ffffff'&gt;&lt;b&gt;User Name&lt;/b&gt;&lt;/font&gt;&lt;/td&gt;"
"&lt;td&gt;&lt;font size='-1' face='Arial,Helvetica' color='#ffffff'&gt;&lt;b&gt;Last Bind&lt;/b&gt;&lt;/font&gt;&lt;/td&gt;"
"&lt;/tr&gt;\n"</expr></argument>, <argument><expr><name>r</name></expr></argument>
)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>n</name></expr>)</condition><then> <block>{
<for>for (<init><expr><name>i</name>=0</expr>;</init> <condition><expr><name>i</name> &lt; <name><name>n</name>-&gt;<name>search_cache</name>-&gt;<name>size</name></name></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>) <block>{
<for>for (<init><expr><name>p</name> = <name><name>n</name>-&gt;<name>search_cache</name>-&gt;<name>nodes</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</init> <condition><expr><name>p</name> != <name>NULL</name></expr>;</condition> <incr><expr><name>p</name> = <name><name>p</name>-&gt;<name>next</name></name></expr></incr>) <block>{
<expr_stmt><expr><call>(*<name><name>n</name>-&gt;<name>search_cache</name>-&gt;<name>display</name></name>)<argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name><name>n</name>-&gt;<name>search_cache</name></name></expr></argument>, <argument><expr><name><name>p</name>-&gt;<name>payload</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></for>
}</block></for>
}</block></then></if>
<expr_stmt><expr><call><name>ap_rputs</name><argument_list>(<argument><expr>"&lt;/table&gt;\n&lt;/p&gt;\n"</expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr>'c'</expr>:
<expr_stmt><expr><call><name>ap_rputs</name><argument_list>(<argument><expr>"&lt;p&gt;\n"
"&lt;table border='0'&gt;\n"
"&lt;tr bgcolor='#000000'&gt;\n"
"&lt;td&gt;&lt;font size='-1' face='Arial,Helvetica' color='#ffffff'&gt;&lt;b&gt;DN&lt;/b&gt;&lt;/font&gt;&lt;/td&gt;"
"&lt;td&gt;&lt;font size='-1' face='Arial,Helvetica' color='#ffffff'&gt;&lt;b&gt;Attribute&lt;/b&gt;&lt;/font&gt;&lt;/td&gt;"
"&lt;td&gt;&lt;font size='-1' face='Arial,Helvetica' color='#ffffff'&gt;&lt;b&gt;Value&lt;/b&gt;&lt;/font&gt;&lt;/td&gt;"
"&lt;td&gt;&lt;font size='-1' face='Arial,Helvetica' color='#ffffff'&gt;&lt;b&gt;Last Compare&lt;/b&gt;&lt;/font&gt;&lt;/td&gt;"
"&lt;td&gt;&lt;font size='-1' face='Arial,Helvetica' color='#ffffff'&gt;&lt;b&gt;Result&lt;/b&gt;&lt;/font&gt;&lt;/td&gt;"
"&lt;td&gt;&lt;font size='-1' face='Arial,Helvetica' color='#ffffff'&gt;&lt;b&gt;Sub-groups?&lt;/b&gt;&lt;/font&gt;&lt;/td&gt;"
"&lt;td&gt;&lt;font size='-1' face='Arial,Helvetica' color='#ffffff'&gt;&lt;b&gt;S-G Checked?&lt;/b&gt;&lt;/font&gt;&lt;/td&gt;"
"&lt;/tr&gt;\n"</expr></argument>, <argument><expr><name>r</name></expr></argument>
)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>n</name></expr>)</condition><then> <block>{
<for>for (<init><expr><name>i</name>=0</expr>;</init> <condition><expr><name>i</name> &lt; <name><name>n</name>-&gt;<name>compare_cache</name>-&gt;<name>size</name></name></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>) <block>{
<for>for (<init><expr><name>p</name> = <name><name>n</name>-&gt;<name>compare_cache</name>-&gt;<name>nodes</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</init> <condition><expr><name>p</name> != <name>NULL</name></expr>;</condition> <incr><expr><name>p</name> = <name><name>p</name>-&gt;<name>next</name></name></expr></incr>) <block>{
<expr_stmt><expr><call>(*<name><name>n</name>-&gt;<name>compare_cache</name>-&gt;<name>display</name></name>)<argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name><name>n</name>-&gt;<name>compare_cache</name></name></expr></argument>, <argument><expr><name><name>p</name>-&gt;<name>payload</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></for>
}</block></for>
}</block></then></if>
<expr_stmt><expr><call><name>ap_rputs</name><argument_list>(<argument><expr>"&lt;/table&gt;\n&lt;/p&gt;\n"</expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr>'d'</expr>:
<expr_stmt><expr><call><name>ap_rputs</name><argument_list>(<argument><expr>"&lt;p&gt;\n"
"&lt;table border='0'&gt;\n"
"&lt;tr bgcolor='#000000'&gt;\n"
"&lt;td&gt;&lt;font size='-1' face='Arial,Helvetica' color='#ffffff'&gt;&lt;b&gt;Require DN&lt;/b&gt;&lt;/font&gt;&lt;/td&gt;"
"&lt;td&gt;&lt;font size='-1' face='Arial,Helvetica' color='#ffffff'&gt;&lt;b&gt;Actual DN&lt;/b&gt;&lt;/font&gt;&lt;/td&gt;"
"&lt;/tr&gt;\n"</expr></argument>, <argument><expr><name>r</name></expr></argument>
)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>n</name></expr>)</condition><then> <block>{
<for>for (<init><expr><name>i</name>=0</expr>;</init> <condition><expr><name>i</name> &lt; <name><name>n</name>-&gt;<name>dn_compare_cache</name>-&gt;<name>size</name></name></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>) <block>{
<for>for (<init><expr><name>p</name> = <name><name>n</name>-&gt;<name>dn_compare_cache</name>-&gt;<name>nodes</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</init> <condition><expr><name>p</name> != <name>NULL</name></expr>;</condition> <incr><expr><name>p</name> = <name><name>p</name>-&gt;<name>next</name></name></expr></incr>) <block>{
<expr_stmt><expr><call>(*<name><name>n</name>-&gt;<name>dn_compare_cache</name>-&gt;<name>display</name></name>)<argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name><name>n</name>-&gt;<name>dn_compare_cache</name></name></expr></argument>, <argument><expr><name><name>p</name>-&gt;<name>payload</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></for>
}</block></for>
}</block></then></if>
<expr_stmt><expr><call><name>ap_rputs</name><argument_list>(<argument><expr>"&lt;/table&gt;\n&lt;/p&gt;\n"</expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</case><default>default:
<break>break;</break>
</default>}</block></switch>
}</block></then> <else>else <block>{
<expr_stmt><expr><name>buf</name> = ""</expr>;</expr_stmt>
}</block></else></if>
}</block></then> <else>else <block>{
<expr_stmt><expr><call><name>ap_rputs</name><argument_list>(<argument><expr>"&lt;p&gt;\n"
"&lt;table border='0'&gt;\n"
"&lt;tr bgcolor='#000000'&gt;\n"
"&lt;td&gt;&lt;font size='-1' face='Arial,Helvetica' color='#ffffff'&gt;&lt;b&gt;Cache Name&lt;/b&gt;&lt;/font&gt;&lt;/td&gt;"
"&lt;td&gt;&lt;font size='-1' face='Arial,Helvetica' color='#ffffff'&gt;&lt;b&gt;Entries&lt;/b&gt;&lt;/font&gt;&lt;/td&gt;"
"&lt;td&gt;&lt;font size='-1' face='Arial,Helvetica' color='#ffffff'&gt;&lt;b&gt;Avg. Chain Len.&lt;/b&gt;&lt;/font&gt;&lt;/td&gt;"
"&lt;td colspan='2'&gt;&lt;font size='-1' face='Arial,Helvetica' color='#ffffff'&gt;&lt;b&gt;Hits&lt;/b&gt;&lt;/font&gt;&lt;/td&gt;"
"&lt;td&gt;&lt;font size='-1' face='Arial,Helvetica' color='#ffffff'&gt;&lt;b&gt;Ins/Rem&lt;/b&gt;&lt;/font&gt;&lt;/td&gt;"
"&lt;td colspan='2'&gt;&lt;font size='-1' face='Arial,Helvetica' color='#ffffff'&gt;&lt;b&gt;Purges&lt;/b&gt;&lt;/font&gt;&lt;/td&gt;"
"&lt;td&gt;&lt;font size='-1' face='Arial,Helvetica' color='#ffffff'&gt;&lt;b&gt;Avg Purge Time&lt;/b&gt;&lt;/font&gt;&lt;/td&gt;"
"&lt;/tr&gt;\n"</expr></argument>, <argument><expr><name>r</name></expr></argument>
)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>id1</name> = <call><name>apr_psprintf</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>argfmt</name></expr></argument>, <argument><expr>"main"</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>buf</name> = <call><name>util_ald_cache_display_stats</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name><name>st</name>-&gt;<name>util_ldap_cache</name></name></expr></argument>, <argument><expr>"LDAP URL Cache"</expr></argument>, <argument><expr><name>id1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for (<init><expr><name>i</name>=0</expr>;</init> <condition><expr><name>i</name> &lt; <name><name>util_ldap_cache</name>-&gt;<name>size</name></name></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>) <block>{
<for>for (<init><expr><name>p</name> = <name><name>util_ldap_cache</name>-&gt;<name>nodes</name><index>[<expr><name>i</name></expr>]</index></name></expr>,<expr><name>j</name>=0</expr>;</init> <condition><expr><name>p</name> != <name>NULL</name></expr>;</condition> <incr><expr><name>p</name> = <name><name>p</name>-&gt;<name>next</name></name></expr>,<expr><name>j</name>++</expr></incr>) <block>{
<expr_stmt><expr><name>n</name> = (<name>util_url_node_t</name> *)<name><name>p</name>-&gt;<name>payload</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>t1</name> = <call><name>apr_psprintf</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr>"%s (Searches)"</expr></argument>, <argument><expr><name><name>n</name>-&gt;<name>url</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>t2</name> = <call><name>apr_psprintf</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr>"%s (Compares)"</expr></argument>, <argument><expr><name><name>n</name>-&gt;<name>url</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>t3</name> = <call><name>apr_psprintf</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr>"%s (DNCompares)"</expr></argument>, <argument><expr><name><name>n</name>-&gt;<name>url</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>id1</name> = <call><name>apr_psprintf</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>argfmt</name></expr></argument>, <argument><expr>"srch"</expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>id2</name> = <call><name>apr_psprintf</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>argfmt</name></expr></argument>, <argument><expr>"cmpr"</expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>id3</name> = <call><name>apr_psprintf</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>argfmt</name></expr></argument>, <argument><expr>"dncp"</expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>buf</name> = <call><name>apr_psprintf</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr>"%s\n\n"
"%s\n\n"
"%s\n\n"
"%s\n\n"</expr></argument>,
<argument><expr><name>buf</name></expr></argument>,
<argument><expr><call><name>util_ald_cache_display_stats</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name><name>n</name>-&gt;<name>search_cache</name></name></expr></argument>, <argument><expr><name>t1</name></expr></argument>, <argument><expr><name>id1</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name>util_ald_cache_display_stats</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name><name>n</name>-&gt;<name>compare_cache</name></name></expr></argument>, <argument><expr><name>t2</name></expr></argument>, <argument><expr><name>id2</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name>util_ald_cache_display_stats</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name><name>n</name>-&gt;<name>dn_compare_cache</name></name></expr></argument>, <argument><expr><name>t3</name></expr></argument>, <argument><expr><name>id3</name></expr></argument>)</argument_list></call></expr></argument>
)</argument_list></call></expr>;</expr_stmt>
}</block></for>
}</block></for>
<expr_stmt><expr><call><name>ap_rputs</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ap_rputs</name><argument_list>(<argument><expr>"&lt;/table&gt;\n&lt;/p&gt;\n"</expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></else></if>
<return>return <expr><name>buf</name></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</unit>
