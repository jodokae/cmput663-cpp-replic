<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C" filename="projects/httpd-2.4.29/_cppstats/_cppstats/server/mpm/worker/worker.c"><cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"apr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"apr_portable.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"apr_strings.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"apr_file_io.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"apr_thread_proc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"apr_signal.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"apr_thread_mutex.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"apr_proc_mutex.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"apr_poll.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdlib.h&gt;</cpp:file></cpp:include>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>APR_WANT_STRFUNC</name></cpp:macro></cpp:define>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"apr_want.h"</cpp:file></cpp:include>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>APR_HAVE_UNISTD_H</name></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;unistd.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>APR_HAVE_SYS_SOCKET_H</name></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/socket.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>APR_HAVE_SYS_WAIT_H</name></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/wait.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_SYS_PROCESSOR_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/processor.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<name>APR_HAS_THREADS</name></expr></cpp:if>
<cpp:error>#<cpp:directive>error</cpp:directive> The Worker MPM requires APR threads, but they are unavailable.</cpp:error>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ap_config.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"httpd.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"http_main.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"http_log.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"http_config.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"http_core.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"http_connection.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ap_mpm.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"mpm_common.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ap_listen.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"scoreboard.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"fdqueue.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"mpm_default.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"util_mutex.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"unixd.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;signal.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;limits.h&gt;</cpp:file></cpp:include>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>DEFAULT_SERVER_LIMIT</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DEFAULT_SERVER_LIMIT</name></cpp:macro> <cpp:value>16</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>MAX_SERVER_LIMIT</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAX_SERVER_LIMIT</name></cpp:macro> <cpp:value>20000</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>DEFAULT_THREAD_LIMIT</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DEFAULT_THREAD_LIMIT</name></cpp:macro> <cpp:value>64</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>MAX_THREAD_LIMIT</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAX_THREAD_LIMIT</name></cpp:macro> <cpp:value>20000</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>threads_per_child</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>ap_daemons_to_start</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>min_spare_threads</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>max_spare_threads</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>ap_daemons_limit</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>max_workers</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>server_limit</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>thread_limit</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>had_healthy_child</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>dying</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>workers_may_exit</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>start_thread_may_exit</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>listener_may_exit</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>requests_this_child</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>num_listensocks</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>resource_shortage</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>fd_queue_t</name> *</type><name>worker_queue</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>fd_queue_info_t</name> *</type><name>worker_queue_info</name></decl>;</decl_stmt>
<typedef>typedef <type><struct>struct <name>worker_retained_data</name> <block>{
<decl_stmt><decl><type><name>ap_unixd_mpm_retained_data</name> *</type><name>mpm</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>first_server_limit</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>first_thread_limit</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>sick_child_detected</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>maxclients_reported</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>near_maxclients_reported</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>max_daemons_limit</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name> *</type><name>idle_spawn_rate</name></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>MAX_SPAWN_RATE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAX_SPAWN_RATE</name></cpp:macro> <cpp:value>(32)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<decl_stmt><decl><type><name>int</name></type> <name>hold_off_on_exponential_spawning</name></decl>;</decl_stmt>
}</block></struct></type> <name>worker_retained_data</name>;</typedef>
<decl_stmt><decl><type><specifier>static</specifier> <name>worker_retained_data</name> *</type><name>retained</name></decl>;</decl_stmt>
<typedef>typedef <type><struct>struct <name>worker_child_bucket</name> <block>{
<decl_stmt><decl><type><name>ap_pod_t</name> *</type><name>pod</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ap_listen_rec</name> *</type><name>listeners</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>apr_proc_mutex_t</name> *</type><name>mutex</name></decl>;</decl_stmt>
}</block></struct></type> <name>worker_child_bucket</name>;</typedef>
<decl_stmt><decl><type><specifier>static</specifier> <name>worker_child_bucket</name> *</type><name>all_buckets</name></decl>,
*<decl><type ref="prev"/><name>my_bucket</name></decl>;</decl_stmt>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MPM_CHILD_PID</name><parameter_list>(<param><type><name>i</name></type></param>)</parameter_list></cpp:macro> <cpp:value>(ap_scoreboard_image-&gt;parent[i].pid)</cpp:value></cpp:define>
<typedef>typedef <type><struct>struct <block>{
<decl_stmt><decl><type><name>int</name></type> <name>pid</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>tid</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>sd</name></decl>;</decl_stmt>
}</block></struct></type> <name>proc_info</name>;</typedef>
<typedef>typedef <type><struct>struct <block>{
<decl_stmt><decl><type><name>apr_thread_t</name> **</type><name>threads</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>apr_thread_t</name> *</type><name>listener</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>child_num_arg</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>apr_threadattr_t</name> *</type><name>threadattr</name></decl>;</decl_stmt>
}</block></struct></type> <name>thread_starter</name>;</typedef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ID_FROM_CHILD_THREAD</name><parameter_list>(<param><type><name>c</name></type></param>, <param><type><name>t</name></type></param>)</parameter_list></cpp:macro> <cpp:value>((c * thread_limit) + t)</cpp:value></cpp:define>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>one_process</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>DEBUG_SIGSTOP</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>int</name></type> <name>raise_sigstop_flags</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<decl_stmt><decl><type><specifier>static</specifier> <name>apr_pool_t</name> *</type><name>pconf</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>apr_pool_t</name> *</type><name>pchild</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>pid_t</name></type> <name>ap_my_pid</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>pid_t</name></type> <name>parent_pid</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>apr_os_thread_t</name> *</type><name>listener_os_thread</name></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SINGLE_LISTEN_UNSERIALIZED_ACCEPT</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SAFE_ACCEPT</name><parameter_list>(<param><type><name>stmt</name></type></param>)</parameter_list></cpp:macro> <cpp:value>(ap_listeners-&gt;next ? (stmt) : APR_SUCCESS)</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SAFE_ACCEPT</name><parameter_list>(<param><type><name>stmt</name></type></param>)</parameter_list></cpp:macro> <cpp:value>(stmt)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LISTENER_SIGNAL</name></cpp:macro> <cpp:value>SIGHUP</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WORKER_SIGNAL</name></cpp:macro> <cpp:value>AP_SIG_GRACEFUL</cpp:value></cpp:define>
<decl_stmt><decl><type><specifier>static</specifier> <name>apr_socket_t</name> **</type><name>worker_sockets</name></decl>;</decl_stmt>
<function><type><specifier>static</specifier> <name>void</name></type> <name>close_worker_sockets</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>threads_per_child</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
<if>if <condition>(<expr><name><name>worker_sockets</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>apr_socket_close</name><argument_list>(<argument><expr><name><name>worker_sockets</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>worker_sockets</name><index>[<expr><name>i</name></expr>]</index></name> = <name>NULL</name></expr>;</expr_stmt>
}</block></then></if>
}</block></for>
}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>wakeup_listener</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list> <block>{
<expr_stmt><expr><name>listener_may_exit</name> = 1</expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>listener_os_thread</name></expr>)</condition><then> <block>{
<return>return;</return>
}</block></then></if>
<expr_stmt><expr><call><name>ap_queue_info_term</name><argument_list>(<argument><expr><name>worker_queue_info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_PTHREAD_KILL</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>pthread_kill</name><argument_list>(<argument><expr>*<name>listener_os_thread</name></expr></argument>, <argument><expr><name>LISTENER_SIGNAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<expr_stmt><expr><call><name>kill</name><argument_list>(<argument><expr><name>ap_my_pid</name></expr></argument>, <argument><expr><name>LISTENER_SIGNAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></function>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ST_INIT</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ST_GRACEFUL</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ST_UNGRACEFUL</name></cpp:macro> <cpp:value>2</cpp:value></cpp:define>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>terminate_mode</name> <init>= <expr><name>ST_INIT</name></expr></init></decl>;</decl_stmt>
<function><type><specifier>static</specifier> <name>void</name></type> <name>signal_threads</name><parameter_list>(<param><decl><type><name>int</name></type> <name>mode</name></decl></param>)</parameter_list> <block>{
<if>if <condition>(<expr><name>terminate_mode</name> == <name>mode</name></expr>)</condition><then> <block>{
<return>return;</return>
}</block></then></if>
<expr_stmt><expr><name>terminate_mode</name> = <name>mode</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>retained</name>-&gt;<name>mpm</name>-&gt;<name>mpm_state</name></name> = <name>AP_MPMQ_STOPPING</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>wakeup_listener</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>mode</name> == <name>ST_UNGRACEFUL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>workers_may_exit</name> = 1</expr>;</expr_stmt>
<expr_stmt><expr><call><name>ap_queue_interrupt_all</name><argument_list>(<argument><expr><name>worker_queue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>close_worker_sockets</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>worker_query</name><parameter_list>(<param><decl><type><name>int</name></type> <name>query_code</name></decl></param>, <param><decl><type><name>int</name> *</type><name>result</name></decl></param>, <param><decl><type><name>apr_status_t</name> *</type><name>rv</name></decl></param>)</parameter_list> <block>{
<expr_stmt><expr>*<name>rv</name> = <name>APR_SUCCESS</name></expr>;</expr_stmt>
<switch>switch <condition>(<expr><name>query_code</name></expr>)</condition> <block>{
<case>case <expr><name>AP_MPMQ_MAX_DAEMON_USED</name></expr>:
<expr_stmt><expr>*<name>result</name> = <name><name>retained</name>-&gt;<name>max_daemons_limit</name></name></expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr><name>AP_MPMQ_IS_THREADED</name></expr>:
<expr_stmt><expr>*<name>result</name> = <name>AP_MPMQ_STATIC</name></expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr><name>AP_MPMQ_IS_FORKED</name></expr>:
<expr_stmt><expr>*<name>result</name> = <name>AP_MPMQ_DYNAMIC</name></expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr><name>AP_MPMQ_HARD_LIMIT_DAEMONS</name></expr>:
<expr_stmt><expr>*<name>result</name> = <name>server_limit</name></expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr><name>AP_MPMQ_HARD_LIMIT_THREADS</name></expr>:
<expr_stmt><expr>*<name>result</name> = <name>thread_limit</name></expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr><name>AP_MPMQ_MAX_THREADS</name></expr>:
<expr_stmt><expr>*<name>result</name> = <name>threads_per_child</name></expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr><name>AP_MPMQ_MIN_SPARE_DAEMONS</name></expr>:
<expr_stmt><expr>*<name>result</name> = 0</expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr><name>AP_MPMQ_MIN_SPARE_THREADS</name></expr>:
<expr_stmt><expr>*<name>result</name> = <name>min_spare_threads</name></expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr><name>AP_MPMQ_MAX_SPARE_DAEMONS</name></expr>:
<expr_stmt><expr>*<name>result</name> = 0</expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr><name>AP_MPMQ_MAX_SPARE_THREADS</name></expr>:
<expr_stmt><expr>*<name>result</name> = <name>max_spare_threads</name></expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr><name>AP_MPMQ_MAX_REQUESTS_DAEMON</name></expr>:
<expr_stmt><expr>*<name>result</name> = <name>ap_max_requests_per_child</name></expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr><name>AP_MPMQ_MAX_DAEMONS</name></expr>:
<expr_stmt><expr>*<name>result</name> = <name>ap_daemons_limit</name></expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr><name>AP_MPMQ_MPM_STATE</name></expr>:
<expr_stmt><expr>*<name>result</name> = <name><name>retained</name>-&gt;<name>mpm</name>-&gt;<name>mpm_state</name></name></expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr><name>AP_MPMQ_GENERATION</name></expr>:
<expr_stmt><expr>*<name>result</name> = <name><name>retained</name>-&gt;<name>mpm</name>-&gt;<name>my_generation</name></name></expr>;</expr_stmt>
<break>break;</break>
</case><default>default:
<expr_stmt><expr>*<name>rv</name> = <name>APR_ENOTIMPL</name></expr>;</expr_stmt>
<break>break;</break>
</default>}</block></switch>
<return>return <expr><name>OK</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>worker_note_child_killed</name><parameter_list>(<param><decl><type><name>int</name></type> <name>childnum</name></decl></param>, <param><decl><type><name>pid_t</name></type> <name>pid</name></decl></param>, <param><decl><type><name>ap_generation_t</name></type> <name>gen</name></decl></param>)</parameter_list> <block>{
<if>if <condition>(<expr><name>childnum</name> != -1</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>ap_run_child_status</name><argument_list>(<argument><expr><name>ap_server_conf</name></expr></argument>,
<argument><expr><name><name>ap_scoreboard_image</name>-&gt;<name>parent</name><index>[<expr><name>childnum</name></expr>]</index></name>.<name>pid</name></expr></argument>,
<argument><expr><name><name>ap_scoreboard_image</name>-&gt;<name>parent</name><index>[<expr><name>childnum</name></expr>]</index></name>.<name>generation</name></expr></argument>,
<argument><expr><name>childnum</name></expr></argument>, <argument><expr><name>MPM_CHILD_EXITED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ap_scoreboard_image</name>-&gt;<name>parent</name><index>[<expr><name>childnum</name></expr>]</index></name>.<name>pid</name> = 0</expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr><call><name>ap_run_child_status</name><argument_list>(<argument><expr><name>ap_server_conf</name></expr></argument>, <argument><expr><name>pid</name></expr></argument>, <argument><expr><name>gen</name></expr></argument>, <argument><expr>-1</expr></argument>, <argument><expr><name>MPM_CHILD_EXITED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></else></if>
}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>worker_note_child_started</name><parameter_list>(<param><decl><type><name>int</name></type> <name>slot</name></decl></param>, <param><decl><type><name>pid_t</name></type> <name>pid</name></decl></param>)</parameter_list> <block>{
<expr_stmt><expr><name><name>ap_scoreboard_image</name>-&gt;<name>parent</name><index>[<expr><name>slot</name></expr>]</index></name>.<name>pid</name> = <name>pid</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ap_run_child_status</name><argument_list>(<argument><expr><name>ap_server_conf</name></expr></argument>,
<argument><expr><name><name>ap_scoreboard_image</name>-&gt;<name>parent</name><index>[<expr><name>slot</name></expr>]</index></name>.<name>pid</name></expr></argument>,
<argument><expr><name><name>retained</name>-&gt;<name>mpm</name>-&gt;<name>my_generation</name></name></expr></argument>, <argument><expr><name>slot</name></expr></argument>, <argument><expr><name>MPM_CHILD_STARTED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>worker_note_child_lost_slot</name><parameter_list>(<param><decl><type><name>int</name></type> <name>slot</name></decl></param>, <param><decl><type><name>pid_t</name></type> <name>newpid</name></decl></param>)</parameter_list> <block>{
<expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_DEBUG</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>ap_server_conf</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00263</expr></argument>)</argument_list></call>
"pid %" <name>APR_PID_T_FMT</name> " taking over scoreboard slot from "
"%" <name>APR_PID_T_FMT</name> "%s"</expr></argument>,
<argument><expr><name>newpid</name></expr></argument>,
<argument><expr><name><name>ap_scoreboard_image</name>-&gt;<name>parent</name><index>[<expr><name>slot</name></expr>]</index></name>.<name>pid</name></expr></argument>,
<argument><expr><name><name>ap_scoreboard_image</name>-&gt;<name>parent</name><index>[<expr><name>slot</name></expr>]</index></name>.<name>quiescing</name> ?
" (quiescing)" : ""</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ap_run_child_status</name><argument_list>(<argument><expr><name>ap_server_conf</name></expr></argument>,
<argument><expr><name><name>ap_scoreboard_image</name>-&gt;<name>parent</name><index>[<expr><name>slot</name></expr>]</index></name>.<name>pid</name></expr></argument>,
<argument><expr><name><name>ap_scoreboard_image</name>-&gt;<name>parent</name><index>[<expr><name>slot</name></expr>]</index></name>.<name>generation</name></expr></argument>,
<argument><expr><name>slot</name></expr></argument>, <argument><expr><name>MPM_CHILD_LOST_SLOT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ap_register_extra_mpm_process</name><argument_list>(<argument><expr><name><name>ap_scoreboard_image</name>-&gt;<name>parent</name><index>[<expr><name>slot</name></expr>]</index></name>.<name>pid</name></expr></argument>,
<argument><expr><name><name>ap_scoreboard_image</name>-&gt;<name>parent</name><index>[<expr><name>slot</name></expr>]</index></name>.<name>generation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>
<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> *</type><name>worker_get_name</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list> <block>{
<return>return <expr>"worker"</expr>;</return>
}</block></function>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>clean_child_exit</name><parameter_list>(<param><decl><type><name>int</name></type> <name>code</name></decl></param>)</parameter_list> __attribute__ <parameter_list>(<param/></parameter_list>(noreturn</function_decl>))<empty_stmt>;</empty_stmt>
<function><type><specifier>static</specifier> <name>void</name></type> <name>clean_child_exit</name><parameter_list>(<param><decl><type><name>int</name></type> <name>code</name></decl></param>)</parameter_list> <block>{
<expr_stmt><expr><name><name>retained</name>-&gt;<name>mpm</name>-&gt;<name>mpm_state</name></name> = <name>AP_MPMQ_STOPPING</name></expr>;</expr_stmt>
<if>if <condition>(<expr><name>pchild</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>apr_pool_destroy</name><argument_list>(<argument><expr><name>pchild</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<if>if <condition>(<expr><name>one_process</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>worker_note_child_killed</name><argument_list>( <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><name>code</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>just_die</name><parameter_list>(<param><decl><type><name>int</name></type> <name>sig</name></decl></param>)</parameter_list> <block>{
<expr_stmt><expr><call><name>clean_child_exit</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>child_fatal</name></decl>;</decl_stmt>
<function><type><specifier>static</specifier> <name>void</name></type> <name>process_socket</name><parameter_list>(<param><decl><type><name>apr_thread_t</name> *</type><name>thd</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>p</name></decl></param>, <param><decl><type><name>apr_socket_t</name> *</type><name>sock</name></decl></param>,
<param><decl><type><name>int</name></type> <name>my_child_num</name></decl></param>,
<param><decl><type><name>int</name></type> <name>my_thread_num</name></decl></param>, <param><decl><type><name>apr_bucket_alloc_t</name> *</type><name>bucket_alloc</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>conn_rec</name> *</type><name>current_conn</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>long</name></type> <name>conn_id</name> <init>= <expr><call><name>ID_FROM_CHILD_THREAD</name><argument_list>(<argument><expr><name>my_child_num</name></expr></argument>, <argument><expr><name>my_thread_num</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ap_sb_handle_t</name> *</type><name>sbh</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>ap_create_sb_handle</name><argument_list>(<argument><expr>&amp;<name>sbh</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>my_child_num</name></expr></argument>, <argument><expr><name>my_thread_num</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>current_conn</name> = <call><name>ap_run_create_connection</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>ap_server_conf</name></expr></argument>, <argument><expr><name>sock</name></expr></argument>,
<argument><expr><name>conn_id</name></expr></argument>, <argument><expr><name>sbh</name></expr></argument>, <argument><expr><name>bucket_alloc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>current_conn</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>current_conn</name>-&gt;<name>current_thread</name></name> = <name>thd</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ap_process_connection</name><argument_list>(<argument><expr><name>current_conn</name></expr></argument>, <argument><expr><name>sock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ap_lingering_close</name><argument_list>(<argument><expr><name>current_conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>check_infinite_requests</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list> <block>{
<if>if <condition>(<expr><name>ap_max_requests_per_child</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>signal_threads</name><argument_list>(<argument><expr><name>ST_GRACEFUL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr><name>requests_this_child</name> = <name>INT_MAX</name></expr>;</expr_stmt>
}</block></else></if>
}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>unblock_signal</name><parameter_list>(<param><decl><type><name>int</name></type> <name>sig</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>sigset_t</name></type> <name>sig_mask</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>sigemptyset</name><argument_list>(<argument><expr>&amp;<name>sig_mask</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>sigaddset</name><argument_list>(<argument><expr>&amp;<name>sig_mask</name></expr></argument>, <argument><expr><name>sig</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SIGPROCMASK_SETS_THREAD_MASK</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>sigprocmask</name><argument_list>(<argument><expr><name>SIG_UNBLOCK</name></expr></argument>, <argument><expr>&amp;<name>sig_mask</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<expr_stmt><expr><call><name>pthread_sigmask</name><argument_list>(<argument><expr><name>SIG_UNBLOCK</name></expr></argument>, <argument><expr>&amp;<name>sig_mask</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>dummy_signal_handler</name><parameter_list>(<param><decl><type><name>int</name></type> <name>sig</name></decl></param>)</parameter_list> <block>{
}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>accept_mutex_error</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>func</name></decl></param>, <param><decl><type><name>apr_status_t</name></type> <name>rv</name></decl></param>, <param><decl><type><name>int</name></type> <name>process_slot</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>level</name> <init>= <expr><name>APLOG_EMERG</name></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name><name>ap_scoreboard_image</name>-&gt;<name>parent</name><index>[<expr><name>process_slot</name></expr>]</index></name>.<name>generation</name> !=
<name><name>ap_scoreboard_image</name>-&gt;<name>global</name>-&gt;<name>running_generation</name></name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>level</name> = <name>APLOG_DEBUG</name></expr>;</expr_stmt>
}</block></then> <else>else <if>if <condition>(<expr><name>requests_this_child</name> == <name>INT_MAX</name>
|| ((<name>requests_this_child</name> == <name>ap_max_requests_per_child</name>)
&amp;&amp; <name>ap_max_requests_per_child</name>)</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>level</name></expr></argument>, <argument><expr><name>rv</name></expr></argument>, <argument><expr><name>ap_server_conf</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00272</expr></argument>)</argument_list></call>
"apr_proc_mutex_%s failed "
"before this child process served any requests."</expr></argument>,
<argument><expr><name>func</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>clean_child_exit</name><argument_list>(<argument><expr><name>APEXIT_CHILDSICK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if></else></if>
<expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>level</name></expr></argument>, <argument><expr><name>rv</name></expr></argument>, <argument><expr><name>ap_server_conf</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00273</expr></argument>)</argument_list></call>
"apr_proc_mutex_%s failed. Attempting to "
"shutdown process gracefully."</expr></argument>, <argument><expr><name>func</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>signal_threads</name><argument_list>(<argument><expr><name>ST_GRACEFUL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>
<function><type><specifier>static</specifier> <name>void</name> * <name>APR_THREAD_FUNC</name></type> <name>listener_thread</name><parameter_list>(<param><decl><type><name>apr_thread_t</name> *</type><name>thd</name></decl></param>, <param><decl><type><name>void</name> *</type> <name>dummy</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>proc_info</name> *</type> <name>ti</name> <init>= <expr><name>dummy</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>process_slot</name> <init>= <expr><name><name>ti</name>-&gt;<name>pid</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>tpool</name> <init>= <expr><call><name>apr_thread_pool_get</name><argument_list>(<argument><expr><name>thd</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>void</name> *</type><name>csd</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>ptrans</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>apr_pollset_t</name> *</type><name>pollset</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>apr_status_t</name></type> <name>rv</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ap_listen_rec</name> *</type><name>lr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>have_idle_worker</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>last_poll_idx</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>ti</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>rv</name> = <call><name>apr_pollset_create</name><argument_list>(<argument><expr>&amp;<name>pollset</name></expr></argument>, <argument><expr><name>num_listensocks</name></expr></argument>, <argument><expr><name>tpool</name></expr></argument>,
<argument><expr><name>APR_POLLSET_NOCOPY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>rv</name> != <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_EMERG</name></expr></argument>, <argument><expr><name>rv</name></expr></argument>, <argument><expr><name>ap_server_conf</name></expr></argument>,
<argument><expr>"Couldn't create pollset in thread;"
" check system or user limits"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>clean_child_exit</name><argument_list>(<argument><expr><name>APEXIT_CHILDSICK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<for>for (<init><expr><name>lr</name> = <name><name>my_bucket</name>-&gt;<name>listeners</name></name></expr>;</init> <condition><expr><name>lr</name> != <name>NULL</name></expr>;</condition> <incr><expr><name>lr</name> = <name><name>lr</name>-&gt;<name>next</name></name></expr></incr>) <block>{
<decl_stmt><decl><type><name>apr_pollfd_t</name> *</type><name>pfd</name> <init>= <expr><call><name>apr_pcalloc</name><argument_list>(<argument><expr><name>tpool</name></expr></argument>, <argument><expr>sizeof *<name>pfd</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>pfd</name>-&gt;<name>desc_type</name></name> = <name>APR_POLL_SOCKET</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>pfd</name>-&gt;<name>desc</name>.<name>s</name></name> = <name><name>lr</name>-&gt;<name>sd</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>pfd</name>-&gt;<name>reqevents</name></name> = <name>APR_POLLIN</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>pfd</name>-&gt;<name>client_data</name></name> = <name>lr</name></expr>;</expr_stmt>
<expr_stmt><expr><name>rv</name> = <call><name>apr_pollset_add</name><argument_list>(<argument><expr><name>pollset</name></expr></argument>, <argument><expr><name>pfd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>rv</name> != <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_EMERG</name></expr></argument>, <argument><expr><name>rv</name></expr></argument>, <argument><expr><name>ap_server_conf</name></expr></argument>,
<argument><expr>"Couldn't create add listener to pollset;"
" check system or user limits"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>clean_child_exit</name><argument_list>(<argument><expr><name>APEXIT_CHILDSICK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><name><name>lr</name>-&gt;<name>accept_func</name></name> = <name>ap_unixd_accept</name></expr>;</expr_stmt>
}</block></for>
<expr_stmt><expr><call><name>unblock_signal</name><argument_list>(<argument><expr><name>LISTENER_SIGNAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>apr_signal</name><argument_list>(<argument><expr><name>LISTENER_SIGNAL</name></expr></argument>, <argument><expr><name>dummy_signal_handler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<while>while <condition>(<expr>1</expr>)</condition> <block>{
<if>if <condition>(<expr><name>requests_this_child</name> &lt;= 0</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>check_infinite_requests</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<if>if <condition>(<expr><name>listener_may_exit</name></expr>)</condition><then> <break>break;</break></then></if>
<if>if <condition>(<expr>!<name>have_idle_worker</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>rv</name> = <call><name>ap_queue_info_wait_for_idler</name><argument_list>(<argument><expr><name>worker_queue_info</name></expr></argument>,
<argument><expr>&amp;<name>ptrans</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>APR_STATUS_IS_EOF</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<break>break;</break>
}</block></then> <else>else <if>if <condition>(<expr><name>rv</name> != <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_EMERG</name></expr></argument>, <argument><expr><name>rv</name></expr></argument>, <argument><expr><name>ap_server_conf</name></expr></argument>,
<argument><expr>"apr_queue_info_wait failed. Attempting to "
" shutdown process gracefully."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>signal_threads</name><argument_list>(<argument><expr><name>ST_GRACEFUL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
}</block></then></if></else></if>
<expr_stmt><expr><name>have_idle_worker</name> = 1</expr>;</expr_stmt>
}</block></then></if>
<if>if <condition>(<expr>(<name>rv</name> = <call><name>SAFE_ACCEPT</name><argument_list>(<argument><expr><call><name>apr_proc_mutex_lock</name><argument_list>(<argument><expr><name><name>my_bucket</name>-&gt;<name>mutex</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>)
!= <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr>!<name>listener_may_exit</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>accept_mutex_error</name><argument_list>(<argument><expr>"lock"</expr></argument>, <argument><expr><name>rv</name></expr></argument>, <argument><expr><name>process_slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<break>break;</break>
}</block></then></if>
<if>if <condition>(<expr>!<name><name>my_bucket</name>-&gt;<name>listeners</name>-&gt;<name>next</name></name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>lr</name> = <name><name>my_bucket</name>-&gt;<name>listeners</name></name></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<while>while <condition>(<expr>!<name>listener_may_exit</name></expr>)</condition> <block>{
<decl_stmt><decl><type><name>apr_int32_t</name></type> <name>numdesc</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>apr_pollfd_t</name> *</type><name>pdesc</name></decl>;</decl_stmt>
<expr_stmt><expr><name>rv</name> = <call><name>apr_pollset_poll</name><argument_list>(<argument><expr><name>pollset</name></expr></argument>, <argument><expr>-1</expr></argument>, <argument><expr>&amp;<name>numdesc</name></expr></argument>, <argument><expr>&amp;<name>pdesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>rv</name> != <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr><call><name>APR_STATUS_IS_EINTR</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<continue>continue;</continue>
}</block></then></if>
<expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_ERR</name></expr></argument>, <argument><expr><name>rv</name></expr></argument>, <argument><expr><name>ap_server_conf</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>03137</expr></argument>)</argument_list></call>
"apr_pollset_poll: (listen)"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>signal_threads</name><argument_list>(<argument><expr><name>ST_GRACEFUL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<if>if <condition>(<expr><name>listener_may_exit</name></expr>)</condition><then> <break>break;</break></then></if>
<if>if <condition>(<expr><name>last_poll_idx</name> &gt;= <name>numdesc</name></expr>)</condition><then>
<expr_stmt><expr><name>last_poll_idx</name> = 0</expr>;</expr_stmt></then></if>
<expr_stmt><expr><name>lr</name> = <name><name>pdesc</name><index>[<expr><name>last_poll_idx</name>++</expr>]</index></name>.<name>client_data</name></expr>;</expr_stmt>
<break>break;</break>
}</block></while>
}</block></else></if>
<if>if <condition>(<expr>!<name>listener_may_exit</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr><name>ptrans</name> == <name>NULL</name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>apr_allocator_t</name> *</type><name>allocator</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>apr_allocator_create</name><argument_list>(<argument><expr>&amp;<name>allocator</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>apr_allocator_max_free_set</name><argument_list>(<argument><expr><name>allocator</name></expr></argument>, <argument><expr><name>ap_max_mem_free</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>apr_pool_create_ex</name><argument_list>(<argument><expr>&amp;<name>ptrans</name></expr></argument>, <argument><expr><name>pconf</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>allocator</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>apr_allocator_owner_set</name><argument_list>(<argument><expr><name>allocator</name></expr></argument>, <argument><expr><name>ptrans</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><call><name>apr_pool_tag</name><argument_list>(<argument><expr><name>ptrans</name></expr></argument>, <argument><expr>"transaction"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>rv</name> = <call><name><name>lr</name>-&gt;<name>accept_func</name></name><argument_list>(<argument><expr>&amp;<name>csd</name></expr></argument>, <argument><expr><name>lr</name></expr></argument>, <argument><expr><name>ptrans</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>AP_DEBUG_ASSERT</name><argument_list>(<argument><expr><name>rv</name> == <name>APR_SUCCESS</name> || !<name>csd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>rv</name> == <name>APR_EGENERAL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>resource_shortage</name> = 1</expr>;</expr_stmt>
<expr_stmt><expr><call><name>signal_threads</name><argument_list>(<argument><expr><name>ST_GRACEFUL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<if>if <condition>(<expr>(<name>rv</name> = <call><name>SAFE_ACCEPT</name><argument_list>(<argument><expr><call><name>apr_proc_mutex_unlock</name><argument_list>(<argument><expr><name><name>my_bucket</name>-&gt;<name>mutex</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>)
!= <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr><name>listener_may_exit</name></expr>)</condition><then> <block>{
<break>break;</break>
}</block></then></if>
<expr_stmt><expr><call><name>accept_mutex_error</name><argument_list>(<argument><expr>"unlock"</expr></argument>, <argument><expr><name>rv</name></expr></argument>, <argument><expr><name>process_slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<if>if <condition>(<expr><name>csd</name> != <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>rv</name> = <call><name>ap_queue_push</name><argument_list>(<argument><expr><name>worker_queue</name></expr></argument>, <argument><expr><name>csd</name></expr></argument>, <argument><expr><name>ptrans</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>rv</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>apr_socket_close</name><argument_list>(<argument><expr><name>csd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_CRIT</name></expr></argument>, <argument><expr><name>rv</name></expr></argument>, <argument><expr><name>ap_server_conf</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>03138</expr></argument>)</argument_list></call>
"ap_queue_push failed"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr><name>have_idle_worker</name> = 0</expr>;</expr_stmt>
}</block></else></if>
}</block></then></if>
}</block></then> <else>else <block>{
<if>if <condition>(<expr>(<name>rv</name> = <call><name>SAFE_ACCEPT</name><argument_list>(<argument><expr><call><name>apr_proc_mutex_unlock</name><argument_list>(<argument><expr><name><name>my_bucket</name>-&gt;<name>mutex</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>)
!= <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>level</name> <init>= <expr><name>APLOG_EMERG</name></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name><name>ap_scoreboard_image</name>-&gt;<name>parent</name><index>[<expr><name>process_slot</name></expr>]</index></name>.<name>generation</name> !=
<name><name>ap_scoreboard_image</name>-&gt;<name>global</name>-&gt;<name>running_generation</name></name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>level</name> = <name>APLOG_DEBUG</name></expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>level</name></expr></argument>, <argument><expr><name>rv</name></expr></argument>, <argument><expr><name>ap_server_conf</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00274</expr></argument>)</argument_list></call>
"apr_proc_mutex_unlock failed. Attempting to "
"shutdown process gracefully."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>signal_threads</name><argument_list>(<argument><expr><name>ST_GRACEFUL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<break>break;</break>
}</block></else></if>
}</block></while>
<expr_stmt><expr><call><name>ap_close_listeners_ex</name><argument_list>(<argument><expr><name><name>my_bucket</name>-&gt;<name>listeners</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ap_queue_term</name><argument_list>(<argument><expr><name>worker_queue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>dying</name> = 1</expr>;</expr_stmt>
<expr_stmt><expr><name><name>ap_scoreboard_image</name>-&gt;<name>parent</name><index>[<expr><name>process_slot</name></expr>]</index></name>.<name>quiescing</name> = 1</expr>;</expr_stmt>
<expr_stmt><expr><call><name>kill</name><argument_list>(<argument><expr><name>ap_my_pid</name></expr></argument>, <argument><expr><name>SIGTERM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>apr_thread_exit</name><argument_list>(<argument><expr><name>thd</name></expr></argument>, <argument><expr><name>APR_SUCCESS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>void</name> * <name>APR_THREAD_FUNC</name></type> <name>worker_thread</name><parameter_list>(<param><decl><type><name>apr_thread_t</name> *</type><name>thd</name></decl></param>, <param><decl><type><name>void</name> *</type> <name>dummy</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>proc_info</name> *</type> <name>ti</name> <init>= <expr><name>dummy</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>process_slot</name> <init>= <expr><name><name>ti</name>-&gt;<name>pid</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>thread_slot</name> <init>= <expr><name><name>ti</name>-&gt;<name>tid</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>apr_socket_t</name> *</type><name>csd</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>apr_bucket_alloc_t</name> *</type><name>bucket_alloc</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>last_ptrans</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>ptrans</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>apr_status_t</name></type> <name>rv</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>is_idle</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>ti</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ap_scoreboard_image</name>-&gt;<name>servers</name><index>[<expr><name>process_slot</name></expr>]</index><index>[<expr><name>thread_slot</name></expr>]</index></name>.<name>pid</name> = <name>ap_my_pid</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ap_scoreboard_image</name>-&gt;<name>servers</name><index>[<expr><name>process_slot</name></expr>]</index><index>[<expr><name>thread_slot</name></expr>]</index></name>.<name>tid</name> = <call><name>apr_os_thread_current</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ap_scoreboard_image</name>-&gt;<name>servers</name><index>[<expr><name>process_slot</name></expr>]</index><index>[<expr><name>thread_slot</name></expr>]</index></name>.<name>generation</name> = <name><name>retained</name>-&gt;<name>mpm</name>-&gt;<name>my_generation</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ap_update_child_status_from_indexes</name><argument_list>(<argument><expr><name>process_slot</name></expr></argument>, <argument><expr><name>thread_slot</name></expr></argument>,
<argument><expr><name>SERVER_STARTING</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_PTHREAD_KILL</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>unblock_signal</name><argument_list>(<argument><expr><name>WORKER_SIGNAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>apr_signal</name><argument_list>(<argument><expr><name>WORKER_SIGNAL</name></expr></argument>, <argument><expr><name>dummy_signal_handler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<while>while <condition>(<expr>!<name>workers_may_exit</name></expr>)</condition> <block>{
<if>if <condition>(<expr>!<name>is_idle</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>rv</name> = <call><name>ap_queue_info_set_idle</name><argument_list>(<argument><expr><name>worker_queue_info</name></expr></argument>, <argument><expr><name>last_ptrans</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>last_ptrans</name> = <name>NULL</name></expr>;</expr_stmt>
<if>if <condition>(<expr><name>rv</name> != <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_EMERG</name></expr></argument>, <argument><expr><name>rv</name></expr></argument>, <argument><expr><name>ap_server_conf</name></expr></argument>,
<argument><expr>"ap_queue_info_set_idle failed. Attempting to "
"shutdown process gracefully."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>signal_threads</name><argument_list>(<argument><expr><name>ST_GRACEFUL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
}</block></then></if>
<expr_stmt><expr><name>is_idle</name> = 1</expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><call><name>ap_update_child_status_from_indexes</name><argument_list>(<argument><expr><name>process_slot</name></expr></argument>, <argument><expr><name>thread_slot</name></expr></argument>,
<argument><expr><name>SERVER_READY</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<label><name>worker_pop</name>:</label>
<if>if <condition>(<expr><name>workers_may_exit</name></expr>)</condition><then> <block>{
<break>break;</break>
}</block></then></if>
<expr_stmt><expr><name>rv</name> = <call><name>ap_queue_pop</name><argument_list>(<argument><expr><name>worker_queue</name></expr></argument>, <argument><expr>&amp;<name>csd</name></expr></argument>, <argument><expr>&amp;<name>ptrans</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>rv</name> != <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr><call><name>APR_STATUS_IS_EOF</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<break>break;</break>
}</block></then>
<else>else <if>if <condition>(<expr><call><name>APR_STATUS_IS_EINTR</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<goto>goto <name>worker_pop</name>;</goto>
}</block></then>
<else>else <if>if <condition>(<expr>!<name>workers_may_exit</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_CRIT</name></expr></argument>, <argument><expr><name>rv</name></expr></argument>, <argument><expr><name>ap_server_conf</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>03139</expr></argument>)</argument_list></call>
"ap_queue_pop failed"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if></else></if></else></if>
<continue>continue;</continue>
}</block></then></if>
<expr_stmt><expr><name>is_idle</name> = 0</expr>;</expr_stmt>
<expr_stmt><expr><name><name>worker_sockets</name><index>[<expr><name>thread_slot</name></expr>]</index></name> = <name>csd</name></expr>;</expr_stmt>
<expr_stmt><expr><name>bucket_alloc</name> = <call><name>apr_bucket_alloc_create</name><argument_list>(<argument><expr><name>ptrans</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>process_socket</name><argument_list>(<argument><expr><name>thd</name></expr></argument>, <argument><expr><name>ptrans</name></expr></argument>, <argument><expr><name>csd</name></expr></argument>, <argument><expr><name>process_slot</name></expr></argument>, <argument><expr><name>thread_slot</name></expr></argument>, <argument><expr><name>bucket_alloc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>worker_sockets</name><index>[<expr><name>thread_slot</name></expr>]</index></name> = <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name>requests_this_child</name>--</expr>;</expr_stmt>
<expr_stmt><expr><call><name>apr_pool_clear</name><argument_list>(<argument><expr><name>ptrans</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>last_ptrans</name> = <name>ptrans</name></expr>;</expr_stmt>
}</block></while>
<expr_stmt><expr><call><name>ap_update_child_status_from_indexes</name><argument_list>(<argument><expr><name>process_slot</name></expr></argument>, <argument><expr><name>thread_slot</name></expr></argument>,
<argument><expr><name>dying</name> ? <name>SERVER_DEAD</name>
: <name>SERVER_GRACEFUL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>apr_thread_exit</name><argument_list>(<argument><expr><name>thd</name></expr></argument>, <argument><expr><name>APR_SUCCESS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>check_signal</name><parameter_list>(<param><decl><type><name>int</name></type> <name>signum</name></decl></param>)</parameter_list> <block>{
<switch>switch <condition>(<expr><name>signum</name></expr>)</condition> <block>{
<case>case <expr><name>SIGTERM</name></expr>:
</case><case>case <expr><name>SIGINT</name></expr>:
<return>return <expr>1</expr>;</return>
</case>}</block></switch>
<return>return <expr>0</expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>create_listener_thread</name><parameter_list>(<param><decl><type><name>thread_starter</name> *</type><name>ts</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>my_child_num</name> <init>= <expr><name><name>ts</name>-&gt;<name>child_num_arg</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>apr_threadattr_t</name> *</type><name>thread_attr</name> <init>= <expr><name><name>ts</name>-&gt;<name>threadattr</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>proc_info</name> *</type><name>my_info</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>apr_status_t</name></type> <name>rv</name></decl>;</decl_stmt>
<expr_stmt><expr><name>my_info</name> = (<name>proc_info</name> *)<call><name>ap_malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>proc_info</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>my_info</name>-&gt;<name>pid</name></name> = <name>my_child_num</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>my_info</name>-&gt;<name>tid</name></name> = -1</expr>;</expr_stmt>
<expr_stmt><expr><name><name>my_info</name>-&gt;<name>sd</name></name> = 0</expr>;</expr_stmt>
<expr_stmt><expr><name>rv</name> = <call><name>apr_thread_create</name><argument_list>(<argument><expr>&amp;<name><name>ts</name>-&gt;<name>listener</name></name></expr></argument>, <argument><expr><name>thread_attr</name></expr></argument>, <argument><expr><name>listener_thread</name></expr></argument>,
<argument><expr><name>my_info</name></expr></argument>, <argument><expr><name>pchild</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>rv</name> != <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_ALERT</name></expr></argument>, <argument><expr><name>rv</name></expr></argument>, <argument><expr><name>ap_server_conf</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00275</expr></argument>)</argument_list></call>
"apr_thread_create: unable to create listener thread"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>clean_child_exit</name><argument_list>(<argument><expr><name>APEXIT_CHILDSICK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><call><name>apr_os_thread_get</name><argument_list>(<argument><expr>&amp;<name>listener_os_thread</name></expr></argument>, <argument><expr><name><name>ts</name>-&gt;<name>listener</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>
<function><type><specifier>static</specifier> <name>void</name> * <name>APR_THREAD_FUNC</name></type> <name>start_threads</name><parameter_list>(<param><decl><type><name>apr_thread_t</name> *</type><name>thd</name></decl></param>, <param><decl><type><name>void</name> *</type><name>dummy</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>thread_starter</name> *</type><name>ts</name> <init>= <expr><name>dummy</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>apr_thread_t</name> **</type><name>threads</name> <init>= <expr><name><name>ts</name>-&gt;<name>threads</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>apr_threadattr_t</name> *</type><name>thread_attr</name> <init>= <expr><name><name>ts</name>-&gt;<name>threadattr</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>my_child_num</name> <init>= <expr><name><name>ts</name>-&gt;<name>child_num_arg</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>proc_info</name> *</type><name>my_info</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>apr_status_t</name></type> <name>rv</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>threads_created</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>listener_started</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>loops</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>prev_threads_created</name></decl>;</decl_stmt>
<expr_stmt><expr><name>worker_queue</name> = <call><name>apr_pcalloc</name><argument_list>(<argument><expr><name>pchild</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>*<name>worker_queue</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>rv</name> = <call><name>ap_queue_init</name><argument_list>(<argument><expr><name>worker_queue</name></expr></argument>, <argument><expr><name>threads_per_child</name></expr></argument>, <argument><expr><name>pchild</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>rv</name> != <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_ALERT</name></expr></argument>, <argument><expr><name>rv</name></expr></argument>, <argument><expr><name>ap_server_conf</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>03140</expr></argument>)</argument_list></call>
"ap_queue_init() failed"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>clean_child_exit</name><argument_list>(<argument><expr><name>APEXIT_CHILDFATAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><name>rv</name> = <call><name>ap_queue_info_create</name><argument_list>(<argument><expr>&amp;<name>worker_queue_info</name></expr></argument>, <argument><expr><name>pchild</name></expr></argument>,
<argument><expr><name>threads_per_child</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>rv</name> != <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_ALERT</name></expr></argument>, <argument><expr><name>rv</name></expr></argument>, <argument><expr><name>ap_server_conf</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>03141</expr></argument>)</argument_list></call>
"ap_queue_info_create() failed"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>clean_child_exit</name><argument_list>(<argument><expr><name>APEXIT_CHILDFATAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><name>worker_sockets</name> = <call><name>apr_pcalloc</name><argument_list>(<argument><expr><name>pchild</name></expr></argument>, <argument><expr><name>threads_per_child</name>
* <sizeof>sizeof<argument_list>(<argument><expr><name>apr_socket_t</name> *</expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>loops</name> = <name>prev_threads_created</name> = 0</expr>;</expr_stmt>
<while>while <condition>(<expr>1</expr>)</condition> <block>{
<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>threads_per_child</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
<decl_stmt><decl><type><name>int</name></type> <name>status</name> <init>= <expr><name><name>ap_scoreboard_image</name>-&gt;<name>servers</name><index>[<expr><name>my_child_num</name></expr>]</index><index>[<expr><name>i</name></expr>]</index></name>.<name>status</name></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>status</name> != <name>SERVER_GRACEFUL</name> &amp;&amp; <name>status</name> != <name>SERVER_DEAD</name></expr>)</condition><then> <block>{
<continue>continue;</continue>
}</block></then></if>
<expr_stmt><expr><name>my_info</name> = (<name>proc_info</name> *)<call><name>ap_malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>proc_info</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>my_info</name>-&gt;<name>pid</name></name> = <name>my_child_num</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>my_info</name>-&gt;<name>tid</name></name> = <name>i</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>my_info</name>-&gt;<name>sd</name></name> = 0</expr>;</expr_stmt>
<expr_stmt><expr><call><name>ap_update_child_status_from_indexes</name><argument_list>(<argument><expr><name>my_child_num</name></expr></argument>, <argument><expr><name>i</name></expr></argument>,
<argument><expr><name>SERVER_STARTING</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>rv</name> = <call><name>apr_thread_create</name><argument_list>(<argument><expr>&amp;<name><name>threads</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>thread_attr</name></expr></argument>,
<argument><expr><name>worker_thread</name></expr></argument>, <argument><expr><name>my_info</name></expr></argument>, <argument><expr><name>pchild</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>rv</name> != <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_ALERT</name></expr></argument>, <argument><expr><name>rv</name></expr></argument>, <argument><expr><name>ap_server_conf</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>03142</expr></argument>)</argument_list></call>
"apr_thread_create: unable to create worker thread"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>clean_child_exit</name><argument_list>(<argument><expr><name>APEXIT_CHILDSICK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><name>threads_created</name>++</expr>;</expr_stmt>
}</block></for>
<if>if <condition>(<expr>!<name>listener_started</name> &amp;&amp; <name>threads_created</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>create_listener_thread</name><argument_list>(<argument><expr><name>ts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>listener_started</name> = 1</expr>;</expr_stmt>
}</block></then></if>
<if>if <condition>(<expr><name>start_thread_may_exit</name> || <name>threads_created</name> == <name>threads_per_child</name></expr>)</condition><then> <block>{
<break>break;</break>
}</block></then></if>
<expr_stmt><expr><call><name>apr_sleep</name><argument_list>(<argument><expr><call><name>apr_time_from_sec</name><argument_list>(<argument><expr>1</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr>++<name>loops</name></expr>;</expr_stmt>
<if>if <condition>(<expr><name>loops</name> % 120 == 0</expr>)</condition><then> <block>{
<if>if <condition>(<expr><name>prev_threads_created</name> == <name>threads_created</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_DEBUG</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>ap_server_conf</name></expr></argument>,
<argument><expr>"child %" <name>APR_PID_T_FMT</name> " isn't taking over "
"slots very quickly (%d of %d)"</expr></argument>,
<argument><expr><name>ap_my_pid</name></expr></argument>, <argument><expr><name>threads_created</name></expr></argument>, <argument><expr><name>threads_per_child</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><name>prev_threads_created</name> = <name>threads_created</name></expr>;</expr_stmt>
}</block></then></if>
}</block></while>
<expr_stmt><expr><call><name>apr_thread_exit</name><argument_list>(<argument><expr><name>thd</name></expr></argument>, <argument><expr><name>APR_SUCCESS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>join_workers</name><parameter_list>(<param><decl><type><name>apr_thread_t</name> *</type><name>listener</name></decl></param>, <param><decl><type><name>apr_thread_t</name> **</type><name>threads</name></decl></param>,
<param><decl><type><name>int</name></type> <name>mode</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>apr_status_t</name></type> <name>rv</name></decl>, <decl><type ref="prev"/><name>thread_rv</name></decl>;</decl_stmt>
<if>if <condition>(<expr><name>listener</name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>iter</name></decl>;</decl_stmt>
<expr_stmt><expr><name>iter</name> = 0</expr>;</expr_stmt>
<while>while <condition>(<expr><name>iter</name> &lt; 10 &amp;&amp;
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_PTHREAD_KILL</name></expr></argument>)</argument_list></call></expr></cpp:if>
<call><name>pthread_kill</name><argument_list>(<argument><expr>*<name>listener_os_thread</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<call><name>kill</name><argument_list>(<argument><expr><name>ap_my_pid</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
== 0</expr>)</condition> <block>{
<expr_stmt><expr><call><name>apr_sleep</name><argument_list>(<argument><expr><call><name>apr_time_make</name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr>500000</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>wakeup_listener</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr>++<name>iter</name></expr>;</expr_stmt>
}</block></while>
<if>if <condition>(<expr><name>iter</name> &gt;= 10</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_DEBUG</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>ap_server_conf</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00276</expr></argument>)</argument_list></call>
"the listener thread didn't exit"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr><name>rv</name> = <call><name>apr_thread_join</name><argument_list>(<argument><expr>&amp;<name>thread_rv</name></expr></argument>, <argument><expr><name>listener</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>rv</name> != <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_CRIT</name></expr></argument>, <argument><expr><name>rv</name></expr></argument>, <argument><expr><name>ap_server_conf</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00277</expr></argument>)</argument_list></call>
"apr_thread_join: unable to join listener thread"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
}</block></else></if>
}</block></then></if>
<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>threads_per_child</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
<if>if <condition>(<expr><name><name>threads</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><then> <block>{
<if>if <condition>(<expr><name>mode</name> != <name>ST_GRACEFUL</name></expr>)</condition><then> <block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_PTHREAD_KILL</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>apr_os_thread_t</name> *</type><name>worker_os_thread</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>apr_os_thread_get</name><argument_list>(<argument><expr>&amp;<name>worker_os_thread</name></expr></argument>, <argument><expr><name><name>threads</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>pthread_kill</name><argument_list>(<argument><expr>*<name>worker_os_thread</name></expr></argument>, <argument><expr><name>WORKER_SIGNAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></then></if>
<expr_stmt><expr><name>rv</name> = <call><name>apr_thread_join</name><argument_list>(<argument><expr>&amp;<name>thread_rv</name></expr></argument>, <argument><expr><name><name>threads</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>rv</name> != <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_CRIT</name></expr></argument>, <argument><expr><name>rv</name></expr></argument>, <argument><expr><name>ap_server_conf</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00278</expr></argument>)</argument_list></call>
"apr_thread_join: unable to join worker "
"thread %d"</expr></argument>,
<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
}</block></then></if>
}</block></for>
}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>join_start_thread</name><parameter_list>(<param><decl><type><name>apr_thread_t</name> *</type><name>start_thread_id</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>apr_status_t</name></type> <name>rv</name></decl>, <decl><type ref="prev"/><name>thread_rv</name></decl>;</decl_stmt>
<expr_stmt><expr><name>start_thread_may_exit</name> = 1</expr>;</expr_stmt>
<expr_stmt><expr><name>rv</name> = <call><name>apr_thread_join</name><argument_list>(<argument><expr>&amp;<name>thread_rv</name></expr></argument>, <argument><expr><name>start_thread_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>rv</name> != <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_CRIT</name></expr></argument>, <argument><expr><name>rv</name></expr></argument>, <argument><expr><name>ap_server_conf</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00279</expr></argument>)</argument_list></call>
"apr_thread_join: unable to join the start "
"thread"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>child_main</name><parameter_list>(<param><decl><type><name>int</name></type> <name>child_num_arg</name></decl></param>, <param><decl><type><name>int</name></type> <name>child_bucket</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>apr_thread_t</name> **</type><name>threads</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>apr_status_t</name></type> <name>rv</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>thread_starter</name> *</type><name>ts</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>apr_threadattr_t</name> *</type><name>thread_attr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>apr_thread_t</name> *</type><name>start_thread_id</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<expr_stmt><expr><name><name>retained</name>-&gt;<name>mpm</name>-&gt;<name>mpm_state</name></name> = <name>AP_MPMQ_STARTING</name></expr>;</expr_stmt>
<expr_stmt><expr><name>ap_my_pid</name> = <call><name>getpid</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ap_fatal_signal_child_setup</name><argument_list>(<argument><expr><name>ap_server_conf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>apr_pool_create</name><argument_list>(<argument><expr>&amp;<name>pchild</name></expr></argument>, <argument><expr><name>pconf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name><name>retained</name>-&gt;<name>mpm</name>-&gt;<name>num_buckets</name></name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
<if>if <condition>(<expr><name>i</name> != <name>child_bucket</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>ap_close_listeners_ex</name><argument_list>(<argument><expr><name><name>all_buckets</name><index>[<expr><name>i</name></expr>]</index></name>.<name>listeners</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ap_mpm_podx_close</name><argument_list>(<argument><expr><name><name>all_buckets</name><index>[<expr><name>i</name></expr>]</index></name>.<name>pod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
}</block></for>
<expr_stmt><expr><call><name>ap_reopen_scoreboard</name><argument_list>(<argument><expr><name>pchild</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>rv</name> = <call><name>SAFE_ACCEPT</name><argument_list>(<argument><expr><call><name>apr_proc_mutex_child_init</name><argument_list>(<argument><expr>&amp;<name><name>my_bucket</name>-&gt;<name>mutex</name></name></expr></argument>,
<argument><expr><call><name>apr_proc_mutex_lockfile</name><argument_list>(<argument><expr><name><name>my_bucket</name>-&gt;<name>mutex</name></name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>pchild</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>rv</name> != <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_EMERG</name></expr></argument>, <argument><expr><name>rv</name></expr></argument>, <argument><expr><name>ap_server_conf</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00280</expr></argument>)</argument_list></call>
"Couldn't initialize cross-process lock in child"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>clean_child_exit</name><argument_list>(<argument><expr><name>APEXIT_CHILDFATAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<if>if <condition>(<expr><call><name>ap_run_drop_privileges</name><argument_list>(<argument><expr><name>pchild</name></expr></argument>, <argument><expr><name>ap_server_conf</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>clean_child_exit</name><argument_list>(<argument><expr><name>APEXIT_CHILDFATAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><call><name>ap_run_child_init</name><argument_list>(<argument><expr><name>pchild</name></expr></argument>, <argument><expr><name>ap_server_conf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>rv</name> = <call><name>apr_setup_signal_thread</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>rv</name> != <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_EMERG</name></expr></argument>, <argument><expr><name>rv</name></expr></argument>, <argument><expr><name>ap_server_conf</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00281</expr></argument>)</argument_list></call>
"Couldn't initialize signal thread"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>clean_child_exit</name><argument_list>(<argument><expr><name>APEXIT_CHILDFATAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<if>if <condition>(<expr><name>ap_max_requests_per_child</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>requests_this_child</name> = <name>ap_max_requests_per_child</name></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr><name>requests_this_child</name> = <name>INT_MAX</name></expr>;</expr_stmt>
}</block></else></if>
<expr_stmt><expr><name>threads</name> = (<name>apr_thread_t</name> **)<call><name>ap_calloc</name><argument_list>(<argument><expr>1</expr></argument>,
<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>apr_thread_t</name> *</expr></argument>)</argument_list></sizeof> * <name>threads_per_child</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ts</name> = (<name>thread_starter</name> *)<call><name>apr_palloc</name><argument_list>(<argument><expr><name>pchild</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>*<name>ts</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>apr_threadattr_create</name><argument_list>(<argument><expr>&amp;<name>thread_attr</name></expr></argument>, <argument><expr><name>pchild</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>apr_threadattr_detach_set</name><argument_list>(<argument><expr><name>thread_attr</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>ap_thread_stacksize</name> != 0</expr>)</condition><then> <block>{
<expr_stmt><expr><name>rv</name> = <call><name>apr_threadattr_stacksize_set</name><argument_list>(<argument><expr><name>thread_attr</name></expr></argument>, <argument><expr><name>ap_thread_stacksize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>rv</name> != <name>APR_SUCCESS</name> &amp;&amp; <name>rv</name> != <name>APR_ENOTIMPL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_WARNING</name></expr></argument>, <argument><expr><name>rv</name></expr></argument>, <argument><expr><name>ap_server_conf</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>02435</expr></argument>)</argument_list></call>
"WARNING: ThreadStackSize of %" <name>APR_SIZE_T_FMT</name> " is "
"inappropriate, using default"</expr></argument>,
<argument><expr><name>ap_thread_stacksize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
}</block></then></if>
<expr_stmt><expr><name><name>ts</name>-&gt;<name>threads</name></name> = <name>threads</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ts</name>-&gt;<name>listener</name></name> = <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ts</name>-&gt;<name>child_num_arg</name></name> = <name>child_num_arg</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ts</name>-&gt;<name>threadattr</name></name> = <name>thread_attr</name></expr>;</expr_stmt>
<expr_stmt><expr><name>rv</name> = <call><name>apr_thread_create</name><argument_list>(<argument><expr>&amp;<name>start_thread_id</name></expr></argument>, <argument><expr><name>thread_attr</name></expr></argument>, <argument><expr><name>start_threads</name></expr></argument>,
<argument><expr><name>ts</name></expr></argument>, <argument><expr><name>pchild</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>rv</name> != <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_ALERT</name></expr></argument>, <argument><expr><name>rv</name></expr></argument>, <argument><expr><name>ap_server_conf</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00282</expr></argument>)</argument_list></call>
"apr_thread_create: unable to create worker thread"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>clean_child_exit</name><argument_list>(<argument><expr><name>APEXIT_CHILDSICK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><name><name>retained</name>-&gt;<name>mpm</name>-&gt;<name>mpm_state</name></name> = <name>AP_MPMQ_RUNNING</name></expr>;</expr_stmt>
<if>if <condition>(<expr><name>one_process</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>apr_signal_thread</name><argument_list>(<argument><expr><name>check_signal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>join_start_thread</name><argument_list>(<argument><expr><name>start_thread_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>signal_threads</name><argument_list>(<argument><expr><name>ST_UNGRACEFUL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>join_workers</name><argument_list>(<argument><expr><name><name>ts</name>-&gt;<name>listener</name></name></expr></argument>, <argument><expr><name>threads</name></expr></argument>, <argument><expr><name>ST_UNGRACEFUL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr><call><name>unblock_signal</name><argument_list>(<argument><expr><name>SIGTERM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>apr_signal</name><argument_list>(<argument><expr><name>SIGTERM</name></expr></argument>, <argument><expr><name>dummy_signal_handler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<while>while <condition>(<expr>1</expr>)</condition> <block>{
<expr_stmt><expr><name>rv</name> = <call><name>ap_mpm_podx_check</name><argument_list>(<argument><expr><name><name>my_bucket</name>-&gt;<name>pod</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>rv</name> == <name>AP_MPM_PODX_NORESTART</name></expr>)</condition><then> <block>{
<switch>switch<condition>(<expr><name>terminate_mode</name></expr>)</condition> <block>{
<case>case <expr><name>ST_GRACEFUL</name></expr>:
<expr_stmt><expr><name>rv</name> = <name>AP_MPM_PODX_GRACEFUL</name></expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr><name>ST_UNGRACEFUL</name></expr>:
<expr_stmt><expr><name>rv</name> = <name>AP_MPM_PODX_RESTART</name></expr>;</expr_stmt>
<break>break;</break>
</case>}</block></switch>
}</block></then></if>
<if>if <condition>(<expr><name>rv</name> == <name>AP_MPM_PODX_GRACEFUL</name> || <name>rv</name> == <name>AP_MPM_PODX_RESTART</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>join_start_thread</name><argument_list>(<argument><expr><name>start_thread_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>signal_threads</name><argument_list>(<argument><expr><name>rv</name> == <name>AP_MPM_PODX_GRACEFUL</name> ? <name>ST_GRACEFUL</name> : <name>ST_UNGRACEFUL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
}</block></then></if>
}</block></while>
<expr_stmt><expr><call><name>join_workers</name><argument_list>(<argument><expr><name><name>ts</name>-&gt;<name>listener</name></name></expr></argument>, <argument><expr><name>threads</name></expr></argument>,
<argument><expr><name>rv</name> == <name>AP_MPM_PODX_GRACEFUL</name> ? <name>ST_GRACEFUL</name> : <name>ST_UNGRACEFUL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></else></if>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>threads</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>clean_child_exit</name><argument_list>(<argument><expr><name>resource_shortage</name> ? <name>APEXIT_CHILDSICK</name> : 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>make_child</name><parameter_list>(<param><decl><type><name>server_rec</name> *</type><name>s</name></decl></param>, <param><decl><type><name>int</name></type> <name>slot</name></decl></param>, <param><decl><type><name>int</name></type> <name>bucket</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>pid</name></decl>;</decl_stmt>
<if>if <condition>(<expr><name>slot</name> + 1 &gt; <name><name>retained</name>-&gt;<name>max_daemons_limit</name></name></expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>retained</name>-&gt;<name>max_daemons_limit</name></name> = <name>slot</name> + 1</expr>;</expr_stmt>
}</block></then></if>
<if>if <condition>(<expr><name>one_process</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>my_bucket</name> = &amp;<name><name>all_buckets</name><index>[<expr>0</expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>worker_note_child_started</name><argument_list>(<argument><expr><name>slot</name></expr></argument>, <argument><expr><call><name>getpid</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>child_main</name><argument_list>(<argument><expr><name>slot</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ap_assert</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>-1</expr>;</return>
}</block></then></if>
<if>if <condition>(<expr>(<name>pid</name> = <call><name>fork</name><argument_list>()</argument_list></call>) == -1</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_ERR</name></expr></argument>, <argument><expr><name>errno</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00283</expr></argument>)</argument_list></call>
"fork: Unable to fork new process"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>apr_sleep</name><argument_list>(<argument><expr><call><name>apr_time_from_sec</name><argument_list>(<argument><expr>10</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>-1</expr>;</return>
}</block></then></if>
<if>if <condition>(<expr>!<name>pid</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>my_bucket</name> = &amp;<name><name>all_buckets</name><index>[<expr><name>bucket</name></expr>]</index></name></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_BINDPROCESSOR</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>int</name></type> <name>status</name> <init>= <expr><call><name>bindprocessor</name><argument_list>(<argument><expr><name>BINDPROCESS</name></expr></argument>, <argument><expr>(<name>int</name>)<call><name>getpid</name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><name>PROCESSOR_CLASS_ANY</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>status</name> != <name>OK</name></expr>)</condition><then>
<expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_DEBUG</name></expr></argument>, <argument><expr><name>errno</name></expr></argument>,
<argument><expr><name>ap_server_conf</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00284</expr></argument>)</argument_list></call>
"processor unbind failed"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><call><name>RAISE_SIGSTOP</name><argument_list>(<argument><expr><name>MAKE_CHILD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>apr_signal</name><argument_list>(<argument><expr><name>SIGTERM</name></expr></argument>, <argument><expr><name>just_die</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>child_main</name><argument_list>(<argument><expr><name>slot</name></expr></argument>, <argument><expr><name>bucket</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ap_assert</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>-1</expr>;</return>
}</block></then></if>
<if>if <condition>(<expr><name><name>ap_scoreboard_image</name>-&gt;<name>parent</name><index>[<expr><name>slot</name></expr>]</index></name>.<name>pid</name> != 0</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>worker_note_child_lost_slot</name><argument_list>(<argument><expr><name>slot</name></expr></argument>, <argument><expr><name>pid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><name><name>ap_scoreboard_image</name>-&gt;<name>parent</name><index>[<expr><name>slot</name></expr>]</index></name>.<name>quiescing</name> = 0</expr>;</expr_stmt>
<expr_stmt><expr><name><name>ap_scoreboard_image</name>-&gt;<name>parent</name><index>[<expr><name>slot</name></expr>]</index></name>.<name>bucket</name> = <name>bucket</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>worker_note_child_started</name><argument_list>(<argument><expr><name>slot</name></expr></argument>, <argument><expr><name>pid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>0</expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>startup_children</name><parameter_list>(<param><decl><type><name>int</name></type> <name>number_to_start</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>number_to_start</name> &amp;&amp; <name>i</name> &lt; <name>ap_daemons_limit</name></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>) <block>{
<if>if <condition>(<expr><name><name>ap_scoreboard_image</name>-&gt;<name>parent</name><index>[<expr><name>i</name></expr>]</index></name>.<name>pid</name> != 0</expr>)</condition><then> <block>{
<continue>continue;</continue>
}</block></then></if>
<if>if <condition>(<expr><call><name>make_child</name><argument_list>(<argument><expr><name>ap_server_conf</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i</name> % <name><name>retained</name>-&gt;<name>mpm</name>-&gt;<name>num_buckets</name></name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then> <block>{
<break>break;</break>
}</block></then></if>
<expr_stmt><expr>--<name>number_to_start</name></expr>;</expr_stmt>
}</block></for>
}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>perform_idle_server_maintenance</name><parameter_list>(<param><decl><type><name>int</name></type> <name>child_bucket</name></decl></param>, <param><decl><type><name>int</name></type> <name>num_buckets</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>idle_thread_count</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>worker_score</name> *</type><name>ws</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>process_score</name> *</type><name>ps</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>free_length</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>totally_free_length</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name><name>free_slots</name><index>[<expr><name>MAX_SPAWN_RATE</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>last_non_dead</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>total_non_dead</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>active_thread_count</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>free_length</name> = 0</expr>;</expr_stmt>
<expr_stmt><expr><name>idle_thread_count</name> = 0</expr>;</expr_stmt>
<expr_stmt><expr><name>last_non_dead</name> = -1</expr>;</expr_stmt>
<expr_stmt><expr><name>total_non_dead</name> = 0</expr>;</expr_stmt>
<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>ap_daemons_limit</name></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>) <block>{
<decl_stmt><decl><type><name>int</name></type> <name>status</name> <init>= <expr><name>SERVER_DEAD</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>any_dying_threads</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>any_dead_threads</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>all_dead_threads</name> <init>= <expr>1</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>child_threads_active</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>i</name> &gt;= <name><name>retained</name>-&gt;<name>max_daemons_limit</name></name> &amp;&amp;
<name>totally_free_length</name> == <name><name>retained</name>-&gt;<name>idle_spawn_rate</name><index>[<expr><name>child_bucket</name></expr>]</index></name></expr>)</condition><then> <block>{
<break>break;</break>
}</block></then></if>
<expr_stmt><expr><name>ps</name> = &amp;<name><name>ap_scoreboard_image</name>-&gt;<name>parent</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
<for>for (<init><expr><name>j</name> = 0</expr>;</init> <condition><expr><name>j</name> &lt; <name>threads_per_child</name></expr>;</condition> <incr><expr><name>j</name>++</expr></incr>) <block>{
<expr_stmt><expr><name>ws</name> = &amp;<name><name>ap_scoreboard_image</name>-&gt;<name>servers</name><index>[<expr><name>i</name></expr>]</index><index>[<expr><name>j</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name>status</name> = <name><name>ws</name>-&gt;<name>status</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>any_dying_threads</name> = <name>any_dying_threads</name> ||
(<name>status</name> == <name>SERVER_GRACEFUL</name>)</expr>;</expr_stmt>
<expr_stmt><expr><name>any_dead_threads</name> = <name>any_dead_threads</name> || (<name>status</name> == <name>SERVER_DEAD</name>)</expr>;</expr_stmt>
<expr_stmt><expr><name>all_dead_threads</name> = <name>all_dead_threads</name> &amp;&amp;
(<name>status</name> == <name>SERVER_DEAD</name> ||
<name>status</name> == <name>SERVER_GRACEFUL</name>)</expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>ps</name>-&gt;<name>pid</name></name> != 0</expr>)</condition><then> <block>{
<if>if <condition>(<expr><name>status</name> &lt;= <name>SERVER_READY</name> &amp;&amp;
!<name><name>ps</name>-&gt;<name>quiescing</name></name> &amp;&amp;
<name><name>ps</name>-&gt;<name>generation</name></name> == <name><name>retained</name>-&gt;<name>mpm</name>-&gt;<name>my_generation</name></name> &amp;&amp;
<name><name>ps</name>-&gt;<name>bucket</name></name> == <name>child_bucket</name></expr>)</condition><then> <block>{
<expr_stmt><expr>++<name>idle_thread_count</name></expr>;</expr_stmt>
}</block></then></if>
<if>if <condition>(<expr><name>status</name> &gt;= <name>SERVER_READY</name> &amp;&amp; <name>status</name> &lt; <name>SERVER_GRACEFUL</name></expr>)</condition><then> <block>{
<expr_stmt><expr>++<name>child_threads_active</name></expr>;</expr_stmt>
}</block></then></if>
}</block></then></if>
}</block></for>
<expr_stmt><expr><name>active_thread_count</name> += <name>child_threads_active</name></expr>;</expr_stmt>
<if>if <condition>(<expr><name>any_dead_threads</name>
&amp;&amp; <name>totally_free_length</name> &lt; <name><name>retained</name>-&gt;<name>idle_spawn_rate</name><index>[<expr><name>child_bucket</name></expr>]</index></name>
&amp;&amp; <name>free_length</name> &lt; <name>MAX_SPAWN_RATE</name> / <name>num_buckets</name>
&amp;&amp; (!<name><name>ps</name>-&gt;<name>pid</name></name>
|| <name><name>ps</name>-&gt;<name>quiescing</name></name>)</expr>)</condition><then> <block>{
<if>if <condition>(<expr><name>all_dead_threads</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>free_slots</name><index>[<expr><name>free_length</name></expr>]</index></name> = <name><name>free_slots</name><index>[<expr><name>totally_free_length</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>free_slots</name><index>[<expr><name>totally_free_length</name>++</expr>]</index></name> = <name>i</name></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr><name><name>free_slots</name><index>[<expr><name>free_length</name></expr>]</index></name> = <name>i</name></expr>;</expr_stmt>
}</block></else></if>
<expr_stmt><expr>++<name>free_length</name></expr>;</expr_stmt>
}</block></then> <else>else <if>if <condition>(<expr><name>child_threads_active</name> == <name>threads_per_child</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>had_healthy_child</name> = 1</expr>;</expr_stmt>
}</block></then></if></else></if>
<if>if <condition>(<expr>!<name>any_dying_threads</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>last_non_dead</name> = <name>i</name></expr>;</expr_stmt>
<expr_stmt><expr>++<name>total_non_dead</name></expr>;</expr_stmt>
}</block></then></if>
}</block></for>
<if>if <condition>(<expr><name><name>retained</name>-&gt;<name>sick_child_detected</name></name></expr>)</condition><then> <block>{
<if>if <condition>(<expr><name>had_healthy_child</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>retained</name>-&gt;<name>sick_child_detected</name></name> = 0</expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr><name><name>retained</name>-&gt;<name>mpm</name>-&gt;<name>shutdown_pending</name></name> = 1</expr>;</expr_stmt>
<expr_stmt><expr><name>child_fatal</name> = 1</expr>;</expr_stmt>
<expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_ALERT</name></expr></argument>, <argument><expr>0</expr></argument>,
<argument><expr><name>ap_server_conf</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>02325</expr></argument>)</argument_list></call>
"A resource shortage or other unrecoverable failure "
"was encountered before any child process initialized "
"successfully... httpd is exiting!"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
}</block></else></if>
}</block></then></if>
<expr_stmt><expr><name><name>retained</name>-&gt;<name>max_daemons_limit</name></name> = <name>last_non_dead</name> + 1</expr>;</expr_stmt>
<if>if <condition>(<expr><name>idle_thread_count</name> &gt; <name>max_spare_threads</name> / <name>num_buckets</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>ap_mpm_podx_signal</name><argument_list>(<argument><expr><name><name>all_buckets</name><index>[<expr><name>child_bucket</name></expr>]</index></name>.<name>pod</name></expr></argument>,
<argument><expr><name>AP_MPM_PODX_GRACEFUL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>retained</name>-&gt;<name>idle_spawn_rate</name><index>[<expr><name>child_bucket</name></expr>]</index></name> = 1</expr>;</expr_stmt>
}</block></then> <else>else <if>if <condition>(<expr><name>idle_thread_count</name> &lt; <name>min_spare_threads</name> / <name>num_buckets</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr><name>free_length</name> == 0</expr>)</condition><then> <block>{
<if>if <condition>(<expr><name>active_thread_count</name> &gt;= <name>ap_daemons_limit</name> * <name>threads_per_child</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr>0 == <name>idle_thread_count</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr>!<name><name>retained</name>-&gt;<name>maxclients_reported</name></name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_ERR</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>ap_server_conf</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00286</expr></argument>)</argument_list></call>
"server reached MaxRequestWorkers "
"setting, consider raising the "
"MaxRequestWorkers setting"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>retained</name>-&gt;<name>maxclients_reported</name></name> = 1</expr>;</expr_stmt>
}</block></then></if>
}</block></then> <else>else <block>{
<if>if <condition>(<expr>!<name><name>retained</name>-&gt;<name>near_maxclients_reported</name></name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_ERR</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>ap_server_conf</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00287</expr></argument>)</argument_list></call>
"server is within MinSpareThreads of "
"MaxRequestWorkers, consider raising the "
"MaxRequestWorkers setting"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>retained</name>-&gt;<name>near_maxclients_reported</name></name> = 1</expr>;</expr_stmt>
}</block></then></if>
}</block></else></if>
}</block></then> <else>else <block>{
<expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_ERR</name></expr></argument>, <argument><expr>0</expr></argument>,
<argument><expr><name>ap_server_conf</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00288</expr></argument>)</argument_list></call>
"scoreboard is full, not at MaxRequestWorkers"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></else></if>
<expr_stmt><expr><name><name>retained</name>-&gt;<name>idle_spawn_rate</name><index>[<expr><name>child_bucket</name></expr>]</index></name> = 1</expr>;</expr_stmt>
}</block></then> <else>else <block>{
<if>if <condition>(<expr><name>free_length</name> &gt; <name><name>retained</name>-&gt;<name>idle_spawn_rate</name><index>[<expr><name>child_bucket</name></expr>]</index></name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>free_length</name> = <name><name>retained</name>-&gt;<name>idle_spawn_rate</name><index>[<expr><name>child_bucket</name></expr>]</index></name></expr>;</expr_stmt>
}</block></then></if>
<if>if <condition>(<expr><name><name>retained</name>-&gt;<name>idle_spawn_rate</name><index>[<expr><name>child_bucket</name></expr>]</index></name> &gt;= 8</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_INFO</name></expr></argument>, <argument><expr>0</expr></argument>,
<argument><expr><name>ap_server_conf</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00289</expr></argument>)</argument_list></call>
"server seems busy, (you may need "
"to increase StartServers, ThreadsPerChild "
"or Min/MaxSpareThreads), "
"spawning %d children, there are around %d idle "
"threads, and %d total children"</expr></argument>, <argument><expr><name>free_length</name></expr></argument>,
<argument><expr><name>idle_thread_count</name></expr></argument>, <argument><expr><name>total_non_dead</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>free_length</name></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>) <block>{
<expr_stmt><expr><call><name>make_child</name><argument_list>(<argument><expr><name>ap_server_conf</name></expr></argument>, <argument><expr><name><name>free_slots</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>child_bucket</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></for>
<if>if <condition>(<expr><name><name>retained</name>-&gt;<name>hold_off_on_exponential_spawning</name></name></expr>)</condition><then> <block>{
<expr_stmt><expr>--<name><name>retained</name>-&gt;<name>hold_off_on_exponential_spawning</name></name></expr>;</expr_stmt>
}</block></then> <else>else <if>if <condition>(<expr><name><name>retained</name>-&gt;<name>idle_spawn_rate</name><index>[<expr><name>child_bucket</name></expr>]</index></name>
&lt; <name>MAX_SPAWN_RATE</name> / <name>num_buckets</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>retained</name>-&gt;<name>idle_spawn_rate</name><index>[<expr><name>child_bucket</name></expr>]</index></name> *= 2</expr>;</expr_stmt>
}</block></then></if></else></if>
}</block></else></if>
}</block></then> <else>else <block>{
<expr_stmt><expr><name><name>retained</name>-&gt;<name>idle_spawn_rate</name><index>[<expr><name>child_bucket</name></expr>]</index></name> = 1</expr>;</expr_stmt>
}</block></else></if></else></if>
}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>server_main_loop</name><parameter_list>(<param><decl><type><name>int</name></type> <name>remaining_children_to_start</name></decl></param>, <param><decl><type><name>int</name></type> <name>num_buckets</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>ap_generation_t</name></type> <name>old_gen</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>child_slot</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>apr_exit_why_e</name></type> <name>exitwhy</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>status</name></decl>, <decl><type ref="prev"/><name>processed_status</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>apr_proc_t</name></type> <name>pid</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<while>while <condition>(<expr>!<name><name>retained</name>-&gt;<name>mpm</name>-&gt;<name>restart_pending</name></name> &amp;&amp; !<name><name>retained</name>-&gt;<name>mpm</name>-&gt;<name>shutdown_pending</name></name></expr>)</condition> <block>{
<expr_stmt><expr><call><name>ap_wait_or_timeout</name><argument_list>(<argument><expr>&amp;<name>exitwhy</name></expr></argument>, <argument><expr>&amp;<name>status</name></expr></argument>, <argument><expr>&amp;<name>pid</name></expr></argument>, <argument><expr><name>pconf</name></expr></argument>, <argument><expr><name>ap_server_conf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>pid</name>.<name>pid</name></name> != -1</expr>)</condition><then> <block>{
<expr_stmt><expr><name>processed_status</name> = <call><name>ap_process_child_status</name><argument_list>(<argument><expr>&amp;<name>pid</name></expr></argument>, <argument><expr><name>exitwhy</name></expr></argument>, <argument><expr><name>status</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>child_slot</name> = <call><name>ap_find_child_by_pid</name><argument_list>(<argument><expr>&amp;<name>pid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>processed_status</name> == <name>APEXIT_CHILDFATAL</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr><name>child_slot</name> &lt; 0
|| <call><name>ap_get_scoreboard_process</name><argument_list>(<argument><expr><name>child_slot</name></expr></argument>)</argument_list></call>-&gt;<name>generation</name>
== <name><name>retained</name>-&gt;<name>mpm</name>-&gt;<name>my_generation</name></name></expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>retained</name>-&gt;<name>mpm</name>-&gt;<name>shutdown_pending</name></name> = 1</expr>;</expr_stmt>
<expr_stmt><expr><name>child_fatal</name> = 1</expr>;</expr_stmt>
<return>return;</return>
}</block></then> <else>else <block>{
<expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_WARNING</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>ap_server_conf</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00290</expr></argument>)</argument_list></call>
"Ignoring fatal error in child of previous "
"generation (pid %ld)."</expr></argument>,
<argument><expr>(<name>long</name>)<name><name>pid</name>.<name>pid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>retained</name>-&gt;<name>sick_child_detected</name></name> = 1</expr>;</expr_stmt>
}</block></else></if>
}</block></then> <else>else <if>if <condition>(<expr><name>processed_status</name> == <name>APEXIT_CHILDSICK</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>retained</name>-&gt;<name>sick_child_detected</name></name> = 1</expr>;</expr_stmt>
}</block></then></if></else></if>
<if>if <condition>(<expr><name>child_slot</name> &gt;= 0</expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>process_score</name> *</type><name>ps</name></decl>;</decl_stmt>
<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>threads_per_child</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
<expr_stmt><expr><call><name>ap_update_child_status_from_indexes</name><argument_list>(<argument><expr><name>child_slot</name></expr></argument>, <argument><expr><name>i</name></expr></argument>,
<argument><expr><name>SERVER_DEAD</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></for>
<expr_stmt><expr><call><name>worker_note_child_killed</name><argument_list>(<argument><expr><name>child_slot</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ps</name> = &amp;<name><name>ap_scoreboard_image</name>-&gt;<name>parent</name><index>[<expr><name>child_slot</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ps</name>-&gt;<name>quiescing</name></name> = 0</expr>;</expr_stmt>
<if>if <condition>(<expr><name>processed_status</name> == <name>APEXIT_CHILDSICK</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>retained</name>-&gt;<name>idle_spawn_rate</name><index>[<expr><name><name>ps</name>-&gt;<name>bucket</name></name></expr>]</index></name> = 1</expr>;</expr_stmt>
}</block></then> <else>else <if>if <condition>(<expr><name>remaining_children_to_start</name>
&amp;&amp; <name>child_slot</name> &lt; <name>ap_daemons_limit</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>make_child</name><argument_list>(<argument><expr><name>ap_server_conf</name></expr></argument>, <argument><expr><name>child_slot</name></expr></argument>, <argument><expr><name><name>ps</name>-&gt;<name>bucket</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr>--<name>remaining_children_to_start</name></expr>;</expr_stmt>
}</block></then></if></else></if>
}</block></then> <else>else <if>if <condition>(<expr><call><name>ap_unregister_extra_mpm_process</name><argument_list>(<argument><expr><name><name>pid</name>.<name>pid</name></name></expr></argument>, <argument><expr>&amp;<name>old_gen</name></expr></argument>)</argument_list></call> == 1</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>worker_note_child_killed</name><argument_list>(<argument><expr>-1</expr></argument>,
<argument><expr><name><name>pid</name>.<name>pid</name></name></expr></argument>, <argument><expr><name>old_gen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>processed_status</name> == <name>APEXIT_CHILDSICK</name>
&amp;&amp; <name>old_gen</name> == <name><name>retained</name>-&gt;<name>mpm</name>-&gt;<name>my_generation</name></name></expr>)</condition><then> <block>{
<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>num_buckets</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
<expr_stmt><expr><name><name>retained</name>-&gt;<name>idle_spawn_rate</name><index>[<expr><name>i</name></expr>]</index></name> = 1</expr>;</expr_stmt>
}</block></for>
}</block></then></if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>APR_HAS_OTHER_CHILD</name></expr></cpp:if>
}</block></then> <else>else <if>if <condition>(<expr><call><name>apr_proc_other_child_alert</name><argument_list>(<argument><expr>&amp;<name>pid</name></expr></argument>, <argument><expr><name>APR_OC_REASON_DEATH</name></expr></argument>,
<argument><expr><name>status</name></expr></argument>)</argument_list></call> == 0</expr>)</condition><then> <block>{
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></then> <else>else <if>if <condition>(<expr><name><name>retained</name>-&gt;<name>mpm</name>-&gt;<name>was_graceful</name></name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_WARNING</name></expr></argument>, <argument><expr>0</expr></argument>,
<argument><expr><name>ap_server_conf</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00291</expr></argument>)</argument_list></call>
"long lost child came home! (pid %ld)"</expr></argument>,
<argument><expr>(<name>long</name>)<name><name>pid</name>.<name>pid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if></else></if></else></if></else></if>
<continue>continue;</continue>
}</block></then> <else>else <if>if <condition>(<expr><name>remaining_children_to_start</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>startup_children</name><argument_list>(<argument><expr><name>remaining_children_to_start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>remaining_children_to_start</name> = 0</expr>;</expr_stmt>
<continue>continue;</continue>
}</block></then></if></else></if>
<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>num_buckets</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
<expr_stmt><expr><call><name>perform_idle_server_maintenance</name><argument_list>(<argument><expr><name>i</name></expr></argument>, <argument><expr><name>num_buckets</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></for>
}</block></while>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>worker_run</name><parameter_list>(<param><decl><type><name>apr_pool_t</name> *</type><name>_pconf</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>plog</name></decl></param>, <param><decl><type><name>server_rec</name> *</type><name>s</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>num_buckets</name> <init>= <expr><name><name>retained</name>-&gt;<name>mpm</name>-&gt;<name>num_buckets</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>remaining_children_to_start</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>ap_log_pid</name><argument_list>(<argument><expr><name>pconf</name></expr></argument>, <argument><expr><name>ap_pid_fname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name><name>retained</name>-&gt;<name>mpm</name>-&gt;<name>was_graceful</name></name></expr>)</condition><then> <block>{
<if>if <condition>(<expr><call><name>ap_run_pre_mpm</name><argument_list>(<argument><expr><name><name>s</name>-&gt;<name>process</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>SB_SHARED</name></expr></argument>)</argument_list></call> != <name>OK</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>retained</name>-&gt;<name>mpm</name>-&gt;<name>mpm_state</name></name> = <name>AP_MPMQ_STOPPING</name></expr>;</expr_stmt>
<return>return <expr>!<name>OK</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name><name>ap_scoreboard_image</name>-&gt;<name>global</name>-&gt;<name>running_generation</name></name> = <name><name>retained</name>-&gt;<name>mpm</name>-&gt;<name>my_generation</name></name></expr>;</expr_stmt>
}</block></then></if>
<if>if <condition>(<expr>!<name>one_process</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>ap_fatal_signal_setup</name><argument_list>(<argument><expr><name>ap_server_conf</name></expr></argument>, <argument><expr><name>pconf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><call><name>ap_unixd_mpm_set_signals</name><argument_list>(<argument><expr><name>pconf</name></expr></argument>, <argument><expr><name>one_process</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>ap_daemons_limit</name> &lt; <name>num_buckets</name></expr>)</condition><then>
<expr_stmt><expr><name>ap_daemons_limit</name> = <name>num_buckets</name></expr>;</expr_stmt></then></if>
<if>if <condition>(<expr><name>ap_daemons_to_start</name> &lt; <name>num_buckets</name></expr>)</condition><then>
<expr_stmt><expr><name>ap_daemons_to_start</name> = <name>num_buckets</name></expr>;</expr_stmt></then></if>
<if>if <condition>(<expr><name>min_spare_threads</name> &lt; <call><name>threads_per_child</name> * <argument_list>(<argument><expr><name>num_buckets</name> - 1</expr></argument>)</argument_list></call> + <name>num_buckets</name></expr>)</condition><then>
<expr_stmt><expr><name>min_spare_threads</name> = <call><name>threads_per_child</name> * <argument_list>(<argument><expr><name>num_buckets</name> - 1</expr></argument>)</argument_list></call> + <name>num_buckets</name></expr>;</expr_stmt></then></if>
<if>if <condition>(<expr><name>max_spare_threads</name> &lt; <name>min_spare_threads</name> + (<name>threads_per_child</name> + 1) * <name>num_buckets</name></expr>)</condition><then>
<expr_stmt><expr><name>max_spare_threads</name> = <name>min_spare_threads</name> + (<name>threads_per_child</name> + 1) * <name>num_buckets</name></expr>;</expr_stmt></then></if>
<expr_stmt><expr><name>remaining_children_to_start</name> = <name>ap_daemons_to_start</name></expr>;</expr_stmt>
<if>if <condition>(<expr><name>remaining_children_to_start</name> &gt; <name>ap_daemons_limit</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>remaining_children_to_start</name> = <name>ap_daemons_limit</name></expr>;</expr_stmt>
}</block></then></if>
<if>if <condition>(<expr>!<name><name>retained</name>-&gt;<name>mpm</name>-&gt;<name>was_graceful</name></name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>startup_children</name><argument_list>(<argument><expr><name>remaining_children_to_start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>remaining_children_to_start</name> = 0</expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr><name><name>retained</name>-&gt;<name>hold_off_on_exponential_spawning</name></name> = 10</expr>;</expr_stmt>
}</block></else></if>
<expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_NOTICE</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>ap_server_conf</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00292</expr></argument>)</argument_list></call>
"%s configured -- resuming normal operations"</expr></argument>,
<argument><expr><call><name>ap_get_server_description</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_INFO</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>ap_server_conf</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00293</expr></argument>)</argument_list></call>
"Server built: %s"</expr></argument>, <argument><expr><call><name>ap_get_server_built</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ap_log_command_line</name><argument_list>(<argument><expr><name>plog</name></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ap_log_mpm_common</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_DEBUG</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>ap_server_conf</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00294</expr></argument>)</argument_list></call>
"Accept mutex: %s (default: %s)"</expr></argument>,
<argument><expr>(<name><name>all_buckets</name><index>[<expr>0</expr>]</index></name>.<name>mutex</name>)
? <call><name>apr_proc_mutex_name</name><argument_list>(<argument><expr><name><name>all_buckets</name><index>[<expr>0</expr>]</index></name>.<name>mutex</name></expr></argument>)</argument_list></call>
: "none"</expr></argument>,
<argument><expr><call><name>apr_proc_mutex_defname</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>retained</name>-&gt;<name>mpm</name>-&gt;<name>mpm_state</name></name> = <name>AP_MPMQ_RUNNING</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>server_main_loop</name><argument_list>(<argument><expr><name>remaining_children_to_start</name></expr></argument>, <argument><expr><name>num_buckets</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>retained</name>-&gt;<name>mpm</name>-&gt;<name>mpm_state</name></name> = <name>AP_MPMQ_STOPPING</name></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>retained</name>-&gt;<name>mpm</name>-&gt;<name>shutdown_pending</name></name> &amp;&amp; <name><name>retained</name>-&gt;<name>mpm</name>-&gt;<name>is_ungraceful</name></name></expr>)</condition><then> <block>{
<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>num_buckets</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
<expr_stmt><expr><call><name>ap_mpm_podx_killpg</name><argument_list>(<argument><expr><name><name>all_buckets</name><index>[<expr><name>i</name></expr>]</index></name>.<name>pod</name></expr></argument>, <argument><expr><name>ap_daemons_limit</name></expr></argument>,
<argument><expr><name>AP_MPM_PODX_RESTART</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></for>
<expr_stmt><expr><call><name>ap_reclaim_child_processes</name><argument_list>(<argument><expr>1</expr></argument>,
<argument><expr><name>worker_note_child_killed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>child_fatal</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>ap_remove_pid</name><argument_list>(<argument><expr><name>pconf</name></expr></argument>, <argument><expr><name>ap_pid_fname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_NOTICE</name></expr></argument>, <argument><expr>0</expr></argument>,
<argument><expr><name>ap_server_conf</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00295</expr></argument>)</argument_list></call> "caught SIGTERM, shutting down"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<return>return <expr><name>DONE</name></expr>;</return>
}</block></then></if>
<if>if <condition>(<expr><name><name>retained</name>-&gt;<name>mpm</name>-&gt;<name>shutdown_pending</name></name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>active_children</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>index</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>apr_time_t</name></type> <name>cutoff</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>ap_close_listeners</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>num_buckets</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
<expr_stmt><expr><call><name>ap_mpm_podx_killpg</name><argument_list>(<argument><expr><name><name>all_buckets</name><index>[<expr><name>i</name></expr>]</index></name>.<name>pod</name></expr></argument>, <argument><expr><name>ap_daemons_limit</name></expr></argument>,
<argument><expr><name>AP_MPM_PODX_GRACEFUL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></for>
<expr_stmt><expr><call><name>ap_relieve_child_processes</name><argument_list>(<argument><expr><name>worker_note_child_killed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>child_fatal</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>ap_remove_pid</name><argument_list>(<argument><expr><name>pconf</name></expr></argument>, <argument><expr><name>ap_pid_fname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_NOTICE</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>ap_server_conf</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00296</expr></argument>)</argument_list></call>
"caught " <name>AP_SIG_GRACEFUL_STOP_STRING</name>
", shutting down gracefully"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<if>if <condition>(<expr><name>ap_graceful_shutdown_timeout</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>cutoff</name> = <call><name>apr_time_now</name><argument_list>()</argument_list></call> +
<call><name>apr_time_from_sec</name><argument_list>(<argument><expr><name>ap_graceful_shutdown_timeout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><name><name>retained</name>-&gt;<name>mpm</name>-&gt;<name>shutdown_pending</name></name> = 0</expr>;</expr_stmt>
<do>do <block>{
<expr_stmt><expr><call><name>apr_sleep</name><argument_list>(<argument><expr><call><name>apr_time_from_sec</name><argument_list>(<argument><expr>1</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ap_relieve_child_processes</name><argument_list>(<argument><expr><name>worker_note_child_killed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>active_children</name> = 0</expr>;</expr_stmt>
<for>for (<init><expr><name>index</name> = 0</expr>;</init> <condition><expr><name>index</name> &lt; <name>ap_daemons_limit</name></expr>;</condition> <incr><expr>++<name>index</name></expr></incr>) <block>{
<if>if <condition>(<expr><call><name>ap_mpm_safe_kill</name><argument_list>(<argument><expr><call><name>MPM_CHILD_PID</name><argument_list>(<argument><expr><name>index</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call> == <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>active_children</name> = 1</expr>;</expr_stmt>
<break>break;</break>
}</block></then></if>
}</block></for>
}</block> while <condition>(<expr>!<name><name>retained</name>-&gt;<name>mpm</name>-&gt;<name>shutdown_pending</name></name> &amp;&amp; <name>active_children</name> &amp;&amp;
(!<name>ap_graceful_shutdown_timeout</name> || <call><name>apr_time_now</name><argument_list>()</argument_list></call> &lt; <name>cutoff</name>)</expr>)</condition>;</do>
<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>num_buckets</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
<expr_stmt><expr><call><name>ap_mpm_podx_killpg</name><argument_list>(<argument><expr><name><name>all_buckets</name><index>[<expr><name>i</name></expr>]</index></name>.<name>pod</name></expr></argument>, <argument><expr><name>ap_daemons_limit</name></expr></argument>,
<argument><expr><name>AP_MPM_PODX_RESTART</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></for>
<expr_stmt><expr><call><name>ap_reclaim_child_processes</name><argument_list>(<argument><expr>1</expr></argument>, <argument><expr><name>worker_note_child_killed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>DONE</name></expr>;</return>
}</block></then></if>
<if>if <condition>(<expr><name>one_process</name></expr>)</condition><then> <block>{
<return>return <expr><name>DONE</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr>++<name><name>retained</name>-&gt;<name>mpm</name>-&gt;<name>my_generation</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ap_scoreboard_image</name>-&gt;<name>global</name>-&gt;<name>running_generation</name></name> = <name><name>retained</name>-&gt;<name>mpm</name>-&gt;<name>my_generation</name></name></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name><name>retained</name>-&gt;<name>mpm</name>-&gt;<name>is_ungraceful</name></name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_NOTICE</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>ap_server_conf</name></expr></argument>, <argument><expr><macro><name>APLOGNO</name><argument_list>(<argument>00297</argument>)</argument_list></macro>
<name>AP_SIG_GRACEFUL_STRING</name> " received. Doing graceful restart"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>num_buckets</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
<expr_stmt><expr><call><name>ap_mpm_podx_killpg</name><argument_list>(<argument><expr><name><name>all_buckets</name><index>[<expr><name>i</name></expr>]</index></name>.<name>pod</name></expr></argument>, <argument><expr><name>ap_daemons_limit</name></expr></argument>,
<argument><expr><name>AP_MPM_PODX_GRACEFUL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></for>
}</block></then> <else>else <block>{
<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>num_buckets</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
<expr_stmt><expr><call><name>ap_mpm_podx_killpg</name><argument_list>(<argument><expr><name><name>all_buckets</name><index>[<expr><name>i</name></expr>]</index></name>.<name>pod</name></expr></argument>, <argument><expr><name>ap_daemons_limit</name></expr></argument>,
<argument><expr><name>AP_MPM_PODX_RESTART</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></for>
<expr_stmt><expr><call><name>ap_reclaim_child_processes</name><argument_list>(<argument><expr>1</expr></argument>,
<argument><expr><name>worker_note_child_killed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_NOTICE</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>ap_server_conf</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00298</expr></argument>)</argument_list></call>
"SIGHUP received. Attempting to restart"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></else></if>
<return>return <expr><name>OK</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>worker_open_logs</name><parameter_list>(<param><decl><type><name>apr_pool_t</name> *</type><name>p</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>plog</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>ptemp</name></decl></param>, <param><decl><type><name>server_rec</name> *</type><name>s</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>startup</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>level_flags</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>num_buckets</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ap_listen_rec</name> **</type><name>listen_buckets</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>apr_status_t</name></type> <name>rv</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name><name>id</name><index>[<expr>16</expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<expr_stmt><expr><name>pconf</name> = <name>p</name></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>retained</name>-&gt;<name>mpm</name>-&gt;<name>module_loads</name></name> == 1</expr>)</condition><then> <block>{
<expr_stmt><expr><name>startup</name> = 1</expr>;</expr_stmt>
<expr_stmt><expr><name>level_flags</name> |= <name>APLOG_STARTUP</name></expr>;</expr_stmt>
}</block></then></if>
<if>if <condition>(<expr>(<name>num_listensocks</name> = <call><name>ap_setup_listeners</name><argument_list>(<argument><expr><name>ap_server_conf</name></expr></argument>)</argument_list></call>) &lt; 1</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_ALERT</name> | <name>level_flags</name></expr></argument>, <argument><expr>0</expr></argument>,
<argument><expr>(<name>startup</name> ? <name>NULL</name> : <name>s</name>)</expr></argument>,
<argument><expr>"no listening sockets available, shutting down"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>!<name>OK</name></expr>;</return>
}</block></then></if>
<if>if <condition>(<expr><name>one_process</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>num_buckets</name> = 1</expr>;</expr_stmt>
}</block></then> <else>else <if>if <condition>(<expr><name><name>retained</name>-&gt;<name>mpm</name>-&gt;<name>was_graceful</name></name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>num_buckets</name> = <name><name>retained</name>-&gt;<name>mpm</name>-&gt;<name>num_buckets</name></name></expr>;</expr_stmt>
}</block></then></if></else></if>
<if>if <condition>(<expr>(<name>rv</name> = <call><name>ap_duplicate_listeners</name><argument_list>(<argument><expr><name>pconf</name></expr></argument>, <argument><expr><name>ap_server_conf</name></expr></argument>,
<argument><expr>&amp;<name>listen_buckets</name></expr></argument>, <argument><expr>&amp;<name>num_buckets</name></expr></argument>)</argument_list></call>)</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_CRIT</name> | <name>level_flags</name></expr></argument>, <argument><expr><name>rv</name></expr></argument>,
<argument><expr>(<name>startup</name> ? <name>NULL</name> : <name>s</name>)</expr></argument>,
<argument><expr>"could not duplicate listeners"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>!<name>OK</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>all_buckets</name> = <call><name>apr_pcalloc</name><argument_list>(<argument><expr><name>pconf</name></expr></argument>, <argument><expr><name>num_buckets</name> * <sizeof>sizeof<argument_list>(<argument><expr>*<name>all_buckets</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>num_buckets</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
<if>if <condition>(<expr>!<name>one_process</name> &amp;&amp;
(<name>rv</name> = <call><name>ap_mpm_podx_open</name><argument_list>(<argument><expr><name>pconf</name></expr></argument>, <argument><expr>&amp;<name><name>all_buckets</name><index>[<expr><name>i</name></expr>]</index></name>.<name>pod</name></expr></argument>)</argument_list></call>)</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_CRIT</name> | <name>level_flags</name></expr></argument>, <argument><expr><name>rv</name></expr></argument>,
<argument><expr>(<name>startup</name> ? <name>NULL</name> : <name>s</name>)</expr></argument>,
<argument><expr>"could not open pipe-of-death"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>!<name>OK</name></expr>;</return>
}</block></then></if>
<if>if <condition>(<expr>(<name>rv</name> = <call><name>SAFE_ACCEPT</name><argument_list>(<argument><expr>(<call><name>apr_snprintf</name><argument_list>(<argument><expr><name>id</name></expr></argument>, <argument><expr>sizeof <name>id</name></expr></argument>, <argument><expr>"%i"</expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call>,
<call><name>ap_proc_mutex_create</name><argument_list>(<argument><expr>&amp;<name><name>all_buckets</name><index>[<expr><name>i</name></expr>]</index></name>.<name>mutex</name></expr></argument>,
<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>AP_ACCEPT_MUTEX_TYPE</name></expr></argument>,
<argument><expr><name>id</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>pconf</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call>)</expr></argument>)</argument_list></call>)</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_CRIT</name> | <name>level_flags</name></expr></argument>, <argument><expr><name>rv</name></expr></argument>,
<argument><expr>(<name>startup</name> ? <name>NULL</name> : <name>s</name>)</expr></argument>,
<argument><expr>"could not create accept mutex"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>!<name>OK</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name><name>all_buckets</name><index>[<expr><name>i</name></expr>]</index></name>.<name>listeners</name> = <name><name>listen_buckets</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
}</block></for>
<if>if <condition>(<expr><name><name>retained</name>-&gt;<name>mpm</name>-&gt;<name>max_buckets</name></name> &lt; <name>num_buckets</name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>new_max</name></decl>, *<decl><type ref="prev"/><name>new_ptr</name></decl>;</decl_stmt>
<expr_stmt><expr><name>new_max</name> = <name><name>retained</name>-&gt;<name>mpm</name>-&gt;<name>max_buckets</name></name> * 2</expr>;</expr_stmt>
<if>if <condition>(<expr><name>new_max</name> &lt; <name>num_buckets</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>new_max</name> = <name>num_buckets</name></expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><name>new_ptr</name> = (<name>int</name> *)<call><name>apr_palloc</name><argument_list>(<argument><expr><name>ap_pglobal</name></expr></argument>, <argument><expr><name>new_max</name> * <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>new_ptr</name></expr></argument>, <argument><expr><name><name>retained</name>-&gt;<name>idle_spawn_rate</name></name></expr></argument>,
<argument><expr><name><name>retained</name>-&gt;<name>mpm</name>-&gt;<name>num_buckets</name></name> * <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>retained</name>-&gt;<name>idle_spawn_rate</name></name> = <name>new_ptr</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>retained</name>-&gt;<name>mpm</name>-&gt;<name>max_buckets</name></name> = <name>new_max</name></expr>;</expr_stmt>
}</block></then></if>
<if>if <condition>(<expr><name><name>retained</name>-&gt;<name>mpm</name>-&gt;<name>num_buckets</name></name> &lt; <name>num_buckets</name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>rate_max</name> <init>= <expr>1</expr></init></decl>;</decl_stmt>
<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name><name>retained</name>-&gt;<name>mpm</name>-&gt;<name>num_buckets</name></name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
<if>if <condition>(<expr><name>rate_max</name> &lt; <name><name>retained</name>-&gt;<name>idle_spawn_rate</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>rate_max</name> = <name><name>retained</name>-&gt;<name>idle_spawn_rate</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
}</block></then></if>
}</block></for>
<for>for (<init>;</init> <condition><expr><name>i</name> &lt; <name>num_buckets</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
<expr_stmt><expr><name><name>retained</name>-&gt;<name>idle_spawn_rate</name><index>[<expr><name>i</name></expr>]</index></name> = <name>rate_max</name></expr>;</expr_stmt>
}</block></for>
}</block></then></if>
<expr_stmt><expr><name><name>retained</name>-&gt;<name>mpm</name>-&gt;<name>num_buckets</name></name> = <name>num_buckets</name></expr>;</expr_stmt>
<return>return <expr><name>OK</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>worker_pre_config</name><parameter_list>(<param><decl><type><name>apr_pool_t</name> *</type><name>pconf</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>plog</name></decl></param>,
<param><decl><type><name>apr_pool_t</name> *</type><name>ptemp</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>no_detach</name></decl>, <decl><type ref="prev"/><name>debug</name></decl>, <decl><type ref="prev"/><name>foreground</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>apr_status_t</name></type> <name>rv</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>userdata_key</name> <init>= <expr>"mpm_worker_module"</expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>debug</name> = <call><name>ap_exists_config_define</name><argument_list>(<argument><expr>"DEBUG"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>debug</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>foreground</name> = <name>one_process</name> = 1</expr>;</expr_stmt>
<expr_stmt><expr><name>no_detach</name> = 0</expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr><name>one_process</name> = <call><name>ap_exists_config_define</name><argument_list>(<argument><expr>"ONE_PROCESS"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>no_detach</name> = <call><name>ap_exists_config_define</name><argument_list>(<argument><expr>"NO_DETACH"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>foreground</name> = <call><name>ap_exists_config_define</name><argument_list>(<argument><expr>"FOREGROUND"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></else></if>
<expr_stmt><expr><call><name>ap_mutex_register</name><argument_list>(<argument><expr><name>pconf</name></expr></argument>, <argument><expr><name>AP_ACCEPT_MUTEX_TYPE</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>APR_LOCK_DEFAULT</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>retained</name> = <call><name>ap_retained_data_get</name><argument_list>(<argument><expr><name>userdata_key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>retained</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>retained</name> = <call><name>ap_retained_data_create</name><argument_list>(<argument><expr><name>userdata_key</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>*<name>retained</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>retained</name>-&gt;<name>mpm</name></name> = <call><name>ap_unixd_mpm_get_retained_data</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>retained</name>-&gt;<name>max_daemons_limit</name></name> = -1</expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><name><name>retained</name>-&gt;<name>mpm</name>-&gt;<name>mpm_state</name></name> = <name>AP_MPMQ_STARTING</name></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>retained</name>-&gt;<name>mpm</name>-&gt;<name>baton</name></name> != <name>retained</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>retained</name>-&gt;<name>mpm</name>-&gt;<name>was_graceful</name></name> = 0</expr>;</expr_stmt>
<expr_stmt><expr><name><name>retained</name>-&gt;<name>mpm</name>-&gt;<name>baton</name></name> = <name>retained</name></expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr>++<name><name>retained</name>-&gt;<name>mpm</name>-&gt;<name>module_loads</name></name></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>retained</name>-&gt;<name>mpm</name>-&gt;<name>module_loads</name></name> == 2</expr>)</condition><then> <block>{
<if>if <condition>(<expr>!<name>one_process</name> &amp;&amp; !<name>foreground</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>ap_fatal_signal_setup</name><argument_list>(<argument><expr><name>ap_server_conf</name></expr></argument>, <argument><expr><name>pconf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>rv</name> = <call><name>apr_proc_detach</name><argument_list>(<argument><expr><name>no_detach</name> ? <name>APR_PROC_DETACH_FOREGROUND</name>
: <name>APR_PROC_DETACH_DAEMONIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>rv</name> != <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_CRIT</name></expr></argument>, <argument><expr><name>rv</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00299</expr></argument>)</argument_list></call>
"apr_proc_detach failed"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>HTTP_INTERNAL_SERVER_ERROR</name></expr>;</return>
}</block></then></if>
}</block></then></if>
}</block></then></if>
<expr_stmt><expr><name>parent_pid</name> = <name>ap_my_pid</name> = <call><name>getpid</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ap_listen_pre_config</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ap_daemons_to_start</name> = <name>DEFAULT_START_DAEMON</name></expr>;</expr_stmt>
<expr_stmt><expr><name>min_spare_threads</name> = <name>DEFAULT_MIN_FREE_DAEMON</name> * <name>DEFAULT_THREADS_PER_CHILD</name></expr>;</expr_stmt>
<expr_stmt><expr><name>max_spare_threads</name> = <name>DEFAULT_MAX_FREE_DAEMON</name> * <name>DEFAULT_THREADS_PER_CHILD</name></expr>;</expr_stmt>
<expr_stmt><expr><name>server_limit</name> = <name>DEFAULT_SERVER_LIMIT</name></expr>;</expr_stmt>
<expr_stmt><expr><name>thread_limit</name> = <name>DEFAULT_THREAD_LIMIT</name></expr>;</expr_stmt>
<expr_stmt><expr><name>ap_daemons_limit</name> = <name>server_limit</name></expr>;</expr_stmt>
<expr_stmt><expr><name>threads_per_child</name> = <name>DEFAULT_THREADS_PER_CHILD</name></expr>;</expr_stmt>
<expr_stmt><expr><name>max_workers</name> = <name>ap_daemons_limit</name> * <name>threads_per_child</name></expr>;</expr_stmt>
<expr_stmt><expr><name>had_healthy_child</name> = 0</expr>;</expr_stmt>
<expr_stmt><expr><name>ap_extended_status</name> = 0</expr>;</expr_stmt>
<return>return <expr><name>OK</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>worker_check_config</name><parameter_list>(<param><decl><type><name>apr_pool_t</name> *</type><name>p</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>plog</name></decl></param>,
<param><decl><type><name>apr_pool_t</name> *</type><name>ptemp</name></decl></param>, <param><decl><type><name>server_rec</name> *</type><name>s</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>startup</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name><name>retained</name>-&gt;<name>mpm</name>-&gt;<name>module_loads</name></name> == 1</expr>)</condition><then> <block>{
<expr_stmt><expr><name>startup</name> = 1</expr>;</expr_stmt>
}</block></then></if>
<if>if <condition>(<expr><name>server_limit</name> &gt; <name>MAX_SERVER_LIMIT</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr><name>startup</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_WARNING</name> | <name>APLOG_STARTUP</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00300</expr></argument>)</argument_list></call>
"WARNING: ServerLimit of %d exceeds compile-time "
"limit of %d servers, decreasing to %d."</expr></argument>,
<argument><expr><name>server_limit</name></expr></argument>, <argument><expr><name>MAX_SERVER_LIMIT</name></expr></argument>, <argument><expr><name>MAX_SERVER_LIMIT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_WARNING</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00301</expr></argument>)</argument_list></call>
"ServerLimit of %d exceeds compile-time limit "
"of %d, decreasing to match"</expr></argument>,
<argument><expr><name>server_limit</name></expr></argument>, <argument><expr><name>MAX_SERVER_LIMIT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></else></if>
<expr_stmt><expr><name>server_limit</name> = <name>MAX_SERVER_LIMIT</name></expr>;</expr_stmt>
}</block></then> <else>else <if>if <condition>(<expr><name>server_limit</name> &lt; 1</expr>)</condition><then> <block>{
<if>if <condition>(<expr><name>startup</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_WARNING</name> | <name>APLOG_STARTUP</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00302</expr></argument>)</argument_list></call>
"WARNING: ServerLimit of %d not allowed, "
"increasing to 1."</expr></argument>, <argument><expr><name>server_limit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_WARNING</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00303</expr></argument>)</argument_list></call>
"ServerLimit of %d not allowed, increasing to 1"</expr></argument>,
<argument><expr><name>server_limit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></else></if>
<expr_stmt><expr><name>server_limit</name> = 1</expr>;</expr_stmt>
}</block></then></if></else></if>
<if>if <condition>(<expr>!<name><name>retained</name>-&gt;<name>first_server_limit</name></name></expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>retained</name>-&gt;<name>first_server_limit</name></name> = <name>server_limit</name></expr>;</expr_stmt>
}</block></then> <else>else <if>if <condition>(<expr><name>server_limit</name> != <name><name>retained</name>-&gt;<name>first_server_limit</name></name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_WARNING</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00304</expr></argument>)</argument_list></call>
"changing ServerLimit to %d from original value of %d "
"not allowed during restart"</expr></argument>,
<argument><expr><name>server_limit</name></expr></argument>, <argument><expr><name><name>retained</name>-&gt;<name>first_server_limit</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>server_limit</name> = <name><name>retained</name>-&gt;<name>first_server_limit</name></name></expr>;</expr_stmt>
}</block></then></if></else></if>
<if>if <condition>(<expr><name>thread_limit</name> &gt; <name>MAX_THREAD_LIMIT</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr><name>startup</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_WARNING</name> | <name>APLOG_STARTUP</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00305</expr></argument>)</argument_list></call>
"WARNING: ThreadLimit of %d exceeds compile-time "
"limit of %d threads, decreasing to %d."</expr></argument>,
<argument><expr><name>thread_limit</name></expr></argument>, <argument><expr><name>MAX_THREAD_LIMIT</name></expr></argument>, <argument><expr><name>MAX_THREAD_LIMIT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_WARNING</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00306</expr></argument>)</argument_list></call>
"ThreadLimit of %d exceeds compile-time limit "
"of %d, decreasing to match"</expr></argument>,
<argument><expr><name>thread_limit</name></expr></argument>, <argument><expr><name>MAX_THREAD_LIMIT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></else></if>
<expr_stmt><expr><name>thread_limit</name> = <name>MAX_THREAD_LIMIT</name></expr>;</expr_stmt>
}</block></then> <else>else <if>if <condition>(<expr><name>thread_limit</name> &lt; 1</expr>)</condition><then> <block>{
<if>if <condition>(<expr><name>startup</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_WARNING</name> | <name>APLOG_STARTUP</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00307</expr></argument>)</argument_list></call>
"WARNING: ThreadLimit of %d not allowed, "
"increasing to 1."</expr></argument>, <argument><expr><name>thread_limit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_WARNING</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00308</expr></argument>)</argument_list></call>
"ThreadLimit of %d not allowed, increasing to 1"</expr></argument>,
<argument><expr><name>thread_limit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></else></if>
<expr_stmt><expr><name>thread_limit</name> = 1</expr>;</expr_stmt>
}</block></then></if></else></if>
<if>if <condition>(<expr>!<name><name>retained</name>-&gt;<name>first_thread_limit</name></name></expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>retained</name>-&gt;<name>first_thread_limit</name></name> = <name>thread_limit</name></expr>;</expr_stmt>
}</block></then> <else>else <if>if <condition>(<expr><name>thread_limit</name> != <name><name>retained</name>-&gt;<name>first_thread_limit</name></name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_WARNING</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00309</expr></argument>)</argument_list></call>
"changing ThreadLimit to %d from original value of %d "
"not allowed during restart"</expr></argument>,
<argument><expr><name>thread_limit</name></expr></argument>, <argument><expr><name><name>retained</name>-&gt;<name>first_thread_limit</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>thread_limit</name> = <name><name>retained</name>-&gt;<name>first_thread_limit</name></name></expr>;</expr_stmt>
}</block></then></if></else></if>
<if>if <condition>(<expr><name>threads_per_child</name> &gt; <name>thread_limit</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr><name>startup</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_WARNING</name> | <name>APLOG_STARTUP</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00310</expr></argument>)</argument_list></call>
"WARNING: ThreadsPerChild of %d exceeds ThreadLimit "
"of %d threads, decreasing to %d. "
"To increase, please see the ThreadLimit directive."</expr></argument>,
<argument><expr><name>threads_per_child</name></expr></argument>, <argument><expr><name>thread_limit</name></expr></argument>, <argument><expr><name>thread_limit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_WARNING</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00311</expr></argument>)</argument_list></call>
"ThreadsPerChild of %d exceeds ThreadLimit "
"of %d, decreasing to match"</expr></argument>,
<argument><expr><name>threads_per_child</name></expr></argument>, <argument><expr><name>thread_limit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></else></if>
<expr_stmt><expr><name>threads_per_child</name> = <name>thread_limit</name></expr>;</expr_stmt>
}</block></then> <else>else <if>if <condition>(<expr><name>threads_per_child</name> &lt; 1</expr>)</condition><then> <block>{
<if>if <condition>(<expr><name>startup</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_WARNING</name> | <name>APLOG_STARTUP</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00312</expr></argument>)</argument_list></call>
"WARNING: ThreadsPerChild of %d not allowed, "
"increasing to 1."</expr></argument>, <argument><expr><name>threads_per_child</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_WARNING</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00313</expr></argument>)</argument_list></call>
"ThreadsPerChild of %d not allowed, increasing to 1"</expr></argument>,
<argument><expr><name>threads_per_child</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></else></if>
<expr_stmt><expr><name>threads_per_child</name> = 1</expr>;</expr_stmt>
}</block></then></if></else></if>
<if>if <condition>(<expr><name>max_workers</name> &lt; <name>threads_per_child</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr><name>startup</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_WARNING</name> | <name>APLOG_STARTUP</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00314</expr></argument>)</argument_list></call>
"WARNING: MaxRequestWorkers of %d is less than "
"ThreadsPerChild of %d, increasing to %d. "
"MaxRequestWorkers must be at least as large "
"as the number of threads in a single server."</expr></argument>,
<argument><expr><name>max_workers</name></expr></argument>, <argument><expr><name>threads_per_child</name></expr></argument>, <argument><expr><name>threads_per_child</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_WARNING</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00315</expr></argument>)</argument_list></call>
"MaxRequestWorkers of %d is less than ThreadsPerChild "
"of %d, increasing to match"</expr></argument>,
<argument><expr><name>max_workers</name></expr></argument>, <argument><expr><name>threads_per_child</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></else></if>
<expr_stmt><expr><name>max_workers</name> = <name>threads_per_child</name></expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><name>ap_daemons_limit</name> = <name>max_workers</name> / <name>threads_per_child</name></expr>;</expr_stmt>
<if>if <condition>(<expr><name>max_workers</name> % <name>threads_per_child</name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>tmp_max_workers</name> <init>= <expr><name>ap_daemons_limit</name> * <name>threads_per_child</name></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>startup</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_WARNING</name> | <name>APLOG_STARTUP</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00316</expr></argument>)</argument_list></call>
"WARNING: MaxRequestWorkers of %d is not an integer "
"multiple of ThreadsPerChild of %d, decreasing to nearest "
"multiple %d, for a maximum of %d servers."</expr></argument>,
<argument><expr><name>max_workers</name></expr></argument>, <argument><expr><name>threads_per_child</name></expr></argument>, <argument><expr><name>tmp_max_workers</name></expr></argument>,
<argument><expr><name>ap_daemons_limit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_WARNING</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00317</expr></argument>)</argument_list></call>
"MaxRequestWorkers of %d is not an integer multiple of "
"ThreadsPerChild of %d, decreasing to nearest "
"multiple %d"</expr></argument>, <argument><expr><name>max_workers</name></expr></argument>, <argument><expr><name>threads_per_child</name></expr></argument>,
<argument><expr><name>tmp_max_workers</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></else></if>
<expr_stmt><expr><name>max_workers</name> = <name>tmp_max_workers</name></expr>;</expr_stmt>
}</block></then></if>
<if>if <condition>(<expr><name>ap_daemons_limit</name> &gt; <name>server_limit</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr><name>startup</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_WARNING</name> | <name>APLOG_STARTUP</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00318</expr></argument>)</argument_list></call>
"WARNING: MaxRequestWorkers of %d would require %d "
"servers and would exceed ServerLimit of %d, decreasing to %d. "
"To increase, please see the ServerLimit directive."</expr></argument>,
<argument><expr><name>max_workers</name></expr></argument>, <argument><expr><name>ap_daemons_limit</name></expr></argument>, <argument><expr><name>server_limit</name></expr></argument>,
<argument><expr><name>server_limit</name> * <name>threads_per_child</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_WARNING</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00319</expr></argument>)</argument_list></call>
"MaxRequestWorkers of %d would require %d servers and "
"exceed ServerLimit of %d, decreasing to %d"</expr></argument>,
<argument><expr><name>max_workers</name></expr></argument>, <argument><expr><name>ap_daemons_limit</name></expr></argument>, <argument><expr><name>server_limit</name></expr></argument>,
<argument><expr><name>server_limit</name> * <name>threads_per_child</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></else></if>
<expr_stmt><expr><name>ap_daemons_limit</name> = <name>server_limit</name></expr>;</expr_stmt>
}</block></then></if>
<if>if <condition>(<expr><name>ap_daemons_to_start</name> &lt; 1</expr>)</condition><then> <block>{
<if>if <condition>(<expr><name>startup</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_WARNING</name> | <name>APLOG_STARTUP</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00320</expr></argument>)</argument_list></call>
"WARNING: StartServers of %d not allowed, "
"increasing to 1."</expr></argument>, <argument><expr><name>ap_daemons_to_start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_WARNING</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00321</expr></argument>)</argument_list></call>
"StartServers of %d not allowed, increasing to 1"</expr></argument>,
<argument><expr><name>ap_daemons_to_start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></else></if>
<expr_stmt><expr><name>ap_daemons_to_start</name> = 1</expr>;</expr_stmt>
}</block></then></if>
<if>if <condition>(<expr><name>min_spare_threads</name> &lt; 1</expr>)</condition><then> <block>{
<if>if <condition>(<expr><name>startup</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_WARNING</name> | <name>APLOG_STARTUP</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00322</expr></argument>)</argument_list></call>
"WARNING: MinSpareThreads of %d not allowed, "
"increasing to 1 to avoid almost certain server failure. "
"Please read the documentation."</expr></argument>, <argument><expr><name>min_spare_threads</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_WARNING</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00323</expr></argument>)</argument_list></call>
"MinSpareThreads of %d not allowed, increasing to 1"</expr></argument>,
<argument><expr><name>min_spare_threads</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></else></if>
<expr_stmt><expr><name>min_spare_threads</name> = 1</expr>;</expr_stmt>
}</block></then></if>
<return>return <expr><name>OK</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>worker_hooks</name><parameter_list>(<param><decl><type><name>apr_pool_t</name> *</type><name>p</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> *<specifier>const</specifier></type> <name><name>aszSucc</name><index>[]</index></name> <init>= <expr><block>{<expr>"core.c"</expr>, <expr><name>NULL</name></expr>}</block></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>one_process</name> = 0</expr>;</expr_stmt>
<expr_stmt><expr><call><name>ap_hook_open_logs</name><argument_list>(<argument><expr><name>worker_open_logs</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>aszSucc</name></expr></argument>, <argument><expr><name>APR_HOOK_REALLY_FIRST</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ap_hook_pre_config</name><argument_list>(<argument><expr><name>worker_pre_config</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>APR_HOOK_REALLY_FIRST</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ap_hook_check_config</name><argument_list>(<argument><expr><name>worker_check_config</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>APR_HOOK_MIDDLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ap_hook_mpm</name><argument_list>(<argument><expr><name>worker_run</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>APR_HOOK_MIDDLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ap_hook_mpm_query</name><argument_list>(<argument><expr><name>worker_query</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>APR_HOOK_MIDDLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ap_hook_mpm_get_name</name><argument_list>(<argument><expr><name>worker_get_name</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>APR_HOOK_MIDDLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>
<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> *</type><name>set_daemons_to_start</name><parameter_list>(<param><decl><type><name>cmd_parms</name> *</type><name>cmd</name></decl></param>, <param><decl><type><name>void</name> *</type><name>dummy</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>arg</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>err</name> <init>= <expr><call><name>ap_check_cmd_context</name><argument_list>(<argument><expr><name>cmd</name></expr></argument>, <argument><expr><name>GLOBAL_ONLY</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>err</name> != <name>NULL</name></expr>)</condition><then> <block>{
<return>return <expr><name>err</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>ap_daemons_to_start</name> = <call><name>atoi</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> *</type><name>set_min_spare_threads</name><parameter_list>(<param><decl><type><name>cmd_parms</name> *</type><name>cmd</name></decl></param>, <param><decl><type><name>void</name> *</type><name>dummy</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>arg</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>err</name> <init>= <expr><call><name>ap_check_cmd_context</name><argument_list>(<argument><expr><name>cmd</name></expr></argument>, <argument><expr><name>GLOBAL_ONLY</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>err</name> != <name>NULL</name></expr>)</condition><then> <block>{
<return>return <expr><name>err</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>min_spare_threads</name> = <call><name>atoi</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> *</type><name>set_max_spare_threads</name><parameter_list>(<param><decl><type><name>cmd_parms</name> *</type><name>cmd</name></decl></param>, <param><decl><type><name>void</name> *</type><name>dummy</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>arg</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>err</name> <init>= <expr><call><name>ap_check_cmd_context</name><argument_list>(<argument><expr><name>cmd</name></expr></argument>, <argument><expr><name>GLOBAL_ONLY</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>err</name> != <name>NULL</name></expr>)</condition><then> <block>{
<return>return <expr><name>err</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>max_spare_threads</name> = <call><name>atoi</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> *</type><name>set_max_workers</name> <parameter_list>(<param><decl><type><name>cmd_parms</name> *</type><name>cmd</name></decl></param>, <param><decl><type><name>void</name> *</type><name>dummy</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>arg</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>err</name> <init>= <expr><call><name>ap_check_cmd_context</name><argument_list>(<argument><expr><name>cmd</name></expr></argument>, <argument><expr><name>GLOBAL_ONLY</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>err</name> != <name>NULL</name></expr>)</condition><then> <block>{
<return>return <expr><name>err</name></expr>;</return>
}</block></then></if>
<if>if <condition>(<expr>!<call><name>strcasecmp</name><argument_list>(<argument><expr><name><name>cmd</name>-&gt;<name>cmd</name>-&gt;<name>name</name></name></expr></argument>, <argument><expr>"MaxClients"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_INFO</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00324</expr></argument>)</argument_list></call>
"MaxClients is deprecated, use MaxRequestWorkers "
"instead."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><name>max_workers</name> = <call><name>atoi</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> *</type><name>set_threads_per_child</name> <parameter_list>(<param><decl><type><name>cmd_parms</name> *</type><name>cmd</name></decl></param>, <param><decl><type><name>void</name> *</type><name>dummy</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>arg</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>err</name> <init>= <expr><call><name>ap_check_cmd_context</name><argument_list>(<argument><expr><name>cmd</name></expr></argument>, <argument><expr><name>GLOBAL_ONLY</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>err</name> != <name>NULL</name></expr>)</condition><then> <block>{
<return>return <expr><name>err</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>threads_per_child</name> = <call><name>atoi</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> *</type><name>set_server_limit</name> <parameter_list>(<param><decl><type><name>cmd_parms</name> *</type><name>cmd</name></decl></param>, <param><decl><type><name>void</name> *</type><name>dummy</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>arg</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>err</name> <init>= <expr><call><name>ap_check_cmd_context</name><argument_list>(<argument><expr><name>cmd</name></expr></argument>, <argument><expr><name>GLOBAL_ONLY</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>err</name> != <name>NULL</name></expr>)</condition><then> <block>{
<return>return <expr><name>err</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>server_limit</name> = <call><name>atoi</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> *</type><name>set_thread_limit</name> <parameter_list>(<param><decl><type><name>cmd_parms</name> *</type><name>cmd</name></decl></param>, <param><decl><type><name>void</name> *</type><name>dummy</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>arg</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>err</name> <init>= <expr><call><name>ap_check_cmd_context</name><argument_list>(<argument><expr><name>cmd</name></expr></argument>, <argument><expr><name>GLOBAL_ONLY</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>err</name> != <name>NULL</name></expr>)</condition><then> <block>{
<return>return <expr><name>err</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>thread_limit</name> = <call><name>atoi</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></function>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>command_rec</name></type> <name><name>worker_cmds</name><index>[]</index></name> <init>= <expr><block>{
<expr><name>LISTEN_COMMANDS</name></expr>,
<expr><call><name>AP_INIT_TAKE1</name><argument_list>(<argument><expr>"StartServers"</expr></argument>, <argument><expr><name>set_daemons_to_start</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>RSRC_CONF</name></expr></argument>,
<argument><expr>"Number of child processes launched at server startup"</expr></argument>)</argument_list></call></expr>,
<expr><call><name>AP_INIT_TAKE1</name><argument_list>(<argument><expr>"MinSpareThreads"</expr></argument>, <argument><expr><name>set_min_spare_threads</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>RSRC_CONF</name></expr></argument>,
<argument><expr>"Minimum number of idle threads, to handle request spikes"</expr></argument>)</argument_list></call></expr>,
<expr><call><name>AP_INIT_TAKE1</name><argument_list>(<argument><expr>"MaxSpareThreads"</expr></argument>, <argument><expr><name>set_max_spare_threads</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>RSRC_CONF</name></expr></argument>,
<argument><expr>"Maximum number of idle threads"</expr></argument>)</argument_list></call></expr>,
<expr><call><name>AP_INIT_TAKE1</name><argument_list>(<argument><expr>"MaxRequestWorkers"</expr></argument>, <argument><expr><name>set_max_workers</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>RSRC_CONF</name></expr></argument>,
<argument><expr>"Maximum number of threads alive at the same time"</expr></argument>)</argument_list></call></expr>,
<expr><call><name>AP_INIT_TAKE1</name><argument_list>(<argument><expr>"MaxClients"</expr></argument>, <argument><expr><name>set_max_workers</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>RSRC_CONF</name></expr></argument>,
<argument><expr>"Deprecated name of MaxRequestWorkers"</expr></argument>)</argument_list></call></expr>,
<expr><call><name>AP_INIT_TAKE1</name><argument_list>(<argument><expr>"ThreadsPerChild"</expr></argument>, <argument><expr><name>set_threads_per_child</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>RSRC_CONF</name></expr></argument>,
<argument><expr>"Number of threads each child creates"</expr></argument>)</argument_list></call></expr>,
<expr><call><name>AP_INIT_TAKE1</name><argument_list>(<argument><expr>"ServerLimit"</expr></argument>, <argument><expr><name>set_server_limit</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>RSRC_CONF</name></expr></argument>,
<argument><expr>"Maximum number of child processes for this run of Apache"</expr></argument>)</argument_list></call></expr>,
<expr><call><name>AP_INIT_TAKE1</name><argument_list>(<argument><expr>"ThreadLimit"</expr></argument>, <argument><expr><name>set_thread_limit</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>RSRC_CONF</name></expr></argument>,
<argument><expr>"Maximum number of worker threads per child process for this run of Apache - Upper limit for ThreadsPerChild"</expr></argument>)</argument_list></call></expr>,
<expr><name>AP_GRACEFUL_SHUTDOWN_TIMEOUT_COMMAND</name></expr>,
<expr><block>{ <expr><name>NULL</name></expr> }</block></expr>
}</block></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>AP_DECLARE_MODULE</name><argument_list>(<argument><expr><name>mpm_worker</name></expr></argument>)</argument_list></call> = <block>{
<expr><name>MPM20_MODULE_STUFF</name></expr>,
<expr><name>NULL</name></expr>,
<expr><name>NULL</name></expr>,
<expr><name>NULL</name></expr>,
<expr><name>NULL</name></expr>,
<expr><name>NULL</name></expr>,
<expr><name>worker_cmds</name></expr>,
<expr><name>worker_hooks</name></expr>
}</block></expr>;</expr_stmt>
</unit>
