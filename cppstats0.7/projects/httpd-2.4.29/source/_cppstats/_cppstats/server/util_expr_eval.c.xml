<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C" filename="projects/httpd-2.4.29/_cppstats/_cppstats/server/util_expr_eval.c"><cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"httpd.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"http_log.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"http_core.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"http_protocol.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"http_request.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ap_provider.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"util_expr_private.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"util_md5.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"apr_lib.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"apr_fnmatch.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"apr_base64.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"apr_sha1.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;limits.h&gt;</cpp:file></cpp:include>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>APLOG_MODULE_INDEX</name></cpp:undef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>APLOG_MODULE_INDEX</name></cpp:macro> <cpp:value>AP_CORE_MODULE_INDEX</cpp:value></cpp:define>
<macro><name>APR_HOOK_STRUCT</name><argument_list>(
<argument>APR_HOOK_LINK(expr_lookup)</argument>
)</argument_list></macro>
<macro><name>AP_IMPLEMENT_HOOK_RUN_FIRST</name><argument_list>(<argument>int</argument>, <argument>expr_lookup</argument>, <argument>(ap_expr_lookup_parms *parms)</argument>,
<argument>(parms)</argument>, <argument>DECLINED</argument>)</argument_list></macro>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LOG_MARK</name><parameter_list>(<param><type><name>info</name></type></param>)</parameter_list></cpp:macro> <cpp:value>__FILE__, __LINE__, (info)-&gt;module_index</cpp:value></cpp:define>
<function_decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> *</type><name>ap_expr_eval_string_func</name><parameter_list>(<param><decl><type><name>ap_expr_eval_ctx_t</name> *</type><name>ctx</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>ap_expr_t</name> *</type><name>info</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>ap_expr_t</name> *</type><name>args</name></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> *</type><name>ap_expr_eval_re_backref</name><parameter_list>(<param><decl><type><name>ap_expr_eval_ctx_t</name> *</type><name>ctx</name></decl></param>,
<param><decl><type><name>unsigned</name> <name>int</name></type> <name>n</name></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> *</type><name>ap_expr_eval_var</name><parameter_list>(<param><decl><type><name>ap_expr_eval_ctx_t</name> *</type><name>ctx</name></decl></param>,
<param><decl><type><name>ap_expr_var_func_t</name> *</type><name>func</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>void</name> *</type><name>data</name></decl></param>)</parameter_list>;</function_decl>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>AP_EXPR_DEBUG</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>expr_dump_tree</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>ap_expr_t</name> *</type><name>e</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>server_rec</name> *</type><name>s</name></decl></param>,
<param><decl><type><name>int</name></type> <name>loglevel</name></decl></param>, <param><decl><type><name>int</name></type> <name>indent</name></decl></param>)</parameter_list>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AP_EXPR_MAX_RECURSION</name></cpp:macro> <cpp:value>20</cpp:value></cpp:define>
<function><type><specifier>static</specifier> <name>int</name></type> <name>inc_rec</name><parameter_list>(<param><decl><type><name>ap_expr_eval_ctx_t</name> *</type><name>ctx</name></decl></param>)</parameter_list> <block>{
<if>if <condition>(<expr><name><name>ctx</name>-&gt;<name>reclvl</name></name> &lt; <name>AP_EXPR_MAX_RECURSION</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>ctx</name>-&gt;<name>reclvl</name></name>++</expr>;</expr_stmt>
<return>return <expr>0</expr>;</return>
}</block></then></if>
<expr_stmt><expr>*<name><name>ctx</name>-&gt;<name>err</name></name> = "Recursion limit reached"</expr>;</expr_stmt>
<expr_stmt><expr><name><name>ctx</name>-&gt;<name>reclvl</name></name> = <name>INT_MAX</name></expr>;</expr_stmt>
<return>return <expr>1</expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> *</type><name>ap_expr_eval_word</name><parameter_list>(<param><decl><type><name>ap_expr_eval_ctx_t</name> *</type><name>ctx</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>ap_expr_t</name> *</type><name>node</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>result</name> <init>= <expr>""</expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><call><name>inc_rec</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>result</name></expr>;</return></then></if>
<switch>switch <condition>(<expr><name><name>node</name>-&gt;<name>node_op</name></name></expr>)</condition> <block>{
<case>case <expr><name>op_Digit</name></expr>:
</case><case>case <expr><name>op_String</name></expr>:
<expr_stmt><expr><name>result</name> = <name><name>node</name>-&gt;<name>node_arg1</name></name></expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr><name>op_Var</name></expr>:
<expr_stmt><expr><name>result</name> = <call><name>ap_expr_eval_var</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr>(<name>ap_expr_var_func_t</name> *)<name><name>node</name>-&gt;<name>node_arg1</name></name></expr></argument>,
<argument><expr><name><name>node</name>-&gt;<name>node_arg2</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr><name>op_Concat</name></expr>:
<if>if <condition>(<expr>((<name>ap_expr_t</name> *)<name><name>node</name>-&gt;<name>node_arg2</name></name>)-&gt;<name>node_op</name> != <name>op_Concat</name> &amp;&amp;
((<name>ap_expr_t</name> *)<name><name>node</name>-&gt;<name>node_arg1</name></name>)-&gt;<name>node_op</name> != <name>op_Concat</name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>s1</name> <init>= <expr><call><name>ap_expr_eval_word</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name><name>node</name>-&gt;<name>node_arg1</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>s2</name> <init>= <expr><call><name>ap_expr_eval_word</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name><name>node</name>-&gt;<name>node_arg2</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr>!*<name>s1</name></expr>)</condition><then>
<expr_stmt><expr><name>result</name> = <name>s2</name></expr>;</expr_stmt></then>
<else>else <if>if <condition>(<expr>!*<name>s2</name></expr>)</condition><then>
<expr_stmt><expr><name>result</name> = <name>s1</name></expr>;</expr_stmt></then>
<else>else
<expr_stmt><expr><name>result</name> = <call><name>apr_pstrcat</name><argument_list>(<argument><expr><name><name>ctx</name>-&gt;<name>p</name></name></expr></argument>, <argument><expr><name>s1</name></expr></argument>, <argument><expr><name>s2</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if></else></if>
}</block></then> <else>else <if>if <condition>(<expr>((<name>ap_expr_t</name> *)<name><name>node</name>-&gt;<name>node_arg1</name></name>)-&gt;<name>node_op</name> == <name>op_Concat</name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>ap_expr_t</name> *</type><name>nodep</name> <init>= <expr><name>node</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr>1</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type>struct <name>iovec</name> *</type><name>vec</name></decl>;</decl_stmt>
<do>do <block>{
<expr_stmt><expr><name>nodep</name> = <name><name>nodep</name>-&gt;<name>node_arg1</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>i</name>++</expr>;</expr_stmt>
}</block> while <condition>(<expr><name><name>nodep</name>-&gt;<name>node_op</name></name> == <name>op_Concat</name></expr>)</condition>;</do>
<expr_stmt><expr><name>vec</name> = <call><name>apr_palloc</name><argument_list>(<argument><expr><name><name>ctx</name>-&gt;<name>p</name></name></expr></argument>, <argument><expr><name>i</name> * <sizeof>sizeof<argument_list>(<argument>struct <expr><name>iovec</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>n</name> = <name>i</name></expr>;</expr_stmt>
<expr_stmt><expr><name>nodep</name> = <name>node</name></expr>;</expr_stmt>
<expr_stmt><expr><name>i</name>--</expr>;</expr_stmt>
<do>do <block>{
<expr_stmt><expr><name><name>vec</name><index>[<expr><name>i</name></expr>]</index></name>.<name>iov_base</name> = (<name>void</name> *)<call><name>ap_expr_eval_word</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>,
<argument><expr><name><name>nodep</name>-&gt;<name>node_arg2</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>vec</name><index>[<expr><name>i</name></expr>]</index></name>.<name>iov_len</name> = <call><name>strlen</name><argument_list>(<argument><expr><name><name>vec</name><index>[<expr><name>i</name></expr>]</index></name>.<name>iov_base</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>i</name>--</expr>;</expr_stmt>
<expr_stmt><expr><name>nodep</name> = <name><name>nodep</name>-&gt;<name>node_arg1</name></name></expr>;</expr_stmt>
}</block> while <condition>(<expr><name><name>nodep</name>-&gt;<name>node_op</name></name> == <name>op_Concat</name></expr>)</condition>;</do>
<expr_stmt><expr><name><name>vec</name><index>[<expr><name>i</name></expr>]</index></name>.<name>iov_base</name> = (<name>void</name> *)<call><name>ap_expr_eval_word</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>nodep</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>vec</name><index>[<expr><name>i</name></expr>]</index></name>.<name>iov_len</name> = <call><name>strlen</name><argument_list>(<argument><expr><name><name>vec</name><index>[<expr><name>i</name></expr>]</index></name>.<name>iov_base</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>result</name> = <call><name>apr_pstrcatv</name><argument_list>(<argument><expr><name><name>ctx</name>-&gt;<name>p</name></name></expr></argument>, <argument><expr><name>vec</name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>ap_expr_t</name> *</type><name>nodep</name> <init>= <expr><name>node</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr>1</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type>struct <name>iovec</name> *</type><name>vec</name></decl>;</decl_stmt>
<do>do <block>{
<expr_stmt><expr><name>nodep</name> = <name><name>nodep</name>-&gt;<name>node_arg2</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>i</name>++</expr>;</expr_stmt>
}</block> while <condition>(<expr><name><name>nodep</name>-&gt;<name>node_op</name></name> == <name>op_Concat</name></expr>)</condition>;</do>
<expr_stmt><expr><name>vec</name> = <call><name>apr_palloc</name><argument_list>(<argument><expr><name><name>ctx</name>-&gt;<name>p</name></name></expr></argument>, <argument><expr><name>i</name> * <sizeof>sizeof<argument_list>(<argument>struct <expr><name>iovec</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>nodep</name> = <name>node</name></expr>;</expr_stmt>
<expr_stmt><expr><name>i</name> = 0</expr>;</expr_stmt>
<do>do <block>{
<expr_stmt><expr><name><name>vec</name><index>[<expr><name>i</name></expr>]</index></name>.<name>iov_base</name> = (<name>void</name> *)<call><name>ap_expr_eval_word</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>,
<argument><expr><name><name>nodep</name>-&gt;<name>node_arg1</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>vec</name><index>[<expr><name>i</name></expr>]</index></name>.<name>iov_len</name> = <call><name>strlen</name><argument_list>(<argument><expr><name><name>vec</name><index>[<expr><name>i</name></expr>]</index></name>.<name>iov_base</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>i</name>++</expr>;</expr_stmt>
<expr_stmt><expr><name>nodep</name> = <name><name>nodep</name>-&gt;<name>node_arg2</name></name></expr>;</expr_stmt>
}</block> while <condition>(<expr><name><name>nodep</name>-&gt;<name>node_op</name></name> == <name>op_Concat</name></expr>)</condition>;</do>
<expr_stmt><expr><name><name>vec</name><index>[<expr><name>i</name></expr>]</index></name>.<name>iov_base</name> = (<name>void</name> *)<call><name>ap_expr_eval_word</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>nodep</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>vec</name><index>[<expr><name>i</name></expr>]</index></name>.<name>iov_len</name> = <call><name>strlen</name><argument_list>(<argument><expr><name><name>vec</name><index>[<expr><name>i</name></expr>]</index></name>.<name>iov_base</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>i</name>++</expr>;</expr_stmt>
<expr_stmt><expr><name>result</name> = <call><name>apr_pstrcatv</name><argument_list>(<argument><expr><name><name>ctx</name>-&gt;<name>p</name></name></expr></argument>, <argument><expr><name>vec</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></else></if></else></if>
<break>break;</break>
</case><case>case <expr><name>op_StringFuncCall</name></expr>: <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>ap_expr_t</name> *</type><name>info</name> <init>= <expr><name><name>node</name>-&gt;<name>node_arg1</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>ap_expr_t</name> *</type><name>args</name> <init>= <expr><name><name>node</name>-&gt;<name>node_arg2</name></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>result</name> = <call><name>ap_expr_eval_string_func</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>info</name></expr></argument>, <argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
}</block>
</case><case>case <expr><name>op_RegexBackref</name></expr>: <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>int</name> *</type><name>np</name> <init>= <expr><name><name>node</name>-&gt;<name>node_arg1</name></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>result</name> = <call><name>ap_expr_eval_re_backref</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr>*<name>np</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
}</block>
</case><default>default:
<expr_stmt><expr>*<name><name>ctx</name>-&gt;<name>err</name></name> = "Internal evaluation error: Unknown word expression node"</expr>;</expr_stmt>
<break>break;</break>
</default>}</block></switch>
<if>if <condition>(<expr>!<name>result</name></expr>)</condition><then>
<expr_stmt><expr><name>result</name> = ""</expr>;</expr_stmt></then></if>
<expr_stmt><expr><name><name>ctx</name>-&gt;<name>reclvl</name></name>--</expr>;</expr_stmt>
<return>return <expr><name>result</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> *</type><name>ap_expr_eval_var</name><parameter_list>(<param><decl><type><name>ap_expr_eval_ctx_t</name> *</type><name>ctx</name></decl></param>,
<param><decl><type><name>ap_expr_var_func_t</name> *</type><name>func</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>void</name> *</type><name>data</name></decl></param>)</parameter_list> <block>{
<expr_stmt><expr><call><name>AP_DEBUG_ASSERT</name><argument_list>(<argument><expr><name>func</name> != <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>AP_DEBUG_ASSERT</name><argument_list>(<argument><expr><name>data</name> != <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call>(*<name>func</name>)<argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>data</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> *</type><name>ap_expr_eval_re_backref</name><parameter_list>(<param><decl><type><name>ap_expr_eval_ctx_t</name> *</type><name>ctx</name></decl></param>, <param><decl><type><name>unsigned</name> <name>int</name></type> <name>n</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>len</name></decl>;</decl_stmt>
<if>if <condition>(<expr>!<name><name>ctx</name>-&gt;<name>re_pmatch</name></name> || !<name><name>ctx</name>-&gt;<name>re_source</name></name> || !*<name><name>ctx</name>-&gt;<name>re_source</name></name>
|| **<name><name>ctx</name>-&gt;<name>re_source</name></name> == '\0' || <name><name>ctx</name>-&gt;<name>re_nmatch</name></name> &lt; <name>n</name> + 1</expr>)</condition><then>
<return>return <expr>""</expr>;</return></then></if>
<expr_stmt><expr><name>len</name> = <name><name>ctx</name>-&gt;<name>re_pmatch</name><index>[<expr><name>n</name></expr>]</index></name>.<name>rm_eo</name> - <name><name>ctx</name>-&gt;<name>re_pmatch</name><index>[<expr><name>n</name></expr>]</index></name>.<name>rm_so</name></expr>;</expr_stmt>
<if>if <condition>(<expr><name>len</name> == 0</expr>)</condition><then>
<return>return <expr>""</expr>;</return></then></if>
<return>return <expr><call><name>apr_pstrndup</name><argument_list>(<argument><expr><name><name>ctx</name>-&gt;<name>p</name></name></expr></argument>, <argument><expr>*<name><name>ctx</name>-&gt;<name>re_source</name></name> + <name><name>ctx</name>-&gt;<name>re_pmatch</name><index>[<expr><name>n</name></expr>]</index></name>.<name>rm_so</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> *</type><name>ap_expr_eval_string_func</name><parameter_list>(<param><decl><type><name>ap_expr_eval_ctx_t</name> *</type><name>ctx</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>ap_expr_t</name> *</type><name>info</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>ap_expr_t</name> *</type><name>arg</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>ap_expr_string_func_t</name> *</type><name>func</name> <init>= <expr>(<name>ap_expr_string_func_t</name> *)<name><name>info</name>-&gt;<name>node_arg1</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>void</name> *</type><name>data</name> <init>= <expr><name><name>info</name>-&gt;<name>node_arg2</name></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>AP_DEBUG_ASSERT</name><argument_list>(<argument><expr><name><name>info</name>-&gt;<name>node_op</name></name> == <name>op_StringFuncInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>AP_DEBUG_ASSERT</name><argument_list>(<argument><expr><name>func</name> != <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>AP_DEBUG_ASSERT</name><argument_list>(<argument><expr><name>data</name> != <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call>(*<name>func</name>)<argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>data</name></expr></argument>, <argument><expr><call><name>ap_expr_eval_word</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>intstrcmp</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>s1</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>s2</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>apr_int64_t</name></type> <name>i1</name> <init>= <expr><call><name>apr_atoi64</name><argument_list>(<argument><expr><name>s1</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>apr_int64_t</name></type> <name>i2</name> <init>= <expr><call><name>apr_atoi64</name><argument_list>(<argument><expr><name>s2</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>i1</name> &lt; <name>i2</name></expr>)</condition><then>
<return>return <expr>-1</expr>;</return></then>
<else>else <if>if <condition>(<expr><name>i1</name> == <name>i2</name></expr>)</condition><then>
<return>return <expr>0</expr>;</return></then>
<else>else
<return>return <expr>1</expr>;</return></else></if></else></if>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>ap_expr_eval_comp</name><parameter_list>(<param><decl><type><name>ap_expr_eval_ctx_t</name> *</type><name>ctx</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>ap_expr_t</name> *</type><name>node</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>ap_expr_t</name> *</type><name>e1</name> <init>= <expr><name><name>node</name>-&gt;<name>node_arg1</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>ap_expr_t</name> *</type><name>e2</name> <init>= <expr><name><name>node</name>-&gt;<name>node_arg2</name></name></expr></init></decl>;</decl_stmt>
<switch>switch <condition>(<expr><name><name>node</name>-&gt;<name>node_op</name></name></expr>)</condition> <block>{
<case>case <expr><name>op_EQ</name></expr>:
<return>return <expr>(<call><name>intstrcmp</name><argument_list>(<argument><expr><call><name>ap_expr_eval_word</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>e1</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>ap_expr_eval_word</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>e2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> == 0)</expr>;</return>
</case><case>case <expr><name>op_NE</name></expr>:
<return>return <expr>(<call><name>intstrcmp</name><argument_list>(<argument><expr><call><name>ap_expr_eval_word</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>e1</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>ap_expr_eval_word</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>e2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> != 0)</expr>;</return>
</case><case>case <expr><name>op_LT</name></expr>:
<return>return <expr>(<call><name>intstrcmp</name><argument_list>(<argument><expr><call><name>ap_expr_eval_word</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>e1</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>ap_expr_eval_word</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>e2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> &lt; 0)</expr>;</return>
</case><case>case <expr><name>op_LE</name></expr>:
<return>return <expr>(<call><name>intstrcmp</name><argument_list>(<argument><expr><call><name>ap_expr_eval_word</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>e1</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>ap_expr_eval_word</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>e2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> &lt;= 0)</expr>;</return>
</case><case>case <expr><name>op_GT</name></expr>:
<return>return <expr>(<call><name>intstrcmp</name><argument_list>(<argument><expr><call><name>ap_expr_eval_word</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>e1</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>ap_expr_eval_word</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>e2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> &gt; 0)</expr>;</return>
</case><case>case <expr><name>op_GE</name></expr>:
<return>return <expr>(<call><name>intstrcmp</name><argument_list>(<argument><expr><call><name>ap_expr_eval_word</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>e1</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>ap_expr_eval_word</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>e2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> &gt;= 0)</expr>;</return>
</case><case>case <expr><name>op_STR_EQ</name></expr>:
<return>return <expr>(<call><name>strcmp</name><argument_list>(<argument><expr><call><name>ap_expr_eval_word</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>e1</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>ap_expr_eval_word</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>e2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> == 0)</expr>;</return>
</case><case>case <expr><name>op_STR_NE</name></expr>:
<return>return <expr>(<call><name>strcmp</name><argument_list>(<argument><expr><call><name>ap_expr_eval_word</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>e1</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>ap_expr_eval_word</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>e2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> != 0)</expr>;</return>
</case><case>case <expr><name>op_STR_LT</name></expr>:
<return>return <expr>(<call><name>strcmp</name><argument_list>(<argument><expr><call><name>ap_expr_eval_word</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>e1</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>ap_expr_eval_word</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>e2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> &lt; 0)</expr>;</return>
</case><case>case <expr><name>op_STR_LE</name></expr>:
<return>return <expr>(<call><name>strcmp</name><argument_list>(<argument><expr><call><name>ap_expr_eval_word</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>e1</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>ap_expr_eval_word</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>e2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> &lt;= 0)</expr>;</return>
</case><case>case <expr><name>op_STR_GT</name></expr>:
<return>return <expr>(<call><name>strcmp</name><argument_list>(<argument><expr><call><name>ap_expr_eval_word</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>e1</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>ap_expr_eval_word</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>e2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> &gt; 0)</expr>;</return>
</case><case>case <expr><name>op_STR_GE</name></expr>:
<return>return <expr>(<call><name>strcmp</name><argument_list>(<argument><expr><call><name>ap_expr_eval_word</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>e1</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>ap_expr_eval_word</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>e2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> &gt;= 0)</expr>;</return>
</case><case>case <expr><name>op_IN</name></expr>: <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>needle</name> <init>= <expr><call><name>ap_expr_eval_word</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>e1</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name><name>e2</name>-&gt;<name>node_op</name></name> == <name>op_ListElement</name></expr>)</condition><then> <block>{
<do>do <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>ap_expr_t</name> *</type><name>val</name> <init>= <expr><name><name>e2</name>-&gt;<name>node_arg1</name></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>AP_DEBUG_ASSERT</name><argument_list>(<argument><expr><name><name>e2</name>-&gt;<name>node_op</name></name> == <name>op_ListElement</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>needle</name></expr></argument>, <argument><expr><call><name>ap_expr_eval_word</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> == 0</expr>)</condition><then>
<return>return <expr>1</expr>;</return></then></if>
<expr_stmt><expr><name>e2</name> = <name><name>e2</name>-&gt;<name>node_arg2</name></name></expr>;</expr_stmt>
}</block> while <condition>(<expr><name>e2</name> != <name>NULL</name></expr>)</condition>;</do>
}</block></then> <else>else <if>if <condition>(<expr><name><name>e2</name>-&gt;<name>node_op</name></name> == <name>op_ListFuncCall</name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>ap_expr_t</name> *</type><name>info</name> <init>= <expr><name><name>e2</name>-&gt;<name>node_arg1</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>ap_expr_t</name> *</type><name>arg</name> <init>= <expr><name><name>e2</name>-&gt;<name>node_arg2</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ap_expr_list_func_t</name> *</type><name>func</name> <init>= <expr>(<name>ap_expr_list_func_t</name> *)<name><name>info</name>-&gt;<name>node_arg1</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>apr_array_header_t</name> *</type><name>haystack</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>AP_DEBUG_ASSERT</name><argument_list>(<argument><expr><name>func</name> != <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>AP_DEBUG_ASSERT</name><argument_list>(<argument><expr><name><name>info</name>-&gt;<name>node_op</name></name> == <name>op_ListFuncInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>haystack</name> = <call>(*<name>func</name>)<argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name><name>info</name>-&gt;<name>node_arg2</name></name></expr></argument>, <argument><expr><call><name>ap_expr_eval_word</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>haystack</name> == <name>NULL</name></expr>)</condition><then> <block>{
<return>return <expr>0</expr>;</return>
}</block></then></if>
<if>if <condition>(<expr><call><name>ap_array_str_contains</name><argument_list>(<argument><expr><name>haystack</name></expr></argument>, <argument><expr><name>needle</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<return>return <expr>1</expr>;</return>
}</block></then></if>
}</block></then></if></else></if>
<return>return <expr>0</expr>;</return>
}</block>
</case><case>case <expr><name>op_REG</name></expr>:
</case><case>case <expr><name>op_NRE</name></expr>: <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>word</name> <init>= <expr><call><name>ap_expr_eval_word</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>e1</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>ap_regex_t</name> *</type><name>regex</name> <init>= <expr><name><name>e2</name>-&gt;<name>node_arg1</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>result</name></decl>;</decl_stmt>
<if>if <condition>(<expr><name><name>regex</name>-&gt;<name>re_nsub</name></name> &gt; 0</expr>)</condition><then> <block>{
<expr_stmt><expr><name>result</name> = (0 == <call><name>ap_regexec</name><argument_list>(<argument><expr><name>regex</name></expr></argument>, <argument><expr><name>word</name></expr></argument>, <argument><expr><name><name>ctx</name>-&gt;<name>re_nmatch</name></name></expr></argument>,
<argument><expr><name><name>ctx</name>-&gt;<name>re_pmatch</name></name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call>)</expr>;</expr_stmt>
<expr_stmt><expr>*<name><name>ctx</name>-&gt;<name>re_source</name></name> = <name>result</name> ? <name>word</name> : <name>NULL</name></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr><name>result</name> = (0 == <call><name>ap_regexec</name><argument_list>(<argument><expr><name>regex</name></expr></argument>, <argument><expr><name>word</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call>)</expr>;</expr_stmt>
}</block></else></if>
<if>if <condition>(<expr><name><name>node</name>-&gt;<name>node_op</name></name> == <name>op_REG</name></expr>)</condition><then>
<return>return <expr><name>result</name></expr>;</return></then>
<else>else
<return>return <expr>!<name>result</name></expr>;</return></else></if>
}</block>
</case><default>default:
<expr_stmt><expr>*<name><name>ctx</name>-&gt;<name>err</name></name> = "Internal evaluation error: Unknown comp expression node"</expr>;</expr_stmt>
<return>return <expr>-1</expr>;</return>
</default>}</block></switch>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>strcmplex</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>str1</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>str2</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>n1</name></decl>, <decl><type ref="prev"/><name>n2</name></decl>;</decl_stmt>
<if>if <condition>(<expr><name>str1</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr>-1</expr>;</return></then></if>
<if>if <condition>(<expr><name>str2</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr>+1</expr>;</return></then></if>
<expr_stmt><expr><name>n1</name> = <call><name>strlen</name><argument_list>(<argument><expr><name>str1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>n2</name> = <call><name>strlen</name><argument_list>(<argument><expr><name>str2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>n1</name> &gt; <name>n2</name></expr>)</condition><then>
<return>return <expr>1</expr>;</return></then></if>
<if>if <condition>(<expr><name>n1</name> &lt; <name>n2</name></expr>)</condition><then>
<return>return <expr>-1</expr>;</return></then></if>
<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>n1</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
<if>if <condition>(<expr><name><name>str1</name><index>[<expr><name>i</name></expr>]</index></name> &gt; <name><name>str2</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><then>
<return>return <expr>1</expr>;</return></then></if>
<if>if <condition>(<expr><name><name>str1</name><index>[<expr><name>i</name></expr>]</index></name> &lt; <name><name>str2</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><then>
<return>return <expr>-1</expr>;</return></then></if>
}</block></for>
<return>return <expr>0</expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>ssl_expr_eval_comp</name><parameter_list>(<param><decl><type><name>ap_expr_eval_ctx_t</name> *</type><name>ctx</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>ap_expr_t</name> *</type><name>node</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>ap_expr_t</name> *</type><name>e1</name> <init>= <expr><name><name>node</name>-&gt;<name>node_arg1</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>ap_expr_t</name> *</type><name>e2</name> <init>= <expr><name><name>node</name>-&gt;<name>node_arg2</name></name></expr></init></decl>;</decl_stmt>
<switch>switch <condition>(<expr><name><name>node</name>-&gt;<name>node_op</name></name></expr>)</condition> <block>{
<case>case <expr><name>op_EQ</name></expr>:
</case><case>case <expr><name>op_STR_EQ</name></expr>:
<return>return <expr>(<call><name>strcmplex</name><argument_list>(<argument><expr><call><name>ap_expr_eval_word</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>e1</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>ap_expr_eval_word</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>e2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> == 0)</expr>;</return>
</case><case>case <expr><name>op_NE</name></expr>:
</case><case>case <expr><name>op_STR_NE</name></expr>:
<return>return <expr>(<call><name>strcmplex</name><argument_list>(<argument><expr><call><name>ap_expr_eval_word</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>e1</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>ap_expr_eval_word</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>e2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> != 0)</expr>;</return>
</case><case>case <expr><name>op_LT</name></expr>:
</case><case>case <expr><name>op_STR_LT</name></expr>:
<return>return <expr>(<call><name>strcmplex</name><argument_list>(<argument><expr><call><name>ap_expr_eval_word</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>e1</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>ap_expr_eval_word</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>e2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> &lt; 0)</expr>;</return>
</case><case>case <expr><name>op_LE</name></expr>:
</case><case>case <expr><name>op_STR_LE</name></expr>:
<return>return <expr>(<call><name>strcmplex</name><argument_list>(<argument><expr><call><name>ap_expr_eval_word</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>e1</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>ap_expr_eval_word</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>e2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> &lt;= 0)</expr>;</return>
</case><case>case <expr><name>op_GT</name></expr>:
</case><case>case <expr><name>op_STR_GT</name></expr>:
<return>return <expr>(<call><name>strcmplex</name><argument_list>(<argument><expr><call><name>ap_expr_eval_word</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>e1</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>ap_expr_eval_word</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>e2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> &gt; 0)</expr>;</return>
</case><case>case <expr><name>op_GE</name></expr>:
</case><case>case <expr><name>op_STR_GE</name></expr>:
<return>return <expr>(<call><name>strcmplex</name><argument_list>(<argument><expr><call><name>ap_expr_eval_word</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>e1</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>ap_expr_eval_word</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>e2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> &gt;= 0)</expr>;</return>
</case><default>default:
<return>return <expr><call><name>ap_expr_eval_comp</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</return>
</default>}</block></switch>
}</block></function>
<macro><name>AP_DECLARE_NONSTD</name><argument_list>(<argument>int</argument>)</argument_list></macro> <macro><name>ap_expr_lookup_default</name><argument_list>(<argument>ap_expr_lookup_parms *parms</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name>ap_run_expr_lookup</name><argument_list>(<argument><expr><name>parms</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<macro><name>AP_DECLARE</name><argument_list>(<argument>const char *</argument>)</argument_list></macro> <macro><name>ap_expr_parse</name><argument_list>(<argument>apr_pool_t *pool</argument>, <argument>apr_pool_t *ptemp</argument>,
<argument>ap_expr_info_t *info</argument>, <argument>const char *expr</argument>,
<argument>ap_expr_lookup_fn_t *lookup_fn</argument>)</argument_list></macro> <block>{
<decl_stmt><decl><type><name>ap_expr_parse_ctx_t</name></type> <name>ctx</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
<expr_stmt><expr><name><name>ctx</name>.<name>pool</name></name> = <name>pool</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ctx</name>.<name>ptemp</name></name> = <name>ptemp</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ctx</name>.<name>inputbuf</name></name> = <name>expr</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ctx</name>.<name>inputlen</name></name> = <call><name>strlen</name><argument_list>(<argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ctx</name>.<name>inputptr</name></name> = <name><name>ctx</name>.<name>inputbuf</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ctx</name>.<name>expr</name></name> = <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ctx</name>.<name>error</name></name> = <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ctx</name>.<name>error2</name></name> = <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ctx</name>.<name>flags</name></name> = <name><name>info</name>-&gt;<name>flags</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ctx</name>.<name>scan_del</name></name> = '\0'</expr>;</expr_stmt>
<expr_stmt><expr><name><name>ctx</name>.<name>scan_buf</name><index>[<expr>0</expr>]</index></name> = '\0'</expr>;</expr_stmt>
<expr_stmt><expr><name><name>ctx</name>.<name>scan_ptr</name></name> = <name><name>ctx</name>.<name>scan_buf</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ctx</name>.<name>lookup_fn</name></name> = <name>lookup_fn</name> ? <name>lookup_fn</name> : <name>ap_expr_lookup_default</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ctx</name>.<name>at_start</name></name> = 1</expr>;</expr_stmt>
<expr_stmt><expr><call><name>ap_expr_yylex_init</name><argument_list>(<argument><expr>&amp;<name><name>ctx</name>.<name>scanner</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ap_expr_yyset_extra</name><argument_list>(<argument><expr>&amp;<name>ctx</name></expr></argument>, <argument><expr><name><name>ctx</name>.<name>scanner</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>rc</name> = <call><name>ap_expr_yyparse</name><argument_list>(<argument><expr>&amp;<name>ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ap_expr_yylex_destroy</name><argument_list>(<argument><expr><name><name>ctx</name>.<name>scanner</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>ctx</name>.<name>error</name></name></expr>)</condition><then> <block>{
<if>if <condition>(<expr><name><name>ctx</name>.<name>error2</name></name></expr>)</condition><then>
<return>return <expr><call><name>apr_psprintf</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr>"%s: %s"</expr></argument>, <argument><expr><name><name>ctx</name>.<name>error</name></name></expr></argument>, <argument><expr><name><name>ctx</name>.<name>error2</name></name></expr></argument>)</argument_list></call></expr>;</return></then>
<else>else
<return>return <expr><name><name>ctx</name>.<name>error</name></name></expr>;</return></else></if>
}</block></then> <else>else <if>if <condition>(<expr><name><name>ctx</name>.<name>error2</name></name></expr>)</condition><then> <block>{
<return>return <expr><name><name>ctx</name>.<name>error2</name></name></expr>;</return>
}</block></then></if></else></if>
<if>if <condition>(<expr><name>rc</name></expr>)</condition><then>
<return>return <expr>"syntax error"</expr>;</return></then></if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>AP_EXPR_DEBUG</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if>if <condition>(<expr><name><name>ctx</name>.<name>expr</name></name></expr>)</condition><then>
<expr_stmt><expr><call><name>expr_dump_tree</name><argument_list>(<argument><expr><name><name>ctx</name>.<name>expr</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>APLOG_NOTICE</name></expr></argument>, <argument><expr>2</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><name><name>info</name>-&gt;<name>root_node</name></name> = <name><name>ctx</name>.<name>expr</name></name></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block>
<macro><name>AP_DECLARE</name><argument_list>(<argument>ap_expr_info_t*</argument>)</argument_list></macro> <macro><name>ap_expr_parse_cmd_mi</name><argument_list>(<argument>const cmd_parms *cmd</argument>,
<argument>const char *expr</argument>,
<argument>unsigned int flags</argument>,
<argument>const char **err</argument>,
<argument>ap_expr_lookup_fn_t *lookup_fn</argument>,
<argument>int module_index</argument>)</argument_list></macro> <block>{
<decl_stmt><decl><type><name>ap_expr_info_t</name> *</type><name>info</name> <init>= <expr><call><name>apr_pcalloc</name><argument_list>(<argument><expr><name><name>cmd</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ap_expr_info_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>info</name>-&gt;<name>filename</name></name> = <name><name>cmd</name>-&gt;<name>directive</name>-&gt;<name>filename</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>info</name>-&gt;<name>line_number</name></name> = <name><name>cmd</name>-&gt;<name>directive</name>-&gt;<name>line_num</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>info</name>-&gt;<name>flags</name></name> = <name>flags</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>info</name>-&gt;<name>module_index</name></name> = <name>module_index</name></expr>;</expr_stmt>
<expr_stmt><expr>*<name>err</name> = <call><name>ap_expr_parse</name><argument_list>(<argument><expr><name><name>cmd</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name><name>cmd</name>-&gt;<name>temp_pool</name></name></expr></argument>, <argument><expr><name>info</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>, <argument><expr><name>lookup_fn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>*<name>err</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<return>return <expr><name>info</name></expr>;</return>
}</block>
<function><type><name>ap_expr_t</name> *</type><name>ap_expr_make</name><parameter_list>(<param><decl><type><name>ap_expr_node_op_e</name></type> <name>op</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>void</name> *</type><name>a1</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>void</name> *</type><name>a2</name></decl></param>,
<param><decl><type><name>ap_expr_parse_ctx_t</name> *</type><name>ctx</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>ap_expr_t</name> *</type><name>node</name> <init>= <expr><call><name>apr_palloc</name><argument_list>(<argument><expr><name><name>ctx</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ap_expr_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>node</name>-&gt;<name>node_op</name></name> = <name>op</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>node</name>-&gt;<name>node_arg1</name></name> = <name>a1</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>node</name>-&gt;<name>node_arg2</name></name> = <name>a2</name></expr>;</expr_stmt>
<return>return <expr><name>node</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>ap_expr_t</name> *</type><name>ap_expr_info_make</name><parameter_list>(<param><decl><type><name>int</name></type> <name>type</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>name</name></decl></param>,
<param><decl><type><name>ap_expr_parse_ctx_t</name> *</type><name>ctx</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>ap_expr_t</name> *</type><name>arg</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>ap_expr_t</name> *</type><name>info</name> <init>= <expr><call><name>apr_palloc</name><argument_list>(<argument><expr><name><name>ctx</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ap_expr_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ap_expr_lookup_parms</name></type> <name>parms</name></decl>;</decl_stmt>
<expr_stmt><expr><name><name>parms</name>.<name>type</name></name> = <name>type</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>parms</name>.<name>flags</name></name> = <name><name>ctx</name>-&gt;<name>flags</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>parms</name>.<name>pool</name></name> = <name><name>ctx</name>-&gt;<name>pool</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>parms</name>.<name>ptemp</name></name> = <name><name>ctx</name>-&gt;<name>ptemp</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>parms</name>.<name>name</name></name> = <name>name</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>parms</name>.<name>func</name></name> = &amp;<name><name>info</name>-&gt;<name>node_arg1</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>parms</name>.<name>data</name></name> = &amp;<name><name>info</name>-&gt;<name>node_arg2</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>parms</name>.<name>err</name></name> = &amp;<name><name>ctx</name>-&gt;<name>error2</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>parms</name>.<name>arg</name></name> = (<name>arg</name> &amp;&amp; <name><name>arg</name>-&gt;<name>node_op</name></name> == <name>op_String</name>) ? <name><name>arg</name>-&gt;<name>node_arg1</name></name> : <name>NULL</name></expr>;</expr_stmt>
<if>if <condition>(<expr><call><name><name>ctx</name>-&gt;<name>lookup_fn</name></name><argument_list>(<argument><expr>&amp;<name>parms</name></expr></argument>)</argument_list></call> != <name>OK</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<return>return <expr><name>info</name></expr>;</return>
}</block></function>
<function><type><name>ap_expr_t</name> *</type><name>ap_expr_str_func_make</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>name</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>ap_expr_t</name> *</type><name>arg</name></decl></param>,
<param><decl><type><name>ap_expr_parse_ctx_t</name> *</type><name>ctx</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>ap_expr_t</name> *</type><name>info</name> <init>= <expr><call><name>ap_expr_info_make</name><argument_list>(<argument><expr><name>AP_EXPR_FUNC_STRING</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr>!<name>info</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name><name>info</name>-&gt;<name>node_op</name></name> = <name>op_StringFuncInfo</name></expr>;</expr_stmt>
<return>return <expr><call><name>ap_expr_make</name><argument_list>(<argument><expr><name>op_StringFuncCall</name></expr></argument>, <argument><expr><name>info</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>, <argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><name>ap_expr_t</name> *</type><name>ap_expr_list_func_make</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>name</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>ap_expr_t</name> *</type><name>arg</name></decl></param>,
<param><decl><type><name>ap_expr_parse_ctx_t</name> *</type><name>ctx</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>ap_expr_t</name> *</type><name>info</name> <init>= <expr><call><name>ap_expr_info_make</name><argument_list>(<argument><expr><name>AP_EXPR_FUNC_LIST</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr>!<name>info</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name><name>info</name>-&gt;<name>node_op</name></name> = <name>op_ListFuncInfo</name></expr>;</expr_stmt>
<return>return <expr><call><name>ap_expr_make</name><argument_list>(<argument><expr><name>op_ListFuncCall</name></expr></argument>, <argument><expr><name>info</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>, <argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><name>ap_expr_t</name> *</type><name>ap_expr_unary_op_make</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>name</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>ap_expr_t</name> *</type><name>arg</name></decl></param>,
<param><decl><type><name>ap_expr_parse_ctx_t</name> *</type><name>ctx</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>ap_expr_t</name> *</type><name>info</name> <init>= <expr><call><name>ap_expr_info_make</name><argument_list>(<argument><expr><name>AP_EXPR_FUNC_OP_UNARY</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr>!<name>info</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name><name>info</name>-&gt;<name>node_op</name></name> = <name>op_UnaryOpInfo</name></expr>;</expr_stmt>
<return>return <expr><call><name>ap_expr_make</name><argument_list>(<argument><expr><name>op_UnaryOpCall</name></expr></argument>, <argument><expr><name>info</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>, <argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><name>ap_expr_t</name> *</type><name>ap_expr_binary_op_make</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>name</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>ap_expr_t</name> *</type><name>arg1</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>ap_expr_t</name> *</type><name>arg2</name></decl></param>, <param><decl><type><name>ap_expr_parse_ctx_t</name> *</type><name>ctx</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>ap_expr_t</name> *</type><name>args</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ap_expr_t</name> *</type><name>info</name> <init>= <expr><call><name>ap_expr_info_make</name><argument_list>(<argument><expr><name>AP_EXPR_FUNC_OP_BINARY</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>ctx</name></expr></argument>,
<argument><expr><name>arg2</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr>!<name>info</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name><name>info</name>-&gt;<name>node_op</name></name> = <name>op_BinaryOpInfo</name></expr>;</expr_stmt>
<expr_stmt><expr><name>args</name> = <call><name>ap_expr_make</name><argument_list>(<argument><expr><name>op_BinaryOpArgs</name></expr></argument>, <argument><expr><name>arg1</name></expr></argument>, <argument><expr><name>arg2</name></expr></argument>, <argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>ap_expr_make</name><argument_list>(<argument><expr><name>op_BinaryOpCall</name></expr></argument>, <argument><expr><name>info</name></expr></argument>, <argument><expr><name>args</name></expr></argument>, <argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><name>ap_expr_t</name> *</type><name>ap_expr_var_make</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>name</name></decl></param>, <param><decl><type><name>ap_expr_parse_ctx_t</name> *</type><name>ctx</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>ap_expr_t</name> *</type><name>node</name> <init>= <expr><call><name>ap_expr_info_make</name><argument_list>(<argument><expr><name>AP_EXPR_FUNC_VAR</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr>!<name>node</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name><name>node</name>-&gt;<name>node_op</name></name> = <name>op_Var</name></expr>;</expr_stmt>
<return>return <expr><name>node</name></expr>;</return>
}</block></function>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>AP_EXPR_DEBUG</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MARK</name></cpp:macro> <cpp:value>APLOG_MARK,loglevel,0,s</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DUMP_E_E</name><parameter_list>(<param><type><name>op</name></type></param>, <param><type><name>e1</name></type></param>, <param><type><name>e2</name></type></param>)</parameter_list></cpp:macro> <cpp:value>do { ap_log_error(MARK,"%*s%s: %pp %pp", indent, " ", op, e1, e2); if (e1) expr_dump_tree(e1, s, loglevel, indent + 2); if (e2) expr_dump_tree(e2, s, loglevel, indent + 2); } while (0)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DUMP_S_E</name><parameter_list>(<param><type><name>op</name></type></param>, <param><type><name>s1</name></type></param>, <param><type><name>e1</name></type></param>)</parameter_list></cpp:macro> <cpp:value>do { ap_log_error(MARK,"%*s%s: '%s' %pp", indent, " ", op, (char *)s1, e1); if (e1) expr_dump_tree(e1, s, loglevel, indent + 2); } while (0)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DUMP_S_P</name><parameter_list>(<param><type><name>op</name></type></param>, <param><type><name>s1</name></type></param>, <param><type><name>p1</name></type></param>)</parameter_list></cpp:macro> <cpp:value>ap_log_error(MARK,"%*s%s: '%s' %pp", indent, " ", op, (char *)s1, p1);</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DUMP_P_P</name><parameter_list>(<param><type><name>op</name></type></param>, <param><type><name>p1</name></type></param>, <param><type><name>p2</name></type></param>)</parameter_list></cpp:macro> <cpp:value>ap_log_error(MARK,"%*s%s: %pp %pp", indent, " ", op, p1, p2);</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DUMP_S_S</name><parameter_list>(<param><type><name>op</name></type></param>, <param><type><name>s1</name></type></param>, <param><type><name>s2</name></type></param>)</parameter_list></cpp:macro> <cpp:value>ap_log_error(MARK,"%*s%s: '%s' '%s'", indent, " ", op, (char *)s1, (char *)s2)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DUMP_P</name><parameter_list>(<param><type><name>op</name></type></param>, <param><type><name>p1</name></type></param>)</parameter_list></cpp:macro> <cpp:value>ap_log_error(MARK,"%*s%s: %pp", indent, " ", op, p1);</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DUMP_IP</name><parameter_list>(<param><type><name>op</name></type></param>, <param><type><name>p1</name></type></param>)</parameter_list></cpp:macro> <cpp:value>ap_log_error(MARK,"%*s%s: %d", indent, " ", op, *(int *)p1);</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DUMP_S</name><parameter_list>(<param><type><name>op</name></type></param>, <param><type><name>s1</name></type></param>)</parameter_list></cpp:macro> <cpp:value>ap_log_error(MARK,"%*s%s: '%s'", indent, " ", op, (char *)s1)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CASE_OP</name><parameter_list>(<param><type><name>op</name></type></param>)</parameter_list></cpp:macro> <cpp:value>case op: name = #op ; break;</cpp:value></cpp:define>
<function><type><specifier>static</specifier> <name>void</name></type> <name>expr_dump_tree</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>ap_expr_t</name> *</type><name>e</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>server_rec</name> *</type><name>s</name></decl></param>,
<param><decl><type><name>int</name></type> <name>loglevel</name></decl></param>, <param><decl><type><name>int</name></type> <name>indent</name></decl></param>)</parameter_list> <block>{
<switch>switch <condition>(<expr><name><name>e</name>-&gt;<name>node_op</name></name></expr>)</condition> <block>{
<case>case <expr><name>op_NOP</name></expr>:
</case><case>case <expr><name>op_True</name></expr>:
</case><case>case <expr><name>op_False</name></expr>: <block>{
<decl_stmt><decl><type><name>char</name> *</type><name>name</name></decl>;</decl_stmt>
<switch>switch <condition>(<expr><name><name>e</name>-&gt;<name>node_op</name></name></expr>)</condition> <block>{
<expr_stmt><expr><call><name>CASE_OP</name><argument_list>(<argument><expr><name>op_NOP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>CASE_OP</name><argument_list>(<argument><expr><name>op_True</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>CASE_OP</name><argument_list>(<argument><expr><name>op_False</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<default>default:
<expr_stmt><expr><call><name>ap_assert</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
</default>}</block></switch>
<expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>MARK</name></expr></argument>, <argument><expr>"%*s%s"</expr></argument>, <argument><expr><name>indent</name></expr></argument>, <argument><expr>" "</expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block>
<break>break;</break>
</case><case>case <expr><name>op_UnaryOpCall</name></expr>:
</case><case>case <expr><name>op_BinaryOpCall</name></expr>:
</case><case>case <expr><name>op_BinaryOpArgs</name></expr>: <block>{
<decl_stmt><decl><type><name>char</name> *</type><name>name</name></decl>;</decl_stmt>
<switch>switch <condition>(<expr><name><name>e</name>-&gt;<name>node_op</name></name></expr>)</condition> <block>{
<expr_stmt><expr><call><name>CASE_OP</name><argument_list>(<argument><expr><name>op_BinaryOpCall</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>CASE_OP</name><argument_list>(<argument><expr><name>op_UnaryOpCall</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>CASE_OP</name><argument_list>(<argument><expr><name>op_BinaryOpArgs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<default>default:
<expr_stmt><expr><call><name>ap_assert</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
</default>}</block></switch>
<expr_stmt><expr><call><name>DUMP_S_E</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name><name>e</name>-&gt;<name>node_arg1</name></name></expr></argument>, <argument><expr><name><name>e</name>-&gt;<name>node_arg2</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block>
<break>break;</break>
</case><case>case <expr><name>op_Comp</name></expr>:
</case><case>case <expr><name>op_Not</name></expr>:
</case><case>case <expr><name>op_Or</name></expr>:
</case><case>case <expr><name>op_And</name></expr>:
</case><case>case <expr><name>op_EQ</name></expr>:
</case><case>case <expr><name>op_NE</name></expr>:
</case><case>case <expr><name>op_LT</name></expr>:
</case><case>case <expr><name>op_LE</name></expr>:
</case><case>case <expr><name>op_GT</name></expr>:
</case><case>case <expr><name>op_GE</name></expr>:
</case><case>case <expr><name>op_STR_EQ</name></expr>:
</case><case>case <expr><name>op_STR_NE</name></expr>:
</case><case>case <expr><name>op_STR_LT</name></expr>:
</case><case>case <expr><name>op_STR_LE</name></expr>:
</case><case>case <expr><name>op_STR_GT</name></expr>:
</case><case>case <expr><name>op_STR_GE</name></expr>:
</case><case>case <expr><name>op_IN</name></expr>:
</case><case>case <expr><name>op_REG</name></expr>:
</case><case>case <expr><name>op_NRE</name></expr>:
</case><case>case <expr><name>op_Concat</name></expr>:
</case><case>case <expr><name>op_StringFuncCall</name></expr>:
</case><case>case <expr><name>op_ListFuncCall</name></expr>:
</case><case>case <expr><name>op_ListElement</name></expr>: <block>{
<decl_stmt><decl><type><name>char</name> *</type><name>name</name></decl>;</decl_stmt>
<switch>switch <condition>(<expr><name><name>e</name>-&gt;<name>node_op</name></name></expr>)</condition> <block>{
<expr_stmt><expr><call><name>CASE_OP</name><argument_list>(<argument><expr><name>op_Comp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>CASE_OP</name><argument_list>(<argument><expr><name>op_Not</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>CASE_OP</name><argument_list>(<argument><expr><name>op_Or</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>CASE_OP</name><argument_list>(<argument><expr><name>op_And</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>CASE_OP</name><argument_list>(<argument><expr><name>op_EQ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>CASE_OP</name><argument_list>(<argument><expr><name>op_NE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>CASE_OP</name><argument_list>(<argument><expr><name>op_LT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>CASE_OP</name><argument_list>(<argument><expr><name>op_LE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>CASE_OP</name><argument_list>(<argument><expr><name>op_GT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>CASE_OP</name><argument_list>(<argument><expr><name>op_GE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>CASE_OP</name><argument_list>(<argument><expr><name>op_STR_EQ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>CASE_OP</name><argument_list>(<argument><expr><name>op_STR_NE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>CASE_OP</name><argument_list>(<argument><expr><name>op_STR_LT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>CASE_OP</name><argument_list>(<argument><expr><name>op_STR_LE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>CASE_OP</name><argument_list>(<argument><expr><name>op_STR_GT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>CASE_OP</name><argument_list>(<argument><expr><name>op_STR_GE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>CASE_OP</name><argument_list>(<argument><expr><name>op_IN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>CASE_OP</name><argument_list>(<argument><expr><name>op_REG</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>CASE_OP</name><argument_list>(<argument><expr><name>op_NRE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>CASE_OP</name><argument_list>(<argument><expr><name>op_Concat</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>CASE_OP</name><argument_list>(<argument><expr><name>op_StringFuncCall</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>CASE_OP</name><argument_list>(<argument><expr><name>op_ListFuncCall</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>CASE_OP</name><argument_list>(<argument><expr><name>op_ListElement</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<default>default:
<expr_stmt><expr><call><name>ap_assert</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
</default>}</block></switch>
<expr_stmt><expr><call><name>DUMP_E_E</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name><name>e</name>-&gt;<name>node_arg1</name></name></expr></argument>, <argument><expr><name><name>e</name>-&gt;<name>node_arg2</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block>
<break>break;</break>
</case><case>case <expr><name>op_Digit</name></expr>:
</case><case>case <expr><name>op_String</name></expr>: <block>{
<decl_stmt><decl><type><name>char</name> *</type><name>name</name></decl>;</decl_stmt>
<switch>switch <condition>(<expr><name><name>e</name>-&gt;<name>node_op</name></name></expr>)</condition> <block>{
<expr_stmt><expr><call><name>CASE_OP</name><argument_list>(<argument><expr><name>op_Digit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>CASE_OP</name><argument_list>(<argument><expr><name>op_String</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<default>default:
<expr_stmt><expr><call><name>ap_assert</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
</default>}</block></switch>
<expr_stmt><expr><call><name>DUMP_S</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name><name>e</name>-&gt;<name>node_arg1</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block>
<break>break;</break>
</case><case>case <expr><name>op_Var</name></expr>:
</case><case>case <expr><name>op_StringFuncInfo</name></expr>:
</case><case>case <expr><name>op_UnaryOpInfo</name></expr>:
</case><case>case <expr><name>op_BinaryOpInfo</name></expr>:
</case><case>case <expr><name>op_ListFuncInfo</name></expr>: <block>{
<decl_stmt><decl><type><name>char</name> *</type><name>name</name></decl>;</decl_stmt>
<switch>switch <condition>(<expr><name><name>e</name>-&gt;<name>node_op</name></name></expr>)</condition> <block>{
<expr_stmt><expr><call><name>CASE_OP</name><argument_list>(<argument><expr><name>op_Var</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>CASE_OP</name><argument_list>(<argument><expr><name>op_StringFuncInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>CASE_OP</name><argument_list>(<argument><expr><name>op_UnaryOpInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>CASE_OP</name><argument_list>(<argument><expr><name>op_BinaryOpInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>CASE_OP</name><argument_list>(<argument><expr><name>op_ListFuncInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<default>default:
<expr_stmt><expr><call><name>ap_assert</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
</default>}</block></switch>
<expr_stmt><expr><call><name>DUMP_P_P</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name><name>e</name>-&gt;<name>node_arg1</name></name></expr></argument>, <argument><expr><name><name>e</name>-&gt;<name>node_arg2</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block>
<break>break;</break>
</case><case>case <expr><name>op_Regex</name></expr>:
<expr_stmt><expr><call><name>DUMP_P</name><argument_list>(<argument><expr>"op_Regex"</expr></argument>, <argument><expr><name><name>e</name>-&gt;<name>node_arg1</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr><name>op_RegexBackref</name></expr>:
<expr_stmt><expr><call><name>DUMP_IP</name><argument_list>(<argument><expr>"op_RegexBackref"</expr></argument>, <argument><expr><name><name>e</name>-&gt;<name>node_arg1</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</case><default>default:
<expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>MARK</name></expr></argument>, <argument><expr>"%*sERROR: INVALID OP %d"</expr></argument>, <argument><expr><name>indent</name></expr></argument>, <argument><expr>" "</expr></argument>, <argument><expr><name><name>e</name>-&gt;<name>node_op</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</default>}</block></switch>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<function><type><specifier>static</specifier> <name>int</name></type> <name>ap_expr_eval_unary_op</name><parameter_list>(<param><decl><type><name>ap_expr_eval_ctx_t</name> *</type><name>ctx</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>ap_expr_t</name> *</type><name>info</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>ap_expr_t</name> *</type><name>arg</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>ap_expr_op_unary_t</name> *</type><name>op_func</name> <init>= <expr>(<name>ap_expr_op_unary_t</name> *)<name><name>info</name>-&gt;<name>node_arg1</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>void</name> *</type><name>data</name> <init>= <expr><name><name>info</name>-&gt;<name>node_arg2</name></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>AP_DEBUG_ASSERT</name><argument_list>(<argument><expr><name><name>info</name>-&gt;<name>node_op</name></name> == <name>op_UnaryOpInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>AP_DEBUG_ASSERT</name><argument_list>(<argument><expr><name>op_func</name> != <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>AP_DEBUG_ASSERT</name><argument_list>(<argument><expr><name>data</name> != <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call>(*<name>op_func</name>)<argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>data</name></expr></argument>, <argument><expr><call><name>ap_expr_eval_word</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>ap_expr_eval_binary_op</name><parameter_list>(<param><decl><type><name>ap_expr_eval_ctx_t</name> *</type><name>ctx</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>ap_expr_t</name> *</type><name>info</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>ap_expr_t</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>ap_expr_op_binary_t</name> *</type><name>op_func</name> <init>= <expr>(<name>ap_expr_op_binary_t</name> *)<name><name>info</name>-&gt;<name>node_arg1</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>void</name> *</type><name>data</name> <init>= <expr><name><name>info</name>-&gt;<name>node_arg2</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>ap_expr_t</name> *</type><name>a1</name> <init>= <expr><name><name>args</name>-&gt;<name>node_arg1</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>ap_expr_t</name> *</type><name>a2</name> <init>= <expr><name><name>args</name>-&gt;<name>node_arg2</name></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>AP_DEBUG_ASSERT</name><argument_list>(<argument><expr><name><name>info</name>-&gt;<name>node_op</name></name> == <name>op_BinaryOpInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>AP_DEBUG_ASSERT</name><argument_list>(<argument><expr><name><name>args</name>-&gt;<name>node_op</name></name> == <name>op_BinaryOpArgs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>AP_DEBUG_ASSERT</name><argument_list>(<argument><expr><name>op_func</name> != <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>AP_DEBUG_ASSERT</name><argument_list>(<argument><expr><name>data</name> != <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call>(*<name>op_func</name>)<argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>data</name></expr></argument>, <argument><expr><call><name>ap_expr_eval_word</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>a1</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name>ap_expr_eval_word</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>a2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>ap_expr_eval</name><parameter_list>(<param><decl><type><name>ap_expr_eval_ctx_t</name> *</type><name>ctx</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>ap_expr_t</name> *</type><name>node</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>ap_expr_t</name> *</type><name>e1</name> <init>= <expr><name><name>node</name>-&gt;<name>node_arg1</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>ap_expr_t</name> *</type><name>e2</name> <init>= <expr><name><name>node</name>-&gt;<name>node_arg2</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>result</name> <init>= <expr><name>FALSE</name></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><call><name>inc_rec</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>result</name></expr>;</return></then></if>
<while>while <condition>(<expr>1</expr>)</condition> <block>{
<switch>switch <condition>(<expr><name><name>node</name>-&gt;<name>node_op</name></name></expr>)</condition> <block>{
<case>case <expr><name>op_True</name></expr>:
<expr_stmt><expr><name>result</name> ^= <name>TRUE</name></expr>;</expr_stmt>
<goto>goto <name>out</name>;</goto>
</case><case>case <expr><name>op_False</name></expr>:
<expr_stmt><expr><name>result</name> ^= <name>FALSE</name></expr>;</expr_stmt>
<goto>goto <name>out</name>;</goto>
</case><case>case <expr><name>op_Not</name></expr>:
<expr_stmt><expr><name>result</name> = !<name>result</name></expr>;</expr_stmt>
<expr_stmt><expr><name>node</name> = <name>e1</name></expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr><name>op_Or</name></expr>:
<do>do <block>{
<if>if <condition>(<expr><name><name>e1</name>-&gt;<name>node_op</name></name> == <name>op_Not</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr>!<call><name>ap_expr_eval</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name><name>e1</name>-&gt;<name>node_arg1</name></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><name>result</name> ^= <name>TRUE</name></expr>;</expr_stmt>
<goto>goto <name>out</name>;</goto>
}</block></then></if>
}</block></then> <else>else <block>{
<if>if <condition>(<expr><call><name>ap_expr_eval</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>e1</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><name>result</name> ^= <name>TRUE</name></expr>;</expr_stmt>
<goto>goto <name>out</name>;</goto>
}</block></then></if>
}</block></else></if>
<expr_stmt><expr><name>node</name> = <name><name>node</name>-&gt;<name>node_arg2</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>e1</name> = <name><name>node</name>-&gt;<name>node_arg1</name></name></expr>;</expr_stmt>
}</block> while <condition>(<expr><name><name>node</name>-&gt;<name>node_op</name></name> == <name>op_Or</name></expr>)</condition>;</do>
<break>break;</break>
</case><case>case <expr><name>op_And</name></expr>:
<do>do <block>{
<if>if <condition>(<expr><name><name>e1</name>-&gt;<name>node_op</name></name> == <name>op_Not</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr><call><name>ap_expr_eval</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name><name>e1</name>-&gt;<name>node_arg1</name></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><name>result</name> ^= <name>FALSE</name></expr>;</expr_stmt>
<goto>goto <name>out</name>;</goto>
}</block></then></if>
}</block></then> <else>else <block>{
<if>if <condition>(<expr>!<call><name>ap_expr_eval</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>e1</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><name>result</name> ^= <name>FALSE</name></expr>;</expr_stmt>
<goto>goto <name>out</name>;</goto>
}</block></then></if>
}</block></else></if>
<expr_stmt><expr><name>node</name> = <name><name>node</name>-&gt;<name>node_arg2</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>e1</name> = <name><name>node</name>-&gt;<name>node_arg1</name></name></expr>;</expr_stmt>
}</block> while <condition>(<expr><name><name>node</name>-&gt;<name>node_op</name></name> == <name>op_And</name></expr>)</condition>;</do>
<break>break;</break>
</case><case>case <expr><name>op_UnaryOpCall</name></expr>:
<expr_stmt><expr><name>result</name> ^= <call><name>ap_expr_eval_unary_op</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>e1</name></expr></argument>, <argument><expr><name>e2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>out</name>;</goto>
</case><case>case <expr><name>op_BinaryOpCall</name></expr>:
<expr_stmt><expr><name>result</name> ^= <call><name>ap_expr_eval_binary_op</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>e1</name></expr></argument>, <argument><expr><name>e2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>out</name>;</goto>
</case><case>case <expr><name>op_Comp</name></expr>:
<if>if <condition>(<expr><name><name>ctx</name>-&gt;<name>info</name>-&gt;<name>flags</name></name> &amp; <name>AP_EXPR_FLAG_SSL_EXPR_COMPAT</name></expr>)</condition><then>
<expr_stmt><expr><name>result</name> ^= <call><name>ssl_expr_eval_comp</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>e1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
<else>else
<expr_stmt><expr><name>result</name> ^= <call><name>ap_expr_eval_comp</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>e1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
<goto>goto <name>out</name>;</goto>
</case><default>default:
<expr_stmt><expr>*<name><name>ctx</name>-&gt;<name>err</name></name> = "Internal evaluation error: Unknown expression node"</expr>;</expr_stmt>
<goto>goto <name>out</name>;</goto>
</default>}</block></switch>
<expr_stmt><expr><name>e1</name> = <name><name>node</name>-&gt;<name>node_arg1</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>e2</name> = <name><name>node</name>-&gt;<name>node_arg2</name></name></expr>;</expr_stmt>
}</block></while>
<label><name>out</name>:</label>
<expr_stmt><expr><name><name>ctx</name>-&gt;<name>reclvl</name></name>--</expr>;</expr_stmt>
<return>return <expr><name>result</name></expr>;</return>
}</block></function>
<macro><name>AP_DECLARE</name><argument_list>(<argument>int</argument>)</argument_list></macro> <macro><name>ap_expr_exec</name><argument_list>(<argument>request_rec *r</argument>, <argument>const ap_expr_info_t *info</argument>,
<argument>const char **err</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name>ap_expr_exec_re</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>info</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<macro><name>AP_DECLARE</name><argument_list>(<argument>int</argument>)</argument_list></macro> <macro><name>ap_expr_exec_ctx</name><argument_list>(<argument>ap_expr_eval_ctx_t *ctx</argument>)</argument_list></macro> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>AP_DEBUG_ASSERT</name><argument_list>(<argument><expr><name><name>ctx</name>-&gt;<name>p</name></name> != <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>AP_DEBUG_ASSERT</name><argument_list>(<argument><expr><name><name>ctx</name>-&gt;<name>r</name></name> != <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>AP_DEBUG_ASSERT</name><argument_list>(<argument><expr><name><name>ctx</name>-&gt;<name>c</name></name> != <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>AP_DEBUG_ASSERT</name><argument_list>(<argument><expr><name><name>ctx</name>-&gt;<name>s</name></name> != <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>AP_DEBUG_ASSERT</name><argument_list>(<argument><expr><name><name>ctx</name>-&gt;<name>err</name></name> != <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>AP_DEBUG_ASSERT</name><argument_list>(<argument><expr><name><name>ctx</name>-&gt;<name>info</name></name> != <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>ctx</name>-&gt;<name>re_pmatch</name></name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>AP_DEBUG_ASSERT</name><argument_list>(<argument><expr><name><name>ctx</name>-&gt;<name>re_source</name></name> != <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>AP_DEBUG_ASSERT</name><argument_list>(<argument><expr><name><name>ctx</name>-&gt;<name>re_nmatch</name></name> &gt; 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><name><name>ctx</name>-&gt;<name>reclvl</name></name> = 0</expr>;</expr_stmt>
<expr_stmt><expr>*<name><name>ctx</name>-&gt;<name>err</name></name> = <name>NULL</name></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>ctx</name>-&gt;<name>info</name>-&gt;<name>flags</name></name> &amp; <name>AP_EXPR_FLAG_STRING_RESULT</name></expr>)</condition><then> <block>{
<expr_stmt><expr>*<name><name>ctx</name>-&gt;<name>result_string</name></name> = <call><name>ap_expr_eval_word</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name><name>ctx</name>-&gt;<name>info</name>-&gt;<name>root_node</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>*<name><name>ctx</name>-&gt;<name>err</name></name> != <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>ap_log_rerror</name><argument_list>(<argument><expr><call><name>LOG_MARK</name><argument_list>(<argument><expr><name><name>ctx</name>-&gt;<name>info</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>APLOG_ERR</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name><name>ctx</name>-&gt;<name>r</name></name></expr></argument>,
<argument><expr>"Evaluation of expression from %s:%d failed: %s"</expr></argument>,
<argument><expr><name><name>ctx</name>-&gt;<name>info</name>-&gt;<name>filename</name></name></expr></argument>, <argument><expr><name><name>ctx</name>-&gt;<name>info</name>-&gt;<name>line_number</name></name></expr></argument>, <argument><expr>*<name><name>ctx</name>-&gt;<name>err</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>-1</expr>;</return>
}</block></then> <else>else <block>{
<expr_stmt><expr><call><name>ap_log_rerror</name><argument_list>(<argument><expr><call><name>LOG_MARK</name><argument_list>(<argument><expr><name><name>ctx</name>-&gt;<name>info</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>APLOG_TRACE4</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name><name>ctx</name>-&gt;<name>r</name></name></expr></argument>,
<argument><expr>"Evaluation of string expression from %s:%d gave: %s"</expr></argument>,
<argument><expr><name><name>ctx</name>-&gt;<name>info</name>-&gt;<name>filename</name></name></expr></argument>, <argument><expr><name><name>ctx</name>-&gt;<name>info</name>-&gt;<name>line_number</name></name></expr></argument>,
<argument><expr>*<name><name>ctx</name>-&gt;<name>result_string</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>1</expr>;</return>
}</block></else></if>
}</block></then> <else>else <block>{
<expr_stmt><expr><name>rc</name> = <call><name>ap_expr_eval</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name><name>ctx</name>-&gt;<name>info</name>-&gt;<name>root_node</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>*<name><name>ctx</name>-&gt;<name>err</name></name> != <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>ap_log_rerror</name><argument_list>(<argument><expr><call><name>LOG_MARK</name><argument_list>(<argument><expr><name><name>ctx</name>-&gt;<name>info</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>APLOG_ERR</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name><name>ctx</name>-&gt;<name>r</name></name></expr></argument>,
<argument><expr>"Evaluation of expression from %s:%d failed: %s"</expr></argument>,
<argument><expr><name><name>ctx</name>-&gt;<name>info</name>-&gt;<name>filename</name></name></expr></argument>, <argument><expr><name><name>ctx</name>-&gt;<name>info</name>-&gt;<name>line_number</name></name></expr></argument>, <argument><expr>*<name><name>ctx</name>-&gt;<name>err</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>-1</expr>;</return>
}</block></then> <else>else <block>{
<expr_stmt><expr><name>rc</name> = <name>rc</name> ? 1 : 0</expr>;</expr_stmt>
<expr_stmt><expr><call><name>ap_log_rerror</name><argument_list>(<argument><expr><call><name>LOG_MARK</name><argument_list>(<argument><expr><name><name>ctx</name>-&gt;<name>info</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>APLOG_TRACE4</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name><name>ctx</name>-&gt;<name>r</name></name></expr></argument>,
<argument><expr>"Evaluation of expression from %s:%d gave: %d"</expr></argument>,
<argument><expr><name><name>ctx</name>-&gt;<name>info</name>-&gt;<name>filename</name></name></expr></argument>, <argument><expr><name><name>ctx</name>-&gt;<name>info</name>-&gt;<name>line_number</name></name></expr></argument>, <argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>ctx</name>-&gt;<name>vary_this</name></name> &amp;&amp; *<name><name>ctx</name>-&gt;<name>vary_this</name></name></expr>)</condition><then>
<expr_stmt><expr><call><name>apr_table_merge</name><argument_list>(<argument><expr><name><name>ctx</name>-&gt;<name>r</name>-&gt;<name>headers_out</name></name></expr></argument>, <argument><expr>"Vary"</expr></argument>, <argument><expr>*<name><name>ctx</name>-&gt;<name>vary_this</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<return>return <expr><name>rc</name></expr>;</return>
}</block></else></if>
}</block></else></if>
}</block>
<macro><name>AP_DECLARE</name><argument_list>(<argument>int</argument>)</argument_list></macro> <macro><name>ap_expr_exec_re</name><argument_list>(<argument>request_rec *r</argument>, <argument>const ap_expr_info_t *info</argument>,
<argument>apr_size_t nmatch</argument>, <argument>ap_regmatch_t *pmatch</argument>,
<argument>const char **source</argument>, <argument>const char **err</argument>)</argument_list></macro> <block>{
<decl_stmt><decl><type><name>ap_expr_eval_ctx_t</name></type> <name>ctx</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>dont_vary</name> <init>= <expr>(<name><name>info</name>-&gt;<name>flags</name></name> &amp; <name>AP_EXPR_FLAG_DONT_VARY</name>)</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>tmp_source</name> <init>= <expr><name>NULL</name></expr></init>, *<name>vary_this</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ap_regmatch_t</name></type> <name><name>tmp_pmatch</name><index>[<expr><name>AP_MAX_REG_MATCH</name></expr>]</index></name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>AP_DEBUG_ASSERT</name><argument_list>(<argument><expr>(<name><name>info</name>-&gt;<name>flags</name></name> &amp; <name>AP_EXPR_FLAG_STRING_RESULT</name>) == 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ctx</name>.<name>r</name></name> = <name>r</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ctx</name>.<name>c</name></name> = <name><name>r</name>-&gt;<name>connection</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ctx</name>.<name>s</name></name> = <name><name>r</name>-&gt;<name>server</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ctx</name>.<name>p</name></name> = <name><name>r</name>-&gt;<name>pool</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ctx</name>.<name>err</name></name> = <name>err</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ctx</name>.<name>info</name></name> = <name>info</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ctx</name>.<name>re_nmatch</name></name> = <name>nmatch</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ctx</name>.<name>re_pmatch</name></name> = <name>pmatch</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ctx</name>.<name>re_source</name></name> = <name>source</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ctx</name>.<name>vary_this</name></name> = <name>dont_vary</name> ? <name>NULL</name> : &amp;<name>vary_this</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ctx</name>.<name>data</name></name> = <name>NULL</name></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>pmatch</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>ctx</name>.<name>re_nmatch</name></name> = <name>AP_MAX_REG_MATCH</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ctx</name>.<name>re_pmatch</name></name> = <name>tmp_pmatch</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ctx</name>.<name>re_source</name></name> = &amp;<name>tmp_source</name></expr>;</expr_stmt>
}</block></then></if>
<return>return <expr><call><name>ap_expr_exec_ctx</name><argument_list>(<argument><expr>&amp;<name>ctx</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<macro><name>AP_DECLARE</name><argument_list>(<argument>const char *</argument>)</argument_list></macro> <macro><name>ap_expr_str_exec_re</name><argument_list>(<argument>request_rec *r</argument>,
<argument>const ap_expr_info_t *info</argument>,
<argument>apr_size_t nmatch</argument>,
<argument>ap_regmatch_t *pmatch</argument>,
<argument>const char **source</argument>,
<argument>const char **err</argument>)</argument_list></macro> <block>{
<decl_stmt><decl><type><name>ap_expr_eval_ctx_t</name></type> <name>ctx</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>dont_vary</name></decl>, <decl><type ref="prev"/><name>rc</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>tmp_source</name></decl>, *<decl><type ref="prev"/><name>vary_this</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ap_regmatch_t</name></type> <name><name>tmp_pmatch</name><index>[<expr><name>AP_MAX_REG_MATCH</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>result</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>AP_DEBUG_ASSERT</name><argument_list>(<argument><expr><name><name>info</name>-&gt;<name>flags</name></name> &amp; <name>AP_EXPR_FLAG_STRING_RESULT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>info</name>-&gt;<name>root_node</name>-&gt;<name>node_op</name></name> == <name>op_String</name></expr>)</condition><then> <block>{
<expr_stmt><expr>*<name>err</name> = <name>NULL</name></expr>;</expr_stmt>
<return>return <expr>(const <name>char</name> *)<name><name>info</name>-&gt;<name>root_node</name>-&gt;<name>node_arg1</name></name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>tmp_source</name> = <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name>vary_this</name> = <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name>dont_vary</name> = (<name><name>info</name>-&gt;<name>flags</name></name> &amp; <name>AP_EXPR_FLAG_DONT_VARY</name>)</expr>;</expr_stmt>
<expr_stmt><expr><name><name>ctx</name>.<name>r</name></name> = <name>r</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ctx</name>.<name>c</name></name> = <name><name>r</name>-&gt;<name>connection</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ctx</name>.<name>s</name></name> = <name><name>r</name>-&gt;<name>server</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ctx</name>.<name>p</name></name> = <name><name>r</name>-&gt;<name>pool</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ctx</name>.<name>err</name></name> = <name>err</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ctx</name>.<name>info</name></name> = <name>info</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ctx</name>.<name>re_nmatch</name></name> = <name>nmatch</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ctx</name>.<name>re_pmatch</name></name> = <name>pmatch</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ctx</name>.<name>re_source</name></name> = <name>source</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ctx</name>.<name>vary_this</name></name> = <name>dont_vary</name> ? <name>NULL</name> : &amp;<name>vary_this</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ctx</name>.<name>data</name></name> = <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ctx</name>.<name>result_string</name></name> = &amp;<name>result</name></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>pmatch</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>ctx</name>.<name>re_nmatch</name></name> = <name>AP_MAX_REG_MATCH</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ctx</name>.<name>re_pmatch</name></name> = <name>tmp_pmatch</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ctx</name>.<name>re_source</name></name> = &amp;<name>tmp_source</name></expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><name>rc</name> = <call><name>ap_expr_exec_ctx</name><argument_list>(<argument><expr>&amp;<name>ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>rc</name> &gt; 0</expr>)</condition><then>
<return>return <expr><name>result</name></expr>;</return></then>
<else>else <if>if <condition>(<expr><name>rc</name> &lt; 0</expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then>
<else>else
<expr_stmt><expr><call><name>ap_assert</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if></else></if>
<return>return <expr><name>NULL</name></expr>;</return>
}</block>
<macro><name>AP_DECLARE</name><argument_list>(<argument>const char *</argument>)</argument_list></macro> <macro><name>ap_expr_str_exec</name><argument_list>(<argument>request_rec *r</argument>,
<argument>const ap_expr_info_t *info</argument>,
<argument>const char **err</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name>ap_expr_str_exec_re</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>info</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<function><type><specifier>static</specifier> <name>void</name></type> <name>add_vary</name><parameter_list>(<param><decl><type><name>ap_expr_eval_ctx_t</name> *</type><name>ctx</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>name</name></decl></param>)</parameter_list> <block>{
<if>if <condition>(<expr>!<name><name>ctx</name>-&gt;<name>vary_this</name></name></expr>)</condition><then>
<return>return;</return></then></if>
<if>if <condition>(<expr>*<name><name>ctx</name>-&gt;<name>vary_this</name></name></expr>)</condition><then> <block>{
<expr_stmt><expr>*<name><name>ctx</name>-&gt;<name>vary_this</name></name> = <call><name>apr_pstrcat</name><argument_list>(<argument><expr><name><name>ctx</name>-&gt;<name>p</name></name></expr></argument>, <argument><expr>*<name><name>ctx</name>-&gt;<name>vary_this</name></name></expr></argument>, <argument><expr>", "</expr></argument>, <argument><expr><name>name</name></expr></argument>,
<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr>*<name><name>ctx</name>-&gt;<name>vary_this</name></name> = <name>name</name></expr>;</expr_stmt>
}</block></else></if>
}</block></function>
<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> *</type><name>req_table_func</name><parameter_list>(<param><decl><type><name>ap_expr_eval_ctx_t</name> *</type><name>ctx</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>void</name> *</type><name>data</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>arg</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>name</name> <init>= <expr>(const <name>char</name> *)<name>data</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>apr_table_t</name> *</type><name>t</name></decl>;</decl_stmt>
<if>if <condition>(<expr>!<name><name>ctx</name>-&gt;<name>r</name></name></expr>)</condition><then>
<return>return <expr>""</expr>;</return></then></if>
<if>if <condition>(<expr><name><name>name</name><index>[<expr>2</expr>]</index></name> == 's'</expr>)</condition><then> <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>v</name> <init>= <expr><call><name>apr_table_get</name><argument_list>(<argument><expr><name><name>ctx</name>-&gt;<name>r</name>-&gt;<name>headers_out</name></name></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>v</name></expr>)</condition><then> <block>{
<return>return <expr><name>v</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>t</name> = <name><name>ctx</name>-&gt;<name>r</name>-&gt;<name>err_headers_out</name></name></expr>;</expr_stmt>
}</block></then> <else>else <if>if <condition>(<expr><name><name>name</name><index>[<expr>0</expr>]</index></name> == 'n'</expr>)</condition><then>
<expr_stmt><expr><name>t</name> = <name><name>ctx</name>-&gt;<name>r</name>-&gt;<name>notes</name></name></expr>;</expr_stmt></then>
<else>else <if>if <condition>(<expr><name><name>name</name><index>[<expr>3</expr>]</index></name> == 'e'</expr>)</condition><then>
<expr_stmt><expr><name>t</name> = <name><name>ctx</name>-&gt;<name>r</name>-&gt;<name>subprocess_env</name></name></expr>;</expr_stmt></then>
<else>else <if>if <condition>(<expr><name><name>name</name><index>[<expr>3</expr>]</index></name> == '_'</expr>)</condition><then>
<expr_stmt><expr><name>t</name> = <name><name>ctx</name>-&gt;<name>r</name>-&gt;<name>headers_in</name></name></expr>;</expr_stmt></then>
<else>else <block>{
<expr_stmt><expr><name>t</name> = <name><name>ctx</name>-&gt;<name>r</name>-&gt;<name>headers_in</name></name></expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>strcasecmp</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr>"Host"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>add_vary</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
}</block></else></if></else></if></else></if></else></if>
<return>return <expr><call><name>apr_table_get</name><argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> *</type><name>env_func</name><parameter_list>(<param><decl><type><name>ap_expr_eval_ctx_t</name> *</type><name>ctx</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>void</name> *</type><name>data</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>arg</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>res</name></decl>;</decl_stmt>
<if>if <condition>(<expr><name><name>ctx</name>-&gt;<name>r</name></name></expr>)</condition><then> <block>{
<if>if <condition>(<expr>(<name>res</name> = <call><name>apr_table_get</name><argument_list>(<argument><expr><name><name>ctx</name>-&gt;<name>r</name>-&gt;<name>notes</name></name></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call>) != <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>res</name></expr>;</return></then>
<else>else <if>if <condition>(<expr>(<name>res</name> = <call><name>apr_table_get</name><argument_list>(<argument><expr><name><name>ctx</name>-&gt;<name>r</name>-&gt;<name>subprocess_env</name></name></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call>) != <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>res</name></expr>;</return></then></if></else></if>
}</block></then></if>
<return>return <expr><call><name>getenv</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> *</type><name>osenv_func</name><parameter_list>(<param><decl><type><name>ap_expr_eval_ctx_t</name> *</type><name>ctx</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>void</name> *</type><name>data</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>arg</name></decl></param>)</parameter_list> <block>{
<return>return <expr><call><name>getenv</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> *</type><name>tolower_func</name><parameter_list>(<param><decl><type><name>ap_expr_eval_ctx_t</name> *</type><name>ctx</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>void</name> *</type><name>data</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>arg</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>char</name> *</type><name>result</name> <init>= <expr><call><name>apr_pstrdup</name><argument_list>(<argument><expr><name><name>ctx</name>-&gt;<name>p</name></name></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>ap_str_tolower</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>result</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> *</type><name>toupper_func</name><parameter_list>(<param><decl><type><name>ap_expr_eval_ctx_t</name> *</type><name>ctx</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>void</name> *</type><name>data</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>arg</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>char</name> *</type><name>result</name> <init>= <expr><call><name>apr_pstrdup</name><argument_list>(<argument><expr><name><name>ctx</name>-&gt;<name>p</name></name></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>ap_str_toupper</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>result</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> *</type><name>escape_func</name><parameter_list>(<param><decl><type><name>ap_expr_eval_ctx_t</name> *</type><name>ctx</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>void</name> *</type><name>data</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>arg</name></decl></param>)</parameter_list> <block>{
<return>return <expr><call><name>ap_escape_uri</name><argument_list>(<argument><expr><name><name>ctx</name>-&gt;<name>p</name></name></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> *</type><name>base64_func</name><parameter_list>(<param><decl><type><name>ap_expr_eval_ctx_t</name> *</type><name>ctx</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>void</name> *</type><name>data</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>arg</name></decl></param>)</parameter_list> <block>{
<return>return <expr><call><name>ap_pbase64encode</name><argument_list>(<argument><expr><name><name>ctx</name>-&gt;<name>p</name></name></expr></argument>, <argument><expr>(<name>char</name> *)<name>arg</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> *</type><name>unbase64_func</name><parameter_list>(<param><decl><type><name>ap_expr_eval_ctx_t</name> *</type><name>ctx</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>void</name> *</type><name>data</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>arg</name></decl></param>)</parameter_list> <block>{
<return>return <expr><call><name>ap_pbase64decode</name><argument_list>(<argument><expr><name><name>ctx</name>-&gt;<name>p</name></name></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> *</type><name>sha1_func</name><parameter_list>(<param><decl><type><name>ap_expr_eval_ctx_t</name> *</type><name>ctx</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>void</name> *</type><name>data</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>arg</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>apr_sha1_ctx_t</name></type> <name>context</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>apr_byte_t</name></type> <name><name>sha1</name><index>[<expr><name>APR_SHA1_DIGESTSIZE</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>out</name></decl>;</decl_stmt>
<expr_stmt><expr><name>out</name> = <call><name>apr_palloc</name><argument_list>(<argument><expr><name><name>ctx</name>-&gt;<name>p</name></name></expr></argument>, <argument><expr><name>APR_SHA1_DIGESTSIZE</name>*2+1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>apr_sha1_init</name><argument_list>(<argument><expr>&amp;<name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>apr_sha1_update</name><argument_list>(<argument><expr>&amp;<name>context</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>apr_sha1_final</name><argument_list>(<argument><expr><name>sha1</name></expr></argument>, <argument><expr>&amp;<name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ap_bin2hex</name><argument_list>(<argument><expr><name>sha1</name></expr></argument>, <argument><expr><name>APR_SHA1_DIGESTSIZE</name></expr></argument>, <argument><expr><name>out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>out</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> *</type><name>md5_func</name><parameter_list>(<param><decl><type><name>ap_expr_eval_ctx_t</name> *</type><name>ctx</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>void</name> *</type><name>data</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>arg</name></decl></param>)</parameter_list> <block>{
<return>return <expr><call><name>ap_md5</name><argument_list>(<argument><expr><name><name>ctx</name>-&gt;<name>p</name></name></expr></argument>, <argument><expr>(const <name>unsigned</name> <name>char</name> *)<name>arg</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAX_FILE_SIZE</name></cpp:macro> <cpp:value>10*1024*1024</cpp:value></cpp:define>
<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> *</type><name>file_func</name><parameter_list>(<param><decl><type><name>ap_expr_eval_ctx_t</name> *</type><name>ctx</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>void</name> *</type><name>data</name></decl></param>,
<param><decl><type><name>char</name> *</type><name>arg</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>apr_file_t</name> *</type><name>fp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>buf</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>apr_off_t</name></type> <name>offset</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>apr_size_t</name></type> <name>len</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>apr_finfo_t</name></type> <name>finfo</name></decl>;</decl_stmt>
<if>if <condition>(<expr><call><name>apr_file_open</name><argument_list>(<argument><expr>&amp;<name>fp</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>, <argument><expr><name>APR_READ</name>|<name>APR_BUFFERED</name></expr></argument>,
<argument><expr><name>APR_OS_DEFAULT</name></expr></argument>, <argument><expr><name><name>ctx</name>-&gt;<name>p</name></name></expr></argument>)</argument_list></call> != <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
<expr_stmt><expr>*<name><name>ctx</name>-&gt;<name>err</name></name> = <call><name>apr_psprintf</name><argument_list>(<argument><expr><name><name>ctx</name>-&gt;<name>p</name></name></expr></argument>, <argument><expr>"Cannot open file %s"</expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>""</expr>;</return>
}</block></then></if>
<expr_stmt><expr><call><name>apr_file_info_get</name><argument_list>(<argument><expr>&amp;<name>finfo</name></expr></argument>, <argument><expr><name>APR_FINFO_SIZE</name></expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>finfo</name>.<name>size</name></name> &gt; <name>MAX_FILE_SIZE</name></expr>)</condition><then> <block>{
<expr_stmt><expr>*<name><name>ctx</name>-&gt;<name>err</name></name> = <call><name>apr_psprintf</name><argument_list>(<argument><expr><name><name>ctx</name>-&gt;<name>p</name></name></expr></argument>, <argument><expr>"File %s too large"</expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>apr_file_close</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>""</expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>len</name> = (<name>apr_size_t</name>)<name><name>finfo</name>.<name>size</name></name></expr>;</expr_stmt>
<if>if <condition>(<expr><name>len</name> == 0</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>apr_file_close</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>""</expr>;</return>
}</block></then> <else>else <block>{
<if>if <condition>(<expr>(<name>buf</name> = (<name>char</name> *)<call><name>apr_palloc</name><argument_list>(<argument><expr><name><name>ctx</name>-&gt;<name>p</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>char</name></expr></argument>)</argument_list></sizeof>*(<name>len</name>+1)</expr></argument>)</argument_list></call>) == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr>*<name><name>ctx</name>-&gt;<name>err</name></name> = "Cannot allocate memory"</expr>;</expr_stmt>
<expr_stmt><expr><call><name>apr_file_close</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>""</expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>offset</name> = 0</expr>;</expr_stmt>
<expr_stmt><expr><call><name>apr_file_seek</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><name>APR_SET</name></expr></argument>, <argument><expr>&amp;<name>offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>apr_file_read</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr>&amp;<name>len</name></expr></argument>)</argument_list></call> != <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
<expr_stmt><expr>*<name><name>ctx</name>-&gt;<name>err</name></name> = <call><name>apr_psprintf</name><argument_list>(<argument><expr><name><name>ctx</name>-&gt;<name>p</name></name></expr></argument>, <argument><expr>"Cannot read from file %s"</expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>apr_file_close</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>""</expr>;</return>
}</block></then></if>
<expr_stmt><expr><name><name>buf</name><index>[<expr><name>len</name></expr>]</index></name> = '\0'</expr>;</expr_stmt>
}</block></else></if>
<expr_stmt><expr><call><name>apr_file_close</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>buf</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> *</type><name>filesize_func</name><parameter_list>(<param><decl><type><name>ap_expr_eval_ctx_t</name> *</type><name>ctx</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>void</name> *</type><name>data</name></decl></param>,
<param><decl><type><name>char</name> *</type><name>arg</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>apr_finfo_t</name></type> <name>sb</name></decl>;</decl_stmt>
<if>if <condition>(<expr><call><name>apr_stat</name><argument_list>(<argument><expr>&amp;<name>sb</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>, <argument><expr><name>APR_FINFO_MIN</name></expr></argument>, <argument><expr><name><name>ctx</name>-&gt;<name>p</name></name></expr></argument>)</argument_list></call> == <name>APR_SUCCESS</name>
&amp;&amp; <name><name>sb</name>.<name>filetype</name></name> == <name>APR_REG</name> &amp;&amp; <name><name>sb</name>.<name>size</name></name> &gt; 0</expr>)</condition><then>
<return>return <expr><call><name>apr_psprintf</name><argument_list>(<argument><expr><name><name>ctx</name>-&gt;<name>p</name></name></expr></argument>, <argument><expr>"%" <name>APR_OFF_T_FMT</name></expr></argument>, <argument><expr><name><name>sb</name>.<name>size</name></name></expr></argument>)</argument_list></call></expr>;</return></then>
<else>else
<return>return <expr>"0"</expr>;</return></else></if>
}</block></function>
<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> *</type><name>unescape_func</name><parameter_list>(<param><decl><type><name>ap_expr_eval_ctx_t</name> *</type><name>ctx</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>void</name> *</type><name>data</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>arg</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>char</name> *</type><name>result</name> <init>= <expr><call><name>apr_pstrdup</name><argument_list>(<argument><expr><name><name>ctx</name>-&gt;<name>p</name></name></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>ret</name> <init>= <expr><call><name>ap_unescape_url_keep2f</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>ret</name> == <name>OK</name></expr>)</condition><then>
<return>return <expr><name>result</name></expr>;</return></then></if>
<expr_stmt><expr><call><name>ap_log_rerror</name><argument_list>(<argument><expr><call><name>LOG_MARK</name><argument_list>(<argument><expr><name><name>ctx</name>-&gt;<name>info</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>APLOG_DEBUG</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name><name>ctx</name>-&gt;<name>r</name></name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00538</expr></argument>)</argument_list></call>
"%s %% escape in unescape('%s') at %s:%d"</expr></argument>,
<argument><expr><name>ret</name> == <name>HTTP_BAD_REQUEST</name> ? "Bad" : "Forbidden"</expr></argument>, <argument><expr><name>arg</name></expr></argument>,
<argument><expr><name><name>ctx</name>-&gt;<name>info</name>-&gt;<name>filename</name></name></expr></argument>, <argument><expr><name><name>ctx</name>-&gt;<name>info</name>-&gt;<name>line_number</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>""</expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>op_nz</name><parameter_list>(<param><decl><type><name>ap_expr_eval_ctx_t</name> *</type><name>ctx</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>void</name> *</type><name>data</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>arg</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>name</name> <init>= <expr>(const <name>char</name> *)<name>data</name></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name><name>name</name><index>[<expr>0</expr>]</index></name> == 'z'</expr>)</condition><then>
<return>return <expr>(<name><name>arg</name><index>[<expr>0</expr>]</index></name> == '\0')</expr>;</return></then>
<else>else
<return>return <expr>(<name><name>arg</name><index>[<expr>0</expr>]</index></name> != '\0')</expr>;</return></else></if>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>op_file_min</name><parameter_list>(<param><decl><type><name>ap_expr_eval_ctx_t</name> *</type><name>ctx</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>void</name> *</type><name>data</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>arg</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>apr_finfo_t</name></type> <name>sb</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>name</name> <init>= <expr>(const <name>char</name> *)<name>data</name></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><call><name>apr_stat</name><argument_list>(<argument><expr>&amp;<name>sb</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>, <argument><expr><name>APR_FINFO_MIN</name></expr></argument>, <argument><expr><name><name>ctx</name>-&gt;<name>p</name></name></expr></argument>)</argument_list></call> != <name>APR_SUCCESS</name></expr>)</condition><then>
<return>return <expr><name>FALSE</name></expr>;</return></then></if>
<switch>switch <condition>(<expr><name><name>name</name><index>[<expr>0</expr>]</index></name></expr>)</condition> <block>{
<case>case <expr>'d'</expr>:
<return>return <expr>(<name><name>sb</name>.<name>filetype</name></name> == <name>APR_DIR</name>)</expr>;</return>
</case><case>case <expr>'e'</expr>:
<return>return <expr><name>TRUE</name></expr>;</return>
</case><case>case <expr>'f'</expr>:
<return>return <expr>(<name><name>sb</name>.<name>filetype</name></name> == <name>APR_REG</name>)</expr>;</return>
</case><case>case <expr>'s'</expr>:
<return>return <expr>(<name><name>sb</name>.<name>filetype</name></name> == <name>APR_REG</name> &amp;&amp; <name><name>sb</name>.<name>size</name></name> &gt; 0)</expr>;</return>
</case><default>default:
<expr_stmt><expr><call><name>ap_assert</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
</default>}</block></switch>
<return>return <expr><name>FALSE</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>op_file_link</name><parameter_list>(<param><decl><type><name>ap_expr_eval_ctx_t</name> *</type><name>ctx</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>void</name> *</type><name>data</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>arg</name></decl></param>)</parameter_list> <block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>OS2</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>apr_finfo_t</name></type> <name>sb</name></decl>;</decl_stmt>
<if>if <condition>(<expr><call><name>apr_stat</name><argument_list>(<argument><expr>&amp;<name>sb</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>, <argument><expr><name>APR_FINFO_MIN</name> | <name>APR_FINFO_LINK</name></expr></argument>, <argument><expr><name><name>ctx</name>-&gt;<name>p</name></name></expr></argument>)</argument_list></call> == <name>APR_SUCCESS</name>
&amp;&amp; <name><name>sb</name>.<name>filetype</name></name> == <name>APR_LNK</name></expr>)</condition><then> <block>{
<return>return <expr><name>TRUE</name></expr>;</return>
}</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<return>return <expr><name>FALSE</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>op_file_xbit</name><parameter_list>(<param><decl><type><name>ap_expr_eval_ctx_t</name> *</type><name>ctx</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>void</name> *</type><name>data</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>arg</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>apr_finfo_t</name></type> <name>sb</name></decl>;</decl_stmt>
<if>if <condition>(<expr><call><name>apr_stat</name><argument_list>(<argument><expr>&amp;<name>sb</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>, <argument><expr><name>APR_FINFO_PROT</name>| <name>APR_FINFO_LINK</name></expr></argument>, <argument><expr><name><name>ctx</name>-&gt;<name>p</name></name></expr></argument>)</argument_list></call> == <name>APR_SUCCESS</name>
&amp;&amp; (<name><name>sb</name>.<name>protection</name></name> &amp; (<name>APR_UEXECUTE</name> | <name>APR_GEXECUTE</name> | <name>APR_WEXECUTE</name>))</expr>)</condition><then> <block>{
<return>return <expr><name>TRUE</name></expr>;</return>
}</block></then></if>
<return>return <expr><name>FALSE</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>op_url_subr</name><parameter_list>(<param><decl><type><name>ap_expr_eval_ctx_t</name> *</type><name>ctx</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>void</name> *</type><name>data</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>arg</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>FALSE</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>request_rec</name> *</type><name>rsub</name></decl>, *<decl><type ref="prev"/><name>r</name> <init>= <expr><name><name>ctx</name>-&gt;<name>r</name></name></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr>!<name>r</name></expr>)</condition><then>
<return>return <expr><name>FALSE</name></expr>;</return></then></if>
<if>if <condition>(<expr><name><name>r</name>-&gt;<name/></name>main &amp;&amp; <name><name>r</name>-&gt;<name/></name>main-&gt;<name>uri</name> &amp;&amp; <name><name>r</name>-&gt;<name>uri</name></name> &amp;&amp; <call><name>strcmp</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name/></name>main-&gt;<name>uri</name></expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>uri</name></name></expr></argument>)</argument_list></call> == 0</expr>)</condition><then>
<return>return <expr><name>FALSE</name></expr>;</return></then></if>
<expr_stmt><expr><name>rsub</name> = <call><name>ap_sub_req_lookup_uri</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>rsub</name>-&gt;<name>status</name></name> &lt; 400</expr>)</condition><then> <block>{
<expr_stmt><expr><name>rc</name> = <name>TRUE</name></expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><call><name>ap_log_rerror</name><argument_list>(<argument><expr><call><name>LOG_MARK</name><argument_list>(<argument><expr><name><name>ctx</name>-&gt;<name>info</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>APLOG_TRACE5</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>r</name></expr></argument>,
<argument><expr>"Subrequest for -U %s at %s:%d gave status: %d"</expr></argument>,
<argument><expr><name>arg</name></expr></argument>, <argument><expr><name><name>ctx</name>-&gt;<name>info</name>-&gt;<name>filename</name></name></expr></argument>, <argument><expr><name><name>ctx</name>-&gt;<name>info</name>-&gt;<name>line_number</name></name></expr></argument>,
<argument><expr><name><name>rsub</name>-&gt;<name>status</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ap_destroy_sub_req</name><argument_list>(<argument><expr><name>rsub</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>rc</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>op_file_subr</name><parameter_list>(<param><decl><type><name>ap_expr_eval_ctx_t</name> *</type><name>ctx</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>void</name> *</type><name>data</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>arg</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>FALSE</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>apr_finfo_t</name></type> <name>sb</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>request_rec</name> *</type><name>rsub</name></decl>, *<decl><type ref="prev"/><name>r</name> <init>= <expr><name><name>ctx</name>-&gt;<name>r</name></name></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr>!<name>r</name></expr>)</condition><then>
<return>return <expr><name>FALSE</name></expr>;</return></then></if>
<expr_stmt><expr><name>rsub</name> = <call><name>ap_sub_req_lookup_file</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>rsub</name>-&gt;<name>status</name></name> &lt; 300 &amp;&amp;
<call><name>apr_stat</name><argument_list>(<argument><expr>&amp;<name>sb</name></expr></argument>, <argument><expr><name><name>rsub</name>-&gt;<name>filename</name></name></expr></argument>, <argument><expr><name>APR_FINFO_MIN</name></expr></argument>, <argument><expr><name><name>ctx</name>-&gt;<name>p</name></name></expr></argument>)</argument_list></call> == <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>rc</name> = <name>TRUE</name></expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><call><name>ap_log_rerror</name><argument_list>(<argument><expr><call><name>LOG_MARK</name><argument_list>(<argument><expr><name><name>ctx</name>-&gt;<name>info</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>APLOG_TRACE5</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>r</name></expr></argument>,
<argument><expr>"Subrequest for -F %s at %s:%d gave status: %d"</expr></argument>,
<argument><expr><name>arg</name></expr></argument>, <argument><expr><name><name>ctx</name>-&gt;<name>info</name>-&gt;<name>filename</name></name></expr></argument>, <argument><expr><name><name>ctx</name>-&gt;<name>info</name>-&gt;<name>line_number</name></name></expr></argument>,
<argument><expr><name><name>rsub</name>-&gt;<name>status</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ap_destroy_sub_req</name><argument_list>(<argument><expr><name>rsub</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>rc</name></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>APR_DECLARE_OPTIONAL_FN</name><argument_list>(<argument><expr><name>int</name></expr></argument>, <argument><expr><name>ssl_is_https</name></expr></argument>, <argument><expr>(<name>conn_rec</name> *)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr>static <call><name>APR_OPTIONAL_FN_TYPE</name><argument_list>(<argument><expr><name>ssl_is_https</name></expr></argument>)</argument_list></call> *<name>is_https</name> = <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>APR_DECLARE_OPTIONAL_FN</name><argument_list>(<argument><expr><name>int</name></expr></argument>, <argument><expr><name>http2_is_h2</name></expr></argument>, <argument><expr>(<name>conn_rec</name> *)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr>static <call><name>APR_OPTIONAL_FN_TYPE</name><argument_list>(<argument><expr><name>http2_is_h2</name></expr></argument>)</argument_list></call> *<name>is_http2</name> = <name>NULL</name></expr>;</expr_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> *</type><name><name>conn_var_names</name><index>[]</index></name> <init>= <expr><block>{
<expr>"HTTPS"</expr>,
<expr>"IPV6"</expr>,
<expr>"CONN_LOG_ID"</expr>,
<expr>"CONN_REMOTE_ADDR"</expr>,
<expr>"HTTP2"</expr>,
<expr><name>NULL</name></expr>
}</block></expr></init></decl>;</decl_stmt>
<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> *</type><name>conn_var_fn</name><parameter_list>(<param><decl><type><name>ap_expr_eval_ctx_t</name> *</type><name>ctx</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>void</name> *</type><name>data</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>index</name> <init>= <expr>((const <name>char</name> **)<name>data</name> - <name>conn_var_names</name>)</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>conn_rec</name> *</type><name>c</name> <init>= <expr><name><name>ctx</name>-&gt;<name>c</name></name></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr>!<name>c</name></expr>)</condition><then>
<return>return <expr>""</expr>;</return></then></if>
<switch>switch <condition>(<expr><name>index</name></expr>)</condition> <block>{
<case>case <expr>0</expr>:
<if>if <condition>(<expr><name>is_https</name> &amp;&amp; <call><name>is_https</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr>"on"</expr>;</return></then>
<else>else
<return>return <expr>"off"</expr>;</return></else></if>
</case><case>case <expr>1</expr>:
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>APR_HAVE_IPV6</name></expr></cpp:if>
<block>{
<decl_stmt><decl><type><name>apr_sockaddr_t</name> *</type><name>addr</name> <init>= <expr><name><name>c</name>-&gt;<name>client_addr</name></name></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name><name>addr</name>-&gt;<name>family</name></name> == <name>AF_INET6</name>
&amp;&amp; !<call><name>IN6_IS_ADDR_V4MAPPED</name><argument_list>(<argument><expr>(struct <name>in6_addr</name> *)<name><name>addr</name>-&gt;<name>ipaddr_ptr</name></name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr>"on"</expr>;</return></then>
<else>else
<return>return <expr>"off"</expr>;</return></else></if>
}</block>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<return>return <expr>"off"</expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</case><case>case <expr>2</expr>:
<return>return <expr><name><name>c</name>-&gt;<name>log_id</name></name></expr>;</return>
</case><case>case <expr>3</expr>:
<return>return <expr><name><name>c</name>-&gt;<name>client_ip</name></name></expr>;</return>
</case><case>case <expr>4</expr>:
<if>if <condition>(<expr><name>is_http2</name> &amp;&amp; <call><name>is_http2</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr>"on"</expr>;</return></then>
<else>else
<return>return <expr>"off"</expr>;</return></else></if>
</case><default>default:
<expr_stmt><expr><call><name>ap_assert</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
</default>}</block></switch>
}</block></function>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> *</type><name><name>request_var_names</name><index>[]</index></name> <init>= <expr><block>{
<expr>"REQUEST_METHOD"</expr>,
<expr>"REQUEST_SCHEME"</expr>,
<expr>"REQUEST_URI"</expr>,
<expr>"REQUEST_FILENAME"</expr>,
<expr>"REMOTE_HOST"</expr>,
<expr>"REMOTE_IDENT"</expr>,
<expr>"REMOTE_USER"</expr>,
<expr>"SERVER_ADMIN"</expr>,
<expr>"SERVER_NAME"</expr>,
<expr>"SERVER_PORT"</expr>,
<expr>"SERVER_PROTOCOL"</expr>,
<expr>"SCRIPT_FILENAME"</expr>,
<expr>"PATH_INFO"</expr>,
<expr>"QUERY_STRING"</expr>,
<expr>"IS_SUBREQ"</expr>,
<expr>"DOCUMENT_ROOT"</expr>,
<expr>"AUTH_TYPE"</expr>,
<expr>"THE_REQUEST"</expr>,
<expr>"CONTENT_TYPE"</expr>,
<expr>"HANDLER"</expr>,
<expr>"REQUEST_LOG_ID"</expr>,
<expr>"SCRIPT_USER"</expr>,
<expr>"SCRIPT_GROUP"</expr>,
<expr>"DOCUMENT_URI"</expr>,
<expr>"LAST_MODIFIED"</expr>,
<expr>"CONTEXT_PREFIX"</expr>,
<expr>"CONTEXT_DOCUMENT_ROOT"</expr>,
<expr>"REQUEST_STATUS"</expr>,
<expr>"REMOTE_ADDR"</expr>,
<expr>"REMOTE_PORT"</expr>,
<expr><name>NULL</name></expr>
}</block></expr></init></decl>;</decl_stmt>
<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> *</type><name>request_var_fn</name><parameter_list>(<param><decl><type><name>ap_expr_eval_ctx_t</name> *</type><name>ctx</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>void</name> *</type><name>data</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>index</name> <init>= <expr>((const <name>char</name> **)<name>data</name> - <name>request_var_names</name>)</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>request_rec</name> *</type><name>r</name> <init>= <expr><name><name>ctx</name>-&gt;<name>r</name></name></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr>!<name>r</name></expr>)</condition><then>
<return>return <expr>""</expr>;</return></then></if>
<switch>switch <condition>(<expr><name>index</name></expr>)</condition> <block>{
<case>case <expr>0</expr>:
<return>return <expr><name><name>r</name>-&gt;<name>method</name></name></expr>;</return>
</case><case>case <expr>1</expr>:
<return>return <expr><call><name>ap_http_scheme</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</return>
</case><case>case <expr>2</expr>:
<return>return <expr><name><name>r</name>-&gt;<name>uri</name></name></expr>;</return>
</case><case>case <expr>3</expr>:
<return>return <expr><name><name>r</name>-&gt;<name>filename</name></name></expr>;</return>
</case><case>case <expr>4</expr>:
<return>return <expr><call><name>ap_get_useragent_host</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>REMOTE_NAME</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
</case><case>case <expr>5</expr>:
<return>return <expr><call><name>ap_get_remote_logname</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</return>
</case><case>case <expr>6</expr>:
<return>return <expr><name><name>r</name>-&gt;<name>user</name></name></expr>;</return>
</case><case>case <expr>7</expr>:
<return>return <expr><name><name>r</name>-&gt;<name>server</name>-&gt;<name>server_admin</name></name></expr>;</return>
</case><case>case <expr>8</expr>:
<return>return <expr><call><name>ap_get_server_name_for_url</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</return>
</case><case>case <expr>9</expr>:
<return>return <expr><call><name>apr_psprintf</name><argument_list>(<argument><expr><name><name>ctx</name>-&gt;<name>p</name></name></expr></argument>, <argument><expr>"%u"</expr></argument>, <argument><expr><call><name>ap_get_server_port</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</case><case>case <expr>10</expr>:
<return>return <expr><name><name>r</name>-&gt;<name>protocol</name></name></expr>;</return>
</case><case>case <expr>11</expr>:
<return>return <expr><name><name>r</name>-&gt;<name>filename</name></name></expr>;</return>
</case><case>case <expr>12</expr>:
<return>return <expr><name><name>r</name>-&gt;<name>path_info</name></name></expr>;</return>
</case><case>case <expr>13</expr>:
<return>return <expr><name><name>r</name>-&gt;<name>args</name></name></expr>;</return>
</case><case>case <expr>14</expr>:
<return>return <expr>(<name><name>r</name>-&gt;<name/></name>main != <name>NULL</name> ? "true" : "false")</expr>;</return>
</case><case>case <expr>15</expr>:
<return>return <expr><call><name>ap_document_root</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</return>
</case><case>case <expr>16</expr>:
<return>return <expr><name><name>r</name>-&gt;<name>ap_auth_type</name></name></expr>;</return>
</case><case>case <expr>17</expr>:
<return>return <expr><name><name>r</name>-&gt;<name>the_request</name></name></expr>;</return>
</case><case>case <expr>18</expr>:
<return>return <expr><name><name>r</name>-&gt;<name>content_type</name></name></expr>;</return>
</case><case>case <expr>19</expr>:
<return>return <expr><name><name>r</name>-&gt;<name>handler</name></name></expr>;</return>
</case><case>case <expr>20</expr>:
<return>return <expr><name><name>r</name>-&gt;<name>log_id</name></name></expr>;</return>
</case><case>case <expr>21</expr>: <block>{
<decl_stmt><decl><type><name>char</name> *</type><name>result</name> <init>= <expr>""</expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name><name>r</name>-&gt;<name>finfo</name>.<name>valid</name></name> &amp; <name>APR_FINFO_USER</name></expr>)</condition><then>
<expr_stmt><expr><call><name>apr_uid_name_get</name><argument_list>(<argument><expr>&amp;<name>result</name></expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>finfo</name>.<name>user</name></name></expr></argument>, <argument><expr><name><name>ctx</name>-&gt;<name>p</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<return>return <expr><name>result</name></expr>;</return>
}</block>
</case><case>case <expr>22</expr>: <block>{
<decl_stmt><decl><type><name>char</name> *</type><name>result</name> <init>= <expr>""</expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name><name>r</name>-&gt;<name>finfo</name>.<name>valid</name></name> &amp; <name>APR_FINFO_USER</name></expr>)</condition><then>
<expr_stmt><expr><call><name>apr_gid_name_get</name><argument_list>(<argument><expr>&amp;<name>result</name></expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>finfo</name>.<name>group</name></name></expr></argument>, <argument><expr><name><name>ctx</name>-&gt;<name>p</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<return>return <expr><name>result</name></expr>;</return>
}</block>
</case><case>case <expr>23</expr>: <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>uri</name> <init>= <expr><call><name>apr_table_get</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>subprocess_env</name></name></expr></argument>, <argument><expr>"DOCUMENT_URI"</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<return>return <expr><name>uri</name> ? <name>uri</name> : <name><name>r</name>-&gt;<name>uri</name></name></expr>;</return>
}</block>
</case><case>case <expr>24</expr>: <block>{
<decl_stmt><decl><type><name>apr_time_exp_t</name></type> <name>tm</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>apr_time_exp_lt</name><argument_list>(<argument><expr>&amp;<name>tm</name></expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>mtime</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>apr_psprintf</name><argument_list>(<argument><expr><name><name>ctx</name>-&gt;<name>p</name></name></expr></argument>, <argument><expr>"%02d%02d%02d%02d%02d%02d%02d"</expr></argument>,
<argument><expr>(<name><name>tm</name>.<name>tm_year</name></name> / 100) + 19</expr></argument>, <argument><expr>(<name><name>tm</name>.<name>tm_year</name></name> % 100)</expr></argument>,
<argument><expr><name><name>tm</name>.<name>tm_mon</name></name>+1</expr></argument>, <argument><expr><name><name>tm</name>.<name>tm_mday</name></name></expr></argument>, <argument><expr><name><name>tm</name>.<name>tm_hour</name></name></expr></argument>, <argument><expr><name><name>tm</name>.<name>tm_min</name></name></expr></argument>,
<argument><expr><name><name>tm</name>.<name>tm_sec</name></name></expr></argument>)</argument_list></call></expr>;</return>
}</block>
</case><case>case <expr>25</expr>:
<return>return <expr><call><name>ap_context_prefix</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</return>
</case><case>case <expr>26</expr>:
<return>return <expr><call><name>ap_context_document_root</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</return>
</case><case>case <expr>27</expr>:
<return>return <expr><name><name>r</name>-&gt;<name>status</name></name> ? <call><name>apr_psprintf</name><argument_list>(<argument><expr><name><name>ctx</name>-&gt;<name>p</name></name></expr></argument>, <argument><expr>"%d"</expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>status</name></name></expr></argument>)</argument_list></call> : ""</expr>;</return>
</case><case>case <expr>28</expr>:
<return>return <expr><name><name>r</name>-&gt;<name>useragent_ip</name></name></expr>;</return>
</case><case>case <expr>29</expr>:
<return>return <expr><call><name>apr_psprintf</name><argument_list>(<argument><expr><name><name>ctx</name>-&gt;<name>p</name></name></expr></argument>, <argument><expr>"%u"</expr></argument>, <argument><expr><name><name>ctx</name>-&gt;<name>c</name>-&gt;<name>client_addr</name>-&gt;<name>port</name></name></expr></argument>)</argument_list></call></expr>;</return>
</case><default>default:
<expr_stmt><expr><call><name>ap_assert</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
</default>}</block></switch>
}</block></function>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> *</type><name><name>req_header_var_names</name><index>[]</index></name> <init>= <expr><block>{
<expr>"HTTP_USER_AGENT"</expr>,
<expr>"HTTP_PROXY_CONNECTION"</expr>,
<expr>"HTTP_REFERER"</expr>,
<expr>"HTTP_COOKIE"</expr>,
<expr>"HTTP_FORWARDED"</expr>,
<expr>"HTTP_HOST"</expr>,
<expr>"HTTP_ACCEPT"</expr>,
<expr><name>NULL</name></expr>
}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> *</type><name><name>req_header_header_names</name><index>[]</index></name> <init>= <expr><block>{
<expr>"User-Agent"</expr>,
<expr>"Proxy-Connection"</expr>,
<expr>"Referer"</expr>,
<expr>"Cookie"</expr>,
<expr>"Forwarded"</expr>,
<expr>"Host"</expr>,
<expr>"Accept"</expr>
}</block></expr></init></decl>;</decl_stmt>
<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> *</type><name>req_header_var_fn</name><parameter_list>(<param><decl><type><name>ap_expr_eval_ctx_t</name> *</type><name>ctx</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>void</name> *</type><name>data</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> **</type><name>varname</name> <init>= <expr>(const <name>char</name> **)<name>data</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>index</name> <init>= <expr>(<name>varname</name> - <name>req_header_var_names</name>)</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>name</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>AP_DEBUG_ASSERT</name><argument_list>(<argument><expr><name>index</name> &lt; 7</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name><name>ctx</name>-&gt;<name>r</name></name></expr>)</condition><then>
<return>return <expr>""</expr>;</return></then></if>
<expr_stmt><expr><name>name</name> = <name><name>req_header_header_names</name><index>[<expr><name>index</name></expr>]</index></name></expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>strcasecmp</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr>"Host"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>add_vary</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<return>return <expr><call><name>apr_table_get</name><argument_list>(<argument><expr><name><name>ctx</name>-&gt;<name>r</name>-&gt;<name>headers_in</name></name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> *</type><name><name>misc_var_names</name><index>[]</index></name> <init>= <expr><block>{
<expr>"TIME_YEAR"</expr>,
<expr>"TIME_MON"</expr>,
<expr>"TIME_DAY"</expr>,
<expr>"TIME_HOUR"</expr>,
<expr>"TIME_MIN"</expr>,
<expr>"TIME_SEC"</expr>,
<expr>"TIME_WDAY"</expr>,
<expr>"TIME"</expr>,
<expr>"SERVER_SOFTWARE"</expr>,
<expr>"API_VERSION"</expr>,
<expr><name>NULL</name></expr>
}</block></expr></init></decl>;</decl_stmt>
<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> *</type><name>misc_var_fn</name><parameter_list>(<param><decl><type><name>ap_expr_eval_ctx_t</name> *</type><name>ctx</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>void</name> *</type><name>data</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>apr_time_exp_t</name></type> <name>tm</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>index</name> <init>= <expr>((const <name>char</name> **)<name>data</name> - <name>misc_var_names</name>)</expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>apr_time_exp_lt</name><argument_list>(<argument><expr>&amp;<name>tm</name></expr></argument>, <argument><expr><call><name>apr_time_now</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<switch>switch <condition>(<expr><name>index</name></expr>)</condition> <block>{
<case>case <expr>0</expr>:
<return>return <expr><call><name>apr_psprintf</name><argument_list>(<argument><expr><name><name>ctx</name>-&gt;<name>p</name></name></expr></argument>, <argument><expr>"%02d%02d"</expr></argument>, <argument><expr>(<name><name>tm</name>.<name>tm_year</name></name> / 100) + 19</expr></argument>,
<argument><expr><name><name>tm</name>.<name>tm_year</name></name> % 100</expr></argument>)</argument_list></call></expr>;</return>
</case><case>case <expr>1</expr>:
<return>return <expr><call><name>apr_psprintf</name><argument_list>(<argument><expr><name><name>ctx</name>-&gt;<name>p</name></name></expr></argument>, <argument><expr>"%02d"</expr></argument>, <argument><expr><name><name>tm</name>.<name>tm_mon</name></name>+1</expr></argument>)</argument_list></call></expr>;</return>
</case><case>case <expr>2</expr>:
<return>return <expr><call><name>apr_psprintf</name><argument_list>(<argument><expr><name><name>ctx</name>-&gt;<name>p</name></name></expr></argument>, <argument><expr>"%02d"</expr></argument>, <argument><expr><name><name>tm</name>.<name>tm_mday</name></name></expr></argument>)</argument_list></call></expr>;</return>
</case><case>case <expr>3</expr>:
<return>return <expr><call><name>apr_psprintf</name><argument_list>(<argument><expr><name><name>ctx</name>-&gt;<name>p</name></name></expr></argument>, <argument><expr>"%02d"</expr></argument>, <argument><expr><name><name>tm</name>.<name>tm_hour</name></name></expr></argument>)</argument_list></call></expr>;</return>
</case><case>case <expr>4</expr>:
<return>return <expr><call><name>apr_psprintf</name><argument_list>(<argument><expr><name><name>ctx</name>-&gt;<name>p</name></name></expr></argument>, <argument><expr>"%02d"</expr></argument>, <argument><expr><name><name>tm</name>.<name>tm_min</name></name></expr></argument>)</argument_list></call></expr>;</return>
</case><case>case <expr>5</expr>:
<return>return <expr><call><name>apr_psprintf</name><argument_list>(<argument><expr><name><name>ctx</name>-&gt;<name>p</name></name></expr></argument>, <argument><expr>"%02d"</expr></argument>, <argument><expr><name><name>tm</name>.<name>tm_sec</name></name></expr></argument>)</argument_list></call></expr>;</return>
</case><case>case <expr>6</expr>:
<return>return <expr><call><name>apr_psprintf</name><argument_list>(<argument><expr><name><name>ctx</name>-&gt;<name>p</name></name></expr></argument>, <argument><expr>"%d"</expr></argument>, <argument><expr><name><name>tm</name>.<name>tm_wday</name></name></expr></argument>)</argument_list></call></expr>;</return>
</case><case>case <expr>7</expr>:
<return>return <expr><call><name>apr_psprintf</name><argument_list>(<argument><expr><name><name>ctx</name>-&gt;<name>p</name></name></expr></argument>, <argument><expr>"%02d%02d%02d%02d%02d%02d%02d"</expr></argument>,
<argument><expr>(<name><name>tm</name>.<name>tm_year</name></name> / 100) + 19</expr></argument>, <argument><expr>(<name><name>tm</name>.<name>tm_year</name></name> % 100)</expr></argument>,
<argument><expr><name><name>tm</name>.<name>tm_mon</name></name>+1</expr></argument>, <argument><expr><name><name>tm</name>.<name>tm_mday</name></name></expr></argument>, <argument><expr><name><name>tm</name>.<name>tm_hour</name></name></expr></argument>, <argument><expr><name><name>tm</name>.<name>tm_min</name></name></expr></argument>,
<argument><expr><name><name>tm</name>.<name>tm_sec</name></name></expr></argument>)</argument_list></call></expr>;</return>
</case><case>case <expr>8</expr>:
<return>return <expr><call><name>ap_get_server_banner</name><argument_list>()</argument_list></call></expr>;</return>
</case><case>case <expr>9</expr>:
<return>return <expr><call><name>apr_itoa</name><argument_list>(<argument><expr><name><name>ctx</name>-&gt;<name>p</name></name></expr></argument>, <argument><expr><name>MODULE_MAGIC_NUMBER_MAJOR</name></expr></argument>)</argument_list></call></expr>;</return>
</case><default>default:
<expr_stmt><expr><call><name>ap_assert</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
</default>}</block></switch>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>subnet_parse_arg</name><parameter_list>(<param><decl><type><name>ap_expr_lookup_parms</name> *</type><name>parms</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>apr_ipsubnet_t</name> *</type><name>subnet</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>addr</name> <init>= <expr><name><name>parms</name>-&gt;<name>arg</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>mask</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>apr_status_t</name></type> <name>ret</name></decl>;</decl_stmt>
<if>if <condition>(<expr>!<name><name>parms</name>-&gt;<name>arg</name></name></expr>)</condition><then> <block>{
<expr_stmt><expr>*<name><name>parms</name>-&gt;<name>err</name></name> = <call><name>apr_psprintf</name><argument_list>(<argument><expr><name><name>parms</name>-&gt;<name>ptemp</name></name></expr></argument>,
<argument><expr>"-%s requires subnet/netmask as constant argument"</expr></argument>,
<argument><expr><name><name>parms</name>-&gt;<name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>!<name>OK</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>mask</name> = <call><name>ap_strchr_c</name><argument_list>(<argument><expr><name>addr</name></expr></argument>, <argument><expr>'/'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>mask</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>addr</name> = <call><name>apr_pstrmemdup</name><argument_list>(<argument><expr><name><name>parms</name>-&gt;<name>ptemp</name></name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><name>mask</name> - <name>addr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>mask</name>++</expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><name>ret</name> = <call><name>apr_ipsubnet_create</name><argument_list>(<argument><expr>&amp;<name>subnet</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><name>mask</name></expr></argument>, <argument><expr><name><name>parms</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>ret</name> != <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
<expr_stmt><expr>*<name><name>parms</name>-&gt;<name>err</name></name> = "parsing of subnet/netmask failed"</expr>;</expr_stmt>
<return>return <expr>!<name>OK</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr>*<name><name>parms</name>-&gt;<name>data</name></name> = <name>subnet</name></expr>;</expr_stmt>
<return>return <expr><name>OK</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>op_ipmatch</name><parameter_list>(<param><decl><type><name>ap_expr_eval_ctx_t</name> *</type><name>ctx</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>void</name> *</type><name>data</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>arg1</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>arg2</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>apr_ipsubnet_t</name> *</type><name>subnet</name> <init>= <expr>(<name>apr_ipsubnet_t</name> *)<name>data</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>apr_sockaddr_t</name> *</type><name>saddr</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>AP_DEBUG_ASSERT</name><argument_list>(<argument><expr><name>subnet</name> != <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>apr_sockaddr_info_get</name><argument_list>(<argument><expr>&amp;<name>saddr</name></expr></argument>, <argument><expr><name>arg1</name></expr></argument>, <argument><expr><name>APR_UNSPEC</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name><name>ctx</name>-&gt;<name>p</name></name></expr></argument>)</argument_list></call> != <name>APR_SUCCESS</name></expr>)</condition><then>
<return>return <expr><name>FALSE</name></expr>;</return></then></if>
<return>return <expr><call><name>apr_ipsubnet_test</name><argument_list>(<argument><expr><name>subnet</name></expr></argument>, <argument><expr><name>saddr</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>op_R</name><parameter_list>(<param><decl><type><name>ap_expr_eval_ctx_t</name> *</type><name>ctx</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>void</name> *</type><name>data</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>arg1</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>apr_ipsubnet_t</name> *</type><name>subnet</name> <init>= <expr>(<name>apr_ipsubnet_t</name> *)<name>data</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>AP_DEBUG_ASSERT</name><argument_list>(<argument><expr><name>subnet</name> != <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name><name>ctx</name>-&gt;<name>r</name></name></expr>)</condition><then>
<return>return <expr><name>FALSE</name></expr>;</return></then></if>
<return>return <expr><call><name>apr_ipsubnet_test</name><argument_list>(<argument><expr><name>subnet</name></expr></argument>, <argument><expr><name><name>ctx</name>-&gt;<name>r</name>-&gt;<name>useragent_addr</name></name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>op_T</name><parameter_list>(<param><decl><type><name>ap_expr_eval_ctx_t</name> *</type><name>ctx</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>void</name> *</type><name>data</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>arg</name></decl></param>)</parameter_list> <block>{
<switch>switch <condition>(<expr><name><name>arg</name><index>[<expr>0</expr>]</index></name></expr>)</condition> <block>{
<case>case <expr>'\0'</expr>:
<return>return <expr><name>FALSE</name></expr>;</return>
</case><case>case <expr>'o'</expr>:
</case><case>case <expr>'O'</expr>:
<return>return <expr><call><name>strcasecmp</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr>"off"</expr></argument>)</argument_list></call> == 0 ? <name>FALSE</name> : <name>TRUE</name></expr>;</return>
</case><case>case <expr>'n'</expr>:
</case><case>case <expr>'N'</expr>:
<return>return <expr><call><name>strcasecmp</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr>"no"</expr></argument>)</argument_list></call> == 0 ? <name>FALSE</name> : <name>TRUE</name></expr>;</return>
</case><case>case <expr>'f'</expr>:
</case><case>case <expr>'F'</expr>:
<return>return <expr><call><name>strcasecmp</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr>"false"</expr></argument>)</argument_list></call> == 0 ? <name>FALSE</name> : <name>TRUE</name></expr>;</return>
</case><case>case <expr>'0'</expr>:
<return>return <expr><name><name>arg</name><index>[<expr>1</expr>]</index></name> == '\0' ? <name>FALSE</name> : <name>TRUE</name></expr>;</return>
</case><default>default:
<return>return <expr><name>TRUE</name></expr>;</return>
</default>}</block></switch>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>op_fnmatch</name><parameter_list>(<param><decl><type><name>ap_expr_eval_ctx_t</name> *</type><name>ctx</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>void</name> *</type><name>data</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>arg1</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>arg2</name></decl></param>)</parameter_list> <block>{
<return>return <expr>(<name>APR_SUCCESS</name> == <call><name>apr_fnmatch</name><argument_list>(<argument><expr><name>arg2</name></expr></argument>, <argument><expr><name>arg1</name></expr></argument>, <argument><expr><name>APR_FNM_PATHNAME</name></expr></argument>)</argument_list></call>)</expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>op_strmatch</name><parameter_list>(<param><decl><type><name>ap_expr_eval_ctx_t</name> *</type><name>ctx</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>void</name> *</type><name>data</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>arg1</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>arg2</name></decl></param>)</parameter_list> <block>{
<return>return <expr>(<name>APR_SUCCESS</name> == <call><name>apr_fnmatch</name><argument_list>(<argument><expr><name>arg2</name></expr></argument>, <argument><expr><name>arg1</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call>)</expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>op_strcmatch</name><parameter_list>(<param><decl><type><name>ap_expr_eval_ctx_t</name> *</type><name>ctx</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>void</name> *</type><name>data</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>arg1</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>arg2</name></decl></param>)</parameter_list> <block>{
<return>return <expr>(<name>APR_SUCCESS</name> == <call><name>apr_fnmatch</name><argument_list>(<argument><expr><name>arg2</name></expr></argument>, <argument><expr><name>arg1</name></expr></argument>, <argument><expr><name>APR_FNM_CASE_BLIND</name></expr></argument>)</argument_list></call>)</expr>;</return>
}</block></function>
<struct>struct <name>expr_provider_single</name> <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>void</name> *</type><name>func</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>name</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ap_expr_lookup_fn_t</name> *</type><name>arg_parsing_func</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>restricted</name></decl>;</decl_stmt>
}</block>;</struct>
<struct>struct <name>expr_provider_multi</name> <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>void</name> *</type><name>func</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> **</type><name>names</name></decl>;</decl_stmt>
}</block>;</struct>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> struct <name>expr_provider_multi</name></type> <name><name>var_providers</name><index>[]</index></name> <init>= <expr><block>{
<expr><block>{ <expr><name>misc_var_fn</name></expr>, <expr><name>misc_var_names</name></expr> }</block></expr>,
<expr><block>{ <expr><name>req_header_var_fn</name></expr>, <expr><name>req_header_var_names</name></expr> }</block></expr>,
<expr><block>{ <expr><name>request_var_fn</name></expr>, <expr><name>request_var_names</name></expr> }</block></expr>,
<expr><block>{ <expr><name>conn_var_fn</name></expr>, <expr><name>conn_var_names</name></expr> }</block></expr>,
<expr><block>{ <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr> }</block></expr>
}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> struct <name>expr_provider_single</name></type> <name><name>string_func_providers</name><index>[]</index></name> <init>= <expr><block>{
<expr><block>{ <expr><name>osenv_func</name></expr>, <expr>"osenv"</expr>, <expr><name>NULL</name></expr>, <expr>0</expr> }</block></expr>,
<expr><block>{ <expr><name>env_func</name></expr>, <expr>"env"</expr>, <expr><name>NULL</name></expr>, <expr>0</expr> }</block></expr>,
<expr><block>{ <expr><name>req_table_func</name></expr>, <expr>"resp"</expr>, <expr><name>NULL</name></expr>, <expr>0</expr> }</block></expr>,
<expr><block>{ <expr><name>req_table_func</name></expr>, <expr>"req"</expr>, <expr><name>NULL</name></expr>, <expr>0</expr> }</block></expr>,
<expr><block>{ <expr><name>req_table_func</name></expr>, <expr>"http"</expr>, <expr><name>NULL</name></expr>, <expr>0</expr> }</block></expr>,
<expr><block>{ <expr><name>req_table_func</name></expr>, <expr>"note"</expr>, <expr><name>NULL</name></expr>, <expr>0</expr> }</block></expr>,
<expr><block>{ <expr><name>req_table_func</name></expr>, <expr>"reqenv"</expr>, <expr><name>NULL</name></expr>, <expr>0</expr> }</block></expr>,
<expr><block>{ <expr><name>req_table_func</name></expr>, <expr>"req_novary"</expr>, <expr><name>NULL</name></expr>, <expr>0</expr> }</block></expr>,
<expr><block>{ <expr><name>tolower_func</name></expr>, <expr>"tolower"</expr>, <expr><name>NULL</name></expr>, <expr>0</expr> }</block></expr>,
<expr><block>{ <expr><name>toupper_func</name></expr>, <expr>"toupper"</expr>, <expr><name>NULL</name></expr>, <expr>0</expr> }</block></expr>,
<expr><block>{ <expr><name>escape_func</name></expr>, <expr>"escape"</expr>, <expr><name>NULL</name></expr>, <expr>0</expr> }</block></expr>,
<expr><block>{ <expr><name>unescape_func</name></expr>, <expr>"unescape"</expr>, <expr><name>NULL</name></expr>, <expr>0</expr> }</block></expr>,
<expr><block>{ <expr><name>file_func</name></expr>, <expr>"file"</expr>, <expr><name>NULL</name></expr>, <expr>1</expr> }</block></expr>,
<expr><block>{ <expr><name>filesize_func</name></expr>, <expr>"filesize"</expr>, <expr><name>NULL</name></expr>, <expr>1</expr> }</block></expr>,
<expr><block>{ <expr><name>base64_func</name></expr>, <expr>"base64"</expr>, <expr><name>NULL</name></expr>, <expr>0</expr> }</block></expr>,
<expr><block>{ <expr><name>unbase64_func</name></expr>, <expr>"unbase64"</expr>, <expr><name>NULL</name></expr>, <expr>0</expr> }</block></expr>,
<expr><block>{ <expr><name>sha1_func</name></expr>, <expr>"sha1"</expr>, <expr><name>NULL</name></expr>, <expr>0</expr> }</block></expr>,
<expr><block>{ <expr><name>md5_func</name></expr>, <expr>"md5"</expr>, <expr><name>NULL</name></expr>, <expr>0</expr> }</block></expr>,
<expr><block>{ <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>}</block></expr>
}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> struct <name>expr_provider_single</name></type> <name><name>unary_op_providers</name><index>[]</index></name> <init>= <expr><block>{
<expr><block>{ <expr><name>op_nz</name></expr>, <expr>"n"</expr>, <expr><name>NULL</name></expr>, <expr>0</expr> }</block></expr>,
<expr><block>{ <expr><name>op_nz</name></expr>, <expr>"z"</expr>, <expr><name>NULL</name></expr>, <expr>0</expr> }</block></expr>,
<expr><block>{ <expr><name>op_R</name></expr>, <expr>"R"</expr>, <expr><name>subnet_parse_arg</name></expr>, <expr>0</expr> }</block></expr>,
<expr><block>{ <expr><name>op_T</name></expr>, <expr>"T"</expr>, <expr><name>NULL</name></expr>, <expr>0</expr> }</block></expr>,
<expr><block>{ <expr><name>op_file_min</name></expr>, <expr>"d"</expr>, <expr><name>NULL</name></expr>, <expr>1</expr> }</block></expr>,
<expr><block>{ <expr><name>op_file_min</name></expr>, <expr>"e"</expr>, <expr><name>NULL</name></expr>, <expr>1</expr> }</block></expr>,
<expr><block>{ <expr><name>op_file_min</name></expr>, <expr>"f"</expr>, <expr><name>NULL</name></expr>, <expr>1</expr> }</block></expr>,
<expr><block>{ <expr><name>op_file_min</name></expr>, <expr>"s"</expr>, <expr><name>NULL</name></expr>, <expr>1</expr> }</block></expr>,
<expr><block>{ <expr><name>op_file_link</name></expr>, <expr>"L"</expr>, <expr><name>NULL</name></expr>, <expr>1</expr> }</block></expr>,
<expr><block>{ <expr><name>op_file_link</name></expr>, <expr>"h"</expr>, <expr><name>NULL</name></expr>, <expr>1</expr> }</block></expr>,
<expr><block>{ <expr><name>op_file_xbit</name></expr>, <expr>"x"</expr>, <expr><name>NULL</name></expr>, <expr>1</expr> }</block></expr>,
<expr><block>{ <expr><name>op_file_subr</name></expr>, <expr>"F"</expr>, <expr><name>NULL</name></expr>, <expr>0</expr> }</block></expr>,
<expr><block>{ <expr><name>op_url_subr</name></expr>, <expr>"U"</expr>, <expr><name>NULL</name></expr>, <expr>0</expr> }</block></expr>,
<expr><block>{ <expr><name>op_url_subr</name></expr>, <expr>"A"</expr>, <expr><name>NULL</name></expr>, <expr>0</expr> }</block></expr>,
<expr><block>{ <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr> }</block></expr>
}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> struct <name>expr_provider_single</name></type> <name><name>binary_op_providers</name><index>[]</index></name> <init>= <expr><block>{
<expr><block>{ <expr><name>op_ipmatch</name></expr>, <expr>"ipmatch"</expr>, <expr><name>subnet_parse_arg</name></expr>, <expr>0</expr> }</block></expr>,
<expr><block>{ <expr><name>op_fnmatch</name></expr>, <expr>"fnmatch"</expr>, <expr><name>NULL</name></expr>, <expr>0</expr> }</block></expr>,
<expr><block>{ <expr><name>op_strmatch</name></expr>, <expr>"strmatch"</expr>, <expr><name>NULL</name></expr>, <expr>0</expr> }</block></expr>,
<expr><block>{ <expr><name>op_strcmatch</name></expr>, <expr>"strcmatch"</expr>, <expr><name>NULL</name></expr>, <expr>0</expr> }</block></expr>,
<expr><block>{ <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr> }</block></expr>
}</block></expr></init></decl>;</decl_stmt>
<function><type><specifier>static</specifier> <name>int</name></type> <name>core_expr_lookup</name><parameter_list>(<param><decl><type><name>ap_expr_lookup_parms</name> *</type><name>parms</name></decl></param>)</parameter_list> <block>{
<switch>switch <condition>(<expr><name><name>parms</name>-&gt;<name>type</name></name></expr>)</condition> <block>{
<case>case <expr><name>AP_EXPR_FUNC_VAR</name></expr>: <block>{
<decl_stmt><decl><type><specifier>const</specifier> struct <name>expr_provider_multi</name> *</type><name>prov</name> <init>= <expr><name>var_providers</name></expr></init></decl>;</decl_stmt>
<while>while <condition>(<expr><name><name>prov</name>-&gt;<name>func</name></name></expr>)</condition> <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> **</type><name>name</name> <init>= <expr><name><name>prov</name>-&gt;<name>names</name></name></expr></init></decl>;</decl_stmt>
<while>while <condition>(<expr>*<name>name</name></expr>)</condition> <block>{
<if>if <condition>(<expr><call><name>strcasecmp</name><argument_list>(<argument><expr>*<name>name</name></expr></argument>, <argument><expr><name><name>parms</name>-&gt;<name>name</name></name></expr></argument>)</argument_list></call> == 0</expr>)</condition><then> <block>{
<expr_stmt><expr>*<name><name>parms</name>-&gt;<name>func</name></name> = <name><name>prov</name>-&gt;<name>func</name></name></expr>;</expr_stmt>
<expr_stmt><expr>*<name><name>parms</name>-&gt;<name>data</name></name> = <name>name</name></expr>;</expr_stmt>
<return>return <expr><name>OK</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>name</name>++</expr>;</expr_stmt>
}</block></while>
<expr_stmt><expr><name>prov</name>++</expr>;</expr_stmt>
}</block></while>
}</block>
<break>break;</break>
</case><case>case <expr><name>AP_EXPR_FUNC_STRING</name></expr>:
</case><case>case <expr><name>AP_EXPR_FUNC_OP_UNARY</name></expr>:
</case><case>case <expr><name>AP_EXPR_FUNC_OP_BINARY</name></expr>: <block>{
<decl_stmt><decl><type><specifier>const</specifier> struct <name>expr_provider_single</name> *</type><name>prov</name></decl>;</decl_stmt>
<switch>switch <condition>(<expr><name><name>parms</name>-&gt;<name>type</name></name></expr>)</condition> <block>{
<case>case <expr><name>AP_EXPR_FUNC_STRING</name></expr>:
<expr_stmt><expr><name>prov</name> = <name>string_func_providers</name></expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr><name>AP_EXPR_FUNC_OP_UNARY</name></expr>:
<expr_stmt><expr><name>prov</name> = <name>unary_op_providers</name></expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr><name>AP_EXPR_FUNC_OP_BINARY</name></expr>:
<expr_stmt><expr><name>prov</name> = <name>binary_op_providers</name></expr>;</expr_stmt>
<break>break;</break>
</case><default>default:
<expr_stmt><expr><call><name>ap_assert</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
</default>}</block></switch>
<while>while <condition>(<expr><name><name>prov</name>-&gt;<name>func</name></name></expr>)</condition> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>match</name></decl>;</decl_stmt>
<if>if <condition>(<expr><name><name>parms</name>-&gt;<name>type</name></name> == <name>AP_EXPR_FUNC_OP_UNARY</name></expr>)</condition><then>
<expr_stmt><expr><name>match</name> = !<call><name>strcmp</name><argument_list>(<argument><expr><name><name>prov</name>-&gt;<name>name</name></name></expr></argument>, <argument><expr><name><name>parms</name>-&gt;<name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
<else>else
<expr_stmt><expr><name>match</name> = !<call><name>strcasecmp</name><argument_list>(<argument><expr><name><name>prov</name>-&gt;<name>name</name></name></expr></argument>, <argument><expr><name><name>parms</name>-&gt;<name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
<if>if <condition>(<expr><name>match</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr>(<name><name>parms</name>-&gt;<name>flags</name></name> &amp; <name>AP_EXPR_FLAG_RESTRICTED</name>)
&amp;&amp; <name><name>prov</name>-&gt;<name>restricted</name></name></expr>)</condition><then> <block>{
<expr_stmt><expr>*<name><name>parms</name>-&gt;<name>err</name></name> =
<call><name>apr_psprintf</name><argument_list>(<argument><expr><name><name>parms</name>-&gt;<name>ptemp</name></name></expr></argument>,
<argument><expr>"%s%s not available in restricted context"</expr></argument>,
<argument><expr>(<name><name>parms</name>-&gt;<name>type</name></name> == <name>AP_EXPR_FUNC_STRING</name>) ? "" : "-"</expr></argument>,
<argument><expr><name><name>prov</name>-&gt;<name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>!<name>OK</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr>*<name><name>parms</name>-&gt;<name>func</name></name> = <name><name>prov</name>-&gt;<name>func</name></name></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>prov</name>-&gt;<name>arg_parsing_func</name></name></expr>)</condition><then> <block>{
<return>return <expr><call><name><name>prov</name>-&gt;<name>arg_parsing_func</name></name><argument_list>(<argument><expr><name>parms</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></then> <else>else <block>{
<expr_stmt><expr>*<name><name>parms</name>-&gt;<name>data</name></name> = <name><name>prov</name>-&gt;<name>name</name></name></expr>;</expr_stmt>
<return>return <expr><name>OK</name></expr>;</return>
}</block></else></if>
}</block></then></if>
<expr_stmt><expr><name>prov</name>++</expr>;</expr_stmt>
}</block></while>
}</block>
<break>break;</break>
</case><default>default:
<break>break;</break>
</default>}</block></switch>
<return>return <expr><name>DECLINED</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>expr_lookup_not_found</name><parameter_list>(<param><decl><type><name>ap_expr_lookup_parms</name> *</type><name>parms</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>type</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>prefix</name> <init>= <expr>""</expr></init></decl>;</decl_stmt>
<switch>switch <condition>(<expr><name><name>parms</name>-&gt;<name>type</name></name></expr>)</condition> <block>{
<case>case <expr><name>AP_EXPR_FUNC_VAR</name></expr>:
<expr_stmt><expr><name>type</name> = "Variable"</expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr><name>AP_EXPR_FUNC_STRING</name></expr>:
<expr_stmt><expr><name>type</name> = "Function"</expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr><name>AP_EXPR_FUNC_LIST</name></expr>:
<expr_stmt><expr><name>type</name> = "List-returning function"</expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr><name>AP_EXPR_FUNC_OP_UNARY</name></expr>:
<expr_stmt><expr><name>type</name> = "Unary operator"</expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr><name>AP_EXPR_FUNC_OP_BINARY</name></expr>:
<expr_stmt><expr><name>type</name> = "Binary operator"</expr>;</expr_stmt>
<break>break;</break>
</case><default>default:
<expr_stmt><expr>*<name><name>parms</name>-&gt;<name>err</name></name> = "Inavalid expression type in expr_lookup"</expr>;</expr_stmt>
<return>return <expr>!<name>OK</name></expr>;</return>
</default>}</block></switch>
<if>if <condition>( <expr><name><name>parms</name>-&gt;<name>type</name></name> == <name>AP_EXPR_FUNC_OP_UNARY</name>
|| <name><name>parms</name>-&gt;<name>type</name></name> == <name>AP_EXPR_FUNC_OP_BINARY</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>prefix</name> = "-"</expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr>*<name><name>parms</name>-&gt;<name>err</name></name> = <call><name>apr_psprintf</name><argument_list>(<argument><expr><name><name>parms</name>-&gt;<name>ptemp</name></name></expr></argument>, <argument><expr>"%s '%s%s' does not exist"</expr></argument>, <argument><expr><name>type</name></expr></argument>,
<argument><expr><name>prefix</name></expr></argument>, <argument><expr><name><name>parms</name>-&gt;<name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>!<name>OK</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>ap_expr_post_config</name><parameter_list>(<param><decl><type><name>apr_pool_t</name> *</type><name>pconf</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>plog</name></decl></param>,
<param><decl><type><name>apr_pool_t</name> *</type><name>ptemp</name></decl></param>, <param><decl><type><name>server_rec</name> *</type><name>s</name></decl></param>)</parameter_list> <block>{
<expr_stmt><expr><name>is_https</name> = <call><name>APR_RETRIEVE_OPTIONAL_FN</name><argument_list>(<argument><expr><name>ssl_is_https</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>is_http2</name> = <call><name>APR_RETRIEVE_OPTIONAL_FN</name><argument_list>(<argument><expr><name>http2_is_h2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>apr_pool_cleanup_register</name><argument_list>(<argument><expr><name>pconf</name></expr></argument>, <argument><expr>&amp;<name>is_https</name></expr></argument>, <argument><expr><name>ap_pool_cleanup_set_null</name></expr></argument>,
<argument><expr><name>apr_pool_cleanup_null</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>OK</name></expr>;</return>
}</block></function>
<function><type><name>void</name></type> <name>ap_expr_init</name><parameter_list>(<param><decl><type><name>apr_pool_t</name> *</type><name>p</name></decl></param>)</parameter_list> <block>{
<expr_stmt><expr><call><name>ap_hook_expr_lookup</name><argument_list>(<argument><expr><name>core_expr_lookup</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>APR_HOOK_MIDDLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ap_hook_expr_lookup</name><argument_list>(<argument><expr><name>expr_lookup_not_found</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>APR_HOOK_REALLY_LAST</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ap_hook_post_config</name><argument_list>(<argument><expr><name>ap_expr_post_config</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>APR_HOOK_MIDDLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>
</unit>
