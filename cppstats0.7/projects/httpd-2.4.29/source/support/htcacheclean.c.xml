<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C" filename="projects/httpd-2.4.29/support/htcacheclean.c"><comment type="block">/* Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */</comment>

<comment type="block">/*
 * htcacheclean.c: simple program for cleaning of
 * the disk cache of the Apache HTTP server
 *
 * Contributed by Andreas Steinmetz &lt;ast domdv.de&gt;
 * 8 Oct 2004
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"apr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"apr_lib.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"apr_strings.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"apr_file_io.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"apr_file_info.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"apr_pools.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"apr_hash.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"apr_thread_proc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"apr_signal.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"apr_getopt.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"apr_md5.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"apr_ring.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"apr_date.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"apr_buckets.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"../modules/cache/cache_common.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"../modules/cache/cache_disk_common.h"</cpp:file></cpp:include>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>APR_HAVE_UNISTD_H</name></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;unistd.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>APR_HAVE_STDLIB_H</name></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdlib.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* define the following for debugging */</comment>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>DEBUG</name></cpp:undef>

<comment type="block">/*
 * Note: on Linux delays &lt;= 2ms are busy waits without
 *       scheduling, so never use a delay &lt;= 2ms below
 */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NICE_DELAY</name></cpp:macro>    <cpp:value>10000</cpp:value></cpp:define>     <comment type="block">/* usecs */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DELETE_NICE</name></cpp:macro>   <cpp:value>10</cpp:value></cpp:define>        <comment type="block">/* be nice after this amount of delete ops */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>STAT_ATTEMPTS</name></cpp:macro> <cpp:value>10</cpp:value></cpp:define>        <comment type="block">/* maximum stat attempts for a file */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>STAT_DELAY</name></cpp:macro>    <cpp:value>5000</cpp:value></cpp:define>      <comment type="block">/* usecs */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HEADER</name></cpp:macro>        <cpp:value>1</cpp:value></cpp:define>         <comment type="block">/* headers file */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DATA</name></cpp:macro>          <cpp:value>2</cpp:value></cpp:define>         <comment type="block">/* body file */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TEMP</name></cpp:macro>          <cpp:value>4</cpp:value></cpp:define>         <comment type="block">/* temporary file */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HEADERDATA</name></cpp:macro>    <cpp:value>(HEADER|DATA)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAXDEVIATION</name></cpp:macro>  <cpp:value>3600</cpp:value></cpp:define>      <comment type="block">/* secs */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SECS_PER_MIN</name></cpp:macro>  <cpp:value>60</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>KBYTE</name></cpp:macro>         <cpp:value>1024</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MBYTE</name></cpp:macro>         <cpp:value>1048576</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GBYTE</name></cpp:macro>         <cpp:value>1073741824</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DIRINFO</name></cpp:macro> <cpp:value>(APR_FINFO_MTIME|APR_FINFO_SIZE|APR_FINFO_TYPE|APR_FINFO_LINK)</cpp:value></cpp:define>

<typedef>typedef <type><struct>struct <name>_direntry</name> <block>{
    <macro><name>APR_RING_ENTRY</name><argument_list>(<argument>_direntry</argument>)</argument_list></macro> <expr_stmt><expr><name>link</name></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>type</name></decl>;</decl_stmt>         <comment type="block">/* type of file/fileset: TEMP, HEADER, DATA, HEADERDATA */</comment>
    <decl_stmt><decl><type><name>apr_time_t</name></type> <name>htime</name></decl>;</decl_stmt> <comment type="block">/* headers file modification time */</comment>
    <decl_stmt><decl><type><name>apr_time_t</name></type> <name>dtime</name></decl>;</decl_stmt> <comment type="block">/* body file modification time */</comment>
    <decl_stmt><decl><type><name>apr_off_t</name></type> <name>hsize</name></decl>;</decl_stmt>  <comment type="block">/* headers file size */</comment>
    <decl_stmt><decl><type><name>apr_off_t</name></type> <name>dsize</name></decl>;</decl_stmt>  <comment type="block">/* body or temporary file size */</comment>
    <decl_stmt><decl><type><name>char</name> *</type><name>basename</name></decl>;</decl_stmt>   <comment type="block">/* file/fileset base name */</comment>
}</block></struct></type> <name>DIRENTRY</name>;</typedef>

<typedef>typedef <type><struct>struct <name>_entry</name> <block>{
    <macro><name>APR_RING_ENTRY</name><argument_list>(<argument>_entry</argument>)</argument_list></macro> <expr_stmt><expr><name>link</name></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>apr_time_t</name></type> <name>expire</name></decl>;</decl_stmt>        <comment type="block">/* cache entry exiration time */</comment>
    <decl_stmt><decl><type><name>apr_time_t</name></type> <name>response_time</name></decl>;</decl_stmt> <comment type="block">/* cache entry time of last response to client */</comment>
    <decl_stmt><decl><type><name>apr_time_t</name></type> <name>htime</name></decl>;</decl_stmt>         <comment type="block">/* headers file modification time */</comment>
    <decl_stmt><decl><type><name>apr_time_t</name></type> <name>dtime</name></decl>;</decl_stmt>         <comment type="block">/* body file modification time */</comment>
    <decl_stmt><decl><type><name>apr_off_t</name></type> <name>hsize</name></decl>;</decl_stmt>          <comment type="block">/* headers file size */</comment>
    <decl_stmt><decl><type><name>apr_off_t</name></type> <name>dsize</name></decl>;</decl_stmt>          <comment type="block">/* body or temporary file size */</comment>
    <decl_stmt><decl><type><name>char</name> *</type><name>basename</name></decl>;</decl_stmt>           <comment type="block">/* fileset base name */</comment>
}</block></struct></type> <name>ENTRY</name>;</typedef>


<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>delcount</name></decl>;</decl_stmt>    <comment type="block">/* file deletion count for nice mode */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>interrupted</name></decl>;</decl_stmt> <comment type="block">/* flag: true if SIGINT or SIGTERM occurred */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>realclean</name></decl>;</decl_stmt>   <comment type="block">/* flag: true means user said apache is not running */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>verbose</name></decl>;</decl_stmt>     <comment type="block">/* flag: true means print statistics */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>benice</name></decl>;</decl_stmt>      <comment type="block">/* flag: true means nice mode is activated */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>dryrun</name></decl>;</decl_stmt>      <comment type="block">/* flag: true means dry run, don't actually delete
                                 anything */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>deldirs</name></decl>;</decl_stmt>     <comment type="block">/* flag: true means directories should be deleted */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>listurls</name></decl>;</decl_stmt>    <comment type="block">/* flag: true means list cached urls */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>listextended</name></decl>;</decl_stmt><comment type="block">/* flag: true means list cached urls */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>baselen</name></decl>;</decl_stmt>     <comment type="block">/* string length of the path to the proxy directory */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>apr_time_t</name></type> <name>now</name></decl>;</decl_stmt>  <comment type="block">/* start time of this processing run */</comment>

<decl_stmt><decl><type><specifier>static</specifier> <name>apr_file_t</name> *</type><name>errfile</name></decl>;</decl_stmt>   <comment type="block">/* stderr file handle */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>apr_file_t</name> *</type><name>outfile</name></decl>;</decl_stmt>   <comment type="block">/* stdout file handle */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>apr_off_t</name></type> <name>unsolicited</name></decl>;</decl_stmt> <comment type="block">/* file size summary for deleted unsolicited
                                 files */</comment>
<expr_stmt><expr>static <macro><name>APR_RING_ENTRY</name><argument_list>(<argument>_entry</argument>)</argument_list></macro> <name>root</name></expr>;</expr_stmt> <comment type="block">/* ENTRY ring anchor */</comment>

<comment type="block">/* short program name as called */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> *</type><name>shortname</name> <init>= <expr>"htcacheclean"</expr></init></decl>;</decl_stmt>

<comment type="block">/* what did we clean? */</comment>
<struct>struct <name>stats</name> <block>{
    <decl_stmt><decl><type><name>apr_off_t</name></type> <name>total</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_off_t</name></type> <name>sum</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_off_t</name></type> <name>max</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_off_t</name></type> <name>ntotal</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_off_t</name></type> <name>nodes</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_off_t</name></type> <name>inodes</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_off_t</name></type> <name>etotal</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_off_t</name></type> <name>entries</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_off_t</name></type> <name>dfuture</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_off_t</name></type> <name>dexpired</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_off_t</name></type> <name>dfresh</name></decl>;</decl_stmt>
}</block>;</struct>


<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
<comment type="block">/*
 * fake delete for debug purposes
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>apr_file_remove</name></cpp:macro> <cpp:value>fake_file_remove</cpp:value></cpp:define>
<function><type><specifier>static</specifier> <name>void</name></type> <name>fake_file_remove</name><parameter_list>(<param><decl><type><name>char</name> *</type><name>pathname</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>p</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>apr_finfo_t</name></type> <name>info</name></decl>;</decl_stmt>

    <comment type="block">/* stat and printing to simulate some deletion system load and to
       display what would actually have happened */</comment>
    <expr_stmt><expr><call><name>apr_stat</name><argument_list>(<argument><expr>&amp;<name>info</name></expr></argument>, <argument><expr><name>pathname</name></expr></argument>, <argument><expr><name>DIRINFO</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>apr_file_printf</name><argument_list>(<argument><expr><name>errfile</name></expr></argument>, <argument><expr>"would delete %s" <name>APR_EOL_STR</name></expr></argument>, <argument><expr><name>pathname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
 * called on SIGINT or SIGTERM
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>setterm</name><parameter_list>(<param><decl><type><name>int</name></type> <name>unused</name></decl></param>)</parameter_list>
<block>{
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
    <expr_stmt><expr><call><name>apr_file_printf</name><argument_list>(<argument><expr><name>errfile</name></expr></argument>, <argument><expr>"interrupt" <name>APR_EOL_STR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><name>interrupted</name> = 1</expr>;</expr_stmt>
}</block></function>

<comment type="block">/*
 * called in out of memory condition
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>oom</name><parameter_list>(<param><decl><type><name>int</name></type> <name>unused</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>called</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>

    <comment type="block">/* be careful to call exit() only once */</comment>
    <if>if <condition>(<expr>!<name>called</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>called</name> = 1</expr>;</expr_stmt>
        <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <return>return <expr><name>APR_ENOMEM</name></expr>;</return>
}</block></function>

<comment type="block">/*
 * print purge statistics
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>printstats</name><parameter_list>(<param><decl><type><name>char</name> *</type><name>path</name></decl></param>, <param><decl><type>struct <name>stats</name> *</type><name>s</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>char</name></type> <name>ttype</name></decl>, <decl><type ref="prev"/><name>stype</name></decl>, <decl><type ref="prev"/><name>mtype</name></decl>, <decl><type ref="prev"/><name>utype</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_off_t</name></type> <name>tfrag</name></decl>, <decl><type ref="prev"/><name>sfrag</name></decl>, <decl><type ref="prev"/><name>ufrag</name></decl>;</decl_stmt>

    <if>if <condition>(<expr>!<name>verbose</name></expr>)</condition><then> <block>{
        <return>return;</return>
    }</block></then></if>

    <expr_stmt><expr><name>ttype</name> = 'K'</expr>;</expr_stmt>
    <expr_stmt><expr><name>tfrag</name> = ((<name><name>s</name>-&gt;<name>total</name></name> * 10) / <name>KBYTE</name>) % 10</expr>;</expr_stmt>
    <expr_stmt><expr><name><name>s</name>-&gt;<name>total</name></name> /= <name>KBYTE</name></expr>;</expr_stmt>
    <if>if <condition>(<expr><name><name>s</name>-&gt;<name>total</name></name> &gt;= <name>KBYTE</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>ttype</name> = 'M'</expr>;</expr_stmt>
        <expr_stmt><expr><name>tfrag</name> = ((<name><name>s</name>-&gt;<name>total</name></name> * 10) / <name>KBYTE</name>) % 10</expr>;</expr_stmt>
        <expr_stmt><expr><name><name>s</name>-&gt;<name>total</name></name> /= <name>KBYTE</name></expr>;</expr_stmt>
    }</block></then></if>

    <expr_stmt><expr><name>stype</name> = 'K'</expr>;</expr_stmt>
    <expr_stmt><expr><name>sfrag</name> = ((<name><name>s</name>-&gt;<name>sum</name></name> * 10) / <name>KBYTE</name>) % 10</expr>;</expr_stmt>
    <expr_stmt><expr><name><name>s</name>-&gt;<name>sum</name></name> /= <name>KBYTE</name></expr>;</expr_stmt>
    <if>if <condition>(<expr><name><name>s</name>-&gt;<name>sum</name></name> &gt;= <name>KBYTE</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>stype</name> = 'M'</expr>;</expr_stmt>
        <expr_stmt><expr><name>sfrag</name> = ((<name><name>s</name>-&gt;<name>sum</name></name> * 10) / <name>KBYTE</name>) % 10</expr>;</expr_stmt>
        <expr_stmt><expr><name><name>s</name>-&gt;<name>sum</name></name> /= <name>KBYTE</name></expr>;</expr_stmt>
    }</block></then></if>

    <expr_stmt><expr><name>mtype</name> = 'K'</expr>;</expr_stmt>
    <expr_stmt><expr><name><name>s</name>-&gt;<name>max</name></name> /= <name>KBYTE</name></expr>;</expr_stmt>
    <if>if <condition>(<expr><name><name>s</name>-&gt;<name>max</name></name> &gt;= <name>KBYTE</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>mtype</name> = 'M'</expr>;</expr_stmt>
        <expr_stmt><expr><name><name>s</name>-&gt;<name>max</name></name> /= <name>KBYTE</name></expr>;</expr_stmt>
    }</block></then></if>

    <expr_stmt><expr><call><name>apr_file_printf</name><argument_list>(<argument><expr><name>errfile</name></expr></argument>, <argument><expr>"Cleaned %s. Statistics:" <name>APR_EOL_STR</name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>unsolicited</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>utype</name> = 'K'</expr>;</expr_stmt>
        <expr_stmt><expr><name>ufrag</name> = ((<name>unsolicited</name> * 10) / <name>KBYTE</name>) % 10</expr>;</expr_stmt>
        <expr_stmt><expr><name>unsolicited</name> /= <name>KBYTE</name></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>unsolicited</name> &gt;= <name>KBYTE</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>utype</name> = 'M'</expr>;</expr_stmt>
            <expr_stmt><expr><name>ufrag</name> = ((<name>unsolicited</name> * 10) / <name>KBYTE</name>) % 10</expr>;</expr_stmt>
            <expr_stmt><expr><name>unsolicited</name> /= <name>KBYTE</name></expr>;</expr_stmt>
        }</block></then></if>
        <if>if <condition>(<expr>!<name>unsolicited</name> &amp;&amp; !<name>ufrag</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>ufrag</name> = 1</expr>;</expr_stmt>
        }</block></then></if>
        <expr_stmt><expr><call><name>apr_file_printf</name><argument_list>(<argument><expr><name>errfile</name></expr></argument>, <argument><expr>"unsolicited size %d.%d%c" <name>APR_EOL_STR</name></expr></argument>,
                        <argument><expr><call>(<name>int</name>)<argument_list>(<argument><expr><name>unsolicited</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call>(<name>int</name>)<argument_list>(<argument><expr><name>ufrag</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>utype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <expr_stmt><expr><call><name>apr_file_printf</name><argument_list>(<argument><expr><name>errfile</name></expr></argument>, <argument><expr>"size limit %" <name>APR_OFF_T_FMT</name> ".0%c" <name>APR_EOL_STR</name></expr></argument>,
            <argument><expr><name><name>s</name>-&gt;<name>max</name></name></expr></argument>, <argument><expr><name>mtype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <macro><name>apr_file_printf</name><argument_list>(<argument>errfile</argument>, <argument>"inodes limit %" APR_OFF_T_FMT APR_EOL_STR</argument>,
            <argument>s-&gt;inodes</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
    <expr_stmt><expr><call><name>apr_file_printf</name><argument_list>(
            <argument><expr><name>errfile</name></expr></argument>,
            <argument><expr>"total size was %" <name>APR_OFF_T_FMT</name> ".%" <name>APR_OFF_T_FMT</name> "%c, total size now "
            "%" <name>APR_OFF_T_FMT</name> ".%" <name>APR_OFF_T_FMT</name> "%c" <name>APR_EOL_STR</name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>total</name></name></expr></argument>,
            <argument><expr><name>tfrag</name></expr></argument>, <argument><expr><name>ttype</name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>sum</name></name></expr></argument>, <argument><expr><name>sfrag</name></expr></argument>, <argument><expr><name>stype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <macro><name>apr_file_printf</name><argument_list>(<argument>errfile</argument>, <argument>"total inodes was %" APR_OFF_T_FMT
            ", total %sinodes now "
            "%" APR_OFF_T_FMT APR_EOL_STR</argument>, <argument>s-&gt;ntotal</argument>, <argument>dryrun &amp;&amp; deldirs ? "estimated "
            : ""</argument>, <argument>s-&gt;nodes</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
    <macro><name>apr_file_printf</name><argument_list>(
            <argument>errfile</argument>,
            <argument>"total entries was %" APR_OFF_T_FMT ", total entries now %" APR_OFF_T_FMT
            APR_EOL_STR</argument>, <argument>s-&gt;etotal</argument>, <argument>s-&gt;entries</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
    <expr_stmt><expr><call><name>apr_file_printf</name><argument_list>(
            <argument><expr><name>errfile</name></expr></argument>,
            <argument><expr>"%" <name>APR_OFF_T_FMT</name> " entries deleted (%" <name>APR_OFF_T_FMT</name> " from future, %"
            <name>APR_OFF_T_FMT</name> " expired, %" <name>APR_OFF_T_FMT</name> " fresh)" <name>APR_EOL_STR</name></expr></argument>,
            <argument><expr>(<name><name>s</name>-&gt;<name>etotal</name></name> - <name><name>s</name>-&gt;<name>entries</name></name>)</expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>dfuture</name></name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>dexpired</name></name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>dfresh</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<comment type="block">/**
 * Round the value up to the given threshold.
 */</comment>
<function><type><specifier>static</specifier> <name>apr_size_t</name></type> <name>round_up</name><parameter_list>(<param><decl><type><name>apr_size_t</name></type> <name>val</name></decl></param>, <param><decl><type><name>apr_off_t</name></type> <name>round</name></decl></param>)</parameter_list> <block>{
    <if>if <condition>(<expr><name>round</name> &gt; 1</expr>)</condition><then> <block>{
        <return>return <expr><call>(<name>apr_size_t</name>)<argument_list>(<argument><expr>((<name>val</name> + <name>round</name> - 1) / <name>round</name>) * <name>round</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></then></if>
    <return>return <expr><name>val</name></expr>;</return>
}</block></function>

<comment type="block">/*
 * delete parent directories
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>delete_parent</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>basename</name></decl></param>,
        <param><decl><type><name>apr_off_t</name> *</type><name>nodes</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>char</name> *</type><name>nextpath</name></decl>, *<decl><type ref="prev"/><name>name</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>p</name></decl>;</decl_stmt>

    <comment type="block">/* temp pool, otherwise lots of memory could be allocated */</comment>
    <expr_stmt><expr><call><name>apr_pool_create</name><argument_list>(<argument><expr>&amp;<name>p</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>name</name> = <call><name>apr_pstrdup</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>basename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* If asked to delete dirs, do so now. We don't care if it fails.
     * If it fails, it likely means there was something else there.
     */</comment>
    <if>if <condition>(<expr><name>deldirs</name> &amp;&amp; !<name>dryrun</name></expr>)</condition><then> <block>{
        <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>vary</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>char</name> *</type><name>end</name> <init>= <expr><call><name>strrchr</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr>'/'</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <while>while <condition>(<expr><name>end</name></expr>)</condition> <block>{
            <expr_stmt><expr>*<name>end</name> = 0</expr>;</expr_stmt>

            <comment type="block">/* remove the directory */</comment>
            <expr_stmt><expr><name>nextpath</name> = <call><name>apr_pstrcat</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr>"/"</expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr>!<call><name>apr_dir_remove</name><argument_list>(<argument><expr><name>nextpath</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <expr_stmt><expr>(*<name>nodes</name>)--</expr>;</expr_stmt>

                <comment type="block">/* vary directory found? */</comment>
                <expr_stmt><expr><name>vary</name> = <call><name>strstr</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>CACHE_VDIR_SUFFIX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if>if <condition>(<expr><name>vary</name> &amp;&amp; !<name><name>vary</name><index>[<expr><sizeof>sizeof<argument_list>(<argument><expr><name>CACHE_VDIR_SUFFIX</name></expr></argument>)</argument_list></sizeof> - 1</expr>]</index></name></expr>)</condition><then> <block>{
                    <expr_stmt><expr><name>nextpath</name> = <call><name>apr_pstrcat</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr>"/"</expr></argument>, <argument><expr><call><name>apr_pstrndup</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>vary</name>
                            - <name>name</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <if>if <condition>(<expr>!<call><name>apr_file_remove</name><argument_list>(<argument><expr><name>nextpath</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                        <expr_stmt><expr>(*<name>nodes</name>)--</expr>;</expr_stmt>
                    }</block></then></if>
                }</block></then></if>

            }</block></then>
            <else>else <block>{
                <break>break;</break>
            }</block></else></if>
            <expr_stmt><expr><name>end</name> = <call><name>strrchr</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr>'/'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></while>
    }</block></then></if>

    <expr_stmt><expr><call><name>apr_pool_destroy</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr><name>benice</name></expr>)</condition><then> <block>{
        <if>if <condition>(<expr>++<name>delcount</name> &gt;= <name>DELETE_NICE</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>apr_sleep</name><argument_list>(<argument><expr><name>NICE_DELAY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>delcount</name> = 0</expr>;</expr_stmt>
        }</block></then></if>
    }</block></then></if>

}</block></function>

<comment type="block">/*
 * delete a single file
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>delete_file</name><parameter_list>(<param><decl><type><name>char</name> *</type><name>path</name></decl></param>, <param><decl><type><name>char</name> *</type><name>basename</name></decl></param>, <param><decl><type><name>apr_off_t</name> *</type><name>nodes</name></decl></param>,
        <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>char</name> *</type><name>nextpath</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>p</name></decl>;</decl_stmt>

    <comment type="block">/* temp pool, otherwise lots of memory could be allocated */</comment>
    <expr_stmt><expr><call><name>apr_pool_create</name><argument_list>(<argument><expr>&amp;<name>p</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>nextpath</name> = <call><name>apr_pstrcat</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr>"/"</expr></argument>, <argument><expr><name>basename</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr><name>dryrun</name></expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name>apr_finfo_t</name></type> <name>finfo</name></decl>;</decl_stmt>
        <if>if <condition>(<expr>!<call><name>apr_stat</name><argument_list>(<argument><expr>&amp;<name>finfo</name></expr></argument>, <argument><expr><name>nextpath</name></expr></argument>, <argument><expr><name>APR_FINFO_NLINK</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <expr_stmt><expr>(*<name>nodes</name>)--</expr>;</expr_stmt>
        }</block></then></if>
    }</block></then>
    <else>else <if>if <condition>(<expr>!<call><name>apr_file_remove</name><argument_list>(<argument><expr><name>nextpath</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr>(*<name>nodes</name>)--</expr>;</expr_stmt>
    }</block></then></if></else></if>

    <expr_stmt><expr><call><name>apr_pool_destroy</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr><name>benice</name></expr>)</condition><then> <block>{
        <if>if <condition>(<expr>++<name>delcount</name> &gt;= <name>DELETE_NICE</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>apr_sleep</name><argument_list>(<argument><expr><name>NICE_DELAY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>delcount</name> = 0</expr>;</expr_stmt>
        }</block></then></if>
    }</block></then></if>

    <expr_stmt><expr><call><name>delete_parent</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>basename</name></expr></argument>, <argument><expr><name>nodes</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

}</block></function>

<comment type="block">/*
 * delete cache file set
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>delete_entry</name><parameter_list>(<param><decl><type><name>char</name> *</type><name>path</name></decl></param>, <param><decl><type><name>char</name> *</type><name>basename</name></decl></param>, <param><decl><type><name>apr_off_t</name> *</type><name>nodes</name></decl></param>,
        <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>char</name> *</type><name>nextpath</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>p</name></decl>;</decl_stmt>

    <comment type="block">/* temp pool, otherwise lots of memory could be allocated */</comment>
    <expr_stmt><expr><call><name>apr_pool_create</name><argument_list>(<argument><expr>&amp;<name>p</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>nextpath</name> = <call><name>apr_pstrcat</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr>"/"</expr></argument>, <argument><expr><name>basename</name></expr></argument>, <argument><expr><name>CACHE_HEADER_SUFFIX</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>dryrun</name></expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name>apr_finfo_t</name></type> <name>finfo</name></decl>;</decl_stmt>
        <if>if <condition>(<expr>!<call><name>apr_stat</name><argument_list>(<argument><expr>&amp;<name>finfo</name></expr></argument>, <argument><expr><name>nextpath</name></expr></argument>, <argument><expr><name>APR_FINFO_NLINK</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <expr_stmt><expr>(*<name>nodes</name>)--</expr>;</expr_stmt>
        }</block></then></if>
    }</block></then>
    <else>else <if>if <condition>(<expr>!<call><name>apr_file_remove</name><argument_list>(<argument><expr><name>nextpath</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr>(*<name>nodes</name>)--</expr>;</expr_stmt>
    }</block></then></if></else></if>

    <expr_stmt><expr><name>nextpath</name> = <call><name>apr_pstrcat</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr>"/"</expr></argument>, <argument><expr><name>basename</name></expr></argument>, <argument><expr><name>CACHE_DATA_SUFFIX</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>dryrun</name></expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name>apr_finfo_t</name></type> <name>finfo</name></decl>;</decl_stmt>
        <if>if <condition>(<expr>!<call><name>apr_stat</name><argument_list>(<argument><expr>&amp;<name>finfo</name></expr></argument>, <argument><expr><name>nextpath</name></expr></argument>, <argument><expr><name>APR_FINFO_NLINK</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <expr_stmt><expr>(*<name>nodes</name>)--</expr>;</expr_stmt>
        }</block></then></if>
    }</block></then>
    <else>else <if>if <condition>(<expr>!<call><name>apr_file_remove</name><argument_list>(<argument><expr><name>nextpath</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr>(*<name>nodes</name>)--</expr>;</expr_stmt>
    }</block></then></if></else></if>

    <expr_stmt><expr><call><name>apr_pool_destroy</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr><name>benice</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>delcount</name> += 2</expr>;</expr_stmt>
        <if>if <condition>(<expr><name>delcount</name> &gt;= <name>DELETE_NICE</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>apr_sleep</name><argument_list>(<argument><expr><name>NICE_DELAY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>delcount</name> = 0</expr>;</expr_stmt>
        }</block></then></if>
    }</block></then></if>

    <expr_stmt><expr><call><name>delete_parent</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>basename</name></expr></argument>, <argument><expr><name>nodes</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

}</block></function>

<comment type="block">/*
 * list the cache directory tree
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>list_urls</name><parameter_list>(<param><decl><type><name>char</name> *</type><name>path</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>, <param><decl><type><name>apr_off_t</name></type> <name>round</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>apr_dir_t</name> *</type><name>dir</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_finfo_t</name></type> <name>info</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_size_t</name></type> <name>len</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>p</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_file_t</name> *</type><name>fd</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>ext</name></decl>, *<decl><type ref="prev"/><name>nextpath</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> *</type><name>url</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_uint32_t</name></type> <name>format</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>disk_cache_info_t</name></type> <name>disk_info</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>apr_pool_create</name><argument_list>(<argument><expr>&amp;<name>p</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr><call><name>apr_dir_open</name><argument_list>(<argument><expr>&amp;<name>dir</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call> != <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
        <return>return <expr>1</expr>;</return>
    }</block></then></if>

    <while>while <condition>(<expr><call><name>apr_dir_read</name><argument_list>(<argument><expr>&amp;<name>info</name></expr></argument>, <argument><expr><name>APR_FINFO_TYPE</name></expr></argument>, <argument><expr><name>dir</name></expr></argument>)</argument_list></call> == <name>APR_SUCCESS</name> &amp;&amp; !<name>interrupted</name></expr>)</condition> <block>{

        <if>if <condition>(<expr><name><name>info</name>.<name>filetype</name></name> == <name>APR_DIR</name></expr>)</condition><then> <block>{
            <if>if <condition>(<expr>!<call><name>strcmp</name><argument_list>(<argument><expr><name><name>info</name>.<name>name</name></name></expr></argument>, <argument><expr>"."</expr></argument>)</argument_list></call> || !<call><name>strcmp</name><argument_list>(<argument><expr><name><name>info</name>.<name>name</name></name></expr></argument>, <argument><expr>".."</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <continue>continue;</continue>
            }</block></then></if>

            <if>if <condition>(<expr><call><name>list_urls</name><argument_list>(<argument><expr><call><name>apr_pstrcat</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr>"/"</expr></argument>, <argument><expr><name><name>info</name>.<name>name</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>pool</name></expr></argument>, <argument><expr><name>round</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <return>return <expr>1</expr>;</return>
            }</block></then></if>
        }</block></then>

        <else>else <if>if <condition>(<expr><name><name>info</name>.<name>filetype</name></name> == <name>APR_REG</name></expr>)</condition><then> <block>{

            <expr_stmt><expr><name>ext</name> = <call><name>strchr</name><argument_list>(<argument><expr><name><name>info</name>.<name>name</name></name></expr></argument>, <argument><expr>'.'</expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <if>if <condition>(<expr><name>ext</name> &amp;&amp; !<call><name>strcasecmp</name><argument_list>(<argument><expr><name>ext</name></expr></argument>, <argument><expr><name>CACHE_HEADER_SUFFIX</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{

                <expr_stmt><expr><name>nextpath</name> = <call><name>apr_pstrcat</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr>"/"</expr></argument>, <argument><expr><name><name>info</name>.<name>name</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <if>if <condition>(<expr><call><name>apr_file_open</name><argument_list>(<argument><expr>&amp;<name>fd</name></expr></argument>, <argument><expr><name>nextpath</name></expr></argument>, <argument><expr><name>APR_FOPEN_READ</name>
                        | <name>APR_FOPEN_BINARY</name></expr></argument>, <argument><expr><name>APR_OS_DEFAULT</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call> == <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
                    <expr_stmt><expr><name>len</name> = <sizeof>sizeof<argument_list>(<argument><expr><name>format</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
                    <if>if <condition>(<expr><call><name>apr_file_read_full</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr>&amp;<name>format</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr>&amp;<name>len</name></expr></argument>)</argument_list></call>
                            == <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
                        <if>if <condition>(<expr><name>format</name> == <name>DISK_FORMAT_VERSION</name></expr>)</condition><then> <block>{
                            <decl_stmt><decl><type><name>apr_off_t</name></type> <name>offset</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>

                            <expr_stmt><expr><call><name>apr_file_seek</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>APR_SET</name></expr></argument>, <argument><expr>&amp;<name>offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                            <expr_stmt><expr><name>len</name> = <sizeof>sizeof<argument_list>(<argument><expr><name>disk_cache_info_t</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

                            <if>if <condition>(<expr><call><name>apr_file_read_full</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr>&amp;<name>disk_info</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr>&amp;<name>len</name></expr></argument>)</argument_list></call>
                                    == <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
                                <expr_stmt><expr><name>len</name> = <name><name>disk_info</name>.<name>name_len</name></name></expr>;</expr_stmt>
                                <expr_stmt><expr><name>url</name> = <call><name>apr_palloc</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>len</name> + 1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                <expr_stmt><expr><name><name>url</name><index>[<expr><name>len</name></expr>]</index></name> = 0</expr>;</expr_stmt>

                                <if>if <condition>(<expr><call><name>apr_file_read_full</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>url</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr>&amp;<name>len</name></expr></argument>)</argument_list></call>
                                        == <name>APR_SUCCESS</name></expr>)</condition><then> <block>{

                                    <if>if <condition>(<expr><name>listextended</name></expr>)</condition><then> <block>{
                                        <decl_stmt><decl><type><name>apr_finfo_t</name></type> <name>hinfo</name></decl>, <decl><type ref="prev"/><name>dinfo</name></decl>;</decl_stmt>

                                        <comment type="block">/* stat the header file */</comment>
                                        <if>if <condition>(<expr><name>APR_SUCCESS</name> != <call><name>apr_file_info_get</name><argument_list>(
                                                <argument><expr>&amp;<name>hinfo</name></expr></argument>, <argument><expr><name>APR_FINFO_SIZE</name></expr></argument>, <argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                                            <comment type="block">/* ignore the file */</comment>
                                        }</block></then>
                                        <else>else <if>if <condition>(<expr><name><name>disk_info</name>.<name>has_body</name></name> &amp;&amp; <name>APR_SUCCESS</name>
                                                != <call><name>apr_stat</name><argument_list>(
                                                        <argument><expr>&amp;<name>dinfo</name></expr></argument>,
                                                        <argument><expr><call><name>apr_pstrcat</name><argument_list>(
                                                                <argument><expr><name>p</name></expr></argument>,
                                                                <argument><expr><name>path</name></expr></argument>,
                                                                <argument><expr>"/"</expr></argument>,
                                                                <argument><expr><call><name>apr_pstrndup</name><argument_list>(
                                                                        <argument><expr><name>p</name></expr></argument>,
                                                                        <argument><expr><name><name>info</name>.<name>name</name></name></expr></argument>,
                                                                        <argument><expr><name>ext</name>
                                                                                - <name><name>info</name>.<name>name</name></name></expr></argument>)</argument_list></call></expr></argument>,
                                                                <argument><expr><name>CACHE_DATA_SUFFIX</name></expr></argument>,
                                                                <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></argument>,
                                                        <argument><expr><name>APR_FINFO_SIZE</name>
                                                                | <name>APR_FINFO_IDENT</name></expr></argument>,
                                                        <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                                            <comment type="block">/* ignore the file */</comment>
                                        }</block></then>
                                        <else>else <if>if <condition>(<expr><name><name>disk_info</name>.<name>has_body</name></name> &amp;&amp; (<name><name>dinfo</name>.<name>device</name></name>
                                                != <name><name>disk_info</name>.<name>device</name></name>
                                                || <name><name>dinfo</name>.<name>inode</name></name>
                                                        != <name><name>disk_info</name>.<name>inode</name></name>)</expr>)</condition><then> <block>{
                                            <comment type="block">/* ignore the file */</comment>
                                        }</block></then>
                                        <else>else <block>{

                                            <expr_stmt><expr><call><name>apr_file_printf</name><argument_list>(
                                                    <argument><expr><name>outfile</name></expr></argument>,
                                                    <argument><expr>"%s %" <name>APR_SIZE_T_FMT</name>
                                                    " %" <name>APR_SIZE_T_FMT</name>
                                                    " %d %" <name>APR_SIZE_T_FMT</name>
                                                    " %" <name>APR_TIME_T_FMT</name>
                                                    " %" <name>APR_TIME_T_FMT</name>
                                                    " %" <name>APR_TIME_T_FMT</name>
                                                    " %" <name>APR_TIME_T_FMT</name>
                                                    " %d %d\n"</expr></argument>,
                                                    <argument><expr><name>url</name></expr></argument>,
                                                    <argument><expr><call><name>round_up</name><argument_list>(<argument><expr>(<name>apr_size_t</name>)<name><name>hinfo</name>.<name>size</name></name></expr></argument>, <argument><expr><name>round</name></expr></argument>)</argument_list></call></expr></argument>,
                                                    <argument><expr><call><name>round_up</name><argument_list>(
                                                            <argument><expr><name><name>disk_info</name>.<name>has_body</name></name> ? (<name>apr_size_t</name>)<name><name>dinfo</name>.<name>size</name></name>
                                                                    : 0</expr></argument>, <argument><expr><name>round</name></expr></argument>)</argument_list></call></expr></argument>,
                                                    <argument><expr><name><name>disk_info</name>.<name>status</name></name></expr></argument>,
                                                    <argument><expr><name><name>disk_info</name>.<name>entity_version</name></name></expr></argument>,
                                                    <argument><expr><name><name>disk_info</name>.<name>date</name></name></expr></argument>,
                                                    <argument><expr><name><name>disk_info</name>.<name>expire</name></name></expr></argument>,
                                                    <argument><expr><name><name>disk_info</name>.<name>request_time</name></name></expr></argument>,
                                                    <argument><expr><name><name>disk_info</name>.<name>response_time</name></name></expr></argument>,
                                                    <argument><expr><name><name>disk_info</name>.<name>has_body</name></name></expr></argument>,
                                                    <argument><expr><name><name>disk_info</name>.<name>header_only</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                        }</block></else></if></else></if></else></if>
                                    }</block></then>
                                    <else>else <block>{
                                        <decl_stmt><decl><type><name>apr_finfo_t</name></type> <name>dinfo</name></decl>;</decl_stmt>

                                        <comment type="block">/* stat the data file */</comment>
                                        <if>if <condition>(<expr><name><name>disk_info</name>.<name>has_body</name></name> &amp;&amp; <name>APR_SUCCESS</name>
                                                != <call><name>apr_stat</name><argument_list>(
                                                        <argument><expr>&amp;<name>dinfo</name></expr></argument>,
                                                        <argument><expr><call><name>apr_pstrcat</name><argument_list>(
                                                                <argument><expr><name>p</name></expr></argument>,
                                                                <argument><expr><name>path</name></expr></argument>,
                                                                <argument><expr>"/"</expr></argument>,
                                                                <argument><expr><call><name>apr_pstrndup</name><argument_list>(
                                                                        <argument><expr><name>p</name></expr></argument>,
                                                                        <argument><expr><name><name>info</name>.<name>name</name></name></expr></argument>,
                                                                        <argument><expr><name>ext</name>
                                                                                - <name><name>info</name>.<name>name</name></name></expr></argument>)</argument_list></call></expr></argument>,
                                                                <argument><expr><name>CACHE_DATA_SUFFIX</name></expr></argument>,
                                                                <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></argument>,
                                                        <argument><expr><name>APR_FINFO_SIZE</name>
                                                                | <name>APR_FINFO_IDENT</name></expr></argument>,
                                                        <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                                            <comment type="block">/* ignore the file */</comment>
                                        }</block></then>
                                        <else>else <if>if <condition>(<expr><name><name>disk_info</name>.<name>has_body</name></name> &amp;&amp; (<name><name>dinfo</name>.<name>device</name></name>
                                                != <name><name>disk_info</name>.<name>device</name></name>
                                                || <name><name>dinfo</name>.<name>inode</name></name>
                                                        != <name><name>disk_info</name>.<name>inode</name></name>)</expr>)</condition><then> <block>{
                                            <comment type="block">/* ignore the file */</comment>
                                        }</block></then>
                                        <else>else <block>{
                                            <expr_stmt><expr><call><name>apr_file_printf</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>, <argument><expr>"%s\n"</expr></argument>,
                                                    <argument><expr><name>url</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                        }</block></else></if></else></if>
                                    }</block></else></if>
                                }</block></then></if>

                                <break>break;</break>
                            }</block></then></if>
                        }</block></then></if>
                    }</block></then></if>
                    <expr_stmt><expr><call><name>apr_file_close</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                }</block></then></if>
            }</block></then></if>
        }</block></then></if></else></if>

    }</block></while>

    <expr_stmt><expr><call><name>apr_dir_close</name><argument_list>(<argument><expr><name>dir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr><name>interrupted</name></expr>)</condition><then> <block>{
        <return>return <expr>1</expr>;</return>
    }</block></then></if>

    <expr_stmt><expr><call><name>apr_pool_destroy</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr><name>benice</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>apr_sleep</name><argument_list>(<argument><expr><name>NICE_DELAY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

    <if>if <condition>(<expr><name>interrupted</name></expr>)</condition><then> <block>{
        <return>return <expr>1</expr>;</return>
    }</block></then></if>

    <return>return <expr>0</expr>;</return>
}</block></function>

<comment type="block">/*
 * walk the cache directory tree
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>process_dir</name><parameter_list>(<param><decl><type><name>char</name> *</type><name>path</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>, <param><decl><type><name>apr_off_t</name> *</type><name>nodes</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>apr_dir_t</name> *</type><name>dir</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>p</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_hash_t</name> *</type><name>h</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_hash_index_t</name> *</type><name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_file_t</name> *</type><name>fd</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_status_t</name></type> <name>status</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_finfo_t</name></type> <name>info</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_size_t</name></type> <name>len</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_time_t</name></type> <name>current</name></decl>, <decl><type ref="prev"/><name>deviation</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> *</type><name>nextpath</name></decl>, *<decl><type ref="prev"/><name>base</name></decl>, *<decl><type ref="prev"/><name>ext</name></decl>;</decl_stmt>
    <macro><name>APR_RING_ENTRY</name><argument_list>(<argument>_direntry</argument>)</argument_list></macro> <expr_stmt><expr><name>anchor</name></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>DIRENTRY</name> *</type><name>d</name></decl>, *<decl><type ref="prev"/><name>t</name></decl>, *<decl><type ref="prev"/><name>n</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ENTRY</name> *</type><name>e</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>skip</name></decl>, <decl><type ref="prev"/><name>retries</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>disk_cache_info_t</name></type> <name>disk_info</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>APR_RING_INIT</name><argument_list>(<argument><expr>&amp;<name>anchor</name></expr></argument>, <argument><expr><name>_direntry</name></expr></argument>, <argument><expr><name>link</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>apr_pool_create</name><argument_list>(<argument><expr>&amp;<name>p</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>h</name> = <call><name>apr_hash_make</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>fd</name> = <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>deviation</name> = <name>MAXDEVIATION</name> * <name>APR_USEC_PER_SEC</name></expr>;</expr_stmt>

    <if>if <condition>(<expr><call><name>apr_dir_open</name><argument_list>(<argument><expr>&amp;<name>dir</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call> != <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
        <return>return <expr>1</expr>;</return>
    }</block></then></if>

    <while>while <condition>(<expr><call><name>apr_dir_read</name><argument_list>(<argument><expr>&amp;<name>info</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>dir</name></expr></argument>)</argument_list></call> == <name>APR_SUCCESS</name> &amp;&amp; !<name>interrupted</name></expr>)</condition> <block>{
        <if>if <condition>(<expr>!<call><name>strcmp</name><argument_list>(<argument><expr><name><name>info</name>.<name>name</name></name></expr></argument>, <argument><expr>"."</expr></argument>)</argument_list></call> || !<call><name>strcmp</name><argument_list>(<argument><expr><name><name>info</name>.<name>name</name></name></expr></argument>, <argument><expr>".."</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <continue>continue;</continue>
        }</block></then></if>
        <expr_stmt><expr><name>d</name> = <call><name>apr_pcalloc</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>DIRENTRY</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>d</name>-&gt;<name>basename</name></name> = <call><name>apr_pstrcat</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr>"/"</expr></argument>, <argument><expr><name><name>info</name>.<name>name</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>APR_RING_INSERT_TAIL</name><argument_list>(<argument><expr>&amp;<name>anchor</name></expr></argument>, <argument><expr><name>d</name></expr></argument>, <argument><expr><name>_direntry</name></expr></argument>, <argument><expr><name>link</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr>(*<name>nodes</name>)++</expr>;</expr_stmt>
    }</block></while>

    <expr_stmt><expr><call><name>apr_dir_close</name><argument_list>(<argument><expr><name>dir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr><name>interrupted</name></expr>)</condition><then> <block>{
        <return>return <expr>1</expr>;</return>
    }</block></then></if>

    <expr_stmt><expr><name>skip</name> = <name>baselen</name> + 1</expr>;</expr_stmt>

    <for>for (<init><expr><name>d</name> = <call><name>APR_RING_FIRST</name><argument_list>(<argument><expr>&amp;<name>anchor</name></expr></argument>)</argument_list></call></expr>;</init>
         <condition><expr>!<name>interrupted</name> &amp;&amp; <name>d</name> != <call><name>APR_RING_SENTINEL</name><argument_list>(<argument><expr>&amp;<name>anchor</name></expr></argument>, <argument><expr><name>_direntry</name></expr></argument>, <argument><expr><name>link</name></expr></argument>)</argument_list></call></expr>;</condition>
         <incr><expr><name>d</name>=<name>n</name></expr></incr>) <block>{
        <expr_stmt><expr><name>n</name> = <call><name>APR_RING_NEXT</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr><name>link</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>base</name> = <call><name>strrchr</name><argument_list>(<argument><expr><name><name>d</name>-&gt;<name>basename</name></name></expr></argument>, <argument><expr>'/'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr>!<name>base</name>++</expr>)</condition><then> <block>{
            <expr_stmt><expr><name>base</name> = <name><name>d</name>-&gt;<name>basename</name></name></expr>;</expr_stmt>
        }</block></then></if>
        <expr_stmt><expr><name>ext</name> = <call><name>strchr</name><argument_list>(<argument><expr><name>base</name></expr></argument>, <argument><expr>'.'</expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* there may be temporary files which may be gone before
         * processing, always skip these if not in realclean mode
         */</comment>
        <if>if <condition>(<expr>!<name>ext</name> &amp;&amp; !<name>realclean</name></expr>)</condition><then> <block>{
            <if>if <condition>(<expr>!<call><name>strncasecmp</name><argument_list>(<argument><expr><name>base</name></expr></argument>, <argument><expr><name>AP_TEMPFILE_BASE</name></expr></argument>, <argument><expr><name>AP_TEMPFILE_BASELEN</name></expr></argument>)</argument_list></call>
                &amp;&amp; <call><name>strlen</name><argument_list>(<argument><expr><name>base</name></expr></argument>)</argument_list></call> == <name>AP_TEMPFILE_NAMELEN</name></expr>)</condition><then> <block>{
                <continue>continue;</continue>
            }</block></then></if>
        }</block></then></if>

        <comment type="block">/* this may look strange but apr_stat() may return an error which
         * is system dependent and there may be transient failures,
         * so just blindly retry for a short while
         */</comment>
        <expr_stmt><expr><name>retries</name> = <name>STAT_ATTEMPTS</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>status</name> = <name>APR_SUCCESS</name></expr>;</expr_stmt>
        <do>do <block>{
            <if>if <condition>(<expr><name>status</name> != <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name>apr_sleep</name><argument_list>(<argument><expr><name>STAT_DELAY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>
            <expr_stmt><expr><name>status</name> = <call><name>apr_stat</name><argument_list>(<argument><expr>&amp;<name>info</name></expr></argument>, <argument><expr><name><name>d</name>-&gt;<name>basename</name></name></expr></argument>, <argument><expr><name>DIRINFO</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block> while <condition>(<expr><name>status</name> != <name>APR_SUCCESS</name> &amp;&amp; !<name>interrupted</name> &amp;&amp; --<name>retries</name></expr>)</condition>;</do>

        <comment type="block">/* what may happen here is that apache did create a file which
         * we did detect but then does delete the file before we can
         * get file information, so if we don't get any file information
         * we will ignore the file in this case
         */</comment>
        <if>if <condition>(<expr><name>status</name> != <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
            <if>if <condition>(<expr>!<name>realclean</name> &amp;&amp; !<name>interrupted</name></expr>)</condition><then> <block>{
                <continue>continue;</continue>
            }</block></then></if>
            <return>return <expr>1</expr>;</return>
        }</block></then></if>

        <if>if <condition>(<expr><name><name>info</name>.<name>filetype</name></name> == <name>APR_DIR</name></expr>)</condition><then> <block>{
            <if>if <condition>(<expr><call><name>process_dir</name><argument_list>(<argument><expr><name><name>d</name>-&gt;<name>basename</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>, <argument><expr><name>nodes</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <return>return <expr>1</expr>;</return>
            }</block></then></if>
            <continue>continue;</continue>
        }</block></then></if>

        <if>if <condition>(<expr><name><name>info</name>.<name>filetype</name></name> != <name>APR_REG</name></expr>)</condition><then> <block>{
            <continue>continue;</continue>
        }</block></then></if>

        <if>if <condition>(<expr>!<name>ext</name></expr>)</condition><then> <block>{
            <if>if <condition>(<expr>!<call><name>strncasecmp</name><argument_list>(<argument><expr><name>base</name></expr></argument>, <argument><expr><name>AP_TEMPFILE_BASE</name></expr></argument>, <argument><expr><name>AP_TEMPFILE_BASELEN</name></expr></argument>)</argument_list></call>
                &amp;&amp; <call><name>strlen</name><argument_list>(<argument><expr><name>base</name></expr></argument>)</argument_list></call> == <name>AP_TEMPFILE_NAMELEN</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><name><name>d</name>-&gt;<name>basename</name></name> += <name>skip</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>d</name>-&gt;<name>type</name></name> = <name>TEMP</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>d</name>-&gt;<name>dsize</name></name> = <name><name>info</name>.<name>size</name></name></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>apr_hash_set</name><argument_list>(<argument><expr><name>h</name></expr></argument>, <argument><expr><name><name>d</name>-&gt;<name>basename</name></name></expr></argument>, <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>, <argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>
            <continue>continue;</continue>
        }</block></then></if>

        <if>if <condition>(<expr>!<call><name>strcasecmp</name><argument_list>(<argument><expr><name>ext</name></expr></argument>, <argument><expr><name>CACHE_HEADER_SUFFIX</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <expr_stmt><expr>*<name>ext</name> = '\0'</expr>;</expr_stmt>
            <expr_stmt><expr><name><name>d</name>-&gt;<name>basename</name></name> += <name>skip</name></expr>;</expr_stmt>
            <comment type="block">/* if a user manually creates a '.header' file */</comment>
            <if>if <condition>(<expr><name><name>d</name>-&gt;<name>basename</name><index>[<expr>0</expr>]</index></name> == '\0'</expr>)</condition><then> <block>{
                <continue>continue;</continue>
            }</block></then></if>
            <expr_stmt><expr><name>t</name> = <call><name>apr_hash_get</name><argument_list>(<argument><expr><name>h</name></expr></argument>, <argument><expr><name><name>d</name>-&gt;<name>basename</name></name></expr></argument>, <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr><name>t</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><name>d</name> = <name>t</name></expr>;</expr_stmt>
            }</block></then></if>
            <expr_stmt><expr><name><name>d</name>-&gt;<name>type</name></name> |= <name>HEADER</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>d</name>-&gt;<name>htime</name></name> = <name><name>info</name>.<name>mtime</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>d</name>-&gt;<name>hsize</name></name> = <name><name>info</name>.<name>size</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>apr_hash_set</name><argument_list>(<argument><expr><name>h</name></expr></argument>, <argument><expr><name><name>d</name>-&gt;<name>basename</name></name></expr></argument>, <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>, <argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <continue>continue;</continue>
        }</block></then></if>

        <if>if <condition>(<expr>!<call><name>strcasecmp</name><argument_list>(<argument><expr><name>ext</name></expr></argument>, <argument><expr><name>CACHE_DATA_SUFFIX</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <expr_stmt><expr>*<name>ext</name> = '\0'</expr>;</expr_stmt>
            <expr_stmt><expr><name><name>d</name>-&gt;<name>basename</name></name> += <name>skip</name></expr>;</expr_stmt>
            <comment type="block">/* if a user manually creates a '.data' file */</comment>
            <if>if <condition>(<expr><name><name>d</name>-&gt;<name>basename</name><index>[<expr>0</expr>]</index></name> == '\0'</expr>)</condition><then> <block>{
                <continue>continue;</continue>
            }</block></then></if>
            <expr_stmt><expr><name>t</name> = <call><name>apr_hash_get</name><argument_list>(<argument><expr><name>h</name></expr></argument>, <argument><expr><name><name>d</name>-&gt;<name>basename</name></name></expr></argument>, <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr><name>t</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><name>d</name> = <name>t</name></expr>;</expr_stmt>
            }</block></then></if>
            <expr_stmt><expr><name><name>d</name>-&gt;<name>type</name></name> |= <name>DATA</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>d</name>-&gt;<name>dtime</name></name> = <name><name>info</name>.<name>mtime</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>d</name>-&gt;<name>dsize</name></name> = <name><name>info</name>.<name>size</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>apr_hash_set</name><argument_list>(<argument><expr><name>h</name></expr></argument>, <argument><expr><name><name>d</name>-&gt;<name>basename</name></name></expr></argument>, <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>, <argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
    }</block></for>

    <if>if <condition>(<expr><name>interrupted</name></expr>)</condition><then> <block>{
        <return>return <expr>1</expr>;</return>
    }</block></then></if>

    <expr_stmt><expr><name><name>path</name><index>[<expr><name>baselen</name></expr>]</index></name> = '\0'</expr>;</expr_stmt>

    <for>for (<init><expr><name>i</name> = <call><name>apr_hash_first</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>h</name></expr></argument>)</argument_list></call></expr>;</init> <condition><expr><name>i</name> &amp;&amp; !<name>interrupted</name></expr>;</condition> <incr><expr><name>i</name> = <call><name>apr_hash_next</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></incr>) <block>{
        <decl_stmt><decl><type><name>void</name> *</type><name>hvalue</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>apr_uint32_t</name></type> <name>format</name></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>apr_hash_this</name><argument_list>(<argument><expr><name>i</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr>&amp;<name>hvalue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>d</name> = <name>hvalue</name></expr>;</expr_stmt>

        <switch>switch<condition>(<expr><name><name>d</name>-&gt;<name>type</name></name></expr>)</condition> <block>{
        <case>case <expr><name>HEADERDATA</name></expr>:
            <expr_stmt><expr><name>nextpath</name> = <call><name>apr_pstrcat</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr>"/"</expr></argument>, <argument><expr><name><name>d</name>-&gt;<name>basename</name></name></expr></argument>,
                                   <argument><expr><name>CACHE_HEADER_SUFFIX</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr><call><name>apr_file_open</name><argument_list>(<argument><expr>&amp;<name>fd</name></expr></argument>, <argument><expr><name>nextpath</name></expr></argument>, <argument><expr><name>APR_FOPEN_READ</name> | <name>APR_FOPEN_BINARY</name></expr></argument>,
                              <argument><expr><name>APR_OS_DEFAULT</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call> == <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><name>len</name> = <sizeof>sizeof<argument_list>(<argument><expr><name>format</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
                <if>if <condition>(<expr><call><name>apr_file_read_full</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr>&amp;<name>format</name></expr></argument>, <argument><expr><name>len</name></expr></argument>,
                                       <argument><expr>&amp;<name>len</name></expr></argument>)</argument_list></call> == <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
                    <if>if <condition>(<expr><name>format</name> == <name>DISK_FORMAT_VERSION</name></expr>)</condition><then> <block>{
                        <decl_stmt><decl><type><name>apr_off_t</name></type> <name>offset</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>

                        <expr_stmt><expr><call><name>apr_file_seek</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>APR_SET</name></expr></argument>, <argument><expr>&amp;<name>offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                        <expr_stmt><expr><name>len</name> = <sizeof>sizeof<argument_list>(<argument><expr><name>disk_cache_info_t</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

                        <if>if <condition>(<expr><call><name>apr_file_read_full</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr>&amp;<name>disk_info</name></expr></argument>, <argument><expr><name>len</name></expr></argument>,
                                               <argument><expr>&amp;<name>len</name></expr></argument>)</argument_list></call> == <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
                            <expr_stmt><expr><call><name>apr_file_close</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <expr_stmt><expr><name>e</name> = <call><name>apr_palloc</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ENTRY</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <expr_stmt><expr><call><name>APR_RING_INSERT_TAIL</name><argument_list>(<argument><expr>&amp;<name>root</name></expr></argument>, <argument><expr><name>e</name></expr></argument>, <argument><expr><name>_entry</name></expr></argument>, <argument><expr><name>link</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <expr_stmt><expr><name><name>e</name>-&gt;<name>expire</name></name> = <name><name>disk_info</name>.<name>expire</name></name></expr>;</expr_stmt>
                            <expr_stmt><expr><name><name>e</name>-&gt;<name>response_time</name></name> = <name><name>disk_info</name>.<name>response_time</name></name></expr>;</expr_stmt>
                            <expr_stmt><expr><name><name>e</name>-&gt;<name>htime</name></name> = <name><name>d</name>-&gt;<name>htime</name></name></expr>;</expr_stmt>
                            <expr_stmt><expr><name><name>e</name>-&gt;<name>dtime</name></name> = <name><name>d</name>-&gt;<name>dtime</name></name></expr>;</expr_stmt>
                            <expr_stmt><expr><name><name>e</name>-&gt;<name>hsize</name></name> = <name><name>d</name>-&gt;<name>hsize</name></name></expr>;</expr_stmt>
                            <expr_stmt><expr><name><name>e</name>-&gt;<name>dsize</name></name> = <name><name>d</name>-&gt;<name>dsize</name></name></expr>;</expr_stmt>
                            <expr_stmt><expr><name><name>e</name>-&gt;<name>basename</name></name> = <call><name>apr_pstrdup</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name><name>d</name>-&gt;<name>basename</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <if>if <condition>(<expr>!<name><name>disk_info</name>.<name>has_body</name></name></expr>)</condition><then> <block>{
                                <expr_stmt><expr><call><name>delete_file</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><call><name>apr_pstrcat</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr>"/"</expr></argument>,
                                        <argument><expr><name><name>d</name>-&gt;<name>basename</name></name></expr></argument>, <argument><expr><name>CACHE_DATA_SUFFIX</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></argument>,
                                        <argument><expr><name>nodes</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            }</block></then></if>
                            <break>break;</break>
                        }</block></then>
                        <else>else <block>{
                            <expr_stmt><expr><call><name>apr_file_close</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        }</block></else></if>
                    }</block></then>
                    <else>else <if>if <condition>(<expr><name>format</name> == <name>VARY_FORMAT_VERSION</name></expr>)</condition><then> <block>{
                        <decl_stmt><decl><type><name>apr_finfo_t</name></type> <name>finfo</name></decl>;</decl_stmt>

                        <comment type="block">/* This must be a URL that added Vary headers later,
                         * so kill the orphaned .data file
                         */</comment>
                        <expr_stmt><expr><call><name>apr_file_close</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                        <if>if <condition>(<expr><call><name>apr_stat</name><argument_list>(<argument><expr>&amp;<name>finfo</name></expr></argument>, <argument><expr><call><name>apr_pstrcat</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>nextpath</name></expr></argument>,
                                <argument><expr><name>CACHE_VDIR_SUFFIX</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>APR_FINFO_TYPE</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call>
                                || <name><name>finfo</name>.<name>filetype</name></name> != <name>APR_DIR</name></expr>)</condition><then> <block>{
                            <expr_stmt><expr><call><name>delete_entry</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name><name>d</name>-&gt;<name>basename</name></name></expr></argument>, <argument><expr><name>nodes</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        }</block></then>
                        <else>else <block>{
                            <expr_stmt><expr><call><name>delete_file</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><call><name>apr_pstrcat</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr>"/"</expr></argument>,
                                    <argument><expr><name><name>d</name>-&gt;<name>basename</name></name></expr></argument>, <argument><expr><name>CACHE_DATA_SUFFIX</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></argument>,
                                    <argument><expr><name>nodes</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        }</block></else></if>
                        <break>break;</break>
                    }</block></then>
                    <else>else <block>{
                        <comment type="block">/* We didn't recognise the format, kill the files */</comment>
                        <expr_stmt><expr><call><name>apr_file_close</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><call><name>delete_entry</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name><name>d</name>-&gt;<name>basename</name></name></expr></argument>, <argument><expr><name>nodes</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <break>break;</break>
                    }</block></else></if></else></if>
                }</block></then>
                <else>else <block>{
                    <expr_stmt><expr><call><name>apr_file_close</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></else></if>

            }</block></then></if>
            <comment type="block">/* we have a somehow unreadable headers file which is associated
             * with a data file. this may be caused by apache currently
             * rewriting the headers file. thus we may delete the file set
             * either in realclean mode or if the headers file modification
             * timestamp is not within a specified positive or negative offset
             * to the current time.
             */</comment>
            <expr_stmt><expr><name>current</name> = <call><name>apr_time_now</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr><name>realclean</name> || <name><name>d</name>-&gt;<name>htime</name></name> &lt; <name>current</name> - <name>deviation</name>
                || <name><name>d</name>-&gt;<name>htime</name></name> &gt; <name>current</name> + <name>deviation</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name>delete_entry</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name><name>d</name>-&gt;<name>basename</name></name></expr></argument>, <argument><expr><name>nodes</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>unsolicited</name> += <name><name>d</name>-&gt;<name>hsize</name></name></expr>;</expr_stmt>
                <expr_stmt><expr><name>unsolicited</name> += <name><name>d</name>-&gt;<name>dsize</name></name></expr>;</expr_stmt>
            }</block></then></if>
            <break>break;</break>

        <comment type="block">/* single data and header files may be deleted either in realclean
         * mode or if their modification timestamp is not within a
         * specified positive or negative offset to the current time.
         * this handling is necessary due to possible race conditions
         * between apache and this process
         */</comment>
        </case><case>case <expr><name>HEADER</name></expr>:
            <expr_stmt><expr><name>current</name> = <call><name>apr_time_now</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>nextpath</name> = <call><name>apr_pstrcat</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr>"/"</expr></argument>, <argument><expr><name><name>d</name>-&gt;<name>basename</name></name></expr></argument>,
                                   <argument><expr><name>CACHE_HEADER_SUFFIX</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr><call><name>apr_file_open</name><argument_list>(<argument><expr>&amp;<name>fd</name></expr></argument>, <argument><expr><name>nextpath</name></expr></argument>, <argument><expr><name>APR_FOPEN_READ</name> | <name>APR_FOPEN_BINARY</name></expr></argument>,
                              <argument><expr><name>APR_OS_DEFAULT</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call> == <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><name>len</name> = <sizeof>sizeof<argument_list>(<argument><expr><name>format</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
                <if>if <condition>(<expr><call><name>apr_file_read_full</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr>&amp;<name>format</name></expr></argument>, <argument><expr><name>len</name></expr></argument>,
                                       <argument><expr>&amp;<name>len</name></expr></argument>)</argument_list></call> == <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
                    <if>if <condition>(<expr><name>format</name> == <name>VARY_FORMAT_VERSION</name></expr>)</condition><then> <block>{
                        <decl_stmt><decl><type><name>apr_time_t</name></type> <name>expires</name></decl>;</decl_stmt>

                        <expr_stmt><expr><name>len</name> = <sizeof>sizeof<argument_list>(<argument><expr><name>expires</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

                        <if>if <condition>(<expr><call><name>apr_file_read_full</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr>&amp;<name>expires</name></expr></argument>, <argument><expr><name>len</name></expr></argument>,
                                               <argument><expr>&amp;<name>len</name></expr></argument>)</argument_list></call> == <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
                            <decl_stmt><decl><type><name>apr_finfo_t</name></type> <name>finfo</name></decl>;</decl_stmt>

                            <expr_stmt><expr><call><name>apr_file_close</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                            <if>if <condition>(<expr><call><name>apr_stat</name><argument_list>(<argument><expr>&amp;<name>finfo</name></expr></argument>, <argument><expr><call><name>apr_pstrcat</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>nextpath</name></expr></argument>,
                                    <argument><expr><name>CACHE_VDIR_SUFFIX</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>APR_FINFO_TYPE</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call>
                                    || <name><name>finfo</name>.<name>filetype</name></name> != <name>APR_DIR</name></expr>)</condition><then> <block>{
                                <expr_stmt><expr><call><name>delete_entry</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name><name>d</name>-&gt;<name>basename</name></name></expr></argument>, <argument><expr><name>nodes</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            }</block></then>
                            <else>else <if>if <condition>(<expr><name>expires</name> &lt; <name>current</name></expr>)</condition><then> <block>{
                                <expr_stmt><expr><call><name>delete_entry</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name><name>d</name>-&gt;<name>basename</name></name></expr></argument>, <argument><expr><name>nodes</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            }</block></then></if></else></if>

                            <break>break;</break>
                        }</block></then></if>
                    }</block></then>
                    <else>else <if>if <condition>(<expr><name>format</name> == <name>DISK_FORMAT_VERSION</name></expr>)</condition><then> <block>{
                        <decl_stmt><decl><type><name>apr_off_t</name></type> <name>offset</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>

                        <expr_stmt><expr><call><name>apr_file_seek</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>APR_SET</name></expr></argument>, <argument><expr>&amp;<name>offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                        <expr_stmt><expr><name>len</name> = <sizeof>sizeof<argument_list>(<argument><expr><name>disk_cache_info_t</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

                        <if>if <condition>(<expr><call><name>apr_file_read_full</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr>&amp;<name>disk_info</name></expr></argument>, <argument><expr><name>len</name></expr></argument>,
                                               <argument><expr>&amp;<name>len</name></expr></argument>)</argument_list></call> == <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
                            <expr_stmt><expr><call><name>apr_file_close</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <expr_stmt><expr><name>e</name> = <call><name>apr_palloc</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ENTRY</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <expr_stmt><expr><call><name>APR_RING_INSERT_TAIL</name><argument_list>(<argument><expr>&amp;<name>root</name></expr></argument>, <argument><expr><name>e</name></expr></argument>, <argument><expr><name>_entry</name></expr></argument>, <argument><expr><name>link</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <expr_stmt><expr><name><name>e</name>-&gt;<name>expire</name></name> = <name><name>disk_info</name>.<name>expire</name></name></expr>;</expr_stmt>
                            <expr_stmt><expr><name><name>e</name>-&gt;<name>response_time</name></name> = <name><name>disk_info</name>.<name>response_time</name></name></expr>;</expr_stmt>
                            <expr_stmt><expr><name><name>e</name>-&gt;<name>htime</name></name> = <name><name>d</name>-&gt;<name>htime</name></name></expr>;</expr_stmt>
                            <expr_stmt><expr><name><name>e</name>-&gt;<name>dtime</name></name> = <name><name>d</name>-&gt;<name>dtime</name></name></expr>;</expr_stmt>
                            <expr_stmt><expr><name><name>e</name>-&gt;<name>hsize</name></name> = <name><name>d</name>-&gt;<name>hsize</name></name></expr>;</expr_stmt>
                            <expr_stmt><expr><name><name>e</name>-&gt;<name>dsize</name></name> = <name><name>d</name>-&gt;<name>dsize</name></name></expr>;</expr_stmt>
                            <expr_stmt><expr><name><name>e</name>-&gt;<name>basename</name></name> = <call><name>apr_pstrdup</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name><name>d</name>-&gt;<name>basename</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <break>break;</break>
                        }</block></then>
                        <else>else <block>{
                            <expr_stmt><expr><call><name>apr_file_close</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        }</block></else></if>
                    }</block></then>
                    <else>else <block>{
                        <expr_stmt><expr><call><name>apr_file_close</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><call><name>delete_entry</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name><name>d</name>-&gt;<name>basename</name></name></expr></argument>, <argument><expr><name>nodes</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <break>break;</break>
                    }</block></else></if></else></if>
                }</block></then>
                <else>else <block>{
                    <expr_stmt><expr><call><name>apr_file_close</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></else></if>
            }</block></then></if>

            <if>if <condition>(<expr><name>realclean</name> || <name><name>d</name>-&gt;<name>htime</name></name> &lt; <name>current</name> - <name>deviation</name>
                || <name><name>d</name>-&gt;<name>htime</name></name> &gt; <name>current</name> + <name>deviation</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name>delete_entry</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name><name>d</name>-&gt;<name>basename</name></name></expr></argument>, <argument><expr><name>nodes</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>unsolicited</name> += <name><name>d</name>-&gt;<name>hsize</name></name></expr>;</expr_stmt>
            }</block></then></if>
            <break>break;</break>

        </case><case>case <expr><name>DATA</name></expr>:
            <expr_stmt><expr><name>current</name> = <call><name>apr_time_now</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr><name>realclean</name> || <name><name>d</name>-&gt;<name>dtime</name></name> &lt; <name>current</name> - <name>deviation</name>
                || <name><name>d</name>-&gt;<name>dtime</name></name> &gt; <name>current</name> + <name>deviation</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name>delete_entry</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name><name>d</name>-&gt;<name>basename</name></name></expr></argument>, <argument><expr><name>nodes</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>unsolicited</name> += <name><name>d</name>-&gt;<name>dsize</name></name></expr>;</expr_stmt>
            }</block></then></if>
            <break>break;</break>

        <comment type="block">/* temp files may only be deleted in realclean mode which
         * is asserted above if a tempfile is in the hash array
         */</comment>
        </case><case>case <expr><name>TEMP</name></expr>:
            <expr_stmt><expr><call><name>delete_file</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name><name>d</name>-&gt;<name>basename</name></name></expr></argument>, <argument><expr><name>nodes</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>unsolicited</name> += <name><name>d</name>-&gt;<name>dsize</name></name></expr>;</expr_stmt>
            <break>break;</break>
        </case>}</block></switch>
    }</block></for>

    <if>if <condition>(<expr><name>interrupted</name></expr>)</condition><then> <block>{
        <return>return <expr>1</expr>;</return>
    }</block></then></if>

    <expr_stmt><expr><call><name>apr_pool_destroy</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr><name>benice</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>apr_sleep</name><argument_list>(<argument><expr><name>NICE_DELAY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

    <if>if <condition>(<expr><name>interrupted</name></expr>)</condition><then> <block>{
        <return>return <expr>1</expr>;</return>
    }</block></then></if>

    <return>return <expr>0</expr>;</return>
}</block></function>

<comment type="block">/*
 * purge cache entries
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>purge</name><parameter_list>(<param><decl><type><name>char</name> *</type><name>path</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>, <param><decl><type><name>apr_off_t</name></type> <name>max</name></decl></param>,
        <param><decl><type><name>apr_off_t</name></type> <name>inodes</name></decl></param>, <param><decl><type><name>apr_off_t</name></type> <name>nodes</name></decl></param>, <param><decl><type><name>apr_off_t</name></type> <name>round</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>ENTRY</name> *</type><name>e</name></decl>, *<decl><type ref="prev"/><name>n</name></decl>, *<decl><type ref="prev"/><name>oldest</name></decl>;</decl_stmt>

    <decl_stmt><decl><type>struct <name>stats</name></type> <name>s</name></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>s</name>.<name>sum</name></name> = 0</expr>;</expr_stmt>
    <expr_stmt><expr><name><name>s</name>.<name>entries</name></name> = 0</expr>;</expr_stmt>
    <expr_stmt><expr><name><name>s</name>.<name>dfuture</name></name> = 0</expr>;</expr_stmt>
    <expr_stmt><expr><name><name>s</name>.<name>dexpired</name></name> = 0</expr>;</expr_stmt>
    <expr_stmt><expr><name><name>s</name>.<name>dfresh</name></name> = 0</expr>;</expr_stmt>
    <expr_stmt><expr><name><name>s</name>.<name>max</name></name> = <name>max</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>s</name>.<name>nodes</name></name> = <name>nodes</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>s</name>.<name>inodes</name></name> = <name>inodes</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>s</name>.<name>ntotal</name></name> = <name>nodes</name></expr>;</expr_stmt>

    <for>for (<init><expr><name>e</name> = <call><name>APR_RING_FIRST</name><argument_list>(<argument><expr>&amp;<name>root</name></expr></argument>)</argument_list></call></expr>;</init>
         <condition><expr><name>e</name> != <call><name>APR_RING_SENTINEL</name><argument_list>(<argument><expr>&amp;<name>root</name></expr></argument>, <argument><expr><name>_entry</name></expr></argument>, <argument><expr><name>link</name></expr></argument>)</argument_list></call></expr>;</condition>
         <incr><expr><name>e</name> = <call><name>APR_RING_NEXT</name><argument_list>(<argument><expr><name>e</name></expr></argument>, <argument><expr><name>link</name></expr></argument>)</argument_list></call></expr></incr>) <block>{
        <expr_stmt><expr><name><name>s</name>.<name>sum</name></name> += <call><name>round_up</name><argument_list>(<argument><expr>(<name>apr_size_t</name>)<name><name>e</name>-&gt;<name>hsize</name></name></expr></argument>, <argument><expr><name>round</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>s</name>.<name>sum</name></name> += <call><name>round_up</name><argument_list>(<argument><expr>(<name>apr_size_t</name>)<name><name>e</name>-&gt;<name>dsize</name></name></expr></argument>, <argument><expr><name>round</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>s</name>.<name>entries</name></name>++</expr>;</expr_stmt>
    }</block></for>

    <expr_stmt><expr><name><name>s</name>.<name>total</name></name> = <name><name>s</name>.<name>sum</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>s</name>.<name>etotal</name></name> = <name><name>s</name>.<name>entries</name></name></expr>;</expr_stmt>

    <if>if <condition>(<expr>(!<name><name>s</name>.<name>max</name></name> || <name><name>s</name>.<name>sum</name></name> &lt;= <name><name>s</name>.<name>max</name></name>) &amp;&amp; (!<name><name>s</name>.<name>inodes</name></name> || <name><name>s</name>.<name>nodes</name></name> &lt;= <name><name>s</name>.<name>inodes</name></name>)</expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>printstats</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr>&amp;<name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return;</return>
    }</block></then></if>

    <comment type="block">/* process all entries with a timestamp in the future, this may
     * happen if a wrong system time is corrected
     */</comment>

    <for>for (<init><expr><name>e</name> = <call><name>APR_RING_FIRST</name><argument_list>(<argument><expr>&amp;<name>root</name></expr></argument>)</argument_list></call></expr>;</init>
         <condition><expr><name>e</name> != <call><name>APR_RING_SENTINEL</name><argument_list>(<argument><expr>&amp;<name>root</name></expr></argument>, <argument><expr><name>_entry</name></expr></argument>, <argument><expr><name>link</name></expr></argument>)</argument_list></call> &amp;&amp; !<name>interrupted</name></expr>;</condition><incr/>) <block>{
        <expr_stmt><expr><name>n</name> = <call><name>APR_RING_NEXT</name><argument_list>(<argument><expr><name>e</name></expr></argument>, <argument><expr><name>link</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name><name>e</name>-&gt;<name>response_time</name></name> &gt; <name>now</name> || <name><name>e</name>-&gt;<name>htime</name></name> &gt; <name>now</name> || <name><name>e</name>-&gt;<name>dtime</name></name> &gt; <name>now</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>delete_entry</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name><name>e</name>-&gt;<name>basename</name></name></expr></argument>, <argument><expr>&amp;<name><name>s</name>.<name>nodes</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>s</name>.<name>sum</name></name> -= <call><name>round_up</name><argument_list>(<argument><expr>(<name>apr_size_t</name>)<name><name>e</name>-&gt;<name>hsize</name></name></expr></argument>, <argument><expr><name>round</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>s</name>.<name>sum</name></name> -= <call><name>round_up</name><argument_list>(<argument><expr>(<name>apr_size_t</name>)<name><name>e</name>-&gt;<name>dsize</name></name></expr></argument>, <argument><expr><name>round</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>s</name>.<name>entries</name></name>--</expr>;</expr_stmt>
            <expr_stmt><expr><name><name>s</name>.<name>dfuture</name></name>++</expr>;</expr_stmt>
            <expr_stmt><expr><call><name>APR_RING_REMOVE</name><argument_list>(<argument><expr><name>e</name></expr></argument>, <argument><expr><name>link</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr>(!<name><name>s</name>.<name>max</name></name> || <name><name>s</name>.<name>sum</name></name> &lt;= <name><name>s</name>.<name>max</name></name>) &amp;&amp; (!<name><name>s</name>.<name>inodes</name></name> || <name><name>s</name>.<name>nodes</name></name> &lt;= <name><name>s</name>.<name>inodes</name></name>)</expr>)</condition><then> <block>{
                <if>if <condition>(<expr>!<name>interrupted</name></expr>)</condition><then> <block>{
                    <expr_stmt><expr><call><name>printstats</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr>&amp;<name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></then></if>
                <return>return;</return>
            }</block></then></if>
        }</block></then></if>
        <expr_stmt><expr><name>e</name> = <name>n</name></expr>;</expr_stmt>
    }</block></for>

    <if>if <condition>(<expr><name>interrupted</name></expr>)</condition><then> <block>{
        <return>return;</return>
    }</block></then></if>

    <comment type="block">/* process all entries with are expired */</comment>
    <for>for (<init><expr><name>e</name> = <call><name>APR_RING_FIRST</name><argument_list>(<argument><expr>&amp;<name>root</name></expr></argument>)</argument_list></call></expr>;</init>
         <condition><expr><name>e</name> != <call><name>APR_RING_SENTINEL</name><argument_list>(<argument><expr>&amp;<name>root</name></expr></argument>, <argument><expr><name>_entry</name></expr></argument>, <argument><expr><name>link</name></expr></argument>)</argument_list></call> &amp;&amp; !<name>interrupted</name></expr>;</condition><incr/>) <block>{
        <expr_stmt><expr><name>n</name> = <call><name>APR_RING_NEXT</name><argument_list>(<argument><expr><name>e</name></expr></argument>, <argument><expr><name>link</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name><name>e</name>-&gt;<name>expire</name></name> != <name>APR_DATE_BAD</name> &amp;&amp; <name><name>e</name>-&gt;<name>expire</name></name> &lt; <name>now</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>delete_entry</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name><name>e</name>-&gt;<name>basename</name></name></expr></argument>, <argument><expr>&amp;<name><name>s</name>.<name>nodes</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>s</name>.<name>sum</name></name> -= <call><name>round_up</name><argument_list>(<argument><expr>(<name>apr_size_t</name>)<name><name>e</name>-&gt;<name>hsize</name></name></expr></argument>, <argument><expr><name>round</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>s</name>.<name>sum</name></name> -= <call><name>round_up</name><argument_list>(<argument><expr>(<name>apr_size_t</name>)<name><name>e</name>-&gt;<name>dsize</name></name></expr></argument>, <argument><expr><name>round</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>s</name>.<name>entries</name></name>--</expr>;</expr_stmt>
            <expr_stmt><expr><name><name>s</name>.<name>dexpired</name></name>++</expr>;</expr_stmt>
            <expr_stmt><expr><call><name>APR_RING_REMOVE</name><argument_list>(<argument><expr><name>e</name></expr></argument>, <argument><expr><name>link</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr>(!<name><name>s</name>.<name>max</name></name> || <name><name>s</name>.<name>sum</name></name> &lt;= <name><name>s</name>.<name>max</name></name>) &amp;&amp; (!<name><name>s</name>.<name>inodes</name></name> || <name><name>s</name>.<name>nodes</name></name> &lt;= <name><name>s</name>.<name>inodes</name></name>)</expr>)</condition><then> <block>{
                <if>if <condition>(<expr>!<name>interrupted</name></expr>)</condition><then> <block>{
                    <expr_stmt><expr><call><name>printstats</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr>&amp;<name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></then></if>
                <return>return;</return>
            }</block></then></if>
        }</block></then></if>
        <expr_stmt><expr><name>e</name> = <name>n</name></expr>;</expr_stmt>
    }</block></for>

    <if>if <condition>(<expr><name>interrupted</name></expr>)</condition><then> <block>{
         <return>return;</return>
    }</block></then></if>

    <comment type="block">/* process remaining entries oldest to newest, the check for an empty
     * ring actually isn't necessary except when the compiler does
     * corrupt 64bit arithmetics which happened to me once, so better safe
     * than sorry
     */</comment>
    <while>while <condition>(<expr>!((!<name><name>s</name>.<name>max</name></name> || <name><name>s</name>.<name>sum</name></name> &lt;= <name><name>s</name>.<name>max</name></name>) &amp;&amp; (!<name><name>s</name>.<name>inodes</name></name> || <name><name>s</name>.<name>nodes</name></name> &lt;= <name><name>s</name>.<name>inodes</name></name>))
            &amp;&amp; !<name>interrupted</name> &amp;&amp; !<call><name>APR_RING_EMPTY</name><argument_list>(<argument><expr>&amp;<name>root</name></expr></argument>, <argument><expr><name>_entry</name></expr></argument>, <argument><expr><name>link</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{
        <expr_stmt><expr><name>oldest</name> = <call><name>APR_RING_FIRST</name><argument_list>(<argument><expr>&amp;<name>root</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <for>for (<init><expr><name>e</name> = <call><name>APR_RING_NEXT</name><argument_list>(<argument><expr><name>oldest</name></expr></argument>, <argument><expr><name>link</name></expr></argument>)</argument_list></call></expr>;</init>
             <condition><expr><name>e</name> != <call><name>APR_RING_SENTINEL</name><argument_list>(<argument><expr>&amp;<name>root</name></expr></argument>, <argument><expr><name>_entry</name></expr></argument>, <argument><expr><name>link</name></expr></argument>)</argument_list></call></expr>;</condition>
             <incr><expr><name>e</name> = <call><name>APR_RING_NEXT</name><argument_list>(<argument><expr><name>e</name></expr></argument>, <argument><expr><name>link</name></expr></argument>)</argument_list></call></expr></incr>) <block>{
            <if>if <condition>(<expr><name><name>e</name>-&gt;<name>dtime</name></name> &lt; <name><name>oldest</name>-&gt;<name>dtime</name></name></expr>)</condition><then> <block>{
                <expr_stmt><expr><name>oldest</name> = <name>e</name></expr>;</expr_stmt>
            }</block></then></if>
        }</block></for>

        <expr_stmt><expr><call><name>delete_entry</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name><name>oldest</name>-&gt;<name>basename</name></name></expr></argument>, <argument><expr>&amp;<name><name>s</name>.<name>nodes</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>s</name>.<name>sum</name></name> -= <call><name>round_up</name><argument_list>(<argument><expr>(<name>apr_size_t</name>)<name><name>oldest</name>-&gt;<name>hsize</name></name></expr></argument>, <argument><expr><name>round</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>s</name>.<name>sum</name></name> -= <call><name>round_up</name><argument_list>(<argument><expr>(<name>apr_size_t</name>)<name><name>oldest</name>-&gt;<name>dsize</name></name></expr></argument>, <argument><expr><name>round</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>s</name>.<name>entries</name></name>--</expr>;</expr_stmt>
        <expr_stmt><expr><name><name>s</name>.<name>dfresh</name></name>++</expr>;</expr_stmt>
        <expr_stmt><expr><call><name>APR_RING_REMOVE</name><argument_list>(<argument><expr><name>oldest</name></expr></argument>, <argument><expr><name>link</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></while>

    <if>if <condition>(<expr>!<name>interrupted</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>printstats</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr>&amp;<name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
}</block></function>

<function><type><specifier>static</specifier> <name>apr_status_t</name></type> <name>remove_directory</name><parameter_list>(<param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>dir</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>apr_status_t</name></type> <name>rv</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_dir_t</name> *</type><name>dirp</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_finfo_t</name></type> <name>dirent</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>rv</name> = <call><name>apr_dir_open</name><argument_list>(<argument><expr>&amp;<name>dirp</name></expr></argument>, <argument><expr><name>dir</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><call><name>APR_STATUS_IS_ENOENT</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <return>return <expr><name>rv</name></expr>;</return>
    }</block></then></if>
    <if>if <condition>(<expr><name>rv</name> != <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>apr_file_printf</name><argument_list>(<argument><expr><name>errfile</name></expr></argument>, <argument><expr>"Could not open directory %s: %pm" <name>APR_EOL_STR</name></expr></argument>,
                <argument><expr><name>dir</name></expr></argument>, <argument><expr>&amp;<name>rv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>rv</name></expr>;</return>
    }</block></then></if>

    <while>while <condition>(<expr><call><name>apr_dir_read</name><argument_list>(<argument><expr>&amp;<name>dirent</name></expr></argument>, <argument><expr><name>APR_FINFO_DIRENT</name> | <name>APR_FINFO_TYPE</name></expr></argument>, <argument><expr><name>dirp</name></expr></argument>)</argument_list></call>
            == <name>APR_SUCCESS</name></expr>)</condition> <block>{
        <if>if <condition>(<expr><name><name>dirent</name>.<name>filetype</name></name> == <name>APR_DIR</name></expr>)</condition><then> <block>{
            <if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>dirent</name>.<name>name</name></name></expr></argument>, <argument><expr>"."</expr></argument>)</argument_list></call> &amp;&amp; <call><name>strcmp</name><argument_list>(<argument><expr><name><name>dirent</name>.<name>name</name></name></expr></argument>, <argument><expr>".."</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <expr_stmt><expr><name>rv</name> = <call><name>remove_directory</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><call><name>apr_pstrcat</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>dir</name></expr></argument>, <argument><expr>"/"</expr></argument>,
                        <argument><expr><name><name>dirent</name>.<name>name</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <comment type="block">/* tolerate the directory not being empty, the cache may have
                 * attempted to recreate the directory in the mean time.
                 */</comment>
                <if>if <condition>(<expr><name>APR_SUCCESS</name> != <name>rv</name> &amp;&amp; <name>APR_ENOTEMPTY</name> != <name>rv</name></expr>)</condition><then> <block>{
                    <break>break;</break>
                }</block></then></if>
            }</block></then></if>
        }</block></then> <else>else <block>{
            <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>file</name> <init>= <expr><call><name>apr_pstrcat</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>dir</name></expr></argument>, <argument><expr>"/"</expr></argument>, <argument><expr><name><name>dirent</name>.<name>name</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><name>rv</name> = <call><name>apr_file_remove</name><argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr><name>APR_SUCCESS</name> != <name>rv</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name>apr_file_printf</name><argument_list>(<argument><expr><name>errfile</name></expr></argument>,
                        <argument><expr>"Could not remove file '%s': %pm" <name>APR_EOL_STR</name></expr></argument>, <argument><expr><name>file</name></expr></argument>,
                        <argument><expr>&amp;<name>rv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
            }</block></then></if>
        }</block></else></if>
    }</block></while>

    <expr_stmt><expr><call><name>apr_dir_close</name><argument_list>(<argument><expr><name>dirp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr><name>rv</name> == <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>rv</name> = <call><name>apr_dir_remove</name><argument_list>(<argument><expr><name>dir</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>APR_ENOTEMPTY</name> == <name>rv</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>rv</name> = <name>APR_SUCCESS</name></expr>;</expr_stmt>
        }</block></then></if>
        <if>if <condition>(<expr><name>rv</name> != <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>apr_file_printf</name><argument_list>(<argument><expr><name>errfile</name></expr></argument>, <argument><expr>"Could not remove directory %s: %pm" <name>APR_EOL_STR</name></expr></argument>,
                    <argument><expr><name>dir</name></expr></argument>, <argument><expr>&amp;<name>rv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
    }</block></then></if>

    <return>return <expr><name>rv</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>apr_status_t</name></type> <name>find_directory</name><parameter_list>(<param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>base</name></decl></param>,
        <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>rest</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>apr_status_t</name></type> <name>rv</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_dir_t</name> *</type><name>dirp</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_finfo_t</name></type> <name>dirent</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>found</name> <init>= <expr>0</expr></init>, <name>files</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>header</name> <init>= <expr><call><name>apr_pstrcat</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>rest</name></expr></argument>, <argument><expr><name>CACHE_HEADER_SUFFIX</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>data</name> <init>= <expr><call><name>apr_pstrcat</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>rest</name></expr></argument>, <argument><expr><name>CACHE_DATA_SUFFIX</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>vdir</name> <init>= <expr><call><name>apr_pstrcat</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>rest</name></expr></argument>, <argument><expr><name>CACHE_HEADER_SUFFIX</name></expr></argument>,
            <argument><expr><name>CACHE_VDIR_SUFFIX</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>dirname</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name>rv</name> = <call><name>apr_dir_open</name><argument_list>(<argument><expr>&amp;<name>dirp</name></expr></argument>, <argument><expr><name>base</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>rv</name> != <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>apr_file_printf</name><argument_list>(<argument><expr><name>errfile</name></expr></argument>, <argument><expr>"Could not open directory %s: %pm" <name>APR_EOL_STR</name></expr></argument>,
                <argument><expr><name>base</name></expr></argument>, <argument><expr>&amp;<name>rv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>rv</name></expr>;</return>
    }</block></then></if>

    <expr_stmt><expr><name>rv</name> = <name>APR_ENOENT</name></expr>;</expr_stmt>

    <while>while <condition>(<expr><call><name>apr_dir_read</name><argument_list>(<argument><expr>&amp;<name>dirent</name></expr></argument>, <argument><expr><name>APR_FINFO_DIRENT</name> | <name>APR_FINFO_TYPE</name></expr></argument>, <argument><expr><name>dirp</name></expr></argument>)</argument_list></call>
            == <name>APR_SUCCESS</name></expr>)</condition> <block>{
        <decl_stmt><decl><type><name>int</name></type> <name>len</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name><name>dirent</name>.<name>name</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>restlen</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name>rest</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name><name>dirent</name>.<name>filetype</name></name> == <name>APR_DIR</name> &amp;&amp; !<call><name>strncmp</name><argument_list>(<argument><expr><name>rest</name></expr></argument>, <argument><expr><name><name>dirent</name>.<name>name</name></name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>dirname</name> = <call><name>apr_pstrcat</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>base</name></expr></argument>, <argument><expr>"/"</expr></argument>, <argument><expr><name><name>dirent</name>.<name>name</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>rv</name> = <call><name>find_directory</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>dirname</name></expr></argument>, <argument><expr><name>rest</name> + (<name>len</name> &lt; <name>restlen</name> ? <name>len</name>
                    : <name>restlen</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr><name>APR_SUCCESS</name> == <name>rv</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><name>found</name> = 1</expr>;</expr_stmt>
            }</block></then></if>
        }</block></then></if>
        <if>if <condition>(<expr><name><name>dirent</name>.<name>filetype</name></name> == <name>APR_DIR</name></expr>)</condition><then> <block>{
            <if>if <condition>(<expr>!<call><name>strcmp</name><argument_list>(<argument><expr><name><name>dirent</name>.<name>name</name></name></expr></argument>, <argument><expr><name>vdir</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <expr_stmt><expr><name>files</name> = 1</expr>;</expr_stmt>
            }</block></then></if>
        }</block></then></if>
        <if>if <condition>(<expr><name><name>dirent</name>.<name>filetype</name></name> == <name>APR_REG</name></expr>)</condition><then> <block>{
            <if>if <condition>(<expr>!<call><name>strcmp</name><argument_list>(<argument><expr><name><name>dirent</name>.<name>name</name></name></expr></argument>, <argument><expr><name>header</name></expr></argument>)</argument_list></call> || !<call><name>strcmp</name><argument_list>(<argument><expr><name><name>dirent</name>.<name>name</name></name></expr></argument>, <argument><expr><name>data</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <expr_stmt><expr><name>files</name> = 1</expr>;</expr_stmt>
            }</block></then></if>
        }</block></then></if>
    }</block></while>

    <expr_stmt><expr><call><name>apr_dir_close</name><argument_list>(<argument><expr><name>dirp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr><name>files</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>rv</name> = <name>APR_SUCCESS</name></expr>;</expr_stmt>
        <if>if <condition>(<expr>!<name>dryrun</name></expr>)</condition><then> <block>{
            <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>remove</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>apr_status_t</name></type> <name>status</name></decl>;</decl_stmt>

            <expr_stmt><expr><name>remove</name> = <call><name>apr_pstrcat</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>base</name></expr></argument>, <argument><expr>"/"</expr></argument>, <argument><expr><name>header</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>status</name> = <call><name>apr_file_remove</name><argument_list>(<argument><expr><name>remove</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr><name>status</name> != <name>APR_SUCCESS</name> &amp;&amp; !<call><name>APR_STATUS_IS_ENOENT</name><argument_list>(<argument><expr><name>status</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name>apr_file_printf</name><argument_list>(<argument><expr><name>errfile</name></expr></argument>, <argument><expr>"Could not remove file %s: %pm" <name>APR_EOL_STR</name></expr></argument>,
                        <argument><expr><name>remove</name></expr></argument>, <argument><expr>&amp;<name>status</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>rv</name> = <name>status</name></expr>;</expr_stmt>
            }</block></then></if>

            <expr_stmt><expr><name>remove</name> = <call><name>apr_pstrcat</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>base</name></expr></argument>, <argument><expr>"/"</expr></argument>, <argument><expr><name>data</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>status</name> = <call><name>apr_file_remove</name><argument_list>(<argument><expr><name>remove</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr><name>status</name> != <name>APR_SUCCESS</name> &amp;&amp; !<call><name>APR_STATUS_IS_ENOENT</name><argument_list>(<argument><expr><name>status</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name>apr_file_printf</name><argument_list>(<argument><expr><name>errfile</name></expr></argument>, <argument><expr>"Could not remove file %s: %pm" <name>APR_EOL_STR</name></expr></argument>,
                        <argument><expr><name>remove</name></expr></argument>, <argument><expr>&amp;<name>status</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>rv</name> = <name>status</name></expr>;</expr_stmt>
            }</block></then></if>

            <expr_stmt><expr><name>status</name> = <call><name>remove_directory</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><call><name>apr_pstrcat</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>base</name></expr></argument>, <argument><expr>"/"</expr></argument>, <argument><expr><name>vdir</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr><name>status</name> != <name>APR_SUCCESS</name> &amp;&amp; !<call><name>APR_STATUS_IS_ENOENT</name><argument_list>(<argument><expr><name>status</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <expr_stmt><expr><name>rv</name> = <name>status</name></expr>;</expr_stmt>
            }</block></then></if>
        }</block></then></if>
    }</block></then></if>

    <comment type="block">/* If asked to delete dirs, do so now. We don't care if it fails.
     * If it fails, it likely means there was something else there.
     */</comment>
    <if>if <condition>(<expr><name>dirname</name> &amp;&amp; <name>deldirs</name> &amp;&amp; !<name>dryrun</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>apr_dir_remove</name><argument_list>(<argument><expr><name>dirname</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

    <if>if <condition>(<expr><name>found</name></expr>)</condition><then> <block>{
        <return>return <expr><name>APR_SUCCESS</name></expr>;</return>
    }</block></then></if>

    <return>return <expr><name>rv</name></expr>;</return>
}</block></function>

<comment type="block">/**
 * Delete a specific URL from the cache.
 */</comment>
<function><type><specifier>static</specifier> <name>apr_status_t</name></type> <name>delete_url</name><parameter_list>(<param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>proxypath</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>url</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>apr_md5_ctx_t</name></type> <name>context</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name><name>digest</name><index>[<expr>16</expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type> <name><name>tmp</name><index>[<expr>23</expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>k</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>x</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name></type> <name><name>enc_table</name><index>[<expr>64</expr>]</index></name> <init>=
            <expr>"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789_@"</expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>apr_md5_init</name><argument_list>(<argument><expr>&amp;<name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>apr_md5_update</name><argument_list>(<argument><expr>&amp;<name>context</name></expr></argument>, <argument><expr>(const <name>unsigned</name> <name>char</name> *) <name>url</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>url</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>apr_md5_final</name><argument_list>(<argument><expr><name>digest</name></expr></argument>, <argument><expr>&amp;<name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* encode 128 bits as 22 characters, using a modified uuencoding
     * the encoding is 3 bytes -&gt; 4 characters* i.e. 128 bits is
     * 5 x 3 bytes + 1 byte -&gt; 5 * 4 characters + 2 characters
     */</comment>
    <for>for (<init><expr><name>i</name> = 0</expr>, <expr><name>k</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; 15</expr>;</condition> <incr><expr><name>i</name> += 3</expr></incr>) <block>{
        <expr_stmt><expr><name>x</name> = (<name><name>digest</name><index>[<expr><name>i</name></expr>]</index></name> &lt;&lt; 16) | (<name><name>digest</name><index>[<expr><name>i</name> + 1</expr>]</index></name> &lt;&lt; 8) | <name><name>digest</name><index>[<expr><name>i</name> + 2</expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>tmp</name><index>[<expr><name>k</name>++</expr>]</index></name> = <name><name>enc_table</name><index>[<expr><name>x</name> &gt;&gt; 18</expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>tmp</name><index>[<expr><name>k</name>++</expr>]</index></name> = <name><name>enc_table</name><index>[<expr>(<name>x</name> &gt;&gt; 12) &amp; 0x3f</expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>tmp</name><index>[<expr><name>k</name>++</expr>]</index></name> = <name><name>enc_table</name><index>[<expr>(<name>x</name> &gt;&gt; 6) &amp; 0x3f</expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>tmp</name><index>[<expr><name>k</name>++</expr>]</index></name> = <name><name>enc_table</name><index>[<expr><name>x</name> &amp; 0x3f</expr>]</index></name></expr>;</expr_stmt>
    }</block></for>

    <comment type="block">/* one byte left */</comment>
    <expr_stmt><expr><name>x</name> = <name><name>digest</name><index>[<expr>15</expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>tmp</name><index>[<expr><name>k</name>++</expr>]</index></name> = <name><name>enc_table</name><index>[<expr><name>x</name> &gt;&gt; 2</expr>]</index></name></expr>;</expr_stmt> <comment type="block">/* use up 6 bits */</comment>
    <expr_stmt><expr><name><name>tmp</name><index>[<expr><name>k</name>++</expr>]</index></name> = <name><name>enc_table</name><index>[<expr>(<name>x</name> &lt;&lt; 4) &amp; 0x3f</expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>tmp</name><index>[<expr><name>k</name></expr>]</index></name> = 0</expr>;</expr_stmt>

    <comment type="block">/* automatically find the directory levels */</comment>
    <return>return <expr><call><name>find_directory</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>proxypath</name></expr></argument>, <argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<comment type="block">/*
 * usage info
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NL</name></cpp:macro> <cpp:value>APR_EOL_STR</cpp:value></cpp:define>
<function><type><specifier>static</specifier> <name>void</name></type> <name>usage</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>error</name></decl></param>)</parameter_list>
<block>{
    <if>if <condition>(<expr><name>error</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>apr_file_printf</name><argument_list>(<argument><expr><name>errfile</name></expr></argument>, <argument><expr>"%s error: %s\n"</expr></argument>, <argument><expr><name>shortname</name></expr></argument>, <argument><expr><name>error</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <macro><name>apr_file_printf</name><argument_list>(<argument>errfile</argument>,
    <argument>"%s -- program for cleaning the disk cache."                             NL
    "Usage: %s [-Dvtrn] -pPATH [-lLIMIT|-LLIMIT] [-PPIDFILE]"                NL
    "       %s [-nti] -dINTERVAL -pPATH [-lLIMIT|-LLIMIT] [-PPIDFILE]"       NL
    "       %s [-Dvt] -pPATH URL ..."                                        NL
                                                                             NL
    "Options:"                                                               NL
    "  -d   Daemonize and repeat cache cleaning every INTERVAL minutes."     NL
    "       This option is mutually exclusive with the -D, -v and -r"        NL
    "       options."                                                        NL
                                                                             NL
    "  -D   Do a dry run and don't delete anything. This option is mutually" NL
    "       exclusive with the -d option. When doing a dry run and deleting" NL
    "       directories with -t, the inodes reported deleted in the stats"   NL
    "       cannot take into account the directories deleted, and will be"   NL
    "       marked as an estimate."                                          NL
                                                                             NL
    "  -v   Be verbose and print statistics. This option is mutually"        NL
    "       exclusive with the -d option."                                   NL
                                                                             NL
    "  -r   Clean thoroughly. This assumes that the Apache web server is "   NL
    "       not running. This option is mutually exclusive with the -d"      NL
    "       option and implies -t."                                          NL
                                                                             NL
    "  -n   Be nice. This causes slower processing in favour of other"       NL
    "       processes."                                                      NL
                                                                             NL
    "  -t   Delete all empty directories. By default only cache files are"   NL
    "       removed, however with some configurations the large number of"   NL
    "       directories created may require attention."                      NL
                                                                             NL
    "  -p   Specify PATH as the root directory of the disk cache."           NL
                                                                             NL
    "  -P   Specify PIDFILE as the file to write the pid to."                NL
                                                                             NL
    "  -R   Specify amount to round sizes up to."                            NL
                                                                             NL
    "  -l   Specify LIMIT as the total disk cache size limit. Attach 'K'"    NL
    "       or 'M' to the number for specifying KBytes or MBytes."           NL
                                                                             NL
    "  -L   Specify LIMIT as the total disk cache inode limit."              NL
                                                                             NL
    "  -i   Be intelligent and run only when there was a modification of"    NL
    "       the disk cache. This option is only possible together with the"  NL
    "       -d option."                                                      NL
                                                                             NL
    "  -a   List the URLs currently stored in the cache. Variants of the"    NL
    "       same URL will be listed once for each variant."                  NL
                                                                             NL
    "  -A   List the URLs currently stored in the cache, along with their"   NL
    "       attributes in the following order: url, header size, body size," NL
    "       status, entity version, date, expiry, request time,"             NL
    "       response time, body present, head request."                      NL
                                                                             NL
    "Should an URL be provided on the command line, the URL will be"         NL
    "deleted from the cache. A reverse proxied URL is made up as follows:"   NL
    "http://&lt;hostname&gt;:&lt;port&gt;&lt;path&gt;?[query]. So, for the path \"/\" on the"  NL
    "host \"localhost\" and port 80, the URL to delete becomes"              NL
    "\"http://localhost:80/?\". Note the '?' in the URL must always be"      NL
    "specified explicitly, whether a query string is present or not."        NL</argument>,
    <argument>shortname</argument>,
    <argument>shortname</argument>,
    <argument>shortname</argument>,
    <argument>shortname</argument>
    )</argument_list></macro><empty_stmt>;</empty_stmt>

    <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>NL</name></cpp:undef>

<function><type><specifier>static</specifier> <name>void</name></type> <name>usage_repeated_arg</name><parameter_list>(<param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>, <param><decl><type><name>char</name></type> <name>option</name></decl></param>)</parameter_list> <block>{
    <expr_stmt><expr><call><name>usage</name><argument_list>(<argument><expr><call><name>apr_psprintf</name><argument_list>(<argument><expr><name>pool</name></expr></argument>,
                       <argument><expr>"The option '%c' cannot be specified more than once"</expr></argument>,
                       <argument><expr><name>option</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>log_pid</name><parameter_list>(<param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>pidfilename</name></decl></param>, <param><decl><type><name>apr_file_t</name> **</type><name>pidfile</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>apr_status_t</name></type> <name>status</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>pid_t</name></type> <name>mypid</name> <init>= <expr><call><name>getpid</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr><name>APR_SUCCESS</name> == (<name>status</name> = <call><name>apr_file_open</name><argument_list>(<argument><expr><name>pidfile</name></expr></argument>, <argument><expr><name>pidfilename</name></expr></argument>,
                <argument><expr><name>APR_FOPEN_WRITE</name> | <name>APR_FOPEN_CREATE</name> | <name>APR_FOPEN_TRUNCATE</name> |
                <name>APR_FOPEN_DELONCLOSE</name></expr></argument>, <argument><expr><name>APR_FPROT_UREAD</name> | <name>APR_FPROT_UWRITE</name> |
                <name>APR_FPROT_GREAD</name> | <name>APR_FPROT_WREAD</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call>)</expr>)</condition><then> <block>{
        <macro><name>apr_file_printf</name><argument_list>(<argument>*pidfile</argument>, <argument>"%" APR_PID_T_FMT APR_EOL_STR</argument>, <argument>mypid</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
    }</block></then>
    <else>else <block>{
        <if>if <condition>(<expr><name>errfile</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>apr_file_printf</name><argument_list>(<argument><expr><name>errfile</name></expr></argument>,
                            <argument><expr>"Could not write the pid file '%s': %pm" <name>APR_EOL_STR</name></expr></argument>,
                            <argument><expr><name>pidfilename</name></expr></argument>, <argument><expr>&amp;<name>status</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
        <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>
}</block></function>

<comment type="block">/*
 * main
 */</comment>
<function><type><name>int</name></type> <name>main</name><parameter_list>(<param><decl><type><name>int</name></type> <name>argc</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> * <specifier>const</specifier></type> <name><name>argv</name><index>[]</index></name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>apr_off_t</name></type> <name>max</name></decl>, <decl><type ref="prev"/><name>inodes</name></decl>, <decl><type ref="prev"/><name>round</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_time_t</name></type> <name>current</name></decl>, <decl><type ref="prev"/><name>repeat</name></decl>, <decl><type ref="prev"/><name>delay</name></decl>, <decl><type ref="prev"/><name>previous</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_status_t</name></type> <name>status</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl>, *<decl><type ref="prev"/><name>instance</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_getopt_t</name> *</type><name>o</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_finfo_t</name></type> <name>info</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_file_t</name> *</type><name>pidfile</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>retries</name></decl>, <decl><type ref="prev"/><name>isdaemon</name></decl>, <decl><type ref="prev"/><name>limit_found</name></decl>, <decl><type ref="prev"/><name>inodes_found</name></decl>, <decl><type ref="prev"/><name>intelligent</name></decl>, <decl><type ref="prev"/><name>dowork</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type> <name>opt</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>arg</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> *</type><name>proxypath</name></decl>, *<decl><type ref="prev"/><name>path</name></decl>, *<decl><type ref="prev"/><name>pidfilename</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>interrupted</name> = 0</expr>;</expr_stmt>
    <expr_stmt><expr><name>repeat</name> = 0</expr>;</expr_stmt>
    <expr_stmt><expr><name>isdaemon</name> = 0</expr>;</expr_stmt>
    <expr_stmt><expr><name>dryrun</name> = 0</expr>;</expr_stmt>
    <expr_stmt><expr><name>limit_found</name> = 0</expr>;</expr_stmt>
    <expr_stmt><expr><name>inodes_found</name> = 0</expr>;</expr_stmt>
    <expr_stmt><expr><name>max</name> = 0</expr>;</expr_stmt>
    <expr_stmt><expr><name>inodes</name> = 0</expr>;</expr_stmt>
    <expr_stmt><expr><name>round</name> = 0</expr>;</expr_stmt>
    <expr_stmt><expr><name>verbose</name> = 0</expr>;</expr_stmt>
    <expr_stmt><expr><name>realclean</name> = 0</expr>;</expr_stmt>
    <expr_stmt><expr><name>benice</name> = 0</expr>;</expr_stmt>
    <expr_stmt><expr><name>deldirs</name> = 0</expr>;</expr_stmt>
    <expr_stmt><expr><name>intelligent</name> = 0</expr>;</expr_stmt>
    <expr_stmt><expr><name>previous</name> = 0</expr>;</expr_stmt> <comment type="block">/* avoid compiler warning */</comment>
    <expr_stmt><expr><name>proxypath</name> = <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>pidfilename</name> = <name>NULL</name></expr>;</expr_stmt>

    <if>if <condition>(<expr><call><name>apr_app_initialize</name><argument_list>(<argument><expr>&amp;<name>argc</name></expr></argument>, <argument><expr>&amp;<name>argv</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call> != <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
        <return>return <expr>1</expr>;</return>
    }</block></then></if>
    <expr_stmt><expr><call><name>atexit</name><argument_list>(<argument><expr><name>apr_terminate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr><name>argc</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>shortname</name> = <call><name>apr_filepath_name_get</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

    <if>if <condition>(<expr><call><name>apr_pool_create</name><argument_list>(<argument><expr>&amp;<name>pool</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call> != <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
        <return>return <expr>1</expr>;</return>
    }</block></then></if>
    <expr_stmt><expr><call><name>apr_pool_abort_set</name><argument_list>(<argument><expr><name>oom</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>apr_file_open_stderr</name><argument_list>(<argument><expr>&amp;<name>errfile</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>apr_file_open_stdout</name><argument_list>(<argument><expr>&amp;<name>outfile</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>apr_signal</name><argument_list>(<argument><expr><name>SIGINT</name></expr></argument>, <argument><expr><name>setterm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>apr_signal</name><argument_list>(<argument><expr><name>SIGTERM</name></expr></argument>, <argument><expr><name>setterm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>apr_getopt_init</name><argument_list>(<argument><expr>&amp;<name>o</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>, <argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <while>while <condition>(<expr>1</expr>)</condition> <block>{
        <expr_stmt><expr><name>status</name> = <call><name>apr_getopt</name><argument_list>(<argument><expr><name>o</name></expr></argument>, <argument><expr>"iDnvrtd:l:L:p:P:R:aA"</expr></argument>, <argument><expr>&amp;<name>opt</name></expr></argument>, <argument><expr>&amp;<name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>status</name> == <name>APR_EOF</name></expr>)</condition><then> <block>{
            <break>break;</break>
        }</block></then>
        <else>else <if>if <condition>(<expr><name>status</name> != <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>usage</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then>
        <else>else <block>{
            <decl_stmt><decl><type><name>char</name> *</type><name>end</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>apr_status_t</name></type> <name>rv</name></decl>;</decl_stmt>
            <switch>switch <condition>(<expr><name>opt</name></expr>)</condition> <block>{
            <case>case <expr>'i'</expr>:
                <if>if <condition>(<expr><name>intelligent</name></expr>)</condition><then> <block>{
                    <expr_stmt><expr><call><name>usage_repeated_arg</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>opt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></then></if>
                <expr_stmt><expr><name>intelligent</name> = 1</expr>;</expr_stmt>
                <break>break;</break>

            </case><case>case <expr>'D'</expr>:
                <if>if <condition>(<expr><name>dryrun</name></expr>)</condition><then> <block>{
                    <expr_stmt><expr><call><name>usage_repeated_arg</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>opt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></then></if>
                <expr_stmt><expr><name>dryrun</name> = 1</expr>;</expr_stmt>
                <break>break;</break>

            </case><case>case <expr>'n'</expr>:
                <if>if <condition>(<expr><name>benice</name></expr>)</condition><then> <block>{
                    <expr_stmt><expr><call><name>usage_repeated_arg</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>opt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></then></if>
                <expr_stmt><expr><name>benice</name> = 1</expr>;</expr_stmt>
                <break>break;</break>

            </case><case>case <expr>'t'</expr>:
                <if>if <condition>(<expr><name>deldirs</name></expr>)</condition><then> <block>{
                    <expr_stmt><expr><call><name>usage_repeated_arg</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>opt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></then></if>
                <expr_stmt><expr><name>deldirs</name> = 1</expr>;</expr_stmt>
                <break>break;</break>

            </case><case>case <expr>'v'</expr>:
                <if>if <condition>(<expr><name>verbose</name></expr>)</condition><then> <block>{
                    <expr_stmt><expr><call><name>usage_repeated_arg</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>opt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></then></if>
                <expr_stmt><expr><name>verbose</name> = 1</expr>;</expr_stmt>
                <break>break;</break>

            </case><case>case <expr>'r'</expr>:
                <if>if <condition>(<expr><name>realclean</name></expr>)</condition><then> <block>{
                    <expr_stmt><expr><call><name>usage_repeated_arg</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>opt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></then></if>
                <expr_stmt><expr><name>realclean</name> = 1</expr>;</expr_stmt>
                <expr_stmt><expr><name>deldirs</name> = 1</expr>;</expr_stmt>
                <break>break;</break>

            </case><case>case <expr>'d'</expr>:
                <if>if <condition>(<expr><name>isdaemon</name></expr>)</condition><then> <block>{
                    <expr_stmt><expr><call><name>usage_repeated_arg</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>opt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></then></if>
                <expr_stmt><expr><name>isdaemon</name> = 1</expr>;</expr_stmt>
                <expr_stmt><expr><name>repeat</name> = <call><name>apr_atoi64</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>repeat</name> *= <name>SECS_PER_MIN</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>repeat</name> *= <name>APR_USEC_PER_SEC</name></expr>;</expr_stmt>
                <break>break;</break>

            </case><case>case <expr>'l'</expr>:
                <if>if <condition>(<expr><name>limit_found</name></expr>)</condition><then> <block>{
                    <expr_stmt><expr><call><name>usage_repeated_arg</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>opt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></then></if>
                <expr_stmt><expr><name>limit_found</name> = 1</expr>;</expr_stmt>

                <do>do <block>{
                    <expr_stmt><expr><name>rv</name> = <call><name>apr_strtoff</name><argument_list>(<argument><expr>&amp;<name>max</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>, <argument><expr>&amp;<name>end</name></expr></argument>, <argument><expr>10</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <if>if <condition>(<expr><name>rv</name> == <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
                        <if>if <condition>(<expr>(*<name>end</name> == 'K' || *<name>end</name> == 'k') &amp;&amp; !<name><name>end</name><index>[<expr>1</expr>]</index></name></expr>)</condition><then> <block>{
                            <expr_stmt><expr><name>max</name> *= <name>KBYTE</name></expr>;</expr_stmt>
                        }</block></then>
                        <else>else <if>if <condition>(<expr>(*<name>end</name> == 'M' || *<name>end</name> == 'm') &amp;&amp; !<name><name>end</name><index>[<expr>1</expr>]</index></name></expr>)</condition><then> <block>{
                            <expr_stmt><expr><name>max</name> *= <name>MBYTE</name></expr>;</expr_stmt>
                        }</block></then>
                        <else>else <if>if <condition>(<expr>(*<name>end</name> == 'G' || *<name>end</name> == 'g') &amp;&amp; !<name><name>end</name><index>[<expr>1</expr>]</index></name></expr>)</condition><then> <block>{
                            <expr_stmt><expr><name>max</name> *= <name>GBYTE</name></expr>;</expr_stmt>
                        }</block></then>
                        <else>else <if>if <condition>(<expr>*<name>end</name> &amp;&amp;        <comment type="block">/* neither empty nor [Bb] */</comment>
                                 ((*<name>end</name> != 'B' &amp;&amp; *<name>end</name> != 'b') || <name><name>end</name><index>[<expr>1</expr>]</index></name>)</expr>)</condition><then> <block>{
                            <expr_stmt><expr><name>rv</name> = <name>APR_EGENERAL</name></expr>;</expr_stmt>
                        }</block></then></if></else></if></else></if></else></if>
                    }</block></then></if>
                    <if>if <condition>(<expr><name>rv</name> != <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
                        <expr_stmt><expr><call><name>usage</name><argument_list>(<argument><expr><macro><name>apr_psprintf</name><argument_list>(<argument>pool</argument>, <argument>"Invalid limit: %s"
                                                 APR_EOL_STR APR_EOL_STR</argument>, <argument>arg</argument>)</argument_list></macro></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    }</block></then></if>
                }</block> while<condition>(<expr>0</expr>)</condition>;</do>
                <break>break;</break>

            </case><case>case <expr>'L'</expr>:
                <if>if <condition>(<expr><name>inodes_found</name></expr>)</condition><then> <block>{
                    <expr_stmt><expr><call><name>usage_repeated_arg</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>opt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></then></if>
                <expr_stmt><expr><name>inodes_found</name> = 1</expr>;</expr_stmt>

                <do>do <block>{
                    <expr_stmt><expr><name>rv</name> = <call><name>apr_strtoff</name><argument_list>(<argument><expr>&amp;<name>inodes</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>, <argument><expr>&amp;<name>end</name></expr></argument>, <argument><expr>10</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <if>if <condition>(<expr><name>rv</name> == <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
                        <if>if <condition>(<expr>(*<name>end</name> == 'K' || *<name>end</name> == 'k') &amp;&amp; !<name><name>end</name><index>[<expr>1</expr>]</index></name></expr>)</condition><then> <block>{
                            <expr_stmt><expr><name>inodes</name> *= <name>KBYTE</name></expr>;</expr_stmt>
                        }</block></then>
                        <else>else <if>if <condition>(<expr>(*<name>end</name> == 'M' || *<name>end</name> == 'm') &amp;&amp; !<name><name>end</name><index>[<expr>1</expr>]</index></name></expr>)</condition><then> <block>{
                            <expr_stmt><expr><name>inodes</name> *= <name>MBYTE</name></expr>;</expr_stmt>
                        }</block></then>
                        <else>else <if>if <condition>(<expr>(*<name>end</name> == 'G' || *<name>end</name> == 'g') &amp;&amp; !<name><name>end</name><index>[<expr>1</expr>]</index></name></expr>)</condition><then> <block>{
                            <expr_stmt><expr><name>inodes</name> *= <name>GBYTE</name></expr>;</expr_stmt>
                        }</block></then>
                        <else>else <if>if <condition>(<expr>*<name>end</name> &amp;&amp;        <comment type="block">/* neither empty nor [Bb] */</comment>
                                 ((*<name>end</name> != 'B' &amp;&amp; *<name>end</name> != 'b') || <name><name>end</name><index>[<expr>1</expr>]</index></name>)</expr>)</condition><then> <block>{
                            <expr_stmt><expr><name>rv</name> = <name>APR_EGENERAL</name></expr>;</expr_stmt>
                        }</block></then></if></else></if></else></if></else></if>
                    }</block></then></if>
                    <if>if <condition>(<expr><name>rv</name> != <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
                        <expr_stmt><expr><call><name>usage</name><argument_list>(<argument><expr><macro><name>apr_psprintf</name><argument_list>(<argument>pool</argument>, <argument>"Invalid limit: %s"
                                                 APR_EOL_STR APR_EOL_STR</argument>, <argument>arg</argument>)</argument_list></macro></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    }</block></then></if>
                }</block> while<condition>(<expr>0</expr>)</condition>;</do>
                <break>break;</break>

            </case><case>case <expr>'a'</expr>:
                <if>if <condition>(<expr><name>listurls</name></expr>)</condition><then> <block>{
                    <expr_stmt><expr><call><name>usage_repeated_arg</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>opt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></then></if>
                <expr_stmt><expr><name>listurls</name> = 1</expr>;</expr_stmt>
                <break>break;</break>

            </case><case>case <expr>'A'</expr>:
                <if>if <condition>(<expr><name>listurls</name></expr>)</condition><then> <block>{
                    <expr_stmt><expr><call><name>usage_repeated_arg</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>opt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></then></if>
                <expr_stmt><expr><name>listurls</name> = 1</expr>;</expr_stmt>
                <expr_stmt><expr><name>listextended</name> = 1</expr>;</expr_stmt>
                <break>break;</break>

            </case><case>case <expr>'p'</expr>:
                <if>if <condition>(<expr><name>proxypath</name></expr>)</condition><then> <block>{
                    <expr_stmt><expr><call><name>usage_repeated_arg</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>opt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></then></if>
                <expr_stmt><expr><name>proxypath</name> = <call><name>apr_pstrdup</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if>if <condition>(<expr>(<name>status</name> = <call><name>apr_filepath_set</name><argument_list>(<argument><expr><name>proxypath</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call>) != <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
                    <expr_stmt><expr><call><name>usage</name><argument_list>(<argument><expr><call><name>apr_psprintf</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr>"Could not set filepath to '%s': %pm"</expr></argument>,
                                       <argument><expr><name>proxypath</name></expr></argument>, <argument><expr>&amp;<name>status</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></then></if>
                <break>break;</break>

            </case><case>case <expr>'P'</expr>:
                <if>if <condition>(<expr><name>pidfilename</name></expr>)</condition><then> <block>{
                    <expr_stmt><expr><call><name>usage_repeated_arg</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>opt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></then></if>
                <expr_stmt><expr><name>pidfilename</name> = <call><name>apr_pstrdup</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>

            </case><case>case <expr>'R'</expr>:
                <if>if <condition>(<expr><name>round</name></expr>)</condition><then> <block>{
                    <expr_stmt><expr><call><name>usage_repeated_arg</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>opt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></then></if>
                <expr_stmt><expr><name>rv</name> = <call><name>apr_strtoff</name><argument_list>(<argument><expr>&amp;<name>round</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>, <argument><expr>&amp;<name>end</name></expr></argument>, <argument><expr>10</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if>if <condition>(<expr><name>rv</name> == <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
                    <if>if <condition>(<expr>*<name>end</name></expr>)</condition><then> <block>{
                        <expr_stmt><expr><call><name>usage</name><argument_list>(<argument><expr><macro><name>apr_psprintf</name><argument_list>(<argument>pool</argument>, <argument>"Invalid round value: %s"
                                                 APR_EOL_STR APR_EOL_STR</argument>, <argument>arg</argument>)</argument_list></macro></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    }</block></then>
                    <else>else <if>if <condition>(<expr><name>round</name> &lt; 0</expr>)</condition><then> <block>{
                        <expr_stmt><expr><call><name>usage</name><argument_list>(<argument><expr><macro><name>apr_psprintf</name><argument_list>(<argument>pool</argument>, <argument>"Round value must be positive: %s"
                                                 APR_EOL_STR APR_EOL_STR</argument>, <argument>arg</argument>)</argument_list></macro></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    }</block></then></if></else></if>
                }</block></then></if>
                <if>if <condition>(<expr><name>rv</name> != <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
                    <expr_stmt><expr><call><name>usage</name><argument_list>(<argument><expr><macro><name>apr_psprintf</name><argument_list>(<argument>pool</argument>, <argument>"Invalid round value: %s"
                                             APR_EOL_STR APR_EOL_STR</argument>, <argument>arg</argument>)</argument_list></macro></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></then></if>
                <break>break;</break>

            </case>}</block></switch> <comment type="block">/* switch */</comment>
        }</block></else></if></else></if> <comment type="block">/* else */</comment>
    }</block></while> <comment type="block">/* while */</comment>

    <if>if <condition>(<expr><name>argc</name> &lt;= 1</expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>usage</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

    <if>if <condition>(<expr>!<name>proxypath</name></expr>)</condition><then> <block>{
         <expr_stmt><expr><call><name>usage</name><argument_list>(<argument><expr>"Option -p must be specified"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

    <if>if <condition>(<expr><name><name>o</name>-&gt;<name>ind</name></name> &lt; <name>argc</name></expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name>int</name></type> <name>deleted</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>error</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>isdaemon</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>usage</name><argument_list>(<argument><expr>"Option -d cannot be used with URL arguments, aborting"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
        <if>if <condition>(<expr><name>intelligent</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>usage</name><argument_list>(<argument><expr>"Option -i cannot be used with URL arguments, aborting"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
        <if>if <condition>(<expr><name>limit_found</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>usage</name><argument_list>(<argument><expr>"Option -l cannot be used with URL arguments, aborting"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
        <while>while <condition>(<expr><name><name>o</name>-&gt;<name>ind</name></name> &lt; <name>argc</name></expr>)</condition> <block>{
            <expr_stmt><expr><name>status</name> = <call><name>delete_url</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>proxypath</name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><name><name>o</name>-&gt;<name>ind</name></name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr><name>APR_SUCCESS</name> == <name>status</name></expr>)</condition><then> <block>{
                <if>if <condition>(<expr><name>verbose</name></expr>)</condition><then> <block>{
                    <expr_stmt><expr><call><name>apr_file_printf</name><argument_list>(<argument><expr><name>errfile</name></expr></argument>, <argument><expr>"Removed: %s" <name>APR_EOL_STR</name></expr></argument>,
                            <argument><expr><name><name>argv</name><index>[<expr><name><name>o</name>-&gt;<name>ind</name></name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></then></if>
                <expr_stmt><expr><name>deleted</name> = 1</expr>;</expr_stmt>
            }</block></then>
            <else>else <if>if <condition>(<expr><name>APR_ENOENT</name> == <name>status</name></expr>)</condition><then> <block>{
                <if>if <condition>(<expr><name>verbose</name></expr>)</condition><then> <block>{
                    <expr_stmt><expr><call><name>apr_file_printf</name><argument_list>(<argument><expr><name>errfile</name></expr></argument>, <argument><expr>"Not cached: %s" <name>APR_EOL_STR</name></expr></argument>,
                            <argument><expr><name><name>argv</name><index>[<expr><name><name>o</name>-&gt;<name>ind</name></name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></then></if>
            }</block></then>
            <else>else <block>{
                <if>if <condition>(<expr><name>verbose</name></expr>)</condition><then> <block>{
                    <expr_stmt><expr><call><name>apr_file_printf</name><argument_list>(<argument><expr><name>errfile</name></expr></argument>, <argument><expr>"Error while removed: %s" <name>APR_EOL_STR</name></expr></argument>,
                            <argument><expr><name><name>argv</name><index>[<expr><name><name>o</name>-&gt;<name>ind</name></name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></then></if>
                <expr_stmt><expr><name>error</name> = 1</expr>;</expr_stmt>
            }</block></else></if></else></if>
            <expr_stmt><expr><name><name>o</name>-&gt;<name>ind</name></name>++</expr>;</expr_stmt>
        }</block></while>
        <return>return <expr><name>error</name> ? 1 : <name>deleted</name> ? 0 : 2</expr>;</return>
    }</block></then></if>

    <if>if <condition>(<expr><name>isdaemon</name> &amp;&amp; <name>repeat</name> &lt;= 0</expr>)</condition><then> <block>{
         <expr_stmt><expr><call><name>usage</name><argument_list>(<argument><expr>"Option -d must be greater than zero"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

    <if>if <condition>(<expr><name>isdaemon</name> &amp;&amp; (<name>verbose</name> || <name>realclean</name> || <name>dryrun</name> || <name>listurls</name>)</expr>)</condition><then> <block>{
         <expr_stmt><expr><call><name>usage</name><argument_list>(<argument><expr>"Option -d cannot be used with -v, -r, -L or -D"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

    <if>if <condition>(<expr>!<name>isdaemon</name> &amp;&amp; <name>intelligent</name></expr>)</condition><then> <block>{
         <expr_stmt><expr><call><name>usage</name><argument_list>(<argument><expr>"Option -i cannot be used without -d"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

    <if>if <condition>(<expr>!<name>listurls</name> &amp;&amp; <name>max</name> &lt;= 0 &amp;&amp; <name>inodes</name> &lt;= 0</expr>)</condition><then> <block>{
         <expr_stmt><expr><call><name>usage</name><argument_list>(<argument><expr>"At least one of option -l or -L must be greater than zero"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

    <if>if <condition>(<expr><call><name>apr_filepath_get</name><argument_list>(<argument><expr>&amp;<name>path</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call> != <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>usage</name><argument_list>(<argument><expr><call><name>apr_psprintf</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr>"Could not get the filepath: %pm"</expr></argument>, <argument><expr>&amp;<name>status</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <expr_stmt><expr><name>baselen</name> = <call><name>strlen</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr><name>pidfilename</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>log_pid</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>pidfilename</name></expr></argument>, <argument><expr>&amp;<name>pidfile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* before daemonizing, so we
                                               * can report errors
                                               */</comment>
    }</block></then></if>

    <if>if <condition>(<expr><name>listurls</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>list_urls</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>, <argument><expr><name>round</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr>(<name>interrupted</name> != 0)</expr>;</return>
    }</block></then></if>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>DEBUG</name></cpp:ifndef>
    <if>if <condition>(<expr><name>isdaemon</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>apr_file_close</name><argument_list>(<argument><expr><name>errfile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>errfile</name> = <name>NULL</name></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>pidfilename</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>apr_file_close</name><argument_list>(<argument><expr><name>pidfile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* delete original pidfile only in parent */</comment>
        }</block></then></if>
        <expr_stmt><expr><call><name>apr_proc_detach</name><argument_list>(<argument><expr><name>APR_PROC_DETACH_DAEMONIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>pidfilename</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>log_pid</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>pidfilename</name></expr></argument>, <argument><expr>&amp;<name>pidfile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
    }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <do>do <block>{
        <expr_stmt><expr><call><name>apr_pool_create</name><argument_list>(<argument><expr>&amp;<name>instance</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>now</name> = <call><name>apr_time_now</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>APR_RING_INIT</name><argument_list>(<argument><expr>&amp;<name>root</name></expr></argument>, <argument><expr><name>_entry</name></expr></argument>, <argument><expr><name>link</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>delcount</name> = 0</expr>;</expr_stmt>
        <expr_stmt><expr><name>unsolicited</name> = 0</expr>;</expr_stmt>
        <expr_stmt><expr><name>dowork</name> = 0</expr>;</expr_stmt>

        <switch>switch <condition>(<expr><name>intelligent</name></expr>)</condition> <block>{
        <case>case <expr>0</expr>:
            <expr_stmt><expr><name>dowork</name> = 1</expr>;</expr_stmt>
            <break>break;</break>

        </case><case>case <expr>1</expr>:
            <expr_stmt><expr><name>retries</name> = <name>STAT_ATTEMPTS</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>status</name> = <name>APR_SUCCESS</name></expr>;</expr_stmt>

            <do>do <block>{
                <if>if <condition>(<expr><name>status</name> != <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
                    <expr_stmt><expr><call><name>apr_sleep</name><argument_list>(<argument><expr><name>STAT_DELAY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></then></if>
                <expr_stmt><expr><name>status</name> = <call><name>apr_stat</name><argument_list>(<argument><expr>&amp;<name>info</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>APR_FINFO_MTIME</name></expr></argument>, <argument><expr><name>instance</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block> while <condition>(<expr><name>status</name> != <name>APR_SUCCESS</name> &amp;&amp; !<name>interrupted</name> &amp;&amp; --<name>retries</name></expr>)</condition>;</do>

            <if>if <condition>(<expr><name>status</name> == <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><name>previous</name> = <name><name>info</name>.<name>mtime</name></name></expr>;</expr_stmt>
                <expr_stmt><expr><name>intelligent</name> = 2</expr>;</expr_stmt>
            }</block></then></if>
            <expr_stmt><expr><name>dowork</name> = 1</expr>;</expr_stmt>
            <break>break;</break>

        </case><case>case <expr>2</expr>:
            <expr_stmt><expr><name>retries</name> = <name>STAT_ATTEMPTS</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>status</name> = <name>APR_SUCCESS</name></expr>;</expr_stmt>

            <do>do <block>{
                <if>if <condition>(<expr><name>status</name> != <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
                    <expr_stmt><expr><call><name>apr_sleep</name><argument_list>(<argument><expr><name>STAT_DELAY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></then></if>
                <expr_stmt><expr><name>status</name> = <call><name>apr_stat</name><argument_list>(<argument><expr>&amp;<name>info</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>APR_FINFO_MTIME</name></expr></argument>, <argument><expr><name>instance</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block> while <condition>(<expr><name>status</name> != <name>APR_SUCCESS</name> &amp;&amp; !<name>interrupted</name> &amp;&amp; --<name>retries</name></expr>)</condition>;</do>

            <if>if <condition>(<expr><name>status</name> == <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
                <if>if <condition>(<expr><name>previous</name> != <name><name>info</name>.<name>mtime</name></name></expr>)</condition><then> <block>{
                    <expr_stmt><expr><name>dowork</name> = 1</expr>;</expr_stmt>
                }</block></then></if>
                <expr_stmt><expr><name>previous</name> = <name><name>info</name>.<name>mtime</name></name></expr>;</expr_stmt>
                <break>break;</break>
            }</block></then></if>
            <expr_stmt><expr><name>intelligent</name> = 1</expr>;</expr_stmt>
            <expr_stmt><expr><name>dowork</name> = 1</expr>;</expr_stmt>
            <break>break;</break>
        </case>}</block></switch>

        <if>if <condition>(<expr><name>dowork</name> &amp;&amp; !<name>interrupted</name></expr>)</condition><then> <block>{
            <decl_stmt><decl><type><name>apr_off_t</name></type> <name>nodes</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
            <if>if <condition>(<expr>!<call><name>process_dir</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>instance</name></expr></argument>, <argument><expr>&amp;<name>nodes</name></expr></argument>)</argument_list></call> &amp;&amp; !<name>interrupted</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name>purge</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>instance</name></expr></argument>, <argument><expr><name>max</name></expr></argument>, <argument><expr><name>inodes</name></expr></argument>, <argument><expr><name>nodes</name></expr></argument>, <argument><expr><name>round</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then>
            <else>else <if>if <condition>(<expr>!<name>isdaemon</name> &amp;&amp; !<name>interrupted</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name>apr_file_printf</name><argument_list>(<argument><expr><name>errfile</name></expr></argument>, <argument><expr>"An error occurred, cache cleaning "
                                         "aborted." <name>APR_EOL_STR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return <expr>1</expr>;</return>
            }</block></then></if></else></if>

            <if>if <condition>(<expr><name>intelligent</name> &amp;&amp; !<name>interrupted</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><name>retries</name> = <name>STAT_ATTEMPTS</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>status</name> = <name>APR_SUCCESS</name></expr>;</expr_stmt>
                <do>do <block>{
                    <if>if <condition>(<expr><name>status</name> != <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
                        <expr_stmt><expr><call><name>apr_sleep</name><argument_list>(<argument><expr><name>STAT_DELAY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    }</block></then></if>
                    <expr_stmt><expr><name>status</name> = <call><name>apr_stat</name><argument_list>(<argument><expr>&amp;<name>info</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>APR_FINFO_MTIME</name></expr></argument>, <argument><expr><name>instance</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block> while <condition>(<expr><name>status</name> != <name>APR_SUCCESS</name> &amp;&amp; !<name>interrupted</name> &amp;&amp; --<name>retries</name></expr>)</condition>;</do>

                <if>if <condition>(<expr><name>status</name> == <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
                    <expr_stmt><expr><name>previous</name> = <name><name>info</name>.<name>mtime</name></name></expr>;</expr_stmt>
                    <expr_stmt><expr><name>intelligent</name> = 2</expr>;</expr_stmt>
                }</block></then>
                <else>else <block>{
                    <expr_stmt><expr><name>intelligent</name> = 1</expr>;</expr_stmt>
                }</block></else></if>
            }</block></then></if>
        }</block></then></if>

        <expr_stmt><expr><call><name>apr_pool_destroy</name><argument_list>(<argument><expr><name>instance</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>current</name> = <call><name>apr_time_now</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>current</name> &lt; <name>now</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>delay</name> = <name>repeat</name></expr>;</expr_stmt>
        }</block></then>
        <else>else <if>if <condition>(<expr><name>current</name> - <name>now</name> &gt;= <name>repeat</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>delay</name> = <name>repeat</name></expr>;</expr_stmt>
        }</block></then>
        <else>else <block>{
            <expr_stmt><expr><name>delay</name> = <name>now</name> + <name>repeat</name> - <name>current</name></expr>;</expr_stmt>
        }</block></else></if></else></if>

        <comment type="block">/* we can't sleep the whole delay time here apiece as this is racy
         * with respect to interrupt delivery - think about what happens
         * if we have tested for an interrupt, then get scheduled
         * before the apr_sleep() call and while waiting for the cpu
         * we do get an interrupt
         */</comment>
        <if>if <condition>(<expr><name>isdaemon</name></expr>)</condition><then> <block>{
            <while>while <condition>(<expr><name>delay</name> &amp;&amp; !<name>interrupted</name></expr>)</condition> <block>{
                <if>if <condition>(<expr><name>delay</name> &gt; <name>APR_USEC_PER_SEC</name></expr>)</condition><then> <block>{
                    <expr_stmt><expr><call><name>apr_sleep</name><argument_list>(<argument><expr><name>APR_USEC_PER_SEC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>delay</name> -= <name>APR_USEC_PER_SEC</name></expr>;</expr_stmt>
                }</block></then>
                <else>else <block>{
                    <expr_stmt><expr><call><name>apr_sleep</name><argument_list>(<argument><expr><name>delay</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>delay</name> = 0</expr>;</expr_stmt>
                }</block></else></if>
            }</block></while>
        }</block></then></if>
    }</block> while <condition>(<expr><name>isdaemon</name> &amp;&amp; !<name>interrupted</name></expr>)</condition>;</do>

    <if>if <condition>(<expr>!<name>isdaemon</name> &amp;&amp; <name>interrupted</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>apr_file_printf</name><argument_list>(<argument><expr><name>errfile</name></expr></argument>, <argument><expr>"Cache cleaning aborted due to user "
                                 "request." <name>APR_EOL_STR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr>1</expr>;</return>
    }</block></then></if>

    <return>return <expr>0</expr>;</return>
}</block></function>
</unit>
