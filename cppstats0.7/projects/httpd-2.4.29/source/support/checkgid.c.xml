<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C" filename="projects/httpd-2.4.29/support/checkgid.c"><comment type="block">/* Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */</comment>

<comment type="block">/*
 * Given one or more group identifiers on the command line (e.g.,
 * "httpd" or "#-1"), figure out whether they'll be valid for
 * the server to use at run-time.
 *
 * If a groupname isn't found, or we can't setgid() to it, return
 * -1.  If all groups are valid, return 0.
 *
 * This may need to be run as the superuser for the setgid() to
 * succeed; running it as any other user may result in a false
 * negative.
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ap_config.h"</cpp:file></cpp:include>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>APR_HAVE_STDIO_H</name></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdio.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>APR_HAVE_STDLIB_H</name></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdlib.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>APR_HAVE_SYS_TYPES_H</name></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/types.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>HAVE_GRP_H</name></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;grp.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>APR_HAVE_UNISTD_H</name></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;unistd.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><name>int</name></type> <name>main</name><parameter_list>(<param><decl><type><name>int</name></type> <name>argc</name></decl></param>, <param><decl><type><name>char</name> *</type><name><name>argv</name><index>[]</index></name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>result</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>gid_t</name></type> <name>gid</name></decl>;</decl_stmt>
    <decl_stmt><decl><type>struct <name>group</name> *</type><name>grent</name></decl>;</decl_stmt>
    <decl_stmt><decl><type>struct <name>group</name></type> <name>fake_grent</name></decl>;</decl_stmt>

    <comment type="block">/*
     * Assume success. :-)
     */</comment>
    <expr_stmt><expr><name>result</name> = 0</expr>;</expr_stmt>
    <for>for (<init><expr><name>i</name> = 1</expr>;</init> <condition><expr><name>i</name> &lt; <name>argc</name></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>) <block>{
        <decl_stmt><decl><type><name>char</name> *</type><name>arg</name></decl>;</decl_stmt>
        <expr_stmt><expr><name>arg</name> = <name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>

        <comment type="block">/*
         * If it's from a 'Group #-1' statement, get the numeric value
         * and skip the group lookup stuff.
         */</comment>
        <if>if <condition>(<expr>*<name>arg</name> == '#'</expr>)</condition><then> <block>{
            <expr_stmt><expr><name>gid</name> = <call><name>atoi</name><argument_list>(<argument><expr>&amp;<name><name>arg</name><index>[<expr>1</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>fake_grent</name>.<name>gr_gid</name></name> = <name>gid</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>grent</name> = &amp;<name>fake_grent</name></expr>;</expr_stmt>
        }</block></then>
        <else>else <block>{
            <expr_stmt><expr><name>grent</name> = <call><name>getgrnam</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></else></if>

        <comment type="block">/*
         * A NULL return means no such group was found, so we're done
         * with this one.
         */</comment>
        <if>if <condition>(<expr><name>grent</name> == <name>NULL</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr>"%s: group '%s' not found\n"</expr></argument>, <argument><expr><name><name>argv</name><index>[<expr>0</expr>]</index></name></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>result</name> = -1</expr>;</expr_stmt>
        }</block></then>
        <else>else <block>{
            <decl_stmt><decl><type><name>int</name></type> <name>check</name></decl>;</decl_stmt>

            <comment type="block">/*
             * See if we can switch to the numeric GID we have. If so,
             * all well and good; if not, well..
             */</comment>
            <expr_stmt><expr><name>gid</name> = <name><name>grent</name>-&gt;<name>gr_gid</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name>check</name> = <call><name>setgid</name><argument_list>(<argument><expr><name>gid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr><name>check</name> != 0</expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr>"%s: invalid group '%s'\n"</expr></argument>, <argument><expr><name><name>argv</name><index>[<expr>0</expr>]</index></name></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>perror</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>result</name> = -1</expr>;</expr_stmt>
            }</block></then></if>
        }</block></else></if>
    }</block></for>
    <comment type="block">/*
     * Worst-case return value.
     */</comment>
    <return>return <expr><name>result</name></expr>;</return>
}</block></function>
<comment type="block">/*
 * Local Variables:
 * mode: C
 * c-file-style: "bsd"
 * End:
 */</comment>
</unit>
