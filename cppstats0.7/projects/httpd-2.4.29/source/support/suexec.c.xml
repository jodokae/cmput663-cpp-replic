<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C" filename="projects/httpd-2.4.29/support/suexec.c"><comment type="block">/* Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */</comment>

<comment type="block">/*
 * suexec.c -- "Wrapper" support program for suEXEC behaviour for Apache
 *
 ***********************************************************************
 *
 * NOTE! : DO NOT edit this code!!!  Unless you know what you are doing,
 *         editing this code might open up your system in unexpected
 *         ways to would-be crackers.  Every precaution has been taken
 *         to make this code as safe as possible; alter it at your own
 *         risk.
 *
 ***********************************************************************
 *
 *
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"apr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ap_config.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"suexec.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/param.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/stat.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/types.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;time.h&gt;</cpp:file></cpp:include>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>APR_HAVE_UNISTD_H</name></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;unistd.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdio.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdarg.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdlib.h&gt;</cpp:file></cpp:include>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>APR_HAVE_FCNTL_H</name></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;fcntl.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_PWD_H</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;pwd.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_GRP_H</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;grp.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>PATH_MAX</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AP_MAXPATH</name></cpp:macro> <cpp:value>PATH_MAX</cpp:value></cpp:define>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MAXPATHLEN</name></expr></argument>)</argument_list></call></expr></cpp:elif>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AP_MAXPATH</name></cpp:macro> <cpp:value>MAXPATHLEN</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AP_MAXPATH</name></cpp:macro> <cpp:value>8192</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AP_ENVBUF</name></cpp:macro> <cpp:value>256</cpp:value></cpp:define>

<decl_stmt><decl><type><specifier>extern</specifier> <name>char</name> **</type><name>environ</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>FILE</name> *</type><name>log</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> *<specifier>const</specifier></type> <name><name>safe_env_lst</name><index>[]</index></name> <init>=
<expr><block>{
    <comment type="block">/* variable name starts with */</comment>
    <expr>"HTTP_"</expr>,
    <expr>"SSL_"</expr>,

    <comment type="block">/* variable name is */</comment>
    <expr>"AUTH_TYPE="</expr>,
    <expr>"CONTENT_LENGTH="</expr>,
    <expr>"CONTENT_TYPE="</expr>,
    <expr>"CONTEXT_DOCUMENT_ROOT="</expr>,
    <expr>"CONTEXT_PREFIX="</expr>,
    <expr>"DATE_GMT="</expr>,
    <expr>"DATE_LOCAL="</expr>,
    <expr>"DOCUMENT_ARGS="</expr>,
    <expr>"DOCUMENT_NAME="</expr>,
    <expr>"DOCUMENT_PATH_INFO="</expr>,
    <expr>"DOCUMENT_ROOT="</expr>,
    <expr>"DOCUMENT_URI="</expr>,
    <expr>"GATEWAY_INTERFACE="</expr>,
    <expr>"HTTPS="</expr>,
    <expr>"LAST_MODIFIED="</expr>,
    <expr>"PATH_INFO="</expr>,
    <expr>"PATH_TRANSLATED="</expr>,
    <expr>"QUERY_STRING="</expr>,
    <expr>"QUERY_STRING_UNESCAPED="</expr>,
    <expr>"REMOTE_ADDR="</expr>,
    <expr>"REMOTE_HOST="</expr>,
    <expr>"REMOTE_IDENT="</expr>,
    <expr>"REMOTE_PORT="</expr>,
    <expr>"REMOTE_USER="</expr>,
    <expr>"REDIRECT_ERROR_NOTES="</expr>,
    <expr>"REDIRECT_HANDLER="</expr>,
    <expr>"REDIRECT_QUERY_STRING="</expr>,
    <expr>"REDIRECT_REMOTE_USER="</expr>,
    <expr>"REDIRECT_SCRIPT_FILENAME="</expr>,
    <expr>"REDIRECT_STATUS="</expr>,
    <expr>"REDIRECT_URL="</expr>,
    <expr>"REQUEST_METHOD="</expr>,
    <expr>"REQUEST_URI="</expr>,
    <expr>"REQUEST_SCHEME="</expr>,
    <expr>"SCRIPT_FILENAME="</expr>,
    <expr>"SCRIPT_NAME="</expr>,
    <expr>"SCRIPT_URI="</expr>,
    <expr>"SCRIPT_URL="</expr>,
    <expr>"SERVER_ADMIN="</expr>,
    <expr>"SERVER_NAME="</expr>,
    <expr>"SERVER_ADDR="</expr>,
    <expr>"SERVER_PORT="</expr>,
    <expr>"SERVER_PROTOCOL="</expr>,
    <expr>"SERVER_SIGNATURE="</expr>,
    <expr>"SERVER_SOFTWARE="</expr>,
    <expr>"UNIQUE_ID="</expr>,
    <expr>"USER_NAME="</expr>,
    <expr>"TZ="</expr>,
    <expr><name>NULL</name></expr>
}</block></expr></init></decl>;</decl_stmt>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>log_err</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>fmt</name></decl></param>,<param><decl><type>...</type></decl></param>)</parameter_list> 
    __attribute__<parameter_list>(<param/></parameter_list>(format<parameter_list>(<param><decl><type><name>printf</name></type></decl></param>,<param/></parameter_list>1,2</function_decl>)))<empty_stmt>;</empty_stmt>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>log_no_err</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>fmt</name></decl></param>,<param><decl><type>...</type></decl></param>)</parameter_list>  
    __attribute__<parameter_list>(<param/></parameter_list>(format<parameter_list>(<param><decl><type><name>printf</name></type></decl></param>,<param/></parameter_list>1,2</function_decl>)))<empty_stmt>;</empty_stmt>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>err_output</name><parameter_list>(<param><decl><type><name>int</name></type> <name>is_error</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>fmt</name></decl></param>, <param><decl><type><name>va_list</name></type> <name>ap</name></decl></param>)</parameter_list> 
    __attribute__<parameter_list>(<param/></parameter_list>(format<parameter_list>(<param><decl><type><name>printf</name></type></decl></param>,<param/></parameter_list>2,0</function_decl>)))<empty_stmt>;</empty_stmt>

<function><type><specifier>static</specifier> <name>void</name></type> <name>err_output</name><parameter_list>(<param><decl><type><name>int</name></type> <name>is_error</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>fmt</name></decl></param>, <param><decl><type><name>va_list</name></type> <name>ap</name></decl></param>)</parameter_list>
<block>{
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>AP_LOG_EXEC</name></cpp:ifdef>
    <decl_stmt><decl><type><name>time_t</name></type> <name>timevar</name></decl>;</decl_stmt>
    <decl_stmt><decl><type>struct <name>tm</name> *</type><name>lt</name></decl>;</decl_stmt>

    <if>if <condition>(<expr>!<name>log</name></expr>)</condition><then> <block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_LARGEFILE64_SOURCE</name></expr></argument>)</argument_list></call> &amp;&amp; <name>HAVE_FOPEN64</name></expr></cpp:if>
        <if>if <condition>(<expr>(<name>log</name> = <call><name>fopen64</name><argument_list>(<argument><expr><name>AP_LOG_EXEC</name></expr></argument>, <argument><expr>"a"</expr></argument>)</argument_list></call>) == <name>NULL</name></expr>)</condition><then> <block>{
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
        <if>if <condition>(<expr>(<name>log</name> = <call><name>fopen</name><argument_list>(<argument><expr><name>AP_LOG_EXEC</name></expr></argument>, <argument><expr>"a"</expr></argument>)</argument_list></call>) == <name>NULL</name></expr>)</condition><then> <block>{
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
            <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr>"suexec failure: could not open log file\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>perror</name><argument_list>(<argument><expr>"fopen"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
    }</block></then></if>

    <if>if <condition>(<expr><name>is_error</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr>"suexec policy violation: see suexec log for more "
                        "details\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

    <expr_stmt><expr><call><name>time</name><argument_list>(<argument><expr>&amp;<name>timevar</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>lt</name> = <call><name>localtime</name><argument_list>(<argument><expr>&amp;<name>timevar</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>log</name></expr></argument>, <argument><expr>"[%d-%.2d-%.2d %.2d:%.2d:%.2d]: "</expr></argument>,
            <argument><expr><name><name>lt</name>-&gt;<name>tm_year</name></name> + 1900</expr></argument>, <argument><expr><name><name>lt</name>-&gt;<name>tm_mon</name></name> + 1</expr></argument>, <argument><expr><name><name>lt</name>-&gt;<name>tm_mday</name></name></expr></argument>,
            <argument><expr><name><name>lt</name>-&gt;<name>tm_hour</name></name></expr></argument>, <argument><expr><name><name>lt</name>-&gt;<name>tm_min</name></name></expr></argument>, <argument><expr><name><name>lt</name>-&gt;<name>tm_sec</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>vfprintf</name><argument_list>(<argument><expr><name>log</name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>, <argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>fflush</name><argument_list>(<argument><expr><name>log</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* AP_LOG_EXEC */</comment>
    <return>return;</return>
}</block></then></if>

<function><type><specifier>static</specifier> <name>void</name></type> <name>log_err</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>fmt</name></decl></param>,<param><decl><type>...</type></decl></param>)</parameter_list>
<block>{
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>AP_LOG_EXEC</name></cpp:ifdef>
    <decl_stmt><decl><type><name>va_list</name></type> <name>ap</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>err_output</name><argument_list>(<argument><expr>1</expr></argument>, <argument><expr><name>fmt</name></expr></argument>, <argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* 1 == is_error */</comment>
    <expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* AP_LOG_EXEC */</comment>
    <return>return;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>log_no_err</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>fmt</name></decl></param>,<param><decl><type>...</type></decl></param>)</parameter_list>
<block>{
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>AP_LOG_EXEC</name></cpp:ifdef>
    <decl_stmt><decl><type><name>va_list</name></type> <name>ap</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>err_output</name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr><name>fmt</name></expr></argument>, <argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* 0 == !is_error */</comment>
    <expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* AP_LOG_EXEC */</comment>
    <return>return;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>clean_env</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>char</name></type> <name><name>pathbuf</name><index>[<expr>512</expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> **</type><name>cleanenv</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> **</type><name>ep</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>cidx</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>idx</name></decl>;</decl_stmt>

    <comment type="block">/* While cleaning the environment, the environment should be clean.
     * (e.g. malloc() may get the name of a file for writing debugging info.
     * Bad news if MALLOC_DEBUG_FILE is set to /etc/passwd.  Sprintf() may be
     * susceptible to bad locale settings....)
     * (from PR 2790)
     */</comment>
    <decl_stmt><decl><type><name>char</name> **</type><name>envp</name> <init>= <expr><name>environ</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> *</type><name>empty_ptr</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name>environ</name> = &amp;<name>empty_ptr</name></expr>;</expr_stmt> <comment type="block">/* VERY safe environment */</comment>

    <if>if <condition>(<expr>(<name>cleanenv</name> = (<name>char</name> **) <call><name>calloc</name><argument_list>(<argument><expr><name>AP_ENVBUF</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>char</name> *</expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call>) == <name>NULL</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>log_err</name><argument_list>(<argument><expr>"failed to malloc memory for environment\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr>123</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

    <expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>pathbuf</name></expr></argument>, <argument><expr>"PATH=%s"</expr></argument>, <argument><expr><name>AP_SAFE_PATH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cleanenv</name><index>[<expr><name>cidx</name></expr>]</index></name> = <call><name>strdup</name><argument_list>(<argument><expr><name>pathbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name><name>cleanenv</name><index>[<expr><name>cidx</name></expr>]</index></name> == <name>NULL</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>log_err</name><argument_list>(<argument><expr>"failed to malloc memory for environment\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr>124</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <expr_stmt><expr><name>cidx</name>++</expr>;</expr_stmt>

    <for>for (<init><expr><name>ep</name> = <name>envp</name></expr>;</init> <condition><expr>*<name>ep</name> &amp;&amp; <name>cidx</name> &lt; <name>AP_ENVBUF</name>-1</expr>;</condition> <incr><expr><name>ep</name>++</expr></incr>) <block>{
        <for>for (<init><expr><name>idx</name> = 0</expr>;</init> <condition><expr><name><name>safe_env_lst</name><index>[<expr><name>idx</name></expr>]</index></name></expr>;</condition> <incr><expr><name>idx</name>++</expr></incr>) <block>{
            <if>if <condition>(<expr>!<call><name>strncmp</name><argument_list>(<argument><expr>*<name>ep</name></expr></argument>, <argument><expr><name><name>safe_env_lst</name><index>[<expr><name>idx</name></expr>]</index></name></expr></argument>,
                         <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name><name>safe_env_lst</name><index>[<expr><name>idx</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <expr_stmt><expr><name><name>cleanenv</name><index>[<expr><name>cidx</name></expr>]</index></name> = *<name>ep</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>cidx</name>++</expr>;</expr_stmt>
                <break>break;</break>
            }</block></then></if>
        }</block></for>
    }</block></for>

    <expr_stmt><expr><name><name>cleanenv</name><index>[<expr><name>cidx</name></expr>]</index></name> = <name>NULL</name></expr>;</expr_stmt>

    <expr_stmt><expr><name>environ</name> = <name>cleanenv</name></expr>;</expr_stmt>
}</block></function>

<function><type><name>int</name></type> <name>main</name><parameter_list>(<param><decl><type><name>int</name></type> <name>argc</name></decl></param>, <param><decl><type><name>char</name> *</type><name><name>argv</name><index>[]</index></name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>int</name></type> <name>userdir</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>        <comment type="block">/* ~userdir flag             */</comment>
    <decl_stmt><decl><type><name>uid_t</name></type> <name>uid</name></decl>;</decl_stmt>              <comment type="block">/* user information          */</comment>
    <decl_stmt><decl><type><name>gid_t</name></type> <name>gid</name></decl>;</decl_stmt>              <comment type="block">/* target group placeholder  */</comment>
    <decl_stmt><decl><type><name>char</name> *</type><name>target_uname</name></decl>;</decl_stmt>     <comment type="block">/* target user name          */</comment>
    <decl_stmt><decl><type><name>char</name> *</type><name>target_gname</name></decl>;</decl_stmt>     <comment type="block">/* target group name         */</comment>
    <decl_stmt><decl><type><name>char</name> *</type><name>target_homedir</name></decl>;</decl_stmt>   <comment type="block">/* target home directory     */</comment>
    <decl_stmt><decl><type><name>char</name> *</type><name>actual_uname</name></decl>;</decl_stmt>     <comment type="block">/* actual user name          */</comment>
    <decl_stmt><decl><type><name>char</name> *</type><name>actual_gname</name></decl>;</decl_stmt>     <comment type="block">/* actual group name         */</comment>
    <decl_stmt><decl><type><name>char</name> *</type><name>cmd</name></decl>;</decl_stmt>              <comment type="block">/* command to be executed    */</comment>
    <decl_stmt><decl><type><name>char</name></type> <name><name>cwd</name><index>[<expr><name>AP_MAXPATH</name></expr>]</index></name></decl>;</decl_stmt>   <comment type="block">/* current working directory */</comment>
    <decl_stmt><decl><type><name>char</name></type> <name><name>dwd</name><index>[<expr><name>AP_MAXPATH</name></expr>]</index></name></decl>;</decl_stmt>   <comment type="block">/* docroot working directory */</comment>
    <decl_stmt><decl><type>struct <name>passwd</name> *</type><name>pw</name></decl>;</decl_stmt>      <comment type="block">/* password entry holder     */</comment>
    <decl_stmt><decl><type>struct <name>group</name> *</type><name>gr</name></decl>;</decl_stmt>       <comment type="block">/* group entry holder        */</comment>
    <decl_stmt><decl><type>struct <name>stat</name></type> <name>dir_info</name></decl>;</decl_stmt>   <comment type="block">/* directory info holder     */</comment>
    <decl_stmt><decl><type>struct <name>stat</name></type> <name>prg_info</name></decl>;</decl_stmt>   <comment type="block">/* program info holder       */</comment>

    <comment type="block">/*
     * Start with a "clean" environment
     */</comment>
    <expr_stmt><expr><call><name>clean_env</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Check existence/validity of the UID of the user
     * running this program.  Error out if invalid.
     */</comment>
    <expr_stmt><expr><name>uid</name> = <call><name>getuid</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr>(<name>pw</name> = <call><name>getpwuid</name><argument_list>(<argument><expr><name>uid</name></expr></argument>)</argument_list></call>) == <name>NULL</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>log_err</name><argument_list>(<argument><expr>"crit: invalid uid: (%lu)\n"</expr></argument>, <argument><expr>(<name>unsigned</name> <name>long</name>)<name>uid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr>102</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <comment type="block">/*
     * See if this is a 'how were you compiled' request, and
     * comply if so.
     */</comment>
    <if>if <condition>(<expr>(<name>argc</name> &gt; 1)
        &amp;&amp; (! <call><name>strcmp</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr>1</expr>]</index></name></expr></argument>, <argument><expr>"-V"</expr></argument>)</argument_list></call>)
        &amp;&amp; ((<name>uid</name> == 0)
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_OSD_POSIX</name></cpp:ifdef>
        <comment type="block">/* User name comparisons are case insensitive on BS2000/OSD */</comment>
            || (! <call><name>strcasecmp</name><argument_list>(<argument><expr><name>AP_HTTPD_USER</name></expr></argument>, <argument><expr><name><name>pw</name>-&gt;<name>pw_name</name></name></expr></argument>)</argument_list></call>))
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>  <comment type="block">/* _OSD_POSIX */</comment>
            || (! <call><name>strcmp</name><argument_list>(<argument><expr><name>AP_HTTPD_USER</name></expr></argument>, <argument><expr><name><name>pw</name>-&gt;<name>pw_name</name></name></expr></argument>)</argument_list></call>)</expr>)</condition><then/></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* _OSD_POSIX */</comment>
        )</block> <block>{
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>AP_DOC_ROOT</name></cpp:ifdef>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr>" -D AP_DOC_ROOT=\"%s\"\n"</expr></argument>, <argument><expr><name>AP_DOC_ROOT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>AP_GID_MIN</name></cpp:ifdef>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr>" -D AP_GID_MIN=%d\n"</expr></argument>, <argument><expr><name>AP_GID_MIN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>AP_HTTPD_USER</name></cpp:ifdef>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr>" -D AP_HTTPD_USER=\"%s\"\n"</expr></argument>, <argument><expr><name>AP_HTTPD_USER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>AP_LOG_EXEC</name></cpp:ifdef>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr>" -D AP_LOG_EXEC=\"%s\"\n"</expr></argument>, <argument><expr><name>AP_LOG_EXEC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>AP_SAFE_PATH</name></cpp:ifdef>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr>" -D AP_SAFE_PATH=\"%s\"\n"</expr></argument>, <argument><expr><name>AP_SAFE_PATH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>AP_SUEXEC_UMASK</name></cpp:ifdef>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr>" -D AP_SUEXEC_UMASK=%03o\n"</expr></argument>, <argument><expr><name>AP_SUEXEC_UMASK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>AP_UID_MIN</name></cpp:ifdef>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr>" -D AP_UID_MIN=%d\n"</expr></argument>, <argument><expr><name>AP_UID_MIN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>AP_USERDIR_SUFFIX</name></cpp:ifdef>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr>" -D AP_USERDIR_SUFFIX=\"%s\"\n"</expr></argument>, <argument><expr><name>AP_USERDIR_SUFFIX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>
    <comment type="block">/*
     * If there are a proper number of arguments, set
     * all of them to variables.  Otherwise, error out.
     */</comment>
    <if>if <condition>(<expr><name>argc</name> &lt; 4</expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>log_err</name><argument_list>(<argument><expr>"too few arguments\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr>101</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <expr_stmt><expr><name>target_uname</name> = <name><name>argv</name><index>[<expr>1</expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>target_gname</name> = <name><name>argv</name><index>[<expr>2</expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>cmd</name> = <name><name>argv</name><index>[<expr>3</expr>]</index></name></expr>;</expr_stmt>

    <comment type="block">/*
     * Check to see if the user running this program
     * is the user allowed to do so as defined in
     * suexec.h.  If not the allowed user, error out.
     */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_OSD_POSIX</name></cpp:ifdef>
    <comment type="block">/* User name comparisons are case insensitive on BS2000/OSD */</comment>
    <if>if <condition>(<expr><call><name>strcasecmp</name><argument_list>(<argument><expr><name>AP_HTTPD_USER</name></expr></argument>, <argument><expr><name><name>pw</name>-&gt;<name>pw_name</name></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>log_err</name><argument_list>(<argument><expr>"user mismatch (%s instead of %s)\n"</expr></argument>, <argument><expr><name><name>pw</name>-&gt;<name>pw_name</name></name></expr></argument>, <argument><expr><name>AP_HTTPD_USER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr>103</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>  <comment type="block">/*_OSD_POSIX*/</comment>
    <if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>AP_HTTPD_USER</name></expr></argument>, <argument><expr><name><name>pw</name>-&gt;<name>pw_name</name></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>log_err</name><argument_list>(<argument><expr>"user mismatch (%s instead of %s)\n"</expr></argument>, <argument><expr><name><name>pw</name>-&gt;<name>pw_name</name></name></expr></argument>, <argument><expr><name>AP_HTTPD_USER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr>103</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/*_OSD_POSIX*/</comment>

    <comment type="block">/*
     * Check for a leading '/' (absolute path) in the command to be executed,
     * or attempts to back up out of the current directory,
     * to protect against attacks.  If any are
     * found, error out.  Naughty naughty crackers.
     */</comment>
    <if>if <condition>(<expr>(<name><name>cmd</name><index>[<expr>0</expr>]</index></name> == '/') || (!<call><name>strncmp</name><argument_list>(<argument><expr><name>cmd</name></expr></argument>, <argument><expr>"../"</expr></argument>, <argument><expr>3</expr></argument>)</argument_list></call>)
        || (<call><name>strstr</name><argument_list>(<argument><expr><name>cmd</name></expr></argument>, <argument><expr>"/../"</expr></argument>)</argument_list></call> != <name>NULL</name>)</expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>log_err</name><argument_list>(<argument><expr>"invalid command (%s)\n"</expr></argument>, <argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr>104</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

    <comment type="block">/*
     * Check to see if this is a ~userdir request.  If
     * so, set the flag, and remove the '~' from the
     * target username.
     */</comment>
    <if>if <condition>(<expr>!<call><name>strncmp</name><argument_list>(<argument><expr>"~"</expr></argument>, <argument><expr><name>target_uname</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>target_uname</name>++</expr>;</expr_stmt>
        <expr_stmt><expr><name>userdir</name> = 1</expr>;</expr_stmt>
    }</block></then></if>

    <comment type="block">/*
     * Error out if the target username is invalid.
     */</comment>
    <if>if <condition>(<expr><call><name>strspn</name><argument_list>(<argument><expr><name>target_uname</name></expr></argument>, <argument><expr>"1234567890"</expr></argument>)</argument_list></call> != <call><name>strlen</name><argument_list>(<argument><expr><name>target_uname</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <if>if <condition>(<expr>(<name>pw</name> = <call><name>getpwnam</name><argument_list>(<argument><expr><name>target_uname</name></expr></argument>)</argument_list></call>) == <name>NULL</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>log_err</name><argument_list>(<argument><expr>"invalid target user name: (%s)\n"</expr></argument>, <argument><expr><name>target_uname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr>105</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
    }</block></then>
    <else>else <block>{
        <if>if <condition>(<expr>(<name>pw</name> = <call><name>getpwuid</name><argument_list>(<argument><expr><call><name>atoi</name><argument_list>(<argument><expr><name>target_uname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>) == <name>NULL</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>log_err</name><argument_list>(<argument><expr>"invalid target user id: (%s)\n"</expr></argument>, <argument><expr><name>target_uname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr>121</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
    }</block></else></if>

    <comment type="block">/*
     * Error out if the target group name is invalid.
     */</comment>
    <if>if <condition>(<expr><call><name>strspn</name><argument_list>(<argument><expr><name>target_gname</name></expr></argument>, <argument><expr>"1234567890"</expr></argument>)</argument_list></call> != <call><name>strlen</name><argument_list>(<argument><expr><name>target_gname</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <if>if <condition>(<expr>(<name>gr</name> = <call><name>getgrnam</name><argument_list>(<argument><expr><name>target_gname</name></expr></argument>)</argument_list></call>) == <name>NULL</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>log_err</name><argument_list>(<argument><expr>"invalid target group name: (%s)\n"</expr></argument>, <argument><expr><name>target_gname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr>106</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
    }</block></then>
    <else>else <block>{
        <if>if <condition>(<expr>(<name>gr</name> = <call><name>getgrgid</name><argument_list>(<argument><expr><call><name>atoi</name><argument_list>(<argument><expr><name>target_gname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>) == <name>NULL</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>log_err</name><argument_list>(<argument><expr>"invalid target group id: (%s)\n"</expr></argument>, <argument><expr><name>target_gname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr>106</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
    }</block></else></if>
    <expr_stmt><expr><name>gid</name> = <name><name>gr</name>-&gt;<name>gr_gid</name></name></expr>;</expr_stmt>
    <if>if <condition>(<expr>(<name>actual_gname</name> = <call><name>strdup</name><argument_list>(<argument><expr><name><name>gr</name>-&gt;<name>gr_name</name></name></expr></argument>)</argument_list></call>) == <name>NULL</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>log_err</name><argument_list>(<argument><expr>"failed to alloc memory\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr>125</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_OSD_POSIX</name></cpp:ifdef>
    <comment type="block">/*
     * Initialize BS2000 user environment
     */</comment>
    <block>{
        <decl_stmt><decl><type><name>pid_t</name></type> <name>pid</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>status</name></decl>;</decl_stmt>

        <switch>switch <condition>(<expr><name>pid</name> = <call><name>ufork</name><argument_list>(<argument><expr><name>target_uname</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{
        <case>case <expr>-1</expr>:    <comment type="block">/* Error */</comment>
            <expr_stmt><expr><call><name>log_err</name><argument_list>(<argument><expr>"failed to setup bs2000 environment for user %s: %s\n"</expr></argument>,
                    <argument><expr><name>target_uname</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr>150</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </case><case>case <expr>0</expr>:     <comment type="block">/* Child */</comment>
            <break>break;</break>
        </case><default>default:    <comment type="block">/* Father */</comment>
            <while>while <condition>(<expr><name>pid</name> != <call><name>waitpid</name><argument_list>(<argument><expr><name>pid</name></expr></argument>, <argument><expr>&amp;<name>status</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>)</condition>
                <empty_stmt>;</empty_stmt></while>
            <comment type="block">/* @@@ FIXME: should we deal with STOP signals as well? */</comment>
            <if>if <condition>(<expr><call><name>WIFSIGNALED</name><argument_list>(<argument><expr><name>status</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name>kill</name> <argument_list>(<argument><expr><call><name>getpid</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>WTERMSIG</name><argument_list>(<argument><expr><name>status</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>
            <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><call><name>WEXITSTATUS</name><argument_list>(<argument><expr><name>status</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </default>}</block></switch>
    }</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/*_OSD_POSIX*/</comment>

    <comment type="block">/*
     * Save these for later since initgroups will hose the struct
     */</comment>
    <expr_stmt><expr><name>uid</name> = <name><name>pw</name>-&gt;<name>pw_uid</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>actual_uname</name> = <call><name>strdup</name><argument_list>(<argument><expr><name><name>pw</name>-&gt;<name>pw_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>target_homedir</name> = <call><name>strdup</name><argument_list>(<argument><expr><name><name>pw</name>-&gt;<name>pw_dir</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>actual_uname</name> == <name>NULL</name> || <name>target_homedir</name> == <name>NULL</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>log_err</name><argument_list>(<argument><expr>"failed to alloc memory\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr>126</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

    <comment type="block">/*
     * Log the transaction here to be sure we have an open log
     * before we setuid().
     */</comment>
    <expr_stmt><expr><call><name>log_no_err</name><argument_list>(<argument><expr>"uid: (%s/%s) gid: (%s/%s) cmd: %s\n"</expr></argument>,
               <argument><expr><name>target_uname</name></expr></argument>, <argument><expr><name>actual_uname</name></expr></argument>,
               <argument><expr><name>target_gname</name></expr></argument>, <argument><expr><name>actual_gname</name></expr></argument>,
               <argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Error out if attempt is made to execute as root or as
     * a UID less than AP_UID_MIN.  Tsk tsk.
     */</comment>
    <if>if <condition>(<expr>(<name>uid</name> == 0) || (<name>uid</name> &lt; <name>AP_UID_MIN</name>)</expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>log_err</name><argument_list>(<argument><expr>"cannot run as forbidden uid (%lu/%s)\n"</expr></argument>, <argument><expr>(<name>unsigned</name> <name>long</name>)<name>uid</name></expr></argument>, <argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr>107</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

    <comment type="block">/*
     * Error out if attempt is made to execute as root group
     * or as a GID less than AP_GID_MIN.  Tsk tsk.
     */</comment>
    <if>if <condition>(<expr>(<name>gid</name> == 0) || (<name>gid</name> &lt; <name>AP_GID_MIN</name>)</expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>log_err</name><argument_list>(<argument><expr>"cannot run as forbidden gid (%lu/%s)\n"</expr></argument>, <argument><expr>(<name>unsigned</name> <name>long</name>)<name>gid</name></expr></argument>, <argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr>108</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

    <comment type="block">/*
     * Change UID/GID here so that the following tests work over NFS.
     *
     * Initialize the group access list for the target user,
     * and setgid() to the target group. If unsuccessful, error out.
     */</comment>
    <if>if <condition>(<expr>((<call><name>setgid</name><argument_list>(<argument><expr><name>gid</name></expr></argument>)</argument_list></call>) != 0) || (<call><name>initgroups</name><argument_list>(<argument><expr><name>actual_uname</name></expr></argument>, <argument><expr><name>gid</name></expr></argument>)</argument_list></call> != 0)</expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>log_err</name><argument_list>(<argument><expr>"failed to setgid (%lu: %s)\n"</expr></argument>, <argument><expr>(<name>unsigned</name> <name>long</name>)<name>gid</name></expr></argument>, <argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr>109</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

    <comment type="block">/*
     * setuid() to the target user.  Error out on fail.
     */</comment>
    <if>if <condition>(<expr>(<call><name>setuid</name><argument_list>(<argument><expr><name>uid</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>log_err</name><argument_list>(<argument><expr>"failed to setuid (%lu: %s)\n"</expr></argument>, <argument><expr>(<name>unsigned</name> <name>long</name>)<name>uid</name></expr></argument>, <argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr>110</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

    <comment type="block">/*
     * Get the current working directory, as well as the proper
     * document root (dependant upon whether or not it is a
     * ~userdir request).  Error out if we cannot get either one,
     * or if the current working directory is not in the docroot.
     * Use chdir()s and getcwd()s to avoid problems with symlinked
     * directories.  Yuck.
     */</comment>
    <if>if <condition>(<expr><call><name>getcwd</name><argument_list>(<argument><expr><name>cwd</name></expr></argument>, <argument><expr><name>AP_MAXPATH</name></expr></argument>)</argument_list></call> == <name>NULL</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>log_err</name><argument_list>(<argument><expr>"cannot get current working directory\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr>111</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

    <if>if <condition>(<expr><name>userdir</name></expr>)</condition><then> <block>{
        <if>if <condition>(<expr>((<call><name>chdir</name><argument_list>(<argument><expr><name>target_homedir</name></expr></argument>)</argument_list></call>) != 0) ||
            ((<call><name>chdir</name><argument_list>(<argument><expr><name>AP_USERDIR_SUFFIX</name></expr></argument>)</argument_list></call>) != 0) ||
            ((<call><name>getcwd</name><argument_list>(<argument><expr><name>dwd</name></expr></argument>, <argument><expr><name>AP_MAXPATH</name></expr></argument>)</argument_list></call>) == <name>NULL</name>) ||
            ((<call><name>chdir</name><argument_list>(<argument><expr><name>cwd</name></expr></argument>)</argument_list></call>) != 0)</expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>log_err</name><argument_list>(<argument><expr>"cannot get docroot information (%s)\n"</expr></argument>, <argument><expr><name>target_homedir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr>112</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
    }</block></then>
    <else>else <block>{
        <if>if <condition>(<expr>((<call><name>chdir</name><argument_list>(<argument><expr><name>AP_DOC_ROOT</name></expr></argument>)</argument_list></call>) != 0) ||
            ((<call><name>getcwd</name><argument_list>(<argument><expr><name>dwd</name></expr></argument>, <argument><expr><name>AP_MAXPATH</name></expr></argument>)</argument_list></call>) == <name>NULL</name>) ||
            ((<call><name>chdir</name><argument_list>(<argument><expr><name>cwd</name></expr></argument>)</argument_list></call>) != 0)</expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>log_err</name><argument_list>(<argument><expr>"cannot get docroot information (%s)\n"</expr></argument>, <argument><expr><name>AP_DOC_ROOT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr>113</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
    }</block></else></if>

    <if>if <condition>(<expr>(<call><name>strncmp</name><argument_list>(<argument><expr><name>cwd</name></expr></argument>, <argument><expr><name>dwd</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>dwd</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>log_err</name><argument_list>(<argument><expr>"command not in docroot (%s/%s)\n"</expr></argument>, <argument><expr><name>cwd</name></expr></argument>, <argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr>114</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

    <comment type="block">/*
     * Stat the cwd and verify it is a directory, or error out.
     */</comment>
    <if>if <condition>(<expr>((<call><name>lstat</name><argument_list>(<argument><expr><name>cwd</name></expr></argument>, <argument><expr>&amp;<name>dir_info</name></expr></argument>)</argument_list></call>) != 0) || !(<call><name>S_ISDIR</name><argument_list>(<argument><expr><name><name>dir_info</name>.<name>st_mode</name></name></expr></argument>)</argument_list></call>)</expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>log_err</name><argument_list>(<argument><expr>"cannot stat directory: (%s)\n"</expr></argument>, <argument><expr><name>cwd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr>115</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

    <comment type="block">/*
     * Error out if cwd is writable by others.
     */</comment>
    <if>if <condition>(<expr>(<name><name>dir_info</name>.<name>st_mode</name></name> &amp; <name>S_IWOTH</name>) || (<name><name>dir_info</name>.<name>st_mode</name></name> &amp; <name>S_IWGRP</name>)</expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>log_err</name><argument_list>(<argument><expr>"directory is writable by others: (%s)\n"</expr></argument>, <argument><expr><name>cwd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr>116</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

    <comment type="block">/*
     * Error out if we cannot stat the program.
     */</comment>
    <if>if <condition>(<expr>((<call><name>lstat</name><argument_list>(<argument><expr><name>cmd</name></expr></argument>, <argument><expr>&amp;<name>prg_info</name></expr></argument>)</argument_list></call>) != 0) || (<call><name>S_ISLNK</name><argument_list>(<argument><expr><name><name>prg_info</name>.<name>st_mode</name></name></expr></argument>)</argument_list></call>)</expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>log_err</name><argument_list>(<argument><expr>"cannot stat program: (%s)\n"</expr></argument>, <argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr>117</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

    <comment type="block">/*
     * Error out if the program is writable by others.
     */</comment>
    <if>if <condition>(<expr>(<name><name>prg_info</name>.<name>st_mode</name></name> &amp; <name>S_IWOTH</name>) || (<name><name>prg_info</name>.<name>st_mode</name></name> &amp; <name>S_IWGRP</name>)</expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>log_err</name><argument_list>(<argument><expr>"file is writable by others: (%s/%s)\n"</expr></argument>, <argument><expr><name>cwd</name></expr></argument>, <argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr>118</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

    <comment type="block">/*
     * Error out if the file is setuid or setgid.
     */</comment>
    <if>if <condition>(<expr>(<name><name>prg_info</name>.<name>st_mode</name></name> &amp; <name>S_ISUID</name>) || (<name><name>prg_info</name>.<name>st_mode</name></name> &amp; <name>S_ISGID</name>)</expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>log_err</name><argument_list>(<argument><expr>"file is either setuid or setgid: (%s/%s)\n"</expr></argument>, <argument><expr><name>cwd</name></expr></argument>, <argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr>119</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

    <comment type="block">/*
     * Error out if the target name/group is different from
     * the name/group of the cwd or the program.
     */</comment>
    <if>if <condition>(<expr>(<name>uid</name> != <name><name>dir_info</name>.<name>st_uid</name></name>) ||
        (<name>gid</name> != <name><name>dir_info</name>.<name>st_gid</name></name>) ||
        (<name>uid</name> != <name><name>prg_info</name>.<name>st_uid</name></name>) ||
        (<name>gid</name> != <name><name>prg_info</name>.<name>st_gid</name></name>)</expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>log_err</name><argument_list>(<argument><expr>"target uid/gid (%lu/%lu) mismatch "
                "with directory (%lu/%lu) or program (%lu/%lu)\n"</expr></argument>,
                <argument><expr>(<name>unsigned</name> <name>long</name>)<name>uid</name></expr></argument>, <argument><expr>(<name>unsigned</name> <name>long</name>)<name>gid</name></expr></argument>,
                <argument><expr>(<name>unsigned</name> <name>long</name>)<name><name>dir_info</name>.<name>st_uid</name></name></expr></argument>, <argument><expr>(<name>unsigned</name> <name>long</name>)<name><name>dir_info</name>.<name>st_gid</name></name></expr></argument>,
                <argument><expr>(<name>unsigned</name> <name>long</name>)<name><name>prg_info</name>.<name>st_uid</name></name></expr></argument>, <argument><expr>(<name>unsigned</name> <name>long</name>)<name><name>prg_info</name>.<name>st_gid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr>120</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <comment type="block">/*
     * Error out if the program is not executable for the user.
     * Otherwise, she won't find any error in the logs except for
     * "[error] Premature end of script headers: ..."
     */</comment>
    <if>if <condition>(<expr>!(<name><name>prg_info</name>.<name>st_mode</name></name> &amp; <name>S_IXUSR</name>)</expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>log_err</name><argument_list>(<argument><expr>"file has no execute permission: (%s/%s)\n"</expr></argument>, <argument><expr><name>cwd</name></expr></argument>, <argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr>121</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>AP_SUEXEC_UMASK</name></cpp:ifdef>
    <comment type="block">/*
     * umask() uses inverse logic; bits are CLEAR for allowed access.
     */</comment>
    <if>if <condition>(<expr>(~<name>AP_SUEXEC_UMASK</name>) &amp; 0022</expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>log_err</name><argument_list>(<argument><expr>"notice: AP_SUEXEC_UMASK of %03o allows "
                "write permission to group and/or other\n"</expr></argument>, <argument><expr><name>AP_SUEXEC_UMASK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <expr_stmt><expr><call><name>umask</name><argument_list>(<argument><expr><name>AP_SUEXEC_UMASK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* AP_SUEXEC_UMASK */</comment>

    <comment type="block">/* Be sure to close the log file so the CGI can't mess with it. */</comment>
    <if>if <condition>(<expr><name>log</name> != <name>NULL</name></expr>)</condition><then> <block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>APR_HAVE_FCNTL_H</name></expr></cpp:if>
        <comment type="block">/*
         * ask fcntl(2) to set the FD_CLOEXEC flag on the log file,
         * so it'll be automagically closed if the exec() call succeeds.
         */</comment>
        <expr_stmt><expr><call><name>fflush</name><argument_list>(<argument><expr><name>log</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>setbuf</name><argument_list>(<argument><expr><name>log</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr>(<call><name>fcntl</name><argument_list>(<argument><expr><call><name>fileno</name><argument_list>(<argument><expr><name>log</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>F_SETFD</name></expr></argument>, <argument><expr><name>FD_CLOEXEC</name></expr></argument>)</argument_list></call> == -1)</expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>log_err</name><argument_list>(<argument><expr>"error: can't set close-on-exec flag"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr>122</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
        <comment type="block">/*
         * In this case, exec() errors won't be logged because we have already
         * dropped privileges and won't be able to reopen the log file.
         */</comment>
        <expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>log</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>log</name> = <name>NULL</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    }</block></then></if>

    <comment type="block">/*
     * Execute the command, replacing our image with its own.
     */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>NEED_HASHBANG_EMUL</name></cpp:ifdef>
    <comment type="block">/* We need the #! emulation when we want to execute scripts */</comment>
    <block>{
        <decl_stmt><decl><type><specifier>extern</specifier> <name>char</name> **</type><name>environ</name></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>ap_execve</name><argument_list>(<argument><expr><name>cmd</name></expr></argument>, <argument><expr>&amp;<name><name>argv</name><index>[<expr>3</expr>]</index></name></expr></argument>, <argument><expr><name>environ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else> <comment type="block">/*NEED_HASHBANG_EMUL*/</comment>
    <expr_stmt><expr><call><name>execv</name><argument_list>(<argument><expr><name>cmd</name></expr></argument>, <argument><expr>&amp;<name><name>argv</name><index>[<expr>3</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/*NEED_HASHBANG_EMUL*/</comment>

    <comment type="block">/*
     * (I can't help myself...sorry.)
     *
     * Uh oh.  Still here.  Where's the kaboom?  There was supposed to be an
     * EARTH-shattering kaboom!
     *
     * Oh well, log the failure and error out.
     */</comment>
    <expr_stmt><expr><call><name>log_err</name><argument_list>(<argument><expr>"(%d)%s: exec failed (%s)\n"</expr></argument>, <argument><expr><name>errno</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr>255</expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>
</unit>
