<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C" filename="Include/objimpl.h"><cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>Py_OBJIMPL_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Py_OBJIMPL_H</name></cpp:macro></cpp:define>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pymem.h"</cpp:file></cpp:include>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__cplusplus</name></expr></argument>)</argument_list></call></expr></cpp:if>
<extern>extern "C" <block>{
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<macro><name>PyAPI_FUNC</name><argument_list>(<argument>void *</argument>)</argument_list></macro> <expr_stmt><expr><call><name>PyObject_Malloc</name><argument_list>(<argument><expr><name>size_t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<macro><name>PyAPI_FUNC</name><argument_list>(<argument>void *</argument>)</argument_list></macro> <expr_stmt><expr><call><name>PyObject_Realloc</name><argument_list>(<argument><expr><name>void</name> *</expr></argument>, <argument><expr><name>size_t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<macro><name>PyAPI_FUNC</name><argument_list>(<argument>void</argument>)</argument_list></macro> <expr_stmt><expr><call><name>PyObject_Free</name><argument_list>(<argument><expr><name>void</name> *</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>WITH_PYMALLOC</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>PYMALLOC_DEBUG</name></expr></argument>)</argument_list></call></expr></cpp:if>
<macro><name>PyAPI_FUNC</name><argument_list>(<argument>void *</argument>)</argument_list></macro> <macro><name>_PyObject_DebugMalloc</name><argument_list>(<argument>size_t nbytes</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
<macro><name>PyAPI_FUNC</name><argument_list>(<argument>void *</argument>)</argument_list></macro> <macro><name>_PyObject_DebugRealloc</name><argument_list>(<argument>void *p</argument>, <argument>size_t nbytes</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
<macro><name>PyAPI_FUNC</name><argument_list>(<argument>void</argument>)</argument_list></macro> <expr_stmt><expr><call><name>_PyObject_DebugFree</name><argument_list>(<argument><expr><name>void</name> *<name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<macro><name>PyAPI_FUNC</name><argument_list>(<argument>void</argument>)</argument_list></macro> <expr_stmt><expr><call><name>_PyObject_DebugDumpAddress</name><argument_list>(<argument><expr>const <name>void</name> *<name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<macro><name>PyAPI_FUNC</name><argument_list>(<argument>void</argument>)</argument_list></macro> <expr_stmt><expr><call><name>_PyObject_DebugCheckAddress</name><argument_list>(<argument><expr>const <name>void</name> *<name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<macro><name>PyAPI_FUNC</name><argument_list>(<argument>void</argument>)</argument_list></macro> <expr_stmt><expr><call><name>_PyObject_DebugMallocStats</name><argument_list>(<argument><expr><name>void</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PyObject_MALLOC</name></cpp:macro> <cpp:value>_PyObject_DebugMalloc</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PyObject_Malloc</name></cpp:macro> <cpp:value>_PyObject_DebugMalloc</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PyObject_REALLOC</name></cpp:macro> <cpp:value>_PyObject_DebugRealloc</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PyObject_Realloc</name></cpp:macro> <cpp:value>_PyObject_DebugRealloc</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PyObject_FREE</name></cpp:macro> <cpp:value>_PyObject_DebugFree</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PyObject_Free</name></cpp:macro> <cpp:value>_PyObject_DebugFree</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PyObject_MALLOC</name></cpp:macro> <cpp:value>PyObject_Malloc</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PyObject_REALLOC</name></cpp:macro> <cpp:value>PyObject_Realloc</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PyObject_FREE</name></cpp:macro> <cpp:value>PyObject_Free</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PyObject_MALLOC</name></cpp:macro> <cpp:value>PyMem_MALLOC</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PyObject_REALLOC</name></cpp:macro> <cpp:value>PyMem_REALLOC</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PyObject_FREE</name></cpp:macro> <cpp:value>PyMem_FREE</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PyObject_Del</name></cpp:macro> <cpp:value>PyObject_Free</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PyObject_DEL</name></cpp:macro> <cpp:value>PyObject_FREE</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>_PyObject_Del</name></cpp:macro> <cpp:value>PyObject_Free</cpp:value></cpp:define>
<macro><name>PyAPI_FUNC</name><argument_list>(<argument>PyObject *</argument>)</argument_list></macro> <expr_stmt><expr><call><name>PyObject_Init</name><argument_list>(<argument><expr><name>PyObject</name> *</expr></argument>, <argument><expr><name>PyTypeObject</name> *</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<macro><name>PyAPI_FUNC</name><argument_list>(<argument>PyVarObject *</argument>)</argument_list></macro> <expr_stmt><expr><call><name>PyObject_InitVar</name><argument_list>(<argument><expr><name>PyVarObject</name> *</expr></argument>,
<argument><expr><name>PyTypeObject</name> *</expr></argument>, <argument><expr><name>Py_ssize_t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<macro><name>PyAPI_FUNC</name><argument_list>(<argument>PyObject *</argument>)</argument_list></macro> <expr_stmt><expr><call><name>_PyObject_New</name><argument_list>(<argument><expr><name>PyTypeObject</name> *</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<macro><name>PyAPI_FUNC</name><argument_list>(<argument>PyVarObject *</argument>)</argument_list></macro> <expr_stmt><expr><call><name>_PyObject_NewVar</name><argument_list>(<argument><expr><name>PyTypeObject</name> *</expr></argument>, <argument><expr><name>Py_ssize_t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PyObject_New</name><parameter_list>(<param><type><name>type</name></type></param>, <param><type><name>typeobj</name></type></param>)</parameter_list></cpp:macro> <cpp:value>( (type *) _PyObject_New(typeobj) )</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PyObject_NewVar</name><parameter_list>(<param><type><name>type</name></type></param>, <param><type><name>typeobj</name></type></param>, <param><type><name>n</name></type></param>)</parameter_list></cpp:macro> <cpp:value>( (type *) _PyObject_NewVar((typeobj), (n)) )</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PyObject_INIT</name><parameter_list>(<param><type><name>op</name></type></param>, <param><type><name>typeobj</name></type></param>)</parameter_list></cpp:macro> <cpp:value>( Py_TYPE(op) = (typeobj), _Py_NewReference((PyObject *)(op)), (op) )</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PyObject_INIT_VAR</name><parameter_list>(<param><type><name>op</name></type></param>, <param><type><name>typeobj</name></type></param>, <param><type><name>size</name></type></param>)</parameter_list></cpp:macro> <cpp:value>( Py_SIZE(op) = (size), PyObject_INIT((op), (typeobj)) )</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>_PyObject_SIZE</name><parameter_list>(<param><type><name>typeobj</name></type></param>)</parameter_list></cpp:macro> <cpp:value>( (typeobj)-&gt;tp_basicsize )</cpp:value></cpp:define>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>((<name>SIZEOF_VOID_P</name> - 1) &amp; <name>SIZEOF_VOID_P</name>) != 0</expr></cpp:if>
<cpp:error>#<cpp:directive>error</cpp:directive> "_PyObject_VAR_SIZE requires SIZEOF_VOID_P be a power of 2"</cpp:error>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>_PyObject_VAR_SIZE</name><parameter_list>(<param><type><name>typeobj</name></type></param>, <param><type><name>nitems</name></type></param>)</parameter_list></cpp:macro> <cpp:value>(size_t) ( ( (typeobj)-&gt;tp_basicsize + (nitems)*(typeobj)-&gt;tp_itemsize + (SIZEOF_VOID_P - 1) ) &amp; ~(SIZEOF_VOID_P - 1) )</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PyObject_NEW</name><parameter_list>(<param><type><name>type</name></type></param>, <param><type><name>typeobj</name></type></param>)</parameter_list></cpp:macro> <cpp:value>( (type *) PyObject_Init( (PyObject *) PyObject_MALLOC( _PyObject_SIZE(typeobj) ), (typeobj)) )</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PyObject_NEW_VAR</name><parameter_list>(<param><type><name>type</name></type></param>, <param><type><name>typeobj</name></type></param>, <param><type><name>n</name></type></param>)</parameter_list></cpp:macro> <cpp:value>( (type *) PyObject_InitVar( (PyVarObject *) PyObject_MALLOC(_PyObject_VAR_SIZE((typeobj),(n)) ),(typeobj), (n)) )</cpp:value></cpp:define>
<macro><name>PyAPI_FUNC</name><argument_list>(<argument>Py_ssize_t</argument>)</argument_list></macro> <expr_stmt><expr><call><name>PyGC_Collect</name><argument_list>(<argument><expr><name>void</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PyType_IS_GC</name><parameter_list>(<param><type><name>t</name></type></param>)</parameter_list></cpp:macro> <cpp:value>PyType_HasFeature((t), Py_TPFLAGS_HAVE_GC)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PyObject_IS_GC</name><parameter_list>(<param><type><name>o</name></type></param>)</parameter_list></cpp:macro> <cpp:value>(PyType_IS_GC(Py_TYPE(o)) &amp;&amp; (Py_TYPE(o)-&gt;tp_is_gc == NULL || Py_TYPE(o)-&gt;tp_is_gc(o)))</cpp:value></cpp:define>
<macro><name>PyAPI_FUNC</name><argument_list>(<argument>PyVarObject *</argument>)</argument_list></macro> <expr_stmt><expr><call><name>_PyObject_GC_Resize</name><argument_list>(<argument><expr><name>PyVarObject</name> *</expr></argument>, <argument><expr><name>Py_ssize_t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PyObject_GC_Resize</name><parameter_list>(<param><type><name>type</name></type></param>, <param><type><name>op</name></type></param>, <param><type><name>n</name></type></param>)</parameter_list></cpp:macro> <cpp:value>( (type *) _PyObject_GC_Resize((PyVarObject *)(op), (n)) )</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>_PyObject_GC_Del</name></cpp:macro> <cpp:value>PyObject_GC_Del</cpp:value></cpp:define>
<typedef>typedef <type><union>union <name>_gc_head</name> <block>{
<struct>struct <block>{
<decl_stmt><decl><type>union <name>_gc_head</name> *</type><name>gc_next</name></decl>;</decl_stmt>
<decl_stmt><decl><type>union <name>_gc_head</name> *</type><name>gc_prev</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>gc_refs</name></decl>;</decl_stmt>
}</block> <decl><name>gc</name></decl>;</struct>
<decl_stmt><decl><type><name>long</name> <name>double</name></type> <name>dummy</name></decl>;</decl_stmt>
}</block></union></type> <name>PyGC_Head</name>;</typedef>
<decl_stmt><decl><type><specifier>extern</specifier> <name>PyGC_Head</name> *</type><name>_PyGC_generation0</name></decl>;</decl_stmt>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>_Py_AS_GC</name><parameter_list>(<param><type><name>o</name></type></param>)</parameter_list></cpp:macro> <cpp:value>((PyGC_Head *)(o)-1)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>_PyGC_REFS_UNTRACKED</name></cpp:macro> <cpp:value>(-2)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>_PyGC_REFS_REACHABLE</name></cpp:macro> <cpp:value>(-3)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>_PyGC_REFS_TENTATIVELY_UNREACHABLE</name></cpp:macro> <cpp:value>(-4)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>_PyObject_GC_TRACK</name><parameter_list>(<param><type><name>o</name></type></param>)</parameter_list></cpp:macro> <cpp:value>do { PyGC_Head *g = _Py_AS_GC(o); if (g-&gt;gc.gc_refs != _PyGC_REFS_UNTRACKED) Py_FatalError("GC object already tracked"); g-&gt;gc.gc_refs = _PyGC_REFS_REACHABLE; g-&gt;gc.gc_next = _PyGC_generation0; g-&gt;gc.gc_prev = _PyGC_generation0-&gt;gc.gc_prev; g-&gt;gc.gc_prev-&gt;gc.gc_next = g; _PyGC_generation0-&gt;gc.gc_prev = g; } while (0);</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>_PyObject_GC_UNTRACK</name><parameter_list>(<param><type><name>o</name></type></param>)</parameter_list></cpp:macro> <cpp:value>do { PyGC_Head *g = _Py_AS_GC(o); assert(g-&gt;gc.gc_refs != _PyGC_REFS_UNTRACKED); g-&gt;gc.gc_refs = _PyGC_REFS_UNTRACKED; g-&gt;gc.gc_prev-&gt;gc.gc_next = g-&gt;gc.gc_next; g-&gt;gc.gc_next-&gt;gc.gc_prev = g-&gt;gc.gc_prev; g-&gt;gc.gc_next = NULL; } while (0);</cpp:value></cpp:define>
<macro><name>PyAPI_FUNC</name><argument_list>(<argument>PyObject *</argument>)</argument_list></macro> <expr_stmt><expr><call><name>_PyObject_GC_Malloc</name><argument_list>(<argument><expr><name>size_t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<macro><name>PyAPI_FUNC</name><argument_list>(<argument>PyObject *</argument>)</argument_list></macro> <expr_stmt><expr><call><name>_PyObject_GC_New</name><argument_list>(<argument><expr><name>PyTypeObject</name> *</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<macro><name>PyAPI_FUNC</name><argument_list>(<argument>PyVarObject *</argument>)</argument_list></macro> <expr_stmt><expr><call><name>_PyObject_GC_NewVar</name><argument_list>(<argument><expr><name>PyTypeObject</name> *</expr></argument>, <argument><expr><name>Py_ssize_t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<macro><name>PyAPI_FUNC</name><argument_list>(<argument>void</argument>)</argument_list></macro> <expr_stmt><expr><call><name>PyObject_GC_Track</name><argument_list>(<argument><expr><name>void</name> *</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<macro><name>PyAPI_FUNC</name><argument_list>(<argument>void</argument>)</argument_list></macro> <expr_stmt><expr><call><name>PyObject_GC_UnTrack</name><argument_list>(<argument><expr><name>void</name> *</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<macro><name>PyAPI_FUNC</name><argument_list>(<argument>void</argument>)</argument_list></macro> <expr_stmt><expr><call><name>PyObject_GC_Del</name><argument_list>(<argument><expr><name>void</name> *</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PyObject_GC_New</name><parameter_list>(<param><type><name>type</name></type></param>, <param><type><name>typeobj</name></type></param>)</parameter_list></cpp:macro> <cpp:value>( (type *) _PyObject_GC_New(typeobj) )</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PyObject_GC_NewVar</name><parameter_list>(<param><type><name>type</name></type></param>, <param><type><name>typeobj</name></type></param>, <param><type><name>n</name></type></param>)</parameter_list></cpp:macro> <cpp:value>( (type *) _PyObject_GC_NewVar((typeobj), (n)) )</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Py_VISIT</name><parameter_list>(<param><type><name>op</name></type></param>)</parameter_list></cpp:macro> <cpp:value>do { if (op) { int vret = visit((PyObject *)(op), arg); if (vret) return vret; } } while (0)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PyGC_HEAD_SIZE</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PyObject_GC_Init</name><parameter_list>(<param><type><name>op</name></type></param>)</parameter_list></cpp:macro></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PyObject_GC_Fini</name><parameter_list>(<param><type><name>op</name></type></param>)</parameter_list></cpp:macro></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PyObject_AS_GC</name><parameter_list>(<param><type><name>op</name></type></param>)</parameter_list></cpp:macro> <cpp:value>(op)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PyObject_FROM_GC</name><parameter_list>(<param><type><name>op</name></type></param>)</parameter_list></cpp:macro> <cpp:value>(op)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PyType_SUPPORTS_WEAKREFS</name><parameter_list>(<param><type><name>t</name></type></param>)</parameter_list></cpp:macro> <cpp:value>(PyType_HasFeature((t), Py_TPFLAGS_HAVE_WEAKREFS) &amp;&amp; ((t)-&gt;tp_weaklistoffset &gt; 0))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PyObject_GET_WEAKREFS_LISTPTR</name><parameter_list>(<param><type><name>o</name></type></param>)</parameter_list></cpp:macro> <cpp:value>((PyObject **) (((char *) (o)) + Py_TYPE(o)-&gt;tp_weaklistoffset))</cpp:value></cpp:define>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__cplusplus</name></expr></argument>)</argument_list></call></expr></cpp:if>
}</block></extern>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</unit>
