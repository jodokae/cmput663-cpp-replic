<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C" filename="projects/cpython-2.6.1/_cppstats/Python/bltinmodule.c"><cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"Python.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"Python-ast.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"node.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"code.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"eval.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;ctype.h&gt;</cpp:file></cpp:include>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>RISCOS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"unixstuff.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MS_WINDOWS</name></expr></argument>)</argument_list></call> &amp;&amp; <call><name>defined</name><argument_list>(<argument><expr><name>HAVE_USABLE_WCHAR_T</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>Py_FileSystemDefaultEncoding</name> <init>= <expr>"mbcs"</expr></init></decl>;</decl_stmt>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__APPLE__</name></expr></argument>)</argument_list></call></expr></cpp:elif>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>Py_FileSystemDefaultEncoding</name> <init>= <expr>"utf-8"</expr></init></decl>;</decl_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>Py_FileSystemDefaultEncoding</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<function_decl><type><specifier>static</specifier> <name>PyObject</name> *</type><name>filterstring</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type></decl></param>, <param><decl><type><name>PyObject</name> *</type></decl></param>)</parameter_list>;</function_decl>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>Py_USING_UNICODE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function_decl><type><specifier>static</specifier> <name>PyObject</name> *</type><name>filterunicode</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type></decl></param>, <param><decl><type><name>PyObject</name> *</type></decl></param>)</parameter_list>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<function_decl><type><specifier>static</specifier> <name>PyObject</name> *</type><name>filtertuple</name> <parameter_list>(<param><decl><type><name>PyObject</name> *</type></decl></param>, <param><decl><type><name>PyObject</name> *</type></decl></param>)</parameter_list>;</function_decl>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>builtin___import__</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>kwds</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> *</type><name><name>kwlist</name><index>[]</index></name> <init>= <expr><block>{<expr>"name"</expr>, <expr>"globals"</expr>, <expr>"locals"</expr>, <expr>"fromlist"</expr>,
<expr>"level"</expr>, <expr>0</expr>
}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>name</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>globals</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>locals</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>fromlist</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>level</name> <init>= <expr>-1</expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTupleAndKeywords</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>kwds</name></expr></argument>, <argument><expr>"s|OOOi:__import__"</expr></argument>,
<argument><expr><name>kwlist</name></expr></argument>, <argument><expr>&amp;<name>name</name></expr></argument>, <argument><expr>&amp;<name>globals</name></expr></argument>, <argument><expr>&amp;<name>locals</name></expr></argument>, <argument><expr>&amp;<name>fromlist</name></expr></argument>, <argument><expr>&amp;<name>level</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<return>return <expr><call><name>PyImport_ImportModuleLevel</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>globals</name></expr></argument>, <argument><expr><name>locals</name></expr></argument>,
<argument><expr><name>fromlist</name></expr></argument>, <argument><expr><name>level</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>import_doc</name></expr></argument>,
<argument><expr>"__import__(name, globals={}, locals={}, fromlist=[], level=-1) -&gt; module\n\
\n\
Import a module. The globals are only used to determine the context;\n\
they are not modified. The locals are currently unused. The fromlist\n\
should be a list of names to emulate ``from name import ...'', or an\n\
empty list to emulate ``import name''.\n\
When importing a module from a package, note that __import__('A.B', ...)\n\
returns package A when fromlist is empty, but its submodule B when\n\
fromlist is not empty. Level is used to determine whether to perform \n\
absolute or relative imports. -1 is the original strategy of attempting\n\
both absolute and relative imports, 0 is absolute, a positive number\n\
is the number of parent directories to search relative to the current module."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>builtin_abs</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>v</name></decl></param>)</parameter_list> <block>{
<return>return <expr><call><name>PyNumber_Absolute</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>abs_doc</name></expr></argument>,
<argument><expr>"abs(number) -&gt; number\n\
\n\
Return the absolute value of the argument."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>builtin_all</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>v</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>it</name></decl>, *<decl><type ref="prev"/><name>item</name></decl>;</decl_stmt>
<function_decl><type><name>PyObject</name> *</type>(*<name>iternext</name>)<parameter_list>(<param><decl><type><name>PyObject</name> *</type></decl></param>)</parameter_list>;</function_decl>
<decl_stmt><decl><type><name>int</name></type> <name>cmp</name></decl>;</decl_stmt>
<expr_stmt><expr><name>it</name> = <call><name>PyObject_GetIter</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>it</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>iternext</name> = *<call><name>Py_TYPE</name><argument_list>(<argument><expr><name>it</name></expr></argument>)</argument_list></call>-&gt;<name>tp_iternext</name></expr>;</expr_stmt>
<for>for (<init>;</init><condition>;</condition><incr/>) <block>{
<expr_stmt><expr><name>item</name> = <call><name>iternext</name><argument_list>(<argument><expr><name>it</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>item</name> == <name>NULL</name></expr>)</condition><then>
<break>break;</break></then></if>
<expr_stmt><expr><name>cmp</name> = <call><name>PyObject_IsTrue</name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>cmp</name> &lt; 0</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>it</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<if>if <condition>(<expr><name>cmp</name> == 0</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>it</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>Py_RETURN_FALSE</name></expr>;</expr_stmt>
}</block></then></if>
}</block></for>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>it</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
<if>if <condition>(<expr><call><name>PyErr_ExceptionMatches</name><argument_list>(<argument><expr><name>PyExc_StopIteration</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<expr_stmt><expr><call><name>PyErr_Clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then>
<else>else
<return>return <expr><name>NULL</name></expr>;</return></else></if>
}</block></then></if>
<expr_stmt><expr><name>Py_RETURN_TRUE</name></expr>;</expr_stmt>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>all_doc</name></expr></argument>,
<argument><expr>"all(iterable) -&gt; bool\n\
\n\
Return True if bool(x) is True for all values x in the iterable."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>builtin_any</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>v</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>it</name></decl>, *<decl><type ref="prev"/><name>item</name></decl>;</decl_stmt>
<function_decl><type><name>PyObject</name> *</type>(*<name>iternext</name>)<parameter_list>(<param><decl><type><name>PyObject</name> *</type></decl></param>)</parameter_list>;</function_decl>
<decl_stmt><decl><type><name>int</name></type> <name>cmp</name></decl>;</decl_stmt>
<expr_stmt><expr><name>it</name> = <call><name>PyObject_GetIter</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>it</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>iternext</name> = *<call><name>Py_TYPE</name><argument_list>(<argument><expr><name>it</name></expr></argument>)</argument_list></call>-&gt;<name>tp_iternext</name></expr>;</expr_stmt>
<for>for (<init>;</init><condition>;</condition><incr/>) <block>{
<expr_stmt><expr><name>item</name> = <call><name>iternext</name><argument_list>(<argument><expr><name>it</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>item</name> == <name>NULL</name></expr>)</condition><then>
<break>break;</break></then></if>
<expr_stmt><expr><name>cmp</name> = <call><name>PyObject_IsTrue</name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>cmp</name> &lt; 0</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>it</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<if>if <condition>(<expr><name>cmp</name> == 1</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>it</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>Py_RETURN_TRUE</name></expr>;</expr_stmt>
}</block></then></if>
}</block></for>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>it</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
<if>if <condition>(<expr><call><name>PyErr_ExceptionMatches</name><argument_list>(<argument><expr><name>PyExc_StopIteration</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<expr_stmt><expr><call><name>PyErr_Clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then>
<else>else
<return>return <expr><name>NULL</name></expr>;</return></else></if>
}</block></then></if>
<expr_stmt><expr><name>Py_RETURN_FALSE</name></expr>;</expr_stmt>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>any_doc</name></expr></argument>,
<argument><expr>"any(iterable) -&gt; bool\n\
\n\
Return True if bool(x) is True for any x in the iterable."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>builtin_apply</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>func</name></decl>, *<decl><type ref="prev"/><name>alist</name> <init>= <expr><name>NULL</name></expr></init>, *<name>kwdict</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>t</name> <init>= <expr><name>NULL</name></expr></init>, *<name>retval</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><call><name>PyErr_WarnPy3k</name><argument_list>(<argument><expr>"apply() not supported in 3.x; "
"use func(*args, **kwargs)"</expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<if>if <condition>(<expr>!<call><name>PyArg_UnpackTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"apply"</expr></argument>, <argument><expr>1</expr></argument>, <argument><expr>3</expr></argument>, <argument><expr>&amp;<name>func</name></expr></argument>, <argument><expr>&amp;<name>alist</name></expr></argument>, <argument><expr>&amp;<name>kwdict</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<if>if <condition>(<expr><name>alist</name> != <name>NULL</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr>!<call><name>PyTuple_Check</name><argument_list>(<argument><expr><name>alist</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<if>if <condition>(<expr>!<call><name>PySequence_Check</name><argument_list>(<argument><expr><name>alist</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
<argument><expr>"apply() arg 2 expected sequence, found %s"</expr></argument>,
<argument><expr><name><name>alist</name>-&gt;<name>ob_type</name>-&gt;<name>tp_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>t</name> = <call><name>PySequence_Tuple</name><argument_list>(<argument><expr><name>alist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>t</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>alist</name> = <name>t</name></expr>;</expr_stmt>
}</block></then></if>
}</block></then></if>
<if>if <condition>(<expr><name>kwdict</name> != <name>NULL</name> &amp;&amp; !<call><name>PyDict_Check</name><argument_list>(<argument><expr><name>kwdict</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
<argument><expr>"apply() arg 3 expected dictionary, found %s"</expr></argument>,
<argument><expr><name><name>kwdict</name>-&gt;<name>ob_type</name>-&gt;<name>tp_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>finally</name>;</goto>
}</block></then></if>
<expr_stmt><expr><name>retval</name> = <call><name>PyEval_CallObjectWithKeywords</name><argument_list>(<argument><expr><name>func</name></expr></argument>, <argument><expr><name>alist</name></expr></argument>, <argument><expr><name>kwdict</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<label><name>finally</name>:</label>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>retval</name></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>apply_doc</name></expr></argument>,
<argument><expr>"apply(object[, args[, kwargs]]) -&gt; value\n\
\n\
Call a callable object with positional arguments taken from the tuple args,\n\
and keyword arguments taken from the optional dictionary kwargs.\n\
Note that classes are callable, as are instances with a __call__() method.\n\
\n\
Deprecated since release 2.3. Instead, use the extended call syntax:\n\
function(*args, **keywords)."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>builtin_bin</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>v</name></decl></param>)</parameter_list> <block>{
<return>return <expr><call><name>PyNumber_ToBase</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr>2</expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>bin_doc</name></expr></argument>,
<argument><expr>"bin(number) -&gt; string\n\
\n\
Return the binary representation of an integer or long integer."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>builtin_callable</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>v</name></decl></param>)</parameter_list> <block>{
<if>if <condition>(<expr><call><name>PyErr_WarnPy3k</name><argument_list>(<argument><expr>"callable() not supported in 3.x; "
"use hasattr(o, '__call__')"</expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<return>return <expr><call><name>PyBool_FromLong</name><argument_list>(<argument><expr>(<name>long</name>)<call><name>PyCallable_Check</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>callable_doc</name></expr></argument>,
<argument><expr>"callable(object) -&gt; bool\n\
\n\
Return whether the object is callable (i.e., some kind of function).\n\
Note that classes are callable, as are instances with a __call__() method."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>builtin_filter</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>func</name></decl>, *<decl><type ref="prev"/><name>seq</name></decl>, *<decl><type ref="prev"/><name>result</name></decl>, *<decl><type ref="prev"/><name>it</name></decl>, *<decl><type ref="prev"/><name>arg</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>len</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>register</name> <name>Py_ssize_t</name></type> <name>j</name></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>PyArg_UnpackTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"filter"</expr></argument>, <argument><expr>2</expr></argument>, <argument><expr>2</expr></argument>, <argument><expr>&amp;<name>func</name></expr></argument>, <argument><expr>&amp;<name>seq</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<if>if <condition>(<expr><call><name>PyString_Check</name><argument_list>(<argument><expr><name>seq</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><call><name>filterstring</name><argument_list>(<argument><expr><name>func</name></expr></argument>, <argument><expr><name>seq</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>Py_USING_UNICODE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if>if <condition>(<expr><call><name>PyUnicode_Check</name><argument_list>(<argument><expr><name>seq</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><call><name>filterunicode</name><argument_list>(<argument><expr><name>func</name></expr></argument>, <argument><expr><name>seq</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<if>if <condition>(<expr><call><name>PyTuple_Check</name><argument_list>(<argument><expr><name>seq</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><call><name>filtertuple</name><argument_list>(<argument><expr><name>func</name></expr></argument>, <argument><expr><name>seq</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
<expr_stmt><expr><name>arg</name> = <call><name>PyTuple_New</name><argument_list>(<argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>arg</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>it</name> = <call><name>PyObject_GetIter</name><argument_list>(<argument><expr><name>seq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>it</name> == <name>NULL</name></expr>)</condition><then>
<goto>goto <name>Fail_arg</name>;</goto></then></if>
<expr_stmt><expr><name>len</name> = <call><name>_PyObject_LengthHint</name><argument_list>(<argument><expr><name>seq</name></expr></argument>, <argument><expr>8</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>PyList_Check</name><argument_list>(<argument><expr><name>seq</name></expr></argument>)</argument_list></call> &amp;&amp; <name><name>seq</name>-&gt;<name>ob_refcnt</name></name> == 1</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>seq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>result</name> = <name>seq</name></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr><name>result</name> = <call><name>PyList_New</name><argument_list>(<argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>result</name> == <name>NULL</name></expr>)</condition><then>
<goto>goto <name>Fail_it</name>;</goto></then></if>
}</block></else></if>
<expr_stmt><expr><name>j</name> = 0</expr>;</expr_stmt>
<for>for (<init>;</init><condition>;</condition><incr/>) <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>item</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>ok</name></decl>;</decl_stmt>
<expr_stmt><expr><name>item</name> = <call><name>PyIter_Next</name><argument_list>(<argument><expr><name>it</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>item</name> == <name>NULL</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr><call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then>
<goto>goto <name>Fail_result_it</name>;</goto></then></if>
<break>break;</break>
}</block></then></if>
<if>if <condition>(<expr><name>func</name> == (<name>PyObject</name> *)&amp;<name>PyBool_Type</name> || <name>func</name> == <name>Py_None</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>ok</name> = <call><name>PyObject_IsTrue</name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>good</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>PyTuple_SET_ITEM</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>good</name> = <call><name>PyObject_Call</name><argument_list>(<argument><expr><name>func</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyTuple_SET_ITEM</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>good</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>Fail_result_it</name>;</goto>
}</block></then></if>
<expr_stmt><expr><name>ok</name> = <call><name>PyObject_IsTrue</name><argument_list>(<argument><expr><name>good</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>good</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></else></if>
<if>if <condition>(<expr><name>ok</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr><name>j</name> &lt; <name>len</name></expr>)</condition><then>
<expr_stmt><expr><call><name>PyList_SET_ITEM</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
<else>else <block>{
<decl_stmt><decl><type><name>int</name></type> <name>status</name> <init>= <expr><call><name>PyList_Append</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>item</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>status</name> &lt; 0</expr>)</condition><then>
<goto>goto <name>Fail_result_it</name>;</goto></then></if>
}</block></else></if>
<expr_stmt><expr>++<name>j</name></expr>;</expr_stmt>
}</block></then> <else>else
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
}</block></for>
<if>if <condition>(<expr><name>j</name> &lt; <name>len</name> &amp;&amp; <call><name>PyList_SetSlice</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
<goto>goto <name>Fail_result_it</name>;</goto></then></if>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>it</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>result</name></expr>;</return>
<label><name>Fail_result_it</name>:</label>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<label><name>Fail_it</name>:</label>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>it</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<label><name>Fail_arg</name>:</label>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>filter_doc</name></expr></argument>,
<argument><expr>"filter(function or None, sequence) -&gt; list, tuple, or string\n"
"\n"
"Return those items of sequence for which function(item) is true. If\n"
"function is None, return the items that are true. If sequence is a tuple\n"
"or string, return the same type, else return a list."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>builtin_format</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>value</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>format_spec</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"O|O:format"</expr></argument>, <argument><expr>&amp;<name>value</name></expr></argument>, <argument><expr>&amp;<name>format_spec</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<return>return <expr><call><name>PyObject_Format</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><name>format_spec</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>format_doc</name></expr></argument>,
<argument><expr>"format(value[, format_spec]) -&gt; string\n\
\n\
Returns value.__format__(format_spec)\n\
format_spec defaults to \"\""</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>builtin_chr</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>long</name></type> <name>x</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name><name>s</name><index>[<expr>1</expr>]</index></name></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"l:chr"</expr></argument>, <argument><expr>&amp;<name>x</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<if>if <condition>(<expr><name>x</name> &lt; 0 || <name>x</name> &gt;= 256</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>,
<argument><expr>"chr() arg not in range(256)"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name><name>s</name><index>[<expr>0</expr>]</index></name> = (<name>char</name>)<name>x</name></expr>;</expr_stmt>
<return>return <expr><call><name>PyString_FromStringAndSize</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>chr_doc</name></expr></argument>,
<argument><expr>"chr(i) -&gt; character\n\
\n\
Return a string of one character with ordinal i; 0 &lt;= i &lt; 256."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>Py_USING_UNICODE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>builtin_unichr</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>x</name></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"i:unichr"</expr></argument>, <argument><expr>&amp;<name>x</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<return>return <expr><call><name>PyUnicode_FromOrdinal</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>unichr_doc</name></expr></argument>,
<argument><expr>"unichr(i) -&gt; Unicode character\n\
\n\
Return a Unicode string of one character with ordinal i; 0 &lt;= i &lt;= 0x10ffff."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>builtin_cmp</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>a</name></decl>, *<decl><type ref="prev"/><name>b</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>c</name></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>PyArg_UnpackTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"cmp"</expr></argument>, <argument><expr>2</expr></argument>, <argument><expr>2</expr></argument>, <argument><expr>&amp;<name>a</name></expr></argument>, <argument><expr>&amp;<name>b</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<if>if <condition>(<expr><call><name>PyObject_Cmp</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr>&amp;<name>c</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<return>return <expr><call><name>PyInt_FromLong</name><argument_list>(<argument><expr>(<name>long</name>)<name>c</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>cmp_doc</name></expr></argument>,
<argument><expr>"cmp(x, y) -&gt; integer\n\
\n\
Return negative if x&lt;y, zero if x==y, positive if x&gt;y."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>builtin_coerce</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>v</name></decl>, *<decl><type ref="prev"/><name>w</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>res</name></decl>;</decl_stmt>
<if>if <condition>(<expr><call><name>PyErr_WarnPy3k</name><argument_list>(<argument><expr>"coerce() not supported in 3.x"</expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<if>if <condition>(<expr>!<call><name>PyArg_UnpackTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"coerce"</expr></argument>, <argument><expr>2</expr></argument>, <argument><expr>2</expr></argument>, <argument><expr>&amp;<name>v</name></expr></argument>, <argument><expr>&amp;<name>w</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<if>if <condition>(<expr><call><name>PyNumber_Coerce</name><argument_list>(<argument><expr>&amp;<name>v</name></expr></argument>, <argument><expr>&amp;<name>w</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>res</name> = <call><name>PyTuple_Pack</name><argument_list>(<argument><expr>2</expr></argument>, <argument><expr><name>v</name></expr></argument>, <argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>res</name></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>coerce_doc</name></expr></argument>,
<argument><expr>"coerce(x, y) -&gt; (x1, y1)\n\
\n\
Return a tuple consisting of the two numeric arguments converted to\n\
a common type, using the same rules as used by arithmetic operations.\n\
If coercion is not possible, raise TypeError."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>builtin_compile</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>kwds</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>char</name> *</type><name>str</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>filename</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>startstr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>mode</name> <init>= <expr>-1</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>dont_inherit</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>supplied_flags</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyCompilerFlags</name></type> <name>cf</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>result</name> <init>= <expr><name>NULL</name></expr></init>, *<name>cmd</name></decl>, *<decl><type ref="prev"/><name>tmp</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>length</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> *</type><name><name>kwlist</name><index>[]</index></name> <init>= <expr><block>{<expr>"source"</expr>, <expr>"filename"</expr>, <expr>"mode"</expr>, <expr>"flags"</expr>,
<expr>"dont_inherit"</expr>, <expr><name>NULL</name></expr>
}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name><name>start</name><index>[]</index></name> <init>= <expr><block>{<expr><name>Py_file_input</name></expr>, <expr><name>Py_eval_input</name></expr>, <expr><name>Py_single_input</name></expr>}</block></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTupleAndKeywords</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>kwds</name></expr></argument>, <argument><expr>"Oss|ii:compile"</expr></argument>,
<argument><expr><name>kwlist</name></expr></argument>, <argument><expr>&amp;<name>cmd</name></expr></argument>, <argument><expr>&amp;<name>filename</name></expr></argument>, <argument><expr>&amp;<name>startstr</name></expr></argument>,
<argument><expr>&amp;<name>supplied_flags</name></expr></argument>, <argument><expr>&amp;<name>dont_inherit</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name><name>cf</name>.<name>cf_flags</name></name> = <name>supplied_flags</name></expr>;</expr_stmt>
<if>if <condition>(<expr><name>supplied_flags</name> &amp;
~(<name>PyCF_MASK</name> | <name>PyCF_MASK_OBSOLETE</name> | <name>PyCF_DONT_IMPLY_DEDENT</name> | <name>PyCF_ONLY_AST</name>)</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>,
<argument><expr>"compile(): unrecognised flags"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<if>if <condition>(<expr>!<name>dont_inherit</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyEval_MergeCompilerFlags</name><argument_list>(<argument><expr>&amp;<name>cf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>startstr</name></expr></argument>, <argument><expr>"exec"</expr></argument>)</argument_list></call> == 0</expr>)</condition><then>
<expr_stmt><expr><name>mode</name> = 0</expr>;</expr_stmt></then>
<else>else <if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>startstr</name></expr></argument>, <argument><expr>"eval"</expr></argument>)</argument_list></call> == 0</expr>)</condition><then>
<expr_stmt><expr><name>mode</name> = 1</expr>;</expr_stmt></then>
<else>else <if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>startstr</name></expr></argument>, <argument><expr>"single"</expr></argument>)</argument_list></call> == 0</expr>)</condition><then>
<expr_stmt><expr><name>mode</name> = 2</expr>;</expr_stmt></then>
<else>else <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>,
<argument><expr>"compile() arg 3 must be 'exec', 'eval' or 'single'"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></else></if></else></if></else></if>
<if>if <condition>(<expr><call><name>PyAST_Check</name><argument_list>(<argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<if>if <condition>(<expr><name>supplied_flags</name> &amp; <name>PyCF_ONLY_AST</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>result</name> = <name>cmd</name></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<decl_stmt><decl><type><name>PyArena</name> *</type><name>arena</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>mod_ty</name></type> <name>mod</name></decl>;</decl_stmt>
<expr_stmt><expr><name>arena</name> = <call><name>PyArena_New</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>mod</name> = <call><name>PyAST_obj2mod</name><argument_list>(<argument><expr><name>cmd</name></expr></argument>, <argument><expr><name>arena</name></expr></argument>, <argument><expr><name>mode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>mod</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyArena_Free</name><argument_list>(<argument><expr><name>arena</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>result</name> = (<name>PyObject</name>*)<call><name>PyAST_Compile</name><argument_list>(<argument><expr><name>mod</name></expr></argument>, <argument><expr><name>filename</name></expr></argument>,
<argument><expr>&amp;<name>cf</name></expr></argument>, <argument><expr><name>arena</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyArena_Free</name><argument_list>(<argument><expr><name>arena</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></else></if>
<return>return <expr><name>result</name></expr>;</return>
}</block></then></if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>Py_USING_UNICODE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if>if <condition>(<expr><call><name>PyUnicode_Check</name><argument_list>(<argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><name>tmp</name> = <call><name>PyUnicode_AsUTF8String</name><argument_list>(<argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>tmp</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>cmd</name> = <name>tmp</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cf</name>.<name>cf_flags</name></name> |= <name>PyCF_SOURCE_IS_UTF8</name></expr>;</expr_stmt>
}</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<if>if <condition>(<expr><call><name>PyObject_AsReadBuffer</name><argument_list>(<argument><expr><name>cmd</name></expr></argument>, <argument><expr>(const <name>void</name> **)&amp;<name>str</name></expr></argument>, <argument><expr>&amp;<name>length</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<goto>goto <name>cleanup</name>;</goto></then></if>
<if>if <condition>(<expr>(<name>size_t</name>)<name>length</name> != <call><name>strlen</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
<argument><expr>"compile() expected string without null bytes"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>cleanup</name>;</goto>
}</block></then></if>
<expr_stmt><expr><name>result</name> = <call><name>Py_CompileStringFlags</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>filename</name></expr></argument>, <argument><expr><name><name>start</name><index>[<expr><name>mode</name></expr>]</index></name></expr></argument>, <argument><expr>&amp;<name>cf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<label><name>cleanup</name>:</label>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>result</name></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>compile_doc</name></expr></argument>,
<argument><expr>"compile(source, filename, mode[, flags[, dont_inherit]]) -&gt; code object\n\
\n\
Compile the source string (a Python module, statement or expression)\n\
into a code object that can be executed by the exec statement or eval().\n\
The filename will be used for run-time error messages.\n\
The mode must be 'exec' to compile a module, 'single' to compile a\n\
single (interactive) statement, or 'eval' to compile an expression.\n\
The flags argument, if present, controls which future statements influence\n\
the compilation of the code.\n\
The dont_inherit argument, if non-zero, stops the compilation inheriting\n\
the effects of any future statements in effect in the code calling\n\
compile; if absent or zero these statements do influence the compilation,\n\
in addition to any features explicitly specified."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>builtin_dir</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>arg</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>PyArg_UnpackTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"dir"</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>1</expr></argument>, <argument><expr>&amp;<name>arg</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<return>return <expr><call><name>PyObject_Dir</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>dir_doc</name></expr></argument>,
<argument><expr>"dir([object]) -&gt; list of strings\n"
"\n"
"If called without an argument, return the names in the current scope.\n"
"Else, return an alphabetized list of names comprising (some of) the attributes\n"
"of the given object, and of attributes reachable from it.\n"
"If the object supplies a method named __dir__, it will be used; otherwise\n"
"the default dir() logic is used and returns:\n"
" for a module object: the module's attributes.\n"
" for a class object: its attributes, and recursively the attributes\n"
" of its bases.\n"
" for any other object: its attributes, its class's attributes, and\n"
" recursively the attributes of its class's base classes."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>builtin_divmod</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>v</name></decl>, *<decl><type ref="prev"/><name>w</name></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>PyArg_UnpackTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"divmod"</expr></argument>, <argument><expr>2</expr></argument>, <argument><expr>2</expr></argument>, <argument><expr>&amp;<name>v</name></expr></argument>, <argument><expr>&amp;<name>w</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<return>return <expr><call><name>PyNumber_Divmod</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>divmod_doc</name></expr></argument>,
<argument><expr>"divmod(x, y) -&gt; (div, mod)\n\
\n\
Return the tuple ((x-x%y)/y, x%y). Invariant: div*y + mod == x."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>builtin_eval</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>cmd</name></decl>, *<decl><type ref="prev"/><name>result</name></decl>, *<decl><type ref="prev"/><name>tmp</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>globals</name> <init>= <expr><name>Py_None</name></expr></init>, *<name>locals</name> <init>= <expr><name>Py_None</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>str</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyCompilerFlags</name></type> <name>cf</name></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>PyArg_UnpackTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"eval"</expr></argument>, <argument><expr>1</expr></argument>, <argument><expr>3</expr></argument>, <argument><expr>&amp;<name>cmd</name></expr></argument>, <argument><expr>&amp;<name>globals</name></expr></argument>, <argument><expr>&amp;<name>locals</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<if>if <condition>(<expr><name>locals</name> != <name>Py_None</name> &amp;&amp; !<call><name>PyMapping_Check</name><argument_list>(<argument><expr><name>locals</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>, <argument><expr>"locals must be a mapping"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<if>if <condition>(<expr><name>globals</name> != <name>Py_None</name> &amp;&amp; !<call><name>PyDict_Check</name><argument_list>(<argument><expr><name>globals</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>, <argument><expr><call><name>PyMapping_Check</name><argument_list>(<argument><expr><name>globals</name></expr></argument>)</argument_list></call> ?
"globals must be a real dict; try eval(expr, {}, mapping)"
: "globals must be a dict"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<if>if <condition>(<expr><name>globals</name> == <name>Py_None</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>globals</name> = <call><name>PyEval_GetGlobals</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>locals</name> == <name>Py_None</name></expr>)</condition><then>
<expr_stmt><expr><name>locals</name> = <call><name>PyEval_GetLocals</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>
}</block></then> <else>else <if>if <condition>(<expr><name>locals</name> == <name>Py_None</name></expr>)</condition><then>
<expr_stmt><expr><name>locals</name> = <name>globals</name></expr>;</expr_stmt></then></if></else></if>
<if>if <condition>(<expr><name>globals</name> == <name>NULL</name> || <name>locals</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
<argument><expr>"eval must be given globals and locals "
"when called without a frame"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<if>if <condition>(<expr><call><name>PyDict_GetItemString</name><argument_list>(<argument><expr><name>globals</name></expr></argument>, <argument><expr>"__builtins__"</expr></argument>)</argument_list></call> == <name>NULL</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr><call><name>PyDict_SetItemString</name><argument_list>(<argument><expr><name>globals</name></expr></argument>, <argument><expr>"__builtins__"</expr></argument>,
<argument><expr><call><name>PyEval_GetBuiltins</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call> != 0</expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
}</block></then></if>
<if>if <condition>(<expr><call><name>PyCode_Check</name><argument_list>(<argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<if>if <condition>(<expr><call><name>PyCode_GetNumFree</name><argument_list>(<argument><expr>(<name>PyCodeObject</name> *)<name>cmd</name></expr></argument>)</argument_list></call> &gt; 0</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
<argument><expr>"code object passed to eval() may not contain free variables"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<return>return <expr><call><name>PyEval_EvalCode</name><argument_list>(<argument><expr>(<name>PyCodeObject</name> *) <name>cmd</name></expr></argument>, <argument><expr><name>globals</name></expr></argument>, <argument><expr><name>locals</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></then></if>
<if>if <condition>(<expr>!<call><name>PyString_Check</name><argument_list>(<argument><expr><name>cmd</name></expr></argument>)</argument_list></call> &amp;&amp;
!<call><name>PyUnicode_Check</name><argument_list>(<argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
<argument><expr>"eval() arg 1 must be a string or code object"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name><name>cf</name>.<name>cf_flags</name></name> = 0</expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>Py_USING_UNICODE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if>if <condition>(<expr><call><name>PyUnicode_Check</name><argument_list>(<argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><name>tmp</name> = <call><name>PyUnicode_AsUTF8String</name><argument_list>(<argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>tmp</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>cmd</name> = <name>tmp</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cf</name>.<name>cf_flags</name></name> |= <name>PyCF_SOURCE_IS_UTF8</name></expr>;</expr_stmt>
}</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<if>if <condition>(<expr><call><name>PyString_AsStringAndSize</name><argument_list>(<argument><expr><name>cmd</name></expr></argument>, <argument><expr>&amp;<name>str</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<while>while <condition>(<expr>*<name>str</name> == ' ' || *<name>str</name> == '\t'</expr>)</condition>
<expr_stmt><expr><name>str</name>++</expr>;</expr_stmt></while>
<expr_stmt><expr>(<name>void</name>)<call><name>PyEval_MergeCompilerFlags</name><argument_list>(<argument><expr>&amp;<name>cf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>result</name> = <call><name>PyRun_StringFlags</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>Py_eval_input</name></expr></argument>, <argument><expr><name>globals</name></expr></argument>, <argument><expr><name>locals</name></expr></argument>, <argument><expr>&amp;<name>cf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>result</name></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>eval_doc</name></expr></argument>,
<argument><expr>"eval(source[, globals[, locals]]) -&gt; value\n\
\n\
Evaluate the source in the context of globals and locals.\n\
The source may be a string representing a Python expression\n\
or a code object as returned by compile().\n\
The globals must be a dictionary and locals can be any mapping,\n\
defaulting to the current globals and locals.\n\
If only globals is given, locals defaults to it.\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>builtin_execfile</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>char</name> *</type><name>filename</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>globals</name> <init>= <expr><name>Py_None</name></expr></init>, *<name>locals</name> <init>= <expr><name>Py_None</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>res</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>FILE</name>*</type> <name>fp</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyCompilerFlags</name></type> <name>cf</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>exists</name></decl>;</decl_stmt>
<if>if <condition>(<expr><call><name>PyErr_WarnPy3k</name><argument_list>(<argument><expr>"execfile() not supported in 3.x; use exec()"</expr></argument>,
<argument><expr>1</expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"s|O!O:execfile"</expr></argument>,
<argument><expr>&amp;<name>filename</name></expr></argument>,
<argument><expr>&amp;<name>PyDict_Type</name></expr></argument>, <argument><expr>&amp;<name>globals</name></expr></argument>,
<argument><expr>&amp;<name>locals</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<if>if <condition>(<expr><name>locals</name> != <name>Py_None</name> &amp;&amp; !<call><name>PyMapping_Check</name><argument_list>(<argument><expr><name>locals</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>, <argument><expr>"locals must be a mapping"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<if>if <condition>(<expr><name>globals</name> == <name>Py_None</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>globals</name> = <call><name>PyEval_GetGlobals</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>locals</name> == <name>Py_None</name></expr>)</condition><then>
<expr_stmt><expr><name>locals</name> = <call><name>PyEval_GetLocals</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>
}</block></then> <else>else <if>if <condition>(<expr><name>locals</name> == <name>Py_None</name></expr>)</condition><then>
<expr_stmt><expr><name>locals</name> = <name>globals</name></expr>;</expr_stmt></then></if></else></if>
<if>if <condition>(<expr><call><name>PyDict_GetItemString</name><argument_list>(<argument><expr><name>globals</name></expr></argument>, <argument><expr>"__builtins__"</expr></argument>)</argument_list></call> == <name>NULL</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr><call><name>PyDict_SetItemString</name><argument_list>(<argument><expr><name>globals</name></expr></argument>, <argument><expr>"__builtins__"</expr></argument>,
<argument><expr><call><name>PyEval_GetBuiltins</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call> != 0</expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
}</block></then></if>
<expr_stmt><expr><name>exists</name> = 0</expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>PLAN9</name></expr></argument>)</argument_list></call></expr></cpp:if>
<block>{
<decl_stmt><decl><type><name>Dir</name> *</type><name>d</name></decl>;</decl_stmt>
<if>if <condition>(<expr>(<name>d</name> = <call><name>dirstat</name><argument_list>(<argument><expr><name>filename</name></expr></argument>)</argument_list></call>)!=<name>nil</name></expr>)</condition><then> <block>{
<if>if<condition>(<expr><name><name>d</name>-&gt;<name>mode</name></name> &amp; <name>DMDIR</name></expr>)</condition><then>
<expr_stmt><expr><call><name>werrstr</name><argument_list>(<argument><expr>"is a directory"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
<else>else
<expr_stmt><expr><name>exists</name> = 1</expr>;</expr_stmt></else></if>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
}</block>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>RISCOS</name></expr></argument>)</argument_list></call></expr></cpp:elif>
<if>if <condition>(<expr><call><name>object_exists</name><argument_list>(<argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<if>if <condition>(<expr><call><name>isdir</name><argument_list>(<argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<expr_stmt><expr><name>errno</name> = <name>EISDIR</name></expr>;</expr_stmt></then>
<else>else
<expr_stmt><expr><name>exists</name> = 1</expr>;</expr_stmt></else></if>
}</block></then></if>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<block>{
<decl_stmt><decl><type>struct <name>stat</name></type> <name>s</name></decl>;</decl_stmt>
<if>if <condition>(<expr><call><name>stat</name><argument_list>(<argument><expr><name>filename</name></expr></argument>, <argument><expr>&amp;<name>s</name></expr></argument>)</argument_list></call> == 0</expr>)</condition><then> <block>{
<if>if <condition>(<expr><call><name>S_ISDIR</name><argument_list>(<argument><expr><name><name>s</name>.<name>st_mode</name></name></expr></argument>)</argument_list></call></expr>)</condition><then>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>PYOS_OS2</name></expr></argument>)</argument_list></call> &amp;&amp; <call><name>defined</name><argument_list>(<argument><expr><name>PYCC_VACPP</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><name>errno</name> = <name>EOS2ERR</name></expr>;</expr_stmt></then></if>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<expr_stmt><expr><name>errno</name> = <name>EISDIR</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<else>else
<expr_stmt><expr><name>exists</name> = 1</expr>;</expr_stmt></else>
}</block></then></if>
}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<if>if <condition>(<expr><name>exists</name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>Py_BEGIN_ALLOW_THREADS</name></type>
<name>fp</name> <init>= <expr><call><name>fopen</name><argument_list>(<argument><expr><name>filename</name></expr></argument>, <argument><expr>"r" <name>PY_STDIOTEXTMODE</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<macro><name>Py_END_ALLOW_THREADS</name></macro>
<if>if <condition>(<expr><name>fp</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>exists</name> = 0</expr>;</expr_stmt>
}</block></then></if>
}</block></then></if>
<if>if <condition>(<expr>!<name>exists</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetFromErrnoWithFilename</name><argument_list>(<argument><expr><name>PyExc_IOError</name></expr></argument>, <argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name><name>cf</name>.<name>cf_flags</name></name> = 0</expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>PyEval_MergeCompilerFlags</name><argument_list>(<argument><expr>&amp;<name>cf</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<expr_stmt><expr><name>res</name> = <call><name>PyRun_FileExFlags</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><name>filename</name></expr></argument>, <argument><expr><name>Py_file_input</name></expr></argument>, <argument><expr><name>globals</name></expr></argument>,
<argument><expr><name>locals</name></expr></argument>, <argument><expr>1</expr></argument>, <argument><expr>&amp;<name>cf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
<else>else
<expr_stmt><expr><name>res</name> = <call><name>PyRun_FileEx</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><name>filename</name></expr></argument>, <argument><expr><name>Py_file_input</name></expr></argument>, <argument><expr><name>globals</name></expr></argument>,
<argument><expr><name>locals</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
<return>return <expr><name>res</name></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>execfile_doc</name></expr></argument>,
<argument><expr>"execfile(filename[, globals[, locals]])\n\
\n\
Read and execute a Python script from a file.\n\
The globals and locals are dictionaries, defaulting to the current\n\
globals and locals. If only globals is given, locals defaults to it."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>builtin_getattr</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>v</name></decl>, *<decl><type ref="prev"/><name>result</name></decl>, *<decl><type ref="prev"/><name>dflt</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>name</name></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>PyArg_UnpackTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"getattr"</expr></argument>, <argument><expr>2</expr></argument>, <argument><expr>3</expr></argument>, <argument><expr>&amp;<name>v</name></expr></argument>, <argument><expr>&amp;<name>name</name></expr></argument>, <argument><expr>&amp;<name>dflt</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>Py_USING_UNICODE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if>if <condition>(<expr><call><name>PyUnicode_Check</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><name>name</name> = <call><name>_PyUnicode_AsDefaultEncodedString</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>name</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
}</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<if>if <condition>(<expr>!<call><name>PyString_Check</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
<argument><expr>"getattr(): attribute name must be string"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>result</name> = <call><name>PyObject_GetAttr</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>result</name> == <name>NULL</name> &amp;&amp; <name>dflt</name> != <name>NULL</name> &amp;&amp;
<call><name>PyErr_ExceptionMatches</name><argument_list>(<argument><expr><name>PyExc_AttributeError</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_Clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>dflt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>result</name> = <name>dflt</name></expr>;</expr_stmt>
}</block></then></if>
<return>return <expr><name>result</name></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>getattr_doc</name></expr></argument>,
<argument><expr>"getattr(object, name[, default]) -&gt; value\n\
\n\
Get a named attribute from an object; getattr(x, 'y') is equivalent to x.y.\n\
When a default argument is given, it is returned when the attribute doesn't\n\
exist; without it, an exception is raised in that case."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>builtin_globals</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>d</name></decl>;</decl_stmt>
<expr_stmt><expr><name>d</name> = <call><name>PyEval_GetGlobals</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_XINCREF</name><argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>d</name></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>globals_doc</name></expr></argument>,
<argument><expr>"globals() -&gt; dictionary\n\
\n\
Return the dictionary containing the current scope's global variables."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>builtin_hasattr</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>v</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>name</name></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>PyArg_UnpackTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"hasattr"</expr></argument>, <argument><expr>2</expr></argument>, <argument><expr>2</expr></argument>, <argument><expr>&amp;<name>v</name></expr></argument>, <argument><expr>&amp;<name>name</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>Py_USING_UNICODE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if>if <condition>(<expr><call><name>PyUnicode_Check</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><name>name</name> = <call><name>_PyUnicode_AsDefaultEncodedString</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>name</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
}</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<if>if <condition>(<expr>!<call><name>PyString_Check</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
<argument><expr>"hasattr(): attribute name must be string"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>v</name> = <call><name>PyObject_GetAttr</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>v</name> == <name>NULL</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr>!<call><name>PyErr_ExceptionMatches</name><argument_list>(<argument><expr><name>PyExc_Exception</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then>
<else>else <block>{
<expr_stmt><expr><call><name>PyErr_Clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_False</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>Py_False</name></expr>;</return>
}</block></else></if>
}</block></then></if>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_True</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>Py_True</name></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>hasattr_doc</name></expr></argument>,
<argument><expr>"hasattr(object, name) -&gt; bool\n\
\n\
Return whether the object has an attribute with the given name.\n\
(This is done by calling getattr(object, name) and catching exceptions.)"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>builtin_id</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>v</name></decl></param>)</parameter_list> <block>{
<return>return <expr><call><name>PyLong_FromVoidPtr</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>id_doc</name></expr></argument>,
<argument><expr>"id(object) -&gt; integer\n\
\n\
Return the identity of an object. This is guaranteed to be unique among\n\
simultaneously existing objects. (Hint: it's the object's memory address.)"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>builtin_map</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<typedef>typedef <type><struct>struct <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>it</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>saw_StopIteration</name></decl>;</decl_stmt>
}</block></struct></type> <name>sequence</name>;</typedef>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>func</name></decl>, *<decl><type ref="prev"/><name>result</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>sequence</name> *</type><name>seqs</name> <init>= <expr><name>NULL</name></expr></init>, *<name>sqp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>n</name></decl>, <decl><type ref="prev"/><name>len</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>register</name> <name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>
<expr_stmt><expr><name>n</name> = <call><name>PyTuple_Size</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>n</name> &lt; 2</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
<argument><expr>"map() requires at least two args"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>func</name> = <call><name>PyTuple_GetItem</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>n</name>--</expr>;</expr_stmt>
<if>if <condition>(<expr><name>func</name> == <name>Py_None</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr><call><name>PyErr_WarnPy3k</name><argument_list>(<argument><expr>"map(None, ...) not supported in 3.x; "
"use list(...)"</expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<if>if <condition>(<expr><name>n</name> == 1</expr>)</condition><then> <block>{
<return>return <expr><call><name>PySequence_List</name><argument_list>(<argument><expr><call><name>PyTuple_GetItem</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></then></if>
}</block></then></if>
<if>if <condition>(<expr>(<name>seqs</name> = <call><name>PyMem_NEW</name><argument_list>(<argument><expr><name>sequence</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call>) == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_NoMemory</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>n</name></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>) <block>{
<expr_stmt><expr><name><name>seqs</name><index>[<expr><name>i</name></expr>]</index></name>.<name>it</name> = (<name>PyObject</name>*)<name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>seqs</name><index>[<expr><name>i</name></expr>]</index></name>.<name>saw_StopIteration</name> = 0</expr>;</expr_stmt>
}</block></for>
<expr_stmt><expr><name>len</name> = 0</expr>;</expr_stmt>
<for>for (<init><expr><name>i</name> = 0</expr>, <expr><name>sqp</name> = <name>seqs</name></expr>;</init> <condition><expr><name>i</name> &lt; <name>n</name></expr>;</condition> <incr><expr>++<name>i</name></expr>, <expr>++<name>sqp</name></expr></incr>) <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>curseq</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>curlen</name></decl>;</decl_stmt>
<expr_stmt><expr><name>curseq</name> = <call><name>PyTuple_GetItem</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>i</name>+1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>sqp</name>-&gt;<name>it</name></name> = <call><name>PyObject_GetIter</name><argument_list>(<argument><expr><name>curseq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>sqp</name>-&gt;<name>it</name></name> == <name>NULL</name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name><name>errmsg</name><index>[]</index></name> <init>=
<expr>"argument %d to map() must support iteration"</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name><name>errbuf</name><index>[<expr><sizeof>sizeof<argument_list>(<argument><expr><name>errmsg</name></expr></argument>)</argument_list></sizeof> + 25</expr>]</index></name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>PyOS_snprintf</name><argument_list>(<argument><expr><name>errbuf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>errbuf</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>errmsg</name></expr></argument>, <argument><expr><name>i</name>+2</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>, <argument><expr><name>errbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>Fail_2</name>;</goto>
}</block></then></if>
<expr_stmt><expr><name>curlen</name> = <call><name>_PyObject_LengthHint</name><argument_list>(<argument><expr><name>curseq</name></expr></argument>, <argument><expr>8</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>curlen</name> &gt; <name>len</name></expr>)</condition><then>
<expr_stmt><expr><name>len</name> = <name>curlen</name></expr>;</expr_stmt></then></if>
}</block></for>
<if>if <condition>(<expr>(<name>result</name> = (<name>PyObject</name> *) <call><name>PyList_New</name><argument_list>(<argument><expr><name>len</name></expr></argument>)</argument_list></call>) == <name>NULL</name></expr>)</condition><then>
<goto>goto <name>Fail_2</name>;</goto></then></if>
<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition>;</condition> <incr><expr>++<name>i</name></expr></incr>) <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>alist</name></decl>, *<decl><type ref="prev"/><name>item</name><init>=<expr><name>NULL</name></expr></init>, *<name>value</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>numactive</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>func</name> == <name>Py_None</name> &amp;&amp; <name>n</name> == 1</expr>)</condition><then>
<expr_stmt><expr><name>alist</name> = <name>NULL</name></expr>;</expr_stmt></then>
<else>else <if>if <condition>(<expr>(<name>alist</name> = <call><name>PyTuple_New</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call>) == <name>NULL</name></expr>)</condition><then>
<goto>goto <name>Fail_1</name>;</goto></then></if></else></if>
<for>for (<init><expr><name>j</name> = 0</expr>, <expr><name>sqp</name> = <name>seqs</name></expr>;</init> <condition><expr><name>j</name> &lt; <name>n</name></expr>;</condition> <incr><expr>++<name>j</name></expr>, <expr>++<name>sqp</name></expr></incr>) <block>{
<if>if <condition>(<expr><name><name>sqp</name>-&gt;<name>saw_StopIteration</name></name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>item</name> = <name>Py_None</name></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr><name>item</name> = <call><name>PyIter_Next</name><argument_list>(<argument><expr><name><name>sqp</name>-&gt;<name>it</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>item</name></expr>)</condition><then>
<expr_stmt><expr>++<name>numactive</name></expr>;</expr_stmt></then>
<else>else <block>{
<if>if <condition>(<expr><call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>alist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>Fail_1</name>;</goto>
}</block></then></if>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>item</name> = <name>Py_None</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>sqp</name>-&gt;<name>saw_StopIteration</name></name> = 1</expr>;</expr_stmt>
}</block></else></if>
}</block></else></if>
<if>if <condition>(<expr><name>alist</name></expr>)</condition><then>
<expr_stmt><expr><call><name>PyTuple_SET_ITEM</name><argument_list>(<argument><expr><name>alist</name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
<else>else
<break>break;</break></else></if>
}</block></for>
<if>if <condition>(<expr>!<name>alist</name></expr>)</condition><then>
<expr_stmt><expr><name>alist</name> = <name>item</name></expr>;</expr_stmt></then></if>
<if>if <condition>(<expr><name>numactive</name> == 0</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>alist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
}</block></then></if>
<if>if <condition>(<expr><name>func</name> == <name>Py_None</name></expr>)</condition><then>
<expr_stmt><expr><name>value</name> = <name>alist</name></expr>;</expr_stmt></then>
<else>else <block>{
<expr_stmt><expr><name>value</name> = <call><name>PyEval_CallObject</name><argument_list>(<argument><expr><name>func</name></expr></argument>, <argument><expr><name>alist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>alist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>value</name> == <name>NULL</name></expr>)</condition><then>
<goto>goto <name>Fail_1</name>;</goto></then></if>
}</block></else></if>
<if>if <condition>(<expr><name>i</name> &gt;= <name>len</name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>status</name> <init>= <expr><call><name>PyList_Append</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>status</name> &lt; 0</expr>)</condition><then>
<goto>goto <name>Fail_1</name>;</goto></then></if>
}</block></then> <else>else <if>if <condition>(<expr><call><name>PyList_SetItem</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
<goto>goto <name>Fail_1</name>;</goto></then></if></else></if>
}</block></for>
<if>if <condition>(<expr><name>i</name> &lt; <name>len</name> &amp;&amp; <call><name>PyList_SetSlice</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
<goto>goto <name>Fail_1</name>;</goto></then></if>
<goto>goto <name>Succeed</name>;</goto>
<label><name>Fail_1</name>:</label>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<label><name>Fail_2</name>:</label>
<expr_stmt><expr><name>result</name> = <name>NULL</name></expr>;</expr_stmt>
<label><name>Succeed</name>:</label>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>seqs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>n</name></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>)
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name><name>seqs</name><index>[<expr><name>i</name></expr>]</index></name>.<name>it</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></for>
<expr_stmt><expr><call><name>PyMem_DEL</name><argument_list>(<argument><expr><name>seqs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>result</name></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>map_doc</name></expr></argument>,
<argument><expr>"map(function, sequence[, sequence, ...]) -&gt; list\n\
\n\
Return a list of the results of applying the function to the items of\n\
the argument sequence(s). If more than one sequence is given, the\n\
function is called with an argument list consisting of the corresponding\n\
item of each sequence, substituting None for missing values when not all\n\
sequences have the same length. If the function is None, return a list of\n\
the items of the sequence (or a list of tuples if more than one sequence)."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>builtin_next</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>it</name></decl>, *<decl><type ref="prev"/><name>res</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>def</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>PyArg_UnpackTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"next"</expr></argument>, <argument><expr>1</expr></argument>, <argument><expr>2</expr></argument>, <argument><expr>&amp;<name>it</name></expr></argument>, <argument><expr>&amp;<name>def</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<if>if <condition>(<expr>!<call><name>PyIter_Check</name><argument_list>(<argument><expr><name>it</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
<argument><expr>"%.200s object is not an iterator"</expr></argument>,
<argument><expr><name><name>it</name>-&gt;<name>ob_type</name>-&gt;<name>tp_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>res</name> = <call>(*<name><name>it</name>-&gt;<name>ob_type</name>-&gt;<name>tp_iternext</name></name>)<argument_list>(<argument><expr><name>it</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>res</name> != <name>NULL</name></expr>)</condition><then> <block>{
<return>return <expr><name>res</name></expr>;</return>
}</block></then> <else>else <if>if <condition>(<expr><name>def</name> != <name>NULL</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr><call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
<if>if <condition>(<expr>!<call><name>PyErr_ExceptionMatches</name><argument_list>(<argument><expr><name>PyExc_StopIteration</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><call><name>PyErr_Clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>def</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>def</name></expr>;</return>
}</block></then> <else>else <if>if <condition>(<expr><call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then> <else>else <block>{
<expr_stmt><expr><call><name>PyErr_SetNone</name><argument_list>(<argument><expr><name>PyExc_StopIteration</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></else></if></else></if></else></if>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>next_doc</name></expr></argument>,
<argument><expr>"next(iterator[, default])\n\
\n\
Return the next item from the iterator. If default is given and the iterator\n\
is exhausted, it is returned instead of raising StopIteration."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>builtin_setattr</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>v</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>name</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>value</name></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>PyArg_UnpackTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"setattr"</expr></argument>, <argument><expr>3</expr></argument>, <argument><expr>3</expr></argument>, <argument><expr>&amp;<name>v</name></expr></argument>, <argument><expr>&amp;<name>name</name></expr></argument>, <argument><expr>&amp;<name>value</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<if>if <condition>(<expr><call><name>PyObject_SetAttr</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call> != 0</expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>Py_None</name></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>setattr_doc</name></expr></argument>,
<argument><expr>"setattr(object, name, value)\n\
\n\
Set a named attribute on an object; setattr(x, 'y', v) is equivalent to\n\
``x.y = v''."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>builtin_delattr</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>v</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>name</name></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>PyArg_UnpackTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"delattr"</expr></argument>, <argument><expr>2</expr></argument>, <argument><expr>2</expr></argument>, <argument><expr>&amp;<name>v</name></expr></argument>, <argument><expr>&amp;<name>name</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<if>if <condition>(<expr><call><name>PyObject_SetAttr</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr>(<name>PyObject</name> *)<name>NULL</name></expr></argument>)</argument_list></call> != 0</expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>Py_None</name></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>delattr_doc</name></expr></argument>,
<argument><expr>"delattr(object, name)\n\
\n\
Delete a named attribute on an object; delattr(x, 'y') is equivalent to\n\
``del x.y''."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>builtin_hash</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>v</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>long</name></type> <name>x</name></decl>;</decl_stmt>
<expr_stmt><expr><name>x</name> = <call><name>PyObject_Hash</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>x</name> == -1</expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<return>return <expr><call><name>PyInt_FromLong</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>hash_doc</name></expr></argument>,
<argument><expr>"hash(object) -&gt; integer\n\
\n\
Return a hash value for the object. Two objects with the same value have\n\
the same hash value. The reverse is not necessarily true, but likely."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>builtin_hex</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>v</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyNumberMethods</name> *</type><name>nb</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>res</name></decl>;</decl_stmt>
<if>if <condition>(<expr>(<name>nb</name> = <name><name>v</name>-&gt;<name>ob_type</name>-&gt;<name>tp_as_number</name></name>) == <name>NULL</name> ||
<name><name>nb</name>-&gt;<name>nb_hex</name></name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
<argument><expr>"hex() argument can't be converted to hex"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>res</name> = <call>(*<name><name>nb</name>-&gt;<name>nb_hex</name></name>)<argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>res</name> &amp;&amp; !<call><name>PyString_Check</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
<argument><expr>"__hex__ returned non-string (type %.200s)"</expr></argument>,
<argument><expr><name><name>res</name>-&gt;<name>ob_type</name>-&gt;<name>tp_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<return>return <expr><name>res</name></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>hex_doc</name></expr></argument>,
<argument><expr>"hex(number) -&gt; string\n\
\n\
Return the hexadecimal representation of an integer or long integer."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function_decl><type><specifier>static</specifier> <name>PyObject</name> *</type><name>builtin_raw_input</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type></decl></param>, <param><decl><type><name>PyObject</name> *</type></decl></param>)</parameter_list>;</function_decl>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>builtin_input</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>line</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>str</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>res</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>globals</name></decl>, *<decl><type ref="prev"/><name>locals</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyCompilerFlags</name></type> <name>cf</name></decl>;</decl_stmt>
<expr_stmt><expr><name>line</name> = <call><name>builtin_raw_input</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>line</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>line</name></expr>;</return></then></if>
<if>if <condition>(<expr>!<call><name>PyArg_Parse</name><argument_list>(<argument><expr><name>line</name></expr></argument>, <argument><expr>"s;embedded '\\0' in input line"</expr></argument>, <argument><expr>&amp;<name>str</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<while>while <condition>(<expr>*<name>str</name> == ' ' || *<name>str</name> == '\t'</expr>)</condition>
<expr_stmt><expr><name>str</name>++</expr>;</expr_stmt></while>
<expr_stmt><expr><name>globals</name> = <call><name>PyEval_GetGlobals</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>locals</name> = <call><name>PyEval_GetLocals</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>PyDict_GetItemString</name><argument_list>(<argument><expr><name>globals</name></expr></argument>, <argument><expr>"__builtins__"</expr></argument>)</argument_list></call> == <name>NULL</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr><call><name>PyDict_SetItemString</name><argument_list>(<argument><expr><name>globals</name></expr></argument>, <argument><expr>"__builtins__"</expr></argument>,
<argument><expr><call><name>PyEval_GetBuiltins</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call> != 0</expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
}</block></then></if>
<expr_stmt><expr><name><name>cf</name>.<name>cf_flags</name></name> = 0</expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyEval_MergeCompilerFlags</name><argument_list>(<argument><expr>&amp;<name>cf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>res</name> = <call><name>PyRun_StringFlags</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>Py_eval_input</name></expr></argument>, <argument><expr><name>globals</name></expr></argument>, <argument><expr><name>locals</name></expr></argument>, <argument><expr>&amp;<name>cf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>res</name></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>input_doc</name></expr></argument>,
<argument><expr>"input([prompt]) -&gt; value\n\
\n\
Equivalent to eval(raw_input(prompt))."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>builtin_intern</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>s</name></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"S:intern"</expr></argument>, <argument><expr>&amp;<name>s</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<if>if <condition>(<expr>!<call><name>PyString_CheckExact</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
<argument><expr>"can't intern subclass of string"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyString_InternInPlace</name><argument_list>(<argument><expr>&amp;<name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>s</name></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>intern_doc</name></expr></argument>,
<argument><expr>"intern(string) -&gt; string\n\
\n\
``Intern'' the given string. This enters the string in the (global)\n\
table of interned strings whose purpose is to speed up dictionary lookups.\n\
Return the string itself or the previously interned string object with the\n\
same value."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>builtin_iter</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>v</name></decl>, *<decl><type ref="prev"/><name>w</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>PyArg_UnpackTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"iter"</expr></argument>, <argument><expr>1</expr></argument>, <argument><expr>2</expr></argument>, <argument><expr>&amp;<name>v</name></expr></argument>, <argument><expr>&amp;<name>w</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<if>if <condition>(<expr><name>w</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><call><name>PyObject_GetIter</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
<if>if <condition>(<expr>!<call><name>PyCallable_Check</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
<argument><expr>"iter(v, w): v must be callable"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<return>return <expr><call><name>PyCallIter_New</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>iter_doc</name></expr></argument>,
<argument><expr>"iter(collection) -&gt; iterator\n\
iter(callable, sentinel) -&gt; iterator\n\
\n\
Get an iterator from an object. In the first form, the argument must\n\
supply its own iterator, or be a sequence.\n\
In the second form, the callable is called until it returns the sentinel."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>builtin_len</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>v</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>res</name></decl>;</decl_stmt>
<expr_stmt><expr><name>res</name> = <call><name>PyObject_Size</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>res</name> &lt; 0 &amp;&amp; <call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<return>return <expr><call><name>PyInt_FromSsize_t</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>len_doc</name></expr></argument>,
<argument><expr>"len(object) -&gt; integer\n\
\n\
Return the number of items of a sequence or mapping."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>builtin_locals</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>d</name></decl>;</decl_stmt>
<expr_stmt><expr><name>d</name> = <call><name>PyEval_GetLocals</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_XINCREF</name><argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>d</name></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>locals_doc</name></expr></argument>,
<argument><expr>"locals() -&gt; dictionary\n\
\n\
Update and return a dictionary containing the current scope's local variables."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>min_max</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>kwds</name></decl></param>, <param><decl><type><name>int</name></type> <name>op</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>v</name></decl>, *<decl><type ref="prev"/><name>it</name></decl>, *<decl><type ref="prev"/><name>item</name></decl>, *<decl><type ref="prev"/><name>val</name></decl>, *<decl><type ref="prev"/><name>maxitem</name></decl>, *<decl><type ref="prev"/><name>maxval</name></decl>, *<decl><type ref="prev"/><name>keyfunc</name><init>=<expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>name</name> <init>= <expr><name>op</name> == <name>Py_LT</name> ? "min" : "max"</expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><call><name>PyTuple_Size</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call> &gt; 1</expr>)</condition><then>
<expr_stmt><expr><name>v</name> = <name>args</name></expr>;</expr_stmt></then>
<else>else <if>if <condition>(<expr>!<call><name>PyArg_UnpackTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>(<name>char</name> *)<name>name</name></expr></argument>, <argument><expr>1</expr></argument>, <argument><expr>1</expr></argument>, <argument><expr>&amp;<name>v</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if></else></if>
<if>if <condition>(<expr><name>kwds</name> != <name>NULL</name> &amp;&amp; <call><name>PyDict_Check</name><argument_list>(<argument><expr><name>kwds</name></expr></argument>)</argument_list></call> &amp;&amp; <call><name>PyDict_Size</name><argument_list>(<argument><expr><name>kwds</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><name>keyfunc</name> = <call><name>PyDict_GetItemString</name><argument_list>(<argument><expr><name>kwds</name></expr></argument>, <argument><expr>"key"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>PyDict_Size</name><argument_list>(<argument><expr><name>kwds</name></expr></argument>)</argument_list></call>!=1 || <name>keyfunc</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
<argument><expr>"%s() got an unexpected keyword argument"</expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>keyfunc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><name>it</name> = <call><name>PyObject_GetIter</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>it</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>keyfunc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>maxitem</name> = <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name>maxval</name> = <name>NULL</name></expr>;</expr_stmt>
<while>while <condition>(<expr>( <name>item</name> = <call><name>PyIter_Next</name><argument_list>(<argument><expr><name>it</name></expr></argument>)</argument_list></call> )</expr>)</condition> <block>{
<if>if <condition>(<expr><name>keyfunc</name> != <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>val</name> = <call><name>PyObject_CallFunctionObjArgs</name><argument_list>(<argument><expr><name>keyfunc</name></expr></argument>, <argument><expr><name>item</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>val</name> == <name>NULL</name></expr>)</condition><then>
<goto>goto <name>Fail_it_item</name>;</goto></then></if>
}</block></then>
<else>else <block>{
<expr_stmt><expr><name>val</name> = <name>item</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></else></if>
<if>if <condition>(<expr><name>maxval</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>maxitem</name> = <name>item</name></expr>;</expr_stmt>
<expr_stmt><expr><name>maxval</name> = <name>val</name></expr>;</expr_stmt>
}</block></then>
<else>else <block>{
<decl_stmt><decl><type><name>int</name></type> <name>cmp</name> <init>= <expr><call><name>PyObject_RichCompareBool</name><argument_list>(<argument><expr><name>val</name></expr></argument>, <argument><expr><name>maxval</name></expr></argument>, <argument><expr><name>op</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>cmp</name> &lt; 0</expr>)</condition><then>
<goto>goto <name>Fail_it_item_and_val</name>;</goto></then>
<else>else <if>if <condition>(<expr><name>cmp</name> &gt; 0</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>maxval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>maxitem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>maxval</name> = <name>val</name></expr>;</expr_stmt>
<expr_stmt><expr><name>maxitem</name> = <name>item</name></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></else></if></else></if>
}</block></else></if>
}</block></while>
<if>if <condition>(<expr><call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then>
<goto>goto <name>Fail_it</name>;</goto></then></if>
<if>if <condition>(<expr><name>maxval</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>,
<argument><expr>"%s() arg is an empty sequence"</expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>maxitem</name> == <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>maxval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>it</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>keyfunc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>maxitem</name></expr>;</return>
<label><name>Fail_it_item_and_val</name>:</label>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<label><name>Fail_it_item</name>:</label>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<label><name>Fail_it</name>:</label>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>maxval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>maxitem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>it</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>keyfunc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>builtin_min</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>kwds</name></decl></param>)</parameter_list> <block>{
<return>return <expr><call><name>min_max</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>kwds</name></expr></argument>, <argument><expr><name>Py_LT</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>min_doc</name></expr></argument>,
<argument><expr>"min(iterable[, key=func]) -&gt; value\n\
min(a, b, c, ...[, key=func]) -&gt; value\n\
\n\
With a single iterable argument, return its smallest item.\n\
With two or more arguments, return the smallest argument."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>builtin_max</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>kwds</name></decl></param>)</parameter_list> <block>{
<return>return <expr><call><name>min_max</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>kwds</name></expr></argument>, <argument><expr><name>Py_GT</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>max_doc</name></expr></argument>,
<argument><expr>"max(iterable[, key=func]) -&gt; value\n\
max(a, b, c, ...[, key=func]) -&gt; value\n\
\n\
With a single iterable argument, return its largest item.\n\
With two or more arguments, return the largest argument."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>builtin_oct</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>v</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyNumberMethods</name> *</type><name>nb</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>res</name></decl>;</decl_stmt>
<if>if <condition>(<expr><name>v</name> == <name>NULL</name> || (<name>nb</name> = <name><name>v</name>-&gt;<name>ob_type</name>-&gt;<name>tp_as_number</name></name>) == <name>NULL</name> ||
<name><name>nb</name>-&gt;<name>nb_oct</name></name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
<argument><expr>"oct() argument can't be converted to oct"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>res</name> = <call>(*<name><name>nb</name>-&gt;<name>nb_oct</name></name>)<argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>res</name> &amp;&amp; !<call><name>PyString_Check</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
<argument><expr>"__oct__ returned non-string (type %.200s)"</expr></argument>,
<argument><expr><name><name>res</name>-&gt;<name>ob_type</name>-&gt;<name>tp_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<return>return <expr><name>res</name></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>oct_doc</name></expr></argument>,
<argument><expr>"oct(number) -&gt; string\n\
\n\
Return the octal representation of an integer or long integer."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>builtin_open</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>kwds</name></decl></param>)</parameter_list> <block>{
<return>return <expr><call><name>PyObject_Call</name><argument_list>(<argument><expr>(<name>PyObject</name>*)&amp;<name>PyFile_Type</name></expr></argument>, <argument><expr><name>args</name></expr></argument>, <argument><expr><name>kwds</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>open_doc</name></expr></argument>,
<argument><expr>"open(name[, mode[, buffering]]) -&gt; file object\n\
\n\
Open a file using the file() type, returns a file object. This is the\n\
preferred way to open a file."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>builtin_ord</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name>*</type> <name>obj</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>long</name></type> <name>ord</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>size</name></decl>;</decl_stmt>
<if>if <condition>(<expr><call><name>PyString_Check</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><name>size</name> = <call><name>PyString_GET_SIZE</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>size</name> == 1</expr>)</condition><then> <block>{
<expr_stmt><expr><name>ord</name> = <call>(<name>long</name>)<argument_list>(<argument><expr>(<name>unsigned</name> <name>char</name>)*<call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>PyInt_FromLong</name><argument_list>(<argument><expr><name>ord</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></then></if>
}</block></then> <else>else <if>if <condition>(<expr><call><name>PyByteArray_Check</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><name>size</name> = <call><name>PyByteArray_GET_SIZE</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>size</name> == 1</expr>)</condition><then> <block>{
<expr_stmt><expr><name>ord</name> = <call>(<name>long</name>)<argument_list>(<argument><expr>(<name>unsigned</name> <name>char</name>)*<call><name>PyByteArray_AS_STRING</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>PyInt_FromLong</name><argument_list>(<argument><expr><name>ord</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></then></if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>Py_USING_UNICODE</name></expr></argument>)</argument_list></call></expr></cpp:if>
}</block></then> <else>else <if>if <condition>(<expr><call><name>PyUnicode_Check</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><name>size</name> = <call><name>PyUnicode_GET_SIZE</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>size</name> == 1</expr>)</condition><then> <block>{
<expr_stmt><expr><name>ord</name> = (<name>long</name>)*<call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>PyInt_FromLong</name><argument_list>(<argument><expr><name>ord</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></then> <else>else <block>{
<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
<argument><expr>"ord() expected string of length 1, but " \
"%.200s found"</expr></argument>, <argument><expr><name><name>obj</name>-&gt;<name>ob_type</name>-&gt;<name>tp_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></else></if></else></if></else></if>
<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
<argument><expr>"ord() expected a character, "
"but string of length %zd found"</expr></argument>,
<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>ord_doc</name></expr></argument>,
<argument><expr>"ord(c) -&gt; integer\n\
\n\
Return the integer ordinal of a one-character string."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>builtin_pow</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>v</name></decl>, *<decl><type ref="prev"/><name>w</name></decl>, *<decl><type ref="prev"/><name>z</name> <init>= <expr><name>Py_None</name></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>PyArg_UnpackTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"pow"</expr></argument>, <argument><expr>2</expr></argument>, <argument><expr>3</expr></argument>, <argument><expr>&amp;<name>v</name></expr></argument>, <argument><expr>&amp;<name>w</name></expr></argument>, <argument><expr>&amp;<name>z</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<return>return <expr><call><name>PyNumber_Power</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>w</name></expr></argument>, <argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>pow_doc</name></expr></argument>,
<argument><expr>"pow(x, y[, z]) -&gt; number\n\
\n\
With two arguments, equivalent to x**y. With three arguments,\n\
equivalent to (x**y) % z, but may be more efficient (e.g. for longs)."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>builtin_print</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>kwds</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> *</type><name><name>kwlist</name><index>[]</index></name> <init>= <expr><block>{<expr>"sep"</expr>, <expr>"end"</expr>, <expr>"file"</expr>, <expr>0</expr>}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>PyObject</name> *</type><name>dummy_args</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>sep</name> <init>= <expr><name>NULL</name></expr></init>, *<name>end</name> <init>= <expr><name>NULL</name></expr></init>, *<name>file</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>err</name></decl>;</decl_stmt>
<if>if <condition>(<expr><name>dummy_args</name> == <name>NULL</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr>!(<name>dummy_args</name> = <call><name>PyTuple_New</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call>)</expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
}</block></then></if>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTupleAndKeywords</name><argument_list>(<argument><expr><name>dummy_args</name></expr></argument>, <argument><expr><name>kwds</name></expr></argument>, <argument><expr>"|OOO:print"</expr></argument>,
<argument><expr><name>kwlist</name></expr></argument>, <argument><expr>&amp;<name>sep</name></expr></argument>, <argument><expr>&amp;<name>end</name></expr></argument>, <argument><expr>&amp;<name>file</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<if>if <condition>(<expr><name>file</name> == <name>NULL</name> || <name>file</name> == <name>Py_None</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>file</name> = <call><name>PySys_GetObject</name><argument_list>(<argument><expr>"stdout"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>file</name> == <name>Py_None</name></expr>)</condition><then>
<expr_stmt><expr><name>Py_RETURN_NONE</name></expr>;</expr_stmt></then></if>
}</block></then></if>
<if>if <condition>(<expr><name>sep</name> &amp;&amp; <name>sep</name> != <name>Py_None</name> &amp;&amp; !<call><name>PyString_Check</name><argument_list>(<argument><expr><name>sep</name></expr></argument>)</argument_list></call> &amp;&amp;
!<call><name>PyUnicode_Check</name><argument_list>(<argument><expr><name>sep</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
<argument><expr>"sep must be None, str or unicode, not %.200s"</expr></argument>,
<argument><expr><name><name>sep</name>-&gt;<name>ob_type</name>-&gt;<name>tp_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<if>if <condition>(<expr><name>end</name> &amp;&amp; <name>end</name> != <name>Py_None</name> &amp;&amp; !<call><name>PyString_Check</name><argument_list>(<argument><expr><name>end</name></expr></argument>)</argument_list></call> &amp;&amp;
!<call><name>PyUnicode_Check</name><argument_list>(<argument><expr><name>end</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
<argument><expr>"end must be None, str or unicode, not %.200s"</expr></argument>,
<argument><expr><name><name>end</name>-&gt;<name>ob_type</name>-&gt;<name>tp_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <call><name>PyTuple_Size</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
<if>if <condition>(<expr><name>i</name> &gt; 0</expr>)</condition><then> <block>{
<if>if <condition>(<expr><name>sep</name> == <name>NULL</name> || <name>sep</name> == <name>Py_None</name></expr>)</condition><then>
<expr_stmt><expr><name>err</name> = <call><name>PyFile_WriteString</name><argument_list>(<argument><expr>" "</expr></argument>, <argument><expr><name>file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
<else>else
<expr_stmt><expr><name>err</name> = <call><name>PyFile_WriteObject</name><argument_list>(<argument><expr><name>sep</name></expr></argument>, <argument><expr><name>file</name></expr></argument>,
<argument><expr><name>Py_PRINT_RAW</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
<if>if <condition>(<expr><name>err</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
}</block></then></if>
<expr_stmt><expr><name>err</name> = <call><name>PyFile_WriteObject</name><argument_list>(<argument><expr><call><name>PyTuple_GetItem</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>file</name></expr></argument>,
<argument><expr><name>Py_PRINT_RAW</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>err</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
}</block></for>
<if>if <condition>(<expr><name>end</name> == <name>NULL</name> || <name>end</name> == <name>Py_None</name></expr>)</condition><then>
<expr_stmt><expr><name>err</name> = <call><name>PyFile_WriteString</name><argument_list>(<argument><expr>"\n"</expr></argument>, <argument><expr><name>file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
<else>else
<expr_stmt><expr><name>err</name> = <call><name>PyFile_WriteObject</name><argument_list>(<argument><expr><name>end</name></expr></argument>, <argument><expr><name>file</name></expr></argument>, <argument><expr><name>Py_PRINT_RAW</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
<if>if <condition>(<expr><name>err</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>Py_RETURN_NONE</name></expr>;</expr_stmt>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>print_doc</name></expr></argument>,
<argument><expr>"print(value, ..., sep=' ', end='\\n', file=sys.stdout)\n\
\n\
Prints the values to a stream, or to sys.stdout by default.\n\
Optional keyword arguments:\n\
file: a file-like object (stream); defaults to the current sys.stdout.\n\
sep: string inserted between values, default a space.\n\
end: string appended after the last value, default a newline."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>long</name></type>
<name>get_len_of_range_longs</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>lo</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>hi</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>step</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>long</name></type> <name>n</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>diff</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>one</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>tmp1</name> <init>= <expr><name>NULL</name></expr></init>, *<name>tmp2</name> <init>= <expr><name>NULL</name></expr></init>, *<name>tmp3</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><call><name>PyObject_Compare</name><argument_list>(<argument><expr><name>lo</name></expr></argument>, <argument><expr><name>hi</name></expr></argument>)</argument_list></call> &gt;= 0</expr>)</condition><then>
<return>return <expr>0</expr>;</return></then></if>
<if>if <condition>(<expr>(<name>one</name> = <call><name>PyLong_FromLong</name><argument_list>(<argument><expr>1L</expr></argument>)</argument_list></call>) == <name>NULL</name></expr>)</condition><then>
<goto>goto <name>Fail</name>;</goto></then></if>
<if>if <condition>(<expr>(<name>tmp1</name> = <call><name>PyNumber_Subtract</name><argument_list>(<argument><expr><name>hi</name></expr></argument>, <argument><expr><name>lo</name></expr></argument>)</argument_list></call>) == <name>NULL</name></expr>)</condition><then>
<goto>goto <name>Fail</name>;</goto></then></if>
<if>if <condition>(<expr>(<name>diff</name> = <call><name>PyNumber_Subtract</name><argument_list>(<argument><expr><name>tmp1</name></expr></argument>, <argument><expr><name>one</name></expr></argument>)</argument_list></call>) == <name>NULL</name></expr>)</condition><then>
<goto>goto <name>Fail</name>;</goto></then></if>
<if>if <condition>(<expr>(<name>tmp2</name> = <call><name>PyNumber_FloorDivide</name><argument_list>(<argument><expr><name>diff</name></expr></argument>, <argument><expr><name>step</name></expr></argument>)</argument_list></call>) == <name>NULL</name></expr>)</condition><then>
<goto>goto <name>Fail</name>;</goto></then></if>
<if>if <condition>(<expr>(<name>tmp3</name> = <call><name>PyNumber_Add</name><argument_list>(<argument><expr><name>tmp2</name></expr></argument>, <argument><expr><name>one</name></expr></argument>)</argument_list></call>) == <name>NULL</name></expr>)</condition><then>
<goto>goto <name>Fail</name>;</goto></then></if>
<expr_stmt><expr><name>n</name> = <call><name>PyLong_AsLong</name><argument_list>(<argument><expr><name>tmp3</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_Clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>Fail</name>;</goto>
}</block></then></if>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>tmp3</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>tmp2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>diff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>tmp1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>one</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>n</name></expr>;</return>
<label><name>Fail</name>:</label>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>tmp3</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>tmp2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>diff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>tmp1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>one</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>-1</expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>handle_range_longs</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>ilow</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>ihigh</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>istep</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>curnum</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>v</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>long</name></type> <name>bign</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>n</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>cmp_result</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>zero</name> <init>= <expr><call><name>PyLong_FromLong</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>zero</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<if>if <condition>(<expr>!<call><name>PyArg_UnpackTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"range"</expr></argument>, <argument><expr>1</expr></argument>, <argument><expr>3</expr></argument>, <argument><expr>&amp;<name>ilow</name></expr></argument>, <argument><expr>&amp;<name>ihigh</name></expr></argument>, <argument><expr>&amp;<name>istep</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>zero</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>ilow</name> != <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>ihigh</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>ihigh</name> = <name>ilow</name></expr>;</expr_stmt>
<expr_stmt><expr><name>ilow</name> = <name>NULL</name></expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>ihigh</name> != <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>ihigh</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>ilow</name> == <name>NULL</name></expr>)</condition><then>
<expr_stmt><expr><name>ilow</name> = <name>zero</name></expr>;</expr_stmt></then></if>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>ilow</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>istep</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>istep</name> = <call><name>PyLong_FromLong</name><argument_list>(<argument><expr>1L</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>istep</name> == <name>NULL</name></expr>)</condition><then>
<goto>goto <name>Fail</name>;</goto></then></if>
}</block></then> <else>else <block>{
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>istep</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></else></if>
<if>if <condition>(<expr>!<call><name>PyInt_Check</name><argument_list>(<argument><expr><name>ilow</name></expr></argument>)</argument_list></call> &amp;&amp; !<call><name>PyLong_Check</name><argument_list>(<argument><expr><name>ilow</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
<argument><expr>"range() integer start argument expected, got %s."</expr></argument>,
<argument><expr><name><name>ilow</name>-&gt;<name>ob_type</name>-&gt;<name>tp_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>Fail</name>;</goto>
}</block></then></if>
<if>if <condition>(<expr>!<call><name>PyInt_Check</name><argument_list>(<argument><expr><name>ihigh</name></expr></argument>)</argument_list></call> &amp;&amp; !<call><name>PyLong_Check</name><argument_list>(<argument><expr><name>ihigh</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
<argument><expr>"range() integer end argument expected, got %s."</expr></argument>,
<argument><expr><name><name>ihigh</name>-&gt;<name>ob_type</name>-&gt;<name>tp_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>Fail</name>;</goto>
}</block></then></if>
<if>if <condition>(<expr>!<call><name>PyInt_Check</name><argument_list>(<argument><expr><name>istep</name></expr></argument>)</argument_list></call> &amp;&amp; !<call><name>PyLong_Check</name><argument_list>(<argument><expr><name>istep</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
<argument><expr>"range() integer step argument expected, got %s."</expr></argument>,
<argument><expr><name><name>istep</name>-&gt;<name>ob_type</name>-&gt;<name>tp_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>Fail</name>;</goto>
}</block></then></if>
<if>if <condition>(<expr><call><name>PyObject_Cmp</name><argument_list>(<argument><expr><name>istep</name></expr></argument>, <argument><expr><name>zero</name></expr></argument>, <argument><expr>&amp;<name>cmp_result</name></expr></argument>)</argument_list></call> == -1</expr>)</condition><then>
<goto>goto <name>Fail</name>;</goto></then></if>
<if>if <condition>(<expr><name>cmp_result</name> == 0</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>,
<argument><expr>"range() step argument must not be zero"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>Fail</name>;</goto>
}</block></then></if>
<if>if <condition>(<expr><name>cmp_result</name> &gt; 0</expr>)</condition><then>
<expr_stmt><expr><name>bign</name> = <call><name>get_len_of_range_longs</name><argument_list>(<argument><expr><name>ilow</name></expr></argument>, <argument><expr><name>ihigh</name></expr></argument>, <argument><expr><name>istep</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
<else>else <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>neg_istep</name> <init>= <expr><call><name>PyNumber_Negative</name><argument_list>(<argument><expr><name>istep</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>neg_istep</name> == <name>NULL</name></expr>)</condition><then>
<goto>goto <name>Fail</name>;</goto></then></if>
<expr_stmt><expr><name>bign</name> = <call><name>get_len_of_range_longs</name><argument_list>(<argument><expr><name>ihigh</name></expr></argument>, <argument><expr><name>ilow</name></expr></argument>, <argument><expr><name>neg_istep</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>neg_istep</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></else></if>
<expr_stmt><expr><name>n</name> = (<name>int</name>)<name>bign</name></expr>;</expr_stmt>
<if>if <condition>(<expr><name>bign</name> &lt; 0 || (<name>long</name>)<name>n</name> != <name>bign</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_OverflowError</name></expr></argument>,
<argument><expr>"range() result has too many items"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>Fail</name>;</goto>
}</block></then></if>
<expr_stmt><expr><name>v</name> = <call><name>PyList_New</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>v</name> == <name>NULL</name></expr>)</condition><then>
<goto>goto <name>Fail</name>;</goto></then></if>
<expr_stmt><expr><name>curnum</name> = <name>ilow</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>curnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>n</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>w</name> <init>= <expr><call><name>PyNumber_Long</name><argument_list>(<argument><expr><name>curnum</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>tmp_num</name></decl>;</decl_stmt>
<if>if <condition>(<expr><name>w</name> == <name>NULL</name></expr>)</condition><then>
<goto>goto <name>Fail</name>;</goto></then></if>
<expr_stmt><expr><call><name>PyList_SET_ITEM</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>tmp_num</name> = <call><name>PyNumber_Add</name><argument_list>(<argument><expr><name>curnum</name></expr></argument>, <argument><expr><name>istep</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>tmp_num</name> == <name>NULL</name></expr>)</condition><then>
<goto>goto <name>Fail</name>;</goto></then></if>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>curnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>curnum</name> = <name>tmp_num</name></expr>;</expr_stmt>
}</block></for>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>ilow</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>ihigh</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>istep</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>zero</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>curnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>v</name></expr>;</return>
<label><name>Fail</name>:</label>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>ilow</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>ihigh</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>istep</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>zero</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>curnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>long</name></type>
<name>get_len_of_range</name><parameter_list>(<param><decl><type><name>long</name></type> <name>lo</name></decl></param>, <param><decl><type><name>long</name></type> <name>hi</name></decl></param>, <param><decl><type><name>long</name></type> <name>step</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>long</name></type> <name>n</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>lo</name> &lt; <name>hi</name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>uhi</name> <init>= <expr>(<name>unsigned</name> <name>long</name>)<name>hi</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>ulo</name> <init>= <expr>(<name>unsigned</name> <name>long</name>)<name>lo</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>diff</name> <init>= <expr><name>uhi</name> - <name>ulo</name> - 1</expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>n</name> = <call>(<name>long</name>)<argument_list>(<argument><expr><name>diff</name> / (<name>unsigned</name> <name>long</name>)<name>step</name> + 1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<return>return <expr><name>n</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>builtin_range</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>long</name></type> <name>ilow</name> <init>= <expr>0</expr></init>, <name>ihigh</name> <init>= <expr>0</expr></init>, <name>istep</name> <init>= <expr>1</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>long</name></type> <name>bign</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>n</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>v</name></decl>;</decl_stmt>
<if>if <condition>(<expr><call><name>PyTuple_Size</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call> &lt;= 1</expr>)</condition><then> <block>{
<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>,
<argument><expr>"l;range() requires 1-3 int arguments"</expr></argument>,
<argument><expr>&amp;<name>ihigh</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_Clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>handle_range_longs</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></then></if>
}</block></then> <else>else <block>{
<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>,
<argument><expr>"ll|l;range() requires 1-3 int arguments"</expr></argument>,
<argument><expr>&amp;<name>ilow</name></expr></argument>, <argument><expr>&amp;<name>ihigh</name></expr></argument>, <argument><expr>&amp;<name>istep</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_Clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>handle_range_longs</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></then></if>
}</block></else></if>
<if>if <condition>(<expr><name>istep</name> == 0</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>,
<argument><expr>"range() step argument must not be zero"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<if>if <condition>(<expr><name>istep</name> &gt; 0</expr>)</condition><then>
<expr_stmt><expr><name>bign</name> = <call><name>get_len_of_range</name><argument_list>(<argument><expr><name>ilow</name></expr></argument>, <argument><expr><name>ihigh</name></expr></argument>, <argument><expr><name>istep</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
<else>else
<expr_stmt><expr><name>bign</name> = <call><name>get_len_of_range</name><argument_list>(<argument><expr><name>ihigh</name></expr></argument>, <argument><expr><name>ilow</name></expr></argument>, <argument><expr>-<name>istep</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
<expr_stmt><expr><name>n</name> = (<name>int</name>)<name>bign</name></expr>;</expr_stmt>
<if>if <condition>(<expr><name>bign</name> &lt; 0 || (<name>long</name>)<name>n</name> != <name>bign</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_OverflowError</name></expr></argument>,
<argument><expr>"range() result has too many items"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>v</name> = <call><name>PyList_New</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>v</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>n</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>w</name> <init>= <expr><call><name>PyInt_FromLong</name><argument_list>(<argument><expr><name>ilow</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>w</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><call><name>PyList_SET_ITEM</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ilow</name> += <name>istep</name></expr>;</expr_stmt>
}</block></for>
<return>return <expr><name>v</name></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>range_doc</name></expr></argument>,
<argument><expr>"range([start,] stop[, step]) -&gt; list of integers\n\
\n\
Return a list containing an arithmetic progression of integers.\n\
range(i, j) returns [i, i+1, i+2, ..., j-1]; start (!) defaults to 0.\n\
When step is given, it specifies the increment (or decrement).\n\
For example, range(4) returns [0, 1, 2, 3]. The end point is omitted!\n\
These are exactly the valid indices for a list of 4 elements."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>builtin_raw_input</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>v</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>fin</name> <init>= <expr><call><name>PySys_GetObject</name><argument_list>(<argument><expr>"stdin"</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>fout</name> <init>= <expr><call><name>PySys_GetObject</name><argument_list>(<argument><expr>"stdout"</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>PyArg_UnpackTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"[raw_]input"</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>1</expr></argument>, <argument><expr>&amp;<name>v</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<if>if <condition>(<expr><name>fin</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_RuntimeError</name></expr></argument>, <argument><expr>"[raw_]input: lost sys.stdin"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<if>if <condition>(<expr><name>fout</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_RuntimeError</name></expr></argument>, <argument><expr>"[raw_]input: lost sys.stdout"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<if>if <condition>(<expr><call><name>PyFile_SoftSpace</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<if>if <condition>(<expr><call><name>PyFile_WriteString</name><argument_list>(<argument><expr>" "</expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call> != 0</expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
}</block></then></if>
<if>if <condition>(<expr><call><name>PyFile_AsFile</name><argument_list>(<argument><expr><name>fin</name></expr></argument>)</argument_list></call> &amp;&amp; <call><name>PyFile_AsFile</name><argument_list>(<argument><expr><name>fout</name></expr></argument>)</argument_list></call>
&amp;&amp; <call><name>isatty</name><argument_list>(<argument><expr><call><name>fileno</name><argument_list>(<argument><expr><call><name>PyFile_AsFile</name><argument_list>(<argument><expr><name>fin</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>
&amp;&amp; <call><name>isatty</name><argument_list>(<argument><expr><call><name>fileno</name><argument_list>(<argument><expr><call><name>PyFile_AsFile</name><argument_list>(<argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>po</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>prompt</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>s</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>result</name></decl>;</decl_stmt>
<if>if <condition>(<expr><name>v</name> != <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>po</name> = <call><name>PyObject_Str</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>po</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>prompt</name> = <call><name>PyString_AsString</name><argument_list>(<argument><expr><name>po</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>prompt</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
}</block></then> <else>else <block>{
<expr_stmt><expr><name>po</name> = <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name>prompt</name> = ""</expr>;</expr_stmt>
}</block></else></if>
<expr_stmt><expr><name>s</name> = <call><name>PyOS_Readline</name><argument_list>(<argument><expr><call><name>PyFile_AsFile</name><argument_list>(<argument><expr><name>fin</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>PyFile_AsFile</name><argument_list>(<argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>prompt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>po</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>s</name> == <name>NULL</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr>!<call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then>
<expr_stmt><expr><call><name>PyErr_SetNone</name><argument_list>(<argument><expr><name>PyExc_KeyboardInterrupt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<if>if <condition>(<expr>*<name>s</name> == '\0'</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetNone</name><argument_list>(<argument><expr><name>PyExc_EOFError</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>result</name> = <name>NULL</name></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<decl_stmt><decl><type><name>size_t</name></type> <name>len</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>len</name> &gt; <name>PY_SSIZE_T_MAX</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_OverflowError</name></expr></argument>,
<argument><expr>"[raw_]input: input too long"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>result</name> = <name>NULL</name></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr><name>result</name> = <call><name>PyString_FromStringAndSize</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>len</name>-1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></else></if>
}</block></else></if>
<expr_stmt><expr><call><name>PyMem_FREE</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>result</name></expr>;</return>
}</block></then></if>
<if>if <condition>(<expr><name>v</name> != <name>NULL</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr><call><name>PyFile_WriteObject</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>fout</name></expr></argument>, <argument><expr><name>Py_PRINT_RAW</name></expr></argument>)</argument_list></call> != 0</expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
}</block></then></if>
<return>return <expr><call><name>PyFile_GetLine</name><argument_list>(<argument><expr><name>fin</name></expr></argument>, <argument><expr>-1</expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>raw_input_doc</name></expr></argument>,
<argument><expr>"raw_input([prompt]) -&gt; string\n\
\n\
Read a string from standard input. The trailing newline is stripped.\n\
If the user hits EOF (Unix: Ctl-D, Windows: Ctl-Z+Return), raise EOFError.\n\
On Unix, GNU readline is used if enabled. The prompt string, if given,\n\
is printed without a trailing newline before reading."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>builtin_reduce</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><specifier>static</specifier> <name>PyObject</name> *</type><name>functools_reduce</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><call><name>PyErr_WarnPy3k</name><argument_list>(<argument><expr>"reduce() not supported in 3.x; "
"use functools.reduce()"</expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<if>if <condition>(<expr><name>functools_reduce</name> == <name>NULL</name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>functools</name> <init>= <expr><call><name>PyImport_ImportModule</name><argument_list>(<argument><expr>"functools"</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>functools</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>functools_reduce</name> = <call><name>PyObject_GetAttrString</name><argument_list>(<argument><expr><name>functools</name></expr></argument>, <argument><expr>"reduce"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>functools</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>functools_reduce</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
}</block></then></if>
<return>return <expr><call><name>PyObject_Call</name><argument_list>(<argument><expr><name>functools_reduce</name></expr></argument>, <argument><expr><name>args</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>reduce_doc</name></expr></argument>,
<argument><expr>"reduce(function, sequence[, initial]) -&gt; value\n\
\n\
Apply a function of two arguments cumulatively to the items of a sequence,\n\
from left to right, so as to reduce the sequence to a single value.\n\
For example, reduce(lambda x, y: x+y, [1, 2, 3, 4, 5]) calculates\n\
((((1+2)+3)+4)+5). If initial is present, it is placed before the items\n\
of the sequence in the calculation, and serves as a default when the\n\
sequence is empty."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>builtin_reload</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>v</name></decl></param>)</parameter_list> <block>{
<if>if <condition>(<expr><call><name>PyErr_WarnPy3k</name><argument_list>(<argument><expr>"In 3.x, reload() is renamed to imp.reload()"</expr></argument>,
<argument><expr>1</expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<return>return <expr><call><name>PyImport_ReloadModule</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>reload_doc</name></expr></argument>,
<argument><expr>"reload(module) -&gt; module\n\
\n\
Reload the module. The module must have been successfully imported before."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>builtin_repr</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>v</name></decl></param>)</parameter_list> <block>{
<return>return <expr><call><name>PyObject_Repr</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>repr_doc</name></expr></argument>,
<argument><expr>"repr(object) -&gt; string\n\
\n\
Return the canonical string representation of the object.\n\
For most object types, eval(repr(object)) == object."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>builtin_round</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>kwds</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>double</name></type> <name>number</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>double</name></type> <name>f</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>ndigits</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> *</type><name><name>kwlist</name><index>[]</index></name> <init>= <expr><block>{<expr>"number"</expr>, <expr>"ndigits"</expr>, <expr>0</expr>}</block></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTupleAndKeywords</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>kwds</name></expr></argument>, <argument><expr>"d|i:round"</expr></argument>,
<argument><expr><name>kwlist</name></expr></argument>, <argument><expr>&amp;<name>number</name></expr></argument>, <argument><expr>&amp;<name>ndigits</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>f</name> = 1.0</expr>;</expr_stmt>
<expr_stmt><expr><name>i</name> = <call><name>abs</name><argument_list>(<argument><expr><name>ndigits</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<while>while <condition>(<expr>--<name>i</name> &gt;= 0</expr>)</condition>
<expr_stmt><expr><name>f</name> = <name>f</name>*10.0</expr>;</expr_stmt></while>
<if>if <condition>(<expr><name>ndigits</name> &lt; 0</expr>)</condition><then>
<expr_stmt><expr><name>number</name> /= <name>f</name></expr>;</expr_stmt></then>
<else>else
<expr_stmt><expr><name>number</name> *= <name>f</name></expr>;</expr_stmt></else></if>
<if>if <condition>(<expr><name>number</name> &gt;= 0.0</expr>)</condition><then>
<expr_stmt><expr><name>number</name> = <call><name>floor</name><argument_list>(<argument><expr><name>number</name> + 0.5</expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
<else>else
<expr_stmt><expr><name>number</name> = <call><name>ceil</name><argument_list>(<argument><expr><name>number</name> - 0.5</expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
<if>if <condition>(<expr><name>ndigits</name> &lt; 0</expr>)</condition><then>
<expr_stmt><expr><name>number</name> *= <name>f</name></expr>;</expr_stmt></then>
<else>else
<expr_stmt><expr><name>number</name> /= <name>f</name></expr>;</expr_stmt></else></if>
<return>return <expr><call><name>PyFloat_FromDouble</name><argument_list>(<argument><expr><name>number</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>round_doc</name></expr></argument>,
<argument><expr>"round(number[, ndigits]) -&gt; floating point number\n\
\n\
Round a number to a given precision in decimal digits (default 0 digits).\n\
This always returns a floating point number. Precision may be negative."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>builtin_sorted</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>kwds</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>newlist</name></decl>, *<decl><type ref="prev"/><name>v</name></decl>, *<decl><type ref="prev"/><name>seq</name></decl>, *<decl><type ref="prev"/><name>compare</name><init>=<expr><name>NULL</name></expr></init>, *<name>keyfunc</name><init>=<expr><name>NULL</name></expr></init>, *<name>newargs</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>callable</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> *</type><name><name>kwlist</name><index>[]</index></name> <init>= <expr><block>{<expr>"iterable"</expr>, <expr>"cmp"</expr>, <expr>"key"</expr>, <expr>"reverse"</expr>, <expr>0</expr>}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>reverse</name></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTupleAndKeywords</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>kwds</name></expr></argument>, <argument><expr>"O|OOi:sorted"</expr></argument>,
<argument><expr><name>kwlist</name></expr></argument>, <argument><expr>&amp;<name>seq</name></expr></argument>, <argument><expr>&amp;<name>compare</name></expr></argument>, <argument><expr>&amp;<name>keyfunc</name></expr></argument>, <argument><expr>&amp;<name>reverse</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>newlist</name> = <call><name>PySequence_List</name><argument_list>(<argument><expr><name>seq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>newlist</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>callable</name> = <call><name>PyObject_GetAttrString</name><argument_list>(<argument><expr><name>newlist</name></expr></argument>, <argument><expr>"sort"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>callable</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>newlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>newargs</name> = <call><name>PyTuple_GetSlice</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>1</expr></argument>, <argument><expr>4</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>newargs</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>newlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>callable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>v</name> = <call><name>PyObject_Call</name><argument_list>(<argument><expr><name>callable</name></expr></argument>, <argument><expr><name>newargs</name></expr></argument>, <argument><expr><name>kwds</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>newargs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>callable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>v</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>newlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>newlist</name></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>sorted_doc</name></expr></argument>,
<argument><expr>"sorted(iterable, cmp=None, key=None, reverse=False) --&gt; new sorted list"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>builtin_vars</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>v</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>d</name></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>PyArg_UnpackTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"vars"</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>1</expr></argument>, <argument><expr>&amp;<name>v</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<if>if <condition>(<expr><name>v</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>d</name> = <call><name>PyEval_GetLocals</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>d</name> == <name>NULL</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr>!<call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then>
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_SystemError</name></expr></argument>,
<argument><expr>"vars(): no locals!?"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
}</block></then> <else>else
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
}</block></then> <else>else <block>{
<expr_stmt><expr><name>d</name> = <call><name>PyObject_GetAttrString</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr>"__dict__"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>d</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
<argument><expr>"vars() argument must have __dict__ attribute"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
}</block></else></if>
<return>return <expr><name>d</name></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>vars_doc</name></expr></argument>,
<argument><expr>"vars([object]) -&gt; dictionary\n\
\n\
Without arguments, equivalent to locals().\n\
With an argument, equivalent to object.__dict__."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name>*</type>
<name>builtin_sum</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>seq</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>result</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>temp</name></decl>, *<decl><type ref="prev"/><name>item</name></decl>, *<decl><type ref="prev"/><name>iter</name></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>PyArg_UnpackTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"sum"</expr></argument>, <argument><expr>1</expr></argument>, <argument><expr>2</expr></argument>, <argument><expr>&amp;<name>seq</name></expr></argument>, <argument><expr>&amp;<name>result</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>iter</name> = <call><name>PyObject_GetIter</name><argument_list>(<argument><expr><name>seq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>iter</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<if>if <condition>(<expr><name>result</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>result</name> = <call><name>PyInt_FromLong</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>result</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>iter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
}</block></then> <else>else <block>{
<if>if <condition>(<expr><call><name>PyObject_TypeCheck</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr>&amp;<name>PyBaseString_Type</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
<argument><expr>"sum() can't sum strings [use ''.join(seq) instead]"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>iter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></else></if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>SLOW_SUM</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if>if <condition>(<expr><call><name>PyInt_CheckExact</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>long</name></type> <name>i_result</name> <init>= <expr><call><name>PyInt_AS_LONG</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>result</name> = <name>NULL</name></expr>;</expr_stmt>
<while>while<condition>(<expr><name>result</name> == <name>NULL</name></expr>)</condition> <block>{
<expr_stmt><expr><name>item</name> = <call><name>PyIter_Next</name><argument_list>(<argument><expr><name>iter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>item</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>iter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<return>return <expr><call><name>PyInt_FromLong</name><argument_list>(<argument><expr><name>i_result</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></then></if>
<if>if <condition>(<expr><call><name>PyInt_CheckExact</name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>long</name></type> <name>b</name> <init>= <expr><call><name>PyInt_AS_LONG</name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>long</name></type> <name>x</name> <init>= <expr><name>i_result</name> + <name>b</name></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr>(<name>x</name>^<name>i_result</name>) &gt;= 0 || (<name>x</name>^<name>b</name>) &gt;= 0</expr>)</condition><then> <block>{
<expr_stmt><expr><name>i_result</name> = <name>x</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<continue>continue;</continue>
}</block></then></if>
}</block></then></if>
<expr_stmt><expr><name>result</name> = <call><name>PyInt_FromLong</name><argument_list>(<argument><expr><name>i_result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>temp</name> = <call><name>PyNumber_Add</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>result</name> = <name>temp</name></expr>;</expr_stmt>
<if>if <condition>(<expr><name>result</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>iter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
}</block></while>
}</block></then></if>
<if>if <condition>(<expr><call><name>PyFloat_CheckExact</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>double</name></type> <name>f_result</name> <init>= <expr><call><name>PyFloat_AS_DOUBLE</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>result</name> = <name>NULL</name></expr>;</expr_stmt>
<while>while<condition>(<expr><name>result</name> == <name>NULL</name></expr>)</condition> <block>{
<expr_stmt><expr><name>item</name> = <call><name>PyIter_Next</name><argument_list>(<argument><expr><name>iter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>item</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>iter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<return>return <expr><call><name>PyFloat_FromDouble</name><argument_list>(<argument><expr><name>f_result</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></then></if>
<if>if <condition>(<expr><call><name>PyFloat_CheckExact</name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<macro><name>PyFPE_START_PROTECT</name><argument_list>(<argument>"add"</argument>, <argument>Py_DECREF(item); Py_DECREF(iter); return 0</argument>)</argument_list></macro>
<expr_stmt><expr><name>f_result</name> += <call><name>PyFloat_AS_DOUBLE</name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<macro><name>PyFPE_END_PROTECT</name><argument_list>(<argument>f_result</argument>)</argument_list></macro>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<continue>continue;</continue>
}</block></then></if>
<if>if <condition>(<expr><call><name>PyInt_CheckExact</name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<macro><name>PyFPE_START_PROTECT</name><argument_list>(<argument>"add"</argument>, <argument>Py_DECREF(item); Py_DECREF(iter); return 0</argument>)</argument_list></macro>
<expr_stmt><expr><name>f_result</name> += (<name>double</name>)<call><name>PyInt_AS_LONG</name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<macro><name>PyFPE_END_PROTECT</name><argument_list>(<argument>f_result</argument>)</argument_list></macro>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<continue>continue;</continue>
}</block></then></if>
<expr_stmt><expr><name>result</name> = <call><name>PyFloat_FromDouble</name><argument_list>(<argument><expr><name>f_result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>temp</name> = <call><name>PyNumber_Add</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>result</name> = <name>temp</name></expr>;</expr_stmt>
<if>if <condition>(<expr><name>result</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>iter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
}</block></while>
}</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<for>for(<init>;</init><condition>;</condition><incr/>) <block>{
<expr_stmt><expr><name>item</name> = <call><name>PyIter_Next</name><argument_list>(<argument><expr><name>iter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>item</name> == <name>NULL</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr><call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>result</name> = <name>NULL</name></expr>;</expr_stmt>
}</block></then></if>
<break>break;</break>
}</block></then></if>
<expr_stmt><expr><name>temp</name> = <call><name>PyNumber_Add</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>result</name> = <name>temp</name></expr>;</expr_stmt>
<if>if <condition>(<expr><name>result</name> == <name>NULL</name></expr>)</condition><then>
<break>break;</break></then></if>
}</block></for>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>iter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>result</name></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>sum_doc</name></expr></argument>,
<argument><expr>"sum(sequence[, start]) -&gt; value\n\
\n\
Returns the sum of a sequence of numbers (NOT strings) plus the value\n\
of parameter 'start' (which defaults to 0). When the sequence is\n\
empty, returns start."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>builtin_isinstance</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>inst</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>cls</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>retval</name></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>PyArg_UnpackTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"isinstance"</expr></argument>, <argument><expr>2</expr></argument>, <argument><expr>2</expr></argument>, <argument><expr>&amp;<name>inst</name></expr></argument>, <argument><expr>&amp;<name>cls</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>retval</name> = <call><name>PyObject_IsInstance</name><argument_list>(<argument><expr><name>inst</name></expr></argument>, <argument><expr><name>cls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>retval</name> &lt; 0</expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<return>return <expr><call><name>PyBool_FromLong</name><argument_list>(<argument><expr><name>retval</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>isinstance_doc</name></expr></argument>,
<argument><expr>"isinstance(object, class-or-type-or-tuple) -&gt; bool\n\
\n\
Return whether an object is an instance of a class or of a subclass thereof.\n\
With a type as second argument, return whether that is the object's type.\n\
The form using a tuple, isinstance(x, (A, B, ...)), is a shortcut for\n\
isinstance(x, A) or isinstance(x, B) or ... (etc.)."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>builtin_issubclass</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>derived</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>cls</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>retval</name></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>PyArg_UnpackTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"issubclass"</expr></argument>, <argument><expr>2</expr></argument>, <argument><expr>2</expr></argument>, <argument><expr>&amp;<name>derived</name></expr></argument>, <argument><expr>&amp;<name>cls</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>retval</name> = <call><name>PyObject_IsSubclass</name><argument_list>(<argument><expr><name>derived</name></expr></argument>, <argument><expr><name>cls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>retval</name> &lt; 0</expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<return>return <expr><call><name>PyBool_FromLong</name><argument_list>(<argument><expr><name>retval</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>issubclass_doc</name></expr></argument>,
<argument><expr>"issubclass(C, B) -&gt; bool\n\
\n\
Return whether class C is a subclass (i.e., a derived class) of class B.\n\
When using a tuple as the second argument issubclass(X, (A, B, ...)),\n\
is a shortcut for issubclass(X, A) or issubclass(X, B) or ... (etc.)."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name>*</type>
<name>builtin_zip</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>ret</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>Py_ssize_t</name></type> <name>itemsize</name> <init>= <expr><call><name>PySequence_Length</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>itlist</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>len</name></decl>;</decl_stmt>
<if>if <condition>(<expr><name>itemsize</name> == 0</expr>)</condition><then>
<return>return <expr><call><name>PyList_New</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</return></then></if>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>PyTuple_Check</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>len</name> = -1</expr>;</expr_stmt>
<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>itemsize</name></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>) <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>item</name> <init>= <expr><call><name>PyTuple_GET_ITEM</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>thislen</name> <init>= <expr><call><name>_PyObject_LengthHint</name><argument_list>(<argument><expr><name>item</name></expr></argument>, <argument><expr>-1</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>thislen</name> &lt; 0</expr>)</condition><then> <block>{
<expr_stmt><expr><name>len</name> = -1</expr>;</expr_stmt>
<break>break;</break>
}</block></then> <else>else <if>if <condition>(<expr><name>len</name> &lt; 0 || <name>thislen</name> &lt; <name>len</name></expr>)</condition><then>
<expr_stmt><expr><name>len</name> = <name>thislen</name></expr>;</expr_stmt></then></if></else></if>
}</block></for>
<if>if <condition>(<expr><name>len</name> &lt; 0</expr>)</condition><then>
<expr_stmt><expr><name>len</name> = 10</expr>;</expr_stmt></then></if>
<if>if <condition>(<expr>(<name>ret</name> = <call><name>PyList_New</name><argument_list>(<argument><expr><name>len</name></expr></argument>)</argument_list></call>) == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>itlist</name> = <call><name>PyTuple_New</name><argument_list>(<argument><expr><name>itemsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>itlist</name> == <name>NULL</name></expr>)</condition><then>
<goto>goto <name>Fail_ret</name>;</goto></then></if>
<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>itemsize</name></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>) <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>item</name> <init>= <expr><call><name>PyTuple_GET_ITEM</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>it</name> <init>= <expr><call><name>PyObject_GetIter</name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>it</name> == <name>NULL</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr><call><name>PyErr_ExceptionMatches</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
<argument><expr>"zip argument #%zd must support iteration"</expr></argument>,
<argument><expr><name>i</name>+1</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<goto>goto <name>Fail_ret_itlist</name>;</goto>
}</block></then></if>
<expr_stmt><expr><call><name>PyTuple_SET_ITEM</name><argument_list>(<argument><expr><name>itlist</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>it</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></for>
<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition>;</condition> <incr><expr>++<name>i</name></expr></incr>) <block>{
<decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>next</name> <init>= <expr><call><name>PyTuple_New</name><argument_list>(<argument><expr><name>itemsize</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr>!<name>next</name></expr>)</condition><then>
<goto>goto <name>Fail_ret_itlist</name>;</goto></then></if>
<for>for (<init><expr><name>j</name> = 0</expr>;</init> <condition><expr><name>j</name> &lt; <name>itemsize</name></expr>;</condition> <incr><expr><name>j</name>++</expr></incr>) <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>it</name> <init>= <expr><call><name>PyTuple_GET_ITEM</name><argument_list>(<argument><expr><name>itlist</name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>item</name> <init>= <expr><call><name>PyIter_Next</name><argument_list>(<argument><expr><name>it</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr>!<name>item</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr><call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>ret</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ret</name> = <name>NULL</name></expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>next</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>itlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>Done</name>;</goto>
}</block></then></if>
<expr_stmt><expr><call><name>PyTuple_SET_ITEM</name><argument_list>(<argument><expr><name>next</name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></for>
<if>if <condition>(<expr><name>i</name> &lt; <name>len</name></expr>)</condition><then>
<expr_stmt><expr><call><name>PyList_SET_ITEM</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>next</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
<else>else <block>{
<decl_stmt><decl><type><name>int</name></type> <name>status</name> <init>= <expr><call><name>PyList_Append</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>next</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>next</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr>++<name>len</name></expr>;</expr_stmt>
<if>if <condition>(<expr><name>status</name> &lt; 0</expr>)</condition><then>
<goto>goto <name>Fail_ret_itlist</name>;</goto></then></if>
}</block></else></if>
}</block></for>
<label><name>Done</name>:</label>
<if>if <condition>(<expr><name>ret</name> != <name>NULL</name> &amp;&amp; <name>i</name> &lt; <name>len</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr><call><name>PyList_SetSlice</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
}</block></then></if>
<return>return <expr><name>ret</name></expr>;</return>
<label><name>Fail_ret_itlist</name>:</label>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>itlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<label><name>Fail_ret</name>:</label>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>ret</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>zip_doc</name></expr></argument>,
<argument><expr>"zip(seq1 [, seq2 [...]]) -&gt; [(seq1[0], seq2[0] ...), (...)]\n\
\n\
Return a list of tuples, where each tuple contains the i-th element\n\
from each of the argument sequences. The returned list is truncated\n\
in length to the length of the shortest argument sequence."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>PyMethodDef</name></type> <name><name>builtin_methods</name><index>[]</index></name> <init>= <expr><block>{
<expr><block>{<expr>"__import__"</expr>, <expr>(<name>PyCFunction</name>)<name>builtin___import__</name></expr>, <expr><name>METH_VARARGS</name> | <name>METH_KEYWORDS</name></expr>, <expr><name>import_doc</name></expr>}</block></expr>,
<expr><block>{<expr>"abs"</expr>, <expr><name>builtin_abs</name></expr>, <expr><name>METH_O</name></expr>, <expr><name>abs_doc</name></expr>}</block></expr>,
<expr><block>{<expr>"all"</expr>, <expr><name>builtin_all</name></expr>, <expr><name>METH_O</name></expr>, <expr><name>all_doc</name></expr>}</block></expr>,
<expr><block>{<expr>"any"</expr>, <expr><name>builtin_any</name></expr>, <expr><name>METH_O</name></expr>, <expr><name>any_doc</name></expr>}</block></expr>,
<expr><block>{<expr>"apply"</expr>, <expr><name>builtin_apply</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>apply_doc</name></expr>}</block></expr>,
<expr><block>{<expr>"bin"</expr>, <expr><name>builtin_bin</name></expr>, <expr><name>METH_O</name></expr>, <expr><name>bin_doc</name></expr>}</block></expr>,
<expr><block>{<expr>"callable"</expr>, <expr><name>builtin_callable</name></expr>, <expr><name>METH_O</name></expr>, <expr><name>callable_doc</name></expr>}</block></expr>,
<expr><block>{<expr>"chr"</expr>, <expr><name>builtin_chr</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>chr_doc</name></expr>}</block></expr>,
<expr><block>{<expr>"cmp"</expr>, <expr><name>builtin_cmp</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>cmp_doc</name></expr>}</block></expr>,
<expr><block>{<expr>"coerce"</expr>, <expr><name>builtin_coerce</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>coerce_doc</name></expr>}</block></expr>,
<expr><block>{<expr>"compile"</expr>, <expr>(<name>PyCFunction</name>)<name>builtin_compile</name></expr>, <expr><name>METH_VARARGS</name> | <name>METH_KEYWORDS</name></expr>, <expr><name>compile_doc</name></expr>}</block></expr>,
<expr><block>{<expr>"delattr"</expr>, <expr><name>builtin_delattr</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>delattr_doc</name></expr>}</block></expr>,
<expr><block>{<expr>"dir"</expr>, <expr><name>builtin_dir</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>dir_doc</name></expr>}</block></expr>,
<expr><block>{<expr>"divmod"</expr>, <expr><name>builtin_divmod</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>divmod_doc</name></expr>}</block></expr>,
<expr><block>{<expr>"eval"</expr>, <expr><name>builtin_eval</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>eval_doc</name></expr>}</block></expr>,
<expr><block>{<expr>"execfile"</expr>, <expr><name>builtin_execfile</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>execfile_doc</name></expr>}</block></expr>,
<expr><block>{<expr>"filter"</expr>, <expr><name>builtin_filter</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>filter_doc</name></expr>}</block></expr>,
<expr><block>{<expr>"format"</expr>, <expr><name>builtin_format</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>format_doc</name></expr>}</block></expr>,
<expr><block>{<expr>"getattr"</expr>, <expr><name>builtin_getattr</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>getattr_doc</name></expr>}</block></expr>,
<expr><block>{<expr>"globals"</expr>, <expr>(<name>PyCFunction</name>)<name>builtin_globals</name></expr>, <expr><name>METH_NOARGS</name></expr>, <expr><name>globals_doc</name></expr>}</block></expr>,
<expr><block>{<expr>"hasattr"</expr>, <expr><name>builtin_hasattr</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>hasattr_doc</name></expr>}</block></expr>,
<expr><block>{<expr>"hash"</expr>, <expr><name>builtin_hash</name></expr>, <expr><name>METH_O</name></expr>, <expr><name>hash_doc</name></expr>}</block></expr>,
<expr><block>{<expr>"hex"</expr>, <expr><name>builtin_hex</name></expr>, <expr><name>METH_O</name></expr>, <expr><name>hex_doc</name></expr>}</block></expr>,
<expr><block>{<expr>"id"</expr>, <expr><name>builtin_id</name></expr>, <expr><name>METH_O</name></expr>, <expr><name>id_doc</name></expr>}</block></expr>,
<expr><block>{<expr>"input"</expr>, <expr><name>builtin_input</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>input_doc</name></expr>}</block></expr>,
<expr><block>{<expr>"intern"</expr>, <expr><name>builtin_intern</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>intern_doc</name></expr>}</block></expr>,
<expr><block>{<expr>"isinstance"</expr>, <expr><name>builtin_isinstance</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>isinstance_doc</name></expr>}</block></expr>,
<expr><block>{<expr>"issubclass"</expr>, <expr><name>builtin_issubclass</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>issubclass_doc</name></expr>}</block></expr>,
<expr><block>{<expr>"iter"</expr>, <expr><name>builtin_iter</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>iter_doc</name></expr>}</block></expr>,
<expr><block>{<expr>"len"</expr>, <expr><name>builtin_len</name></expr>, <expr><name>METH_O</name></expr>, <expr><name>len_doc</name></expr>}</block></expr>,
<expr><block>{<expr>"locals"</expr>, <expr>(<name>PyCFunction</name>)<name>builtin_locals</name></expr>, <expr><name>METH_NOARGS</name></expr>, <expr><name>locals_doc</name></expr>}</block></expr>,
<expr><block>{<expr>"map"</expr>, <expr><name>builtin_map</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>map_doc</name></expr>}</block></expr>,
<expr><block>{<expr>"max"</expr>, <expr>(<name>PyCFunction</name>)<name>builtin_max</name></expr>, <expr><name>METH_VARARGS</name> | <name>METH_KEYWORDS</name></expr>, <expr><name>max_doc</name></expr>}</block></expr>,
<expr><block>{<expr>"min"</expr>, <expr>(<name>PyCFunction</name>)<name>builtin_min</name></expr>, <expr><name>METH_VARARGS</name> | <name>METH_KEYWORDS</name></expr>, <expr><name>min_doc</name></expr>}</block></expr>,
<expr><block>{<expr>"next"</expr>, <expr><name>builtin_next</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>next_doc</name></expr>}</block></expr>,
<expr><block>{<expr>"oct"</expr>, <expr><name>builtin_oct</name></expr>, <expr><name>METH_O</name></expr>, <expr><name>oct_doc</name></expr>}</block></expr>,
<expr><block>{<expr>"open"</expr>, <expr>(<name>PyCFunction</name>)<name>builtin_open</name></expr>, <expr><name>METH_VARARGS</name> | <name>METH_KEYWORDS</name></expr>, <expr><name>open_doc</name></expr>}</block></expr>,
<expr><block>{<expr>"ord"</expr>, <expr><name>builtin_ord</name></expr>, <expr><name>METH_O</name></expr>, <expr><name>ord_doc</name></expr>}</block></expr>,
<expr><block>{<expr>"pow"</expr>, <expr><name>builtin_pow</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>pow_doc</name></expr>}</block></expr>,
<expr><block>{<expr>"print"</expr>, <expr>(<name>PyCFunction</name>)<name>builtin_print</name></expr>, <expr><name>METH_VARARGS</name> | <name>METH_KEYWORDS</name></expr>, <expr><name>print_doc</name></expr>}</block></expr>,
<expr><block>{<expr>"range"</expr>, <expr><name>builtin_range</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>range_doc</name></expr>}</block></expr>,
<expr><block>{<expr>"raw_input"</expr>, <expr><name>builtin_raw_input</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>raw_input_doc</name></expr>}</block></expr>,
<expr><block>{<expr>"reduce"</expr>, <expr><name>builtin_reduce</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>reduce_doc</name></expr>}</block></expr>,
<expr><block>{<expr>"reload"</expr>, <expr><name>builtin_reload</name></expr>, <expr><name>METH_O</name></expr>, <expr><name>reload_doc</name></expr>}</block></expr>,
<expr><block>{<expr>"repr"</expr>, <expr><name>builtin_repr</name></expr>, <expr><name>METH_O</name></expr>, <expr><name>repr_doc</name></expr>}</block></expr>,
<expr><block>{<expr>"round"</expr>, <expr>(<name>PyCFunction</name>)<name>builtin_round</name></expr>, <expr><name>METH_VARARGS</name> | <name>METH_KEYWORDS</name></expr>, <expr><name>round_doc</name></expr>}</block></expr>,
<expr><block>{<expr>"setattr"</expr>, <expr><name>builtin_setattr</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>setattr_doc</name></expr>}</block></expr>,
<expr><block>{<expr>"sorted"</expr>, <expr>(<name>PyCFunction</name>)<name>builtin_sorted</name></expr>, <expr><name>METH_VARARGS</name> | <name>METH_KEYWORDS</name></expr>, <expr><name>sorted_doc</name></expr>}</block></expr>,
<expr><block>{<expr>"sum"</expr>, <expr><name>builtin_sum</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>sum_doc</name></expr>}</block></expr>,
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>Py_USING_UNICODE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"unichr"</expr>, <expr><name>builtin_unichr</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>unichr_doc</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr><block>{<expr>"vars"</expr>, <expr><name>builtin_vars</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>vars_doc</name></expr>}</block></expr>,
<expr><block>{<expr>"zip"</expr>, <expr><name>builtin_zip</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>zip_doc</name></expr>}</block></expr>,
<expr><block>{<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>}</block></expr>,
}</block></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>builtin_doc</name></expr></argument>,
<argument><expr>"Built-in functions, exceptions, and other objects.\n\
\n\
Noteworthy: None is the `nil' object; Ellipsis represents `...' in slices."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><name>PyObject</name> *</type>
<name>_PyBuiltin_Init</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>mod</name></decl>, *<decl><type ref="prev"/><name>dict</name></decl>, *<decl><type ref="prev"/><name>debug</name></decl>;</decl_stmt>
<expr_stmt><expr><name>mod</name> = <call><name>Py_InitModule4</name><argument_list>(<argument><expr>"__builtin__"</expr></argument>, <argument><expr><name>builtin_methods</name></expr></argument>,
<argument><expr><name>builtin_doc</name></expr></argument>, <argument><expr>(<name>PyObject</name> *)<name>NULL</name></expr></argument>,
<argument><expr><name>PYTHON_API_VERSION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>mod</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>dict</name> = <call><name>PyModule_GetDict</name><argument_list>(<argument><expr><name>mod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>Py_TRACE_REFS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ADD_TO_ALL</name><parameter_list>(<param><type><name>OBJECT</name></type></param>)</parameter_list></cpp:macro> <cpp:value>_Py_AddToAllObjects((PyObject *)(OBJECT), 0)</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ADD_TO_ALL</name><parameter_list>(<param><type><name>OBJECT</name></type></param>)</parameter_list></cpp:macro> <cpp:value>(void)0</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SETBUILTIN</name><parameter_list>(<param><type><name>NAME</name></type></param>, <param><type><name>OBJECT</name></type></param>)</parameter_list></cpp:macro> <cpp:value>if (PyDict_SetItemString(dict, NAME, (PyObject *)OBJECT) &lt; 0) return NULL; ADD_TO_ALL(OBJECT)</cpp:value></cpp:define>
<expr_stmt><expr><call><name>SETBUILTIN</name><argument_list>(<argument><expr>"None"</expr></argument>, <argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SETBUILTIN</name><argument_list>(<argument><expr>"Ellipsis"</expr></argument>, <argument><expr><name>Py_Ellipsis</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SETBUILTIN</name><argument_list>(<argument><expr>"NotImplemented"</expr></argument>, <argument><expr><name>Py_NotImplemented</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SETBUILTIN</name><argument_list>(<argument><expr>"False"</expr></argument>, <argument><expr><name>Py_False</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SETBUILTIN</name><argument_list>(<argument><expr>"True"</expr></argument>, <argument><expr><name>Py_True</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SETBUILTIN</name><argument_list>(<argument><expr>"basestring"</expr></argument>, <argument><expr>&amp;<name>PyBaseString_Type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SETBUILTIN</name><argument_list>(<argument><expr>"bool"</expr></argument>, <argument><expr>&amp;<name>PyBool_Type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SETBUILTIN</name><argument_list>(<argument><expr>"bytearray"</expr></argument>, <argument><expr>&amp;<name>PyByteArray_Type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SETBUILTIN</name><argument_list>(<argument><expr>"bytes"</expr></argument>, <argument><expr>&amp;<name>PyString_Type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SETBUILTIN</name><argument_list>(<argument><expr>"buffer"</expr></argument>, <argument><expr>&amp;<name>PyBuffer_Type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SETBUILTIN</name><argument_list>(<argument><expr>"classmethod"</expr></argument>, <argument><expr>&amp;<name>PyClassMethod_Type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>WITHOUT_COMPLEX</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>SETBUILTIN</name><argument_list>(<argument><expr>"complex"</expr></argument>, <argument><expr>&amp;<name>PyComplex_Type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><call><name>SETBUILTIN</name><argument_list>(<argument><expr>"dict"</expr></argument>, <argument><expr>&amp;<name>PyDict_Type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SETBUILTIN</name><argument_list>(<argument><expr>"enumerate"</expr></argument>, <argument><expr>&amp;<name>PyEnum_Type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SETBUILTIN</name><argument_list>(<argument><expr>"file"</expr></argument>, <argument><expr>&amp;<name>PyFile_Type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SETBUILTIN</name><argument_list>(<argument><expr>"float"</expr></argument>, <argument><expr>&amp;<name>PyFloat_Type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SETBUILTIN</name><argument_list>(<argument><expr>"frozenset"</expr></argument>, <argument><expr>&amp;<name>PyFrozenSet_Type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SETBUILTIN</name><argument_list>(<argument><expr>"property"</expr></argument>, <argument><expr>&amp;<name>PyProperty_Type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SETBUILTIN</name><argument_list>(<argument><expr>"int"</expr></argument>, <argument><expr>&amp;<name>PyInt_Type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SETBUILTIN</name><argument_list>(<argument><expr>"list"</expr></argument>, <argument><expr>&amp;<name>PyList_Type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SETBUILTIN</name><argument_list>(<argument><expr>"long"</expr></argument>, <argument><expr>&amp;<name>PyLong_Type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SETBUILTIN</name><argument_list>(<argument><expr>"object"</expr></argument>, <argument><expr>&amp;<name>PyBaseObject_Type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SETBUILTIN</name><argument_list>(<argument><expr>"reversed"</expr></argument>, <argument><expr>&amp;<name>PyReversed_Type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SETBUILTIN</name><argument_list>(<argument><expr>"set"</expr></argument>, <argument><expr>&amp;<name>PySet_Type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SETBUILTIN</name><argument_list>(<argument><expr>"slice"</expr></argument>, <argument><expr>&amp;<name>PySlice_Type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SETBUILTIN</name><argument_list>(<argument><expr>"staticmethod"</expr></argument>, <argument><expr>&amp;<name>PyStaticMethod_Type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SETBUILTIN</name><argument_list>(<argument><expr>"str"</expr></argument>, <argument><expr>&amp;<name>PyString_Type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SETBUILTIN</name><argument_list>(<argument><expr>"super"</expr></argument>, <argument><expr>&amp;<name>PySuper_Type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SETBUILTIN</name><argument_list>(<argument><expr>"tuple"</expr></argument>, <argument><expr>&amp;<name>PyTuple_Type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SETBUILTIN</name><argument_list>(<argument><expr>"type"</expr></argument>, <argument><expr>&amp;<name>PyType_Type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SETBUILTIN</name><argument_list>(<argument><expr>"xrange"</expr></argument>, <argument><expr>&amp;<name>PyRange_Type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>Py_USING_UNICODE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>SETBUILTIN</name><argument_list>(<argument><expr>"unicode"</expr></argument>, <argument><expr>&amp;<name>PyUnicode_Type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><name>debug</name> = <call><name>PyBool_FromLong</name><argument_list>(<argument><expr><name>Py_OptimizeFlag</name> == 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>PyDict_SetItemString</name><argument_list>(<argument><expr><name>dict</name></expr></argument>, <argument><expr>"__debug__"</expr></argument>, <argument><expr><name>debug</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>debug</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>debug</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>mod</name></expr>;</return>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>ADD_TO_ALL</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>SETBUILTIN</name></cpp:undef>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>filtertuple</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>func</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>tuple</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>result</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>len</name> <init>= <expr><call><name>PyTuple_Size</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>len</name> == 0</expr>)</condition><then> <block>{
<if>if <condition>(<expr><call><name>PyTuple_CheckExact</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
<else>else
<expr_stmt><expr><name>tuple</name> = <call><name>PyTuple_New</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
<return>return <expr><name>tuple</name></expr>;</return>
}</block></then></if>
<if>if <condition>(<expr>(<name>result</name> = <call><name>PyTuple_New</name><argument_list>(<argument><expr><name>len</name></expr></argument>)</argument_list></call>) == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<for>for (<init><expr><name>i</name> = <name>j</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>len</name></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>) <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>item</name></decl>, *<decl><type ref="prev"/><name>good</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>ok</name></decl>;</decl_stmt>
<if>if <condition>(<expr><name><name>tuple</name>-&gt;<name>ob_type</name>-&gt;<name>tp_as_sequence</name></name> &amp;&amp;
<name><name>tuple</name>-&gt;<name>ob_type</name>-&gt;<name>tp_as_sequence</name>-&gt;<name>sq_item</name></name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>item</name> = <call><name><name>tuple</name>-&gt;<name>ob_type</name>-&gt;<name>tp_as_sequence</name>-&gt;<name>sq_item</name></name><argument_list>(<argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>item</name> == <name>NULL</name></expr>)</condition><then>
<goto>goto <name>Fail_1</name>;</goto></then></if>
}</block></then> <else>else <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>, <argument><expr>"filter(): unsubscriptable tuple"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>Fail_1</name>;</goto>
}</block></else></if>
<if>if <condition>(<expr><name>func</name> == <name>Py_None</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>good</name> = <name>item</name></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>arg</name> <init>= <expr><call><name>PyTuple_Pack</name><argument_list>(<argument><expr>1</expr></argument>, <argument><expr><name>item</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>arg</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>Fail_1</name>;</goto>
}</block></then></if>
<expr_stmt><expr><name>good</name> = <call><name>PyEval_CallObject</name><argument_list>(<argument><expr><name>func</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>good</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>Fail_1</name>;</goto>
}</block></then></if>
}</block></else></if>
<expr_stmt><expr><name>ok</name> = <call><name>PyObject_IsTrue</name><argument_list>(<argument><expr><name>good</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>good</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>ok</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr><call><name>PyTuple_SetItem</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>j</name>++</expr></argument>, <argument><expr><name>item</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
<goto>goto <name>Fail_1</name>;</goto></then></if>
}</block></then> <else>else
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
}</block></for>
<if>if <condition>(<expr><call><name>_PyTuple_Resize</name><argument_list>(<argument><expr>&amp;<name>result</name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<return>return <expr><name>result</name></expr>;</return>
<label><name>Fail_1</name>:</label>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>filterstring</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>func</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>strobj</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>result</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>len</name> <init>= <expr><call><name>PyString_Size</name><argument_list>(<argument><expr><name>strobj</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>outlen</name> <init>= <expr><name>len</name></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>func</name> == <name>Py_None</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr><call><name>PyString_CheckExact</name><argument_list>(<argument><expr><name>strobj</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>strobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>strobj</name></expr>;</return>
}</block></then></if>
}</block></then></if>
<if>if <condition>(<expr>(<name>result</name> = <call><name>PyString_FromStringAndSize</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call>) == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<for>for (<init><expr><name>i</name> = <name>j</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>len</name></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>) <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>item</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>ok</name></decl>;</decl_stmt>
<expr_stmt><expr><name>item</name> = <call>(*<name><name>strobj</name>-&gt;<name>ob_type</name>-&gt;<name>tp_as_sequence</name>-&gt;<name>sq_item</name></name>)<argument_list>(<argument><expr><name>strobj</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>item</name> == <name>NULL</name></expr>)</condition><then>
<goto>goto <name>Fail_1</name>;</goto></then></if>
<if>if <condition>(<expr><name>func</name>==<name>Py_None</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>ok</name> = 1</expr>;</expr_stmt>
}</block></then> <else>else <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>arg</name></decl>, *<decl><type ref="prev"/><name>good</name></decl>;</decl_stmt>
<expr_stmt><expr><name>arg</name> = <call><name>PyTuple_Pack</name><argument_list>(<argument><expr>1</expr></argument>, <argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>arg</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>Fail_1</name>;</goto>
}</block></then></if>
<expr_stmt><expr><name>good</name> = <call><name>PyEval_CallObject</name><argument_list>(<argument><expr><name>func</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>good</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>Fail_1</name>;</goto>
}</block></then></if>
<expr_stmt><expr><name>ok</name> = <call><name>PyObject_IsTrue</name><argument_list>(<argument><expr><name>good</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>good</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></else></if>
<if>if <condition>(<expr><name>ok</name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>reslen</name></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>PyString_Check</name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>, <argument><expr>"can't filter str to str:"
" __getitem__ returned different type"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>Fail_1</name>;</goto>
}</block></then></if>
<expr_stmt><expr><name>reslen</name> = <call><name>PyString_GET_SIZE</name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>reslen</name> == 1</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call><index>[<expr><name>j</name>++</expr>]</index> =
<call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call><index>[<expr>0</expr>]</index></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>need</name> <init>= <expr><name>j</name></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>need</name> &gt; <name>PY_SSIZE_T_MAX</name> - <name>reslen</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>Fail_1</name>;</goto>
}</block></then></if>
<expr_stmt><expr><name>need</name> += <name>reslen</name></expr>;</expr_stmt>
<if>if <condition>(<expr><name>need</name> &gt; <name>PY_SSIZE_T_MAX</name> - <name>len</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>Fail_1</name>;</goto>
}</block></then></if>
<expr_stmt><expr><name>need</name> += <name>len</name></expr>;</expr_stmt>
<if>if <condition>(<expr><name>need</name> &lt;= <name>i</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>Fail_1</name>;</goto>
}</block></then></if>
<expr_stmt><expr><name>need</name> = <name>need</name> - <name>i</name> - 1</expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>need</name> &gt;= 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>outlen</name> &gt;= 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>need</name> &gt; <name>outlen</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr><name>outlen</name> &gt; <name>PY_SSIZE_T_MAX</name> / 2</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<if>if <condition>(<expr><name>need</name>&lt;2*<name>outlen</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>need</name> = 2*<name>outlen</name></expr>;</expr_stmt>
}</block></then></if>
<if>if <condition>(<expr><call><name>_PyString_Resize</name><argument_list>(<argument><expr>&amp;<name>result</name></expr></argument>, <argument><expr><name>need</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>outlen</name> = <name>need</name></expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(
<argument><expr><call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call> + <name>j</name></expr></argument>,
<argument><expr><call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>reslen</name></expr></argument>
)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>j</name> += <name>reslen</name></expr>;</expr_stmt>
}</block></else></if>
}</block></then></if>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></for>
<if>if <condition>(<expr><name>j</name> &lt; <name>outlen</name></expr>)</condition><then>
<expr_stmt><expr><call><name>_PyString_Resize</name><argument_list>(<argument><expr>&amp;<name>result</name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<return>return <expr><name>result</name></expr>;</return>
<label><name>Fail_1</name>:</label>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></function>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>Py_USING_UNICODE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>filterunicode</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>func</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>strobj</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>result</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>register</name> <name>Py_ssize_t</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>len</name> <init>= <expr><call><name>PyUnicode_GetSize</name><argument_list>(<argument><expr><name>strobj</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>outlen</name> <init>= <expr><name>len</name></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>func</name> == <name>Py_None</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr><call><name>PyUnicode_CheckExact</name><argument_list>(<argument><expr><name>strobj</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>strobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>strobj</name></expr>;</return>
}</block></then></if>
}</block></then></if>
<if>if <condition>(<expr>(<name>result</name> = <call><name>PyUnicode_FromUnicode</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call>) == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<for>for (<init><expr><name>i</name> = <name>j</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>len</name></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>) <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>item</name></decl>, *<decl><type ref="prev"/><name>arg</name></decl>, *<decl><type ref="prev"/><name>good</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>ok</name></decl>;</decl_stmt>
<expr_stmt><expr><name>item</name> = <call>(*<name><name>strobj</name>-&gt;<name>ob_type</name>-&gt;<name>tp_as_sequence</name>-&gt;<name>sq_item</name></name>)<argument_list>(<argument><expr><name>strobj</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>item</name> == <name>NULL</name></expr>)</condition><then>
<goto>goto <name>Fail_1</name>;</goto></then></if>
<if>if <condition>(<expr><name>func</name> == <name>Py_None</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>ok</name> = 1</expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr><name>arg</name> = <call><name>PyTuple_Pack</name><argument_list>(<argument><expr>1</expr></argument>, <argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>arg</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>Fail_1</name>;</goto>
}</block></then></if>
<expr_stmt><expr><name>good</name> = <call><name>PyEval_CallObject</name><argument_list>(<argument><expr><name>func</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>good</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>Fail_1</name>;</goto>
}</block></then></if>
<expr_stmt><expr><name>ok</name> = <call><name>PyObject_IsTrue</name><argument_list>(<argument><expr><name>good</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>good</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></else></if>
<if>if <condition>(<expr><name>ok</name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>reslen</name></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>PyUnicode_Check</name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
<argument><expr>"can't filter unicode to unicode:"
" __getitem__ returned different type"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>Fail_1</name>;</goto>
}</block></then></if>
<expr_stmt><expr><name>reslen</name> = <call><name>PyUnicode_GET_SIZE</name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>reslen</name> == 1</expr>)</condition><then>
<expr_stmt><expr><call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call><index>[<expr><name>j</name>++</expr>]</index> =
<call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call><index>[<expr>0</expr>]</index></expr>;</expr_stmt></then>
<else>else <block>{
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>need</name> <init>= <expr><name>j</name> + <name>reslen</name> + <name>len</name> - <name>i</name> - 1</expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr>(<name>j</name> &gt; <name>PY_SSIZE_T_MAX</name> - <name>reslen</name>) ||
((<name>j</name> + <name>reslen</name>) &gt; <name>PY_SSIZE_T_MAX</name> - <name>len</name>) ||
((<name>j</name> + <name>reslen</name> + <name>len</name>) &lt; <name>i</name>) ||
((<name>j</name> + <name>reslen</name> + <name>len</name> - <name>i</name>) &lt;= 0)</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>need</name> &gt;= 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>outlen</name> &gt;= 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>need</name> &gt; <name>outlen</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr><name>need</name> &lt; 2 * <name>outlen</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr><name>outlen</name> &gt; <name>PY_SSIZE_T_MAX</name> / 2</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then> <else>else <block>{
<expr_stmt><expr><name>need</name> = 2 * <name>outlen</name></expr>;</expr_stmt>
}</block></else></if>
}</block></then></if>
<if>if <condition>(<expr><call><name>PyUnicode_Resize</name><argument_list>(
<argument><expr>&amp;<name>result</name></expr></argument>, <argument><expr><name>need</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>Fail_1</name>;</goto>
}</block></then></if>
<expr_stmt><expr><name>outlen</name> = <name>need</name></expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call> + <name>j</name></expr></argument>,
<argument><expr><call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>reslen</name>*<sizeof>sizeof<argument_list>(<argument><expr><name>Py_UNICODE</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>j</name> += <name>reslen</name></expr>;</expr_stmt>
}</block></else></if>
}</block></then></if>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></for>
<if>if <condition>(<expr><name>j</name> &lt; <name>outlen</name></expr>)</condition><then>
<expr_stmt><expr><call><name>PyUnicode_Resize</name><argument_list>(<argument><expr>&amp;<name>result</name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<return>return <expr><name>result</name></expr>;</return>
<label><name>Fail_1</name>:</label>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</unit>
