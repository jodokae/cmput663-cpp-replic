<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C" filename="projects/cpython-2.6.1/_cppstats/Python/compile.c"><cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"Python.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"Python-ast.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"node.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pyarena.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ast.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"code.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"compile.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"symtable.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"opcode.h"</cpp:file></cpp:include>
<decl_stmt><decl><type><name>int</name></type> <name>Py_OptimizeFlag</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DEFAULT_BLOCK_SIZE</name></cpp:macro> <cpp:value>16</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DEFAULT_BLOCKS</name></cpp:macro> <cpp:value>8</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DEFAULT_CODE_SIZE</name></cpp:macro> <cpp:value>128</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DEFAULT_LNOTAB_SIZE</name></cpp:macro> <cpp:value>16</cpp:value></cpp:define>
<struct>struct <name>instr</name> <block>{
<expr_stmt><expr><name>unsigned</name> <name>i_jabs</name> : 1</expr>;</expr_stmt>
<expr_stmt><expr><name>unsigned</name> <name>i_jrel</name> : 1</expr>;</expr_stmt>
<expr_stmt><expr><name>unsigned</name> <name>i_hasarg</name> : 1</expr>;</expr_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name>i_opcode</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i_oparg</name></decl>;</decl_stmt>
<decl_stmt><decl><type>struct <name>basicblock_</name> *</type><name>i_target</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i_lineno</name></decl>;</decl_stmt>
}</block>;</struct>
<typedef>typedef <type><struct>struct <name>basicblock_</name> <block>{
<decl_stmt><decl><type>struct <name>basicblock_</name> *</type><name>b_list</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>b_iused</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>b_ialloc</name></decl>;</decl_stmt>
<decl_stmt><decl><type>struct <name>instr</name> *</type><name>b_instr</name></decl>;</decl_stmt>
<decl_stmt><decl><type>struct <name>basicblock_</name> *</type><name>b_next</name></decl>;</decl_stmt>
<expr_stmt><expr><name>unsigned</name> <name>b_seen</name> : 1</expr>;</expr_stmt>
<expr_stmt><expr><name>unsigned</name> <name>b_return</name> : 1</expr>;</expr_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>b_startdepth</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>b_offset</name></decl>;</decl_stmt>
}</block></struct></type> <name>basicblock</name>;</typedef>
<enum>enum <name>fblocktype</name> <block>{ <decl><name>LOOP</name></decl>, <decl><name>EXCEPT</name></decl>, <decl><name>FINALLY_TRY</name></decl>, <decl><name>FINALLY_END</name></decl> }</block>;</enum>
<struct>struct <name>fblockinfo</name> <block>{
<enum>enum <name>fblocktype</name> <name>fb_type</name>;</enum>
<decl_stmt><decl><type><name>basicblock</name> *</type><name>fb_block</name></decl>;</decl_stmt>
}</block>;</struct>
<struct>struct <name>compiler_unit</name> <block>{
<decl_stmt><decl><type><name>PySTEntryObject</name> *</type><name>u_ste</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>u_name</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>u_consts</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>u_names</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>u_varnames</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>u_cellvars</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>u_freevars</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>u_private</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>u_argcount</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>basicblock</name> *</type><name>u_blocks</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>basicblock</name> *</type><name>u_curblock</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>u_tmpname</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>u_nfblocks</name></decl>;</decl_stmt>
<decl_stmt><decl><type>struct <name>fblockinfo</name></type> <name><name>u_fblock</name><index>[<expr><name>CO_MAXBLOCKS</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>u_firstlineno</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>u_lineno</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>u_lineno_set</name></decl>;</decl_stmt>
}</block>;</struct>
<struct>struct <name>compiler</name> <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>c_filename</name></decl>;</decl_stmt>
<decl_stmt><decl><type>struct <name>symtable</name> *</type><name>c_st</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyFutureFeatures</name> *</type><name>c_future</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyCompilerFlags</name> *</type><name>c_flags</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>c_interactive</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>c_nestlevel</name></decl>;</decl_stmt>
<decl_stmt><decl><type>struct <name>compiler_unit</name> *</type><name>u</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>c_stack</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>c_encoding</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyArena</name> *</type><name>c_arena</name></decl>;</decl_stmt>
}</block>;</struct>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>compiler_enter_scope</name><parameter_list>(<param><decl><type>struct</type> <name>compiler</name> *</decl></param>, <param><decl><type><name>identifier</name></type></decl></param>, <param><decl><type><name>void</name> *</type></decl></param>, <param><decl><type><name>int</name></type></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>compiler_free</name><parameter_list>(<param><decl><type>struct</type> <name>compiler</name> *</decl></param>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>basicblock</name> *</type><name>compiler_new_block</name><parameter_list>(<param><decl><type>struct</type> <name>compiler</name> *</decl></param>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>compiler_next_instr</name><parameter_list>(<param><decl><type>struct</type> <name>compiler</name> *</decl></param>, <param><decl><type><name>basicblock</name> *</type></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>compiler_addop</name><parameter_list>(<param><decl><type>struct</type> <name>compiler</name> *</decl></param>, <param><decl><type><name>int</name></type></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>compiler_addop_o</name><parameter_list>(<param><decl><type>struct</type> <name>compiler</name> *</decl></param>, <param><decl><type><name>int</name></type></decl></param>, <param><decl><type><name>PyObject</name> *</type></decl></param>, <param><decl><type><name>PyObject</name> *</type></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>compiler_addop_i</name><parameter_list>(<param><decl><type>struct</type> <name>compiler</name> *</decl></param>, <param><decl><type><name>int</name></type></decl></param>, <param><decl><type><name>int</name></type></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>compiler_addop_j</name><parameter_list>(<param><decl><type>struct</type> <name>compiler</name> *</decl></param>, <param><decl><type><name>int</name></type></decl></param>, <param><decl><type><name>basicblock</name> *</type></decl></param>, <param><decl><type><name>int</name></type></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>basicblock</name> *</type><name>compiler_use_new_block</name><parameter_list>(<param><decl><type>struct</type> <name>compiler</name> *</decl></param>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>compiler_error</name><parameter_list>(<param><decl><type>struct</type> <name>compiler</name> *</decl></param>, <param><decl><type><specifier>const</specifier></type> <name>char</name> *</decl></param>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>compiler_nameop</name><parameter_list>(<param><decl><type>struct</type> <name>compiler</name> *</decl></param>, <param><decl><type><name>identifier</name></type></decl></param>, <param><decl><type><name>expr_context_ty</name></type></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>PyCodeObject</name> *</type><name>compiler_mod</name><parameter_list>(<param><decl><type>struct</type> <name>compiler</name> *</decl></param>, <param><decl><type><name>mod_ty</name></type></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>compiler_visit_stmt</name><parameter_list>(<param><decl><type>struct</type> <name>compiler</name> *</decl></param>, <param><decl><type><name>stmt_ty</name></type></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>compiler_visit_keyword</name><parameter_list>(<param><decl><type>struct</type> <name>compiler</name> *</decl></param>, <param><decl><type><name>keyword_ty</name></type></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>compiler_visit_expr</name><parameter_list>(<param><decl><type>struct</type> <name>compiler</name> *</decl></param>, <param><decl><type><name>expr_ty</name></type></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>compiler_augassign</name><parameter_list>(<param><decl><type>struct</type> <name>compiler</name> *</decl></param>, <param><decl><type><name>stmt_ty</name></type></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>compiler_visit_slice</name><parameter_list>(<param><decl><type>struct</type> <name>compiler</name> *</decl></param>, <param><decl><type><name>slice_ty</name></type></decl></param>,
<param><decl><type><name>expr_context_ty</name></type></decl></param>)</parameter_list>;</function_decl>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>compiler_push_fblock</name><argument_list>(<argument>struct <expr><name>compiler</name> *</expr></argument>, <argument><enum>enum <name>fblocktype</name><block/></enum>,
<expr><name>basicblock</name> *</expr></argument>)</argument_list></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>void</name></type> <name>compiler_pop_fblock</name><argument_list>(<argument>struct <expr><name>compiler</name> *</expr></argument>, <argument><enum>enum <name>fblocktype</name><block/></enum>,
<expr><name>basicblock</name> *</expr></argument>)</argument_list></decl>;</decl_stmt>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>compiler_in_loop</name><parameter_list>(<param><decl><type>struct</type> <name>compiler</name> *</decl></param>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>inplace_binop</name><parameter_list>(<param><decl><type>struct</type> <name>compiler</name> *</decl></param>, <param><decl><type><name>operator_ty</name></type></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>expr_constant</name><parameter_list>(<param><decl><type><name>expr_ty</name></type> <name>e</name></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>compiler_with</name><parameter_list>(<param><decl><type>struct</type> <name>compiler</name> *</decl></param>, <param><decl><type><name>stmt_ty</name></type></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>PyCodeObject</name> *</type><name>assemble</name><parameter_list>(<param><decl><type>struct</type> <name>compiler</name> *</decl></param>, <param><decl><type><name>int</name></type> <name>addNone</name></decl></param>)</parameter_list>;</function_decl>
<decl_stmt><decl><type><specifier>static</specifier> <name>PyObject</name> *</type><name>__doc__</name></decl>;</decl_stmt>
<function><type><name>PyObject</name> *</type>
<name>_Py_Mangle</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>privateobj</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>ident</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>p</name></decl>, *<decl><type ref="prev"/><name>name</name> <init>= <expr><call><name>PyString_AsString</name><argument_list>(<argument><expr><name>ident</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>buffer</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>nlen</name></decl>, <decl><type ref="prev"/><name>plen</name></decl>;</decl_stmt>
<if>if <condition>(<expr><name>privateobj</name> == <name>NULL</name> || !<call><name>PyString_Check</name><argument_list>(<argument><expr><name>privateobj</name></expr></argument>)</argument_list></call> ||
<name>name</name> == <name>NULL</name> || <name><name>name</name><index>[<expr>0</expr>]</index></name> != '_' || <name><name>name</name><index>[<expr>1</expr>]</index></name> != '_'</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>ident</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>ident</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>p</name> = <call><name>PyString_AsString</name><argument_list>(<argument><expr><name>privateobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>nlen</name> = <call><name>strlen</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>(<name><name>name</name><index>[<expr><name>nlen</name>-1</expr>]</index></name> == '_' &amp;&amp; <name><name>name</name><index>[<expr><name>nlen</name>-2</expr>]</index></name> == '_')
|| <call><name>strchr</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr>'.'</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>ident</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>ident</name></expr>;</return>
}</block></then></if>
<while>while <condition>(<expr>*<name>p</name> == '_'</expr>)</condition>
<expr_stmt><expr><name>p</name>++</expr>;</expr_stmt></while>
<if>if <condition>(<expr>*<name>p</name> == '\0'</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>ident</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>ident</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>plen</name> = <call><name>strlen</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr>1 &lt;= <name>PY_SSIZE_T_MAX</name> - <name>nlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr>1 + <name>nlen</name> &lt;= <name>PY_SSIZE_T_MAX</name> - <name>plen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ident</name> = <call><name>PyString_FromStringAndSize</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr>1 + <name>nlen</name> + <name>plen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>ident</name></expr>)</condition><then>
<return>return <expr>0</expr>;</return></then></if>
<expr_stmt><expr><name>buffer</name> = <call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>ident</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>buffer</name><index>[<expr>0</expr>]</index></name> = '_'</expr>;</expr_stmt>
<expr_stmt><expr><call><name>strncpy</name><argument_list>(<argument><expr><name>buffer</name>+1</expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>plen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>buffer</name>+1+<name>plen</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>ident</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>compiler_init</name><parameter_list>(<param><decl><type>struct <name>compiler</name> *</type><name>c</name></decl></param>)</parameter_list> <block>{
<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument>struct <expr><name>compiler</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>c</name>-&gt;<name>c_stack</name></name> = <call><name>PyList_New</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name><name>c</name>-&gt;<name>c_stack</name></name></expr>)</condition><then>
<return>return <expr>0</expr>;</return></then></if>
<return>return <expr>1</expr>;</return>
}</block></function>
<function><type><name>PyCodeObject</name> *</type>
<name>PyAST_Compile</name><parameter_list>(<param><decl><type><name>mod_ty</name></type> <name>mod</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>filename</name></decl></param>, <param><decl><type><name>PyCompilerFlags</name> *</type><name>flags</name></decl></param>,
<param><decl><type><name>PyArena</name> *</type><name>arena</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type>struct <name>compiler</name></type> <name>c</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyCodeObject</name> *</type><name>co</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyCompilerFlags</name></type> <name>local_flags</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>merged</name></decl>;</decl_stmt>
<if>if <condition>(<expr>!<name>__doc__</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>__doc__</name> = <call><name>PyString_InternFromString</name><argument_list>(<argument><expr>"__doc__"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>__doc__</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
}</block></then></if>
<if>if <condition>(<expr>!<call><name>compiler_init</name><argument_list>(<argument><expr>&amp;<name>c</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name><name>c</name>.<name>c_filename</name></name> = <name>filename</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>c</name>.<name>c_arena</name></name> = <name>arena</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>c</name>.<name>c_future</name></name> = <call><name>PyFuture_FromAST</name><argument_list>(<argument><expr><name>mod</name></expr></argument>, <argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>c</name>.<name>c_future</name></name> == <name>NULL</name></expr>)</condition><then>
<goto>goto <name>finally</name>;</goto></then></if>
<if>if <condition>(<expr>!<name>flags</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>local_flags</name>.<name>cf_flags</name></name> = 0</expr>;</expr_stmt>
<expr_stmt><expr><name>flags</name> = &amp;<name>local_flags</name></expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><name>merged</name> = <name><name>c</name>.<name>c_future</name>-&gt;<name>ff_features</name></name> | <name><name>flags</name>-&gt;<name>cf_flags</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>c</name>.<name>c_future</name>-&gt;<name>ff_features</name></name> = <name>merged</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>flags</name>-&gt;<name>cf_flags</name></name> = <name>merged</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>c</name>.<name>c_flags</name></name> = <name>flags</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>c</name>.<name>c_nestlevel</name></name> = 0</expr>;</expr_stmt>
<expr_stmt><expr><name><name>c</name>.<name>c_st</name></name> = <call><name>PySymtable_Build</name><argument_list>(<argument><expr><name>mod</name></expr></argument>, <argument><expr><name>filename</name></expr></argument>, <argument><expr><name><name>c</name>.<name>c_future</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>c</name>.<name>c_st</name></name> == <name>NULL</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr>!<call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then>
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_SystemError</name></expr></argument>, <argument><expr>"no symtable"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<goto>goto <name>finally</name>;</goto>
}</block></then></if>
<expr_stmt><expr><name><name>c</name>.<name>c_encoding</name></name> = <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name>co</name> = <call><name>compiler_mod</name><argument_list>(<argument><expr>&amp;<name>c</name></expr></argument>, <argument><expr><name>mod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<label><name>finally</name>:</label>
<expr_stmt><expr><call><name>compiler_free</name><argument_list>(<argument><expr>&amp;<name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>co</name> || <call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>co</name></expr>;</return>
}</block></function>
<function><type><name>PyCodeObject</name> *</type>
<name>PyNode_Compile</name><parameter_list>(<param><decl><type>struct <name>_node</name> *</type><name>n</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>filename</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyCodeObject</name> *</type><name>co</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>mod_ty</name></type> <name>mod</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyArena</name> *</type><name>arena</name> <init>= <expr><call><name>PyArena_New</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr>!<name>arena</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>mod</name> = <call><name>PyAST_FromNode</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>filename</name></expr></argument>, <argument><expr><name>arena</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>mod</name></expr>)</condition><then>
<expr_stmt><expr><name>co</name> = <call><name>PyAST_Compile</name><argument_list>(<argument><expr><name>mod</name></expr></argument>, <argument><expr><name>filename</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>arena</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<expr_stmt><expr><call><name>PyArena_Free</name><argument_list>(<argument><expr><name>arena</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>co</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>compiler_free</name><parameter_list>(<param><decl><type>struct <name>compiler</name> *</type><name>c</name></decl></param>)</parameter_list> <block>{
<if>if <condition>(<expr><name><name>c</name>-&gt;<name>c_st</name></name></expr>)</condition><then>
<expr_stmt><expr><call><name>PySymtable_Free</name><argument_list>(<argument><expr><name><name>c</name>-&gt;<name>c_st</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<if>if <condition>(<expr><name><name>c</name>-&gt;<name>c_future</name></name></expr>)</condition><then>
<expr_stmt><expr><call><name>PyObject_Free</name><argument_list>(<argument><expr><name><name>c</name>-&gt;<name>c_future</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name><name>c</name>-&gt;<name>c_stack</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>list2dict</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>list</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>n</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>v</name></decl>, *<decl><type ref="prev"/><name>k</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>dict</name> <init>= <expr><call><name>PyDict_New</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr>!<name>dict</name></expr>)</condition><then> <return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>n</name> = <call><name>PyList_Size</name><argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>n</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
<expr_stmt><expr><name>v</name> = <call><name>PyInt_FromLong</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>v</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>dict</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>k</name> = <call><name>PyList_GET_ITEM</name><argument_list>(<argument><expr><name>list</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>k</name> = <call><name>PyTuple_Pack</name><argument_list>(<argument><expr>2</expr></argument>, <argument><expr><name>k</name></expr></argument>, <argument><expr><name><name>k</name>-&gt;<name>ob_type</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>k</name> == <name>NULL</name> || <call><name>PyDict_SetItem</name><argument_list>(<argument><expr><name>dict</name></expr></argument>, <argument><expr><name>k</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>k</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>dict</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>k</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></for>
<return>return <expr><name>dict</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>dictbytype</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>src</name></decl></param>, <param><decl><type><name>int</name></type> <name>scope_type</name></decl></param>, <param><decl><type><name>int</name></type> <name>flag</name></decl></param>, <param><decl><type><name>int</name></type> <name>offset</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>pos</name> <init>= <expr>0</expr></init>, <name>i</name> <init>= <expr><name>offset</name></expr></init>, <name>scope</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>k</name></decl>, *<decl><type ref="prev"/><name>v</name></decl>, *<decl><type ref="prev"/><name>dest</name> <init>= <expr><call><name>PyDict_New</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>offset</name> &gt;= 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>dest</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<while>while <condition>(<expr><call><name>PyDict_Next</name><argument_list>(<argument><expr><name>src</name></expr></argument>, <argument><expr>&amp;<name>pos</name></expr></argument>, <argument><expr>&amp;<name>k</name></expr></argument>, <argument><expr>&amp;<name>v</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>PyInt_Check</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>scope</name> = (<call><name>PyInt_AS_LONG</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call> &gt;&gt; <name>SCOPE_OFF</name>) &amp; <name>SCOPE_MASK</name></expr>;</expr_stmt>
<if>if <condition>(<expr><name>scope</name> == <name>scope_type</name> || <call><name>PyInt_AS_LONG</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call> &amp; <name>flag</name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>tuple</name></decl>, *<decl><type ref="prev"/><name>item</name> <init>= <expr><call><name>PyInt_FromLong</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>item</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>dest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>i</name>++</expr>;</expr_stmt>
<expr_stmt><expr><name>tuple</name> = <call><name>PyTuple_Pack</name><argument_list>(<argument><expr>2</expr></argument>, <argument><expr><name>k</name></expr></argument>, <argument><expr><name><name>k</name>-&gt;<name>ob_type</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>tuple</name> || <call><name>PyDict_SetItem</name><argument_list>(<argument><expr><name>dest</name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>item</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>dest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
}</block></while>
<return>return <expr><name>dest</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>compiler_unit_check</name><parameter_list>(<param><decl><type>struct <name>compiler_unit</name> *</type><name>u</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>basicblock</name> *</type><name>block</name></decl>;</decl_stmt>
<for>for (<init><expr><name>block</name> = <name><name>u</name>-&gt;<name>u_blocks</name></name></expr>;</init> <condition><expr><name>block</name> != <name>NULL</name></expr>;</condition> <incr><expr><name>block</name> = <name><name>block</name>-&gt;<name>b_list</name></name></expr></incr>) <block>{
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr>(<name>void</name> *)<name>block</name> != (<name>void</name> *)0xcbcbcbcb</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr>(<name>void</name> *)<name>block</name> != (<name>void</name> *)0xfbfbfbfb</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr>(<name>void</name> *)<name>block</name> != (<name>void</name> *)0xdbdbdbdb</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>block</name>-&gt;<name>b_instr</name></name> != <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>block</name>-&gt;<name>b_ialloc</name></name> &gt; 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>block</name>-&gt;<name>b_iused</name></name> &gt; 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>block</name>-&gt;<name>b_ialloc</name></name> &gt;= <name><name>block</name>-&gt;<name>b_iused</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr><call><name>assert</name> <argument_list>(<argument><expr><name><name>block</name>-&gt;<name>b_iused</name></name> == 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name> <argument_list>(<argument><expr><name><name>block</name>-&gt;<name>b_ialloc</name></name> == 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></else></if>
}</block></for>
}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>compiler_unit_free</name><parameter_list>(<param><decl><type>struct <name>compiler_unit</name> *</type><name>u</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>basicblock</name> *</type><name>b</name></decl>, *<decl><type ref="prev"/><name>next</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>compiler_unit_check</name><argument_list>(<argument><expr><name>u</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>b</name> = <name><name>u</name>-&gt;<name>u_blocks</name></name></expr>;</expr_stmt>
<while>while <condition>(<expr><name>b</name> != <name>NULL</name></expr>)</condition> <block>{
<if>if <condition>(<expr><name><name>b</name>-&gt;<name>b_instr</name></name></expr>)</condition><then>
<expr_stmt><expr><call><name>PyObject_Free</name><argument_list>(<argument><expr>(<name>void</name> *)<name><name>b</name>-&gt;<name>b_instr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<expr_stmt><expr><name>next</name> = <name><name>b</name>-&gt;<name>b_list</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyObject_Free</name><argument_list>(<argument><expr>(<name>void</name> *)<name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>b</name> = <name>next</name></expr>;</expr_stmt>
}</block></while>
<expr_stmt><expr><call><name>Py_CLEAR</name><argument_list>(<argument><expr><name><name>u</name>-&gt;<name>u_ste</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_CLEAR</name><argument_list>(<argument><expr><name><name>u</name>-&gt;<name>u_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_CLEAR</name><argument_list>(<argument><expr><name><name>u</name>-&gt;<name>u_consts</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_CLEAR</name><argument_list>(<argument><expr><name><name>u</name>-&gt;<name>u_names</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_CLEAR</name><argument_list>(<argument><expr><name><name>u</name>-&gt;<name>u_varnames</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_CLEAR</name><argument_list>(<argument><expr><name><name>u</name>-&gt;<name>u_freevars</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_CLEAR</name><argument_list>(<argument><expr><name><name>u</name>-&gt;<name>u_cellvars</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_CLEAR</name><argument_list>(<argument><expr><name><name>u</name>-&gt;<name>u_private</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyObject_Free</name><argument_list>(<argument><expr><name>u</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>compiler_enter_scope</name><parameter_list>(<param><decl><type>struct <name>compiler</name> *</type><name>c</name></decl></param>, <param><decl><type><name>identifier</name></type> <name>name</name></decl></param>, <param><decl><type><name>void</name> *</type><name>key</name></decl></param>,
<param><decl><type><name>int</name></type> <name>lineno</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type>struct <name>compiler_unit</name> *</type><name>u</name></decl>;</decl_stmt>
<expr_stmt><expr><name>u</name> = (struct <name>compiler_unit</name> *)<call><name>PyObject_Malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(
<argument>struct <expr><name>compiler_unit</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>u</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_NoMemory</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<return>return <expr>0</expr>;</return>
}</block></then></if>
<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>u</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument>struct <expr><name>compiler_unit</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>u</name>-&gt;<name>u_argcount</name></name> = 0</expr>;</expr_stmt>
<expr_stmt><expr><name><name>u</name>-&gt;<name>u_ste</name></name> = <call><name>PySymtable_Lookup</name><argument_list>(<argument><expr><name><name>c</name>-&gt;<name>c_st</name></name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name><name>u</name>-&gt;<name>u_ste</name></name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>compiler_unit_free</name><argument_list>(<argument><expr><name>u</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>0</expr>;</return>
}</block></then></if>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>u</name>-&gt;<name>u_name</name></name> = <name>name</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>u</name>-&gt;<name>u_varnames</name></name> = <call><name>list2dict</name><argument_list>(<argument><expr><name><name>u</name>-&gt;<name>u_ste</name>-&gt;<name>ste_varnames</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>u</name>-&gt;<name>u_cellvars</name></name> = <call><name>dictbytype</name><argument_list>(<argument><expr><name><name>u</name>-&gt;<name>u_ste</name>-&gt;<name>ste_symbols</name></name></expr></argument>, <argument><expr><name>CELL</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name><name>u</name>-&gt;<name>u_varnames</name></name> || !<name><name>u</name>-&gt;<name>u_cellvars</name></name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>compiler_unit_free</name><argument_list>(<argument><expr><name>u</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>0</expr>;</return>
}</block></then></if>
<expr_stmt><expr><name><name>u</name>-&gt;<name>u_freevars</name></name> = <call><name>dictbytype</name><argument_list>(<argument><expr><name><name>u</name>-&gt;<name>u_ste</name>-&gt;<name>ste_symbols</name></name></expr></argument>, <argument><expr><name>FREE</name></expr></argument>, <argument><expr><name>DEF_FREE_CLASS</name></expr></argument>,
<argument><expr><call><name>PyDict_Size</name><argument_list>(<argument><expr><name><name>u</name>-&gt;<name>u_cellvars</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name><name>u</name>-&gt;<name>u_freevars</name></name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>compiler_unit_free</name><argument_list>(<argument><expr><name>u</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>0</expr>;</return>
}</block></then></if>
<expr_stmt><expr><name><name>u</name>-&gt;<name>u_blocks</name></name> = <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>u</name>-&gt;<name>u_tmpname</name></name> = 0</expr>;</expr_stmt>
<expr_stmt><expr><name><name>u</name>-&gt;<name>u_nfblocks</name></name> = 0</expr>;</expr_stmt>
<expr_stmt><expr><name><name>u</name>-&gt;<name>u_firstlineno</name></name> = <name>lineno</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>u</name>-&gt;<name>u_lineno</name></name> = 0</expr>;</expr_stmt>
<expr_stmt><expr><name><name>u</name>-&gt;<name>u_lineno_set</name></name> = <name>false</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>u</name>-&gt;<name>u_consts</name></name> = <call><name>PyDict_New</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name><name>u</name>-&gt;<name>u_consts</name></name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>compiler_unit_free</name><argument_list>(<argument><expr><name>u</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>0</expr>;</return>
}</block></then></if>
<expr_stmt><expr><name><name>u</name>-&gt;<name>u_names</name></name> = <call><name>PyDict_New</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name><name>u</name>-&gt;<name>u_names</name></name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>compiler_unit_free</name><argument_list>(<argument><expr><name>u</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>0</expr>;</return>
}</block></then></if>
<expr_stmt><expr><name><name>u</name>-&gt;<name>u_private</name></name> = <name>NULL</name></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>c</name>-&gt;<name>u</name></name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>wrapper</name> <init>= <expr><call><name>PyCObject_FromVoidPtr</name><argument_list>(<argument><expr><name><name>c</name>-&gt;<name>u</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr>!<name>wrapper</name> || <call><name>PyList_Append</name><argument_list>(<argument><expr><name><name>c</name>-&gt;<name>c_stack</name></name></expr></argument>, <argument><expr><name>wrapper</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>wrapper</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>compiler_unit_free</name><argument_list>(<argument><expr><name>u</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>0</expr>;</return>
}</block></then></if>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>wrapper</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>u</name>-&gt;<name>u_private</name></name> = <name><name>c</name>-&gt;<name>u</name>-&gt;<name>u_private</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_XINCREF</name><argument_list>(<argument><expr><name><name>u</name>-&gt;<name>u_private</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><name><name>c</name>-&gt;<name>u</name></name> = <name>u</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>c</name>-&gt;<name>c_nestlevel</name></name>++</expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>compiler_use_new_block</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call> == <name>NULL</name></expr>)</condition><then>
<return>return <expr>0</expr>;</return></then></if>
<return>return <expr>1</expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>compiler_exit_scope</name><parameter_list>(<param><decl><type>struct <name>compiler</name> *</type><name>c</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>wrapper</name></decl>;</decl_stmt>
<expr_stmt><expr><name><name>c</name>-&gt;<name>c_nestlevel</name></name>--</expr>;</expr_stmt>
<expr_stmt><expr><call><name>compiler_unit_free</name><argument_list>(<argument><expr><name><name>c</name>-&gt;<name>u</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>n</name> = <call><name>PyList_GET_SIZE</name><argument_list>(<argument><expr><name><name>c</name>-&gt;<name>c_stack</name></name></expr></argument>)</argument_list></call> - 1</expr>;</expr_stmt>
<if>if <condition>(<expr><name>n</name> &gt;= 0</expr>)</condition><then> <block>{
<expr_stmt><expr><name>wrapper</name> = <call><name>PyList_GET_ITEM</name><argument_list>(<argument><expr><name><name>c</name>-&gt;<name>c_stack</name></name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>c</name>-&gt;<name>u</name></name> = (struct <name>compiler_unit</name> *)<call><name>PyCObject_AsVoidPtr</name><argument_list>(<argument><expr><name>wrapper</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>c</name>-&gt;<name>u</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>PySequence_DelItem</name><argument_list>(<argument><expr><name><name>c</name>-&gt;<name>c_stack</name></name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
<expr_stmt><expr><call><name>Py_FatalError</name><argument_list>(<argument><expr>"compiler_exit_scope()"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<expr_stmt><expr><call><name>compiler_unit_check</name><argument_list>(<argument><expr><name><name>c</name>-&gt;<name>u</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else
<expr_stmt><expr><name><name>c</name>-&gt;<name>u</name></name> = <name>NULL</name></expr>;</expr_stmt></else></if>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>compiler_new_tmpname</name><parameter_list>(<param><decl><type>struct <name>compiler</name> *</type><name>c</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>char</name></type> <name><name>tmpname</name><index>[<expr>256</expr>]</index></name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>PyOS_snprintf</name><argument_list>(<argument><expr><name>tmpname</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>tmpname</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr>"_[%d]"</expr></argument>, <argument><expr>++<name><name>c</name>-&gt;<name>u</name>-&gt;<name>u_tmpname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>PyString_FromString</name><argument_list>(<argument><expr><name>tmpname</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>basicblock</name> *</type>
<name>compiler_new_block</name><parameter_list>(<param><decl><type>struct <name>compiler</name> *</type><name>c</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>basicblock</name> *</type><name>b</name></decl>;</decl_stmt>
<decl_stmt><decl><type>struct <name>compiler_unit</name> *</type><name>u</name></decl>;</decl_stmt>
<expr_stmt><expr><name>u</name> = <name><name>c</name>-&gt;<name>u</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>b</name> = (<name>basicblock</name> *)<call><name>PyObject_Malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>basicblock</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>b</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_NoMemory</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr>(<name>void</name> *)<name>b</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>basicblock</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>b</name>-&gt;<name>b_list</name></name> = <name><name>u</name>-&gt;<name>u_blocks</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>u</name>-&gt;<name>u_blocks</name></name> = <name>b</name></expr>;</expr_stmt>
<return>return <expr><name>b</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>basicblock</name> *</type>
<name>compiler_use_new_block</name><parameter_list>(<param><decl><type>struct <name>compiler</name> *</type><name>c</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>basicblock</name> *</type><name>block</name> <init>= <expr><call><name>compiler_new_block</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>block</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name><name>c</name>-&gt;<name>u</name>-&gt;<name>u_curblock</name></name> = <name>block</name></expr>;</expr_stmt>
<return>return <expr><name>block</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>basicblock</name> *</type>
<name>compiler_next_block</name><parameter_list>(<param><decl><type>struct <name>compiler</name> *</type><name>c</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>basicblock</name> *</type><name>block</name> <init>= <expr><call><name>compiler_new_block</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>block</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name><name>c</name>-&gt;<name>u</name>-&gt;<name>u_curblock</name>-&gt;<name>b_next</name></name> = <name>block</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>c</name>-&gt;<name>u</name>-&gt;<name>u_curblock</name></name> = <name>block</name></expr>;</expr_stmt>
<return>return <expr><name>block</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>basicblock</name> *</type>
<name>compiler_use_next_block</name><parameter_list>(<param><decl><type>struct <name>compiler</name> *</type><name>c</name></decl></param>, <param><decl><type><name>basicblock</name> *</type><name>block</name></decl></param>)</parameter_list> <block>{
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>block</name> != <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>c</name>-&gt;<name>u</name>-&gt;<name>u_curblock</name>-&gt;<name>b_next</name></name> = <name>block</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>c</name>-&gt;<name>u</name>-&gt;<name>u_curblock</name></name> = <name>block</name></expr>;</expr_stmt>
<return>return <expr><name>block</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>compiler_next_instr</name><parameter_list>(<param><decl><type>struct <name>compiler</name> *</type><name>c</name></decl></param>, <param><decl><type><name>basicblock</name> *</type><name>b</name></decl></param>)</parameter_list> <block>{
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>b</name> != <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>b</name>-&gt;<name>b_instr</name></name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>b</name>-&gt;<name>b_instr</name></name> = (struct <name>instr</name> *)<call><name>PyObject_Malloc</name><argument_list>(
<argument><expr><sizeof>sizeof<argument_list>(<argument>struct <expr><name>instr</name></expr></argument>)</argument_list></sizeof> * <name>DEFAULT_BLOCK_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>b</name>-&gt;<name>b_instr</name></name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_NoMemory</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<return>return <expr>-1</expr>;</return>
}</block></then></if>
<expr_stmt><expr><name><name>b</name>-&gt;<name>b_ialloc</name></name> = <name>DEFAULT_BLOCK_SIZE</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr>(<name>char</name> *)<name><name>b</name>-&gt;<name>b_instr</name></name></expr></argument>, <argument><expr>0</expr></argument>,
<argument><expr><sizeof>sizeof<argument_list>(<argument>struct <expr><name>instr</name></expr></argument>)</argument_list></sizeof> * <name>DEFAULT_BLOCK_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else <if>if <condition>(<expr><name><name>b</name>-&gt;<name>b_iused</name></name> == <name><name>b</name>-&gt;<name>b_ialloc</name></name></expr>)</condition><then> <block>{
<decl_stmt><decl><type>struct <name>instr</name> *</type><name>tmp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>oldsize</name></decl>, <decl><type ref="prev"/><name>newsize</name></decl>;</decl_stmt>
<expr_stmt><expr><name>oldsize</name> = <name><name>b</name>-&gt;<name>b_ialloc</name></name> * <sizeof>sizeof<argument_list>(<argument>struct <expr><name>instr</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
<expr_stmt><expr><name>newsize</name> = <name>oldsize</name> &lt;&lt; 1</expr>;</expr_stmt>
<if>if <condition>(<expr><name>oldsize</name> &gt; (<name>PY_SIZE_MAX</name> &gt;&gt; 1)</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_NoMemory</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<return>return <expr>-1</expr>;</return>
}</block></then></if>
<if>if <condition>(<expr><name>newsize</name> == 0</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_NoMemory</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<return>return <expr>-1</expr>;</return>
}</block></then></if>
<expr_stmt><expr><name><name>b</name>-&gt;<name>b_ialloc</name></name> &lt;&lt;= 1</expr>;</expr_stmt>
<expr_stmt><expr><name>tmp</name> = (struct <name>instr</name> *)<call><name>PyObject_Realloc</name><argument_list>(
<argument><expr>(<name>void</name> *)<name><name>b</name>-&gt;<name>b_instr</name></name></expr></argument>, <argument><expr><name>newsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>tmp</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_NoMemory</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<return>return <expr>-1</expr>;</return>
}</block></then></if>
<expr_stmt><expr><name><name>b</name>-&gt;<name>b_instr</name></name> = <name>tmp</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr>(<name>char</name> *)<name><name>b</name>-&gt;<name>b_instr</name></name> + <name>oldsize</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>newsize</name> - <name>oldsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if></else></if>
<return>return <expr><name><name>b</name>-&gt;<name>b_iused</name></name>++</expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>compiler_set_lineno</name><parameter_list>(<param><decl><type>struct <name>compiler</name> *</type><name>c</name></decl></param>, <param><decl><type><name>int</name></type> <name>off</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>basicblock</name> *</type><name>b</name></decl>;</decl_stmt>
<if>if <condition>(<expr><name><name>c</name>-&gt;<name>u</name>-&gt;<name>u_lineno_set</name></name></expr>)</condition><then>
<return>return;</return></then></if>
<expr_stmt><expr><name><name>c</name>-&gt;<name>u</name>-&gt;<name>u_lineno_set</name></name> = <name>true</name></expr>;</expr_stmt>
<expr_stmt><expr><name>b</name> = <name><name>c</name>-&gt;<name>u</name>-&gt;<name>u_curblock</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>b</name>-&gt;<name>b_instr</name><index>[<expr><name>off</name></expr>]</index></name>.<name>i_lineno</name> = <name><name>c</name>-&gt;<name>u</name>-&gt;<name>u_lineno</name></name></expr>;</expr_stmt>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>opcode_stack_effect</name><parameter_list>(<param><decl><type><name>int</name></type> <name>opcode</name></decl></param>, <param><decl><type><name>int</name></type> <name>oparg</name></decl></param>)</parameter_list> <block>{
<switch>switch <condition>(<expr><name>opcode</name></expr>)</condition> <block>{
<case>case <expr><name>POP_TOP</name></expr>:
<return>return <expr>-1</expr>;</return>
</case><case>case <expr><name>ROT_TWO</name></expr>:
</case><case>case <expr><name>ROT_THREE</name></expr>:
<return>return <expr>0</expr>;</return>
</case><case>case <expr><name>DUP_TOP</name></expr>:
<return>return <expr>1</expr>;</return>
</case><case>case <expr><name>ROT_FOUR</name></expr>:
<return>return <expr>0</expr>;</return>
</case><case>case <expr><name>UNARY_POSITIVE</name></expr>:
</case><case>case <expr><name>UNARY_NEGATIVE</name></expr>:
</case><case>case <expr><name>UNARY_NOT</name></expr>:
</case><case>case <expr><name>UNARY_CONVERT</name></expr>:
</case><case>case <expr><name>UNARY_INVERT</name></expr>:
<return>return <expr>0</expr>;</return>
</case><case>case <expr><name>LIST_APPEND</name></expr>:
<return>return <expr>-2</expr>;</return>
</case><case>case <expr><name>BINARY_POWER</name></expr>:
</case><case>case <expr><name>BINARY_MULTIPLY</name></expr>:
</case><case>case <expr><name>BINARY_DIVIDE</name></expr>:
</case><case>case <expr><name>BINARY_MODULO</name></expr>:
</case><case>case <expr><name>BINARY_ADD</name></expr>:
</case><case>case <expr><name>BINARY_SUBTRACT</name></expr>:
</case><case>case <expr><name>BINARY_SUBSCR</name></expr>:
</case><case>case <expr><name>BINARY_FLOOR_DIVIDE</name></expr>:
</case><case>case <expr><name>BINARY_TRUE_DIVIDE</name></expr>:
<return>return <expr>-1</expr>;</return>
</case><case>case <expr><name>INPLACE_FLOOR_DIVIDE</name></expr>:
</case><case>case <expr><name>INPLACE_TRUE_DIVIDE</name></expr>:
<return>return <expr>-1</expr>;</return>
</case><case>case <expr><name>SLICE</name>+0</expr>:
<return>return <expr>1</expr>;</return>
</case><case>case <expr><name>SLICE</name>+1</expr>:
<return>return <expr>0</expr>;</return>
</case><case>case <expr><name>SLICE</name>+2</expr>:
<return>return <expr>0</expr>;</return>
</case><case>case <expr><name>SLICE</name>+3</expr>:
<return>return <expr>-1</expr>;</return>
</case><case>case <expr><name>STORE_SLICE</name>+0</expr>:
<return>return <expr>-2</expr>;</return>
</case><case>case <expr><name>STORE_SLICE</name>+1</expr>:
<return>return <expr>-3</expr>;</return>
</case><case>case <expr><name>STORE_SLICE</name>+2</expr>:
<return>return <expr>-3</expr>;</return>
</case><case>case <expr><name>STORE_SLICE</name>+3</expr>:
<return>return <expr>-4</expr>;</return>
</case><case>case <expr><name>DELETE_SLICE</name>+0</expr>:
<return>return <expr>-1</expr>;</return>
</case><case>case <expr><name>DELETE_SLICE</name>+1</expr>:
<return>return <expr>-2</expr>;</return>
</case><case>case <expr><name>DELETE_SLICE</name>+2</expr>:
<return>return <expr>-2</expr>;</return>
</case><case>case <expr><name>DELETE_SLICE</name>+3</expr>:
<return>return <expr>-3</expr>;</return>
</case><case>case <expr><name>INPLACE_ADD</name></expr>:
</case><case>case <expr><name>INPLACE_SUBTRACT</name></expr>:
</case><case>case <expr><name>INPLACE_MULTIPLY</name></expr>:
</case><case>case <expr><name>INPLACE_DIVIDE</name></expr>:
</case><case>case <expr><name>INPLACE_MODULO</name></expr>:
<return>return <expr>-1</expr>;</return>
</case><case>case <expr><name>STORE_SUBSCR</name></expr>:
<return>return <expr>-3</expr>;</return>
</case><case>case <expr><name>STORE_MAP</name></expr>:
<return>return <expr>-2</expr>;</return>
</case><case>case <expr><name>DELETE_SUBSCR</name></expr>:
<return>return <expr>-2</expr>;</return>
</case><case>case <expr><name>BINARY_LSHIFT</name></expr>:
</case><case>case <expr><name>BINARY_RSHIFT</name></expr>:
</case><case>case <expr><name>BINARY_AND</name></expr>:
</case><case>case <expr><name>BINARY_XOR</name></expr>:
</case><case>case <expr><name>BINARY_OR</name></expr>:
<return>return <expr>-1</expr>;</return>
</case><case>case <expr><name>INPLACE_POWER</name></expr>:
<return>return <expr>-1</expr>;</return>
</case><case>case <expr><name>GET_ITER</name></expr>:
<return>return <expr>0</expr>;</return>
</case><case>case <expr><name>PRINT_EXPR</name></expr>:
<return>return <expr>-1</expr>;</return>
</case><case>case <expr><name>PRINT_ITEM</name></expr>:
<return>return <expr>-1</expr>;</return>
</case><case>case <expr><name>PRINT_NEWLINE</name></expr>:
<return>return <expr>0</expr>;</return>
</case><case>case <expr><name>PRINT_ITEM_TO</name></expr>:
<return>return <expr>-2</expr>;</return>
</case><case>case <expr><name>PRINT_NEWLINE_TO</name></expr>:
<return>return <expr>-1</expr>;</return>
</case><case>case <expr><name>INPLACE_LSHIFT</name></expr>:
</case><case>case <expr><name>INPLACE_RSHIFT</name></expr>:
</case><case>case <expr><name>INPLACE_AND</name></expr>:
</case><case>case <expr><name>INPLACE_XOR</name></expr>:
</case><case>case <expr><name>INPLACE_OR</name></expr>:
<return>return <expr>-1</expr>;</return>
</case><case>case <expr><name>BREAK_LOOP</name></expr>:
<return>return <expr>0</expr>;</return>
</case><case>case <expr><name>WITH_CLEANUP</name></expr>:
<return>return <expr>-1</expr>;</return>
</case><case>case <expr><name>LOAD_LOCALS</name></expr>:
<return>return <expr>1</expr>;</return>
</case><case>case <expr><name>RETURN_VALUE</name></expr>:
<return>return <expr>-1</expr>;</return>
</case><case>case <expr><name>IMPORT_STAR</name></expr>:
<return>return <expr>-1</expr>;</return>
</case><case>case <expr><name>EXEC_STMT</name></expr>:
<return>return <expr>-3</expr>;</return>
</case><case>case <expr><name>YIELD_VALUE</name></expr>:
<return>return <expr>0</expr>;</return>
</case><case>case <expr><name>POP_BLOCK</name></expr>:
<return>return <expr>0</expr>;</return>
</case><case>case <expr><name>END_FINALLY</name></expr>:
<return>return <expr>-1</expr>;</return>
</case><case>case <expr><name>BUILD_CLASS</name></expr>:
<return>return <expr>-2</expr>;</return>
</case><case>case <expr><name>STORE_NAME</name></expr>:
<return>return <expr>-1</expr>;</return>
</case><case>case <expr><name>DELETE_NAME</name></expr>:
<return>return <expr>0</expr>;</return>
</case><case>case <expr><name>UNPACK_SEQUENCE</name></expr>:
<return>return <expr><name>oparg</name>-1</expr>;</return>
</case><case>case <expr><name>FOR_ITER</name></expr>:
<return>return <expr>1</expr>;</return>
</case><case>case <expr><name>STORE_ATTR</name></expr>:
<return>return <expr>-2</expr>;</return>
</case><case>case <expr><name>DELETE_ATTR</name></expr>:
<return>return <expr>-1</expr>;</return>
</case><case>case <expr><name>STORE_GLOBAL</name></expr>:
<return>return <expr>-1</expr>;</return>
</case><case>case <expr><name>DELETE_GLOBAL</name></expr>:
<return>return <expr>0</expr>;</return>
</case><case>case <expr><name>DUP_TOPX</name></expr>:
<return>return <expr><name>oparg</name></expr>;</return>
</case><case>case <expr><name>LOAD_CONST</name></expr>:
<return>return <expr>1</expr>;</return>
</case><case>case <expr><name>LOAD_NAME</name></expr>:
<return>return <expr>1</expr>;</return>
</case><case>case <expr><name>BUILD_TUPLE</name></expr>:
</case><case>case <expr><name>BUILD_LIST</name></expr>:
<return>return <expr>1-<name>oparg</name></expr>;</return>
</case><case>case <expr><name>BUILD_MAP</name></expr>:
<return>return <expr>1</expr>;</return>
</case><case>case <expr><name>LOAD_ATTR</name></expr>:
<return>return <expr>0</expr>;</return>
</case><case>case <expr><name>COMPARE_OP</name></expr>:
<return>return <expr>-1</expr>;</return>
</case><case>case <expr><name>IMPORT_NAME</name></expr>:
<return>return <expr>0</expr>;</return>
</case><case>case <expr><name>IMPORT_FROM</name></expr>:
<return>return <expr>1</expr>;</return>
</case><case>case <expr><name>JUMP_FORWARD</name></expr>:
</case><case>case <expr><name>JUMP_IF_FALSE</name></expr>:
</case><case>case <expr><name>JUMP_IF_TRUE</name></expr>:
</case><case>case <expr><name>JUMP_ABSOLUTE</name></expr>:
<return>return <expr>0</expr>;</return>
</case><case>case <expr><name>LOAD_GLOBAL</name></expr>:
<return>return <expr>1</expr>;</return>
</case><case>case <expr><name>CONTINUE_LOOP</name></expr>:
<return>return <expr>0</expr>;</return>
</case><case>case <expr><name>SETUP_LOOP</name></expr>:
<return>return <expr>0</expr>;</return>
</case><case>case <expr><name>SETUP_EXCEPT</name></expr>:
</case><case>case <expr><name>SETUP_FINALLY</name></expr>:
<return>return <expr>3</expr>;</return>
</case><case>case <expr><name>LOAD_FAST</name></expr>:
<return>return <expr>1</expr>;</return>
</case><case>case <expr><name>STORE_FAST</name></expr>:
<return>return <expr>-1</expr>;</return>
</case><case>case <expr><name>DELETE_FAST</name></expr>:
<return>return <expr>0</expr>;</return>
</case><case>case <expr><name>RAISE_VARARGS</name></expr>:
<return>return <expr>-<name>oparg</name></expr>;</return>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NARGS</name><parameter_list>(<param><type><name>o</name></type></param>)</parameter_list></cpp:macro> <cpp:value>(((o) % 256) + 2*((o) / 256))</cpp:value></cpp:define>
</case><case>case <expr><name>CALL_FUNCTION</name></expr>:
<return>return <expr>-<call><name>NARGS</name><argument_list>(<argument><expr><name>oparg</name></expr></argument>)</argument_list></call></expr>;</return>
</case><case>case <expr><name>CALL_FUNCTION_VAR</name></expr>:
</case><case>case <expr><name>CALL_FUNCTION_KW</name></expr>:
<return>return <expr>-<call><name>NARGS</name><argument_list>(<argument><expr><name>oparg</name></expr></argument>)</argument_list></call>-1</expr>;</return>
</case><case>case <expr><name>CALL_FUNCTION_VAR_KW</name></expr>:
<return>return <expr>-<call><name>NARGS</name><argument_list>(<argument><expr><name>oparg</name></expr></argument>)</argument_list></call>-2</expr>;</return>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>NARGS</name></cpp:undef>
</case><case>case <expr><name>MAKE_FUNCTION</name></expr>:
<return>return <expr>-<name>oparg</name></expr>;</return>
</case><case>case <expr><name>BUILD_SLICE</name></expr>:
<if>if <condition>(<expr><name>oparg</name> == 3</expr>)</condition><then>
<return>return <expr>-2</expr>;</return></then>
<else>else
<return>return <expr>-1</expr>;</return></else></if>
</case><case>case <expr><name>MAKE_CLOSURE</name></expr>:
<return>return <expr>-<name>oparg</name></expr>;</return>
</case><case>case <expr><name>LOAD_CLOSURE</name></expr>:
<return>return <expr>1</expr>;</return>
</case><case>case <expr><name>LOAD_DEREF</name></expr>:
<return>return <expr>1</expr>;</return>
</case><case>case <expr><name>STORE_DEREF</name></expr>:
<return>return <expr>-1</expr>;</return>
</case><default>default:
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr>"opcode = %d\n"</expr></argument>, <argument><expr><name>opcode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_FatalError</name><argument_list>(<argument><expr>"opcode_stack_effect()"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
</default>}</block></switch>
<return>return <expr>0</expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>compiler_addop</name><parameter_list>(<param><decl><type>struct <name>compiler</name> *</type><name>c</name></decl></param>, <param><decl><type><name>int</name></type> <name>opcode</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>basicblock</name> *</type><name>b</name></decl>;</decl_stmt>
<decl_stmt><decl><type>struct <name>instr</name> *</type><name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>off</name></decl>;</decl_stmt>
<expr_stmt><expr><name>off</name> = <call><name>compiler_next_instr</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name><name>c</name>-&gt;<name>u</name>-&gt;<name>u_curblock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>off</name> &lt; 0</expr>)</condition><then>
<return>return <expr>0</expr>;</return></then></if>
<expr_stmt><expr><name>b</name> = <name><name>c</name>-&gt;<name>u</name>-&gt;<name>u_curblock</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>i</name> = &amp;<name><name>b</name>-&gt;<name>b_instr</name><index>[<expr><name>off</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>i</name>-&gt;<name>i_opcode</name></name> = <name>opcode</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>i</name>-&gt;<name>i_hasarg</name></name> = 0</expr>;</expr_stmt>
<if>if <condition>(<expr><name>opcode</name> == <name>RETURN_VALUE</name></expr>)</condition><then>
<expr_stmt><expr><name><name>b</name>-&gt;<name>b_return</name></name> = 1</expr>;</expr_stmt></then></if>
<expr_stmt><expr><call><name>compiler_set_lineno</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>off</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>1</expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>compiler_add_o</name><parameter_list>(<param><decl><type>struct <name>compiler</name> *</type><name>c</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>dict</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>o</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>t</name></decl>, *<decl><type ref="prev"/><name>v</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>arg</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name> *</type><name>p</name></decl>, *<decl><type ref="prev"/><name>q</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_complex</name></type> <name>z</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>double</name></type> <name>d</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>real_part_zero</name></decl>, <decl><type ref="prev"/><name>imag_part_zero</name></decl>;</decl_stmt>
<if>if <condition>(<expr><call><name>PyFloat_Check</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><name>d</name> = <call><name>PyFloat_AS_DOUBLE</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>p</name> = (<name>unsigned</name> <name>char</name>*) &amp;<name>d</name></expr>;</expr_stmt>
<if>if <condition>(<expr>*<name>p</name>==0 &amp;&amp; <name><name>p</name><index>[<expr><sizeof>sizeof<argument_list>(<argument><expr><name>double</name></expr></argument>)</argument_list></sizeof>-1</expr>]</index></name>==0</expr>)</condition><then>
<expr_stmt><expr><name>t</name> = <call><name>PyTuple_Pack</name><argument_list>(<argument><expr>3</expr></argument>, <argument><expr><name>o</name></expr></argument>, <argument><expr><name><name>o</name>-&gt;<name>ob_type</name></name></expr></argument>, <argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
<else>else
<expr_stmt><expr><name>t</name> = <call><name>PyTuple_Pack</name><argument_list>(<argument><expr>2</expr></argument>, <argument><expr><name>o</name></expr></argument>, <argument><expr><name><name>o</name>-&gt;<name>ob_type</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
}</block></then> <else>else <if>if <condition>(<expr><call><name>PyComplex_Check</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><name>z</name> = <call><name>PyComplex_AsCComplex</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>p</name> = (<name>unsigned</name> <name>char</name>*) &amp;(<name><name>z</name>.<name>real</name></name>)</expr>;</expr_stmt>
<expr_stmt><expr><name>q</name> = (<name>unsigned</name> <name>char</name>*) &amp;(<name><name>z</name>.<name>imag</name></name>)</expr>;</expr_stmt>
<expr_stmt><expr><name>real_part_zero</name> = *<name>p</name>==0 &amp;&amp; <name><name>p</name><index>[<expr><sizeof>sizeof<argument_list>(<argument><expr><name>double</name></expr></argument>)</argument_list></sizeof>-1</expr>]</index></name>==0</expr>;</expr_stmt>
<expr_stmt><expr><name>imag_part_zero</name> = *<name>q</name>==0 &amp;&amp; <name><name>q</name><index>[<expr><sizeof>sizeof<argument_list>(<argument><expr><name>double</name></expr></argument>)</argument_list></sizeof>-1</expr>]</index></name>==0</expr>;</expr_stmt>
<if>if <condition>(<expr><name>real_part_zero</name> &amp;&amp; <name>imag_part_zero</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>t</name> = <call><name>PyTuple_Pack</name><argument_list>(<argument><expr>4</expr></argument>, <argument><expr><name>o</name></expr></argument>, <argument><expr><name><name>o</name>-&gt;<name>ob_type</name></name></expr></argument>, <argument><expr><name>Py_True</name></expr></argument>, <argument><expr><name>Py_True</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else <if>if <condition>(<expr><name>real_part_zero</name> &amp;&amp; !<name>imag_part_zero</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>t</name> = <call><name>PyTuple_Pack</name><argument_list>(<argument><expr>4</expr></argument>, <argument><expr><name>o</name></expr></argument>, <argument><expr><name><name>o</name>-&gt;<name>ob_type</name></name></expr></argument>, <argument><expr><name>Py_True</name></expr></argument>, <argument><expr><name>Py_False</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else <if>if <condition>(<expr>!<name>real_part_zero</name> &amp;&amp; <name>imag_part_zero</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>t</name> = <call><name>PyTuple_Pack</name><argument_list>(<argument><expr>4</expr></argument>, <argument><expr><name>o</name></expr></argument>, <argument><expr><name><name>o</name>-&gt;<name>ob_type</name></name></expr></argument>, <argument><expr><name>Py_False</name></expr></argument>, <argument><expr><name>Py_True</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr><name>t</name> = <call><name>PyTuple_Pack</name><argument_list>(<argument><expr>2</expr></argument>, <argument><expr><name>o</name></expr></argument>, <argument><expr><name><name>o</name>-&gt;<name>ob_type</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></else></if></else></if></else></if>
}</block></then> <else>else <block>{
<expr_stmt><expr><name>t</name> = <call><name>PyTuple_Pack</name><argument_list>(<argument><expr>2</expr></argument>, <argument><expr><name>o</name></expr></argument>, <argument><expr><name><name>o</name>-&gt;<name>ob_type</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></else></if></else></if>
<if>if <condition>(<expr><name>t</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr>-1</expr>;</return></then></if>
<expr_stmt><expr><name>v</name> = <call><name>PyDict_GetItem</name><argument_list>(<argument><expr><name>dict</name></expr></argument>, <argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>v</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>arg</name> = <call><name>PyDict_Size</name><argument_list>(<argument><expr><name>dict</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>v</name> = <call><name>PyInt_FromLong</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>v</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>-1</expr>;</return>
}</block></then></if>
<if>if <condition>(<expr><call><name>PyDict_SetItem</name><argument_list>(<argument><expr><name>dict</name></expr></argument>, <argument><expr><name>t</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>-1</expr>;</return>
}</block></then></if>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else
<expr_stmt><expr><name>arg</name> = <call><name>PyInt_AsLong</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>arg</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>compiler_addop_o</name><parameter_list>(<param><decl><type>struct <name>compiler</name> *</type><name>c</name></decl></param>, <param><decl><type><name>int</name></type> <name>opcode</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>dict</name></decl></param>,
<param><decl><type><name>PyObject</name> *</type><name>o</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>arg</name> <init>= <expr><call><name>compiler_add_o</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>dict</name></expr></argument>, <argument><expr><name>o</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>arg</name> &lt; 0</expr>)</condition><then>
<return>return <expr>0</expr>;</return></then></if>
<return>return <expr><call><name>compiler_addop_i</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>opcode</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>compiler_addop_name</name><parameter_list>(<param><decl><type>struct <name>compiler</name> *</type><name>c</name></decl></param>, <param><decl><type><name>int</name></type> <name>opcode</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>dict</name></decl></param>,
<param><decl><type><name>PyObject</name> *</type><name>o</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>arg</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>mangled</name> <init>= <expr><call><name>_Py_Mangle</name><argument_list>(<argument><expr><name><name>c</name>-&gt;<name>u</name>-&gt;<name>u_private</name></name></expr></argument>, <argument><expr><name>o</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr>!<name>mangled</name></expr>)</condition><then>
<return>return <expr>0</expr>;</return></then></if>
<expr_stmt><expr><name>arg</name> = <call><name>compiler_add_o</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>dict</name></expr></argument>, <argument><expr><name>mangled</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>mangled</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>arg</name> &lt; 0</expr>)</condition><then>
<return>return <expr>0</expr>;</return></then></if>
<return>return <expr><call><name>compiler_addop_i</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>opcode</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>compiler_addop_i</name><parameter_list>(<param><decl><type>struct <name>compiler</name> *</type><name>c</name></decl></param>, <param><decl><type><name>int</name></type> <name>opcode</name></decl></param>, <param><decl><type><name>int</name></type> <name>oparg</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type>struct <name>instr</name> *</type><name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>off</name></decl>;</decl_stmt>
<expr_stmt><expr><name>off</name> = <call><name>compiler_next_instr</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name><name>c</name>-&gt;<name>u</name>-&gt;<name>u_curblock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>off</name> &lt; 0</expr>)</condition><then>
<return>return <expr>0</expr>;</return></then></if>
<expr_stmt><expr><name>i</name> = &amp;<name><name>c</name>-&gt;<name>u</name>-&gt;<name>u_curblock</name>-&gt;<name>b_instr</name><index>[<expr><name>off</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>i</name>-&gt;<name>i_opcode</name></name> = <name>opcode</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>i</name>-&gt;<name>i_oparg</name></name> = <name>oparg</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>i</name>-&gt;<name>i_hasarg</name></name> = 1</expr>;</expr_stmt>
<expr_stmt><expr><call><name>compiler_set_lineno</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>off</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>1</expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>compiler_addop_j</name><parameter_list>(<param><decl><type>struct <name>compiler</name> *</type><name>c</name></decl></param>, <param><decl><type><name>int</name></type> <name>opcode</name></decl></param>, <param><decl><type><name>basicblock</name> *</type><name>b</name></decl></param>, <param><decl><type><name>int</name></type> <name>absolute</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type>struct <name>instr</name> *</type><name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>off</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>b</name> != <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>off</name> = <call><name>compiler_next_instr</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name><name>c</name>-&gt;<name>u</name>-&gt;<name>u_curblock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>off</name> &lt; 0</expr>)</condition><then>
<return>return <expr>0</expr>;</return></then></if>
<expr_stmt><expr><name>i</name> = &amp;<name><name>c</name>-&gt;<name>u</name>-&gt;<name>u_curblock</name>-&gt;<name>b_instr</name><index>[<expr><name>off</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>i</name>-&gt;<name>i_opcode</name></name> = <name>opcode</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>i</name>-&gt;<name>i_target</name></name> = <name>b</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>i</name>-&gt;<name>i_hasarg</name></name> = 1</expr>;</expr_stmt>
<if>if <condition>(<expr><name>absolute</name></expr>)</condition><then>
<expr_stmt><expr><name><name>i</name>-&gt;<name>i_jabs</name></name> = 1</expr>;</expr_stmt></then>
<else>else
<expr_stmt><expr><name><name>i</name>-&gt;<name>i_jrel</name></name> = 1</expr>;</expr_stmt></else></if>
<expr_stmt><expr><call><name>compiler_set_lineno</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>off</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>1</expr>;</return>
}</block></function>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NEW_BLOCK</name><parameter_list>(<param><type><name>C</name></type></param>)</parameter_list></cpp:macro> <cpp:value>{ if (compiler_use_new_block((C)) == NULL) return 0; }</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NEXT_BLOCK</name><parameter_list>(<param><type><name>C</name></type></param>)</parameter_list></cpp:macro> <cpp:value>{ if (compiler_next_block((C)) == NULL) return 0; }</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ADDOP</name><parameter_list>(<param><type><name>C</name></type></param>, <param><type><name>OP</name></type></param>)</parameter_list></cpp:macro> <cpp:value>{ if (!compiler_addop((C), (OP))) return 0; }</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ADDOP_IN_SCOPE</name><parameter_list>(<param><type><name>C</name></type></param>, <param><type><name>OP</name></type></param>)</parameter_list></cpp:macro> <cpp:value>{ if (!compiler_addop((C), (OP))) { compiler_exit_scope(c); return 0; } }</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ADDOP_O</name><parameter_list>(<param><type><name>C</name></type></param>, <param><type><name>OP</name></type></param>, <param><type><name>O</name></type></param>, <param><type><name>TYPE</name></type></param>)</parameter_list></cpp:macro> <cpp:value>{ if (!compiler_addop_o((C), (OP), (C)-&gt;u-&gt;u_ ##TYPE, (O))) return 0; }</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ADDOP_NAME</name><parameter_list>(<param><type><name>C</name></type></param>, <param><type><name>OP</name></type></param>, <param><type><name>O</name></type></param>, <param><type><name>TYPE</name></type></param>)</parameter_list></cpp:macro> <cpp:value>{ if (!compiler_addop_name((C), (OP), (C)-&gt;u-&gt;u_ ##TYPE, (O))) return 0; }</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ADDOP_I</name><parameter_list>(<param><type><name>C</name></type></param>, <param><type><name>OP</name></type></param>, <param><type><name>O</name></type></param>)</parameter_list></cpp:macro> <cpp:value>{ if (!compiler_addop_i((C), (OP), (O))) return 0; }</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ADDOP_JABS</name><parameter_list>(<param><type><name>C</name></type></param>, <param><type><name>OP</name></type></param>, <param><type><name>O</name></type></param>)</parameter_list></cpp:macro> <cpp:value>{ if (!compiler_addop_j((C), (OP), (O), 1)) return 0; }</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ADDOP_JREL</name><parameter_list>(<param><type><name>C</name></type></param>, <param><type><name>OP</name></type></param>, <param><type><name>O</name></type></param>)</parameter_list></cpp:macro> <cpp:value>{ if (!compiler_addop_j((C), (OP), (O), 0)) return 0; }</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>VISIT</name><parameter_list>(<param><type><name>C</name></type></param>, <param><type><name>TYPE</name></type></param>, <param><type><name>V</name></type></param>)</parameter_list></cpp:macro> <cpp:value>{if (!compiler_visit_ ##TYPE((C), (V))) return 0; }</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>VISIT_IN_SCOPE</name><parameter_list>(<param><type><name>C</name></type></param>, <param><type><name>TYPE</name></type></param>, <param><type><name>V</name></type></param>)</parameter_list></cpp:macro> <cpp:value>{if (!compiler_visit_ ##TYPE((C), (V))) { compiler_exit_scope(c); return 0; } }</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>VISIT_SLICE</name><parameter_list>(<param><type><name>C</name></type></param>, <param><type><name>V</name></type></param>, <param><type><name>CTX</name></type></param>)</parameter_list></cpp:macro> <cpp:value>{if (!compiler_visit_slice((C), (V), (CTX))) return 0; }</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>VISIT_SEQ</name><parameter_list>(<param><type><name>C</name></type></param>, <param><type><name>TYPE</name></type></param>, <param><type><name>SEQ</name></type></param>)</parameter_list></cpp:macro> <cpp:value>{ int _i; asdl_seq *seq = (SEQ); for (_i = 0; _i &lt; asdl_seq_LEN(seq); _i++) { TYPE ##_ty elt = (TYPE ##_ty)asdl_seq_GET(seq, _i); if (!compiler_visit_ ##TYPE((C), elt)) return 0; } }</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>VISIT_SEQ_IN_SCOPE</name><parameter_list>(<param><type><name>C</name></type></param>, <param><type><name>TYPE</name></type></param>, <param><type><name>SEQ</name></type></param>)</parameter_list></cpp:macro> <cpp:value>{ int _i; asdl_seq *seq = (SEQ); for (_i = 0; _i &lt; asdl_seq_LEN(seq); _i++) { TYPE ##_ty elt = (TYPE ##_ty)asdl_seq_GET(seq, _i); if (!compiler_visit_ ##TYPE((C), elt)) { compiler_exit_scope(c); return 0; } } }</cpp:value></cpp:define>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>compiler_isdocstring</name><parameter_list>(<param><decl><type><name>stmt_ty</name></type> <name>s</name></decl></param>)</parameter_list> <block>{
<if>if <condition>(<expr><name><name>s</name>-&gt;<name>kind</name></name> != <name>Expr_kind</name></expr>)</condition><then>
<return>return <expr>0</expr>;</return></then></if>
<return>return <expr><name><name>s</name>-&gt;<name>v</name>.<name>Expr</name>.<name>value</name>-&gt;<name>kind</name></name> == <name>Str_kind</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>compiler_body</name><parameter_list>(<param><decl><type>struct <name>compiler</name> *</type><name>c</name></decl></param>, <param><decl><type><name>asdl_seq</name> *</type><name>stmts</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>stmt_ty</name></type> <name>st</name></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>asdl_seq_LEN</name><argument_list>(<argument><expr><name>stmts</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr>1</expr>;</return></then></if>
<expr_stmt><expr><name>st</name> = (<name>stmt_ty</name>)<call><name>asdl_seq_GET</name><argument_list>(<argument><expr><name>stmts</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>compiler_isdocstring</name><argument_list>(<argument><expr><name>st</name></expr></argument>)</argument_list></call> &amp;&amp; <name>Py_OptimizeFlag</name> &lt; 2</expr>)</condition><then> <block>{
<expr_stmt><expr><name>i</name> = 1</expr>;</expr_stmt>
<expr_stmt><expr><call><name>VISIT</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>, <argument><expr><name><name>st</name>-&gt;<name>v</name>.<name>Expr</name>.<name>value</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<call><name>compiler_nameop</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>__doc__</name></expr></argument>, <argument><expr><name>Store</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr>0</expr>;</return></then></if>
}</block></then></if>
<for>for (<init>;</init> <condition><expr><name>i</name> &lt; <call><name>asdl_seq_LEN</name><argument_list>(<argument><expr><name>stmts</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
<expr_stmt><expr><call><name>VISIT</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>stmt</name></expr></argument>, <argument><expr>(<name>stmt_ty</name>)<call><name>asdl_seq_GET</name><argument_list>(<argument><expr><name>stmts</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></for>
<return>return <expr>1</expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>PyCodeObject</name> *</type>
<name>compiler_mod</name><parameter_list>(<param><decl><type>struct <name>compiler</name> *</type><name>c</name></decl></param>, <param><decl><type><name>mod_ty</name></type> <name>mod</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyCodeObject</name> *</type><name>co</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>addNone</name> <init>= <expr>1</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>PyObject</name> *</type><name>module</name></decl>;</decl_stmt>
<if>if <condition>(<expr>!<name>module</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>module</name> = <call><name>PyString_InternFromString</name><argument_list>(<argument><expr>"&lt;module&gt;"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>module</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
}</block></then></if>
<if>if <condition>(<expr>!<call><name>compiler_enter_scope</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>module</name></expr></argument>, <argument><expr><name>mod</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<switch>switch <condition>(<expr><name><name>mod</name>-&gt;<name>kind</name></name></expr>)</condition> <block>{
<case>case <expr><name>Module_kind</name></expr>:
<if>if <condition>(<expr>!<call><name>compiler_body</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name><name>mod</name>-&gt;<name>v</name>.<name>Module</name>.<name>body</name></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>compiler_exit_scope</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>0</expr>;</return>
}</block></then></if>
<break>break;</break>
</case><case>case <expr><name>Interactive_kind</name></expr>:
<expr_stmt><expr><name><name>c</name>-&gt;<name>c_interactive</name></name> = 1</expr>;</expr_stmt>
<expr_stmt><expr><call><name>VISIT_SEQ_IN_SCOPE</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>stmt</name></expr></argument>,
<argument><expr><name><name>mod</name>-&gt;<name>v</name>.<name>Interactive</name>.<name>body</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr><name>Expression_kind</name></expr>:
<expr_stmt><expr><call><name>VISIT_IN_SCOPE</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>, <argument><expr><name><name>mod</name>-&gt;<name>v</name>.<name>Expression</name>.<name>body</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>addNone</name> = 0</expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr><name>Suite_kind</name></expr>:
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_SystemError</name></expr></argument>,
<argument><expr>"suite should not be possible"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>0</expr>;</return>
</case><default>default:
<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_SystemError</name></expr></argument>,
<argument><expr>"module kind %d should not be possible"</expr></argument>,
<argument><expr><name><name>mod</name>-&gt;<name>kind</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>0</expr>;</return>
</default>}</block></switch>
<expr_stmt><expr><name>co</name> = <call><name>assemble</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>addNone</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>compiler_exit_scope</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>co</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>get_ref_type</name><parameter_list>(<param><decl><type>struct <name>compiler</name> *</type><name>c</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>name</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>scope</name> <init>= <expr><call><name>PyST_GetScope</name><argument_list>(<argument><expr><name><name>c</name>-&gt;<name>u</name>-&gt;<name>u_ste</name></name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>scope</name> == 0</expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>char</name></type> <name><name>buf</name><index>[<expr>350</expr>]</index></name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>PyOS_snprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>,
<argument><expr>"unknown scope for %.100s in %.100s(%s) in %s\n"
"symbols: %s\nlocals: %s\nglobals: %s\n"</expr></argument>,
<argument><expr><call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name><name>c</name>-&gt;<name>u</name>-&gt;<name>u_name</name></name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name>PyObject_REPR</name><argument_list>(<argument><expr><name><name>c</name>-&gt;<name>u</name>-&gt;<name>u_ste</name>-&gt;<name>ste_id</name></name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name><name>c</name>-&gt;<name>c_filename</name></name></expr></argument>,
<argument><expr><call><name>PyObject_REPR</name><argument_list>(<argument><expr><name><name>c</name>-&gt;<name>u</name>-&gt;<name>u_ste</name>-&gt;<name>ste_symbols</name></name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name>PyObject_REPR</name><argument_list>(<argument><expr><name><name>c</name>-&gt;<name>u</name>-&gt;<name>u_varnames</name></name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name>PyObject_REPR</name><argument_list>(<argument><expr><name><name>c</name>-&gt;<name>u</name>-&gt;<name>u_names</name></name></expr></argument>)</argument_list></call></expr></argument>
)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_FatalError</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<return>return <expr><name>scope</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>compiler_lookup_arg</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>dict</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>name</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>k</name></decl>, *<decl><type ref="prev"/><name>v</name></decl>;</decl_stmt>
<expr_stmt><expr><name>k</name> = <call><name>PyTuple_Pack</name><argument_list>(<argument><expr>2</expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name><name>name</name>-&gt;<name>ob_type</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>k</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr>-1</expr>;</return></then></if>
<expr_stmt><expr><name>v</name> = <call><name>PyDict_GetItem</name><argument_list>(<argument><expr><name>dict</name></expr></argument>, <argument><expr><name>k</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>k</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>v</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr>-1</expr>;</return></then></if>
<return>return <expr><call><name>PyInt_AS_LONG</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>compiler_make_closure</name><parameter_list>(<param><decl><type>struct <name>compiler</name> *</type><name>c</name></decl></param>, <param><decl><type><name>PyCodeObject</name> *</type><name>co</name></decl></param>, <param><decl><type><name>int</name></type> <name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>free</name> <init>= <expr><call><name>PyCode_GetNumFree</name><argument_list>(<argument><expr><name>co</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>free</name> == 0</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>ADDOP_O</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>LOAD_CONST</name></expr></argument>, <argument><expr>(<name>PyObject</name>*)<name>co</name></expr></argument>, <argument><expr><name>consts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ADDOP_I</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>MAKE_FUNCTION</name></expr></argument>, <argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>1</expr>;</return>
}</block></then></if>
<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>free</name></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>) <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>name</name> <init>= <expr><call><name>PyTuple_GET_ITEM</name><argument_list>(<argument><expr><name><name>co</name>-&gt;<name>co_freevars</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>arg</name></decl>, <decl><type ref="prev"/><name>reftype</name></decl>;</decl_stmt>
<expr_stmt><expr><name>reftype</name> = <call><name>get_ref_type</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>reftype</name> == <name>CELL</name></expr>)</condition><then>
<expr_stmt><expr><name>arg</name> = <call><name>compiler_lookup_arg</name><argument_list>(<argument><expr><name><name>c</name>-&gt;<name>u</name>-&gt;<name>u_cellvars</name></name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
<else>else
<expr_stmt><expr><name>arg</name> = <call><name>compiler_lookup_arg</name><argument_list>(<argument><expr><name><name>c</name>-&gt;<name>u</name>-&gt;<name>u_freevars</name></name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
<if>if <condition>(<expr><name>arg</name> == -1</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>"lookup %s in %s %d %d\n"
"freevars of %s: %s\n"</expr></argument>,
<argument><expr><call><name>PyObject_REPR</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name><name>c</name>-&gt;<name>u</name>-&gt;<name>u_name</name></name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>reftype</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>,
<argument><expr><call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name><name>co</name>-&gt;<name>co_name</name></name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name>PyObject_REPR</name><argument_list>(<argument><expr><name><name>co</name>-&gt;<name>co_freevars</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_FatalError</name><argument_list>(<argument><expr>"compiler_make_closure()"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><call><name>ADDOP_I</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>LOAD_CLOSURE</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></for>
<expr_stmt><expr><call><name>ADDOP_I</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>BUILD_TUPLE</name></expr></argument>, <argument><expr><name>free</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ADDOP_O</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>LOAD_CONST</name></expr></argument>, <argument><expr>(<name>PyObject</name>*)<name>co</name></expr></argument>, <argument><expr><name>consts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ADDOP_I</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>MAKE_CLOSURE</name></expr></argument>, <argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>1</expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>compiler_decorators</name><parameter_list>(<param><decl><type>struct <name>compiler</name> *</type><name>c</name></decl></param>, <param><decl><type><name>asdl_seq</name>*</type> <name>decos</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<if>if <condition>(<expr>!<name>decos</name></expr>)</condition><then>
<return>return <expr>1</expr>;</return></then></if>
<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <call><name>asdl_seq_LEN</name><argument_list>(<argument><expr><name>decos</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
<expr_stmt><expr><call><name>VISIT</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>, <argument><expr>(<name>expr_ty</name>)<call><name>asdl_seq_GET</name><argument_list>(<argument><expr><name>decos</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></for>
<return>return <expr>1</expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>compiler_arguments</name><parameter_list>(<param><decl><type>struct <name>compiler</name> *</type><name>c</name></decl></param>, <param><decl><type><name>arguments_ty</name></type> <name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>n</name> <init>= <expr><call><name>asdl_seq_LEN</name><argument_list>(<argument><expr><name><name>args</name>-&gt;<name>args</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>n</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
<decl_stmt><decl><type><name>expr_ty</name></type> <name>arg</name> <init>= <expr>(<name>expr_ty</name>)<call><name>asdl_seq_GET</name><argument_list>(<argument><expr><name><name>args</name>-&gt;<name>args</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name><name>arg</name>-&gt;<name>kind</name></name> == <name>Tuple_kind</name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>id</name> <init>= <expr><call><name>PyString_FromFormat</name><argument_list>(<argument><expr>".%d"</expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>id</name> == <name>NULL</name></expr>)</condition><then> <block>{
<return>return <expr>0</expr>;</return>
}</block></then></if>
<if>if <condition>(<expr>!<call><name>compiler_nameop</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><name>Load</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>0</expr>;</return>
}</block></then></if>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>VISIT</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
}</block></for>
<return>return <expr>1</expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>compiler_function</name><parameter_list>(<param><decl><type>struct <name>compiler</name> *</type><name>c</name></decl></param>, <param><decl><type><name>stmt_ty</name></type> <name>s</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyCodeObject</name> *</type><name>co</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>first_const</name> <init>= <expr><name>Py_None</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>arguments_ty</name></type> <name>args</name> <init>= <expr><name><name>s</name>-&gt;<name>v</name>.<name>FunctionDef</name>.<name>args</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>asdl_seq</name>*</type> <name>decos</name> <init>= <expr><name><name>s</name>-&gt;<name>v</name>.<name>FunctionDef</name>.<name>decorator_list</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>stmt_ty</name></type> <name>st</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>n</name></decl>, <decl><type ref="prev"/><name>docstring</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>s</name>-&gt;<name>kind</name></name> == <name>FunctionDef_kind</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<call><name>compiler_decorators</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>decos</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr>0</expr>;</return></then></if>
<if>if <condition>(<expr><name><name>args</name>-&gt;<name>defaults</name></name></expr>)</condition><then>
<expr_stmt><expr><call><name>VISIT_SEQ</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>, <argument><expr><name><name>args</name>-&gt;<name>defaults</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<if>if <condition>(<expr>!<call><name>compiler_enter_scope</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>v</name>.<name>FunctionDef</name>.<name>name</name></name></expr></argument>, <argument><expr>(<name>void</name> *)<name>s</name></expr></argument>,
<argument><expr><name><name>s</name>-&gt;<name>lineno</name></name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr>0</expr>;</return></then></if>
<expr_stmt><expr><name>st</name> = (<name>stmt_ty</name>)<call><name>asdl_seq_GET</name><argument_list>(<argument><expr><name><name>s</name>-&gt;<name>v</name>.<name>FunctionDef</name>.<name>body</name></name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>docstring</name> = <call><name>compiler_isdocstring</name><argument_list>(<argument><expr><name>st</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>docstring</name> &amp;&amp; <name>Py_OptimizeFlag</name> &lt; 2</expr>)</condition><then>
<expr_stmt><expr><name>first_const</name> = <name><name>st</name>-&gt;<name>v</name>.<name>Expr</name>.<name>value</name>-&gt;<name>v</name>.<name>Str</name>.<name>s</name></name></expr>;</expr_stmt></then></if>
<if>if <condition>(<expr><call><name>compiler_add_o</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name><name>c</name>-&gt;<name>u</name>-&gt;<name>u_consts</name></name></expr></argument>, <argument><expr><name>first_const</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>compiler_exit_scope</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>0</expr>;</return>
}</block></then></if>
<expr_stmt><expr><call><name>compiler_arguments</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>c</name>-&gt;<name>u</name>-&gt;<name>u_argcount</name></name> = <call><name>asdl_seq_LEN</name><argument_list>(<argument><expr><name><name>args</name>-&gt;<name>args</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>n</name> = <call><name>asdl_seq_LEN</name><argument_list>(<argument><expr><name><name>s</name>-&gt;<name>v</name>.<name>FunctionDef</name>.<name>body</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for (<init><expr><name>i</name> = <name>docstring</name></expr>;</init> <condition><expr><name>i</name> &lt; <name>n</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
<expr_stmt><expr><name>st</name> = (<name>stmt_ty</name>)<call><name>asdl_seq_GET</name><argument_list>(<argument><expr><name><name>s</name>-&gt;<name>v</name>.<name>FunctionDef</name>.<name>body</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>VISIT_IN_SCOPE</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>stmt</name></expr></argument>, <argument><expr><name>st</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></for>
<expr_stmt><expr><name>co</name> = <call><name>assemble</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>compiler_exit_scope</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>co</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr>0</expr>;</return></then></if>
<expr_stmt><expr><call><name>compiler_make_closure</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>co</name></expr></argument>, <argument><expr><call><name>asdl_seq_LEN</name><argument_list>(<argument><expr><name><name>args</name>-&gt;<name>defaults</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>co</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <call><name>asdl_seq_LEN</name><argument_list>(<argument><expr><name>decos</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
<expr_stmt><expr><call><name>ADDOP_I</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>CALL_FUNCTION</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></for>
<return>return <expr><call><name>compiler_nameop</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>v</name>.<name>FunctionDef</name>.<name>name</name></name></expr></argument>, <argument><expr><name>Store</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>compiler_class</name><parameter_list>(<param><decl><type>struct <name>compiler</name> *</type><name>c</name></decl></param>, <param><decl><type><name>stmt_ty</name></type> <name>s</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>, <decl><type ref="prev"/><name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyCodeObject</name> *</type><name>co</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>str</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>asdl_seq</name>*</type> <name>decos</name> <init>= <expr><name><name>s</name>-&gt;<name>v</name>.<name>ClassDef</name>.<name>decorator_list</name></name></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>compiler_decorators</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>decos</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr>0</expr>;</return></then></if>
<expr_stmt><expr><call><name>ADDOP_O</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>LOAD_CONST</name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>v</name>.<name>ClassDef</name>.<name>name</name></name></expr></argument>, <argument><expr><name>consts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>n</name> = <call><name>asdl_seq_LEN</name><argument_list>(<argument><expr><name><name>s</name>-&gt;<name>v</name>.<name>ClassDef</name>.<name>bases</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>n</name> &gt; 0</expr>)</condition><then>
<expr_stmt><expr><call><name>VISIT_SEQ</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>v</name>.<name>ClassDef</name>.<name>bases</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<expr_stmt><expr><call><name>ADDOP_I</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>BUILD_TUPLE</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<call><name>compiler_enter_scope</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>v</name>.<name>ClassDef</name>.<name>name</name></name></expr></argument>, <argument><expr>(<name>void</name> *)<name>s</name></expr></argument>,
<argument><expr><name><name>s</name>-&gt;<name>lineno</name></name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr>0</expr>;</return></then></if>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name><name>c</name>-&gt;<name>u</name>-&gt;<name>u_private</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>c</name>-&gt;<name>u</name>-&gt;<name>u_private</name></name> = <name><name>s</name>-&gt;<name>v</name>.<name>ClassDef</name>.<name>name</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name><name>c</name>-&gt;<name>u</name>-&gt;<name>u_private</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>str</name> = <call><name>PyString_InternFromString</name><argument_list>(<argument><expr>"__name__"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>str</name> || !<call><name>compiler_nameop</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>str</name></expr></argument>, <argument><expr><name>Load</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>compiler_exit_scope</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>0</expr>;</return>
}</block></then></if>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>str</name> = <call><name>PyString_InternFromString</name><argument_list>(<argument><expr>"__module__"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>str</name> || !<call><name>compiler_nameop</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>str</name></expr></argument>, <argument><expr><name>Store</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>compiler_exit_scope</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>0</expr>;</return>
}</block></then></if>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<call><name>compiler_body</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>v</name>.<name>ClassDef</name>.<name>body</name></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>compiler_exit_scope</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>0</expr>;</return>
}</block></then></if>
<expr_stmt><expr><call><name>ADDOP_IN_SCOPE</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>LOAD_LOCALS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ADDOP_IN_SCOPE</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>RETURN_VALUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>co</name> = <call><name>assemble</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>compiler_exit_scope</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>co</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr>0</expr>;</return></then></if>
<expr_stmt><expr><call><name>compiler_make_closure</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>co</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>co</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ADDOP_I</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>CALL_FUNCTION</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ADDOP</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>BUILD_CLASS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <call><name>asdl_seq_LEN</name><argument_list>(<argument><expr><name>decos</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
<expr_stmt><expr><call><name>ADDOP_I</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>CALL_FUNCTION</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></for>
<if>if <condition>(<expr>!<call><name>compiler_nameop</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>v</name>.<name>ClassDef</name>.<name>name</name></name></expr></argument>, <argument><expr><name>Store</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr>0</expr>;</return></then></if>
<return>return <expr>1</expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>compiler_ifexp</name><parameter_list>(<param><decl><type>struct <name>compiler</name> *</type><name>c</name></decl></param>, <param><decl><type><name>expr_ty</name></type> <name>e</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>basicblock</name> *</type><name>end</name></decl>, *<decl><type ref="prev"/><name>next</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>e</name>-&gt;<name>kind</name></name> == <name>IfExp_kind</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>end</name> = <call><name>compiler_new_block</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>end</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr>0</expr>;</return></then></if>
<expr_stmt><expr><name>next</name> = <call><name>compiler_new_block</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>next</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr>0</expr>;</return></then></if>
<expr_stmt><expr><call><name>VISIT</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>, <argument><expr><name><name>e</name>-&gt;<name>v</name>.<name>IfExp</name>.<name>test</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ADDOP_JREL</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>JUMP_IF_FALSE</name></expr></argument>, <argument><expr><name>next</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ADDOP</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>POP_TOP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>VISIT</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>, <argument><expr><name><name>e</name>-&gt;<name>v</name>.<name>IfExp</name>.<name>body</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ADDOP_JREL</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>JUMP_FORWARD</name></expr></argument>, <argument><expr><name>end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>compiler_use_next_block</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>next</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ADDOP</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>POP_TOP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>VISIT</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>, <argument><expr><name><name>e</name>-&gt;<name>v</name>.<name>IfExp</name>.<name>orelse</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>compiler_use_next_block</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>1</expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>compiler_lambda</name><parameter_list>(<param><decl><type>struct <name>compiler</name> *</type><name>c</name></decl></param>, <param><decl><type><name>expr_ty</name></type> <name>e</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyCodeObject</name> *</type><name>co</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>identifier</name></type> <name>name</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>arguments_ty</name></type> <name>args</name> <init>= <expr><name><name>e</name>-&gt;<name>v</name>.<name>Lambda</name>.<name>args</name></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>e</name>-&gt;<name>kind</name></name> == <name>Lambda_kind</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>name</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>name</name> = <call><name>PyString_InternFromString</name><argument_list>(<argument><expr>"&lt;lambda&gt;"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>name</name></expr>)</condition><then>
<return>return <expr>0</expr>;</return></then></if>
}</block></then></if>
<if>if <condition>(<expr><name><name>args</name>-&gt;<name>defaults</name></name></expr>)</condition><then>
<expr_stmt><expr><call><name>VISIT_SEQ</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>, <argument><expr><name><name>args</name>-&gt;<name>defaults</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<if>if <condition>(<expr>!<call><name>compiler_enter_scope</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr>(<name>void</name> *)<name>e</name></expr></argument>, <argument><expr><name><name>e</name>-&gt;<name>lineno</name></name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr>0</expr>;</return></then></if>
<expr_stmt><expr><call><name>compiler_arguments</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>c</name>-&gt;<name>u</name>-&gt;<name>u_argcount</name></name> = <call><name>asdl_seq_LEN</name><argument_list>(<argument><expr><name><name>args</name>-&gt;<name>args</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>VISIT_IN_SCOPE</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>, <argument><expr><name><name>e</name>-&gt;<name>v</name>.<name>Lambda</name>.<name>body</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ADDOP_IN_SCOPE</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>RETURN_VALUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>co</name> = <call><name>assemble</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>compiler_exit_scope</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>co</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr>0</expr>;</return></then></if>
<expr_stmt><expr><call><name>compiler_make_closure</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>co</name></expr></argument>, <argument><expr><call><name>asdl_seq_LEN</name><argument_list>(<argument><expr><name><name>args</name>-&gt;<name>defaults</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>co</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>1</expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>compiler_print</name><parameter_list>(<param><decl><type>struct <name>compiler</name> *</type><name>c</name></decl></param>, <param><decl><type><name>stmt_ty</name></type> <name>s</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>n</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>dest</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>s</name>-&gt;<name>kind</name></name> == <name>Print_kind</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>n</name> = <call><name>asdl_seq_LEN</name><argument_list>(<argument><expr><name><name>s</name>-&gt;<name>v</name>.<name>Print</name>.<name>values</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>dest</name> = <name>false</name></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>s</name>-&gt;<name>v</name>.<name>Print</name>.<name>dest</name></name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>VISIT</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>v</name>.<name>Print</name>.<name>dest</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>dest</name> = <name>true</name></expr>;</expr_stmt>
}</block></then></if>
<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>n</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
<decl_stmt><decl><type><name>expr_ty</name></type> <name>e</name> <init>= <expr>(<name>expr_ty</name>)<call><name>asdl_seq_GET</name><argument_list>(<argument><expr><name><name>s</name>-&gt;<name>v</name>.<name>Print</name>.<name>values</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>dest</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>ADDOP</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>DUP_TOP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>VISIT</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ADDOP</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>ROT_TWO</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ADDOP</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>PRINT_ITEM_TO</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr><call><name>VISIT</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ADDOP</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>PRINT_ITEM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></else></if>
}</block></for>
<if>if <condition>(<expr><name><name>s</name>-&gt;<name>v</name>.<name>Print</name>.<name>nl</name></name></expr>)</condition><then> <block>{
<if>if <condition>(<expr><name>dest</name></expr>)</condition><then>
<macro><name>ADDOP</name><argument_list>(<argument>c</argument>, <argument>PRINT_NEWLINE_TO</argument>)</argument_list></macro></then>
<else>else
<macro><name>ADDOP</name><argument_list>(<argument>c</argument>, <argument>PRINT_NEWLINE</argument>)</argument_list></macro></else></if>
}</block></then> <else>else <if>if <condition>(<expr><name>dest</name></expr>)</condition><then>
<expr_stmt><expr><call><name>ADDOP</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>POP_TOP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if></else></if>
<return>return <expr>1</expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>compiler_if</name><parameter_list>(<param><decl><type>struct <name>compiler</name> *</type><name>c</name></decl></param>, <param><decl><type><name>stmt_ty</name></type> <name>s</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>basicblock</name> *</type><name>end</name></decl>, *<decl><type ref="prev"/><name>next</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>constant</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>s</name>-&gt;<name>kind</name></name> == <name>If_kind</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>end</name> = <call><name>compiler_new_block</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>end</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr>0</expr>;</return></then></if>
<expr_stmt><expr><name>next</name> = <call><name>compiler_new_block</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>next</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr>0</expr>;</return></then></if>
<expr_stmt><expr><name>constant</name> = <call><name>expr_constant</name><argument_list>(<argument><expr><name><name>s</name>-&gt;<name>v</name>.<name>If</name>.<name>test</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>constant</name> == 0</expr>)</condition><then> <block>{
<if>if <condition>(<expr><name><name>s</name>-&gt;<name>v</name>.<name>If</name>.<name>orelse</name></name></expr>)</condition><then>
<expr_stmt><expr><call><name>VISIT_SEQ</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>stmt</name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>v</name>.<name>If</name>.<name>orelse</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
}</block></then> <else>else <if>if <condition>(<expr><name>constant</name> == 1</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>VISIT_SEQ</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>stmt</name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>v</name>.<name>If</name>.<name>body</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr><call><name>VISIT</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>v</name>.<name>If</name>.<name>test</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ADDOP_JREL</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>JUMP_IF_FALSE</name></expr></argument>, <argument><expr><name>next</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ADDOP</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>POP_TOP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>VISIT_SEQ</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>stmt</name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>v</name>.<name>If</name>.<name>body</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ADDOP_JREL</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>JUMP_FORWARD</name></expr></argument>, <argument><expr><name>end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>compiler_use_next_block</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>next</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ADDOP</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>POP_TOP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>s</name>-&gt;<name>v</name>.<name>If</name>.<name>orelse</name></name></expr>)</condition><then>
<expr_stmt><expr><call><name>VISIT_SEQ</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>stmt</name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>v</name>.<name>If</name>.<name>orelse</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
}</block></else></if></else></if>
<expr_stmt><expr><call><name>compiler_use_next_block</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>1</expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>compiler_for</name><parameter_list>(<param><decl><type>struct <name>compiler</name> *</type><name>c</name></decl></param>, <param><decl><type><name>stmt_ty</name></type> <name>s</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>basicblock</name> *</type><name>start</name></decl>, *<decl><type ref="prev"/><name>cleanup</name></decl>, *<decl><type ref="prev"/><name>end</name></decl>;</decl_stmt>
<expr_stmt><expr><name>start</name> = <call><name>compiler_new_block</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>cleanup</name> = <call><name>compiler_new_block</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>end</name> = <call><name>compiler_new_block</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>start</name> == <name>NULL</name> || <name>end</name> == <name>NULL</name> || <name>cleanup</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr>0</expr>;</return></then></if>
<expr_stmt><expr><call><name>ADDOP_JREL</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>SETUP_LOOP</name></expr></argument>, <argument><expr><name>end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<call><name>compiler_push_fblock</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>LOOP</name></expr></argument>, <argument><expr><name>start</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr>0</expr>;</return></then></if>
<expr_stmt><expr><call><name>VISIT</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>v</name>.<name>For</name>.<name>iter</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ADDOP</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>GET_ITER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>compiler_use_next_block</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>c</name>-&gt;<name>u</name>-&gt;<name>u_lineno_set</name></name> = <name>false</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ADDOP_JREL</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>FOR_ITER</name></expr></argument>, <argument><expr><name>cleanup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>VISIT</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>v</name>.<name>For</name>.<name>target</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>VISIT_SEQ</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>stmt</name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>v</name>.<name>For</name>.<name>body</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ADDOP_JABS</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>JUMP_ABSOLUTE</name></expr></argument>, <argument><expr><name>start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>compiler_use_next_block</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>cleanup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ADDOP</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>POP_BLOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>compiler_pop_fblock</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>LOOP</name></expr></argument>, <argument><expr><name>start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>VISIT_SEQ</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>stmt</name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>v</name>.<name>For</name>.<name>orelse</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>compiler_use_next_block</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>1</expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>compiler_while</name><parameter_list>(<param><decl><type>struct <name>compiler</name> *</type><name>c</name></decl></param>, <param><decl><type><name>stmt_ty</name></type> <name>s</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>basicblock</name> *</type><name>loop</name></decl>, *<decl><type ref="prev"/><name>orelse</name></decl>, *<decl><type ref="prev"/><name>end</name></decl>, *<decl><type ref="prev"/><name>anchor</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>constant</name> <init>= <expr><call><name>expr_constant</name><argument_list>(<argument><expr><name><name>s</name>-&gt;<name>v</name>.<name>While</name>.<name>test</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>constant</name> == 0</expr>)</condition><then> <block>{
<if>if <condition>(<expr><name><name>s</name>-&gt;<name>v</name>.<name>While</name>.<name>orelse</name></name></expr>)</condition><then>
<expr_stmt><expr><call><name>VISIT_SEQ</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>stmt</name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>v</name>.<name>While</name>.<name>orelse</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<return>return <expr>1</expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>loop</name> = <call><name>compiler_new_block</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>end</name> = <call><name>compiler_new_block</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>constant</name> == -1</expr>)</condition><then> <block>{
<expr_stmt><expr><name>anchor</name> = <call><name>compiler_new_block</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>anchor</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr>0</expr>;</return></then></if>
}</block></then></if>
<if>if <condition>(<expr><name>loop</name> == <name>NULL</name> || <name>end</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr>0</expr>;</return></then></if>
<if>if <condition>(<expr><name><name>s</name>-&gt;<name>v</name>.<name>While</name>.<name>orelse</name></name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>orelse</name> = <call><name>compiler_new_block</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>orelse</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr>0</expr>;</return></then></if>
}</block></then> <else>else
<expr_stmt><expr><name>orelse</name> = <name>NULL</name></expr>;</expr_stmt></else></if>
<expr_stmt><expr><call><name>ADDOP_JREL</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>SETUP_LOOP</name></expr></argument>, <argument><expr><name>end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>compiler_use_next_block</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>loop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<call><name>compiler_push_fblock</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>LOOP</name></expr></argument>, <argument><expr><name>loop</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr>0</expr>;</return></then></if>
<if>if <condition>(<expr><name>constant</name> == -1</expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>c</name>-&gt;<name>u</name>-&gt;<name>u_lineno_set</name></name> = <name>false</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>VISIT</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>v</name>.<name>While</name>.<name>test</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ADDOP_JREL</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>JUMP_IF_FALSE</name></expr></argument>, <argument><expr><name>anchor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ADDOP</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>POP_TOP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><call><name>VISIT_SEQ</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>stmt</name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>v</name>.<name>While</name>.<name>body</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ADDOP_JABS</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>JUMP_ABSOLUTE</name></expr></argument>, <argument><expr><name>loop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>constant</name> == -1</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>compiler_use_next_block</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>anchor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ADDOP</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>POP_TOP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ADDOP</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>POP_BLOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><call><name>compiler_pop_fblock</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>LOOP</name></expr></argument>, <argument><expr><name>loop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>orelse</name> != <name>NULL</name></expr>)</condition><then>
<expr_stmt><expr><call><name>VISIT_SEQ</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>stmt</name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>v</name>.<name>While</name>.<name>orelse</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<expr_stmt><expr><call><name>compiler_use_next_block</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>1</expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>compiler_continue</name><parameter_list>(<param><decl><type>struct <name>compiler</name> *</type><name>c</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name></type> <name><name>LOOP_ERROR_MSG</name><index>[]</index></name> <init>= <expr>"'continue' not properly in loop"</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name></type> <name><name>IN_FINALLY_ERROR_MSG</name><index>[]</index></name> <init>=
<expr>"'continue' not supported inside 'finally' clause"</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<if>if <condition>(<expr>!<name><name>c</name>-&gt;<name>u</name>-&gt;<name>u_nfblocks</name></name></expr>)</condition><then>
<return>return <expr><call><name>compiler_error</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>LOOP_ERROR_MSG</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
<expr_stmt><expr><name>i</name> = <name><name>c</name>-&gt;<name>u</name>-&gt;<name>u_nfblocks</name></name> - 1</expr>;</expr_stmt>
<switch>switch <condition>(<expr><name><name>c</name>-&gt;<name>u</name>-&gt;<name>u_fblock</name><index>[<expr><name>i</name></expr>]</index></name>.<name>fb_type</name></expr>)</condition> <block>{
<case>case <expr><name>LOOP</name></expr>:
<expr_stmt><expr><call><name>ADDOP_JABS</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>JUMP_ABSOLUTE</name></expr></argument>, <argument><expr><name><name>c</name>-&gt;<name>u</name>-&gt;<name>u_fblock</name><index>[<expr><name>i</name></expr>]</index></name>.<name>fb_block</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr><name>EXCEPT</name></expr>:
</case><case>case <expr><name>FINALLY_TRY</name></expr>:
<while>while <condition>(<expr>--<name>i</name> &gt;= 0 &amp;&amp; <name><name>c</name>-&gt;<name>u</name>-&gt;<name>u_fblock</name><index>[<expr><name>i</name></expr>]</index></name>.<name>fb_type</name> != <name>LOOP</name></expr>)</condition> <block>{
<if>if <condition>(<expr><name><name>c</name>-&gt;<name>u</name>-&gt;<name>u_fblock</name><index>[<expr><name>i</name></expr>]</index></name>.<name>fb_type</name> == <name>FINALLY_END</name></expr>)</condition><then>
<return>return <expr><call><name>compiler_error</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>IN_FINALLY_ERROR_MSG</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
}</block></while>
<if>if <condition>(<expr><name>i</name> == -1</expr>)</condition><then>
<return>return <expr><call><name>compiler_error</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>LOOP_ERROR_MSG</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
<expr_stmt><expr><call><name>ADDOP_JABS</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>CONTINUE_LOOP</name></expr></argument>, <argument><expr><name><name>c</name>-&gt;<name>u</name>-&gt;<name>u_fblock</name><index>[<expr><name>i</name></expr>]</index></name>.<name>fb_block</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr><name>FINALLY_END</name></expr>:
<return>return <expr><call><name>compiler_error</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>IN_FINALLY_ERROR_MSG</name></expr></argument>)</argument_list></call></expr>;</return>
</case>}</block></switch>
<return>return <expr>1</expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>compiler_try_finally</name><parameter_list>(<param><decl><type>struct <name>compiler</name> *</type><name>c</name></decl></param>, <param><decl><type><name>stmt_ty</name></type> <name>s</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>basicblock</name> *</type><name>body</name></decl>, *<decl><type ref="prev"/><name>end</name></decl>;</decl_stmt>
<expr_stmt><expr><name>body</name> = <call><name>compiler_new_block</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>end</name> = <call><name>compiler_new_block</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>body</name> == <name>NULL</name> || <name>end</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr>0</expr>;</return></then></if>
<expr_stmt><expr><call><name>ADDOP_JREL</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>SETUP_FINALLY</name></expr></argument>, <argument><expr><name>end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>compiler_use_next_block</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>body</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<call><name>compiler_push_fblock</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>FINALLY_TRY</name></expr></argument>, <argument><expr><name>body</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr>0</expr>;</return></then></if>
<expr_stmt><expr><call><name>VISIT_SEQ</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>stmt</name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>v</name>.<name>TryFinally</name>.<name>body</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ADDOP</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>POP_BLOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>compiler_pop_fblock</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>FINALLY_TRY</name></expr></argument>, <argument><expr><name>body</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ADDOP_O</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>LOAD_CONST</name></expr></argument>, <argument><expr><name>Py_None</name></expr></argument>, <argument><expr><name>consts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>compiler_use_next_block</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<call><name>compiler_push_fblock</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>FINALLY_END</name></expr></argument>, <argument><expr><name>end</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr>0</expr>;</return></then></if>
<expr_stmt><expr><call><name>VISIT_SEQ</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>stmt</name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>v</name>.<name>TryFinally</name>.<name>finalbody</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ADDOP</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>END_FINALLY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>compiler_pop_fblock</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>FINALLY_END</name></expr></argument>, <argument><expr><name>end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>1</expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>compiler_try_except</name><parameter_list>(<param><decl><type>struct <name>compiler</name> *</type><name>c</name></decl></param>, <param><decl><type><name>stmt_ty</name></type> <name>s</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>basicblock</name> *</type><name>body</name></decl>, *<decl><type ref="prev"/><name>orelse</name></decl>, *<decl><type ref="prev"/><name>except</name></decl>, *<decl><type ref="prev"/><name>end</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>n</name></decl>;</decl_stmt>
<expr_stmt><expr><name>body</name> = <call><name>compiler_new_block</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>except</name> = <call><name>compiler_new_block</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>orelse</name> = <call><name>compiler_new_block</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>end</name> = <call><name>compiler_new_block</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>body</name> == <name>NULL</name> || <name>except</name> == <name>NULL</name> || <name>orelse</name> == <name>NULL</name> || <name>end</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr>0</expr>;</return></then></if>
<expr_stmt><expr><call><name>ADDOP_JREL</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>SETUP_EXCEPT</name></expr></argument>, <argument><expr><name>except</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>compiler_use_next_block</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>body</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<call><name>compiler_push_fblock</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>EXCEPT</name></expr></argument>, <argument><expr><name>body</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr>0</expr>;</return></then></if>
<expr_stmt><expr><call><name>VISIT_SEQ</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>stmt</name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>v</name>.<name>TryExcept</name>.<name>body</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ADDOP</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>POP_BLOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>compiler_pop_fblock</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>EXCEPT</name></expr></argument>, <argument><expr><name>body</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ADDOP_JREL</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>JUMP_FORWARD</name></expr></argument>, <argument><expr><name>orelse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>n</name> = <call><name>asdl_seq_LEN</name><argument_list>(<argument><expr><name><name>s</name>-&gt;<name>v</name>.<name>TryExcept</name>.<name>handlers</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>compiler_use_next_block</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>except</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>n</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
<decl_stmt><decl><type><name>excepthandler_ty</name></type> <name>handler</name> <init>= <expr>(<name>excepthandler_ty</name>)<call><name>asdl_seq_GET</name><argument_list>(
<argument><expr><name><name>s</name>-&gt;<name>v</name>.<name>TryExcept</name>.<name>handlers</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr>!<name><name>handler</name>-&gt;<name>v</name>.<name>ExceptHandler</name>.<name>type</name></name> &amp;&amp; <name>i</name> &lt; <name>n</name>-1</expr>)</condition><then>
<return>return <expr><call><name>compiler_error</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr>"default 'except:' must be last"</expr></argument>)</argument_list></call></expr>;</return></then></if>
<expr_stmt><expr><name><name>c</name>-&gt;<name>u</name>-&gt;<name>u_lineno_set</name></name> = <name>false</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>c</name>-&gt;<name>u</name>-&gt;<name>u_lineno</name></name> = <name><name>handler</name>-&gt;<name>lineno</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>except</name> = <call><name>compiler_new_block</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>except</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr>0</expr>;</return></then></if>
<if>if <condition>(<expr><name><name>handler</name>-&gt;<name>v</name>.<name>ExceptHandler</name>.<name>type</name></name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>ADDOP</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>DUP_TOP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>VISIT</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>, <argument><expr><name><name>handler</name>-&gt;<name>v</name>.<name>ExceptHandler</name>.<name>type</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ADDOP_I</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>COMPARE_OP</name></expr></argument>, <argument><expr><name>PyCmp_EXC_MATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ADDOP_JREL</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>JUMP_IF_FALSE</name></expr></argument>, <argument><expr><name>except</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ADDOP</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>POP_TOP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><call><name>ADDOP</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>POP_TOP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>handler</name>-&gt;<name>v</name>.<name>ExceptHandler</name>.<name>name</name></name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>VISIT</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>, <argument><expr><name><name>handler</name>-&gt;<name>v</name>.<name>ExceptHandler</name>.<name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr><call><name>ADDOP</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>POP_TOP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></else></if>
<expr_stmt><expr><call><name>ADDOP</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>POP_TOP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>VISIT_SEQ</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>stmt</name></expr></argument>, <argument><expr><name><name>handler</name>-&gt;<name>v</name>.<name>ExceptHandler</name>.<name>body</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ADDOP_JREL</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>JUMP_FORWARD</name></expr></argument>, <argument><expr><name>end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>compiler_use_next_block</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>except</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>handler</name>-&gt;<name>v</name>.<name>ExceptHandler</name>.<name>type</name></name></expr>)</condition><then>
<expr_stmt><expr><call><name>ADDOP</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>POP_TOP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
}</block></for>
<expr_stmt><expr><call><name>ADDOP</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>END_FINALLY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>compiler_use_next_block</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>orelse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>VISIT_SEQ</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>stmt</name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>v</name>.<name>TryExcept</name>.<name>orelse</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>compiler_use_next_block</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>1</expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>compiler_import_as</name><parameter_list>(<param><decl><type>struct <name>compiler</name> *</type><name>c</name></decl></param>, <param><decl><type><name>identifier</name></type> <name>name</name></decl></param>, <param><decl><type><name>identifier</name></type> <name>asname</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>src</name> <init>= <expr><call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>dot</name> <init>= <expr><call><name>strchr</name><argument_list>(<argument><expr><name>src</name></expr></argument>, <argument><expr>'.'</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>dot</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>src</name> = <name>dot</name> + 1</expr>;</expr_stmt>
<while>while <condition>(<expr><name>dot</name></expr>)</condition> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>attr</name></decl>;</decl_stmt>
<expr_stmt><expr><name>dot</name> = <call><name>strchr</name><argument_list>(<argument><expr><name>src</name></expr></argument>, <argument><expr>'.'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>attr</name> = <call><name>PyString_FromStringAndSize</name><argument_list>(<argument><expr><name>src</name></expr></argument>,
<argument><expr><name>dot</name> ? <name>dot</name> - <name>src</name> : <call><name>strlen</name><argument_list>(<argument><expr><name>src</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>attr</name></expr>)</condition><then>
<return>return <expr>-1</expr>;</return></then></if>
<expr_stmt><expr><call><name>ADDOP_O</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>LOAD_ATTR</name></expr></argument>, <argument><expr><name>attr</name></expr></argument>, <argument><expr><name>names</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>attr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>src</name> = <name>dot</name> + 1</expr>;</expr_stmt>
}</block></while>
}</block></then></if>
<return>return <expr><call><name>compiler_nameop</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>asname</name></expr></argument>, <argument><expr><name>Store</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>compiler_import</name><parameter_list>(<param><decl><type>struct <name>compiler</name> *</type><name>c</name></decl></param>, <param><decl><type><name>stmt_ty</name></type> <name>s</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>n</name> <init>= <expr><call><name>asdl_seq_LEN</name><argument_list>(<argument><expr><name><name>s</name>-&gt;<name>v</name>.<name>Import</name>.<name>names</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>n</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
<decl_stmt><decl><type><name>alias_ty</name></type> <name>alias</name> <init>= <expr>(<name>alias_ty</name>)<call><name>asdl_seq_GET</name><argument_list>(<argument><expr><name><name>s</name>-&gt;<name>v</name>.<name>Import</name>.<name>names</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>r</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>level</name></decl>;</decl_stmt>
<if>if <condition>(<expr><name><name>c</name>-&gt;<name>c_flags</name></name> &amp;&amp; (<name><name>c</name>-&gt;<name>c_flags</name>-&gt;<name>cf_flags</name></name> &amp; <name>CO_FUTURE_ABSOLUTE_IMPORT</name>)</expr>)</condition><then>
<expr_stmt><expr><name>level</name> = <call><name>PyInt_FromLong</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
<else>else
<expr_stmt><expr><name>level</name> = <call><name>PyInt_FromLong</name><argument_list>(<argument><expr>-1</expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
<if>if <condition>(<expr><name>level</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr>0</expr>;</return></then></if>
<expr_stmt><expr><call><name>ADDOP_O</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>LOAD_CONST</name></expr></argument>, <argument><expr><name>level</name></expr></argument>, <argument><expr><name>consts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>level</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ADDOP_O</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>LOAD_CONST</name></expr></argument>, <argument><expr><name>Py_None</name></expr></argument>, <argument><expr><name>consts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ADDOP_NAME</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>IMPORT_NAME</name></expr></argument>, <argument><expr><name><name>alias</name>-&gt;<name>name</name></name></expr></argument>, <argument><expr><name>names</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>alias</name>-&gt;<name>asname</name></name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>r</name> = <call><name>compiler_import_as</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name><name>alias</name>-&gt;<name>name</name></name></expr></argument>, <argument><expr><name><name>alias</name>-&gt;<name>asname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>r</name></expr>)</condition><then>
<return>return <expr><name>r</name></expr>;</return></then></if>
}</block></then> <else>else <block>{
<decl_stmt><decl><type><name>identifier</name></type> <name>tmp</name> <init>= <expr><name><name>alias</name>-&gt;<name>name</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>base</name> <init>= <expr><call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name><name>alias</name>-&gt;<name>name</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>dot</name> <init>= <expr><call><name>strchr</name><argument_list>(<argument><expr><name>base</name></expr></argument>, <argument><expr>'.'</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>dot</name></expr>)</condition><then>
<expr_stmt><expr><name>tmp</name> = <call><name>PyString_FromStringAndSize</name><argument_list>(<argument><expr><name>base</name></expr></argument>,
<argument><expr><name>dot</name> - <name>base</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<expr_stmt><expr><name>r</name> = <call><name>compiler_nameop</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>tmp</name></expr></argument>, <argument><expr><name>Store</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>dot</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<if>if <condition>(<expr>!<name>r</name></expr>)</condition><then>
<return>return <expr><name>r</name></expr>;</return></then></if>
}</block></else></if>
}</block></for>
<return>return <expr>1</expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>compiler_from_import</name><parameter_list>(<param><decl><type>struct <name>compiler</name> *</type><name>c</name></decl></param>, <param><decl><type><name>stmt_ty</name></type> <name>s</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>n</name> <init>= <expr><call><name>asdl_seq_LEN</name><argument_list>(<argument><expr><name><name>s</name>-&gt;<name>v</name>.<name>ImportFrom</name>.<name>names</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>names</name> <init>= <expr><call><name>PyTuple_New</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>level</name></decl>;</decl_stmt>
<if>if <condition>(<expr>!<name>names</name></expr>)</condition><then>
<return>return <expr>0</expr>;</return></then></if>
<if>if <condition>(<expr><name><name>s</name>-&gt;<name>v</name>.<name>ImportFrom</name>.<name>level</name></name> == 0 &amp;&amp; <name><name>c</name>-&gt;<name>c_flags</name></name> &amp;&amp;
!(<name><name>c</name>-&gt;<name>c_flags</name>-&gt;<name>cf_flags</name></name> &amp; <name>CO_FUTURE_ABSOLUTE_IMPORT</name>)</expr>)</condition><then>
<expr_stmt><expr><name>level</name> = <call><name>PyInt_FromLong</name><argument_list>(<argument><expr>-1</expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
<else>else
<expr_stmt><expr><name>level</name> = <call><name>PyInt_FromLong</name><argument_list>(<argument><expr><name><name>s</name>-&gt;<name>v</name>.<name>ImportFrom</name>.<name>level</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
<if>if <condition>(<expr>!<name>level</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>names</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>0</expr>;</return>
}</block></then></if>
<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>n</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
<decl_stmt><decl><type><name>alias_ty</name></type> <name>alias</name> <init>= <expr>(<name>alias_ty</name>)<call><name>asdl_seq_GET</name><argument_list>(<argument><expr><name><name>s</name>-&gt;<name>v</name>.<name>ImportFrom</name>.<name>names</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name><name>alias</name>-&gt;<name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyTuple_SET_ITEM</name><argument_list>(<argument><expr><name>names</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name><name>alias</name>-&gt;<name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></for>
<if>if <condition>(<expr><name><name>s</name>-&gt;<name>lineno</name></name> &gt; <name><name>c</name>-&gt;<name>c_future</name>-&gt;<name>ff_lineno</name></name></expr>)</condition><then> <block>{
<if>if <condition>(<expr>!<call><name>strcmp</name><argument_list>(<argument><expr><call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name><name>s</name>-&gt;<name>v</name>.<name>ImportFrom</name>.<name>module</name></name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr>"__future__"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>level</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>names</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>compiler_error</name><argument_list>(<argument><expr><name>c</name></expr></argument>,
<argument><expr>"from __future__ imports must occur "
"at the beginning of the file"</expr></argument>)</argument_list></call></expr>;</return>
}</block></then></if>
}</block></then></if>
<expr_stmt><expr><call><name>ADDOP_O</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>LOAD_CONST</name></expr></argument>, <argument><expr><name>level</name></expr></argument>, <argument><expr><name>consts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>level</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ADDOP_O</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>LOAD_CONST</name></expr></argument>, <argument><expr><name>names</name></expr></argument>, <argument><expr><name>consts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>names</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ADDOP_NAME</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>IMPORT_NAME</name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>v</name>.<name>ImportFrom</name>.<name>module</name></name></expr></argument>, <argument><expr><name>names</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>n</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
<decl_stmt><decl><type><name>alias_ty</name></type> <name>alias</name> <init>= <expr>(<name>alias_ty</name>)<call><name>asdl_seq_GET</name><argument_list>(<argument><expr><name><name>s</name>-&gt;<name>v</name>.<name>ImportFrom</name>.<name>names</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>identifier</name></type> <name>store_name</name></decl>;</decl_stmt>
<if>if <condition>(<expr><name>i</name> == 0 &amp;&amp; *<call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name><name>alias</name>-&gt;<name>name</name></name></expr></argument>)</argument_list></call> == '*'</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>n</name> == 1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ADDOP</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>IMPORT_STAR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>1</expr>;</return>
}</block></then></if>
<expr_stmt><expr><call><name>ADDOP_NAME</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>IMPORT_FROM</name></expr></argument>, <argument><expr><name><name>alias</name>-&gt;<name>name</name></name></expr></argument>, <argument><expr><name>names</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>store_name</name> = <name><name>alias</name>-&gt;<name>name</name></name></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>alias</name>-&gt;<name>asname</name></name></expr>)</condition><then>
<expr_stmt><expr><name>store_name</name> = <name><name>alias</name>-&gt;<name>asname</name></name></expr>;</expr_stmt></then></if>
<if>if <condition>(<expr>!<call><name>compiler_nameop</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>store_name</name></expr></argument>, <argument><expr><name>Store</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>names</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>0</expr>;</return>
}</block></then></if>
}</block></for>
<expr_stmt><expr><call><name>ADDOP</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>POP_TOP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>1</expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>compiler_assert</name><parameter_list>(<param><decl><type>struct <name>compiler</name> *</type><name>c</name></decl></param>, <param><decl><type><name>stmt_ty</name></type> <name>s</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><specifier>static</specifier> <name>PyObject</name> *</type><name>assertion_error</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>basicblock</name> *</type><name>end</name></decl>;</decl_stmt>
<if>if <condition>(<expr><name>Py_OptimizeFlag</name></expr>)</condition><then>
<return>return <expr>1</expr>;</return></then></if>
<if>if <condition>(<expr><name>assertion_error</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>assertion_error</name> = <call><name>PyString_InternFromString</name><argument_list>(<argument><expr>"AssertionError"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>assertion_error</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr>0</expr>;</return></then></if>
}</block></then></if>
<if>if <condition>(<expr><name><name>s</name>-&gt;<name>v</name>.<name>Assert</name>.<name>test</name>-&gt;<name>kind</name></name> == <name>Tuple_kind</name> &amp;&amp;
<call><name>asdl_seq_LEN</name><argument_list>(<argument><expr><name><name>s</name>-&gt;<name>v</name>.<name>Assert</name>.<name>test</name>-&gt;<name>v</name>.<name>Tuple</name>.<name>elts</name></name></expr></argument>)</argument_list></call> &gt; 0</expr>)</condition><then> <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name>*</type> <name>msg</name> <init>=
<expr>"assertion is always true, perhaps remove parentheses?"</expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><call><name>PyErr_WarnExplicit</name><argument_list>(<argument><expr><name>PyExc_SyntaxWarning</name></expr></argument>, <argument><expr><name>msg</name></expr></argument>, <argument><expr><name><name>c</name>-&gt;<name>c_filename</name></name></expr></argument>,
<argument><expr><name><name>c</name>-&gt;<name>u</name>-&gt;<name>u_lineno</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call> == -1</expr>)</condition><then>
<return>return <expr>0</expr>;</return></then></if>
}</block></then></if>
<expr_stmt><expr><call><name>VISIT</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>v</name>.<name>Assert</name>.<name>test</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>end</name> = <call><name>compiler_new_block</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>end</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr>0</expr>;</return></then></if>
<expr_stmt><expr><call><name>ADDOP_JREL</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>JUMP_IF_TRUE</name></expr></argument>, <argument><expr><name>end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ADDOP</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>POP_TOP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ADDOP_O</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>LOAD_GLOBAL</name></expr></argument>, <argument><expr><name>assertion_error</name></expr></argument>, <argument><expr><name>names</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>s</name>-&gt;<name>v</name>.<name>Assert</name>.<name>msg</name></name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>VISIT</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>v</name>.<name>Assert</name>.<name>msg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ADDOP_I</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>RAISE_VARARGS</name></expr></argument>, <argument><expr>2</expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr><call><name>ADDOP_I</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>RAISE_VARARGS</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></else></if>
<expr_stmt><expr><call><name>compiler_use_next_block</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ADDOP</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>POP_TOP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>1</expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>compiler_visit_stmt</name><parameter_list>(<param><decl><type>struct <name>compiler</name> *</type><name>c</name></decl></param>, <param><decl><type><name>stmt_ty</name></type> <name>s</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>n</name></decl>;</decl_stmt>
<expr_stmt><expr><name><name>c</name>-&gt;<name>u</name>-&gt;<name>u_lineno</name></name> = <name><name>s</name>-&gt;<name>lineno</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>c</name>-&gt;<name>u</name>-&gt;<name>u_lineno_set</name></name> = <name>false</name></expr>;</expr_stmt>
<switch>switch <condition>(<expr><name><name>s</name>-&gt;<name>kind</name></name></expr>)</condition> <block>{
<case>case <expr><name>FunctionDef_kind</name></expr>:
<return>return <expr><call><name>compiler_function</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</return>
</case><case>case <expr><name>ClassDef_kind</name></expr>:
<return>return <expr><call><name>compiler_class</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</return>
</case><case>case <expr><name>Return_kind</name></expr>:
<if>if <condition>(<expr><name><name>c</name>-&gt;<name>u</name>-&gt;<name>u_ste</name>-&gt;<name>ste_type</name></name> != <name>FunctionBlock</name></expr>)</condition><then>
<return>return <expr><call><name>compiler_error</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr>"'return' outside function"</expr></argument>)</argument_list></call></expr>;</return></then></if>
<if>if <condition>(<expr><name><name>s</name>-&gt;<name>v</name>.<name>Return</name>.<name>value</name></name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>VISIT</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>v</name>.<name>Return</name>.<name>value</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else
<expr_stmt><expr><call><name>ADDOP_O</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>LOAD_CONST</name></expr></argument>, <argument><expr><name>Py_None</name></expr></argument>, <argument><expr><name>consts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
<expr_stmt><expr><call><name>ADDOP</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>RETURN_VALUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr><name>Delete_kind</name></expr>:
<macro><name>VISIT_SEQ</name><argument_list>(<argument>c</argument>, <argument>expr</argument>, <argument>s-&gt;v.Delete.targets</argument>)</argument_list></macro>
<break>break;</break>
</case><case>case <expr><name>Assign_kind</name></expr>:
<expr_stmt><expr><name>n</name> = <call><name>asdl_seq_LEN</name><argument_list>(<argument><expr><name><name>s</name>-&gt;<name>v</name>.<name>Assign</name>.<name>targets</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>VISIT</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>v</name>.<name>Assign</name>.<name>value</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>n</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
<if>if <condition>(<expr><name>i</name> &lt; <name>n</name> - 1</expr>)</condition><then>
<expr_stmt><expr><call><name>ADDOP</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>DUP_TOP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<expr_stmt><expr><call><name>VISIT</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>,
<argument><expr>(<name>expr_ty</name>)<call><name>asdl_seq_GET</name><argument_list>(<argument><expr><name><name>s</name>-&gt;<name>v</name>.<name>Assign</name>.<name>targets</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></for>
<break>break;</break>
</case><case>case <expr><name>AugAssign_kind</name></expr>:
<return>return <expr><call><name>compiler_augassign</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</return>
</case><case>case <expr><name>Print_kind</name></expr>:
<return>return <expr><call><name>compiler_print</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</return>
</case><case>case <expr><name>For_kind</name></expr>:
<return>return <expr><call><name>compiler_for</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</return>
</case><case>case <expr><name>While_kind</name></expr>:
<return>return <expr><call><name>compiler_while</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</return>
</case><case>case <expr><name>If_kind</name></expr>:
<return>return <expr><call><name>compiler_if</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</return>
</case><case>case <expr><name>Raise_kind</name></expr>:
<expr_stmt><expr><name>n</name> = 0</expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>s</name>-&gt;<name>v</name>.<name>Raise</name>.<name>type</name></name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>VISIT</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>v</name>.<name>Raise</name>.<name>type</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>n</name>++</expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>s</name>-&gt;<name>v</name>.<name>Raise</name>.<name>inst</name></name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>VISIT</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>v</name>.<name>Raise</name>.<name>inst</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>n</name>++</expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>s</name>-&gt;<name>v</name>.<name>Raise</name>.<name>tback</name></name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>VISIT</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>v</name>.<name>Raise</name>.<name>tback</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>n</name>++</expr>;</expr_stmt>
}</block></then></if>
}</block></then></if>
}</block></then></if>
<expr_stmt><expr><call><name>ADDOP_I</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>RAISE_VARARGS</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr><name>TryExcept_kind</name></expr>:
<return>return <expr><call><name>compiler_try_except</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</return>
</case><case>case <expr><name>TryFinally_kind</name></expr>:
<return>return <expr><call><name>compiler_try_finally</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</return>
</case><case>case <expr><name>Assert_kind</name></expr>:
<return>return <expr><call><name>compiler_assert</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</return>
</case><case>case <expr><name>Import_kind</name></expr>:
<return>return <expr><call><name>compiler_import</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</return>
</case><case>case <expr><name>ImportFrom_kind</name></expr>:
<return>return <expr><call><name>compiler_from_import</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</return>
</case><case>case <expr><name>Exec_kind</name></expr>:
<expr_stmt><expr><call><name>VISIT</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>v</name>.<name>Exec</name>.<name>body</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>s</name>-&gt;<name>v</name>.<name>Exec</name>.<name>globals</name></name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>VISIT</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>v</name>.<name>Exec</name>.<name>globals</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>s</name>-&gt;<name>v</name>.<name>Exec</name>.<name>locals</name></name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>VISIT</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>v</name>.<name>Exec</name>.<name>locals</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr><call><name>ADDOP</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>DUP_TOP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></else></if>
}</block></then> <else>else <block>{
<expr_stmt><expr><call><name>ADDOP_O</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>LOAD_CONST</name></expr></argument>, <argument><expr><name>Py_None</name></expr></argument>, <argument><expr><name>consts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ADDOP</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>DUP_TOP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></else></if>
<expr_stmt><expr><call><name>ADDOP</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>EXEC_STMT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr><name>Global_kind</name></expr>:
<break>break;</break>
</case><case>case <expr><name>Expr_kind</name></expr>:
<if>if <condition>(<expr><name><name>c</name>-&gt;<name>c_interactive</name></name> &amp;&amp; <name><name>c</name>-&gt;<name>c_nestlevel</name></name> &lt;= 1</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>VISIT</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>v</name>.<name>Expr</name>.<name>value</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ADDOP</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>PRINT_EXPR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else <if>if <condition>(<expr><name><name>s</name>-&gt;<name>v</name>.<name>Expr</name>.<name>value</name>-&gt;<name>kind</name></name> != <name>Str_kind</name> &amp;&amp;
<name><name>s</name>-&gt;<name>v</name>.<name>Expr</name>.<name>value</name>-&gt;<name>kind</name></name> != <name>Num_kind</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>VISIT</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>v</name>.<name>Expr</name>.<name>value</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ADDOP</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>POP_TOP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if></else></if>
<break>break;</break>
</case><case>case <expr><name>Pass_kind</name></expr>:
<break>break;</break>
</case><case>case <expr><name>Break_kind</name></expr>:
<if>if <condition>(<expr>!<call><name>compiler_in_loop</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><call><name>compiler_error</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr>"'break' outside loop"</expr></argument>)</argument_list></call></expr>;</return></then></if>
<expr_stmt><expr><call><name>ADDOP</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>BREAK_LOOP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr><name>Continue_kind</name></expr>:
<return>return <expr><call><name>compiler_continue</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</return>
</case><case>case <expr><name>With_kind</name></expr>:
<return>return <expr><call><name>compiler_with</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</return>
</case>}</block></switch>
<return>return <expr>1</expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>unaryop</name><parameter_list>(<param><decl><type><name>unaryop_ty</name></type> <name>op</name></decl></param>)</parameter_list> <block>{
<switch>switch <condition>(<expr><name>op</name></expr>)</condition> <block>{
<case>case <expr><name>Invert</name></expr>:
<return>return <expr><name>UNARY_INVERT</name></expr>;</return>
</case><case>case <expr><name>Not</name></expr>:
<return>return <expr><name>UNARY_NOT</name></expr>;</return>
</case><case>case <expr><name>UAdd</name></expr>:
<return>return <expr><name>UNARY_POSITIVE</name></expr>;</return>
</case><case>case <expr><name>USub</name></expr>:
<return>return <expr><name>UNARY_NEGATIVE</name></expr>;</return>
</case><default>default:
<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_SystemError</name></expr></argument>,
<argument><expr>"unary op %d should not be possible"</expr></argument>, <argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>0</expr>;</return>
</default>}</block></switch>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>binop</name><parameter_list>(<param><decl><type>struct <name>compiler</name> *</type><name>c</name></decl></param>, <param><decl><type><name>operator_ty</name></type> <name>op</name></decl></param>)</parameter_list> <block>{
<switch>switch <condition>(<expr><name>op</name></expr>)</condition> <block>{
<case>case <expr><name>Add</name></expr>:
<return>return <expr><name>BINARY_ADD</name></expr>;</return>
</case><case>case <expr><name>Sub</name></expr>:
<return>return <expr><name>BINARY_SUBTRACT</name></expr>;</return>
</case><case>case <expr><name>Mult</name></expr>:
<return>return <expr><name>BINARY_MULTIPLY</name></expr>;</return>
</case><case>case <expr><name>Div</name></expr>:
<if>if <condition>(<expr><name><name>c</name>-&gt;<name>c_flags</name></name> &amp;&amp; <name><name>c</name>-&gt;<name>c_flags</name>-&gt;<name>cf_flags</name></name> &amp; <name>CO_FUTURE_DIVISION</name></expr>)</condition><then>
<return>return <expr><name>BINARY_TRUE_DIVIDE</name></expr>;</return></then>
<else>else
<return>return <expr><name>BINARY_DIVIDE</name></expr>;</return></else></if>
</case><case>case <expr><name>Mod</name></expr>:
<return>return <expr><name>BINARY_MODULO</name></expr>;</return>
</case><case>case <expr><name>Pow</name></expr>:
<return>return <expr><name>BINARY_POWER</name></expr>;</return>
</case><case>case <expr><name>LShift</name></expr>:
<return>return <expr><name>BINARY_LSHIFT</name></expr>;</return>
</case><case>case <expr><name>RShift</name></expr>:
<return>return <expr><name>BINARY_RSHIFT</name></expr>;</return>
</case><case>case <expr><name>BitOr</name></expr>:
<return>return <expr><name>BINARY_OR</name></expr>;</return>
</case><case>case <expr><name>BitXor</name></expr>:
<return>return <expr><name>BINARY_XOR</name></expr>;</return>
</case><case>case <expr><name>BitAnd</name></expr>:
<return>return <expr><name>BINARY_AND</name></expr>;</return>
</case><case>case <expr><name>FloorDiv</name></expr>:
<return>return <expr><name>BINARY_FLOOR_DIVIDE</name></expr>;</return>
</case><default>default:
<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_SystemError</name></expr></argument>,
<argument><expr>"binary op %d should not be possible"</expr></argument>, <argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>0</expr>;</return>
</default>}</block></switch>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>cmpop</name><parameter_list>(<param><decl><type><name>cmpop_ty</name></type> <name>op</name></decl></param>)</parameter_list> <block>{
<switch>switch <condition>(<expr><name>op</name></expr>)</condition> <block>{
<case>case <expr><name>Eq</name></expr>:
<return>return <expr><name>PyCmp_EQ</name></expr>;</return>
</case><case>case <expr><name>NotEq</name></expr>:
<return>return <expr><name>PyCmp_NE</name></expr>;</return>
</case><case>case <expr><name>Lt</name></expr>:
<return>return <expr><name>PyCmp_LT</name></expr>;</return>
</case><case>case <expr><name>LtE</name></expr>:
<return>return <expr><name>PyCmp_LE</name></expr>;</return>
</case><case>case <expr><name>Gt</name></expr>:
<return>return <expr><name>PyCmp_GT</name></expr>;</return>
</case><case>case <expr><name>GtE</name></expr>:
<return>return <expr><name>PyCmp_GE</name></expr>;</return>
</case><case>case <expr><name>Is</name></expr>:
<return>return <expr><name>PyCmp_IS</name></expr>;</return>
</case><case>case <expr><name>IsNot</name></expr>:
<return>return <expr><name>PyCmp_IS_NOT</name></expr>;</return>
</case><case>case <expr><name>In</name></expr>:
<return>return <expr><name>PyCmp_IN</name></expr>;</return>
</case><case>case <expr><name>NotIn</name></expr>:
<return>return <expr><name>PyCmp_NOT_IN</name></expr>;</return>
</case><default>default:
<return>return <expr><name>PyCmp_BAD</name></expr>;</return>
</default>}</block></switch>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>inplace_binop</name><parameter_list>(<param><decl><type>struct <name>compiler</name> *</type><name>c</name></decl></param>, <param><decl><type><name>operator_ty</name></type> <name>op</name></decl></param>)</parameter_list> <block>{
<switch>switch <condition>(<expr><name>op</name></expr>)</condition> <block>{
<case>case <expr><name>Add</name></expr>:
<return>return <expr><name>INPLACE_ADD</name></expr>;</return>
</case><case>case <expr><name>Sub</name></expr>:
<return>return <expr><name>INPLACE_SUBTRACT</name></expr>;</return>
</case><case>case <expr><name>Mult</name></expr>:
<return>return <expr><name>INPLACE_MULTIPLY</name></expr>;</return>
</case><case>case <expr><name>Div</name></expr>:
<if>if <condition>(<expr><name><name>c</name>-&gt;<name>c_flags</name></name> &amp;&amp; <name><name>c</name>-&gt;<name>c_flags</name>-&gt;<name>cf_flags</name></name> &amp; <name>CO_FUTURE_DIVISION</name></expr>)</condition><then>
<return>return <expr><name>INPLACE_TRUE_DIVIDE</name></expr>;</return></then>
<else>else
<return>return <expr><name>INPLACE_DIVIDE</name></expr>;</return></else></if>
</case><case>case <expr><name>Mod</name></expr>:
<return>return <expr><name>INPLACE_MODULO</name></expr>;</return>
</case><case>case <expr><name>Pow</name></expr>:
<return>return <expr><name>INPLACE_POWER</name></expr>;</return>
</case><case>case <expr><name>LShift</name></expr>:
<return>return <expr><name>INPLACE_LSHIFT</name></expr>;</return>
</case><case>case <expr><name>RShift</name></expr>:
<return>return <expr><name>INPLACE_RSHIFT</name></expr>;</return>
</case><case>case <expr><name>BitOr</name></expr>:
<return>return <expr><name>INPLACE_OR</name></expr>;</return>
</case><case>case <expr><name>BitXor</name></expr>:
<return>return <expr><name>INPLACE_XOR</name></expr>;</return>
</case><case>case <expr><name>BitAnd</name></expr>:
<return>return <expr><name>INPLACE_AND</name></expr>;</return>
</case><case>case <expr><name>FloorDiv</name></expr>:
<return>return <expr><name>INPLACE_FLOOR_DIVIDE</name></expr>;</return>
</case><default>default:
<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_SystemError</name></expr></argument>,
<argument><expr>"inplace binary op %d should not be possible"</expr></argument>, <argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>0</expr>;</return>
</default>}</block></switch>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>compiler_nameop</name><parameter_list>(<param><decl><type>struct <name>compiler</name> *</type><name>c</name></decl></param>, <param><decl><type><name>identifier</name></type> <name>name</name></decl></param>, <param><decl><type><name>expr_context_ty</name></type> <name>ctx</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>op</name></decl>, <decl><type ref="prev"/><name>scope</name></decl>, <decl><type ref="prev"/><name>arg</name></decl>;</decl_stmt>
<enum>enum <block>{ <decl><name>OP_FAST</name></decl>, <decl><name>OP_GLOBAL</name></decl>, <decl><name>OP_DEREF</name></decl>, <decl><name>OP_NAME</name></decl> }</block> <decl><name>optype</name></decl>;</enum>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>dict</name> <init>= <expr><name><name>c</name>-&gt;<name>u</name>-&gt;<name>u_names</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>mangled</name></decl>;</decl_stmt>
<if>if <condition>(<expr>(<name>ctx</name> == <name>Store</name> || <name>ctx</name> == <name>AugStore</name> || <name>ctx</name> == <name>Del</name>)
&amp;&amp; !<call><name>strcmp</name><argument_list>(<argument><expr><call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>"__debug__"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<return>return <expr><call><name>compiler_error</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr>"can not assign to __debug__"</expr></argument>)</argument_list></call></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>mangled</name> = <call><name>_Py_Mangle</name><argument_list>(<argument><expr><name><name>c</name>-&gt;<name>u</name>-&gt;<name>u_private</name></name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>mangled</name></expr>)</condition><then>
<return>return <expr>0</expr>;</return></then></if>
<expr_stmt><expr><name>op</name> = 0</expr>;</expr_stmt>
<expr_stmt><expr><name>optype</name> = <name>OP_NAME</name></expr>;</expr_stmt>
<expr_stmt><expr><name>scope</name> = <call><name>PyST_GetScope</name><argument_list>(<argument><expr><name><name>c</name>-&gt;<name>u</name>-&gt;<name>u_ste</name></name></expr></argument>, <argument><expr><name>mangled</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<switch>switch <condition>(<expr><name>scope</name></expr>)</condition> <block>{
<case>case <expr><name>FREE</name></expr>:
<expr_stmt><expr><name>dict</name> = <name><name>c</name>-&gt;<name>u</name>-&gt;<name>u_freevars</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>optype</name> = <name>OP_DEREF</name></expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr><name>CELL</name></expr>:
<expr_stmt><expr><name>dict</name> = <name><name>c</name>-&gt;<name>u</name>-&gt;<name>u_cellvars</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>optype</name> = <name>OP_DEREF</name></expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr><name>LOCAL</name></expr>:
<if>if <condition>(<expr><name><name>c</name>-&gt;<name>u</name>-&gt;<name>u_ste</name>-&gt;<name>ste_type</name></name> == <name>FunctionBlock</name></expr>)</condition><then>
<expr_stmt><expr><name>optype</name> = <name>OP_FAST</name></expr>;</expr_stmt></then></if>
<break>break;</break>
</case><case>case <expr><name>GLOBAL_IMPLICIT</name></expr>:
<if>if <condition>(<expr><name><name>c</name>-&gt;<name>u</name>-&gt;<name>u_ste</name>-&gt;<name>ste_type</name></name> == <name>FunctionBlock</name> &amp;&amp;
!<name><name>c</name>-&gt;<name>u</name>-&gt;<name>u_ste</name>-&gt;<name>ste_unoptimized</name></name></expr>)</condition><then>
<expr_stmt><expr><name>optype</name> = <name>OP_GLOBAL</name></expr>;</expr_stmt></then></if>
<break>break;</break>
</case><case>case <expr><name>GLOBAL_EXPLICIT</name></expr>:
<expr_stmt><expr><name>optype</name> = <name>OP_GLOBAL</name></expr>;</expr_stmt>
<break>break;</break>
</case><default>default:
<break>break;</break>
</default>}</block></switch>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>scope</name> || <call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call><index>[<expr>0</expr>]</index> == '_'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<switch>switch <condition>(<expr><name>optype</name></expr>)</condition> <block>{
<case>case <expr><name>OP_DEREF</name></expr>:
<switch>switch <condition>(<expr><name>ctx</name></expr>)</condition> <block>{
<case>case <expr><name>Load</name></expr>:
<expr_stmt><expr><name>op</name> = <name>LOAD_DEREF</name></expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr><name>Store</name></expr>:
<expr_stmt><expr><name>op</name> = <name>STORE_DEREF</name></expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr><name>AugLoad</name></expr>:
</case><case>case <expr><name>AugStore</name></expr>:
<break>break;</break>
</case><case>case <expr><name>Del</name></expr>:
<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_SyntaxError</name></expr></argument>,
<argument><expr>"can not delete variable '%s' referenced "
"in nested scope"</expr></argument>,
<argument><expr><call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>mangled</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>0</expr>;</return>
</case><case>case <expr><name>Param</name></expr>:
</case><default>default:
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_SystemError</name></expr></argument>,
<argument><expr>"param invalid for deref variable"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>0</expr>;</return>
</default>}</block></switch>
<break>break;</break>
</case><case>case <expr><name>OP_FAST</name></expr>:
<switch>switch <condition>(<expr><name>ctx</name></expr>)</condition> <block>{
<case>case <expr><name>Load</name></expr>:
<expr_stmt><expr><name>op</name> = <name>LOAD_FAST</name></expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr><name>Store</name></expr>:
<expr_stmt><expr><name>op</name> = <name>STORE_FAST</name></expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr><name>Del</name></expr>:
<expr_stmt><expr><name>op</name> = <name>DELETE_FAST</name></expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr><name>AugLoad</name></expr>:
</case><case>case <expr><name>AugStore</name></expr>:
<break>break;</break>
</case><case>case <expr><name>Param</name></expr>:
</case><default>default:
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_SystemError</name></expr></argument>,
<argument><expr>"param invalid for local variable"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>0</expr>;</return>
</default>}</block></switch>
<expr_stmt><expr><call><name>ADDOP_O</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>op</name></expr></argument>, <argument><expr><name>mangled</name></expr></argument>, <argument><expr><name>varnames</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>mangled</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>1</expr>;</return>
</case><case>case <expr><name>OP_GLOBAL</name></expr>:
<switch>switch <condition>(<expr><name>ctx</name></expr>)</condition> <block>{
<case>case <expr><name>Load</name></expr>:
<expr_stmt><expr><name>op</name> = <name>LOAD_GLOBAL</name></expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr><name>Store</name></expr>:
<expr_stmt><expr><name>op</name> = <name>STORE_GLOBAL</name></expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr><name>Del</name></expr>:
<expr_stmt><expr><name>op</name> = <name>DELETE_GLOBAL</name></expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr><name>AugLoad</name></expr>:
</case><case>case <expr><name>AugStore</name></expr>:
<break>break;</break>
</case><case>case <expr><name>Param</name></expr>:
</case><default>default:
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_SystemError</name></expr></argument>,
<argument><expr>"param invalid for global variable"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>0</expr>;</return>
</default>}</block></switch>
<break>break;</break>
</case><case>case <expr><name>OP_NAME</name></expr>:
<switch>switch <condition>(<expr><name>ctx</name></expr>)</condition> <block>{
<case>case <expr><name>Load</name></expr>:
<expr_stmt><expr><name>op</name> = <name>LOAD_NAME</name></expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr><name>Store</name></expr>:
<expr_stmt><expr><name>op</name> = <name>STORE_NAME</name></expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr><name>Del</name></expr>:
<expr_stmt><expr><name>op</name> = <name>DELETE_NAME</name></expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr><name>AugLoad</name></expr>:
</case><case>case <expr><name>AugStore</name></expr>:
<break>break;</break>
</case><case>case <expr><name>Param</name></expr>:
</case><default>default:
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_SystemError</name></expr></argument>,
<argument><expr>"param invalid for name variable"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>0</expr>;</return>
</default>}</block></switch>
<break>break;</break>
</case>}</block></switch>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>arg</name> = <call><name>compiler_add_o</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>dict</name></expr></argument>, <argument><expr><name>mangled</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>mangled</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>arg</name> &lt; 0</expr>)</condition><then>
<return>return <expr>0</expr>;</return></then></if>
<return>return <expr><call><name>compiler_addop_i</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>op</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>compiler_boolop</name><parameter_list>(<param><decl><type>struct <name>compiler</name> *</type><name>c</name></decl></param>, <param><decl><type><name>expr_ty</name></type> <name>e</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>basicblock</name> *</type><name>end</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>jumpi</name></decl>, <decl><type ref="prev"/><name>i</name></decl>, <decl><type ref="prev"/><name>n</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>asdl_seq</name> *</type><name>s</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>e</name>-&gt;<name>kind</name></name> == <name>BoolOp_kind</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>e</name>-&gt;<name>v</name>.<name>BoolOp</name>.<name>op</name></name> == <name>And</name></expr>)</condition><then>
<expr_stmt><expr><name>jumpi</name> = <name>JUMP_IF_FALSE</name></expr>;</expr_stmt></then>
<else>else
<expr_stmt><expr><name>jumpi</name> = <name>JUMP_IF_TRUE</name></expr>;</expr_stmt></else></if>
<expr_stmt><expr><name>end</name> = <call><name>compiler_new_block</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>end</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr>0</expr>;</return></then></if>
<expr_stmt><expr><name>s</name> = <name><name>e</name>-&gt;<name>v</name>.<name>BoolOp</name>.<name>values</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>n</name> = <call><name>asdl_seq_LEN</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call> - 1</expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>n</name> &gt;= 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>n</name></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>) <block>{
<expr_stmt><expr><call><name>VISIT</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>, <argument><expr>(<name>expr_ty</name>)<call><name>asdl_seq_GET</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ADDOP_JREL</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>jumpi</name></expr></argument>, <argument><expr><name>end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<macro><name>ADDOP</name><argument_list>(<argument>c</argument>, <argument>POP_TOP</argument>)</argument_list></macro>
}</block></for>
<expr_stmt><expr><call><name>VISIT</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>, <argument><expr>(<name>expr_ty</name>)<call><name>asdl_seq_GET</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>compiler_use_next_block</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>1</expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>compiler_list</name><parameter_list>(<param><decl><type>struct <name>compiler</name> *</type><name>c</name></decl></param>, <param><decl><type><name>expr_ty</name></type> <name>e</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>n</name> <init>= <expr><call><name>asdl_seq_LEN</name><argument_list>(<argument><expr><name><name>e</name>-&gt;<name>v</name>.<name>List</name>.<name>elts</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name><name>e</name>-&gt;<name>v</name>.<name>List</name>.<name>ctx</name></name> == <name>Store</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>ADDOP_I</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>UNPACK_SEQUENCE</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><call><name>VISIT_SEQ</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>, <argument><expr><name><name>e</name>-&gt;<name>v</name>.<name>List</name>.<name>elts</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>e</name>-&gt;<name>v</name>.<name>List</name>.<name>ctx</name></name> == <name>Load</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>ADDOP_I</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>BUILD_LIST</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<return>return <expr>1</expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>compiler_tuple</name><parameter_list>(<param><decl><type>struct <name>compiler</name> *</type><name>c</name></decl></param>, <param><decl><type><name>expr_ty</name></type> <name>e</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>n</name> <init>= <expr><call><name>asdl_seq_LEN</name><argument_list>(<argument><expr><name><name>e</name>-&gt;<name>v</name>.<name>Tuple</name>.<name>elts</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name><name>e</name>-&gt;<name>v</name>.<name>Tuple</name>.<name>ctx</name></name> == <name>Store</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>ADDOP_I</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>UNPACK_SEQUENCE</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><call><name>VISIT_SEQ</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>, <argument><expr><name><name>e</name>-&gt;<name>v</name>.<name>Tuple</name>.<name>elts</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>e</name>-&gt;<name>v</name>.<name>Tuple</name>.<name>ctx</name></name> == <name>Load</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>ADDOP_I</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>BUILD_TUPLE</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<return>return <expr>1</expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>compiler_compare</name><parameter_list>(<param><decl><type>struct <name>compiler</name> *</type><name>c</name></decl></param>, <param><decl><type><name>expr_ty</name></type> <name>e</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>n</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>basicblock</name> *</type><name>cleanup</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>VISIT</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>, <argument><expr><name><name>e</name>-&gt;<name>v</name>.<name>Compare</name>.<name>left</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>n</name> = <call><name>asdl_seq_LEN</name><argument_list>(<argument><expr><name><name>e</name>-&gt;<name>v</name>.<name>Compare</name>.<name>ops</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>n</name> &gt; 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>n</name> &gt; 1</expr>)</condition><then> <block>{
<expr_stmt><expr><name>cleanup</name> = <call><name>compiler_new_block</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>cleanup</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr>0</expr>;</return></then></if>
<expr_stmt><expr><call><name>VISIT</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>,
<argument><expr>(<name>expr_ty</name>)<call><name>asdl_seq_GET</name><argument_list>(<argument><expr><name><name>e</name>-&gt;<name>v</name>.<name>Compare</name>.<name>comparators</name></name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<for>for (<init><expr><name>i</name> = 1</expr>;</init> <condition><expr><name>i</name> &lt; <name>n</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
<expr_stmt><expr><call><name>ADDOP</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>DUP_TOP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ADDOP</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>ROT_THREE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ADDOP_I</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>COMPARE_OP</name></expr></argument>,
<argument><expr><call><name>cmpop</name><argument_list>(<argument><expr><call>(<name>cmpop_ty</name>)<argument_list>(<argument><expr><call><name>asdl_seq_GET</name><argument_list>(
<argument><expr><name><name>e</name>-&gt;<name>v</name>.<name>Compare</name>.<name>ops</name></name></expr></argument>, <argument><expr><name>i</name> - 1</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ADDOP_JREL</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>JUMP_IF_FALSE</name></expr></argument>, <argument><expr><name>cleanup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>NEXT_BLOCK</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ADDOP</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>POP_TOP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>i</name> &lt; (<name>n</name> - 1)</expr>)</condition><then>
<expr_stmt><expr><call><name>VISIT</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>,
<argument><expr>(<name>expr_ty</name>)<call><name>asdl_seq_GET</name><argument_list>(<argument><expr><name><name>e</name>-&gt;<name>v</name>.<name>Compare</name>.<name>comparators</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
}</block></for>
<expr_stmt><expr><call><name>VISIT</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>, <argument><expr>(<name>expr_ty</name>)<call><name>asdl_seq_GET</name><argument_list>(<argument><expr><name><name>e</name>-&gt;<name>v</name>.<name>Compare</name>.<name>comparators</name></name></expr></argument>, <argument><expr><name>n</name> - 1</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ADDOP_I</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>COMPARE_OP</name></expr></argument>,
<argument><expr><call><name>cmpop</name><argument_list>(<argument><expr><call>(<name>cmpop_ty</name>)<argument_list>(<argument><expr><call><name>asdl_seq_GET</name><argument_list>(<argument><expr><name><name>e</name>-&gt;<name>v</name>.<name>Compare</name>.<name>ops</name></name></expr></argument>, <argument><expr><name>n</name> - 1</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>n</name> &gt; 1</expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>basicblock</name> *</type><name>end</name> <init>= <expr><call><name>compiler_new_block</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>end</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr>0</expr>;</return></then></if>
<expr_stmt><expr><call><name>ADDOP_JREL</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>JUMP_FORWARD</name></expr></argument>, <argument><expr><name>end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>compiler_use_next_block</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>cleanup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ADDOP</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>ROT_TWO</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ADDOP</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>POP_TOP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>compiler_use_next_block</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<return>return <expr>1</expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>compiler_call</name><parameter_list>(<param><decl><type>struct <name>compiler</name> *</type><name>c</name></decl></param>, <param><decl><type><name>expr_ty</name></type> <name>e</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>, <decl><type ref="prev"/><name>code</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>VISIT</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>, <argument><expr><name><name>e</name>-&gt;<name>v</name>.<name>Call</name>.<name>func</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>n</name> = <call><name>asdl_seq_LEN</name><argument_list>(<argument><expr><name><name>e</name>-&gt;<name>v</name>.<name>Call</name>.<name>args</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>VISIT_SEQ</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>, <argument><expr><name><name>e</name>-&gt;<name>v</name>.<name>Call</name>.<name>args</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>e</name>-&gt;<name>v</name>.<name>Call</name>.<name>keywords</name></name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>VISIT_SEQ</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>keyword</name></expr></argument>, <argument><expr><name><name>e</name>-&gt;<name>v</name>.<name>Call</name>.<name>keywords</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>n</name> |= <call><name>asdl_seq_LEN</name><argument_list>(<argument><expr><name><name>e</name>-&gt;<name>v</name>.<name>Call</name>.<name>keywords</name></name></expr></argument>)</argument_list></call> &lt;&lt; 8</expr>;</expr_stmt>
}</block></then></if>
<if>if <condition>(<expr><name><name>e</name>-&gt;<name>v</name>.<name>Call</name>.<name>starargs</name></name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>VISIT</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>, <argument><expr><name><name>e</name>-&gt;<name>v</name>.<name>Call</name>.<name>starargs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>code</name> |= 1</expr>;</expr_stmt>
}</block></then></if>
<if>if <condition>(<expr><name><name>e</name>-&gt;<name>v</name>.<name>Call</name>.<name>kwargs</name></name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>VISIT</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>, <argument><expr><name><name>e</name>-&gt;<name>v</name>.<name>Call</name>.<name>kwargs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>code</name> |= 2</expr>;</expr_stmt>
}</block></then></if>
<switch>switch <condition>(<expr><name>code</name></expr>)</condition> <block>{
<case>case <expr>0</expr>:
<expr_stmt><expr><call><name>ADDOP_I</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>CALL_FUNCTION</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr>1</expr>:
<expr_stmt><expr><call><name>ADDOP_I</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>CALL_FUNCTION_VAR</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr>2</expr>:
<expr_stmt><expr><call><name>ADDOP_I</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>CALL_FUNCTION_KW</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr>3</expr>:
<expr_stmt><expr><call><name>ADDOP_I</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>CALL_FUNCTION_VAR_KW</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</case>}</block></switch>
<return>return <expr>1</expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>compiler_listcomp_generator</name><parameter_list>(<param><decl><type>struct <name>compiler</name> *</type><name>c</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>tmpname</name></decl></param>,
<param><decl><type><name>asdl_seq</name> *</type><name>generators</name></decl></param>, <param><decl><type><name>int</name></type> <name>gen_index</name></decl></param>,
<param><decl><type><name>expr_ty</name></type> <name>elt</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>comprehension_ty</name></type> <name>l</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>basicblock</name> *</type><name>start</name></decl>, *<decl><type ref="prev"/><name>anchor</name></decl>, *<decl><type ref="prev"/><name>skip</name></decl>, *<decl><type ref="prev"/><name>if_cleanup</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>n</name></decl>;</decl_stmt>
<expr_stmt><expr><name>start</name> = <call><name>compiler_new_block</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>skip</name> = <call><name>compiler_new_block</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>if_cleanup</name> = <call><name>compiler_new_block</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>anchor</name> = <call><name>compiler_new_block</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>start</name> == <name>NULL</name> || <name>skip</name> == <name>NULL</name> || <name>if_cleanup</name> == <name>NULL</name> ||
<name>anchor</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr>0</expr>;</return></then></if>
<expr_stmt><expr><name>l</name> = (<name>comprehension_ty</name>)<call><name>asdl_seq_GET</name><argument_list>(<argument><expr><name>generators</name></expr></argument>, <argument><expr><name>gen_index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>VISIT</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>, <argument><expr><name><name>l</name>-&gt;<name>iter</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ADDOP</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>GET_ITER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>compiler_use_next_block</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ADDOP_JREL</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>FOR_ITER</name></expr></argument>, <argument><expr><name>anchor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>NEXT_BLOCK</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>VISIT</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>, <argument><expr><name><name>l</name>-&gt;<name>target</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>n</name> = <call><name>asdl_seq_LEN</name><argument_list>(<argument><expr><name><name>l</name>-&gt;<name>ifs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>n</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
<decl_stmt><decl><type><name>expr_ty</name></type> <name>e</name> <init>= <expr>(<name>expr_ty</name>)<call><name>asdl_seq_GET</name><argument_list>(<argument><expr><name><name>l</name>-&gt;<name>ifs</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>VISIT</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ADDOP_JREL</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>JUMP_IF_FALSE</name></expr></argument>, <argument><expr><name>if_cleanup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>NEXT_BLOCK</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ADDOP</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>POP_TOP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></for>
<if>if <condition>(<expr>++<name>gen_index</name> &lt; <call><name>asdl_seq_LEN</name><argument_list>(<argument><expr><name>generators</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<if>if <condition>(<expr>!<call><name>compiler_listcomp_generator</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>tmpname</name></expr></argument>,
<argument><expr><name>generators</name></expr></argument>, <argument><expr><name>gen_index</name></expr></argument>, <argument><expr><name>elt</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr>0</expr>;</return></then></if></then></if>
<if>if <condition>(<expr><name>gen_index</name> &gt;= <call><name>asdl_seq_LEN</name><argument_list>(<argument><expr><name>generators</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<if>if <condition>(<expr>!<call><name>compiler_nameop</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>tmpname</name></expr></argument>, <argument><expr><name>Load</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr>0</expr>;</return></then></if>
<expr_stmt><expr><call><name>VISIT</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>, <argument><expr><name>elt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ADDOP</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>LIST_APPEND</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>compiler_use_next_block</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>skip</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>n</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
<expr_stmt><expr><call><name>ADDOP_I</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>JUMP_FORWARD</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>i</name> == 0</expr>)</condition><then>
<expr_stmt><expr><call><name>compiler_use_next_block</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>if_cleanup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<expr_stmt><expr><call><name>ADDOP</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>POP_TOP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></for>
<expr_stmt><expr><call><name>ADDOP_JABS</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>JUMP_ABSOLUTE</name></expr></argument>, <argument><expr><name>start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>compiler_use_next_block</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>anchor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>gen_index</name> == 1</expr>)</condition><then>
<if>if <condition>(<expr>!<call><name>compiler_nameop</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>tmpname</name></expr></argument>, <argument><expr><name>Del</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr>0</expr>;</return></then></if></then></if>
<return>return <expr>1</expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>compiler_listcomp</name><parameter_list>(<param><decl><type>struct <name>compiler</name> *</type><name>c</name></decl></param>, <param><decl><type><name>expr_ty</name></type> <name>e</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>identifier</name></type> <name>tmp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>asdl_seq</name> *</type><name>generators</name> <init>= <expr><name><name>e</name>-&gt;<name>v</name>.<name>ListComp</name>.<name>generators</name></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>e</name>-&gt;<name>kind</name></name> == <name>ListComp_kind</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>tmp</name> = <call><name>compiler_new_tmpname</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>tmp</name></expr>)</condition><then>
<return>return <expr>0</expr>;</return></then></if>
<expr_stmt><expr><call><name>ADDOP_I</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>BUILD_LIST</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ADDOP</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>DUP_TOP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>compiler_nameop</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>tmp</name></expr></argument>, <argument><expr><name>Store</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<expr_stmt><expr><name>rc</name> = <call><name>compiler_listcomp_generator</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>tmp</name></expr></argument>, <argument><expr><name>generators</name></expr></argument>, <argument><expr>0</expr></argument>,
<argument><expr><name><name>e</name>-&gt;<name>v</name>.<name>ListComp</name>.<name>elt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>rc</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>compiler_genexp_generator</name><parameter_list>(<param><decl><type>struct <name>compiler</name> *</type><name>c</name></decl></param>,
<param><decl><type><name>asdl_seq</name> *</type><name>generators</name></decl></param>, <param><decl><type><name>int</name></type> <name>gen_index</name></decl></param>,
<param><decl><type><name>expr_ty</name></type> <name>elt</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>comprehension_ty</name></type> <name>ge</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>basicblock</name> *</type><name>start</name></decl>, *<decl><type ref="prev"/><name>anchor</name></decl>, *<decl><type ref="prev"/><name>skip</name></decl>, *<decl><type ref="prev"/><name>if_cleanup</name></decl>, *<decl><type ref="prev"/><name>end</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>n</name></decl>;</decl_stmt>
<expr_stmt><expr><name>start</name> = <call><name>compiler_new_block</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>skip</name> = <call><name>compiler_new_block</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>if_cleanup</name> = <call><name>compiler_new_block</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>anchor</name> = <call><name>compiler_new_block</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>end</name> = <call><name>compiler_new_block</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>start</name> == <name>NULL</name> || <name>skip</name> == <name>NULL</name> || <name>if_cleanup</name> == <name>NULL</name> ||
<name>anchor</name> == <name>NULL</name> || <name>end</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr>0</expr>;</return></then></if>
<expr_stmt><expr><name>ge</name> = (<name>comprehension_ty</name>)<call><name>asdl_seq_GET</name><argument_list>(<argument><expr><name>generators</name></expr></argument>, <argument><expr><name>gen_index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ADDOP_JREL</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>SETUP_LOOP</name></expr></argument>, <argument><expr><name>end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<call><name>compiler_push_fblock</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>LOOP</name></expr></argument>, <argument><expr><name>start</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr>0</expr>;</return></then></if>
<if>if <condition>(<expr><name>gen_index</name> == 0</expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>c</name>-&gt;<name>u</name>-&gt;<name>u_argcount</name></name> = 1</expr>;</expr_stmt>
<expr_stmt><expr><call><name>ADDOP_I</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>LOAD_FAST</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr><call><name>VISIT</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>, <argument><expr><name><name>ge</name>-&gt;<name>iter</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ADDOP</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>GET_ITER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></else></if>
<expr_stmt><expr><call><name>compiler_use_next_block</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ADDOP_JREL</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>FOR_ITER</name></expr></argument>, <argument><expr><name>anchor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>NEXT_BLOCK</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>VISIT</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>, <argument><expr><name><name>ge</name>-&gt;<name>target</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>n</name> = <call><name>asdl_seq_LEN</name><argument_list>(<argument><expr><name><name>ge</name>-&gt;<name>ifs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>n</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
<decl_stmt><decl><type><name>expr_ty</name></type> <name>e</name> <init>= <expr>(<name>expr_ty</name>)<call><name>asdl_seq_GET</name><argument_list>(<argument><expr><name><name>ge</name>-&gt;<name>ifs</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>VISIT</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ADDOP_JREL</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>JUMP_IF_FALSE</name></expr></argument>, <argument><expr><name>if_cleanup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>NEXT_BLOCK</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ADDOP</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>POP_TOP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></for>
<if>if <condition>(<expr>++<name>gen_index</name> &lt; <call><name>asdl_seq_LEN</name><argument_list>(<argument><expr><name>generators</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<if>if <condition>(<expr>!<call><name>compiler_genexp_generator</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>generators</name></expr></argument>, <argument><expr><name>gen_index</name></expr></argument>, <argument><expr><name>elt</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr>0</expr>;</return></then></if></then></if>
<if>if <condition>(<expr><name>gen_index</name> &gt;= <call><name>asdl_seq_LEN</name><argument_list>(<argument><expr><name>generators</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>VISIT</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>, <argument><expr><name>elt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ADDOP</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>YIELD_VALUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ADDOP</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>POP_TOP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>compiler_use_next_block</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>skip</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>n</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
<expr_stmt><expr><call><name>ADDOP_I</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>JUMP_FORWARD</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>i</name> == 0</expr>)</condition><then>
<expr_stmt><expr><call><name>compiler_use_next_block</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>if_cleanup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<expr_stmt><expr><call><name>ADDOP</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>POP_TOP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></for>
<expr_stmt><expr><call><name>ADDOP_JABS</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>JUMP_ABSOLUTE</name></expr></argument>, <argument><expr><name>start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>compiler_use_next_block</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>anchor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ADDOP</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>POP_BLOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>compiler_pop_fblock</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>LOOP</name></expr></argument>, <argument><expr><name>start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>compiler_use_next_block</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>1</expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>compiler_genexp</name><parameter_list>(<param><decl><type>struct <name>compiler</name> *</type><name>c</name></decl></param>, <param><decl><type><name>expr_ty</name></type> <name>e</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><specifier>static</specifier> <name>identifier</name></type> <name>name</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyCodeObject</name> *</type><name>co</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>expr_ty</name></type> <name>outermost_iter</name> <init>= <expr>(<call>(<name>comprehension_ty</name>)
<argument_list>(<argument><expr><call><name>asdl_seq_GET</name><argument_list>(<argument><expr><name><name>e</name>-&gt;<name>v</name>.<name>GeneratorExp</name>.<name>generators</name></name></expr></argument>,
<argument><expr>0</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>)-&gt;<name>iter</name></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr>!<name>name</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>name</name> = <call><name>PyString_FromString</name><argument_list>(<argument><expr>"&lt;genexpr&gt;"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>name</name></expr>)</condition><then>
<return>return <expr>0</expr>;</return></then></if>
}</block></then></if>
<if>if <condition>(<expr>!<call><name>compiler_enter_scope</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr>(<name>void</name> *)<name>e</name></expr></argument>, <argument><expr><name><name>e</name>-&gt;<name>lineno</name></name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr>0</expr>;</return></then></if>
<expr_stmt><expr><call><name>compiler_genexp_generator</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name><name>e</name>-&gt;<name>v</name>.<name>GeneratorExp</name>.<name>generators</name></name></expr></argument>, <argument><expr>0</expr></argument>,
<argument><expr><name><name>e</name>-&gt;<name>v</name>.<name>GeneratorExp</name>.<name>elt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>co</name> = <call><name>assemble</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>compiler_exit_scope</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>co</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr>0</expr>;</return></then></if>
<expr_stmt><expr><call><name>compiler_make_closure</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>co</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>co</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>VISIT</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>, <argument><expr><name>outermost_iter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ADDOP</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>GET_ITER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ADDOP_I</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>CALL_FUNCTION</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>1</expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>compiler_visit_keyword</name><parameter_list>(<param><decl><type>struct <name>compiler</name> *</type><name>c</name></decl></param>, <param><decl><type><name>keyword_ty</name></type> <name>k</name></decl></param>)</parameter_list> <block>{
<expr_stmt><expr><call><name>ADDOP_O</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>LOAD_CONST</name></expr></argument>, <argument><expr><name><name>k</name>-&gt;<name>arg</name></name></expr></argument>, <argument><expr><name>consts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>VISIT</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>, <argument><expr><name><name>k</name>-&gt;<name>value</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>1</expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>expr_constant</name><parameter_list>(<param><decl><type><name>expr_ty</name></type> <name>e</name></decl></param>)</parameter_list> <block>{
<switch>switch <condition>(<expr><name><name>e</name>-&gt;<name>kind</name></name></expr>)</condition> <block>{
<case>case <expr><name>Num_kind</name></expr>:
<return>return <expr><call><name>PyObject_IsTrue</name><argument_list>(<argument><expr><name><name>e</name>-&gt;<name>v</name>.<name>Num</name>.<name>n</name></name></expr></argument>)</argument_list></call></expr>;</return>
</case><case>case <expr><name>Str_kind</name></expr>:
<return>return <expr><call><name>PyObject_IsTrue</name><argument_list>(<argument><expr><name><name>e</name>-&gt;<name>v</name>.<name>Str</name>.<name>s</name></name></expr></argument>)</argument_list></call></expr>;</return>
</case><case>case <expr><name>Name_kind</name></expr>:
<if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name><name>e</name>-&gt;<name>v</name>.<name>Name</name>.<name>id</name></name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr>"__debug__"</expr></argument>)</argument_list></call> == 0</expr>)</condition><then>
<return>return <expr>! <name>Py_OptimizeFlag</name></expr>;</return></then></if>
</case><default>default:
<return>return <expr>-1</expr>;</return>
</default>}</block></switch>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>compiler_with</name><parameter_list>(<param><decl><type>struct <name>compiler</name> *</type><name>c</name></decl></param>, <param><decl><type><name>stmt_ty</name></type> <name>s</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><specifier>static</specifier> <name>identifier</name></type> <name>enter_attr</name></decl>, <decl><type ref="prev"/><name>exit_attr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>basicblock</name> *</type><name>block</name></decl>, *<decl><type ref="prev"/><name>finally</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>identifier</name></type> <name>tmpvalue</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>s</name>-&gt;<name>kind</name></name> == <name>With_kind</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>enter_attr</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>enter_attr</name> = <call><name>PyString_InternFromString</name><argument_list>(<argument><expr>"__enter__"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>enter_attr</name></expr>)</condition><then>
<return>return <expr>0</expr>;</return></then></if>
}</block></then></if>
<if>if <condition>(<expr>!<name>exit_attr</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>exit_attr</name> = <call><name>PyString_InternFromString</name><argument_list>(<argument><expr>"__exit__"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>exit_attr</name></expr>)</condition><then>
<return>return <expr>0</expr>;</return></then></if>
}</block></then></if>
<expr_stmt><expr><name>block</name> = <call><name>compiler_new_block</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>finally</name> = <call><name>compiler_new_block</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>block</name> || !<name>finally</name></expr>)</condition><then>
<return>return <expr>0</expr>;</return></then></if>
<if>if <condition>(<expr><name><name>s</name>-&gt;<name>v</name>.<name>With</name>.<name>optional_vars</name></name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>tmpvalue</name> = <call><name>compiler_new_tmpname</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>tmpvalue</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr>0</expr>;</return></then></if>
<expr_stmt><expr><call><name>PyArena_AddPyObject</name><argument_list>(<argument><expr><name><name>c</name>-&gt;<name>c_arena</name></name></expr></argument>, <argument><expr><name>tmpvalue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><call><name>VISIT</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>v</name>.<name>With</name>.<name>context_expr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ADDOP</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>DUP_TOP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ADDOP_O</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>LOAD_ATTR</name></expr></argument>, <argument><expr><name>exit_attr</name></expr></argument>, <argument><expr><name>names</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ADDOP</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>ROT_TWO</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ADDOP_O</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>LOAD_ATTR</name></expr></argument>, <argument><expr><name>enter_attr</name></expr></argument>, <argument><expr><name>names</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ADDOP_I</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>CALL_FUNCTION</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>s</name>-&gt;<name>v</name>.<name>With</name>.<name>optional_vars</name></name></expr>)</condition><then> <block>{
<if>if <condition>(<expr>!<call><name>compiler_nameop</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>tmpvalue</name></expr></argument>, <argument><expr><name>Store</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr>0</expr>;</return></then></if>
}</block></then> <else>else <block>{
<expr_stmt><expr><call><name>ADDOP</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>POP_TOP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></else></if>
<expr_stmt><expr><call><name>ADDOP_JREL</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>SETUP_FINALLY</name></expr></argument>, <argument><expr><name>finally</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>compiler_use_next_block</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>block</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<call><name>compiler_push_fblock</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>FINALLY_TRY</name></expr></argument>, <argument><expr><name>block</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<return>return <expr>0</expr>;</return>
}</block></then></if>
<if>if <condition>(<expr><name><name>s</name>-&gt;<name>v</name>.<name>With</name>.<name>optional_vars</name></name></expr>)</condition><then> <block>{
<if>if <condition>(<expr>!<call><name>compiler_nameop</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>tmpvalue</name></expr></argument>, <argument><expr><name>Load</name></expr></argument>)</argument_list></call> ||
!<call><name>compiler_nameop</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>tmpvalue</name></expr></argument>, <argument><expr><name>Del</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr>0</expr>;</return></then></if>
<expr_stmt><expr><call><name>VISIT</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>v</name>.<name>With</name>.<name>optional_vars</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><call><name>VISIT_SEQ</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>stmt</name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>v</name>.<name>With</name>.<name>body</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ADDOP</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>POP_BLOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>compiler_pop_fblock</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>FINALLY_TRY</name></expr></argument>, <argument><expr><name>block</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ADDOP_O</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>LOAD_CONST</name></expr></argument>, <argument><expr><name>Py_None</name></expr></argument>, <argument><expr><name>consts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>compiler_use_next_block</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>finally</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<call><name>compiler_push_fblock</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>FINALLY_END</name></expr></argument>, <argument><expr><name>finally</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr>0</expr>;</return></then></if>
<expr_stmt><expr><call><name>ADDOP</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>WITH_CLEANUP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ADDOP</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>END_FINALLY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>compiler_pop_fblock</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>FINALLY_END</name></expr></argument>, <argument><expr><name>finally</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>1</expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>compiler_visit_expr</name><parameter_list>(<param><decl><type>struct <name>compiler</name> *</type><name>c</name></decl></param>, <param><decl><type><name>expr_ty</name></type> <name>e</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>n</name></decl>;</decl_stmt>
<if>if <condition>(<expr><name><name>e</name>-&gt;<name>lineno</name></name> &gt; <name><name>c</name>-&gt;<name>u</name>-&gt;<name>u_lineno</name></name></expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>c</name>-&gt;<name>u</name>-&gt;<name>u_lineno</name></name> = <name><name>e</name>-&gt;<name>lineno</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>c</name>-&gt;<name>u</name>-&gt;<name>u_lineno_set</name></name> = <name>false</name></expr>;</expr_stmt>
}</block></then></if>
<switch>switch <condition>(<expr><name><name>e</name>-&gt;<name>kind</name></name></expr>)</condition> <block>{
<case>case <expr><name>BoolOp_kind</name></expr>:
<return>return <expr><call><name>compiler_boolop</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</return>
</case><case>case <expr><name>BinOp_kind</name></expr>:
<expr_stmt><expr><call><name>VISIT</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>, <argument><expr><name><name>e</name>-&gt;<name>v</name>.<name>BinOp</name>.<name>left</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>VISIT</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>, <argument><expr><name><name>e</name>-&gt;<name>v</name>.<name>BinOp</name>.<name>right</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ADDOP</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><call><name>binop</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name><name>e</name>-&gt;<name>v</name>.<name>BinOp</name>.<name>op</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr><name>UnaryOp_kind</name></expr>:
<expr_stmt><expr><call><name>VISIT</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>, <argument><expr><name><name>e</name>-&gt;<name>v</name>.<name>UnaryOp</name>.<name>operand</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ADDOP</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><call><name>unaryop</name><argument_list>(<argument><expr><name><name>e</name>-&gt;<name>v</name>.<name>UnaryOp</name>.<name>op</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr><name>Lambda_kind</name></expr>:
<return>return <expr><call><name>compiler_lambda</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</return>
</case><case>case <expr><name>IfExp_kind</name></expr>:
<return>return <expr><call><name>compiler_ifexp</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</return>
</case><case>case <expr><name>Dict_kind</name></expr>:
<expr_stmt><expr><name>n</name> = <call><name>asdl_seq_LEN</name><argument_list>(<argument><expr><name><name>e</name>-&gt;<name>v</name>.<name>Dict</name>.<name>values</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ADDOP_I</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>BUILD_MAP</name></expr></argument>, <argument><expr>(<name>n</name>&gt;0xFFFF ? 0xFFFF : <name>n</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>n</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
<expr_stmt><expr><call><name>VISIT</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>,
<argument><expr>(<name>expr_ty</name>)<call><name>asdl_seq_GET</name><argument_list>(<argument><expr><name><name>e</name>-&gt;<name>v</name>.<name>Dict</name>.<name>values</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>VISIT</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>,
<argument><expr>(<name>expr_ty</name>)<call><name>asdl_seq_GET</name><argument_list>(<argument><expr><name><name>e</name>-&gt;<name>v</name>.<name>Dict</name>.<name>keys</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ADDOP</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>STORE_MAP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></for>
<break>break;</break>
</case><case>case <expr><name>ListComp_kind</name></expr>:
<return>return <expr><call><name>compiler_listcomp</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</return>
</case><case>case <expr><name>GeneratorExp_kind</name></expr>:
<return>return <expr><call><name>compiler_genexp</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</return>
</case><case>case <expr><name>Yield_kind</name></expr>:
<if>if <condition>(<expr><name><name>c</name>-&gt;<name>u</name>-&gt;<name>u_ste</name>-&gt;<name>ste_type</name></name> != <name>FunctionBlock</name></expr>)</condition><then>
<return>return <expr><call><name>compiler_error</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr>"'yield' outside function"</expr></argument>)</argument_list></call></expr>;</return></then></if>
<if>if <condition>(<expr><name><name>e</name>-&gt;<name>v</name>.<name>Yield</name>.<name>value</name></name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>VISIT</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>, <argument><expr><name><name>e</name>-&gt;<name>v</name>.<name>Yield</name>.<name>value</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr><call><name>ADDOP_O</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>LOAD_CONST</name></expr></argument>, <argument><expr><name>Py_None</name></expr></argument>, <argument><expr><name>consts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></else></if>
<expr_stmt><expr><call><name>ADDOP</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>YIELD_VALUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr><name>Compare_kind</name></expr>:
<return>return <expr><call><name>compiler_compare</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</return>
</case><case>case <expr><name>Call_kind</name></expr>:
<return>return <expr><call><name>compiler_call</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</return>
</case><case>case <expr><name>Repr_kind</name></expr>:
<expr_stmt><expr><call><name>VISIT</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>, <argument><expr><name><name>e</name>-&gt;<name>v</name>.<name>Repr</name>.<name>value</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ADDOP</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>UNARY_CONVERT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr><name>Num_kind</name></expr>:
<expr_stmt><expr><call><name>ADDOP_O</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>LOAD_CONST</name></expr></argument>, <argument><expr><name><name>e</name>-&gt;<name>v</name>.<name>Num</name>.<name>n</name></name></expr></argument>, <argument><expr><name>consts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr><name>Str_kind</name></expr>:
<expr_stmt><expr><call><name>ADDOP_O</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>LOAD_CONST</name></expr></argument>, <argument><expr><name><name>e</name>-&gt;<name>v</name>.<name>Str</name>.<name>s</name></name></expr></argument>, <argument><expr><name>consts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr><name>Attribute_kind</name></expr>:
<if>if <condition>(<expr><name><name>e</name>-&gt;<name>v</name>.<name>Attribute</name>.<name>ctx</name></name> != <name>AugStore</name></expr>)</condition><then>
<expr_stmt><expr><call><name>VISIT</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>, <argument><expr><name><name>e</name>-&gt;<name>v</name>.<name>Attribute</name>.<name>value</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<switch>switch <condition>(<expr><name><name>e</name>-&gt;<name>v</name>.<name>Attribute</name>.<name>ctx</name></name></expr>)</condition> <block>{
<case>case <expr><name>AugLoad</name></expr>:
<expr_stmt><expr><call><name>ADDOP</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>DUP_TOP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</case><case>case <expr><name>Load</name></expr>:
<expr_stmt><expr><call><name>ADDOP_NAME</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>LOAD_ATTR</name></expr></argument>, <argument><expr><name><name>e</name>-&gt;<name>v</name>.<name>Attribute</name>.<name>attr</name></name></expr></argument>, <argument><expr><name>names</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr><name>AugStore</name></expr>:
<expr_stmt><expr><call><name>ADDOP</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>ROT_TWO</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</case><case>case <expr><name>Store</name></expr>:
<expr_stmt><expr><call><name>ADDOP_NAME</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>STORE_ATTR</name></expr></argument>, <argument><expr><name><name>e</name>-&gt;<name>v</name>.<name>Attribute</name>.<name>attr</name></name></expr></argument>, <argument><expr><name>names</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr><name>Del</name></expr>:
<expr_stmt><expr><call><name>ADDOP_NAME</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>DELETE_ATTR</name></expr></argument>, <argument><expr><name><name>e</name>-&gt;<name>v</name>.<name>Attribute</name>.<name>attr</name></name></expr></argument>, <argument><expr><name>names</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr><name>Param</name></expr>:
</case><default>default:
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_SystemError</name></expr></argument>,
<argument><expr>"param invalid in attribute expression"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>0</expr>;</return>
</default>}</block></switch>
<break>break;</break>
</case><case>case <expr><name>Subscript_kind</name></expr>:
<switch>switch <condition>(<expr><name><name>e</name>-&gt;<name>v</name>.<name>Subscript</name>.<name>ctx</name></name></expr>)</condition> <block>{
<case>case <expr><name>AugLoad</name></expr>:
<expr_stmt><expr><call><name>VISIT</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>, <argument><expr><name><name>e</name>-&gt;<name>v</name>.<name>Subscript</name>.<name>value</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>VISIT_SLICE</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name><name>e</name>-&gt;<name>v</name>.<name>Subscript</name>.<name>slice</name></name></expr></argument>, <argument><expr><name>AugLoad</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr><name>Load</name></expr>:
<expr_stmt><expr><call><name>VISIT</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>, <argument><expr><name><name>e</name>-&gt;<name>v</name>.<name>Subscript</name>.<name>value</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>VISIT_SLICE</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name><name>e</name>-&gt;<name>v</name>.<name>Subscript</name>.<name>slice</name></name></expr></argument>, <argument><expr><name>Load</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr><name>AugStore</name></expr>:
<expr_stmt><expr><call><name>VISIT_SLICE</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name><name>e</name>-&gt;<name>v</name>.<name>Subscript</name>.<name>slice</name></name></expr></argument>, <argument><expr><name>AugStore</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr><name>Store</name></expr>:
<expr_stmt><expr><call><name>VISIT</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>, <argument><expr><name><name>e</name>-&gt;<name>v</name>.<name>Subscript</name>.<name>value</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>VISIT_SLICE</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name><name>e</name>-&gt;<name>v</name>.<name>Subscript</name>.<name>slice</name></name></expr></argument>, <argument><expr><name>Store</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr><name>Del</name></expr>:
<expr_stmt><expr><call><name>VISIT</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>, <argument><expr><name><name>e</name>-&gt;<name>v</name>.<name>Subscript</name>.<name>value</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>VISIT_SLICE</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name><name>e</name>-&gt;<name>v</name>.<name>Subscript</name>.<name>slice</name></name></expr></argument>, <argument><expr><name>Del</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr><name>Param</name></expr>:
</case><default>default:
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_SystemError</name></expr></argument>,
<argument><expr>"param invalid in subscript expression"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>0</expr>;</return>
</default>}</block></switch>
<break>break;</break>
</case><case>case <expr><name>Name_kind</name></expr>:
<return>return <expr><call><name>compiler_nameop</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name><name>e</name>-&gt;<name>v</name>.<name>Name</name>.<name>id</name></name></expr></argument>, <argument><expr><name><name>e</name>-&gt;<name>v</name>.<name>Name</name>.<name>ctx</name></name></expr></argument>)</argument_list></call></expr>;</return>
</case><case>case <expr><name>List_kind</name></expr>:
<return>return <expr><call><name>compiler_list</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</return>
</case><case>case <expr><name>Tuple_kind</name></expr>:
<return>return <expr><call><name>compiler_tuple</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</return>
</case>}</block></switch>
<return>return <expr>1</expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>compiler_augassign</name><parameter_list>(<param><decl><type>struct <name>compiler</name> *</type><name>c</name></decl></param>, <param><decl><type><name>stmt_ty</name></type> <name>s</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>expr_ty</name></type> <name>e</name> <init>= <expr><name><name>s</name>-&gt;<name>v</name>.<name>AugAssign</name>.<name>target</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>expr_ty</name></type> <name>auge</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>s</name>-&gt;<name>kind</name></name> == <name>AugAssign_kind</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<switch>switch <condition>(<expr><name><name>e</name>-&gt;<name>kind</name></name></expr>)</condition> <block>{
<case>case <expr><name>Attribute_kind</name></expr>:
<expr_stmt><expr><name>auge</name> = <call><name>Attribute</name><argument_list>(<argument><expr><name><name>e</name>-&gt;<name>v</name>.<name>Attribute</name>.<name>value</name></name></expr></argument>, <argument><expr><name><name>e</name>-&gt;<name>v</name>.<name>Attribute</name>.<name>attr</name></name></expr></argument>,
<argument><expr><name>AugLoad</name></expr></argument>, <argument><expr><name><name>e</name>-&gt;<name>lineno</name></name></expr></argument>, <argument><expr><name><name>e</name>-&gt;<name>col_offset</name></name></expr></argument>, <argument><expr><name><name>c</name>-&gt;<name>c_arena</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>auge</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr>0</expr>;</return></then></if>
<expr_stmt><expr><call><name>VISIT</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>, <argument><expr><name>auge</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>VISIT</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>v</name>.<name>AugAssign</name>.<name>value</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ADDOP</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><call><name>inplace_binop</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>v</name>.<name>AugAssign</name>.<name>op</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>auge</name>-&gt;<name>v</name>.<name>Attribute</name>.<name>ctx</name></name> = <name>AugStore</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>VISIT</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>, <argument><expr><name>auge</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr><name>Subscript_kind</name></expr>:
<expr_stmt><expr><name>auge</name> = <call><name>Subscript</name><argument_list>(<argument><expr><name><name>e</name>-&gt;<name>v</name>.<name>Subscript</name>.<name>value</name></name></expr></argument>, <argument><expr><name><name>e</name>-&gt;<name>v</name>.<name>Subscript</name>.<name>slice</name></name></expr></argument>,
<argument><expr><name>AugLoad</name></expr></argument>, <argument><expr><name><name>e</name>-&gt;<name>lineno</name></name></expr></argument>, <argument><expr><name><name>e</name>-&gt;<name>col_offset</name></name></expr></argument>, <argument><expr><name><name>c</name>-&gt;<name>c_arena</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>auge</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr>0</expr>;</return></then></if>
<expr_stmt><expr><call><name>VISIT</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>, <argument><expr><name>auge</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>VISIT</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>v</name>.<name>AugAssign</name>.<name>value</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ADDOP</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><call><name>inplace_binop</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>v</name>.<name>AugAssign</name>.<name>op</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>auge</name>-&gt;<name>v</name>.<name>Subscript</name>.<name>ctx</name></name> = <name>AugStore</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>VISIT</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>, <argument><expr><name>auge</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr><name>Name_kind</name></expr>:
<if>if <condition>(<expr>!<call><name>compiler_nameop</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name><name>e</name>-&gt;<name>v</name>.<name>Name</name>.<name>id</name></name></expr></argument>, <argument><expr><name>Load</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr>0</expr>;</return></then></if>
<expr_stmt><expr><call><name>VISIT</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>v</name>.<name>AugAssign</name>.<name>value</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ADDOP</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><call><name>inplace_binop</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>v</name>.<name>AugAssign</name>.<name>op</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>compiler_nameop</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name><name>e</name>-&gt;<name>v</name>.<name>Name</name>.<name>id</name></name></expr></argument>, <argument><expr><name>Store</name></expr></argument>)</argument_list></call></expr>;</return>
</case><default>default:
<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_SystemError</name></expr></argument>,
<argument><expr>"invalid node type (%d) for augmented assignment"</expr></argument>,
<argument><expr><name><name>e</name>-&gt;<name>kind</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>0</expr>;</return>
</default>}</block></switch>
<return>return <expr>1</expr>;</return>
}</block></function>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type>
<name>compiler_push_fblock</name><argument_list>(<argument>struct <expr><name>compiler</name> *<name>c</name></expr></argument>, <argument>enum <expr><name>fblocktype</name> <name>t</name></expr></argument>, <argument><expr><name>basicblock</name> *<name>b</name></expr></argument>)</argument_list> <block>{
<decl_stmt><decl><type>struct <name>fblockinfo</name> *</type><name>f</name></decl>;</decl_stmt>
<if>if <condition>(<expr><name><name>c</name>-&gt;<name>u</name>-&gt;<name>u_nfblocks</name></name> &gt;= <name>CO_MAXBLOCKS</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_SystemError</name></expr></argument>,
<argument><expr>"too many statically nested blocks"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>0</expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>f</name> = &amp;<name><name>c</name>-&gt;<name>u</name>-&gt;<name>u_fblock</name><index>[<expr><name><name>c</name>-&gt;<name>u</name>-&gt;<name>u_nfblocks</name></name>++</expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>f</name>-&gt;<name>fb_type</name></name> = <name>t</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>f</name>-&gt;<name>fb_block</name></name> = <name>b</name></expr>;</expr_stmt>
<return>return <expr>1</expr>;</return>
}</block></decl></decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>void</name></type>
<name>compiler_pop_fblock</name><argument_list>(<argument>struct <expr><name>compiler</name> *<name>c</name></expr></argument>, <argument>enum <expr><name>fblocktype</name> <name>t</name></expr></argument>, <argument><expr><name>basicblock</name> *<name>b</name></expr></argument>)</argument_list> <block>{
<decl_stmt><decl><type>struct <name>compiler_unit</name> *</type><name>u</name> <init>= <expr><name><name>c</name>-&gt;<name>u</name></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>u</name>-&gt;<name>u_nfblocks</name></name> &gt; 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>u</name>-&gt;<name>u_nfblocks</name></name>--</expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>u</name>-&gt;<name>u_fblock</name><index>[<expr><name><name>u</name>-&gt;<name>u_nfblocks</name></name></expr>]</index></name>.<name>fb_type</name> == <name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>u</name>-&gt;<name>u_fblock</name><index>[<expr><name><name>u</name>-&gt;<name>u_nfblocks</name></name></expr>]</index></name>.<name>fb_block</name> == <name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></decl></decl_stmt>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>compiler_in_loop</name><parameter_list>(<param><decl><type>struct <name>compiler</name> *</type><name>c</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type>struct <name>compiler_unit</name> *</type><name>u</name> <init>= <expr><name><name>c</name>-&gt;<name>u</name></name></expr></init></decl>;</decl_stmt>
<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name><name>u</name>-&gt;<name>u_nfblocks</name></name></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>) <block>{
<if>if <condition>(<expr><name><name>u</name>-&gt;<name>u_fblock</name><index>[<expr><name>i</name></expr>]</index></name>.<name>fb_type</name> == <name>LOOP</name></expr>)</condition><then>
<return>return <expr>1</expr>;</return></then></if>
}</block></for>
<return>return <expr>0</expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>compiler_error</name><parameter_list>(<param><decl><type>struct <name>compiler</name> *</type><name>c</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>errstr</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>loc</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>u</name> <init>= <expr><name>NULL</name></expr></init>, *<name>v</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>loc</name> = <call><name>PyErr_ProgramText</name><argument_list>(<argument><expr><name><name>c</name>-&gt;<name>c_filename</name></name></expr></argument>, <argument><expr><name><name>c</name>-&gt;<name>u</name>-&gt;<name>u_lineno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>loc</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>loc</name> = <name>Py_None</name></expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><name>u</name> = <call><name>Py_BuildValue</name><argument_list>(<argument><expr>"(ziOO)"</expr></argument>, <argument><expr><name><name>c</name>-&gt;<name>c_filename</name></name></expr></argument>, <argument><expr><name><name>c</name>-&gt;<name>u</name>-&gt;<name>u_lineno</name></name></expr></argument>,
<argument><expr><name>Py_None</name></expr></argument>, <argument><expr><name>loc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>u</name></expr>)</condition><then>
<goto>goto <name>exit</name>;</goto></then></if>
<expr_stmt><expr><name>v</name> = <call><name>Py_BuildValue</name><argument_list>(<argument><expr>"(zO)"</expr></argument>, <argument><expr><name>errstr</name></expr></argument>, <argument><expr><name>u</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>v</name></expr>)</condition><then>
<goto>goto <name>exit</name>;</goto></then></if>
<expr_stmt><expr><call><name>PyErr_SetObject</name><argument_list>(<argument><expr><name>PyExc_SyntaxError</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<label><name>exit</name>:</label>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>loc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>u</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>0</expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>compiler_handle_subscr</name><parameter_list>(<param><decl><type>struct <name>compiler</name> *</type><name>c</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>kind</name></decl></param>,
<param><decl><type><name>expr_context_ty</name></type> <name>ctx</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>op</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<switch>switch <condition>(<expr><name>ctx</name></expr>)</condition> <block>{
<case>case <expr><name>AugLoad</name></expr>:
</case><case>case <expr><name>Load</name></expr>:
<expr_stmt><expr><name>op</name> = <name>BINARY_SUBSCR</name></expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr><name>AugStore</name></expr>:
</case><case>case <expr><name>Store</name></expr>:
<expr_stmt><expr><name>op</name> = <name>STORE_SUBSCR</name></expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr><name>Del</name></expr>:
<expr_stmt><expr><name>op</name> = <name>DELETE_SUBSCR</name></expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr><name>Param</name></expr>:
<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_SystemError</name></expr></argument>,
<argument><expr>"invalid %s kind %d in subscript\n"</expr></argument>,
<argument><expr><name>kind</name></expr></argument>, <argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>0</expr>;</return>
</case>}</block></switch>
<if>if <condition>(<expr><name>ctx</name> == <name>AugLoad</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>ADDOP_I</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>DUP_TOPX</name></expr></argument>, <argument><expr>2</expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else <if>if <condition>(<expr><name>ctx</name> == <name>AugStore</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>ADDOP</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>ROT_THREE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if></else></if>
<expr_stmt><expr><call><name>ADDOP</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>1</expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>compiler_slice</name><parameter_list>(<param><decl><type>struct <name>compiler</name> *</type><name>c</name></decl></param>, <param><decl><type><name>slice_ty</name></type> <name>s</name></decl></param>, <param><decl><type><name>expr_context_ty</name></type> <name>ctx</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>n</name> <init>= <expr>2</expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>s</name>-&gt;<name>kind</name></name> == <name>Slice_kind</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>s</name>-&gt;<name>v</name>.<name>Slice</name>.<name>lower</name></name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>VISIT</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>v</name>.<name>Slice</name>.<name>lower</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr><call><name>ADDOP_O</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>LOAD_CONST</name></expr></argument>, <argument><expr><name>Py_None</name></expr></argument>, <argument><expr><name>consts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></else></if>
<if>if <condition>(<expr><name><name>s</name>-&gt;<name>v</name>.<name>Slice</name>.<name>upper</name></name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>VISIT</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>v</name>.<name>Slice</name>.<name>upper</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr><call><name>ADDOP_O</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>LOAD_CONST</name></expr></argument>, <argument><expr><name>Py_None</name></expr></argument>, <argument><expr><name>consts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></else></if>
<if>if <condition>(<expr><name><name>s</name>-&gt;<name>v</name>.<name>Slice</name>.<name>step</name></name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>n</name>++</expr>;</expr_stmt>
<expr_stmt><expr><call><name>VISIT</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>v</name>.<name>Slice</name>.<name>step</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><call><name>ADDOP_I</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>BUILD_SLICE</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>1</expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>compiler_simple_slice</name><parameter_list>(<param><decl><type>struct <name>compiler</name> *</type><name>c</name></decl></param>, <param><decl><type><name>slice_ty</name></type> <name>s</name></decl></param>, <param><decl><type><name>expr_context_ty</name></type> <name>ctx</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>op</name> <init>= <expr>0</expr></init>, <name>slice_offset</name> <init>= <expr>0</expr></init>, <name>stack_count</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>s</name>-&gt;<name>v</name>.<name>Slice</name>.<name>step</name></name> == <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>s</name>-&gt;<name>v</name>.<name>Slice</name>.<name>lower</name></name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>slice_offset</name>++</expr>;</expr_stmt>
<expr_stmt><expr><name>stack_count</name>++</expr>;</expr_stmt>
<if>if <condition>(<expr><name>ctx</name> != <name>AugStore</name></expr>)</condition><then>
<expr_stmt><expr><call><name>VISIT</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>v</name>.<name>Slice</name>.<name>lower</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
}</block></then></if>
<if>if <condition>(<expr><name><name>s</name>-&gt;<name>v</name>.<name>Slice</name>.<name>upper</name></name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>slice_offset</name> += 2</expr>;</expr_stmt>
<expr_stmt><expr><name>stack_count</name>++</expr>;</expr_stmt>
<if>if <condition>(<expr><name>ctx</name> != <name>AugStore</name></expr>)</condition><then>
<expr_stmt><expr><call><name>VISIT</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>v</name>.<name>Slice</name>.<name>upper</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
}</block></then></if>
<if>if <condition>(<expr><name>ctx</name> == <name>AugLoad</name></expr>)</condition><then> <block>{
<switch>switch <condition>(<expr><name>stack_count</name></expr>)</condition> <block>{
<case>case <expr>0</expr>:
<expr_stmt><expr><call><name>ADDOP</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>DUP_TOP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr>1</expr>:
<expr_stmt><expr><call><name>ADDOP_I</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>DUP_TOPX</name></expr></argument>, <argument><expr>2</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr>2</expr>:
<expr_stmt><expr><call><name>ADDOP_I</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>DUP_TOPX</name></expr></argument>, <argument><expr>3</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</case>}</block></switch>
}</block></then> <else>else <if>if <condition>(<expr><name>ctx</name> == <name>AugStore</name></expr>)</condition><then> <block>{
<switch>switch <condition>(<expr><name>stack_count</name></expr>)</condition> <block>{
<case>case <expr>0</expr>:
<expr_stmt><expr><call><name>ADDOP</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>ROT_TWO</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr>1</expr>:
<expr_stmt><expr><call><name>ADDOP</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>ROT_THREE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr>2</expr>:
<expr_stmt><expr><call><name>ADDOP</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>ROT_FOUR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</case>}</block></switch>
}</block></then></if></else></if>
<switch>switch <condition>(<expr><name>ctx</name></expr>)</condition> <block>{
<case>case <expr><name>AugLoad</name></expr>:
</case><case>case <expr><name>Load</name></expr>:
<expr_stmt><expr><name>op</name> = <name>SLICE</name></expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr><name>AugStore</name></expr>:
</case><case>case <expr><name>Store</name></expr>:
<expr_stmt><expr><name>op</name> = <name>STORE_SLICE</name></expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr><name>Del</name></expr>:
<expr_stmt><expr><name>op</name> = <name>DELETE_SLICE</name></expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr><name>Param</name></expr>:
</case><default>default:
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_SystemError</name></expr></argument>,
<argument><expr>"param invalid in simple slice"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>0</expr>;</return>
</default>}</block></switch>
<expr_stmt><expr><call><name>ADDOP</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>op</name> + <name>slice_offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>1</expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>compiler_visit_nested_slice</name><parameter_list>(<param><decl><type>struct <name>compiler</name> *</type><name>c</name></decl></param>, <param><decl><type><name>slice_ty</name></type> <name>s</name></decl></param>,
<param><decl><type><name>expr_context_ty</name></type> <name>ctx</name></decl></param>)</parameter_list> <block>{
<switch>switch <condition>(<expr><name><name>s</name>-&gt;<name>kind</name></name></expr>)</condition> <block>{
<case>case <expr><name>Ellipsis_kind</name></expr>:
<expr_stmt><expr><call><name>ADDOP_O</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>LOAD_CONST</name></expr></argument>, <argument><expr><name>Py_Ellipsis</name></expr></argument>, <argument><expr><name>consts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr><name>Slice_kind</name></expr>:
<return>return <expr><call><name>compiler_slice</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr>;</return>
</case><case>case <expr><name>Index_kind</name></expr>:
<expr_stmt><expr><call><name>VISIT</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>v</name>.<name>Index</name>.<name>value</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr><name>ExtSlice_kind</name></expr>:
</case><default>default:
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_SystemError</name></expr></argument>,
<argument><expr>"extended slice invalid in nested slice"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>0</expr>;</return>
</default>}</block></switch>
<return>return <expr>1</expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>compiler_visit_slice</name><parameter_list>(<param><decl><type>struct <name>compiler</name> *</type><name>c</name></decl></param>, <param><decl><type><name>slice_ty</name></type> <name>s</name></decl></param>, <param><decl><type><name>expr_context_ty</name></type> <name>ctx</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>char</name> *</type> <name>kindname</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<switch>switch <condition>(<expr><name><name>s</name>-&gt;<name>kind</name></name></expr>)</condition> <block>{
<case>case <expr><name>Index_kind</name></expr>:
<expr_stmt><expr><name>kindname</name> = "index"</expr>;</expr_stmt>
<if>if <condition>(<expr><name>ctx</name> != <name>AugStore</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>VISIT</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>v</name>.<name>Index</name>.<name>value</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<break>break;</break>
</case><case>case <expr><name>Ellipsis_kind</name></expr>:
<expr_stmt><expr><name>kindname</name> = "ellipsis"</expr>;</expr_stmt>
<if>if <condition>(<expr><name>ctx</name> != <name>AugStore</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>ADDOP_O</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>LOAD_CONST</name></expr></argument>, <argument><expr><name>Py_Ellipsis</name></expr></argument>, <argument><expr><name>consts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<break>break;</break>
</case><case>case <expr><name>Slice_kind</name></expr>:
<expr_stmt><expr><name>kindname</name> = "slice"</expr>;</expr_stmt>
<if>if <condition>(<expr>!<name><name>s</name>-&gt;<name>v</name>.<name>Slice</name>.<name>step</name></name></expr>)</condition><then>
<return>return <expr><call><name>compiler_simple_slice</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
<if>if <condition>(<expr><name>ctx</name> != <name>AugStore</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr>!<call><name>compiler_slice</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr>0</expr>;</return></then></if>
}</block></then></if>
<break>break;</break>
</case><case>case <expr><name>ExtSlice_kind</name></expr>:
<expr_stmt><expr><name>kindname</name> = "extended slice"</expr>;</expr_stmt>
<if>if <condition>(<expr><name>ctx</name> != <name>AugStore</name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>n</name> <init>= <expr><call><name>asdl_seq_LEN</name><argument_list>(<argument><expr><name><name>s</name>-&gt;<name>v</name>.<name>ExtSlice</name>.<name>dims</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>n</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
<decl_stmt><decl><type><name>slice_ty</name></type> <name>sub</name> <init>= <expr>(<name>slice_ty</name>)<call><name>asdl_seq_GET</name><argument_list>(
<argument><expr><name><name>s</name>-&gt;<name>v</name>.<name>ExtSlice</name>.<name>dims</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>compiler_visit_nested_slice</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>sub</name></expr></argument>, <argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr>0</expr>;</return></then></if>
}</block></for>
<expr_stmt><expr><call><name>ADDOP_I</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>BUILD_TUPLE</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<break>break;</break>
</case><default>default:
<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_SystemError</name></expr></argument>,
<argument><expr>"invalid subscript kind %d"</expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>kind</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>0</expr>;</return>
</default>}</block></switch>
<return>return <expr><call><name>compiler_handle_subscr</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>kindname</name></expr></argument>, <argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<struct>struct <name>assembler</name> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>a_bytecode</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>a_offset</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>a_nblocks</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>basicblock</name> **</type><name>a_postorder</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>a_lnotab</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>a_lnotab_off</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>a_lineno</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>a_lineno_off</name></decl>;</decl_stmt>
}</block>;</struct>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>dfs</name><parameter_list>(<param><decl><type>struct <name>compiler</name> *</type><name>c</name></decl></param>, <param><decl><type><name>basicblock</name> *</type><name>b</name></decl></param>, <param><decl><type>struct <name>assembler</name> *</type><name>a</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type>struct <name>instr</name> *</type><name>instr</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name><name>b</name>-&gt;<name>b_seen</name></name></expr>)</condition><then>
<return>return;</return></then></if>
<expr_stmt><expr><name><name>b</name>-&gt;<name>b_seen</name></name> = 1</expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>b</name>-&gt;<name>b_next</name></name> != <name>NULL</name></expr>)</condition><then>
<expr_stmt><expr><call><name>dfs</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name><name>b</name>-&gt;<name>b_next</name></name></expr></argument>, <argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name><name>b</name>-&gt;<name>b_iused</name></name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
<expr_stmt><expr><name>instr</name> = &amp;<name><name>b</name>-&gt;<name>b_instr</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>instr</name>-&gt;<name>i_jrel</name></name> || <name><name>instr</name>-&gt;<name>i_jabs</name></name></expr>)</condition><then>
<expr_stmt><expr><call><name>dfs</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name><name>instr</name>-&gt;<name>i_target</name></name></expr></argument>, <argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
}</block></for>
<expr_stmt><expr><name><name>a</name>-&gt;<name>a_postorder</name><index>[<expr><name><name>a</name>-&gt;<name>a_nblocks</name></name>++</expr>]</index></name> = <name>b</name></expr>;</expr_stmt>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>stackdepth_walk</name><parameter_list>(<param><decl><type>struct <name>compiler</name> *</type><name>c</name></decl></param>, <param><decl><type><name>basicblock</name> *</type><name>b</name></decl></param>, <param><decl><type><name>int</name></type> <name>depth</name></decl></param>, <param><decl><type><name>int</name></type> <name>maxdepth</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type>struct <name>instr</name> *</type><name>instr</name></decl>;</decl_stmt>
<if>if <condition>(<expr><name><name>b</name>-&gt;<name>b_seen</name></name> || <name><name>b</name>-&gt;<name>b_startdepth</name></name> &gt;= <name>depth</name></expr>)</condition><then>
<return>return <expr><name>maxdepth</name></expr>;</return></then></if>
<expr_stmt><expr><name><name>b</name>-&gt;<name>b_seen</name></name> = 1</expr>;</expr_stmt>
<expr_stmt><expr><name><name>b</name>-&gt;<name>b_startdepth</name></name> = <name>depth</name></expr>;</expr_stmt>
<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name><name>b</name>-&gt;<name>b_iused</name></name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
<expr_stmt><expr><name>instr</name> = &amp;<name><name>b</name>-&gt;<name>b_instr</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name>depth</name> += <call><name>opcode_stack_effect</name><argument_list>(<argument><expr><name><name>instr</name>-&gt;<name>i_opcode</name></name></expr></argument>, <argument><expr><name><name>instr</name>-&gt;<name>i_oparg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>depth</name> &gt; <name>maxdepth</name></expr>)</condition><then>
<expr_stmt><expr><name>maxdepth</name> = <name>depth</name></expr>;</expr_stmt></then></if>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>depth</name> &gt;= 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>instr</name>-&gt;<name>i_jrel</name></name> || <name><name>instr</name>-&gt;<name>i_jabs</name></name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>maxdepth</name> = <call><name>stackdepth_walk</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name><name>instr</name>-&gt;<name>i_target</name></name></expr></argument>,
<argument><expr><name>depth</name></expr></argument>, <argument><expr><name>maxdepth</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>instr</name>-&gt;<name>i_opcode</name></name> == <name>JUMP_ABSOLUTE</name> ||
<name><name>instr</name>-&gt;<name>i_opcode</name></name> == <name>JUMP_FORWARD</name></expr>)</condition><then> <block>{
<goto>goto <name>out</name>;</goto>
}</block></then></if>
}</block></then></if>
}</block></for>
<if>if <condition>(<expr><name><name>b</name>-&gt;<name>b_next</name></name></expr>)</condition><then>
<expr_stmt><expr><name>maxdepth</name> = <call><name>stackdepth_walk</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name><name>b</name>-&gt;<name>b_next</name></name></expr></argument>, <argument><expr><name>depth</name></expr></argument>, <argument><expr><name>maxdepth</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<label><name>out</name>:</label>
<expr_stmt><expr><name><name>b</name>-&gt;<name>b_seen</name></name> = 0</expr>;</expr_stmt>
<return>return <expr><name>maxdepth</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>stackdepth</name><parameter_list>(<param><decl><type>struct <name>compiler</name> *</type><name>c</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>basicblock</name> *</type><name>b</name></decl>, *<decl><type ref="prev"/><name>entryblock</name></decl>;</decl_stmt>
<expr_stmt><expr><name>entryblock</name> = <name>NULL</name></expr>;</expr_stmt>
<for>for (<init><expr><name>b</name> = <name><name>c</name>-&gt;<name>u</name>-&gt;<name>u_blocks</name></name></expr>;</init> <condition><expr><name>b</name> != <name>NULL</name></expr>;</condition> <incr><expr><name>b</name> = <name><name>b</name>-&gt;<name>b_list</name></name></expr></incr>) <block>{
<expr_stmt><expr><name><name>b</name>-&gt;<name>b_seen</name></name> = 0</expr>;</expr_stmt>
<expr_stmt><expr><name><name>b</name>-&gt;<name>b_startdepth</name></name> = <name>INT_MIN</name></expr>;</expr_stmt>
<expr_stmt><expr><name>entryblock</name> = <name>b</name></expr>;</expr_stmt>
}</block></for>
<if>if <condition>(<expr>!<name>entryblock</name></expr>)</condition><then>
<return>return <expr>0</expr>;</return></then></if>
<return>return <expr><call><name>stackdepth_walk</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>entryblock</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>assemble_init</name><parameter_list>(<param><decl><type>struct <name>assembler</name> *</type><name>a</name></decl></param>, <param><decl><type><name>int</name></type> <name>nblocks</name></decl></param>, <param><decl><type><name>int</name></type> <name>firstlineno</name></decl></param>)</parameter_list> <block>{
<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument>struct <expr><name>assembler</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>a</name>-&gt;<name>a_lineno</name></name> = <name>firstlineno</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>a</name>-&gt;<name>a_bytecode</name></name> = <call><name>PyString_FromStringAndSize</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>DEFAULT_CODE_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name><name>a</name>-&gt;<name>a_bytecode</name></name></expr>)</condition><then>
<return>return <expr>0</expr>;</return></then></if>
<expr_stmt><expr><name><name>a</name>-&gt;<name>a_lnotab</name></name> = <call><name>PyString_FromStringAndSize</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>DEFAULT_LNOTAB_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name><name>a</name>-&gt;<name>a_lnotab</name></name></expr>)</condition><then>
<return>return <expr>0</expr>;</return></then></if>
<if>if <condition>(<expr><name>nblocks</name> &gt; <name>PY_SIZE_MAX</name> / <sizeof>sizeof<argument_list>(<argument><expr><name>basicblock</name> *</expr></argument>)</argument_list></sizeof></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_NoMemory</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<return>return <expr>0</expr>;</return>
}</block></then></if>
<expr_stmt><expr><name><name>a</name>-&gt;<name>a_postorder</name></name> = (<name>basicblock</name> **)<call><name>PyObject_Malloc</name><argument_list>(
<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>basicblock</name> *</expr></argument>)</argument_list></sizeof> * <name>nblocks</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name><name>a</name>-&gt;<name>a_postorder</name></name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_NoMemory</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<return>return <expr>0</expr>;</return>
}</block></then></if>
<return>return <expr>1</expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>assemble_free</name><parameter_list>(<param><decl><type>struct <name>assembler</name> *</type><name>a</name></decl></param>)</parameter_list> <block>{
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name><name>a</name>-&gt;<name>a_bytecode</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name><name>a</name>-&gt;<name>a_lnotab</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>a</name>-&gt;<name>a_postorder</name></name></expr>)</condition><then>
<expr_stmt><expr><call><name>PyObject_Free</name><argument_list>(<argument><expr><name><name>a</name>-&gt;<name>a_postorder</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>instrsize</name><parameter_list>(<param><decl><type>struct <name>instr</name> *</type><name>instr</name></decl></param>)</parameter_list> <block>{
<if>if <condition>(<expr>!<name><name>instr</name>-&gt;<name>i_hasarg</name></name></expr>)</condition><then>
<return>return <expr>1</expr>;</return></then></if>
<if>if <condition>(<expr><name><name>instr</name>-&gt;<name>i_oparg</name></name> &gt; 0xffff</expr>)</condition><then>
<return>return <expr>6</expr>;</return></then></if>
<return>return <expr>3</expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>blocksize</name><parameter_list>(<param><decl><type><name>basicblock</name> *</type><name>b</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>size</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name><name>b</name>-&gt;<name>b_iused</name></name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
<expr_stmt><expr><name>size</name> += <call><name>instrsize</name><argument_list>(<argument><expr>&amp;<name><name>b</name>-&gt;<name>b_instr</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></for>
<return>return <expr><name>size</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>assemble_lnotab</name><parameter_list>(<param><decl><type>struct <name>assembler</name> *</type><name>a</name></decl></param>, <param><decl><type>struct <name>instr</name> *</type><name>i</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>d_bytecode</name></decl>, <decl><type ref="prev"/><name>d_lineno</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>len</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name> *</type><name>lnotab</name></decl>;</decl_stmt>
<expr_stmt><expr><name>d_bytecode</name> = <name><name>a</name>-&gt;<name>a_offset</name></name> - <name><name>a</name>-&gt;<name>a_lineno_off</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>d_lineno</name> = <name><name>i</name>-&gt;<name>i_lineno</name></name> - <name><name>a</name>-&gt;<name>a_lineno</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>d_bytecode</name> &gt;= 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>d_lineno</name> &gt;= 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if<condition>(<expr><name>d_bytecode</name> == 0 &amp;&amp; <name>d_lineno</name> == 0</expr>)</condition><then>
<return>return <expr>1</expr>;</return></then></if>
<if>if <condition>(<expr><name>d_bytecode</name> &gt; 255</expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>, <decl><type ref="prev"/><name>nbytes</name></decl>, <decl><type ref="prev"/><name>ncodes</name> <init>= <expr><name>d_bytecode</name> / 255</expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>nbytes</name> = <name><name>a</name>-&gt;<name>a_lnotab_off</name></name> + 2 * <name>ncodes</name></expr>;</expr_stmt>
<expr_stmt><expr><name>len</name> = <call><name>PyString_GET_SIZE</name><argument_list>(<argument><expr><name><name>a</name>-&gt;<name>a_lnotab</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>nbytes</name> &gt;= <name>len</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr>(<name>len</name> &lt;= <name>INT_MAX</name> / 2) &amp;&amp; (<name>len</name> * 2 &lt; <name>nbytes</name>)</expr>)</condition><then>
<expr_stmt><expr><name>len</name> = <name>nbytes</name></expr>;</expr_stmt></then>
<else>else <if>if <condition>(<expr><name>len</name> &lt;= <name>INT_MAX</name> / 2</expr>)</condition><then>
<expr_stmt><expr><name>len</name> *= 2</expr>;</expr_stmt></then>
<else>else <block>{
<expr_stmt><expr><call><name>PyErr_NoMemory</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<return>return <expr>0</expr>;</return>
}</block></else></if></else></if>
<if>if <condition>(<expr><call><name>_PyString_Resize</name><argument_list>(<argument><expr>&amp;<name><name>a</name>-&gt;<name>a_lnotab</name></name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
<return>return <expr>0</expr>;</return></then></if>
}</block></then></if>
<expr_stmt><expr><name>lnotab</name> = (<name>unsigned</name> <name>char</name> *)
<call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name><name>a</name>-&gt;<name>a_lnotab</name></name></expr></argument>)</argument_list></call> + <name><name>a</name>-&gt;<name>a_lnotab_off</name></name></expr>;</expr_stmt>
<for>for (<init><expr><name>j</name> = 0</expr>;</init> <condition><expr><name>j</name> &lt; <name>ncodes</name></expr>;</condition> <incr><expr><name>j</name>++</expr></incr>) <block>{
<expr_stmt><expr>*<name>lnotab</name>++ = 255</expr>;</expr_stmt>
<expr_stmt><expr>*<name>lnotab</name>++ = 0</expr>;</expr_stmt>
}</block></for>
<expr_stmt><expr><name>d_bytecode</name> -= <name>ncodes</name> * 255</expr>;</expr_stmt>
<expr_stmt><expr><name><name>a</name>-&gt;<name>a_lnotab_off</name></name> += <name>ncodes</name> * 2</expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>d_bytecode</name> &lt;= 255</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>d_lineno</name> &gt; 255</expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>, <decl><type ref="prev"/><name>nbytes</name></decl>, <decl><type ref="prev"/><name>ncodes</name> <init>= <expr><name>d_lineno</name> / 255</expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>nbytes</name> = <name><name>a</name>-&gt;<name>a_lnotab_off</name></name> + 2 * <name>ncodes</name></expr>;</expr_stmt>
<expr_stmt><expr><name>len</name> = <call><name>PyString_GET_SIZE</name><argument_list>(<argument><expr><name><name>a</name>-&gt;<name>a_lnotab</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>nbytes</name> &gt;= <name>len</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr>(<name>len</name> &lt;= <name>INT_MAX</name> / 2) &amp;&amp; <name>len</name> * 2 &lt; <name>nbytes</name></expr>)</condition><then>
<expr_stmt><expr><name>len</name> = <name>nbytes</name></expr>;</expr_stmt></then>
<else>else <if>if <condition>(<expr><name>len</name> &lt;= <name>INT_MAX</name> / 2</expr>)</condition><then>
<expr_stmt><expr><name>len</name> *= 2</expr>;</expr_stmt></then>
<else>else <block>{
<expr_stmt><expr><call><name>PyErr_NoMemory</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<return>return <expr>0</expr>;</return>
}</block></else></if></else></if>
<if>if <condition>(<expr><call><name>_PyString_Resize</name><argument_list>(<argument><expr>&amp;<name><name>a</name>-&gt;<name>a_lnotab</name></name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
<return>return <expr>0</expr>;</return></then></if>
}</block></then></if>
<expr_stmt><expr><name>lnotab</name> = (<name>unsigned</name> <name>char</name> *)
<call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name><name>a</name>-&gt;<name>a_lnotab</name></name></expr></argument>)</argument_list></call> + <name><name>a</name>-&gt;<name>a_lnotab_off</name></name></expr>;</expr_stmt>
<expr_stmt><expr>*<name>lnotab</name>++ = <name>d_bytecode</name></expr>;</expr_stmt>
<expr_stmt><expr>*<name>lnotab</name>++ = 255</expr>;</expr_stmt>
<expr_stmt><expr><name>d_bytecode</name> = 0</expr>;</expr_stmt>
<for>for (<init><expr><name>j</name> = 1</expr>;</init> <condition><expr><name>j</name> &lt; <name>ncodes</name></expr>;</condition> <incr><expr><name>j</name>++</expr></incr>) <block>{
<expr_stmt><expr>*<name>lnotab</name>++ = 0</expr>;</expr_stmt>
<expr_stmt><expr>*<name>lnotab</name>++ = 255</expr>;</expr_stmt>
}</block></for>
<expr_stmt><expr><name>d_lineno</name> -= <name>ncodes</name> * 255</expr>;</expr_stmt>
<expr_stmt><expr><name><name>a</name>-&gt;<name>a_lnotab_off</name></name> += <name>ncodes</name> * 2</expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><name>len</name> = <call><name>PyString_GET_SIZE</name><argument_list>(<argument><expr><name><name>a</name>-&gt;<name>a_lnotab</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>a</name>-&gt;<name>a_lnotab_off</name></name> + 2 &gt;= <name>len</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr><call><name>_PyString_Resize</name><argument_list>(<argument><expr>&amp;<name><name>a</name>-&gt;<name>a_lnotab</name></name></expr></argument>, <argument><expr><name>len</name> * 2</expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
<return>return <expr>0</expr>;</return></then></if>
}</block></then></if>
<expr_stmt><expr><name>lnotab</name> = (<name>unsigned</name> <name>char</name> *)
<call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name><name>a</name>-&gt;<name>a_lnotab</name></name></expr></argument>)</argument_list></call> + <name><name>a</name>-&gt;<name>a_lnotab_off</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>a</name>-&gt;<name>a_lnotab_off</name></name> += 2</expr>;</expr_stmt>
<if>if <condition>(<expr><name>d_bytecode</name></expr>)</condition><then> <block>{
<expr_stmt><expr>*<name>lnotab</name>++ = <name>d_bytecode</name></expr>;</expr_stmt>
<expr_stmt><expr>*<name>lnotab</name>++ = <name>d_lineno</name></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr>*<name>lnotab</name>++ = 0</expr>;</expr_stmt>
<expr_stmt><expr>*<name>lnotab</name>++ = <name>d_lineno</name></expr>;</expr_stmt>
}</block></else></if>
<expr_stmt><expr><name><name>a</name>-&gt;<name>a_lineno</name></name> = <name><name>i</name>-&gt;<name>i_lineno</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>a</name>-&gt;<name>a_lineno_off</name></name> = <name><name>a</name>-&gt;<name>a_offset</name></name></expr>;</expr_stmt>
<return>return <expr>1</expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>assemble_emit</name><parameter_list>(<param><decl><type>struct <name>assembler</name> *</type><name>a</name></decl></param>, <param><decl><type>struct <name>instr</name> *</type><name>i</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>size</name></decl>, <decl><type ref="prev"/><name>arg</name> <init>= <expr>0</expr></init>, <name>ext</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>len</name> <init>= <expr><call><name>PyString_GET_SIZE</name><argument_list>(<argument><expr><name><name>a</name>-&gt;<name>a_bytecode</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>code</name></decl>;</decl_stmt>
<expr_stmt><expr><name>size</name> = <call><name>instrsize</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>i</name>-&gt;<name>i_hasarg</name></name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>arg</name> = <name><name>i</name>-&gt;<name>i_oparg</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>ext</name> = <name>arg</name> &gt;&gt; 16</expr>;</expr_stmt>
}</block></then></if>
<if>if <condition>(<expr><name><name>i</name>-&gt;<name>i_lineno</name></name> &amp;&amp; !<call><name>assemble_lnotab</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr>0</expr>;</return></then></if>
<if>if <condition>(<expr><name><name>a</name>-&gt;<name>a_offset</name></name> + <name>size</name> &gt;= <name>len</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr><name>len</name> &gt; <name>PY_SSIZE_T_MAX</name> / 2</expr>)</condition><then>
<return>return <expr>0</expr>;</return></then></if>
<if>if <condition>(<expr><call><name>_PyString_Resize</name><argument_list>(<argument><expr>&amp;<name><name>a</name>-&gt;<name>a_bytecode</name></name></expr></argument>, <argument><expr><name>len</name> * 2</expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
<return>return <expr>0</expr>;</return></then></if>
}</block></then></if>
<expr_stmt><expr><name>code</name> = <call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name><name>a</name>-&gt;<name>a_bytecode</name></name></expr></argument>)</argument_list></call> + <name><name>a</name>-&gt;<name>a_offset</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>a</name>-&gt;<name>a_offset</name></name> += <name>size</name></expr>;</expr_stmt>
<if>if <condition>(<expr><name>size</name> == 6</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>i</name>-&gt;<name>i_hasarg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr>*<name>code</name>++ = (<name>char</name>)<name>EXTENDED_ARG</name></expr>;</expr_stmt>
<expr_stmt><expr>*<name>code</name>++ = <name>ext</name> &amp; 0xff</expr>;</expr_stmt>
<expr_stmt><expr>*<name>code</name>++ = <name>ext</name> &gt;&gt; 8</expr>;</expr_stmt>
<expr_stmt><expr><name>arg</name> &amp;= 0xffff</expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr>*<name>code</name>++ = <name><name>i</name>-&gt;<name>i_opcode</name></name></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>i</name>-&gt;<name>i_hasarg</name></name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>size</name> == 3 || <name>size</name> == 6</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr>*<name>code</name>++ = <name>arg</name> &amp; 0xff</expr>;</expr_stmt>
<expr_stmt><expr>*<name>code</name>++ = <name>arg</name> &gt;&gt; 8</expr>;</expr_stmt>
}</block></then></if>
<return>return <expr>1</expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>assemble_jump_offsets</name><parameter_list>(<param><decl><type>struct <name>assembler</name> *</type><name>a</name></decl></param>, <param><decl><type>struct <name>compiler</name> *</type><name>c</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>basicblock</name> *</type><name>b</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>bsize</name></decl>, <decl><type ref="prev"/><name>totsize</name></decl>, <decl><type ref="prev"/><name>extended_arg_count</name></decl>, <decl><type ref="prev"/><name>last_extended_arg_count</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<label><name>start</name>:</label>
<expr_stmt><expr><name>totsize</name> = 0</expr>;</expr_stmt>
<for>for (<init><expr><name>i</name> = <name><name>a</name>-&gt;<name>a_nblocks</name></name> - 1</expr>;</init> <condition><expr><name>i</name> &gt;= 0</expr>;</condition> <incr><expr><name>i</name>--</expr></incr>) <block>{
<expr_stmt><expr><name>b</name> = <name><name>a</name>-&gt;<name>a_postorder</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name>bsize</name> = <call><name>blocksize</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>b</name>-&gt;<name>b_offset</name></name> = <name>totsize</name></expr>;</expr_stmt>
<expr_stmt><expr><name>totsize</name> += <name>bsize</name></expr>;</expr_stmt>
}</block></for>
<expr_stmt><expr><name>extended_arg_count</name> = 0</expr>;</expr_stmt>
<for>for (<init><expr><name>b</name> = <name><name>c</name>-&gt;<name>u</name>-&gt;<name>u_blocks</name></name></expr>;</init> <condition><expr><name>b</name> != <name>NULL</name></expr>;</condition> <incr><expr><name>b</name> = <name><name>b</name>-&gt;<name>b_list</name></name></expr></incr>) <block>{
<expr_stmt><expr><name>bsize</name> = <name><name>b</name>-&gt;<name>b_offset</name></name></expr>;</expr_stmt>
<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name><name>b</name>-&gt;<name>b_iused</name></name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
<decl_stmt><decl><type>struct <name>instr</name> *</type><name>instr</name> <init>= <expr>&amp;<name><name>b</name>-&gt;<name>b_instr</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>bsize</name> += <call><name>instrsize</name><argument_list>(<argument><expr><name>instr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>instr</name>-&gt;<name>i_jabs</name></name></expr>)</condition><then>
<expr_stmt><expr><name><name>instr</name>-&gt;<name>i_oparg</name></name> = <name><name>instr</name>-&gt;<name>i_target</name>-&gt;<name>b_offset</name></name></expr>;</expr_stmt></then>
<else>else <if>if <condition>(<expr><name><name>instr</name>-&gt;<name>i_jrel</name></name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>delta</name> <init>= <expr><name><name>instr</name>-&gt;<name>i_target</name>-&gt;<name>b_offset</name></name> - <name>bsize</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>instr</name>-&gt;<name>i_oparg</name></name> = <name>delta</name></expr>;</expr_stmt>
}</block></then> <else>else
<continue>continue;</continue></else></if></else></if>
<if>if <condition>(<expr><name><name>instr</name>-&gt;<name>i_oparg</name></name> &gt; 0xffff</expr>)</condition><then>
<expr_stmt><expr><name>extended_arg_count</name>++</expr>;</expr_stmt></then></if>
}</block></for>
}</block></for>
<if>if <condition>(<expr><name>last_extended_arg_count</name> != <name>extended_arg_count</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>last_extended_arg_count</name> = <name>extended_arg_count</name></expr>;</expr_stmt>
<goto>goto <name>start</name>;</goto>
}</block></then></if>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>dict_keys_inorder</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>dict</name></decl></param>, <param><decl><type><name>int</name></type> <name>offset</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>tuple</name></decl>, *<decl><type ref="prev"/><name>k</name></decl>, *<decl><type ref="prev"/><name>v</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>pos</name> <init>= <expr>0</expr></init>, <name>size</name> <init>= <expr><call><name>PyDict_Size</name><argument_list>(<argument><expr><name>dict</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>tuple</name> = <call><name>PyTuple_New</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>tuple</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<while>while <condition>(<expr><call><name>PyDict_Next</name><argument_list>(<argument><expr><name>dict</name></expr></argument>, <argument><expr>&amp;<name>pos</name></expr></argument>, <argument><expr>&amp;<name>k</name></expr></argument>, <argument><expr>&amp;<name>v</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{
<expr_stmt><expr><name>i</name> = <call><name>PyInt_AS_LONG</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>k</name> = <call><name>PyTuple_GET_ITEM</name><argument_list>(<argument><expr><name>k</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>k</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr>(<name>i</name> - <name>offset</name>) &lt; <name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr>(<name>i</name> - <name>offset</name>) &gt;= 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyTuple_SET_ITEM</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>i</name> - <name>offset</name></expr></argument>, <argument><expr><name>k</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></while>
<return>return <expr><name>tuple</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>compute_code_flags</name><parameter_list>(<param><decl><type>struct <name>compiler</name> *</type><name>c</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PySTEntryObject</name> *</type><name>ste</name> <init>= <expr><name><name>c</name>-&gt;<name>u</name>-&gt;<name>u_ste</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>flags</name> <init>= <expr>0</expr></init>, <name>n</name></decl>;</decl_stmt>
<if>if <condition>(<expr><name><name>ste</name>-&gt;<name>ste_type</name></name> != <name>ModuleBlock</name></expr>)</condition><then>
<expr_stmt><expr><name>flags</name> |= <name>CO_NEWLOCALS</name></expr>;</expr_stmt></then></if>
<if>if <condition>(<expr><name><name>ste</name>-&gt;<name>ste_type</name></name> == <name>FunctionBlock</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr>!<name><name>ste</name>-&gt;<name>ste_unoptimized</name></name></expr>)</condition><then>
<expr_stmt><expr><name>flags</name> |= <name>CO_OPTIMIZED</name></expr>;</expr_stmt></then></if>
<if>if <condition>(<expr><name><name>ste</name>-&gt;<name>ste_nested</name></name></expr>)</condition><then>
<expr_stmt><expr><name>flags</name> |= <name>CO_NESTED</name></expr>;</expr_stmt></then></if>
<if>if <condition>(<expr><name><name>ste</name>-&gt;<name>ste_generator</name></name></expr>)</condition><then>
<expr_stmt><expr><name>flags</name> |= <name>CO_GENERATOR</name></expr>;</expr_stmt></then></if>
}</block></then></if>
<if>if <condition>(<expr><name><name>ste</name>-&gt;<name>ste_varargs</name></name></expr>)</condition><then>
<expr_stmt><expr><name>flags</name> |= <name>CO_VARARGS</name></expr>;</expr_stmt></then></if>
<if>if <condition>(<expr><name><name>ste</name>-&gt;<name>ste_varkeywords</name></name></expr>)</condition><then>
<expr_stmt><expr><name>flags</name> |= <name>CO_VARKEYWORDS</name></expr>;</expr_stmt></then></if>
<if>if <condition>(<expr><name><name>ste</name>-&gt;<name>ste_generator</name></name></expr>)</condition><then>
<expr_stmt><expr><name>flags</name> |= <name>CO_GENERATOR</name></expr>;</expr_stmt></then></if>
<expr_stmt><expr><name>flags</name> |= (<name><name>c</name>-&gt;<name>c_flags</name>-&gt;<name>cf_flags</name></name> &amp; <name>PyCF_MASK</name>)</expr>;</expr_stmt>
<expr_stmt><expr><name>n</name> = <call><name>PyDict_Size</name><argument_list>(<argument><expr><name><name>c</name>-&gt;<name>u</name>-&gt;<name>u_freevars</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>n</name> &lt; 0</expr>)</condition><then>
<return>return <expr>-1</expr>;</return></then></if>
<if>if <condition>(<expr><name>n</name> == 0</expr>)</condition><then> <block>{
<expr_stmt><expr><name>n</name> = <call><name>PyDict_Size</name><argument_list>(<argument><expr><name><name>c</name>-&gt;<name>u</name>-&gt;<name>u_cellvars</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>n</name> &lt; 0</expr>)</condition><then>
<return>return <expr>-1</expr>;</return></then></if>
<if>if <condition>(<expr><name>n</name> == 0</expr>)</condition><then> <block>{
<expr_stmt><expr><name>flags</name> |= <name>CO_NOFREE</name></expr>;</expr_stmt>
}</block></then></if>
}</block></then></if>
<return>return <expr><name>flags</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>PyCodeObject</name> *</type>
<name>makecode</name><parameter_list>(<param><decl><type>struct <name>compiler</name> *</type><name>c</name></decl></param>, <param><decl><type>struct <name>assembler</name> *</type><name>a</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>tmp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyCodeObject</name> *</type><name>co</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>consts</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>names</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>varnames</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>filename</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>name</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>freevars</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>cellvars</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>bytecode</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>nlocals</name></decl>, <decl><type ref="prev"/><name>flags</name></decl>;</decl_stmt>
<expr_stmt><expr><name>tmp</name> = <call><name>dict_keys_inorder</name><argument_list>(<argument><expr><name><name>c</name>-&gt;<name>u</name>-&gt;<name>u_consts</name></name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>tmp</name></expr>)</condition><then>
<goto>goto <name>error</name>;</goto></then></if>
<expr_stmt><expr><name>consts</name> = <call><name>PySequence_List</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>names</name> = <call><name>dict_keys_inorder</name><argument_list>(<argument><expr><name><name>c</name>-&gt;<name>u</name>-&gt;<name>u_names</name></name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>varnames</name> = <call><name>dict_keys_inorder</name><argument_list>(<argument><expr><name><name>c</name>-&gt;<name>u</name>-&gt;<name>u_varnames</name></name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>consts</name> || !<name>names</name> || !<name>varnames</name></expr>)</condition><then>
<goto>goto <name>error</name>;</goto></then></if>
<expr_stmt><expr><name>cellvars</name> = <call><name>dict_keys_inorder</name><argument_list>(<argument><expr><name><name>c</name>-&gt;<name>u</name>-&gt;<name>u_cellvars</name></name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>cellvars</name></expr>)</condition><then>
<goto>goto <name>error</name>;</goto></then></if>
<expr_stmt><expr><name>freevars</name> = <call><name>dict_keys_inorder</name><argument_list>(<argument><expr><name><name>c</name>-&gt;<name>u</name>-&gt;<name>u_freevars</name></name></expr></argument>, <argument><expr><call><name>PyTuple_Size</name><argument_list>(<argument><expr><name>cellvars</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>freevars</name></expr>)</condition><then>
<goto>goto <name>error</name>;</goto></then></if>
<expr_stmt><expr><name>filename</name> = <call><name>PyString_FromString</name><argument_list>(<argument><expr><name><name>c</name>-&gt;<name>c_filename</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>filename</name></expr>)</condition><then>
<goto>goto <name>error</name>;</goto></then></if>
<expr_stmt><expr><name>nlocals</name> = <call><name>PyDict_Size</name><argument_list>(<argument><expr><name><name>c</name>-&gt;<name>u</name>-&gt;<name>u_varnames</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>flags</name> = <call><name>compute_code_flags</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>flags</name> &lt; 0</expr>)</condition><then>
<goto>goto <name>error</name>;</goto></then></if>
<expr_stmt><expr><name>bytecode</name> = <call><name>PyCode_Optimize</name><argument_list>(<argument><expr><name><name>a</name>-&gt;<name>a_bytecode</name></name></expr></argument>, <argument><expr><name>consts</name></expr></argument>, <argument><expr><name>names</name></expr></argument>, <argument><expr><name><name>a</name>-&gt;<name>a_lnotab</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>bytecode</name></expr>)</condition><then>
<goto>goto <name>error</name>;</goto></then></if>
<expr_stmt><expr><name>tmp</name> = <call><name>PyList_AsTuple</name><argument_list>(<argument><expr><name>consts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>tmp</name></expr>)</condition><then>
<goto>goto <name>error</name>;</goto></then></if>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>consts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>consts</name> = <name>tmp</name></expr>;</expr_stmt>
<expr_stmt><expr><name>co</name> = <call><name>PyCode_New</name><argument_list>(<argument><expr><name><name>c</name>-&gt;<name>u</name>-&gt;<name>u_argcount</name></name></expr></argument>, <argument><expr><name>nlocals</name></expr></argument>, <argument><expr><call><name>stackdepth</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>flags</name></expr></argument>,
<argument><expr><name>bytecode</name></expr></argument>, <argument><expr><name>consts</name></expr></argument>, <argument><expr><name>names</name></expr></argument>, <argument><expr><name>varnames</name></expr></argument>,
<argument><expr><name>freevars</name></expr></argument>, <argument><expr><name>cellvars</name></expr></argument>,
<argument><expr><name>filename</name></expr></argument>, <argument><expr><name><name>c</name>-&gt;<name>u</name>-&gt;<name>u_name</name></name></expr></argument>,
<argument><expr><name><name>c</name>-&gt;<name>u</name>-&gt;<name>u_firstlineno</name></name></expr></argument>,
<argument><expr><name><name>a</name>-&gt;<name>a_lnotab</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<label><name>error</name>:</label>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>consts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>names</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>varnames</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>freevars</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>cellvars</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>bytecode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>co</name></expr>;</return>
}</block></function>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>0</expr></cpp:if>
static void
dump_instr(const struct instr *i) {
const char *jrel = i-&gt;i_jrel ? "jrel " : "";
const char *jabs = i-&gt;i_jabs ? "jabs " : "";
char arg[128];
*arg = '\0';
if (i-&gt;i_hasarg)
sprintf(arg, "arg: %d ", i-&gt;i_oparg);
fprintf(stderr, "line: %d, opcode: %d %s%s%s\n",
i-&gt;i_lineno, i-&gt;i_opcode, arg, jabs, jrel);
}
static void
dump_basicblock(const basicblock *b) {
const char *seen = b-&gt;b_seen ? "seen " : "";
const char *b_return = b-&gt;b_return ? "return " : "";
fprintf(stderr, "used: %d, depth: %d, offset: %d %s%s\n",
b-&gt;b_iused, b-&gt;b_startdepth, b-&gt;b_offset, seen, b_return);
if (b-&gt;b_instr) {
int i;
for (i = 0; i &lt; b-&gt;b_iused; i++) {
fprintf(stderr, " [%02d] ", i);
dump_instr(b-&gt;b_instr + i);
}
}
}
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<function><type><specifier>static</specifier> <name>PyCodeObject</name> *</type>
<name>assemble</name><parameter_list>(<param><decl><type>struct <name>compiler</name> *</type><name>c</name></decl></param>, <param><decl><type><name>int</name></type> <name>addNone</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>basicblock</name> *</type><name>b</name></decl>, *<decl><type ref="prev"/><name>entryblock</name></decl>;</decl_stmt>
<decl_stmt><decl><type>struct <name>assembler</name></type> <name>a</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>, <decl><type ref="prev"/><name>nblocks</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyCodeObject</name> *</type><name>co</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr>!<name><name>c</name>-&gt;<name>u</name>-&gt;<name>u_curblock</name>-&gt;<name>b_return</name></name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>NEXT_BLOCK</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>addNone</name></expr>)</condition><then>
<expr_stmt><expr><call><name>ADDOP_O</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>LOAD_CONST</name></expr></argument>, <argument><expr><name>Py_None</name></expr></argument>, <argument><expr><name>consts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<expr_stmt><expr><call><name>ADDOP</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>RETURN_VALUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><name>nblocks</name> = 0</expr>;</expr_stmt>
<expr_stmt><expr><name>entryblock</name> = <name>NULL</name></expr>;</expr_stmt>
<for>for (<init><expr><name>b</name> = <name><name>c</name>-&gt;<name>u</name>-&gt;<name>u_blocks</name></name></expr>;</init> <condition><expr><name>b</name> != <name>NULL</name></expr>;</condition> <incr><expr><name>b</name> = <name><name>b</name>-&gt;<name>b_list</name></name></expr></incr>) <block>{
<expr_stmt><expr><name>nblocks</name>++</expr>;</expr_stmt>
<expr_stmt><expr><name>entryblock</name> = <name>b</name></expr>;</expr_stmt>
}</block></for>
<if>if <condition>(<expr>!<name><name>c</name>-&gt;<name>u</name>-&gt;<name>u_firstlineno</name></name></expr>)</condition><then> <block>{
<if>if <condition>(<expr><name>entryblock</name> &amp;&amp; <name><name>entryblock</name>-&gt;<name>b_instr</name></name></expr>)</condition><then>
<expr_stmt><expr><name><name>c</name>-&gt;<name>u</name>-&gt;<name>u_firstlineno</name></name> = <name><name>entryblock</name>-&gt;<name>b_instr</name>-&gt;<name>i_lineno</name></name></expr>;</expr_stmt></then>
<else>else
<expr_stmt><expr><name><name>c</name>-&gt;<name>u</name>-&gt;<name>u_firstlineno</name></name> = 1</expr>;</expr_stmt></else></if>
}</block></then></if>
<if>if <condition>(<expr>!<call><name>assemble_init</name><argument_list>(<argument><expr>&amp;<name>a</name></expr></argument>, <argument><expr><name>nblocks</name></expr></argument>, <argument><expr><name><name>c</name>-&gt;<name>u</name>-&gt;<name>u_firstlineno</name></name></expr></argument>)</argument_list></call></expr>)</condition><then>
<goto>goto <name>error</name>;</goto></then></if>
<expr_stmt><expr><call><name>dfs</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>entryblock</name></expr></argument>, <argument><expr>&amp;<name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assemble_jump_offsets</name><argument_list>(<argument><expr>&amp;<name>a</name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for (<init><expr><name>i</name> = <name><name>a</name>.<name>a_nblocks</name></name> - 1</expr>;</init> <condition><expr><name>i</name> &gt;= 0</expr>;</condition> <incr><expr><name>i</name>--</expr></incr>) <block>{
<expr_stmt><expr><name>b</name> = <name><name>a</name>.<name>a_postorder</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
<for>for (<init><expr><name>j</name> = 0</expr>;</init> <condition><expr><name>j</name> &lt; <name><name>b</name>-&gt;<name>b_iused</name></name></expr>;</condition> <incr><expr><name>j</name>++</expr></incr>)
<if>if <condition>(<expr>!<call><name>assemble_emit</name><argument_list>(<argument><expr>&amp;<name>a</name></expr></argument>, <argument><expr>&amp;<name><name>b</name>-&gt;<name>b_instr</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><then>
<goto>goto <name>error</name>;</goto></then></if></for>
}</block></for>
<if>if <condition>(<expr><call><name>_PyString_Resize</name><argument_list>(<argument><expr>&amp;<name><name>a</name>.<name>a_lnotab</name></name></expr></argument>, <argument><expr><name><name>a</name>.<name>a_lnotab_off</name></name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
<goto>goto <name>error</name>;</goto></then></if>
<if>if <condition>(<expr><call><name>_PyString_Resize</name><argument_list>(<argument><expr>&amp;<name><name>a</name>.<name>a_bytecode</name></name></expr></argument>, <argument><expr><name><name>a</name>.<name>a_offset</name></name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
<goto>goto <name>error</name>;</goto></then></if>
<expr_stmt><expr><name>co</name> = <call><name>makecode</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr>&amp;<name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<label><name>error</name>:</label>
<expr_stmt><expr><call><name>assemble_free</name><argument_list>(<argument><expr>&amp;<name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>co</name></expr>;</return>
}</block></function>
</unit>
