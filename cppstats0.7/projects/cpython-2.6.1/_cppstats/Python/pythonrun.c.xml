<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C" filename="Python/pythonrun.c"><cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"Python.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"Python-ast.h"</cpp:file></cpp:include>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>Yield</name></cpp:undef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"grammar.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"node.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"token.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parsetok.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"errcode.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"code.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"compile.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"symtable.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pyarena.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ast.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"eval.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"marshal.h"</cpp:file></cpp:include>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_SIGNAL_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;signal.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_LANGINFO_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;locale.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;langinfo.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MS_WINDOWS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>BYTE</name></cpp:undef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"windows.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>Py_REF_DEBUG</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PRINT_TOTAL_REFS</name><parameter_list>()</parameter_list></cpp:macro></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PRINT_TOTAL_REFS</name><parameter_list>()</parameter_list></cpp:macro> <cpp:value>fprintf(stderr, "[%" PY_FORMAT_SIZE_T "d refs]\n", _Py_GetRefTotal())</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__cplusplus</name></expr></argument>)</argument_list></call></expr></cpp:if>
<extern>extern "C" <block>{
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<function_decl><type><specifier>extern</specifier> <name>char</name> *</type><name>Py_GetPath</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list>;</function_decl>
<decl_stmt><decl><type><specifier>extern</specifier> <name>grammar</name></type> <name>_PyParser_Grammar</name></decl>;</decl_stmt>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>initmain</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>initsite</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>PyObject</name> *</type><name>run_mod</name><parameter_list>(<param><decl><type><name>mod_ty</name></type></decl></param>, <param><decl><type><specifier>const</specifier></type> <name>char</name> *</decl></param>, <param><decl><type><name>PyObject</name> *</type></decl></param>, <param><decl><type><name>PyObject</name> *</type></decl></param>,
<param><decl><type><name>PyCompilerFlags</name> *</type></decl></param>, <param><decl><type><name>PyArena</name> *</type></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>PyObject</name> *</type><name>run_pyc_file</name><parameter_list>(<param><decl><type><name>FILE</name> *</type></decl></param>, <param><decl><type><specifier>const</specifier></type> <name>char</name> *</decl></param>, <param><decl><type><name>PyObject</name> *</type></decl></param>, <param><decl><type><name>PyObject</name> *</type></decl></param>,
<param><decl><type><name>PyCompilerFlags</name> *</type></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>err_input</name><parameter_list>(<param><decl><type><name>perrdetail</name> *</type></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>initsigs</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>call_sys_exitfunc</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>call_ll_exitfuncs</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><specifier>extern</specifier> <name>void</name></type> <name>_PyUnicode_Init</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><specifier>extern</specifier> <name>void</name></type> <name>_PyUnicode_Fini</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list>;</function_decl>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>WITH_THREAD</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function_decl><type><specifier>extern</specifier> <name>void</name></type> <name>_PyGILState_Init</name><parameter_list>(<param><decl><type><name>PyInterpreterState</name> *</type></decl></param>, <param><decl><type><name>PyThreadState</name> *</type></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><specifier>extern</specifier> <name>void</name></type> <name>_PyGILState_Fini</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<decl_stmt><decl><type><name>int</name></type> <name>Py_DebugFlag</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>Py_VerboseFlag</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>Py_InteractiveFlag</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>Py_InspectFlag</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>Py_NoSiteFlag</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>Py_BytesWarningFlag</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>Py_DontWriteBytecodeFlag</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>Py_UseClassExceptionsFlag</name> <init>= <expr>1</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>Py_FrozenFlag</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>Py_UnicodeFlag</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>Py_IgnoreEnvironmentFlag</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>_Py_QnewFlag</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>Py_NoUserSiteDirectory</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<function><type><name>PyObject</name> *</type>
<name>PyModule_GetWarningsModule</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list> <block>{
<return>return <expr><call><name>PyImport_ImportModule</name><argument_list>(<argument><expr>"warnings"</expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>initialized</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<function><type><name>int</name></type>
<name>Py_IsInitialized</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list> <block>{
<return>return <expr><name>initialized</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>add_flag</name><parameter_list>(<param><decl><type><name>int</name></type> <name>flag</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>envs</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>env</name> <init>= <expr><call><name>atoi</name><argument_list>(<argument><expr><name>envs</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>flag</name> &lt; <name>env</name></expr>)</condition><then>
<expr_stmt><expr><name>flag</name> = <name>env</name></expr>;</expr_stmt></then></if>
<if>if <condition>(<expr><name>flag</name> &lt; 1</expr>)</condition><then>
<expr_stmt><expr><name>flag</name> = 1</expr>;</expr_stmt></then></if>
<return>return <expr><name>flag</name></expr>;</return>
}</block></function>
<function><type><name>void</name></type>
<name>Py_InitializeEx</name><parameter_list>(<param><decl><type><name>int</name></type> <name>install_sigs</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyInterpreterState</name> *</type><name>interp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyThreadState</name> *</type><name>tstate</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>bimod</name></decl>, *<decl><type ref="prev"/><name>sysmod</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>p</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>icodeset</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>codeset</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>errors</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>free_codeset</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>overridden</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>sys_stream</name></decl>, *<decl><type ref="prev"/><name>sys_isatty</name></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>Py_USING_UNICODE</name></expr></argument>)</argument_list></call> &amp;&amp; <call><name>defined</name><argument_list>(<argument><expr><name>HAVE_LANGINFO_H</name></expr></argument>)</argument_list></call> &amp;&amp; <call><name>defined</name><argument_list>(<argument><expr><name>CODESET</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>char</name> *</type><name>saved_locale</name></decl>, *<decl><type ref="prev"/><name>loc_codeset</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MS_WINDOWS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>char</name></type> <name><name>ibuf</name><index>[<expr>128</expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name><name>buf</name><index>[<expr>128</expr>]</index></name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<function_decl><type><specifier>extern</specifier> <name>void</name></type> <name>_Py_ReadyTypes</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list>;</function_decl>
<if>if <condition>(<expr><name>initialized</name></expr>)</condition><then>
<return>return;</return></then></if>
<expr_stmt><expr><name>initialized</name> = 1</expr>;</expr_stmt>
<if>if <condition>(<expr>(<name>p</name> = <call><name>Py_GETENV</name><argument_list>(<argument><expr>"PYTHONDEBUG"</expr></argument>)</argument_list></call>) &amp;&amp; *<name>p</name> != '\0'</expr>)</condition><then>
<expr_stmt><expr><name>Py_DebugFlag</name> = <call><name>add_flag</name><argument_list>(<argument><expr><name>Py_DebugFlag</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<if>if <condition>(<expr>(<name>p</name> = <call><name>Py_GETENV</name><argument_list>(<argument><expr>"PYTHONVERBOSE"</expr></argument>)</argument_list></call>) &amp;&amp; *<name>p</name> != '\0'</expr>)</condition><then>
<expr_stmt><expr><name>Py_VerboseFlag</name> = <call><name>add_flag</name><argument_list>(<argument><expr><name>Py_VerboseFlag</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<if>if <condition>(<expr>(<name>p</name> = <call><name>Py_GETENV</name><argument_list>(<argument><expr>"PYTHONOPTIMIZE"</expr></argument>)</argument_list></call>) &amp;&amp; *<name>p</name> != '\0'</expr>)</condition><then>
<expr_stmt><expr><name>Py_OptimizeFlag</name> = <call><name>add_flag</name><argument_list>(<argument><expr><name>Py_OptimizeFlag</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<if>if <condition>(<expr>(<name>p</name> = <call><name>Py_GETENV</name><argument_list>(<argument><expr>"PYTHONDONTWRITEBYTECODE"</expr></argument>)</argument_list></call>) &amp;&amp; *<name>p</name> != '\0'</expr>)</condition><then>
<expr_stmt><expr><name>Py_DontWriteBytecodeFlag</name> = <call><name>add_flag</name><argument_list>(<argument><expr><name>Py_DontWriteBytecodeFlag</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<expr_stmt><expr><name>interp</name> = <call><name>PyInterpreterState_New</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>interp</name> == <name>NULL</name></expr>)</condition><then>
<expr_stmt><expr><call><name>Py_FatalError</name><argument_list>(<argument><expr>"Py_Initialize: can't make first interpreter"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<expr_stmt><expr><name>tstate</name> = <call><name>PyThreadState_New</name><argument_list>(<argument><expr><name>interp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>tstate</name> == <name>NULL</name></expr>)</condition><then>
<expr_stmt><expr><call><name>Py_FatalError</name><argument_list>(<argument><expr>"Py_Initialize: can't make first thread"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<expr_stmt><expr>(<name>void</name>) <call><name>PyThreadState_Swap</name><argument_list>(<argument><expr><name>tstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>_Py_ReadyTypes</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<call><name>_PyFrame_Init</name><argument_list>()</argument_list></call></expr>)</condition><then>
<expr_stmt><expr><call><name>Py_FatalError</name><argument_list>(<argument><expr>"Py_Initialize: can't init frames"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<if>if <condition>(<expr>!<call><name>_PyInt_Init</name><argument_list>()</argument_list></call></expr>)</condition><then>
<expr_stmt><expr><call><name>Py_FatalError</name><argument_list>(<argument><expr>"Py_Initialize: can't init ints"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<if>if <condition>(<expr>!<call><name>PyByteArray_Init</name><argument_list>()</argument_list></call></expr>)</condition><then>
<expr_stmt><expr><call><name>Py_FatalError</name><argument_list>(<argument><expr>"Py_Initialize: can't init bytearray"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<expr_stmt><expr><call><name>_PyFloat_Init</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>interp</name>-&gt;<name>modules</name></name> = <call><name>PyDict_New</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>interp</name>-&gt;<name>modules</name></name> == <name>NULL</name></expr>)</condition><then>
<expr_stmt><expr><call><name>Py_FatalError</name><argument_list>(<argument><expr>"Py_Initialize: can't make modules dictionary"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<expr_stmt><expr><name><name>interp</name>-&gt;<name>modules_reloading</name></name> = <call><name>PyDict_New</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>interp</name>-&gt;<name>modules_reloading</name></name> == <name>NULL</name></expr>)</condition><then>
<expr_stmt><expr><call><name>Py_FatalError</name><argument_list>(<argument><expr>"Py_Initialize: can't make modules_reloading dictionary"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>Py_USING_UNICODE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>_PyUnicode_Init</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><name>bimod</name> = <call><name>_PyBuiltin_Init</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>bimod</name> == <name>NULL</name></expr>)</condition><then>
<expr_stmt><expr><call><name>Py_FatalError</name><argument_list>(<argument><expr>"Py_Initialize: can't initialize __builtin__"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<expr_stmt><expr><name><name>interp</name>-&gt;<name>builtins</name></name> = <call><name>PyModule_GetDict</name><argument_list>(<argument><expr><name>bimod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>interp</name>-&gt;<name>builtins</name></name> == <name>NULL</name></expr>)</condition><then>
<expr_stmt><expr><call><name>Py_FatalError</name><argument_list>(<argument><expr>"Py_Initialize: can't initialize builtins dict"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name><name>interp</name>-&gt;<name>builtins</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>sysmod</name> = <call><name>_PySys_Init</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>sysmod</name> == <name>NULL</name></expr>)</condition><then>
<expr_stmt><expr><call><name>Py_FatalError</name><argument_list>(<argument><expr>"Py_Initialize: can't initialize sys"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<expr_stmt><expr><name><name>interp</name>-&gt;<name>sysdict</name></name> = <call><name>PyModule_GetDict</name><argument_list>(<argument><expr><name>sysmod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>interp</name>-&gt;<name>sysdict</name></name> == <name>NULL</name></expr>)</condition><then>
<expr_stmt><expr><call><name>Py_FatalError</name><argument_list>(<argument><expr>"Py_Initialize: can't initialize sys dict"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name><name>interp</name>-&gt;<name>sysdict</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>_PyImport_FixupExtension</name><argument_list>(<argument><expr>"sys"</expr></argument>, <argument><expr>"sys"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PySys_SetPath</name><argument_list>(<argument><expr><call><name>Py_GetPath</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyDict_SetItemString</name><argument_list>(<argument><expr><name><name>interp</name>-&gt;<name>sysdict</name></name></expr></argument>, <argument><expr>"modules"</expr></argument>,
<argument><expr><name><name>interp</name>-&gt;<name>modules</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>_PyImport_Init</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>_PyExc_Init</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>_PyImport_FixupExtension</name><argument_list>(<argument><expr>"exceptions"</expr></argument>, <argument><expr>"exceptions"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>_PyImport_FixupExtension</name><argument_list>(<argument><expr>"__builtin__"</expr></argument>, <argument><expr>"__builtin__"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>_PyImportHooks_Init</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>install_sigs</name></expr>)</condition><then>
<expr_stmt><expr><call><name>initsigs</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>
<expr_stmt><expr><call><name>_PyWarnings_Init</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>PySys_HasWarnOptions</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>warnings_module</name> <init>= <expr><call><name>PyImport_ImportModule</name><argument_list>(<argument><expr>"warnings"</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr>!<name>warnings_module</name></expr>)</condition><then>
<expr_stmt><expr><call><name>PyErr_Clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>warnings_module</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><call><name>initmain</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>Py_NoSiteFlag</name></expr>)</condition><then>
<expr_stmt><expr><call><name>initsite</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>WITH_THREAD</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>_PyGILState_Init</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr><name>tstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<if>if <condition>(<expr>(<name>p</name> = <call><name>Py_GETENV</name><argument_list>(<argument><expr>"PYTHONIOENCODING"</expr></argument>)</argument_list></call>) &amp;&amp; *<name>p</name> != '\0'</expr>)</condition><then> <block>{
<expr_stmt><expr><name>p</name> = <name>icodeset</name> = <name>codeset</name> = <call><name>strdup</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>free_codeset</name> = 1</expr>;</expr_stmt>
<expr_stmt><expr><name>errors</name> = <call><name>strchr</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr>':'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>errors</name></expr>)</condition><then> <block>{
<expr_stmt><expr>*<name>errors</name> = '\0'</expr>;</expr_stmt>
<expr_stmt><expr><name>errors</name>++</expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><name>overridden</name> = 1</expr>;</expr_stmt>
}</block></then></if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>Py_USING_UNICODE</name></expr></argument>)</argument_list></call> &amp;&amp; <call><name>defined</name><argument_list>(<argument><expr><name>HAVE_LANGINFO_H</name></expr></argument>)</argument_list></call> &amp;&amp; <call><name>defined</name><argument_list>(<argument><expr><name>CODESET</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if>if <condition>(<expr>!<name>overridden</name> || !<name>Py_FileSystemDefaultEncoding</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>saved_locale</name> = <call><name>strdup</name><argument_list>(<argument><expr><call><name>setlocale</name><argument_list>(<argument><expr><name>LC_CTYPE</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>setlocale</name><argument_list>(<argument><expr><name>LC_CTYPE</name></expr></argument>, <argument><expr>""</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>loc_codeset</name> = <call><name>nl_langinfo</name><argument_list>(<argument><expr><name>CODESET</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>loc_codeset</name> &amp;&amp; *<name>loc_codeset</name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>enc</name> <init>= <expr><call><name>PyCodec_Encoder</name><argument_list>(<argument><expr><name>loc_codeset</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>enc</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>loc_codeset</name> = <call><name>strdup</name><argument_list>(<argument><expr><name>loc_codeset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr><name>loc_codeset</name> = <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyErr_Clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
}</block></else></if>
}</block></then> <else>else
<expr_stmt><expr><name>loc_codeset</name> = <name>NULL</name></expr>;</expr_stmt></else></if>
<expr_stmt><expr><call><name>setlocale</name><argument_list>(<argument><expr><name>LC_CTYPE</name></expr></argument>, <argument><expr><name>saved_locale</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>saved_locale</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>overridden</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>codeset</name> = <name>icodeset</name> = <name>loc_codeset</name></expr>;</expr_stmt>
<expr_stmt><expr><name>free_codeset</name> = 1</expr>;</expr_stmt>
}</block></then></if>
<if>if <condition>(<expr>!<name>Py_FileSystemDefaultEncoding</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>Py_FileSystemDefaultEncoding</name> = <name>loc_codeset</name></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>overridden</name></expr>)</condition><then>
<expr_stmt><expr><name>free_codeset</name> = 0</expr>;</expr_stmt></then></if>
}</block></then></if>
}</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MS_WINDOWS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if>if <condition>(<expr>!<name>overridden</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>icodeset</name> = <name>ibuf</name></expr>;</expr_stmt>
<expr_stmt><expr><name>codeset</name> = <name>buf</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>ibuf</name></expr></argument>, <argument><expr>"cp%d"</expr></argument>, <argument><expr><call><name>GetConsoleCP</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr>"cp%d"</expr></argument>, <argument><expr><call><name>GetConsoleOutputCP</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<if>if <condition>(<expr><name>codeset</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>sys_stream</name> = <call><name>PySys_GetObject</name><argument_list>(<argument><expr>"stdin"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>sys_isatty</name> = <call><name>PyObject_CallMethod</name><argument_list>(<argument><expr><name>sys_stream</name></expr></argument>, <argument><expr>"isatty"</expr></argument>, <argument><expr>""</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>sys_isatty</name></expr>)</condition><then>
<expr_stmt><expr><call><name>PyErr_Clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>
<if>if <condition>(<expr>(<name>overridden</name> ||
(<name>sys_isatty</name> &amp;&amp; <call><name>PyObject_IsTrue</name><argument_list>(<argument><expr><name>sys_isatty</name></expr></argument>)</argument_list></call>)) &amp;&amp;
<call><name>PyFile_Check</name><argument_list>(<argument><expr><name>sys_stream</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<if>if <condition>(<expr>!<call><name>PyFile_SetEncodingAndErrors</name><argument_list>(<argument><expr><name>sys_stream</name></expr></argument>, <argument><expr><name>icodeset</name></expr></argument>, <argument><expr><name>errors</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<expr_stmt><expr><call><name>Py_FatalError</name><argument_list>(<argument><expr>"Cannot set codeset of stdin"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
}</block></then></if>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>sys_isatty</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>sys_stream</name> = <call><name>PySys_GetObject</name><argument_list>(<argument><expr>"stdout"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>sys_isatty</name> = <call><name>PyObject_CallMethod</name><argument_list>(<argument><expr><name>sys_stream</name></expr></argument>, <argument><expr>"isatty"</expr></argument>, <argument><expr>""</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>sys_isatty</name></expr>)</condition><then>
<expr_stmt><expr><call><name>PyErr_Clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>
<if>if <condition>(<expr>(<name>overridden</name> ||
(<name>sys_isatty</name> &amp;&amp; <call><name>PyObject_IsTrue</name><argument_list>(<argument><expr><name>sys_isatty</name></expr></argument>)</argument_list></call>)) &amp;&amp;
<call><name>PyFile_Check</name><argument_list>(<argument><expr><name>sys_stream</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<if>if <condition>(<expr>!<call><name>PyFile_SetEncodingAndErrors</name><argument_list>(<argument><expr><name>sys_stream</name></expr></argument>, <argument><expr><name>codeset</name></expr></argument>, <argument><expr><name>errors</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<expr_stmt><expr><call><name>Py_FatalError</name><argument_list>(<argument><expr>"Cannot set codeset of stdout"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
}</block></then></if>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>sys_isatty</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>sys_stream</name> = <call><name>PySys_GetObject</name><argument_list>(<argument><expr>"stderr"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>sys_isatty</name> = <call><name>PyObject_CallMethod</name><argument_list>(<argument><expr><name>sys_stream</name></expr></argument>, <argument><expr>"isatty"</expr></argument>, <argument><expr>""</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>sys_isatty</name></expr>)</condition><then>
<expr_stmt><expr><call><name>PyErr_Clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>
<if>if<condition>(<expr>(<name>overridden</name> ||
(<name>sys_isatty</name> &amp;&amp; <call><name>PyObject_IsTrue</name><argument_list>(<argument><expr><name>sys_isatty</name></expr></argument>)</argument_list></call>)) &amp;&amp;
<call><name>PyFile_Check</name><argument_list>(<argument><expr><name>sys_stream</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<if>if <condition>(<expr>!<call><name>PyFile_SetEncodingAndErrors</name><argument_list>(<argument><expr><name>sys_stream</name></expr></argument>, <argument><expr><name>codeset</name></expr></argument>, <argument><expr><name>errors</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<expr_stmt><expr><call><name>Py_FatalError</name><argument_list>(<argument><expr>"Cannot set codeset of stderr"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
}</block></then></if>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>sys_isatty</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>free_codeset</name></expr>)</condition><then>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>codeset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
}</block></then></if>
}</block></function>
<function><type><name>void</name></type>
<name>Py_Initialize</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list> <block>{
<expr_stmt><expr><call><name>Py_InitializeEx</name><argument_list>(<argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>COUNT_ALLOCS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function_decl><type><specifier>extern</specifier> <name>void</name></type> <name>dump_counts</name><parameter_list>(<param><decl><type><name>FILE</name>*</type></decl></param>)</parameter_list>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<function><type><name>void</name></type>
<name>Py_Finalize</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyInterpreterState</name> *</type><name>interp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyThreadState</name> *</type><name>tstate</name></decl>;</decl_stmt>
<if>if <condition>(<expr>!<name>initialized</name></expr>)</condition><then>
<return>return;</return></then></if>
<expr_stmt><expr><call><name>call_sys_exitfunc</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>initialized</name> = 0</expr>;</expr_stmt>
<expr_stmt><expr><name>tstate</name> = <call><name>PyThreadState_GET</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>interp</name> = <name><name>tstate</name>-&gt;<name>interp</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyOS_FiniInterrupts</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyType_ClearCache</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyGC_Collect</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>COUNT_ALLOCS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<while>while <condition>(<expr><call><name>PyGC_Collect</name><argument_list>()</argument_list></call> &gt; 0</expr>)</condition>
<empty_stmt>;</empty_stmt></while>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><call><name>PyImport_Cleanup</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>0</expr></cpp:if>
PyGC_Collect();
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><call><name>_PyImport_Fini</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>COUNT_ALLOCS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>dump_counts</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><call><name>PRINT_TOTAL_REFS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>Py_TRACE_REFS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if>if <condition>(<expr><call><name>Py_GETENV</name><argument_list>(<argument><expr>"PYTHONDUMPREFS"</expr></argument>)</argument_list></call></expr>)</condition><then>
<expr_stmt><expr><call><name>_Py_PrintReferences</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><call><name>PyInterpreterState_Clear</name><argument_list>(<argument><expr><name>interp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>_PyExc_Fini</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>WITH_THREAD</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>_PyGILState_Fini</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><call><name>PyThreadState_Swap</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyInterpreterState_Delete</name><argument_list>(<argument><expr><name>interp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyMethod_Fini</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyFrame_Fini</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyCFunction_Fini</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyTuple_Fini</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyList_Fini</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PySet_Fini</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyString_Fini</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyByteArray_Fini</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyInt_Fini</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyFloat_Fini</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyDict_Fini</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>Py_USING_UNICODE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>_PyUnicode_Fini</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><call><name>PyGrammar_RemoveAccelerators</name><argument_list>(<argument><expr>&amp;<name>_PyParser_Grammar</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>Py_TRACE_REFS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if>if <condition>(<expr><call><name>Py_GETENV</name><argument_list>(<argument><expr>"PYTHONDUMPREFS"</expr></argument>)</argument_list></call></expr>)</condition><then>
<expr_stmt><expr><call><name>_Py_PrintReferenceAddresses</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>PYMALLOC_DEBUG</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if>if <condition>(<expr><call><name>Py_GETENV</name><argument_list>(<argument><expr>"PYTHONMALLOCSTATS"</expr></argument>)</argument_list></call></expr>)</condition><then>
<expr_stmt><expr><call><name>_PyObject_DebugMallocStats</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><call><name>call_ll_exitfuncs</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
}</block></function>
<function><type><name>PyThreadState</name> *</type>
<name>Py_NewInterpreter</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyInterpreterState</name> *</type><name>interp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyThreadState</name> *</type><name>tstate</name></decl>, *<decl><type ref="prev"/><name>save_tstate</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>bimod</name></decl>, *<decl><type ref="prev"/><name>sysmod</name></decl>;</decl_stmt>
<if>if <condition>(<expr>!<name>initialized</name></expr>)</condition><then>
<expr_stmt><expr><call><name>Py_FatalError</name><argument_list>(<argument><expr>"Py_NewInterpreter: call Py_Initialize first"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<expr_stmt><expr><name>interp</name> = <call><name>PyInterpreterState_New</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>interp</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>tstate</name> = <call><name>PyThreadState_New</name><argument_list>(<argument><expr><name>interp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>tstate</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyInterpreterState_Delete</name><argument_list>(<argument><expr><name>interp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>save_tstate</name> = <call><name>PyThreadState_Swap</name><argument_list>(<argument><expr><name>tstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>interp</name>-&gt;<name>modules</name></name> = <call><name>PyDict_New</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>interp</name>-&gt;<name>modules_reloading</name></name> = <call><name>PyDict_New</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>bimod</name> = <call><name>_PyImport_FindExtension</name><argument_list>(<argument><expr>"__builtin__"</expr></argument>, <argument><expr>"__builtin__"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>bimod</name> != <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>interp</name>-&gt;<name>builtins</name></name> = <call><name>PyModule_GetDict</name><argument_list>(<argument><expr><name>bimod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>interp</name>-&gt;<name>builtins</name></name> == <name>NULL</name></expr>)</condition><then>
<goto>goto <name>handle_error</name>;</goto></then></if>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name><name>interp</name>-&gt;<name>builtins</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><name>sysmod</name> = <call><name>_PyImport_FindExtension</name><argument_list>(<argument><expr>"sys"</expr></argument>, <argument><expr>"sys"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>bimod</name> != <name>NULL</name> &amp;&amp; <name>sysmod</name> != <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>interp</name>-&gt;<name>sysdict</name></name> = <call><name>PyModule_GetDict</name><argument_list>(<argument><expr><name>sysmod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>interp</name>-&gt;<name>sysdict</name></name> == <name>NULL</name></expr>)</condition><then>
<goto>goto <name>handle_error</name>;</goto></then></if>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name><name>interp</name>-&gt;<name>sysdict</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PySys_SetPath</name><argument_list>(<argument><expr><call><name>Py_GetPath</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyDict_SetItemString</name><argument_list>(<argument><expr><name><name>interp</name>-&gt;<name>sysdict</name></name></expr></argument>, <argument><expr>"modules"</expr></argument>,
<argument><expr><name><name>interp</name>-&gt;<name>modules</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>_PyImportHooks_Init</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>initmain</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>Py_NoSiteFlag</name></expr>)</condition><then>
<expr_stmt><expr><call><name>initsite</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>
}</block></then></if>
<if>if <condition>(<expr>!<call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then>
<return>return <expr><name>tstate</name></expr>;</return></then></if>
<label><name>handle_error</name>:</label>
<expr_stmt><expr><call><name>PyErr_Print</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyThreadState_Clear</name><argument_list>(<argument><expr><name>tstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyThreadState_Swap</name><argument_list>(<argument><expr><name>save_tstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyThreadState_Delete</name><argument_list>(<argument><expr><name>tstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyInterpreterState_Delete</name><argument_list>(<argument><expr><name>interp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></function>
<function><type><name>void</name></type>
<name>Py_EndInterpreter</name><parameter_list>(<param><decl><type><name>PyThreadState</name> *</type><name>tstate</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyInterpreterState</name> *</type><name>interp</name> <init>= <expr><name><name>tstate</name>-&gt;<name>interp</name></name></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>tstate</name> != <call><name>PyThreadState_GET</name><argument_list>()</argument_list></call></expr>)</condition><then>
<expr_stmt><expr><call><name>Py_FatalError</name><argument_list>(<argument><expr>"Py_EndInterpreter: thread is not current"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<if>if <condition>(<expr><name><name>tstate</name>-&gt;<name>frame</name></name> != <name>NULL</name></expr>)</condition><then>
<expr_stmt><expr><call><name>Py_FatalError</name><argument_list>(<argument><expr>"Py_EndInterpreter: thread still has a frame"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<if>if <condition>(<expr><name>tstate</name> != <name><name>interp</name>-&gt;<name>tstate_head</name></name> || <name><name>tstate</name>-&gt;<name>next</name></name> != <name>NULL</name></expr>)</condition><then>
<expr_stmt><expr><call><name>Py_FatalError</name><argument_list>(<argument><expr>"Py_EndInterpreter: not the last thread"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<expr_stmt><expr><call><name>PyImport_Cleanup</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyInterpreterState_Clear</name><argument_list>(<argument><expr><name>interp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyThreadState_Swap</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyInterpreterState_Delete</name><argument_list>(<argument><expr><name>interp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> *</type><name>progname</name> <init>= <expr>"python"</expr></init></decl>;</decl_stmt>
<function><type><name>void</name></type>
<name>Py_SetProgramName</name><parameter_list>(<param><decl><type><name>char</name> *</type><name>pn</name></decl></param>)</parameter_list> <block>{
<if>if <condition>(<expr><name>pn</name> &amp;&amp; *<name>pn</name></expr>)</condition><then>
<expr_stmt><expr><name>progname</name> = <name>pn</name></expr>;</expr_stmt></then></if>
}</block></function>
<function><type><name>char</name> *</type>
<name>Py_GetProgramName</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list> <block>{
<return>return <expr><name>progname</name></expr>;</return>
}</block></function>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> *</type><name>default_home</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<function><type><name>void</name></type>
<name>Py_SetPythonHome</name><parameter_list>(<param><decl><type><name>char</name> *</type><name>home</name></decl></param>)</parameter_list> <block>{
<expr_stmt><expr><name>default_home</name> = <name>home</name></expr>;</expr_stmt>
}</block></function>
<function><type><name>char</name> *</type>
<name>Py_GetPythonHome</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>char</name> *</type><name>home</name> <init>= <expr><name>default_home</name></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>home</name> == <name>NULL</name> &amp;&amp; !<name>Py_IgnoreEnvironmentFlag</name></expr>)</condition><then>
<expr_stmt><expr><name>home</name> = <call><name>Py_GETENV</name><argument_list>(<argument><expr>"PYTHONHOME"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<return>return <expr><name>home</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>initmain</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>m</name></decl>, *<decl><type ref="prev"/><name>d</name></decl>;</decl_stmt>
<expr_stmt><expr><name>m</name> = <call><name>PyImport_AddModule</name><argument_list>(<argument><expr>"__main__"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>m</name> == <name>NULL</name></expr>)</condition><then>
<expr_stmt><expr><call><name>Py_FatalError</name><argument_list>(<argument><expr>"can't create __main__ module"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<expr_stmt><expr><name>d</name> = <call><name>PyModule_GetDict</name><argument_list>(<argument><expr><name>m</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>PyDict_GetItemString</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr>"__builtins__"</expr></argument>)</argument_list></call> == <name>NULL</name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>bimod</name> <init>= <expr><call><name>PyImport_ImportModule</name><argument_list>(<argument><expr>"__builtin__"</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>bimod</name> == <name>NULL</name> ||
<call><name>PyDict_SetItemString</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr>"__builtins__"</expr></argument>, <argument><expr><name>bimod</name></expr></argument>)</argument_list></call> != 0</expr>)</condition><then>
<expr_stmt><expr><call><name>Py_FatalError</name><argument_list>(<argument><expr>"can't add __builtins__ to __main__"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>bimod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>initsite</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>m</name></decl>, *<decl><type ref="prev"/><name>f</name></decl>;</decl_stmt>
<expr_stmt><expr><name>m</name> = <call><name>PyImport_ImportModule</name><argument_list>(<argument><expr>"site"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>m</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>f</name> = <call><name>PySys_GetObject</name><argument_list>(<argument><expr>"stderr"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>Py_VerboseFlag</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyFile_WriteString</name><argument_list>(
<argument><expr>"'import site' failed; traceback:\n"</expr></argument>, <argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyErr_Print</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr><call><name>PyFile_WriteString</name><argument_list>(
<argument><expr>"'import site' failed; use -v for traceback\n"</expr></argument>, <argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyErr_Clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
}</block></else></if>
}</block></then> <else>else <block>{
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>m</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></else></if>
}</block></function>
<function><type><name>int</name></type>
<name>PyRun_AnyFileExFlags</name><parameter_list>(<param><decl><type><name>FILE</name> *</type><name>fp</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>filename</name></decl></param>, <param><decl><type><name>int</name></type> <name>closeit</name></decl></param>,
<param><decl><type><name>PyCompilerFlags</name> *</type><name>flags</name></decl></param>)</parameter_list> <block>{
<if>if <condition>(<expr><name>filename</name> == <name>NULL</name></expr>)</condition><then>
<expr_stmt><expr><name>filename</name> = "???"</expr>;</expr_stmt></then></if>
<if>if <condition>(<expr><call><name>Py_FdIsInteractive</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>err</name> <init>= <expr><call><name>PyRun_InteractiveLoopFlags</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><name>filename</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>closeit</name></expr>)</condition><then>
<expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<return>return <expr><name>err</name></expr>;</return>
}</block></then> <else>else
<return>return <expr><call><name>PyRun_SimpleFileExFlags</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><name>filename</name></expr></argument>, <argument><expr><name>closeit</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</return></else></if>
}</block></function>
<function><type><name>int</name></type>
<name>PyRun_InteractiveLoopFlags</name><parameter_list>(<param><decl><type><name>FILE</name> *</type><name>fp</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>filename</name></decl></param>, <param><decl><type><name>PyCompilerFlags</name> *</type><name>flags</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>v</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyCompilerFlags</name></type> <name>local_flags</name></decl>;</decl_stmt>
<if>if <condition>(<expr><name>flags</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>flags</name> = &amp;<name>local_flags</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>local_flags</name>.<name>cf_flags</name></name> = 0</expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><name>v</name> = <call><name>PySys_GetObject</name><argument_list>(<argument><expr>"ps1"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>v</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PySys_SetObject</name><argument_list>(<argument><expr>"ps1"</expr></argument>, <argument><expr><name>v</name> = <call><name>PyString_FromString</name><argument_list>(<argument><expr>"&gt;&gt;&gt; "</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><name>v</name> = <call><name>PySys_GetObject</name><argument_list>(<argument><expr>"ps2"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>v</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PySys_SetObject</name><argument_list>(<argument><expr>"ps2"</expr></argument>, <argument><expr><name>v</name> = <call><name>PyString_FromString</name><argument_list>(<argument><expr>"... "</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<for>for (<init>;</init><condition>;</condition><incr/>) <block>{
<expr_stmt><expr><name>ret</name> = <call><name>PyRun_InteractiveOneFlags</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><name>filename</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PRINT_TOTAL_REFS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>ret</name> == <name>E_EOF</name></expr>)</condition><then>
<return>return <expr>0</expr>;</return></then></if>
}</block></for>
}</block></function>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>0</expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PARSER_FLAGS</name><parameter_list>(<param><type><name>flags</name></type></param>)</parameter_list></cpp:macro> <cpp:value>((flags) ? ((((flags)-&gt;cf_flags &amp; PyCF_DONT_IMPLY_DEDENT) ? PyPARSE_DONT_IMPLY_DEDENT : 0)) : 0)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>1</expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PARSER_FLAGS</name><parameter_list>(<param><type><name>flags</name></type></param>)</parameter_list></cpp:macro> <cpp:value>((flags) ? ((((flags)-&gt;cf_flags &amp; PyCF_DONT_IMPLY_DEDENT) ? PyPARSE_DONT_IMPLY_DEDENT : 0) | (((flags)-&gt;cf_flags &amp; CO_FUTURE_PRINT_FUNCTION) ? PyPARSE_PRINT_IS_FUNCTION : 0) | (((flags)-&gt;cf_flags &amp; CO_FUTURE_UNICODE_LITERALS) ? PyPARSE_UNICODE_LITERALS : 0) ) : 0)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<function><type><name>int</name></type>
<name>PyRun_InteractiveOneFlags</name><parameter_list>(<param><decl><type><name>FILE</name> *</type><name>fp</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>filename</name></decl></param>, <param><decl><type><name>PyCompilerFlags</name> *</type><name>flags</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>m</name></decl>, *<decl><type ref="prev"/><name>d</name></decl>, *<decl><type ref="prev"/><name>v</name></decl>, *<decl><type ref="prev"/><name>w</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>mod_ty</name></type> <name>mod</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyArena</name> *</type><name>arena</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>ps1</name> <init>= <expr>""</expr></init>, *<name>ps2</name> <init>= <expr>""</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>errcode</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>v</name> = <call><name>PySys_GetObject</name><argument_list>(<argument><expr>"ps1"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>v</name> != <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>v</name> = <call><name>PyObject_Str</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>v</name> == <name>NULL</name></expr>)</condition><then>
<expr_stmt><expr><call><name>PyErr_Clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then>
<else>else <if>if <condition>(<expr><call><name>PyString_Check</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<expr_stmt><expr><name>ps1</name> = <call><name>PyString_AsString</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if></else></if>
}</block></then></if>
<expr_stmt><expr><name>w</name> = <call><name>PySys_GetObject</name><argument_list>(<argument><expr>"ps2"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>w</name> != <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>w</name> = <call><name>PyObject_Str</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>w</name> == <name>NULL</name></expr>)</condition><then>
<expr_stmt><expr><call><name>PyErr_Clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then>
<else>else <if>if <condition>(<expr><call><name>PyString_Check</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<expr_stmt><expr><name>ps2</name> = <call><name>PyString_AsString</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if></else></if>
}</block></then></if>
<expr_stmt><expr><name>arena</name> = <call><name>PyArena_New</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>arena</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>-1</expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>mod</name> = <call><name>PyParser_ASTFromFile</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><name>filename</name></expr></argument>,
<argument><expr><name>Py_single_input</name></expr></argument>, <argument><expr><name>ps1</name></expr></argument>, <argument><expr><name>ps2</name></expr></argument>,
<argument><expr><name>flags</name></expr></argument>, <argument><expr>&amp;<name>errcode</name></expr></argument>, <argument><expr><name>arena</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>mod</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyArena_Free</name><argument_list>(<argument><expr><name>arena</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>errcode</name> == <name>E_EOF</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_Clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>E_EOF</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><call><name>PyErr_Print</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<return>return <expr>-1</expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>m</name> = <call><name>PyImport_AddModule</name><argument_list>(<argument><expr>"__main__"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>m</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyArena_Free</name><argument_list>(<argument><expr><name>arena</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>-1</expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>d</name> = <call><name>PyModule_GetDict</name><argument_list>(<argument><expr><name>m</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>v</name> = <call><name>run_mod</name><argument_list>(<argument><expr><name>mod</name></expr></argument>, <argument><expr><name>filename</name></expr></argument>, <argument><expr><name>d</name></expr></argument>, <argument><expr><name>d</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>, <argument><expr><name>arena</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyArena_Free</name><argument_list>(<argument><expr><name>arena</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>v</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_Print</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<return>return <expr>-1</expr>;</return>
}</block></then></if>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>Py_FlushLine</name><argument_list>()</argument_list></call></expr>)</condition><then>
<expr_stmt><expr><call><name>PyErr_Clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>
<return>return <expr>0</expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>maybe_pyc_file</name><parameter_list>(<param><decl><type><name>FILE</name> *</type><name>fp</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name>*</type> <name>filename</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name>*</type> <name>ext</name></decl></param>, <param><decl><type><name>int</name></type> <name>closeit</name></decl></param>)</parameter_list> <block>{
<if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>ext</name></expr></argument>, <argument><expr>".pyc"</expr></argument>)</argument_list></call> == 0 || <call><name>strcmp</name><argument_list>(<argument><expr><name>ext</name></expr></argument>, <argument><expr>".pyo"</expr></argument>)</argument_list></call> == 0</expr>)</condition><then>
<return>return <expr>1</expr>;</return></then></if>
<if>if <condition>(<expr><name>closeit</name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>halfmagic</name> <init>= <expr><call><name>PyImport_GetMagicNumber</name><argument_list>()</argument_list></call> &amp; 0xFFFF</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name><name>buf</name><index>[<expr>2</expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>ispyc</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><call><name>ftell</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call> == 0</expr>)</condition><then> <block>{
<if>if <condition>(<expr><call><name>fread</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr>1</expr></argument>, <argument><expr>2</expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call> == 2 &amp;&amp;
((<name>unsigned</name> <name>int</name>)<name><name>buf</name><index>[<expr>1</expr>]</index></name>&lt;&lt;8 | <name><name>buf</name><index>[<expr>0</expr>]</index></name>) == <name>halfmagic</name></expr>)</condition><then>
<expr_stmt><expr><name>ispyc</name> = 1</expr>;</expr_stmt></then></if>
<expr_stmt><expr><call><name>rewind</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<return>return <expr><name>ispyc</name></expr>;</return>
}</block></then></if>
<return>return <expr>0</expr>;</return>
}</block></function>
<function><type><name>int</name></type>
<name>PyRun_SimpleFileExFlags</name><parameter_list>(<param><decl><type><name>FILE</name> *</type><name>fp</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>filename</name></decl></param>, <param><decl><type><name>int</name></type> <name>closeit</name></decl></param>,
<param><decl><type><name>PyCompilerFlags</name> *</type><name>flags</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>m</name></decl>, *<decl><type ref="prev"/><name>d</name></decl>, *<decl><type ref="prev"/><name>v</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>ext</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>set_file_name</name> <init>= <expr>0</expr></init>, <name>ret</name></decl>;</decl_stmt>
<expr_stmt><expr><name>m</name> = <call><name>PyImport_AddModule</name><argument_list>(<argument><expr>"__main__"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>m</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr>-1</expr>;</return></then></if>
<expr_stmt><expr><name>d</name> = <call><name>PyModule_GetDict</name><argument_list>(<argument><expr><name>m</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>PyDict_GetItemString</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr>"__file__"</expr></argument>)</argument_list></call> == <name>NULL</name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>f</name> <init>= <expr><call><name>PyString_FromString</name><argument_list>(<argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>f</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr>-1</expr>;</return></then></if>
<if>if <condition>(<expr><call><name>PyDict_SetItemString</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr>"__file__"</expr></argument>, <argument><expr><name>f</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>-1</expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>set_file_name</name> = 1</expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><name>ext</name> = <name>filename</name> + <call><name>strlen</name><argument_list>(<argument><expr><name>filename</name></expr></argument>)</argument_list></call> - 4</expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>maybe_pyc_file</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><name>filename</name></expr></argument>, <argument><expr><name>ext</name></expr></argument>, <argument><expr><name>closeit</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<if>if <condition>(<expr><name>closeit</name></expr>)</condition><then>
<expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<if>if <condition>(<expr>(<name>fp</name> = <call><name>fopen</name><argument_list>(<argument><expr><name>filename</name></expr></argument>, <argument><expr>"rb"</expr></argument>)</argument_list></call>) == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr>"python: Can't reopen .pyc file\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ret</name> = -1</expr>;</expr_stmt>
<goto>goto <name>done</name>;</goto>
}</block></then></if>
<if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>ext</name></expr></argument>, <argument><expr>".pyo"</expr></argument>)</argument_list></call> == 0</expr>)</condition><then>
<expr_stmt><expr><name>Py_OptimizeFlag</name> = 1</expr>;</expr_stmt></then></if>
<expr_stmt><expr><name>v</name> = <call><name>run_pyc_file</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><name>filename</name></expr></argument>, <argument><expr><name>d</name></expr></argument>, <argument><expr><name>d</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr><name>v</name> = <call><name>PyRun_FileExFlags</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><name>filename</name></expr></argument>, <argument><expr><name>Py_file_input</name></expr></argument>, <argument><expr><name>d</name></expr></argument>, <argument><expr><name>d</name></expr></argument>,
<argument><expr><name>closeit</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></else></if>
<if>if <condition>(<expr><name>v</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_Print</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ret</name> = -1</expr>;</expr_stmt>
<goto>goto <name>done</name>;</goto>
}</block></then></if>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>Py_FlushLine</name><argument_list>()</argument_list></call></expr>)</condition><then>
<expr_stmt><expr><call><name>PyErr_Clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>
<expr_stmt><expr><name>ret</name> = 0</expr>;</expr_stmt>
<label><name>done</name>:</label>
<if>if <condition>(<expr><name>set_file_name</name> &amp;&amp; <call><name>PyDict_DelItemString</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr>"__file__"</expr></argument>)</argument_list></call></expr>)</condition><then>
<expr_stmt><expr><call><name>PyErr_Clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>
<return>return <expr><name>ret</name></expr>;</return>
}</block></function>
<function><type><name>int</name></type>
<name>PyRun_SimpleStringFlags</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>command</name></decl></param>, <param><decl><type><name>PyCompilerFlags</name> *</type><name>flags</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>m</name></decl>, *<decl><type ref="prev"/><name>d</name></decl>, *<decl><type ref="prev"/><name>v</name></decl>;</decl_stmt>
<expr_stmt><expr><name>m</name> = <call><name>PyImport_AddModule</name><argument_list>(<argument><expr>"__main__"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>m</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr>-1</expr>;</return></then></if>
<expr_stmt><expr><name>d</name> = <call><name>PyModule_GetDict</name><argument_list>(<argument><expr><name>m</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>v</name> = <call><name>PyRun_StringFlags</name><argument_list>(<argument><expr><name>command</name></expr></argument>, <argument><expr><name>Py_file_input</name></expr></argument>, <argument><expr><name>d</name></expr></argument>, <argument><expr><name>d</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>v</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_Print</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<return>return <expr>-1</expr>;</return>
}</block></then></if>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>Py_FlushLine</name><argument_list>()</argument_list></call></expr>)</condition><then>
<expr_stmt><expr><call><name>PyErr_Clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>
<return>return <expr>0</expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>parse_syntax_error</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>err</name></decl></param>, <param><decl><type><name>PyObject</name> **</type><name>message</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> **</type><name>filename</name></decl></param>,
<param><decl><type><name>int</name> *</type><name>lineno</name></decl></param>, <param><decl><type><name>int</name> *</type><name>offset</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> **</type><name>text</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>long</name></type> <name>hold</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>v</name></decl>;</decl_stmt>
<if>if <condition>(<expr><call><name>PyTuple_Check</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>err</name></expr></argument>, <argument><expr>"O(ziiz)"</expr></argument>, <argument><expr><name>message</name></expr></argument>, <argument><expr><name>filename</name></expr></argument>,
<argument><expr><name>lineno</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>, <argument><expr><name>text</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
<if>if <condition>(<expr>! (<name>v</name> = <call><name>PyObject_GetAttrString</name><argument_list>(<argument><expr><name>err</name></expr></argument>, <argument><expr>"msg"</expr></argument>)</argument_list></call>)</expr>)</condition><then>
<goto>goto <name>finally</name>;</goto></then></if>
<expr_stmt><expr>*<name>message</name> = <name>v</name></expr>;</expr_stmt>
<if>if <condition>(<expr>!(<name>v</name> = <call><name>PyObject_GetAttrString</name><argument_list>(<argument><expr><name>err</name></expr></argument>, <argument><expr>"filename"</expr></argument>)</argument_list></call>)</expr>)</condition><then>
<goto>goto <name>finally</name>;</goto></then></if>
<if>if <condition>(<expr><name>v</name> == <name>Py_None</name></expr>)</condition><then>
<expr_stmt><expr>*<name>filename</name> = <name>NULL</name></expr>;</expr_stmt></then>
<else>else <if>if <condition>(<expr>! (*<name>filename</name> = <call><name>PyString_AsString</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call>)</expr>)</condition><then>
<goto>goto <name>finally</name>;</goto></then></if></else></if>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!(<name>v</name> = <call><name>PyObject_GetAttrString</name><argument_list>(<argument><expr><name>err</name></expr></argument>, <argument><expr>"lineno"</expr></argument>)</argument_list></call>)</expr>)</condition><then>
<goto>goto <name>finally</name>;</goto></then></if>
<expr_stmt><expr><name>hold</name> = <call><name>PyInt_AsLong</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>v</name> = <name>NULL</name></expr>;</expr_stmt>
<if>if <condition>(<expr><name>hold</name> &lt; 0 &amp;&amp; <call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then>
<goto>goto <name>finally</name>;</goto></then></if>
<expr_stmt><expr>*<name>lineno</name> = (<name>int</name>)<name>hold</name></expr>;</expr_stmt>
<if>if <condition>(<expr>!(<name>v</name> = <call><name>PyObject_GetAttrString</name><argument_list>(<argument><expr><name>err</name></expr></argument>, <argument><expr>"offset"</expr></argument>)</argument_list></call>)</expr>)</condition><then>
<goto>goto <name>finally</name>;</goto></then></if>
<if>if <condition>(<expr><name>v</name> == <name>Py_None</name></expr>)</condition><then> <block>{
<expr_stmt><expr>*<name>offset</name> = -1</expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>v</name> = <name>NULL</name></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr><name>hold</name> = <call><name>PyInt_AsLong</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>v</name> = <name>NULL</name></expr>;</expr_stmt>
<if>if <condition>(<expr><name>hold</name> &lt; 0 &amp;&amp; <call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then>
<goto>goto <name>finally</name>;</goto></then></if>
<expr_stmt><expr>*<name>offset</name> = (<name>int</name>)<name>hold</name></expr>;</expr_stmt>
}</block></else></if>
<if>if <condition>(<expr>!(<name>v</name> = <call><name>PyObject_GetAttrString</name><argument_list>(<argument><expr><name>err</name></expr></argument>, <argument><expr>"text"</expr></argument>)</argument_list></call>)</expr>)</condition><then>
<goto>goto <name>finally</name>;</goto></then></if>
<if>if <condition>(<expr><name>v</name> == <name>Py_None</name></expr>)</condition><then>
<expr_stmt><expr>*<name>text</name> = <name>NULL</name></expr>;</expr_stmt></then>
<else>else <if>if <condition>(<expr>! (*<name>text</name> = <call><name>PyString_AsString</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call>)</expr>)</condition><then>
<goto>goto <name>finally</name>;</goto></then></if></else></if>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>1</expr>;</return>
<label><name>finally</name>:</label>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>0</expr>;</return>
}</block></function>
<function><type><name>void</name></type>
<name>PyErr_Print</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list> <block>{
<expr_stmt><expr><call><name>PyErr_PrintEx</name><argument_list>(<argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>print_error_text</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>f</name></decl></param>, <param><decl><type><name>int</name></type> <name>offset</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>text</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>char</name> *</type><name>nl</name></decl>;</decl_stmt>
<if>if <condition>(<expr><name>offset</name> &gt;= 0</expr>)</condition><then> <block>{
<if>if <condition>(<expr><name>offset</name> &gt; 0 &amp;&amp; <name>offset</name> == (<name>int</name>)<call><name>strlen</name><argument_list>(<argument><expr><name>text</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<expr_stmt><expr><name>offset</name>--</expr>;</expr_stmt></then></if>
<for>for (<init>;</init><condition>;</condition><incr/>) <block>{
<expr_stmt><expr><name>nl</name> = <call><name>strchr</name><argument_list>(<argument><expr><name>text</name></expr></argument>, <argument><expr>'\n'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>nl</name> == <name>NULL</name> || <name>nl</name>-<name>text</name> &gt;= <name>offset</name></expr>)</condition><then>
<break>break;</break></then></if>
<expr_stmt><expr><name>offset</name> -= <call>(<name>int</name>)<argument_list>(<argument><expr><name>nl</name>+1-<name>text</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>text</name> = <name>nl</name>+1</expr>;</expr_stmt>
}</block></for>
<while>while <condition>(<expr>*<name>text</name> == ' ' || *<name>text</name> == '\t'</expr>)</condition> <block>{
<expr_stmt><expr><name>text</name>++</expr>;</expr_stmt>
<expr_stmt><expr><name>offset</name>--</expr>;</expr_stmt>
}</block></while>
}</block></then></if>
<expr_stmt><expr><call><name>PyFile_WriteString</name><argument_list>(<argument><expr>" "</expr></argument>, <argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyFile_WriteString</name><argument_list>(<argument><expr><name>text</name></expr></argument>, <argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>*<name>text</name> == '\0' || <name><name>text</name><index>[<expr><call><name>strlen</name><argument_list>(<argument><expr><name>text</name></expr></argument>)</argument_list></call>-1</expr>]</index></name> != '\n'</expr>)</condition><then>
<expr_stmt><expr><call><name>PyFile_WriteString</name><argument_list>(<argument><expr>"\n"</expr></argument>, <argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<if>if <condition>(<expr><name>offset</name> == -1</expr>)</condition><then>
<return>return;</return></then></if>
<expr_stmt><expr><call><name>PyFile_WriteString</name><argument_list>(<argument><expr>" "</expr></argument>, <argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>offset</name>--</expr>;</expr_stmt>
<while>while <condition>(<expr><name>offset</name> &gt; 0</expr>)</condition> <block>{
<expr_stmt><expr><call><name>PyFile_WriteString</name><argument_list>(<argument><expr>" "</expr></argument>, <argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>offset</name>--</expr>;</expr_stmt>
}</block></while>
<expr_stmt><expr><call><name>PyFile_WriteString</name><argument_list>(<argument><expr>"^\n"</expr></argument>, <argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>handle_system_exit</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>exception</name></decl>, *<decl><type ref="prev"/><name>value</name></decl>, *<decl><type ref="prev"/><name>tb</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>exitcode</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>Py_InspectFlag</name></expr>)</condition><then>
<return>return;</return></then></if>
<expr_stmt><expr><call><name>PyErr_Fetch</name><argument_list>(<argument><expr>&amp;<name>exception</name></expr></argument>, <argument><expr>&amp;<name>value</name></expr></argument>, <argument><expr>&amp;<name>tb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>Py_FlushLine</name><argument_list>()</argument_list></call></expr>)</condition><then>
<expr_stmt><expr><call><name>PyErr_Clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>
<expr_stmt><expr><call><name>fflush</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>value</name> == <name>NULL</name> || <name>value</name> == <name>Py_None</name></expr>)</condition><then>
<goto>goto <name>done</name>;</goto></then></if>
<if>if <condition>(<expr><call><name>PyExceptionInstance_Check</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>code</name> <init>= <expr><call><name>PyObject_GetAttrString</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr>"code"</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>code</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>value</name> = <name>code</name></expr>;</expr_stmt>
<if>if <condition>(<expr><name>value</name> == <name>Py_None</name></expr>)</condition><then>
<goto>goto <name>done</name>;</goto></then></if>
}</block></then></if>
}</block></then></if>
<if>if <condition>(<expr><call><name>PyInt_Check</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<expr_stmt><expr><name>exitcode</name> = (<name>int</name>)<call><name>PyInt_AsLong</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
<else>else <block>{
<expr_stmt><expr><call><name>PyObject_Print</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><name>stderr</name></expr></argument>, <argument><expr><name>Py_PRINT_RAW</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PySys_WriteStderr</name><argument_list>(<argument><expr>"\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>exitcode</name> = 1</expr>;</expr_stmt>
}</block></else></if>
<label><name>done</name>:</label>
<expr_stmt><expr><call><name>PyErr_Restore</name><argument_list>(<argument><expr><name>exception</name></expr></argument>, <argument><expr><name>value</name></expr></argument>, <argument><expr><name>tb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyErr_Clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_Exit</name><argument_list>(<argument><expr><name>exitcode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>
<function><type><name>void</name></type>
<name>PyErr_PrintEx</name><parameter_list>(<param><decl><type><name>int</name></type> <name>set_sys_last_vars</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>exception</name></decl>, *<decl><type ref="prev"/><name>v</name></decl>, *<decl><type ref="prev"/><name>tb</name></decl>, *<decl><type ref="prev"/><name>hook</name></decl>;</decl_stmt>
<if>if <condition>(<expr><call><name>PyErr_ExceptionMatches</name><argument_list>(<argument><expr><name>PyExc_SystemExit</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>handle_system_exit</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><call><name>PyErr_Fetch</name><argument_list>(<argument><expr>&amp;<name>exception</name></expr></argument>, <argument><expr>&amp;<name>v</name></expr></argument>, <argument><expr>&amp;<name>tb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>exception</name> == <name>NULL</name></expr>)</condition><then>
<return>return;</return></then></if>
<expr_stmt><expr><call><name>PyErr_NormalizeException</name><argument_list>(<argument><expr>&amp;<name>exception</name></expr></argument>, <argument><expr>&amp;<name>v</name></expr></argument>, <argument><expr>&amp;<name>tb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>exception</name> == <name>NULL</name></expr>)</condition><then>
<return>return;</return></then></if>
<if>if <condition>(<expr><name>set_sys_last_vars</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PySys_SetObject</name><argument_list>(<argument><expr>"last_type"</expr></argument>, <argument><expr><name>exception</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PySys_SetObject</name><argument_list>(<argument><expr>"last_value"</expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PySys_SetObject</name><argument_list>(<argument><expr>"last_traceback"</expr></argument>, <argument><expr><name>tb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><name>hook</name> = <call><name>PySys_GetObject</name><argument_list>(<argument><expr>"excepthook"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>hook</name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>args</name> <init>= <expr><call><name>PyTuple_Pack</name><argument_list>(<argument><expr>3</expr></argument>,
<argument><expr><name>exception</name></expr></argument>, <argument><expr><name>v</name></expr></argument>, <argument><expr><name>tb</name> ? <name>tb</name> : <name>Py_None</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>result</name> <init>= <expr><call><name>PyEval_CallObject</name><argument_list>(<argument><expr><name>hook</name></expr></argument>, <argument><expr><name>args</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>result</name> == <name>NULL</name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>exception2</name></decl>, *<decl><type ref="prev"/><name>v2</name></decl>, *<decl><type ref="prev"/><name>tb2</name></decl>;</decl_stmt>
<if>if <condition>(<expr><call><name>PyErr_ExceptionMatches</name><argument_list>(<argument><expr><name>PyExc_SystemExit</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>handle_system_exit</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><call><name>PyErr_Fetch</name><argument_list>(<argument><expr>&amp;<name>exception2</name></expr></argument>, <argument><expr>&amp;<name>v2</name></expr></argument>, <argument><expr>&amp;<name>tb2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyErr_NormalizeException</name><argument_list>(<argument><expr>&amp;<name>exception2</name></expr></argument>, <argument><expr>&amp;<name>v2</name></expr></argument>, <argument><expr>&amp;<name>tb2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>exception2</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>exception2</name> = <name>Py_None</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>exception2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<if>if <condition>(<expr><name>v2</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>v2</name> = <name>Py_None</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>v2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<if>if <condition>(<expr><call><name>Py_FlushLine</name><argument_list>()</argument_list></call></expr>)</condition><then>
<expr_stmt><expr><call><name>PyErr_Clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>
<expr_stmt><expr><call><name>fflush</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PySys_WriteStderr</name><argument_list>(<argument><expr>"Error in sys.excepthook:\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyErr_Display</name><argument_list>(<argument><expr><name>exception2</name></expr></argument>, <argument><expr><name>v2</name></expr></argument>, <argument><expr><name>tb2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PySys_WriteStderr</name><argument_list>(<argument><expr>"\nOriginal exception was:\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyErr_Display</name><argument_list>(<argument><expr><name>exception</name></expr></argument>, <argument><expr><name>v</name></expr></argument>, <argument><expr><name>tb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>exception2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>v2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>tb2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr><call><name>PySys_WriteStderr</name><argument_list>(<argument><expr>"sys.excepthook is missing\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyErr_Display</name><argument_list>(<argument><expr><name>exception</name></expr></argument>, <argument><expr><name>v</name></expr></argument>, <argument><expr><name>tb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></else></if>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>exception</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>tb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>
<function><type><name>void</name></type>
<name>PyErr_Display</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>exception</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>value</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>tb</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>err</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>f</name> <init>= <expr><call><name>PySys_GetObject</name><argument_list>(<argument><expr>"stderr"</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>f</name> == <name>NULL</name></expr>)</condition><then>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr>"lost sys.stderr\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
<else>else <block>{
<if>if <condition>(<expr><call><name>Py_FlushLine</name><argument_list>()</argument_list></call></expr>)</condition><then>
<expr_stmt><expr><call><name>PyErr_Clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>
<expr_stmt><expr><call><name>fflush</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>tb</name> &amp;&amp; <name>tb</name> != <name>Py_None</name></expr>)</condition><then>
<expr_stmt><expr><name>err</name> = <call><name>PyTraceBack_Print</name><argument_list>(<argument><expr><name>tb</name></expr></argument>, <argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<if>if <condition>(<expr><name>err</name> == 0 &amp;&amp;
<call><name>PyObject_HasAttrString</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr>"print_file_and_line"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>message</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>filename</name></decl>, *<decl><type ref="prev"/><name>text</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>lineno</name></decl>, <decl><type ref="prev"/><name>offset</name></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>parse_syntax_error</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr>&amp;<name>message</name></expr></argument>, <argument><expr>&amp;<name>filename</name></expr></argument>,
<argument><expr>&amp;<name>lineno</name></expr></argument>, <argument><expr>&amp;<name>offset</name></expr></argument>, <argument><expr>&amp;<name>text</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<expr_stmt><expr><call><name>PyErr_Clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then>
<else>else <block>{
<decl_stmt><decl><type><name>char</name></type> <name><name>buf</name><index>[<expr>10</expr>]</index></name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>PyFile_WriteString</name><argument_list>(<argument><expr>" File \""</expr></argument>, <argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>filename</name> == <name>NULL</name></expr>)</condition><then>
<expr_stmt><expr><call><name>PyFile_WriteString</name><argument_list>(<argument><expr>"&lt;string&gt;"</expr></argument>, <argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
<else>else
<expr_stmt><expr><call><name>PyFile_WriteString</name><argument_list>(<argument><expr><name>filename</name></expr></argument>, <argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
<expr_stmt><expr><call><name>PyFile_WriteString</name><argument_list>(<argument><expr>"\", line "</expr></argument>, <argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyOS_snprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr>"%d"</expr></argument>, <argument><expr><name>lineno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyFile_WriteString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyFile_WriteString</name><argument_list>(<argument><expr>"\n"</expr></argument>, <argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>text</name> != <name>NULL</name></expr>)</condition><then>
<expr_stmt><expr><call><name>print_error_text</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>, <argument><expr><name>text</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>value</name> = <name>message</name></expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then>
<expr_stmt><expr><name>err</name> = -1</expr>;</expr_stmt></then></if>
}</block></else></if>
}</block></then></if>
<if>if <condition>(<expr><name>err</name></expr>)</condition><then> <block>{
}</block></then> <else>else <if>if <condition>(<expr><call><name>PyExceptionClass_Check</name><argument_list>(<argument><expr><name>exception</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>PyObject</name>*</type> <name>moduleName</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name>*</type> <name>className</name> <init>= <expr><call><name>PyExceptionClass_Name</name><argument_list>(<argument><expr><name>exception</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>className</name> != <name>NULL</name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>char</name> *</type><name>dot</name> <init>= <expr><call><name>strrchr</name><argument_list>(<argument><expr><name>className</name></expr></argument>, <argument><expr>'.'</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>dot</name> != <name>NULL</name></expr>)</condition><then>
<expr_stmt><expr><name>className</name> = <name>dot</name>+1</expr>;</expr_stmt></then></if>
}</block></then></if>
<expr_stmt><expr><name>moduleName</name> = <call><name>PyObject_GetAttrString</name><argument_list>(<argument><expr><name>exception</name></expr></argument>, <argument><expr>"__module__"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>moduleName</name> == <name>NULL</name></expr>)</condition><then>
<expr_stmt><expr><name>err</name> = <call><name>PyFile_WriteString</name><argument_list>(<argument><expr>"&lt;unknown&gt;"</expr></argument>, <argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
<else>else <block>{
<decl_stmt><decl><type><name>char</name>*</type> <name>modstr</name> <init>= <expr><call><name>PyString_AsString</name><argument_list>(<argument><expr><name>moduleName</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>modstr</name> &amp;&amp; <call><name>strcmp</name><argument_list>(<argument><expr><name>modstr</name></expr></argument>, <argument><expr>"exceptions"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><name>err</name> = <call><name>PyFile_WriteString</name><argument_list>(<argument><expr><name>modstr</name></expr></argument>, <argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>err</name> += <call><name>PyFile_WriteString</name><argument_list>(<argument><expr>"."</expr></argument>, <argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>moduleName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></else></if>
<if>if <condition>(<expr><name>err</name> == 0</expr>)</condition><then> <block>{
<if>if <condition>(<expr><name>className</name> == <name>NULL</name></expr>)</condition><then>
<expr_stmt><expr><name>err</name> = <call><name>PyFile_WriteString</name><argument_list>(<argument><expr>"&lt;unknown&gt;"</expr></argument>, <argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
<else>else
<expr_stmt><expr><name>err</name> = <call><name>PyFile_WriteString</name><argument_list>(<argument><expr><name>className</name></expr></argument>, <argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
}</block></then></if>
}</block></then> <else>else
<expr_stmt><expr><name>err</name> = <call><name>PyFile_WriteObject</name><argument_list>(<argument><expr><name>exception</name></expr></argument>, <argument><expr><name>f</name></expr></argument>, <argument><expr><name>Py_PRINT_RAW</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if></else></if>
<if>if <condition>(<expr><name>err</name> == 0 &amp;&amp; (<name>value</name> != <name>Py_None</name>)</expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>s</name> <init>= <expr><call><name>PyObject_Str</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>s</name> == <name>NULL</name></expr>)</condition><then>
<expr_stmt><expr><name>err</name> = -1</expr>;</expr_stmt></then>
<else>else <if>if <condition>(<expr>!<call><name>PyString_Check</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call> ||
<call><name>PyString_GET_SIZE</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call> != 0</expr>)</condition><then>
<expr_stmt><expr><name>err</name> = <call><name>PyFile_WriteString</name><argument_list>(<argument><expr>": "</expr></argument>, <argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if></else></if>
<if>if <condition>(<expr><name>err</name> == 0</expr>)</condition><then>
<expr_stmt><expr><name>err</name> = <call><name>PyFile_WriteObject</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>f</name></expr></argument>, <argument><expr><name>Py_PRINT_RAW</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><name>err</name> += <call><name>PyFile_WriteString</name><argument_list>(<argument><expr>"\n"</expr></argument>, <argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></else></if>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>err</name> != 0</expr>)</condition><then>
<expr_stmt><expr><call><name>PyErr_Clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>
}</block></function>
<function><type><name>PyObject</name> *</type>
<name>PyRun_StringFlags</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>str</name></decl></param>, <param><decl><type><name>int</name></type> <name>start</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>globals</name></decl></param>,
<param><decl><type><name>PyObject</name> *</type><name>locals</name></decl></param>, <param><decl><type><name>PyCompilerFlags</name> *</type><name>flags</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>ret</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>mod_ty</name></type> <name>mod</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyArena</name> *</type><name>arena</name> <init>= <expr><call><name>PyArena_New</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>arena</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>mod</name> = <call><name>PyParser_ASTFromString</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr>"&lt;string&gt;"</expr></argument>, <argument><expr><name>start</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>, <argument><expr><name>arena</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>mod</name> != <name>NULL</name></expr>)</condition><then>
<expr_stmt><expr><name>ret</name> = <call><name>run_mod</name><argument_list>(<argument><expr><name>mod</name></expr></argument>, <argument><expr>"&lt;string&gt;"</expr></argument>, <argument><expr><name>globals</name></expr></argument>, <argument><expr><name>locals</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>, <argument><expr><name>arena</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<expr_stmt><expr><call><name>PyArena_Free</name><argument_list>(<argument><expr><name>arena</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>ret</name></expr>;</return>
}</block></function>
<function><type><name>PyObject</name> *</type>
<name>PyRun_FileExFlags</name><parameter_list>(<param><decl><type><name>FILE</name> *</type><name>fp</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>filename</name></decl></param>, <param><decl><type><name>int</name></type> <name>start</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>globals</name></decl></param>,
<param><decl><type><name>PyObject</name> *</type><name>locals</name></decl></param>, <param><decl><type><name>int</name></type> <name>closeit</name></decl></param>, <param><decl><type><name>PyCompilerFlags</name> *</type><name>flags</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>ret</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>mod_ty</name></type> <name>mod</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyArena</name> *</type><name>arena</name> <init>= <expr><call><name>PyArena_New</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>arena</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>mod</name> = <call><name>PyParser_ASTFromFile</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><name>filename</name></expr></argument>, <argument><expr><name>start</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>,
<argument><expr><name>flags</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>arena</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>closeit</name></expr>)</condition><then>
<expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<if>if <condition>(<expr><name>mod</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyArena_Free</name><argument_list>(<argument><expr><name>arena</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>ret</name> = <call><name>run_mod</name><argument_list>(<argument><expr><name>mod</name></expr></argument>, <argument><expr><name>filename</name></expr></argument>, <argument><expr><name>globals</name></expr></argument>, <argument><expr><name>locals</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>, <argument><expr><name>arena</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyArena_Free</name><argument_list>(<argument><expr><name>arena</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>ret</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>run_mod</name><parameter_list>(<param><decl><type><name>mod_ty</name></type> <name>mod</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>filename</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>globals</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>locals</name></decl></param>,
<param><decl><type><name>PyCompilerFlags</name> *</type><name>flags</name></decl></param>, <param><decl><type><name>PyArena</name> *</type><name>arena</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyCodeObject</name> *</type><name>co</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>v</name></decl>;</decl_stmt>
<expr_stmt><expr><name>co</name> = <call><name>PyAST_Compile</name><argument_list>(<argument><expr><name>mod</name></expr></argument>, <argument><expr><name>filename</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>, <argument><expr><name>arena</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>co</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>v</name> = <call><name>PyEval_EvalCode</name><argument_list>(<argument><expr><name>co</name></expr></argument>, <argument><expr><name>globals</name></expr></argument>, <argument><expr><name>locals</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>co</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>v</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>run_pyc_file</name><parameter_list>(<param><decl><type><name>FILE</name> *</type><name>fp</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>filename</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>globals</name></decl></param>,
<param><decl><type><name>PyObject</name> *</type><name>locals</name></decl></param>, <param><decl><type><name>PyCompilerFlags</name> *</type><name>flags</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyCodeObject</name> *</type><name>co</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>v</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>long</name></type> <name>magic</name></decl>;</decl_stmt>
<function_decl><type><name>long</name></type> <name>PyImport_GetMagicNumber</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list>;</function_decl>
<expr_stmt><expr><name>magic</name> = <call><name>PyMarshal_ReadLongFromFile</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>magic</name> != <call><name>PyImport_GetMagicNumber</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_RuntimeError</name></expr></argument>,
<argument><expr>"Bad magic number in .pyc file"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr>(<name>void</name>) <call><name>PyMarshal_ReadLongFromFile</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>v</name> = <call><name>PyMarshal_ReadLastObjectFromFile</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>v</name> == <name>NULL</name> || !<call><name>PyCode_Check</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_RuntimeError</name></expr></argument>,
<argument><expr>"Bad code object in .pyc file"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>co</name> = (<name>PyCodeObject</name> *)<name>v</name></expr>;</expr_stmt>
<expr_stmt><expr><name>v</name> = <call><name>PyEval_EvalCode</name><argument_list>(<argument><expr><name>co</name></expr></argument>, <argument><expr><name>globals</name></expr></argument>, <argument><expr><name>locals</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>v</name> &amp;&amp; <name>flags</name></expr>)</condition><then>
<expr_stmt><expr><name><name>flags</name>-&gt;<name>cf_flags</name></name> |= (<name><name>co</name>-&gt;<name>co_flags</name></name> &amp; <name>PyCF_MASK</name>)</expr>;</expr_stmt></then></if>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>co</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>v</name></expr>;</return>
}</block></function>
<function><type><name>PyObject</name> *</type>
<name>Py_CompileStringFlags</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>str</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>filename</name></decl></param>, <param><decl><type><name>int</name></type> <name>start</name></decl></param>,
<param><decl><type><name>PyCompilerFlags</name> *</type><name>flags</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyCodeObject</name> *</type><name>co</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>mod_ty</name></type> <name>mod</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyArena</name> *</type><name>arena</name> <init>= <expr><call><name>PyArena_New</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>arena</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>mod</name> = <call><name>PyParser_ASTFromString</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>filename</name></expr></argument>, <argument><expr><name>start</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>, <argument><expr><name>arena</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>mod</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyArena_Free</name><argument_list>(<argument><expr><name>arena</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<if>if <condition>(<expr><name>flags</name> &amp;&amp; (<name><name>flags</name>-&gt;<name>cf_flags</name></name> &amp; <name>PyCF_ONLY_AST</name>)</expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>result</name> <init>= <expr><call><name>PyAST_mod2obj</name><argument_list>(<argument><expr><name>mod</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>PyArena_Free</name><argument_list>(<argument><expr><name>arena</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>result</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>co</name> = <call><name>PyAST_Compile</name><argument_list>(<argument><expr><name>mod</name></expr></argument>, <argument><expr><name>filename</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>, <argument><expr><name>arena</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyArena_Free</name><argument_list>(<argument><expr><name>arena</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>(<name>PyObject</name> *)<name>co</name></expr>;</return>
}</block></function>
<function><type>struct <name>symtable</name> *</type>
<name>Py_SymtableString</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>str</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>filename</name></decl></param>, <param><decl><type><name>int</name></type> <name>start</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type>struct <name>symtable</name> *</type><name>st</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>mod_ty</name></type> <name>mod</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyCompilerFlags</name></type> <name>flags</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyArena</name> *</type><name>arena</name> <init>= <expr><call><name>PyArena_New</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>arena</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name><name>flags</name>.<name>cf_flags</name></name> = 0</expr>;</expr_stmt>
<expr_stmt><expr><name>mod</name> = <call><name>PyParser_ASTFromString</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>filename</name></expr></argument>, <argument><expr><name>start</name></expr></argument>, <argument><expr>&amp;<name>flags</name></expr></argument>, <argument><expr><name>arena</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>mod</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyArena_Free</name><argument_list>(<argument><expr><name>arena</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>st</name> = <call><name>PySymtable_Build</name><argument_list>(<argument><expr><name>mod</name></expr></argument>, <argument><expr><name>filename</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyArena_Free</name><argument_list>(<argument><expr><name>arena</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>st</name></expr>;</return>
}</block></function>
<function><type><name>mod_ty</name></type>
<name>PyParser_ASTFromString</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>s</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>filename</name></decl></param>, <param><decl><type><name>int</name></type> <name>start</name></decl></param>,
<param><decl><type><name>PyCompilerFlags</name> *</type><name>flags</name></decl></param>, <param><decl><type><name>PyArena</name> *</type><name>arena</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>mod_ty</name></type> <name>mod</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyCompilerFlags</name></type> <name>localflags</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>perrdetail</name></type> <name>err</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>iflags</name> <init>= <expr><call><name>PARSER_FLAGS</name><argument_list>(<argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>node</name> *</type><name>n</name> <init>= <expr><call><name>PyParser_ParseStringFlagsFilenameEx</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>filename</name></expr></argument>,
<argument><expr>&amp;<name>_PyParser_Grammar</name></expr></argument>, <argument><expr><name>start</name></expr></argument>, <argument><expr>&amp;<name>err</name></expr></argument>,
<argument><expr>&amp;<name>iflags</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>flags</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>localflags</name>.<name>cf_flags</name></name> = 0</expr>;</expr_stmt>
<expr_stmt><expr><name>flags</name> = &amp;<name>localflags</name></expr>;</expr_stmt>
}</block></then></if>
<if>if <condition>(<expr><name>n</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>flags</name>-&gt;<name>cf_flags</name></name> |= <name>iflags</name> &amp; <name>PyCF_MASK</name></expr>;</expr_stmt>
<expr_stmt><expr><name>mod</name> = <call><name>PyAST_FromNode</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>, <argument><expr><name>filename</name></expr></argument>, <argument><expr><name>arena</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyNode_Free</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>mod</name></expr>;</return>
}</block></then> <else>else <block>{
<expr_stmt><expr><call><name>err_input</name><argument_list>(<argument><expr>&amp;<name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></else></if>
}</block></function>
<function><type><name>mod_ty</name></type>
<name>PyParser_ASTFromFile</name><parameter_list>(<param><decl><type><name>FILE</name> *</type><name>fp</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>filename</name></decl></param>, <param><decl><type><name>int</name></type> <name>start</name></decl></param>, <param><decl><type><name>char</name> *</type><name>ps1</name></decl></param>,
<param><decl><type><name>char</name> *</type><name>ps2</name></decl></param>, <param><decl><type><name>PyCompilerFlags</name> *</type><name>flags</name></decl></param>, <param><decl><type><name>int</name> *</type><name>errcode</name></decl></param>,
<param><decl><type><name>PyArena</name> *</type><name>arena</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>mod_ty</name></type> <name>mod</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyCompilerFlags</name></type> <name>localflags</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>perrdetail</name></type> <name>err</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>iflags</name> <init>= <expr><call><name>PARSER_FLAGS</name><argument_list>(<argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>node</name> *</type><name>n</name> <init>= <expr><call><name>PyParser_ParseFileFlagsEx</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><name>filename</name></expr></argument>, <argument><expr>&amp;<name>_PyParser_Grammar</name></expr></argument>,
<argument><expr><name>start</name></expr></argument>, <argument><expr><name>ps1</name></expr></argument>, <argument><expr><name>ps2</name></expr></argument>, <argument><expr>&amp;<name>err</name></expr></argument>, <argument><expr>&amp;<name>iflags</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>flags</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>localflags</name>.<name>cf_flags</name></name> = 0</expr>;</expr_stmt>
<expr_stmt><expr><name>flags</name> = &amp;<name>localflags</name></expr>;</expr_stmt>
}</block></then></if>
<if>if <condition>(<expr><name>n</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>flags</name>-&gt;<name>cf_flags</name></name> |= <name>iflags</name> &amp; <name>PyCF_MASK</name></expr>;</expr_stmt>
<expr_stmt><expr><name>mod</name> = <call><name>PyAST_FromNode</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>, <argument><expr><name>filename</name></expr></argument>, <argument><expr><name>arena</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyNode_Free</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>mod</name></expr>;</return>
}</block></then> <else>else <block>{
<expr_stmt><expr><call><name>err_input</name><argument_list>(<argument><expr>&amp;<name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>errcode</name></expr>)</condition><then>
<expr_stmt><expr>*<name>errcode</name> = <name><name>err</name>.<name>error</name></name></expr>;</expr_stmt></then></if>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></else></if>
}</block></function>
<function><type><name>node</name> *</type>
<name>PyParser_SimpleParseFileFlags</name><parameter_list>(<param><decl><type><name>FILE</name> *</type><name>fp</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>filename</name></decl></param>, <param><decl><type><name>int</name></type> <name>start</name></decl></param>, <param><decl><type><name>int</name></type> <name>flags</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>perrdetail</name></type> <name>err</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>node</name> *</type><name>n</name> <init>= <expr><call><name>PyParser_ParseFileFlags</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><name>filename</name></expr></argument>, <argument><expr>&amp;<name>_PyParser_Grammar</name></expr></argument>,
<argument><expr><name>start</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr>&amp;<name>err</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>n</name> == <name>NULL</name></expr>)</condition><then>
<expr_stmt><expr><call><name>err_input</name><argument_list>(<argument><expr>&amp;<name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<return>return <expr><name>n</name></expr>;</return>
}</block></function>
<function><type><name>node</name> *</type>
<name>PyParser_SimpleParseStringFlags</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>str</name></decl></param>, <param><decl><type><name>int</name></type> <name>start</name></decl></param>, <param><decl><type><name>int</name></type> <name>flags</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>perrdetail</name></type> <name>err</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>node</name> *</type><name>n</name> <init>= <expr><call><name>PyParser_ParseStringFlags</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr>&amp;<name>_PyParser_Grammar</name></expr></argument>,
<argument><expr><name>start</name></expr></argument>, <argument><expr>&amp;<name>err</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>n</name> == <name>NULL</name></expr>)</condition><then>
<expr_stmt><expr><call><name>err_input</name><argument_list>(<argument><expr>&amp;<name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<return>return <expr><name>n</name></expr>;</return>
}</block></function>
<function><type><name>node</name> *</type>
<name>PyParser_SimpleParseStringFlagsFilename</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>str</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>filename</name></decl></param>,
<param><decl><type><name>int</name></type> <name>start</name></decl></param>, <param><decl><type><name>int</name></type> <name>flags</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>perrdetail</name></type> <name>err</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>node</name> *</type><name>n</name> <init>= <expr><call><name>PyParser_ParseStringFlagsFilename</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>filename</name></expr></argument>,
<argument><expr>&amp;<name>_PyParser_Grammar</name></expr></argument>, <argument><expr><name>start</name></expr></argument>, <argument><expr>&amp;<name>err</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>n</name> == <name>NULL</name></expr>)</condition><then>
<expr_stmt><expr><call><name>err_input</name><argument_list>(<argument><expr>&amp;<name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<return>return <expr><name>n</name></expr>;</return>
}</block></function>
<function><type><name>node</name> *</type>
<name>PyParser_SimpleParseStringFilename</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>str</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>filename</name></decl></param>, <param><decl><type><name>int</name></type> <name>start</name></decl></param>)</parameter_list> <block>{
<return>return <expr><call><name>PyParser_SimpleParseStringFlagsFilename</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>filename</name></expr></argument>, <argument><expr><name>start</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><name>void</name></type>
<name>PyParser_SetError</name><parameter_list>(<param><decl><type><name>perrdetail</name> *</type><name>err</name></decl></param>)</parameter_list> <block>{
<expr_stmt><expr><call><name>err_input</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>err_input</name><parameter_list>(<param><decl><type><name>perrdetail</name> *</type><name>err</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>v</name></decl>, *<decl><type ref="prev"/><name>w</name></decl>, *<decl><type ref="prev"/><name>errtype</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name>*</type> <name>u</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>msg</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>errtype</name> = <name>PyExc_SyntaxError</name></expr>;</expr_stmt>
<switch>switch <condition>(<expr><name><name>err</name>-&gt;<name>error</name></name></expr>)</condition> <block>{
<case>case <expr><name>E_SYNTAX</name></expr>:
<expr_stmt><expr><name>errtype</name> = <name>PyExc_IndentationError</name></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>err</name>-&gt;<name>expected</name></name> == <name>INDENT</name></expr>)</condition><then>
<expr_stmt><expr><name>msg</name> = "expected an indented block"</expr>;</expr_stmt></then>
<else>else <if>if <condition>(<expr><name><name>err</name>-&gt;<name>token</name></name> == <name>INDENT</name></expr>)</condition><then>
<expr_stmt><expr><name>msg</name> = "unexpected indent"</expr>;</expr_stmt></then>
<else>else <if>if <condition>(<expr><name><name>err</name>-&gt;<name>token</name></name> == <name>DEDENT</name></expr>)</condition><then>
<expr_stmt><expr><name>msg</name> = "unexpected unindent"</expr>;</expr_stmt></then>
<else>else <block>{
<expr_stmt><expr><name>errtype</name> = <name>PyExc_SyntaxError</name></expr>;</expr_stmt>
<expr_stmt><expr><name>msg</name> = "invalid syntax"</expr>;</expr_stmt>
}</block></else></if></else></if></else></if>
<break>break;</break>
</case><case>case <expr><name>E_TOKEN</name></expr>:
<expr_stmt><expr><name>msg</name> = "invalid token"</expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr><name>E_EOFS</name></expr>:
<expr_stmt><expr><name>msg</name> = "EOF while scanning triple-quoted string literal"</expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr><name>E_EOLS</name></expr>:
<expr_stmt><expr><name>msg</name> = "EOL while scanning string literal"</expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr><name>E_INTR</name></expr>:
<if>if <condition>(<expr>!<call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then>
<expr_stmt><expr><call><name>PyErr_SetNone</name><argument_list>(<argument><expr><name>PyExc_KeyboardInterrupt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<goto>goto <name>cleanup</name>;</goto>
</case><case>case <expr><name>E_NOMEM</name></expr>:
<expr_stmt><expr><call><name>PyErr_NoMemory</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>cleanup</name>;</goto>
</case><case>case <expr><name>E_EOF</name></expr>:
<expr_stmt><expr><name>msg</name> = "unexpected EOF while parsing"</expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr><name>E_TABSPACE</name></expr>:
<expr_stmt><expr><name>errtype</name> = <name>PyExc_TabError</name></expr>;</expr_stmt>
<expr_stmt><expr><name>msg</name> = "inconsistent use of tabs and spaces in indentation"</expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr><name>E_OVERFLOW</name></expr>:
<expr_stmt><expr><name>msg</name> = "expression too long"</expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr><name>E_DEDENT</name></expr>:
<expr_stmt><expr><name>errtype</name> = <name>PyExc_IndentationError</name></expr>;</expr_stmt>
<expr_stmt><expr><name>msg</name> = "unindent does not match any outer indentation level"</expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr><name>E_TOODEEP</name></expr>:
<expr_stmt><expr><name>errtype</name> = <name>PyExc_IndentationError</name></expr>;</expr_stmt>
<expr_stmt><expr><name>msg</name> = "too many levels of indentation"</expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr><name>E_DECODE</name></expr>: <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>type</name></decl>, *<decl><type ref="prev"/><name>value</name></decl>, *<decl><type ref="prev"/><name>tb</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>PyErr_Fetch</name><argument_list>(<argument><expr>&amp;<name>type</name></expr></argument>, <argument><expr>&amp;<name>value</name></expr></argument>, <argument><expr>&amp;<name>tb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>value</name> != <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>u</name> = <call><name>PyObject_Str</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>u</name> != <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>msg</name> = <call><name>PyString_AsString</name><argument_list>(<argument><expr><name>u</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
}</block></then></if>
<if>if <condition>(<expr><name>msg</name> == <name>NULL</name></expr>)</condition><then>
<expr_stmt><expr><name>msg</name> = "unknown decode error"</expr>;</expr_stmt></then></if>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>tb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
}</block>
</case><case>case <expr><name>E_LINECONT</name></expr>:
<expr_stmt><expr><name>msg</name> = "unexpected character after line continuation character"</expr>;</expr_stmt>
<break>break;</break>
</case><default>default:
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr>"error=%d\n"</expr></argument>, <argument><expr><name><name>err</name>-&gt;<name>error</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>msg</name> = "unknown parsing error"</expr>;</expr_stmt>
<break>break;</break>
</default>}</block></switch>
<expr_stmt><expr><name>v</name> = <call><name>Py_BuildValue</name><argument_list>(<argument><expr>"(ziiz)"</expr></argument>, <argument><expr><name><name>err</name>-&gt;<name>filename</name></name></expr></argument>,
<argument><expr><name><name>err</name>-&gt;<name>lineno</name></name></expr></argument>, <argument><expr><name><name>err</name>-&gt;<name>offset</name></name></expr></argument>, <argument><expr><name><name>err</name>-&gt;<name>text</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>w</name> = <name>NULL</name></expr>;</expr_stmt>
<if>if <condition>(<expr><name>v</name> != <name>NULL</name></expr>)</condition><then>
<expr_stmt><expr><name>w</name> = <call><name>Py_BuildValue</name><argument_list>(<argument><expr>"(sO)"</expr></argument>, <argument><expr><name>msg</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>u</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyErr_SetObject</name><argument_list>(<argument><expr><name>errtype</name></expr></argument>, <argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<label><name>cleanup</name>:</label>
<if>if <condition>(<expr><name><name>err</name>-&gt;<name>text</name></name> != <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyObject_FREE</name><argument_list>(<argument><expr><name><name>err</name>-&gt;<name>text</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>err</name>-&gt;<name>text</name></name> = <name>NULL</name></expr>;</expr_stmt>
}</block></then></if>
}</block></function>
<function><type><name>void</name></type>
<name>Py_FatalError</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>msg</name></decl></param>)</parameter_list> <block>{
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr>"Fatal Python error: %s\n"</expr></argument>, <argument><expr><name>msg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MS_WINDOWS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>OutputDebugString</name><argument_list>(<argument><expr>"Fatal Python error: "</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OutputDebugString</name><argument_list>(<argument><expr><name>msg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OutputDebugString</name><argument_list>(<argument><expr>"\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_DEBUG</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>DebugBreak</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><call><name>abort</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
}</block></function>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>WITH_THREAD</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pythread.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NEXITFUNCS</name></cpp:macro> <cpp:value>32</cpp:value></cpp:define>
<function_decl><type><specifier>static</specifier> <name>void</name></type> (*<name>exitfuncs</name><index>[<expr><name>NEXITFUNCS</name></expr>]</index>)<parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list>;</function_decl>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>nexitfuncs</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<function><type><name>int</name></type> <name>Py_AtExit</name><parameter_list>(<param><function_decl><type><name>void</name></type> (*<name>func</name>)<parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list></function_decl></param>)</parameter_list> <block>{
<if>if <condition>(<expr><name>nexitfuncs</name> &gt;= <name>NEXITFUNCS</name></expr>)</condition><then>
<return>return <expr>-1</expr>;</return></then></if>
<expr_stmt><expr><name><name>exitfuncs</name><index>[<expr><name>nexitfuncs</name>++</expr>]</index></name> = <name>func</name></expr>;</expr_stmt>
<return>return <expr>0</expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>call_sys_exitfunc</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>exitfunc</name> <init>= <expr><call><name>PySys_GetObject</name><argument_list>(<argument><expr>"exitfunc"</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>exitfunc</name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>res</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>exitfunc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PySys_SetObject</name><argument_list>(<argument><expr>"exitfunc"</expr></argument>, <argument><expr>(<name>PyObject</name> *)<name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>res</name> = <call><name>PyEval_CallObject</name><argument_list>(<argument><expr><name>exitfunc</name></expr></argument>, <argument><expr>(<name>PyObject</name> *)<name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>res</name> == <name>NULL</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr>!<call><name>PyErr_ExceptionMatches</name><argument_list>(<argument><expr><name>PyExc_SystemExit</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PySys_WriteStderr</name><argument_list>(<argument><expr>"Error in sys.exitfunc:\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><call><name>PyErr_Print</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>exitfunc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<if>if <condition>(<expr><call><name>Py_FlushLine</name><argument_list>()</argument_list></call></expr>)</condition><then>
<expr_stmt><expr><call><name>PyErr_Clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>
}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>call_ll_exitfuncs</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list> <block>{
<while>while <condition>(<expr><name>nexitfuncs</name> &gt; 0</expr>)</condition>
<expr_stmt><expr><call>(*<name>exitfuncs</name><index>[<expr>--<name>nexitfuncs</name></expr>]</index>)<argument_list>()</argument_list></call></expr>;</expr_stmt></while>
<expr_stmt><expr><call><name>fflush</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>fflush</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>
<function><type><name>void</name></type>
<name>Py_Exit</name><parameter_list>(<param><decl><type><name>int</name></type> <name>sts</name></decl></param>)</parameter_list> <block>{
<expr_stmt><expr><call><name>Py_Finalize</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><name>sts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>initsigs</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list> <block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SIGPIPE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyOS_setsig</name><argument_list>(<argument><expr><name>SIGPIPE</name></expr></argument>, <argument><expr><name>SIG_IGN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SIGXFZ</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyOS_setsig</name><argument_list>(<argument><expr><name>SIGXFZ</name></expr></argument>, <argument><expr><name>SIG_IGN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SIGXFSZ</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyOS_setsig</name><argument_list>(<argument><expr><name>SIGXFSZ</name></expr></argument>, <argument><expr><name>SIG_IGN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><call><name>PyOS_InitInterrupts</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
}</block></function>
<function><type><name>int</name></type>
<name>Py_FdIsInteractive</name><parameter_list>(<param><decl><type><name>FILE</name> *</type><name>fp</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>filename</name></decl></param>)</parameter_list> <block>{
<if>if <condition>(<expr><call><name>isatty</name><argument_list>(<argument><expr>(<name>int</name>)<call><name>fileno</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr>1</expr>;</return></then></if>
<if>if <condition>(<expr>!<name>Py_InteractiveFlag</name></expr>)</condition><then>
<return>return <expr>0</expr>;</return></then></if>
<return>return <expr>(<name>filename</name> == <name>NULL</name>) ||
(<call><name>strcmp</name><argument_list>(<argument><expr><name>filename</name></expr></argument>, <argument><expr>"&lt;stdin&gt;"</expr></argument>)</argument_list></call> == 0) ||
(<call><name>strcmp</name><argument_list>(<argument><expr><name>filename</name></expr></argument>, <argument><expr>"???"</expr></argument>)</argument_list></call> == 0)</expr>;</return>
}</block></function>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>USE_STACKCHECK</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>WIN32</name></expr></argument>)</argument_list></call> &amp;&amp; <call><name>defined</name><argument_list>(<argument><expr><name>_MSC_VER</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;malloc.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;excpt.h&gt;</cpp:file></cpp:include>
<function><type><name>int</name></type>
<name>PyOS_CheckStack</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list> <block>{
<macro><name>__try</name></macro> <block>{
<expr_stmt><expr><call><name>alloca</name><argument_list>(<argument><expr><name>PYOS_STACK_MARGIN</name> * <sizeof>sizeof<argument_list>(<argument><expr><name>void</name>*</expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>0</expr>;</return>
}</block> <macro><name>__except</name> <argument_list>(<argument>GetExceptionCode() == STATUS_STACK_OVERFLOW ?
EXCEPTION_EXECUTE_HANDLER :
EXCEPTION_CONTINUE_SEARCH</argument>)</argument_list></macro> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>errcode</name> <init>= <expr><call><name>_resetstkoflw</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>errcode</name> == 0</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_FatalError</name><argument_list>(<argument><expr>"Could not reset the stack!"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
}</block>
<return>return <expr>1</expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<function><type><name>PyOS_sighandler_t</name></type>
<name>PyOS_getsig</name><parameter_list>(<param><decl><type><name>int</name></type> <name>sig</name></decl></param>)</parameter_list> <block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_SIGACTION</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type>struct <name>sigaction</name></type> <name>context</name></decl>;</decl_stmt>
<if>if <condition>(<expr><call><name>sigaction</name><argument_list>(<argument><expr><name>sig</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr>&amp;<name>context</name></expr></argument>)</argument_list></call> == -1</expr>)</condition><then>
<return>return <expr><name>SIG_ERR</name></expr>;</return></then></if>
<return>return <expr><name><name>context</name>.<name>sa_handler</name></name></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<decl_stmt><decl><type><name>PyOS_sighandler_t</name></type> <name>handler</name></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_MSC_VER</name></expr></argument>)</argument_list></call> &amp;&amp; <name>_MSC_VER</name> &gt;= 1400</expr></cpp:if>
<switch>switch <condition>(<expr><name>sig</name></expr>)</condition> <block>{
<case>case <expr><name>SIGINT</name></expr>:
</case><case>case <expr><name>SIGILL</name></expr>:
</case><case>case <expr><name>SIGFPE</name></expr>:
</case><case>case <expr><name>SIGSEGV</name></expr>:
</case><case>case <expr><name>SIGTERM</name></expr>:
</case><case>case <expr><name>SIGBREAK</name></expr>:
</case><case>case <expr><name>SIGABRT</name></expr>:
<break>break;</break>
</case><default>default:
<return>return <expr><name>SIG_ERR</name></expr>;</return>
</default>}</block></switch>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><name>handler</name> = <call><name>signal</name><argument_list>(<argument><expr><name>sig</name></expr></argument>, <argument><expr><name>SIG_IGN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>handler</name> != <name>SIG_ERR</name></expr>)</condition><then>
<expr_stmt><expr><call><name>signal</name><argument_list>(<argument><expr><name>sig</name></expr></argument>, <argument><expr><name>handler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<return>return <expr><name>handler</name></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></function>
<function><type><name>PyOS_sighandler_t</name></type>
<name>PyOS_setsig</name><parameter_list>(<param><decl><type><name>int</name></type> <name>sig</name></decl></param>, <param><decl><type><name>PyOS_sighandler_t</name></type> <name>handler</name></decl></param>)</parameter_list> <block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_SIGACTION</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type>struct <name>sigaction</name></type> <name>context</name></decl>, <decl><type ref="prev"/><name>ocontext</name></decl>;</decl_stmt>
<expr_stmt><expr><name><name>context</name>.<name>sa_handler</name></name> = <name>handler</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>sigemptyset</name><argument_list>(<argument><expr>&amp;<name><name>context</name>.<name>sa_mask</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>context</name>.<name>sa_flags</name></name> = 0</expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>sigaction</name><argument_list>(<argument><expr><name>sig</name></expr></argument>, <argument><expr>&amp;<name>context</name></expr></argument>, <argument><expr>&amp;<name>ocontext</name></expr></argument>)</argument_list></call> == -1</expr>)</condition><then>
<return>return <expr><name>SIG_ERR</name></expr>;</return></then></if>
<return>return <expr><name><name>ocontext</name>.<name>sa_handler</name></name></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<decl_stmt><decl><type><name>PyOS_sighandler_t</name></type> <name>oldhandler</name></decl>;</decl_stmt>
<expr_stmt><expr><name>oldhandler</name> = <call><name>signal</name><argument_list>(<argument><expr><name>sig</name></expr></argument>, <argument><expr><name>handler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_SIGINTERRUPT</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>siginterrupt</name><argument_list>(<argument><expr><name>sig</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<return>return <expr><name>oldhandler</name></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></function>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>PyParser_SimpleParseFile</name></cpp:undef>
<macro><name>PyAPI_FUNC</name><argument_list>(<argument>node *</argument>)</argument_list></macro>
<macro><name>PyParser_SimpleParseFile</name><argument_list>(<argument>FILE *fp</argument>, <argument>const char *filename</argument>, <argument>int start</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name>PyParser_SimpleParseFileFlags</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><name>filename</name></expr></argument>, <argument><expr><name>start</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</return>
}</block>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>PyParser_SimpleParseString</name></cpp:undef>
<macro><name>PyAPI_FUNC</name><argument_list>(<argument>node *</argument>)</argument_list></macro>
<macro><name>PyParser_SimpleParseString</name><argument_list>(<argument>const char *str</argument>, <argument>int start</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name>PyParser_SimpleParseStringFlags</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>start</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</return>
}</block>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>PyRun_AnyFile</name></cpp:undef>
<macro><name>PyAPI_FUNC</name><argument_list>(<argument>int</argument>)</argument_list></macro>
<macro><name>PyRun_AnyFile</name><argument_list>(<argument>FILE *fp</argument>, <argument>const char *name</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name>PyRun_AnyFileExFlags</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>PyRun_AnyFileEx</name></cpp:undef>
<macro><name>PyAPI_FUNC</name><argument_list>(<argument>int</argument>)</argument_list></macro>
<macro><name>PyRun_AnyFileEx</name><argument_list>(<argument>FILE *fp</argument>, <argument>const char *name</argument>, <argument>int closeit</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name>PyRun_AnyFileExFlags</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>closeit</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>PyRun_AnyFileFlags</name></cpp:undef>
<macro><name>PyAPI_FUNC</name><argument_list>(<argument>int</argument>)</argument_list></macro>
<macro><name>PyRun_AnyFileFlags</name><argument_list>(<argument>FILE *fp</argument>, <argument>const char *name</argument>, <argument>PyCompilerFlags *flags</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name>PyRun_AnyFileExFlags</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>PyRun_File</name></cpp:undef>
<macro><name>PyAPI_FUNC</name><argument_list>(<argument>PyObject *</argument>)</argument_list></macro>
<macro><name>PyRun_File</name><argument_list>(<argument>FILE *fp</argument>, <argument>const char *p</argument>, <argument>int s</argument>, <argument>PyObject *g</argument>, <argument>PyObject *l</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name>PyRun_FileExFlags</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>g</name></expr></argument>, <argument><expr><name>l</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>PyRun_FileEx</name></cpp:undef>
<macro><name>PyAPI_FUNC</name><argument_list>(<argument>PyObject *</argument>)</argument_list></macro>
<macro><name>PyRun_FileEx</name><argument_list>(<argument>FILE *fp</argument>, <argument>const char *p</argument>, <argument>int s</argument>, <argument>PyObject *g</argument>, <argument>PyObject *l</argument>, <argument>int c</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name>PyRun_FileExFlags</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>g</name></expr></argument>, <argument><expr><name>l</name></expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>PyRun_FileFlags</name></cpp:undef>
<macro><name>PyAPI_FUNC</name><argument_list>(<argument>PyObject *</argument>)</argument_list></macro>
<macro><name>PyRun_FileFlags</name><argument_list>(<argument>FILE *fp</argument>, <argument>const char *p</argument>, <argument>int s</argument>, <argument>PyObject *g</argument>, <argument>PyObject *l</argument>,
<argument>PyCompilerFlags *flags</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name>PyRun_FileExFlags</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>g</name></expr></argument>, <argument><expr><name>l</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>PyRun_SimpleFile</name></cpp:undef>
<macro><name>PyAPI_FUNC</name><argument_list>(<argument>int</argument>)</argument_list></macro>
<macro><name>PyRun_SimpleFile</name><argument_list>(<argument>FILE *f</argument>, <argument>const char *p</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name>PyRun_SimpleFileExFlags</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>PyRun_SimpleFileEx</name></cpp:undef>
<macro><name>PyAPI_FUNC</name><argument_list>(<argument>int</argument>)</argument_list></macro>
<macro><name>PyRun_SimpleFileEx</name><argument_list>(<argument>FILE *f</argument>, <argument>const char *p</argument>, <argument>int c</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name>PyRun_SimpleFileExFlags</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>PyRun_String</name></cpp:undef>
<macro><name>PyAPI_FUNC</name><argument_list>(<argument>PyObject *</argument>)</argument_list></macro>
<macro><name>PyRun_String</name><argument_list>(<argument>const char *str</argument>, <argument>int s</argument>, <argument>PyObject *g</argument>, <argument>PyObject *l</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name>PyRun_StringFlags</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>g</name></expr></argument>, <argument><expr><name>l</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>PyRun_SimpleString</name></cpp:undef>
<macro><name>PyAPI_FUNC</name><argument_list>(<argument>int</argument>)</argument_list></macro>
<macro><name>PyRun_SimpleString</name><argument_list>(<argument>const char *s</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name>PyRun_SimpleStringFlags</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>Py_CompileString</name></cpp:undef>
<macro><name>PyAPI_FUNC</name><argument_list>(<argument>PyObject *</argument>)</argument_list></macro>
<macro><name>Py_CompileString</name><argument_list>(<argument>const char *str</argument>, <argument>const char *p</argument>, <argument>int s</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name>Py_CompileStringFlags</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>PyRun_InteractiveOne</name></cpp:undef>
<macro><name>PyAPI_FUNC</name><argument_list>(<argument>int</argument>)</argument_list></macro>
<macro><name>PyRun_InteractiveOne</name><argument_list>(<argument>FILE *f</argument>, <argument>const char *p</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name>PyRun_InteractiveOneFlags</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>PyRun_InteractiveLoop</name></cpp:undef>
<macro><name>PyAPI_FUNC</name><argument_list>(<argument>int</argument>)</argument_list></macro>
<macro><name>PyRun_InteractiveLoop</name><argument_list>(<argument>FILE *f</argument>, <argument>const char *p</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name>PyRun_InteractiveLoopFlags</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__cplusplus</name></expr></argument>)</argument_list></call></expr></cpp:if>
}</block></extern>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</unit>
