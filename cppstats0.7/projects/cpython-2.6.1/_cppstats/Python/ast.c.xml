<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C" filename="Python/ast.c"><cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"Python.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"Python-ast.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"grammar.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"node.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pyarena.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ast.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"token.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parsetok.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"graminit.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;assert.h&gt;</cpp:file></cpp:include>
<struct>struct <name>compiling</name> <block>{
<decl_stmt><decl><type><name>char</name> *</type><name>c_encoding</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>c_future_unicode</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyArena</name> *</type><name>c_arena</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>c_filename</name></decl>;</decl_stmt>
}</block>;</struct>
<function_decl><type><specifier>static</specifier> <name>asdl_seq</name> *</type><name>seq_for_testlist</name><parameter_list>(<param><decl><type>struct</type> <name>compiling</name> *</decl></param>, <param><decl><type><specifier>const</specifier></type> <name>node</name> *</decl></param>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>expr_ty</name></type> <name>ast_for_expr</name><parameter_list>(<param><decl><type>struct</type> <name>compiling</name> *</decl></param>, <param><decl><type><specifier>const</specifier></type> <name>node</name> *</decl></param>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>stmt_ty</name></type> <name>ast_for_stmt</name><parameter_list>(<param><decl><type>struct</type> <name>compiling</name> *</decl></param>, <param><decl><type><specifier>const</specifier></type> <name>node</name> *</decl></param>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>asdl_seq</name> *</type><name>ast_for_suite</name><parameter_list>(<param><decl><type>struct</type> <name>compiling</name> *</decl></param>, <param><decl><type><specifier>const</specifier></type> <name>node</name> *</decl></param>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>asdl_seq</name> *</type><name>ast_for_exprlist</name><parameter_list>(<param><decl><type>struct</type> <name>compiling</name> *</decl></param>, <param><decl><type><specifier>const</specifier></type> <name>node</name> *</decl></param>,
<param><decl><type><name>expr_context_ty</name></type></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>expr_ty</name></type> <name>ast_for_testlist</name><parameter_list>(<param><decl><type>struct</type> <name>compiling</name> *</decl></param>, <param><decl><type><specifier>const</specifier></type> <name>node</name> *</decl></param>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>stmt_ty</name></type> <name>ast_for_classdef</name><parameter_list>(<param><decl><type>struct</type> <name>compiling</name> *</decl></param>, <param><decl><type><specifier>const</specifier></type> <name>node</name> *</decl></param>, <param><decl><type><name>asdl_seq</name> *</type></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>expr_ty</name></type> <name>ast_for_testlist_gexp</name><parameter_list>(<param><decl><type>struct</type> <name>compiling</name> *</decl></param>, <param><decl><type><specifier>const</specifier></type> <name>node</name> *</decl></param>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>expr_ty</name></type> <name>ast_for_call</name><parameter_list>(<param><decl><type>struct</type> <name>compiling</name> *</decl></param>, <param><decl><type><specifier>const</specifier></type> <name>node</name> *</decl></param>, <param><decl><type><name>expr_ty</name></type></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>PyObject</name> *</type><name>parsenumber</name><parameter_list>(<param><decl><type>struct</type> <name>compiling</name> *</decl></param>, <param><decl><type><specifier>const</specifier></type> <name>char</name> *</decl></param>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>PyObject</name> *</type><name>parsestr</name><parameter_list>(<param><decl><type>struct</type> <name>compiling</name> *</decl></param>, <param><decl><type><specifier>const</specifier></type> <name>char</name> *</decl></param>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>PyObject</name> *</type><name>parsestrplus</name><parameter_list>(<param><decl><type>struct</type> <name>compiling</name> *</decl></param>, <param><decl><type><specifier>const</specifier> <name>node</name> *</type><name>n</name></decl></param>)</parameter_list>;</function_decl>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>LINENO</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LINENO</name><parameter_list>(<param><type><name>n</name></type></param>)</parameter_list></cpp:macro> <cpp:value>((n)-&gt;n_lineno)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<function><type><specifier>static</specifier> <name>identifier</name></type>
<name>new_identifier</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name>*</type> <name>n</name></decl></param>, <param><decl><type><name>PyArena</name> *</type><name>arena</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyObject</name>*</type> <name>id</name> <init>= <expr><call><name>PyString_InternFromString</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>id</name> != <name>NULL</name></expr>)</condition><then>
<expr_stmt><expr><call><name>PyArena_AddPyObject</name><argument_list>(<argument><expr><name>arena</name></expr></argument>, <argument><expr><name>id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<return>return <expr><name>id</name></expr>;</return>
}</block></function>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NEW_IDENTIFIER</name><parameter_list>(<param><type><name>n</name></type></param>)</parameter_list></cpp:macro> <cpp:value>new_identifier(STR(n), c-&gt;c_arena)</cpp:value></cpp:define>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>ast_error</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>node</name> *</type><name>n</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>errstr</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>u</name> <init>= <expr><call><name>Py_BuildValue</name><argument_list>(<argument><expr>"zi"</expr></argument>, <argument><expr><name>errstr</name></expr></argument>, <argument><expr><call><name>LINENO</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr>!<name>u</name></expr>)</condition><then>
<return>return <expr>0</expr>;</return></then></if>
<expr_stmt><expr><call><name>PyErr_SetObject</name><argument_list>(<argument><expr><name>PyExc_SyntaxError</name></expr></argument>, <argument><expr><name>u</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>u</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>0</expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ast_error_finish</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>filename</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>type</name></decl>, *<decl><type ref="prev"/><name>value</name></decl>, *<decl><type ref="prev"/><name>tback</name></decl>, *<decl><type ref="prev"/><name>errstr</name></decl>, *<decl><type ref="prev"/><name>loc</name></decl>, *<decl><type ref="prev"/><name>tmp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>long</name></type> <name>lineno</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<call><name>PyErr_ExceptionMatches</name><argument_list>(<argument><expr><name>PyExc_SyntaxError</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return;</return></then></if>
<expr_stmt><expr><call><name>PyErr_Fetch</name><argument_list>(<argument><expr>&amp;<name>type</name></expr></argument>, <argument><expr>&amp;<name>value</name></expr></argument>, <argument><expr>&amp;<name>tback</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>errstr</name> = <call><name>PyTuple_GetItem</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>errstr</name></expr>)</condition><then>
<return>return;</return></then></if>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>errstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>lineno</name> = <call><name>PyInt_AsLong</name><argument_list>(<argument><expr><call><name>PyTuple_GetItem</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>lineno</name> == -1</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>errstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
}</block></then></if>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>loc</name> = <call><name>PyErr_ProgramText</name><argument_list>(<argument><expr><name>filename</name></expr></argument>, <argument><expr><name>lineno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>loc</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>loc</name> = <name>Py_None</name></expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><name>tmp</name> = <call><name>Py_BuildValue</name><argument_list>(<argument><expr>"(zlOO)"</expr></argument>, <argument><expr><name>filename</name></expr></argument>, <argument><expr><name>lineno</name></expr></argument>, <argument><expr><name>Py_None</name></expr></argument>, <argument><expr><name>loc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>loc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>tmp</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>errstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
}</block></then></if>
<expr_stmt><expr><name>value</name> = <call><name>PyTuple_Pack</name><argument_list>(<argument><expr>2</expr></argument>, <argument><expr><name>errstr</name></expr></argument>, <argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>errstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>value</name></expr>)</condition><then>
<return>return;</return></then></if>
<expr_stmt><expr><call><name>PyErr_Restore</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><name>value</name></expr></argument>, <argument><expr><name>tback</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>ast_warn</name><parameter_list>(<param><decl><type>struct <name>compiling</name> *</type><name>c</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>node</name> *</type><name>n</name></decl></param>, <param><decl><type><name>char</name> *</type><name>msg</name></decl></param>)</parameter_list> <block>{
<if>if <condition>(<expr><call><name>PyErr_WarnExplicit</name><argument_list>(<argument><expr><name>PyExc_SyntaxWarning</name></expr></argument>, <argument><expr><name>msg</name></expr></argument>, <argument><expr><name><name>c</name>-&gt;<name>c_filename</name></name></expr></argument>, <argument><expr><call><name>LINENO</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then> <block>{
<if>if <condition>(<expr><call><name>PyErr_Occurred</name><argument_list>()</argument_list></call> &amp;&amp; <call><name>PyErr_ExceptionMatches</name><argument_list>(<argument><expr><name>PyExc_SyntaxWarning</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<expr_stmt><expr><call><name>ast_error</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>msg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<return>return <expr>0</expr>;</return>
}</block></then></if>
<return>return <expr>1</expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>forbidden_check</name><parameter_list>(<param><decl><type>struct <name>compiling</name> *</type><name>c</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>node</name> *</type><name>n</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>x</name></decl></param>)</parameter_list> <block>{
<if>if <condition>(<expr>!<call><name>strcmp</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr>"None"</expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><call><name>ast_error</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr>"assignment to None"</expr></argument>)</argument_list></call></expr>;</return></then></if>
<if>if <condition>(<expr><name>Py_Py3kWarningFlag</name> &amp;&amp; !(<call><name>strcmp</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr>"True"</expr></argument>)</argument_list></call> &amp;&amp; <call><name>strcmp</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr>"False"</expr></argument>)</argument_list></call>) &amp;&amp;
!<call><name>ast_warn</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr>"assignment to True or False is forbidden in 3.x"</expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr>0</expr>;</return></then></if>
<return>return <expr>1</expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>num_stmts</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>node</name> *</type><name>n</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>l</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>node</name> *</type><name>ch</name></decl>;</decl_stmt>
<switch>switch <condition>(<expr><call><name>TYPE</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{
<case>case <expr><name>single_input</name></expr>:
<if>if <condition>(<expr><call><name>TYPE</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> == <name>NEWLINE</name></expr>)</condition><then>
<return>return <expr>0</expr>;</return></then>
<else>else
<return>return <expr><call><name>num_stmts</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></else></if>
</case><case>case <expr><name>file_input</name></expr>:
<expr_stmt><expr><name>l</name> = 0</expr>;</expr_stmt>
<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <call><name>NCH</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
<expr_stmt><expr><name>ch</name> = <call><name>CHILD</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>TYPE</name><argument_list>(<argument><expr><name>ch</name></expr></argument>)</argument_list></call> == <name>stmt</name></expr>)</condition><then>
<expr_stmt><expr><name>l</name> += <call><name>num_stmts</name><argument_list>(<argument><expr><name>ch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
}</block></for>
<return>return <expr><name>l</name></expr>;</return>
</case><case>case <expr><name>stmt</name></expr>:
<return>return <expr><call><name>num_stmts</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</case><case>case <expr><name>compound_stmt</name></expr>:
<return>return <expr>1</expr>;</return>
</case><case>case <expr><name>simple_stmt</name></expr>:
<return>return <expr><call><name>NCH</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call> / 2</expr>;</return>
</case><case>case <expr><name>suite</name></expr>:
<if>if <condition>(<expr><call><name>NCH</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call> == 1</expr>)</condition><then>
<return>return <expr><call><name>num_stmts</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></then>
<else>else <block>{
<expr_stmt><expr><name>l</name> = 0</expr>;</expr_stmt>
<for>for (<init><expr><name>i</name> = 2</expr>;</init> <condition><expr><name>i</name> &lt; (<call><name>NCH</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call> - 1)</expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
<expr_stmt><expr><name>l</name> += <call><name>num_stmts</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></for>
<return>return <expr><name>l</name></expr>;</return>
}</block></else></if>
</case><default>default: <block>{
<decl_stmt><decl><type><name>char</name></type> <name><name>buf</name><index>[<expr>128</expr>]</index></name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr>"Non-statement found: %d %d\n"</expr></argument>,
<argument><expr><call><name>TYPE</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>NCH</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_FatalError</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block>
</default>}</block></switch>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>0</expr>;</return>
}</block></function>
<function><type><name>mod_ty</name></type>
<name>PyAST_FromNode</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>node</name> *</type><name>n</name></decl></param>, <param><decl><type><name>PyCompilerFlags</name> *</type><name>flags</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>filename</name></decl></param>,
<param><decl><type><name>PyArena</name> *</type><name>arena</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>, <decl><type ref="prev"/><name>k</name></decl>, <decl><type ref="prev"/><name>num</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>asdl_seq</name> *</type><name>stmts</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>stmt_ty</name></type> <name>s</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>node</name> *</type><name>ch</name></decl>;</decl_stmt>
<decl_stmt><decl><type>struct <name>compiling</name></type> <name>c</name></decl>;</decl_stmt>
<if>if <condition>(<expr><name>flags</name> &amp;&amp; <name><name>flags</name>-&gt;<name>cf_flags</name></name> &amp; <name>PyCF_SOURCE_IS_UTF8</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>c</name>.<name>c_encoding</name></name> = "utf-8"</expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>TYPE</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call> == <name>encoding_decl</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>ast_error</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr>"encoding declaration in Unicode string"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>error</name>;</goto>
}</block></then></if>
}</block></then> <else>else <if>if <condition>(<expr><call><name>TYPE</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call> == <name>encoding_decl</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>c</name>.<name>c_encoding</name></name> = <call><name>STR</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>n</name> = <call><name>CHILD</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr><name><name>c</name>.<name>c_encoding</name></name> = <name>NULL</name></expr>;</expr_stmt>
}</block></else></if></else></if>
<expr_stmt><expr><name><name>c</name>.<name>c_future_unicode</name></name> = <name>flags</name> &amp;&amp; <name><name>flags</name>-&gt;<name>cf_flags</name></name> &amp; <name>CO_FUTURE_UNICODE_LITERALS</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>c</name>.<name>c_arena</name></name> = <name>arena</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>c</name>.<name>c_filename</name></name> = <name>filename</name></expr>;</expr_stmt>
<expr_stmt><expr><name>k</name> = 0</expr>;</expr_stmt>
<switch>switch <condition>(<expr><call><name>TYPE</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{
<case>case <expr><name>file_input</name></expr>:
<expr_stmt><expr><name>stmts</name> = <call><name>asdl_seq_new</name><argument_list>(<argument><expr><call><name>num_stmts</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>arena</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>stmts</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <call><name>NCH</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call> - 1</expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
<expr_stmt><expr><name>ch</name> = <call><name>CHILD</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>TYPE</name><argument_list>(<argument><expr><name>ch</name></expr></argument>)</argument_list></call> == <name>NEWLINE</name></expr>)</condition><then>
<continue>continue;</continue></then></if>
<expr_stmt><expr><call><name>REQ</name><argument_list>(<argument><expr><name>ch</name></expr></argument>, <argument><expr><name>stmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>num</name> = <call><name>num_stmts</name><argument_list>(<argument><expr><name>ch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>num</name> == 1</expr>)</condition><then> <block>{
<expr_stmt><expr><name>s</name> = <call><name>ast_for_stmt</name><argument_list>(<argument><expr>&amp;<name>c</name></expr></argument>, <argument><expr><name>ch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>s</name></expr>)</condition><then>
<goto>goto <name>error</name>;</goto></then></if>
<expr_stmt><expr><call><name>asdl_seq_SET</name><argument_list>(<argument><expr><name>stmts</name></expr></argument>, <argument><expr><name>k</name>++</expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr><name>ch</name> = <call><name>CHILD</name><argument_list>(<argument><expr><name>ch</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>REQ</name><argument_list>(<argument><expr><name>ch</name></expr></argument>, <argument><expr><name>simple_stmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for (<init><expr><name>j</name> = 0</expr>;</init> <condition><expr><name>j</name> &lt; <name>num</name></expr>;</condition> <incr><expr><name>j</name>++</expr></incr>) <block>{
<expr_stmt><expr><name>s</name> = <call><name>ast_for_stmt</name><argument_list>(<argument><expr>&amp;<name>c</name></expr></argument>, <argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>ch</name></expr></argument>, <argument><expr><name>j</name> * 2</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>s</name></expr>)</condition><then>
<goto>goto <name>error</name>;</goto></then></if>
<expr_stmt><expr><call><name>asdl_seq_SET</name><argument_list>(<argument><expr><name>stmts</name></expr></argument>, <argument><expr><name>k</name>++</expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></for>
}</block></else></if>
}</block></for>
<return>return <expr><call><name>Module</name><argument_list>(<argument><expr><name>stmts</name></expr></argument>, <argument><expr><name>arena</name></expr></argument>)</argument_list></call></expr>;</return>
</case><case>case <expr><name>eval_input</name></expr>: <block>{
<decl_stmt><decl><type><name>expr_ty</name></type> <name>testlist_ast</name></decl>;</decl_stmt>
<expr_stmt><expr><name>testlist_ast</name> = <call><name>ast_for_testlist</name><argument_list>(<argument><expr>&amp;<name>c</name></expr></argument>, <argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>testlist_ast</name></expr>)</condition><then>
<goto>goto <name>error</name>;</goto></then></if>
<return>return <expr><call><name>Expression</name><argument_list>(<argument><expr><name>testlist_ast</name></expr></argument>, <argument><expr><name>arena</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>
</case><case>case <expr><name>single_input</name></expr>:
<if>if <condition>(<expr><call><name>TYPE</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> == <name>NEWLINE</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>stmts</name> = <call><name>asdl_seq_new</name><argument_list>(<argument><expr>1</expr></argument>, <argument><expr><name>arena</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>stmts</name></expr>)</condition><then>
<goto>goto <name>error</name>;</goto></then></if>
<expr_stmt><expr><call><name>asdl_seq_SET</name><argument_list>(<argument><expr><name>stmts</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><call><name>Pass</name><argument_list>(<argument><expr><name><name>n</name>-&gt;<name>n_lineno</name></name></expr></argument>, <argument><expr><name><name>n</name>-&gt;<name>n_col_offset</name></name></expr></argument>,
<argument><expr><name>arena</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<call><name>asdl_seq_GET</name><argument_list>(<argument><expr><name>stmts</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>)</condition><then>
<goto>goto <name>error</name>;</goto></then></if>
<return>return <expr><call><name>Interactive</name><argument_list>(<argument><expr><name>stmts</name></expr></argument>, <argument><expr><name>arena</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></then> <else>else <block>{
<expr_stmt><expr><name>n</name> = <call><name>CHILD</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>num</name> = <call><name>num_stmts</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>stmts</name> = <call><name>asdl_seq_new</name><argument_list>(<argument><expr><name>num</name></expr></argument>, <argument><expr><name>arena</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>stmts</name></expr>)</condition><then>
<goto>goto <name>error</name>;</goto></then></if>
<if>if <condition>(<expr><name>num</name> == 1</expr>)</condition><then> <block>{
<expr_stmt><expr><name>s</name> = <call><name>ast_for_stmt</name><argument_list>(<argument><expr>&amp;<name>c</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>s</name></expr>)</condition><then>
<goto>goto <name>error</name>;</goto></then></if>
<expr_stmt><expr><call><name>asdl_seq_SET</name><argument_list>(<argument><expr><name>stmts</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr><call><name>REQ</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>simple_stmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <call><name>NCH</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name> += 2</expr></incr>) <block>{
<if>if <condition>(<expr><call><name>TYPE</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> == <name>NEWLINE</name></expr>)</condition><then>
<break>break;</break></then></if>
<expr_stmt><expr><name>s</name> = <call><name>ast_for_stmt</name><argument_list>(<argument><expr>&amp;<name>c</name></expr></argument>, <argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>s</name></expr>)</condition><then>
<goto>goto <name>error</name>;</goto></then></if>
<expr_stmt><expr><call><name>asdl_seq_SET</name><argument_list>(<argument><expr><name>stmts</name></expr></argument>, <argument><expr><name>i</name> / 2</expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></for>
}</block></else></if>
<return>return <expr><call><name>Interactive</name><argument_list>(<argument><expr><name>stmts</name></expr></argument>, <argument><expr><name>arena</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></else></if>
</case><default>default:
<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_SystemError</name></expr></argument>,
<argument><expr>"invalid node %d for PyAST_FromNode"</expr></argument>, <argument><expr><call><name>TYPE</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>error</name>;</goto>
</default>}</block></switch>
<label><name>error</name>:</label>
<expr_stmt><expr><call><name>ast_error_finish</name><argument_list>(<argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>operator_ty</name></type>
<name>get_operator</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>node</name> *</type><name>n</name></decl></param>)</parameter_list> <block>{
<switch>switch <condition>(<expr><call><name>TYPE</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{
<case>case <expr><name>VBAR</name></expr>:
<return>return <expr><name>BitOr</name></expr>;</return>
</case><case>case <expr><name>CIRCUMFLEX</name></expr>:
<return>return <expr><name>BitXor</name></expr>;</return>
</case><case>case <expr><name>AMPER</name></expr>:
<return>return <expr><name>BitAnd</name></expr>;</return>
</case><case>case <expr><name>LEFTSHIFT</name></expr>:
<return>return <expr><name>LShift</name></expr>;</return>
</case><case>case <expr><name>RIGHTSHIFT</name></expr>:
<return>return <expr><name>RShift</name></expr>;</return>
</case><case>case <expr><name>PLUS</name></expr>:
<return>return <expr><name>Add</name></expr>;</return>
</case><case>case <expr><name>MINUS</name></expr>:
<return>return <expr><name>Sub</name></expr>;</return>
</case><case>case <expr><name>STAR</name></expr>:
<return>return <expr><name>Mult</name></expr>;</return>
</case><case>case <expr><name>SLASH</name></expr>:
<return>return <expr><name>Div</name></expr>;</return>
</case><case>case <expr><name>DOUBLESLASH</name></expr>:
<return>return <expr><name>FloorDiv</name></expr>;</return>
</case><case>case <expr><name>PERCENT</name></expr>:
<return>return <expr><name>Mod</name></expr>;</return>
</case><default>default:
<return>return <expr>(<name>operator_ty</name>)0</expr>;</return>
</default>}</block></switch>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>set_context</name><parameter_list>(<param><decl><type>struct <name>compiling</name> *</type><name>c</name></decl></param>, <param><decl><type><name>expr_ty</name></type> <name>e</name></decl></param>, <param><decl><type><name>expr_context_ty</name></type> <name>ctx</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>node</name> *</type><name>n</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>asdl_seq</name> *</type><name>s</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name>*</type> <name>expr_name</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>ctx</name> != <name>AugStore</name> &amp;&amp; <name>ctx</name> != <name>AugLoad</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<switch>switch <condition>(<expr><name><name>e</name>-&gt;<name>kind</name></name></expr>)</condition> <block>{
<case>case <expr><name>Attribute_kind</name></expr>:
<if>if <condition>(<expr><name>ctx</name> == <name>Store</name> &amp;&amp; !<call><name>forbidden_check</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>n</name></expr></argument>,
<argument><expr><call><name>PyBytes_AS_STRING</name><argument_list>(<argument><expr><name><name>e</name>-&gt;<name>v</name>.<name>Attribute</name>.<name>attr</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr>0</expr>;</return></then></if>
<expr_stmt><expr><name><name>e</name>-&gt;<name>v</name>.<name>Attribute</name>.<name>ctx</name></name> = <name>ctx</name></expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr><name>Subscript_kind</name></expr>:
<expr_stmt><expr><name><name>e</name>-&gt;<name>v</name>.<name>Subscript</name>.<name>ctx</name></name> = <name>ctx</name></expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr><name>Name_kind</name></expr>:
<if>if <condition>(<expr><name>ctx</name> == <name>Store</name> &amp;&amp; !<call><name>forbidden_check</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>n</name></expr></argument>,
<argument><expr><call><name>PyBytes_AS_STRING</name><argument_list>(<argument><expr><name><name>e</name>-&gt;<name>v</name>.<name>Name</name>.<name>id</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr>0</expr>;</return></then></if>
<expr_stmt><expr><name><name>e</name>-&gt;<name>v</name>.<name>Name</name>.<name>ctx</name></name> = <name>ctx</name></expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr><name>List_kind</name></expr>:
<expr_stmt><expr><name><name>e</name>-&gt;<name>v</name>.<name>List</name>.<name>ctx</name></name> = <name>ctx</name></expr>;</expr_stmt>
<expr_stmt><expr><name>s</name> = <name><name>e</name>-&gt;<name>v</name>.<name>List</name>.<name>elts</name></name></expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr><name>Tuple_kind</name></expr>:
<if>if <condition>(<expr><call><name>asdl_seq_LEN</name><argument_list>(<argument><expr><name><name>e</name>-&gt;<name>v</name>.<name>Tuple</name>.<name>elts</name></name></expr></argument>)</argument_list></call> == 0</expr>)</condition><then>
<return>return <expr><call><name>ast_error</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr>"can't assign to ()"</expr></argument>)</argument_list></call></expr>;</return></then></if>
<expr_stmt><expr><name><name>e</name>-&gt;<name>v</name>.<name>Tuple</name>.<name>ctx</name></name> = <name>ctx</name></expr>;</expr_stmt>
<expr_stmt><expr><name>s</name> = <name><name>e</name>-&gt;<name>v</name>.<name>Tuple</name>.<name>elts</name></name></expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr><name>Lambda_kind</name></expr>:
<expr_stmt><expr><name>expr_name</name> = "lambda"</expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr><name>Call_kind</name></expr>:
<expr_stmt><expr><name>expr_name</name> = "function call"</expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr><name>BoolOp_kind</name></expr>:
</case><case>case <expr><name>BinOp_kind</name></expr>:
</case><case>case <expr><name>UnaryOp_kind</name></expr>:
<expr_stmt><expr><name>expr_name</name> = "operator"</expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr><name>GeneratorExp_kind</name></expr>:
<expr_stmt><expr><name>expr_name</name> = "generator expression"</expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr><name>Yield_kind</name></expr>:
<expr_stmt><expr><name>expr_name</name> = "yield expression"</expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr><name>ListComp_kind</name></expr>:
<expr_stmt><expr><name>expr_name</name> = "list comprehension"</expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr><name>Dict_kind</name></expr>:
</case><case>case <expr><name>Num_kind</name></expr>:
</case><case>case <expr><name>Str_kind</name></expr>:
<expr_stmt><expr><name>expr_name</name> = "literal"</expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr><name>Compare_kind</name></expr>:
<expr_stmt><expr><name>expr_name</name> = "comparison"</expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr><name>Repr_kind</name></expr>:
<expr_stmt><expr><name>expr_name</name> = "repr"</expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr><name>IfExp_kind</name></expr>:
<expr_stmt><expr><name>expr_name</name> = "conditional expression"</expr>;</expr_stmt>
<break>break;</break>
</case><default>default:
<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_SystemError</name></expr></argument>,
<argument><expr>"unexpected expression in assignment %d (line %d)"</expr></argument>,
<argument><expr><name><name>e</name>-&gt;<name>kind</name></name></expr></argument>, <argument><expr><name><name>e</name>-&gt;<name>lineno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>0</expr>;</return>
</default>}</block></switch>
<if>if <condition>(<expr><name>expr_name</name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>char</name></type> <name><name>buf</name><index>[<expr>300</expr>]</index></name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>PyOS_snprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>,
<argument><expr>"can't %s %s"</expr></argument>,
<argument><expr><name>ctx</name> == <name>Store</name> ? "assign to" : "delete"</expr></argument>,
<argument><expr><name>expr_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>ast_error</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></then></if>
<if>if <condition>(<expr><name>s</name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <call><name>asdl_seq_LEN</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
<if>if <condition>(<expr>!<call><name>set_context</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr>(<name>expr_ty</name>)<call><name>asdl_seq_GET</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr>0</expr>;</return></then></if>
}</block></for>
}</block></then></if>
<return>return <expr>1</expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>operator_ty</name></type>
<name>ast_for_augassign</name><parameter_list>(<param><decl><type>struct <name>compiling</name> *</type><name>c</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>node</name> *</type><name>n</name></decl></param>)</parameter_list> <block>{
<expr_stmt><expr><call><name>REQ</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>augassign</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>n</name> = <call><name>CHILD</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<switch>switch <condition>(<expr><call><name>STR</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call><index>[<expr>0</expr>]</index></expr>)</condition> <block>{
<case>case <expr>'+'</expr>:
<return>return <expr><name>Add</name></expr>;</return>
</case><case>case <expr>'-'</expr>:
<return>return <expr><name>Sub</name></expr>;</return>
</case><case>case <expr>'/'</expr>:
<if>if <condition>(<expr><call><name>STR</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call><index>[<expr>1</expr>]</index> == '/'</expr>)</condition><then>
<return>return <expr><name>FloorDiv</name></expr>;</return></then>
<else>else
<return>return <expr><name>Div</name></expr>;</return></else></if>
</case><case>case <expr>'%'</expr>:
<return>return <expr><name>Mod</name></expr>;</return>
</case><case>case <expr>'&lt;'</expr>:
<return>return <expr><name>LShift</name></expr>;</return>
</case><case>case <expr>'&gt;'</expr>:
<return>return <expr><name>RShift</name></expr>;</return>
</case><case>case <expr>'&amp;'</expr>:
<return>return <expr><name>BitAnd</name></expr>;</return>
</case><case>case <expr>'^'</expr>:
<return>return <expr><name>BitXor</name></expr>;</return>
</case><case>case <expr>'|'</expr>:
<return>return <expr><name>BitOr</name></expr>;</return>
</case><case>case <expr>'*'</expr>:
<if>if <condition>(<expr><call><name>STR</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call><index>[<expr>1</expr>]</index> == '*'</expr>)</condition><then>
<return>return <expr><name>Pow</name></expr>;</return></then>
<else>else
<return>return <expr><name>Mult</name></expr>;</return></else></if>
</case><default>default:
<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_SystemError</name></expr></argument>, <argument><expr>"invalid augassign: %s"</expr></argument>, <argument><expr><call><name>STR</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>(<name>operator_ty</name>)0</expr>;</return>
</default>}</block></switch>
}</block></function>
<function><type><specifier>static</specifier> <name>cmpop_ty</name></type>
<name>ast_for_comp_op</name><parameter_list>(<param><decl><type>struct <name>compiling</name> *</type><name>c</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>node</name> *</type><name>n</name></decl></param>)</parameter_list> <block>{
<expr_stmt><expr><call><name>REQ</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>comp_op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>NCH</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call> == 1</expr>)</condition><then> <block>{
<expr_stmt><expr><name>n</name> = <call><name>CHILD</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<switch>switch <condition>(<expr><call><name>TYPE</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{
<case>case <expr><name>LESS</name></expr>:
<return>return <expr><name>Lt</name></expr>;</return>
</case><case>case <expr><name>GREATER</name></expr>:
<return>return <expr><name>Gt</name></expr>;</return>
</case><case>case <expr><name>EQEQUAL</name></expr>:
<return>return <expr><name>Eq</name></expr>;</return>
</case><case>case <expr><name>LESSEQUAL</name></expr>:
<return>return <expr><name>LtE</name></expr>;</return>
</case><case>case <expr><name>GREATEREQUAL</name></expr>:
<return>return <expr><name>GtE</name></expr>;</return>
</case><case>case <expr><name>NOTEQUAL</name></expr>:
<return>return <expr><name>NotEq</name></expr>;</return>
</case><case>case <expr><name>NAME</name></expr>:
<if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><call><name>STR</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>"in"</expr></argument>)</argument_list></call> == 0</expr>)</condition><then>
<return>return <expr><name>In</name></expr>;</return></then></if>
<if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><call><name>STR</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>"is"</expr></argument>)</argument_list></call> == 0</expr>)</condition><then>
<return>return <expr><name>Is</name></expr>;</return></then></if>
</case><default>default:
<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_SystemError</name></expr></argument>, <argument><expr>"invalid comp_op: %s"</expr></argument>,
<argument><expr><call><name>STR</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>(<name>cmpop_ty</name>)0</expr>;</return>
</default>}</block></switch>
}</block></then> <else>else <if>if <condition>(<expr><call><name>NCH</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call> == 2</expr>)</condition><then> <block>{
<switch>switch <condition>(<expr><call><name>TYPE</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{
<case>case <expr><name>NAME</name></expr>:
<if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><call><name>STR</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>"in"</expr></argument>)</argument_list></call> == 0</expr>)</condition><then>
<return>return <expr><name>NotIn</name></expr>;</return></then></if>
<if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><call><name>STR</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>"is"</expr></argument>)</argument_list></call> == 0</expr>)</condition><then>
<return>return <expr><name>IsNot</name></expr>;</return></then></if>
</case><default>default:
<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_SystemError</name></expr></argument>, <argument><expr>"invalid comp_op: %s %s"</expr></argument>,
<argument><expr><call><name>STR</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>STR</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>(<name>cmpop_ty</name>)0</expr>;</return>
</default>}</block></switch>
}</block></then></if></else></if>
<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_SystemError</name></expr></argument>, <argument><expr>"invalid comp_op: has %d children"</expr></argument>,
<argument><expr><call><name>NCH</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>(<name>cmpop_ty</name>)0</expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>asdl_seq</name> *</type>
<name>seq_for_testlist</name><parameter_list>(<param><decl><type>struct <name>compiling</name> *</type><name>c</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>node</name> *</type><name>n</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>asdl_seq</name> *</type><name>seq</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>expr_ty</name></type> <name>expression</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>TYPE</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call> == <name>testlist</name> ||
<call><name>TYPE</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call> == <name>listmaker</name> ||
<call><name>TYPE</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call> == <name>testlist_gexp</name> ||
<call><name>TYPE</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call> == <name>testlist_safe</name> ||
<call><name>TYPE</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call> == <name>testlist1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>seq</name> = <call><name>asdl_seq_new</name><argument_list>(<argument><expr>(<call><name>NCH</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call> + 1) / 2</expr></argument>, <argument><expr><name><name>c</name>-&gt;<name>c_arena</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>seq</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <call><name>NCH</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name> += 2</expr></incr>) <block>{
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>TYPE</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> == <name>test</name> || <call><name>TYPE</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> == <name>old_test</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>expression</name> = <call><name>ast_for_expr</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>expression</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>i</name> / 2 &lt; <name><name>seq</name>-&gt;<name>size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>asdl_seq_SET</name><argument_list>(<argument><expr><name>seq</name></expr></argument>, <argument><expr><name>i</name> / 2</expr></argument>, <argument><expr><name>expression</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></for>
<return>return <expr><name>seq</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>expr_ty</name></type>
<name>compiler_complex_args</name><parameter_list>(<param><decl><type>struct <name>compiling</name> *</type><name>c</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>node</name> *</type><name>n</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>len</name> <init>= <expr>(<call><name>NCH</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call> + 1) / 2</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>expr_ty</name></type> <name>result</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>asdl_seq</name> *</type><name>args</name> <init>= <expr><call><name>asdl_seq_new</name><argument_list>(<argument><expr><name>len</name></expr></argument>, <argument><expr><name><name>c</name>-&gt;<name>c_arena</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr>!<name>args</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><call><name>REQ</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>fplist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>len</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>arg_id</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>node</name> *</type><name>fpdef_node</name> <init>= <expr><call><name>CHILD</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr>2*<name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>node</name> *</type><name>child</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>expr_ty</name></type> <name>arg</name></decl>;</decl_stmt>
<label><name>set_name</name>:</label>
<expr_stmt><expr><name>child</name> = <call><name>CHILD</name><argument_list>(<argument><expr><name>fpdef_node</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>TYPE</name><argument_list>(<argument><expr><name>child</name></expr></argument>)</argument_list></call> == <name>NAME</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr>!<call><name>forbidden_check</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><call><name>STR</name><argument_list>(<argument><expr><name>child</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>arg_id</name> = <call><name>NEW_IDENTIFIER</name><argument_list>(<argument><expr><name>child</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>arg_id</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>arg</name> = <call><name>Name</name><argument_list>(<argument><expr><name>arg_id</name></expr></argument>, <argument><expr><name>Store</name></expr></argument>, <argument><expr><call><name>LINENO</name><argument_list>(<argument><expr><name>child</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>child</name>-&gt;<name>n_col_offset</name></name></expr></argument>,
<argument><expr><name><name>c</name>-&gt;<name>c_arena</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>TYPE</name><argument_list>(<argument><expr><name>fpdef_node</name></expr></argument>)</argument_list></call> == <name>fpdef</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>child</name> = <call><name>CHILD</name><argument_list>(<argument><expr><name>fpdef_node</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>TYPE</name><argument_list>(<argument><expr><name>child</name></expr></argument>)</argument_list></call> == <name>fplist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>NCH</name><argument_list>(<argument><expr><name>child</name></expr></argument>)</argument_list></call> == 1</expr>)</condition><then> <block>{
<expr_stmt><expr><name>fpdef_node</name> = <call><name>CHILD</name><argument_list>(<argument><expr><name>child</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>TYPE</name><argument_list>(<argument><expr><name>fpdef_node</name></expr></argument>)</argument_list></call> == <name>fpdef</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>set_name</name>;</goto>
}</block></then></if>
<expr_stmt><expr><name>arg</name> = <call><name>compiler_complex_args</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>child</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></else></if>
<expr_stmt><expr><call><name>asdl_seq_SET</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></for>
<expr_stmt><expr><name>result</name> = <call><name>Tuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>Store</name></expr></argument>, <argument><expr><call><name>LINENO</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>n</name>-&gt;<name>n_col_offset</name></name></expr></argument>, <argument><expr><name><name>c</name>-&gt;<name>c_arena</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<call><name>set_context</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>result</name></expr></argument>, <argument><expr><name>Store</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<return>return <expr><name>result</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>arguments_ty</name></type>
<name>ast_for_arguments</name><parameter_list>(<param><decl><type>struct <name>compiling</name> *</type><name>c</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>node</name> *</type><name>n</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>, <decl><type ref="prev"/><name>k</name></decl>, <decl><type ref="prev"/><name>n_args</name> <init>= <expr>0</expr></init>, <name>n_defaults</name> <init>= <expr>0</expr></init>, <name>found_default</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>asdl_seq</name> *</type><name>args</name></decl>, *<decl><type ref="prev"/><name>defaults</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>identifier</name></type> <name>vararg</name> <init>= <expr><name>NULL</name></expr></init>, <name>kwarg</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>node</name> *</type><name>ch</name></decl>;</decl_stmt>
<if>if <condition>(<expr><call><name>TYPE</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call> == <name>parameters</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr><call><name>NCH</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call> == 2</expr>)</condition><then>
<return>return <expr><call><name>arguments</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name><name>c</name>-&gt;<name>c_arena</name></name></expr></argument>)</argument_list></call></expr>;</return></then></if>
<expr_stmt><expr><name>n</name> = <call><name>CHILD</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><call><name>REQ</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>varargslist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <call><name>NCH</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
<expr_stmt><expr><name>ch</name> = <call><name>CHILD</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>TYPE</name><argument_list>(<argument><expr><name>ch</name></expr></argument>)</argument_list></call> == <name>fpdef</name></expr>)</condition><then>
<expr_stmt><expr><name>n_args</name>++</expr>;</expr_stmt></then></if>
<if>if <condition>(<expr><call><name>TYPE</name><argument_list>(<argument><expr><name>ch</name></expr></argument>)</argument_list></call> == <name>EQUAL</name></expr>)</condition><then>
<expr_stmt><expr><name>n_defaults</name>++</expr>;</expr_stmt></then></if>
}</block></for>
<expr_stmt><expr><name>args</name> = (<name>n_args</name> ? <call><name>asdl_seq_new</name><argument_list>(<argument><expr><name>n_args</name></expr></argument>, <argument><expr><name><name>c</name>-&gt;<name>c_arena</name></name></expr></argument>)</argument_list></call> : <name>NULL</name>)</expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>args</name> &amp;&amp; <name>n_args</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>defaults</name> = (<name>n_defaults</name> ? <call><name>asdl_seq_new</name><argument_list>(<argument><expr><name>n_defaults</name></expr></argument>, <argument><expr><name><name>c</name>-&gt;<name>c_arena</name></name></expr></argument>)</argument_list></call> : <name>NULL</name>)</expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>defaults</name> &amp;&amp; <name>n_defaults</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>i</name> = 0</expr>;</expr_stmt>
<expr_stmt><expr><name>j</name> = 0</expr>;</expr_stmt>
<expr_stmt><expr><name>k</name> = 0</expr>;</expr_stmt>
<while>while <condition>(<expr><name>i</name> &lt; <call><name>NCH</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{
<expr_stmt><expr><name>ch</name> = <call><name>CHILD</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<switch>switch <condition>(<expr><call><name>TYPE</name><argument_list>(<argument><expr><name>ch</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{
<case>case <expr><name>fpdef</name></expr>:
<label><name>handle_fpdef</name>:</label>
<if>if <condition>(<expr><name>i</name> + 1 &lt; <call><name>NCH</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call> &amp;&amp; <call><name>TYPE</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>i</name> + 1</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> == <name>EQUAL</name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>expr_ty</name></type> <name>expression</name> <init>= <expr><call><name>ast_for_expr</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>i</name> + 2</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr>!<name>expression</name></expr>)</condition><then>
<goto>goto <name>error</name>;</goto></then></if>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>defaults</name> != <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>asdl_seq_SET</name><argument_list>(<argument><expr><name>defaults</name></expr></argument>, <argument><expr><name>j</name>++</expr></argument>, <argument><expr><name>expression</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>i</name> += 2</expr>;</expr_stmt>
<expr_stmt><expr><name>found_default</name> = 1</expr>;</expr_stmt>
}</block></then> <else>else <if>if <condition>(<expr><name>found_default</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>ast_error</name><argument_list>(<argument><expr><name>n</name></expr></argument>,
<argument><expr>"non-default argument follows default argument"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>error</name>;</goto>
}</block></then></if></else></if>
<if>if <condition>(<expr><call><name>NCH</name><argument_list>(<argument><expr><name>ch</name></expr></argument>)</argument_list></call> == 3</expr>)</condition><then> <block>{
<expr_stmt><expr><name>ch</name> = <call><name>CHILD</name><argument_list>(<argument><expr><name>ch</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>NCH</name><argument_list>(<argument><expr><name>ch</name></expr></argument>)</argument_list></call> != 1</expr>)</condition><then> <block>{
<if>if <condition>(<expr><name>Py_Py3kWarningFlag</name> &amp;&amp; !<call><name>ast_warn</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>ch</name></expr></argument>,
<argument><expr>"tuple parameter unpacking has been removed in 3.x"</expr></argument>)</argument_list></call></expr>)</condition><then>
<goto>goto <name>error</name>;</goto></then></if>
<expr_stmt><expr><call><name>asdl_seq_SET</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>k</name>++</expr></argument>, <argument><expr><call><name>compiler_complex_args</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>ch</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<call><name>asdl_seq_GET</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>k</name>-1</expr></argument>)</argument_list></call></expr>)</condition><then>
<goto>goto <name>error</name>;</goto></then></if>
}</block></then> <else>else <block>{
<expr_stmt><expr><name>ch</name> = <call><name>CHILD</name><argument_list>(<argument><expr><name>ch</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>TYPE</name><argument_list>(<argument><expr><name>ch</name></expr></argument>)</argument_list></call> == <name>fpdef</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>handle_fpdef</name>;</goto>
}</block></else></if>
}</block></then></if>
<if>if <condition>(<expr><call><name>TYPE</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>ch</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> == <name>NAME</name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>id</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>expr_ty</name></type> <name>name</name></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>forbidden_check</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><call><name>STR</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>ch</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then>
<goto>goto <name>error</name>;</goto></then></if>
<expr_stmt><expr><name>id</name> = <call><name>NEW_IDENTIFIER</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>ch</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>id</name></expr>)</condition><then>
<goto>goto <name>error</name>;</goto></then></if>
<expr_stmt><expr><name>name</name> = <call><name>Name</name><argument_list>(<argument><expr><name>id</name></expr></argument>, <argument><expr><name>Param</name></expr></argument>, <argument><expr><call><name>LINENO</name><argument_list>(<argument><expr><name>ch</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>ch</name>-&gt;<name>n_col_offset</name></name></expr></argument>,
<argument><expr><name><name>c</name>-&gt;<name>c_arena</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>name</name></expr>)</condition><then>
<goto>goto <name>error</name>;</goto></then></if>
<expr_stmt><expr><call><name>asdl_seq_SET</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>k</name>++</expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><name>i</name> += 2</expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr><name>STAR</name></expr>:
<if>if <condition>(<expr>!<call><name>forbidden_check</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>i</name>+1</expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>STR</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>i</name>+1</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then>
<goto>goto <name>error</name>;</goto></then></if>
<expr_stmt><expr><name>vararg</name> = <call><name>NEW_IDENTIFIER</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>i</name>+1</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>vararg</name></expr>)</condition><then>
<goto>goto <name>error</name>;</goto></then></if>
<expr_stmt><expr><name>i</name> += 3</expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr><name>DOUBLESTAR</name></expr>:
<if>if <condition>(<expr>!<call><name>forbidden_check</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>i</name>+1</expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>STR</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>i</name>+1</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then>
<goto>goto <name>error</name>;</goto></then></if>
<expr_stmt><expr><name>kwarg</name> = <call><name>NEW_IDENTIFIER</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>i</name>+1</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>kwarg</name></expr>)</condition><then>
<goto>goto <name>error</name>;</goto></then></if>
<expr_stmt><expr><name>i</name> += 3</expr>;</expr_stmt>
<break>break;</break>
</case><default>default:
<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_SystemError</name></expr></argument>,
<argument><expr>"unexpected node in varargslist: %d @ %d"</expr></argument>,
<argument><expr><call><name>TYPE</name><argument_list>(<argument><expr><name>ch</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>error</name>;</goto>
</default>}</block></switch>
}</block></while>
<return>return <expr><call><name>arguments</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>vararg</name></expr></argument>, <argument><expr><name>kwarg</name></expr></argument>, <argument><expr><name>defaults</name></expr></argument>, <argument><expr><name><name>c</name>-&gt;<name>c_arena</name></name></expr></argument>)</argument_list></call></expr>;</return>
<label><name>error</name>:</label>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>vararg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>kwarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>expr_ty</name></type>
<name>ast_for_dotted_name</name><parameter_list>(<param><decl><type>struct <name>compiling</name> *</type><name>c</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>node</name> *</type><name>n</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>expr_ty</name></type> <name>e</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>identifier</name></type> <name>id</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>lineno</name></decl>, <decl><type ref="prev"/><name>col_offset</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>REQ</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>dotted_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>lineno</name> = <call><name>LINENO</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>col_offset</name> = <name><name>n</name>-&gt;<name>n_col_offset</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>id</name> = <call><name>NEW_IDENTIFIER</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>id</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>e</name> = <call><name>Name</name><argument_list>(<argument><expr><name>id</name></expr></argument>, <argument><expr><name>Load</name></expr></argument>, <argument><expr><name>lineno</name></expr></argument>, <argument><expr><name>col_offset</name></expr></argument>, <argument><expr><name><name>c</name>-&gt;<name>c_arena</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>e</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<for>for (<init><expr><name>i</name> = 2</expr>;</init> <condition><expr><name>i</name> &lt; <call><name>NCH</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name>+=2</expr></incr>) <block>{
<expr_stmt><expr><name>id</name> = <call><name>NEW_IDENTIFIER</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>id</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>e</name> = <call><name>Attribute</name><argument_list>(<argument><expr><name>e</name></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><name>Load</name></expr></argument>, <argument><expr><name>lineno</name></expr></argument>, <argument><expr><name>col_offset</name></expr></argument>, <argument><expr><name><name>c</name>-&gt;<name>c_arena</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>e</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
}</block></for>
<return>return <expr><name>e</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>expr_ty</name></type>
<name>ast_for_decorator</name><parameter_list>(<param><decl><type>struct <name>compiling</name> *</type><name>c</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>node</name> *</type><name>n</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>expr_ty</name></type> <name>d</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>expr_ty</name></type> <name>name_expr</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>REQ</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>decorator</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>REQ</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>AT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>REQ</name><argument_list>(<argument><expr><call><name>RCHILD</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr>-1</expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>NEWLINE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>name_expr</name> = <call><name>ast_for_dotted_name</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>name_expr</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<if>if <condition>(<expr><call><name>NCH</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call> == 3</expr>)</condition><then> <block>{
<expr_stmt><expr><name>d</name> = <name>name_expr</name></expr>;</expr_stmt>
<expr_stmt><expr><name>name_expr</name> = <name>NULL</name></expr>;</expr_stmt>
}</block></then> <else>else <if>if <condition>(<expr><call><name>NCH</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call> == 5</expr>)</condition><then> <block>{
<expr_stmt><expr><name>d</name> = <call><name>Call</name><argument_list>(<argument><expr><name>name_expr</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><call><name>LINENO</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name><name>n</name>-&gt;<name>n_col_offset</name></name></expr></argument>, <argument><expr><name><name>c</name>-&gt;<name>c_arena</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>d</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>name_expr</name> = <name>NULL</name></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr><name>d</name> = <call><name>ast_for_call</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr>3</expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>name_expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>d</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>name_expr</name> = <name>NULL</name></expr>;</expr_stmt>
}</block></else></if></else></if>
<return>return <expr><name>d</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>asdl_seq</name>*</type>
<name>ast_for_decorators</name><parameter_list>(<param><decl><type>struct <name>compiling</name> *</type><name>c</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>node</name> *</type><name>n</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>asdl_seq</name>*</type> <name>decorator_seq</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>expr_ty</name></type> <name>d</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>REQ</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>decorators</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>decorator_seq</name> = <call><name>asdl_seq_new</name><argument_list>(<argument><expr><call><name>NCH</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>c</name>-&gt;<name>c_arena</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>decorator_seq</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <call><name>NCH</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
<expr_stmt><expr><name>d</name> = <call><name>ast_for_decorator</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>d</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><call><name>asdl_seq_SET</name><argument_list>(<argument><expr><name>decorator_seq</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></for>
<return>return <expr><name>decorator_seq</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>stmt_ty</name></type>
<name>ast_for_funcdef</name><parameter_list>(<param><decl><type>struct <name>compiling</name> *</type><name>c</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>node</name> *</type><name>n</name></decl></param>, <param><decl><type><name>asdl_seq</name> *</type><name>decorator_seq</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>identifier</name></type> <name>name</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>arguments_ty</name></type> <name>args</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>asdl_seq</name> *</type><name>body</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>name_i</name> <init>= <expr>1</expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>REQ</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>funcdef</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>name</name> = <call><name>NEW_IDENTIFIER</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>name_i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>name</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then>
<else>else <if>if <condition>(<expr>!<call><name>forbidden_check</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>name_i</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>STR</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>name_i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if></else></if>
<expr_stmt><expr><name>args</name> = <call><name>ast_for_arguments</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>name_i</name> + 1</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>args</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>body</name> = <call><name>ast_for_suite</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>name_i</name> + 3</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>body</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<return>return <expr><call><name>FunctionDef</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>args</name></expr></argument>, <argument><expr><name>body</name></expr></argument>, <argument><expr><name>decorator_seq</name></expr></argument>, <argument><expr><call><name>LINENO</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name><name>n</name>-&gt;<name>n_col_offset</name></name></expr></argument>, <argument><expr><name><name>c</name>-&gt;<name>c_arena</name></name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>stmt_ty</name></type>
<name>ast_for_decorated</name><parameter_list>(<param><decl><type>struct <name>compiling</name> *</type><name>c</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>node</name> *</type><name>n</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>stmt_ty</name></type> <name>thing</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>asdl_seq</name> *</type><name>decorator_seq</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>REQ</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>decorated</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>decorator_seq</name> = <call><name>ast_for_decorators</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>decorator_seq</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>TYPE</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> == <name>funcdef</name> ||
<call><name>TYPE</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> == <name>classdef</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>TYPE</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> == <name>funcdef</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>thing</name> = <call><name>ast_for_funcdef</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>decorator_seq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else <if>if <condition>(<expr><call><name>TYPE</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> == <name>classdef</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>thing</name> = <call><name>ast_for_classdef</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>decorator_seq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if></else></if>
<if>if <condition>(<expr><name>thing</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>thing</name>-&gt;<name>lineno</name></name> = <call><name>LINENO</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>thing</name>-&gt;<name>col_offset</name></name> = <name><name>n</name>-&gt;<name>n_col_offset</name></name></expr>;</expr_stmt>
}</block></then></if>
<return>return <expr><name>thing</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>expr_ty</name></type>
<name>ast_for_lambdef</name><parameter_list>(<param><decl><type>struct <name>compiling</name> *</type><name>c</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>node</name> *</type><name>n</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>arguments_ty</name></type> <name>args</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>expr_ty</name></type> <name>expression</name></decl>;</decl_stmt>
<if>if <condition>(<expr><call><name>NCH</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call> == 3</expr>)</condition><then> <block>{
<expr_stmt><expr><name>args</name> = <call><name>arguments</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name><name>c</name>-&gt;<name>c_arena</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>args</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>expression</name> = <call><name>ast_for_expr</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr>2</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>expression</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
}</block></then> <else>else <block>{
<expr_stmt><expr><name>args</name> = <call><name>ast_for_arguments</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>args</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>expression</name> = <call><name>ast_for_expr</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr>3</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>expression</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
}</block></else></if>
<return>return <expr><call><name>Lambda</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>expression</name></expr></argument>, <argument><expr><call><name>LINENO</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>n</name>-&gt;<name>n_col_offset</name></name></expr></argument>, <argument><expr><name><name>c</name>-&gt;<name>c_arena</name></name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>expr_ty</name></type>
<name>ast_for_ifexpr</name><parameter_list>(<param><decl><type>struct <name>compiling</name> *</type><name>c</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>node</name> *</type><name>n</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>expr_ty</name></type> <name>expression</name></decl>, <decl><type ref="prev"/><name>body</name></decl>, <decl><type ref="prev"/><name>orelse</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>NCH</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call> == 5</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>body</name> = <call><name>ast_for_expr</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>body</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>expression</name> = <call><name>ast_for_expr</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr>2</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>expression</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>orelse</name> = <call><name>ast_for_expr</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr>4</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>orelse</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<return>return <expr><call><name>IfExp</name><argument_list>(<argument><expr><name>expression</name></expr></argument>, <argument><expr><name>body</name></expr></argument>, <argument><expr><name>orelse</name></expr></argument>, <argument><expr><call><name>LINENO</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>n</name>-&gt;<name>n_col_offset</name></name></expr></argument>,
<argument><expr><name><name>c</name>-&gt;<name>c_arena</name></name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>count_list_fors</name><parameter_list>(<param><decl><type>struct <name>compiling</name> *</type><name>c</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>node</name> *</type><name>n</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>n_fors</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>node</name> *</type><name>ch</name> <init>= <expr><call><name>CHILD</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<label><name>count_list_for</name>:</label>
<expr_stmt><expr><name>n_fors</name>++</expr>;</expr_stmt>
<expr_stmt><expr><call><name>REQ</name><argument_list>(<argument><expr><name>ch</name></expr></argument>, <argument><expr><name>list_for</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>NCH</name><argument_list>(<argument><expr><name>ch</name></expr></argument>)</argument_list></call> == 5</expr>)</condition><then>
<expr_stmt><expr><name>ch</name> = <call><name>CHILD</name><argument_list>(<argument><expr><name>ch</name></expr></argument>, <argument><expr>4</expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
<else>else
<return>return <expr><name>n_fors</name></expr>;</return></else></if>
<label><name>count_list_iter</name>:</label>
<expr_stmt><expr><call><name>REQ</name><argument_list>(<argument><expr><name>ch</name></expr></argument>, <argument><expr><name>list_iter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ch</name> = <call><name>CHILD</name><argument_list>(<argument><expr><name>ch</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>TYPE</name><argument_list>(<argument><expr><name>ch</name></expr></argument>)</argument_list></call> == <name>list_for</name></expr>)</condition><then>
<goto>goto <name>count_list_for</name>;</goto></then>
<else>else <if>if <condition>(<expr><call><name>TYPE</name><argument_list>(<argument><expr><name>ch</name></expr></argument>)</argument_list></call> == <name>list_if</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr><call><name>NCH</name><argument_list>(<argument><expr><name>ch</name></expr></argument>)</argument_list></call> == 3</expr>)</condition><then> <block>{
<expr_stmt><expr><name>ch</name> = <call><name>CHILD</name><argument_list>(<argument><expr><name>ch</name></expr></argument>, <argument><expr>2</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>count_list_iter</name>;</goto>
}</block></then> <else>else
<return>return <expr><name>n_fors</name></expr>;</return></else></if>
}</block></then></if></else></if>
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_SystemError</name></expr></argument>, <argument><expr>"logic error in count_list_fors"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>-1</expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>count_list_ifs</name><parameter_list>(<param><decl><type>struct <name>compiling</name> *</type><name>c</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>node</name> *</type><name>n</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>n_ifs</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<label><name>count_list_iter</name>:</label>
<expr_stmt><expr><call><name>REQ</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>list_iter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>TYPE</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> == <name>list_for</name></expr>)</condition><then>
<return>return <expr><name>n_ifs</name></expr>;</return></then></if>
<expr_stmt><expr><name>n</name> = <call><name>CHILD</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>REQ</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>list_if</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>n_ifs</name>++</expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>NCH</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call> == 2</expr>)</condition><then>
<return>return <expr><name>n_ifs</name></expr>;</return></then></if>
<expr_stmt><expr><name>n</name> = <call><name>CHILD</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr>2</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>count_list_iter</name>;</goto>
}</block></function>
<function><type><specifier>static</specifier> <name>expr_ty</name></type>
<name>ast_for_listcomp</name><parameter_list>(<param><decl><type>struct <name>compiling</name> *</type><name>c</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>node</name> *</type><name>n</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>expr_ty</name></type> <name>elt</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>asdl_seq</name> *</type><name>listcomps</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>n_fors</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>node</name> *</type><name>ch</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>REQ</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>listmaker</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>NCH</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call> &gt; 1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>elt</name> = <call><name>ast_for_expr</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>elt</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>n_fors</name> = <call><name>count_list_fors</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>n_fors</name> == -1</expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>listcomps</name> = <call><name>asdl_seq_new</name><argument_list>(<argument><expr><name>n_fors</name></expr></argument>, <argument><expr><name><name>c</name>-&gt;<name>c_arena</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>listcomps</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>ch</name> = <call><name>CHILD</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>n_fors</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
<decl_stmt><decl><type><name>comprehension_ty</name></type> <name>lc</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>asdl_seq</name> *</type><name>t</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>expr_ty</name></type> <name>expression</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>node</name> *</type><name>for_ch</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>REQ</name><argument_list>(<argument><expr><name>ch</name></expr></argument>, <argument><expr><name>list_for</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>for_ch</name> = <call><name>CHILD</name><argument_list>(<argument><expr><name>ch</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>t</name> = <call><name>ast_for_exprlist</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>for_ch</name></expr></argument>, <argument><expr><name>Store</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>t</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>expression</name> = <call><name>ast_for_testlist</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>ch</name></expr></argument>, <argument><expr>3</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>expression</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<if>if <condition>(<expr><call><name>NCH</name><argument_list>(<argument><expr><name>for_ch</name></expr></argument>)</argument_list></call> == 1</expr>)</condition><then>
<expr_stmt><expr><name>lc</name> = <call><name>comprehension</name><argument_list>(<argument><expr>(<name>expr_ty</name>)<call><name>asdl_seq_GET</name><argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>expression</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
<argument><expr><name><name>c</name>-&gt;<name>c_arena</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
<else>else
<expr_stmt><expr><name>lc</name> = <call><name>comprehension</name><argument_list>(<argument><expr><call><name>Tuple</name><argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><name>Store</name></expr></argument>, <argument><expr><call><name>LINENO</name><argument_list>(<argument><expr><name>ch</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>ch</name>-&gt;<name>n_col_offset</name></name></expr></argument>,
<argument><expr><name><name>c</name>-&gt;<name>c_arena</name></name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>expression</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name><name>c</name>-&gt;<name>c_arena</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
<if>if <condition>(<expr>!<name>lc</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<if>if <condition>(<expr><call><name>NCH</name><argument_list>(<argument><expr><name>ch</name></expr></argument>)</argument_list></call> == 5</expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>, <decl><type ref="prev"/><name>n_ifs</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>asdl_seq</name> *</type><name>ifs</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>expr_ty</name></type> <name>list_for_expr</name></decl>;</decl_stmt>
<expr_stmt><expr><name>ch</name> = <call><name>CHILD</name><argument_list>(<argument><expr><name>ch</name></expr></argument>, <argument><expr>4</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>n_ifs</name> = <call><name>count_list_ifs</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>ch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>n_ifs</name> == -1</expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>ifs</name> = <call><name>asdl_seq_new</name><argument_list>(<argument><expr><name>n_ifs</name></expr></argument>, <argument><expr><name><name>c</name>-&gt;<name>c_arena</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>ifs</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<for>for (<init><expr><name>j</name> = 0</expr>;</init> <condition><expr><name>j</name> &lt; <name>n_ifs</name></expr>;</condition> <incr><expr><name>j</name>++</expr></incr>) <block>{
<expr_stmt><expr><call><name>REQ</name><argument_list>(<argument><expr><name>ch</name></expr></argument>, <argument><expr><name>list_iter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ch</name> = <call><name>CHILD</name><argument_list>(<argument><expr><name>ch</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>REQ</name><argument_list>(<argument><expr><name>ch</name></expr></argument>, <argument><expr><name>list_if</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>list_for_expr</name> = <call><name>ast_for_expr</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>ch</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>list_for_expr</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><call><name>asdl_seq_SET</name><argument_list>(<argument><expr><name>ifs</name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><name>list_for_expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>NCH</name><argument_list>(<argument><expr><name>ch</name></expr></argument>)</argument_list></call> == 3</expr>)</condition><then>
<expr_stmt><expr><name>ch</name> = <call><name>CHILD</name><argument_list>(<argument><expr><name>ch</name></expr></argument>, <argument><expr>2</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
}</block></for>
<if>if <condition>(<expr><call><name>TYPE</name><argument_list>(<argument><expr><name>ch</name></expr></argument>)</argument_list></call> == <name>list_iter</name></expr>)</condition><then>
<expr_stmt><expr><name>ch</name> = <call><name>CHILD</name><argument_list>(<argument><expr><name>ch</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<expr_stmt><expr><name><name>lc</name>-&gt;<name>ifs</name></name> = <name>ifs</name></expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><call><name>asdl_seq_SET</name><argument_list>(<argument><expr><name>listcomps</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></for>
<return>return <expr><call><name>ListComp</name><argument_list>(<argument><expr><name>elt</name></expr></argument>, <argument><expr><name>listcomps</name></expr></argument>, <argument><expr><call><name>LINENO</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>n</name>-&gt;<name>n_col_offset</name></name></expr></argument>, <argument><expr><name><name>c</name>-&gt;<name>c_arena</name></name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>count_gen_fors</name><parameter_list>(<param><decl><type>struct <name>compiling</name> *</type><name>c</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>node</name> *</type><name>n</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>n_fors</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>node</name> *</type><name>ch</name> <init>= <expr><call><name>CHILD</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<label><name>count_gen_for</name>:</label>
<expr_stmt><expr><name>n_fors</name>++</expr>;</expr_stmt>
<expr_stmt><expr><call><name>REQ</name><argument_list>(<argument><expr><name>ch</name></expr></argument>, <argument><expr><name>gen_for</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>NCH</name><argument_list>(<argument><expr><name>ch</name></expr></argument>)</argument_list></call> == 5</expr>)</condition><then>
<expr_stmt><expr><name>ch</name> = <call><name>CHILD</name><argument_list>(<argument><expr><name>ch</name></expr></argument>, <argument><expr>4</expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
<else>else
<return>return <expr><name>n_fors</name></expr>;</return></else></if>
<label><name>count_gen_iter</name>:</label>
<expr_stmt><expr><call><name>REQ</name><argument_list>(<argument><expr><name>ch</name></expr></argument>, <argument><expr><name>gen_iter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ch</name> = <call><name>CHILD</name><argument_list>(<argument><expr><name>ch</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>TYPE</name><argument_list>(<argument><expr><name>ch</name></expr></argument>)</argument_list></call> == <name>gen_for</name></expr>)</condition><then>
<goto>goto <name>count_gen_for</name>;</goto></then>
<else>else <if>if <condition>(<expr><call><name>TYPE</name><argument_list>(<argument><expr><name>ch</name></expr></argument>)</argument_list></call> == <name>gen_if</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr><call><name>NCH</name><argument_list>(<argument><expr><name>ch</name></expr></argument>)</argument_list></call> == 3</expr>)</condition><then> <block>{
<expr_stmt><expr><name>ch</name> = <call><name>CHILD</name><argument_list>(<argument><expr><name>ch</name></expr></argument>, <argument><expr>2</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>count_gen_iter</name>;</goto>
}</block></then> <else>else
<return>return <expr><name>n_fors</name></expr>;</return></else></if>
}</block></then></if></else></if>
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_SystemError</name></expr></argument>,
<argument><expr>"logic error in count_gen_fors"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>-1</expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>count_gen_ifs</name><parameter_list>(<param><decl><type>struct <name>compiling</name> *</type><name>c</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>node</name> *</type><name>n</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>n_ifs</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<while>while <condition>(<expr>1</expr>)</condition> <block>{
<expr_stmt><expr><call><name>REQ</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>gen_iter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>TYPE</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> == <name>gen_for</name></expr>)</condition><then>
<return>return <expr><name>n_ifs</name></expr>;</return></then></if>
<expr_stmt><expr><name>n</name> = <call><name>CHILD</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>REQ</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>gen_if</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>n_ifs</name>++</expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>NCH</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call> == 2</expr>)</condition><then>
<return>return <expr><name>n_ifs</name></expr>;</return></then></if>
<expr_stmt><expr><name>n</name> = <call><name>CHILD</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr>2</expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></while>
}</block></function>
<function><type><specifier>static</specifier> <name>expr_ty</name></type>
<name>ast_for_genexp</name><parameter_list>(<param><decl><type>struct <name>compiling</name> *</type><name>c</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>node</name> *</type><name>n</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>expr_ty</name></type> <name>elt</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>asdl_seq</name> *</type><name>genexps</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>n_fors</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>node</name> *</type><name>ch</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>TYPE</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call> == (<name>testlist_gexp</name>) || <call><name>TYPE</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call> == (<name>argument</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>NCH</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call> &gt; 1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>elt</name> = <call><name>ast_for_expr</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>elt</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>n_fors</name> = <call><name>count_gen_fors</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>n_fors</name> == -1</expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>genexps</name> = <call><name>asdl_seq_new</name><argument_list>(<argument><expr><name>n_fors</name></expr></argument>, <argument><expr><name><name>c</name>-&gt;<name>c_arena</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>genexps</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>ch</name> = <call><name>CHILD</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>n_fors</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
<decl_stmt><decl><type><name>comprehension_ty</name></type> <name>ge</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>asdl_seq</name> *</type><name>t</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>expr_ty</name></type> <name>expression</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>node</name> *</type><name>for_ch</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>REQ</name><argument_list>(<argument><expr><name>ch</name></expr></argument>, <argument><expr><name>gen_for</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>for_ch</name> = <call><name>CHILD</name><argument_list>(<argument><expr><name>ch</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>t</name> = <call><name>ast_for_exprlist</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>for_ch</name></expr></argument>, <argument><expr><name>Store</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>t</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>expression</name> = <call><name>ast_for_expr</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>ch</name></expr></argument>, <argument><expr>3</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>expression</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<if>if <condition>(<expr><call><name>NCH</name><argument_list>(<argument><expr><name>for_ch</name></expr></argument>)</argument_list></call> == 1</expr>)</condition><then>
<expr_stmt><expr><name>ge</name> = <call><name>comprehension</name><argument_list>(<argument><expr>(<name>expr_ty</name>)<call><name>asdl_seq_GET</name><argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>expression</name></expr></argument>,
<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name><name>c</name>-&gt;<name>c_arena</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
<else>else
<expr_stmt><expr><name>ge</name> = <call><name>comprehension</name><argument_list>(<argument><expr><call><name>Tuple</name><argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><name>Store</name></expr></argument>, <argument><expr><call><name>LINENO</name><argument_list>(<argument><expr><name>ch</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>ch</name>-&gt;<name>n_col_offset</name></name></expr></argument>,
<argument><expr><name><name>c</name>-&gt;<name>c_arena</name></name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>expression</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name><name>c</name>-&gt;<name>c_arena</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
<if>if <condition>(<expr>!<name>ge</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<if>if <condition>(<expr><call><name>NCH</name><argument_list>(<argument><expr><name>ch</name></expr></argument>)</argument_list></call> == 5</expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>, <decl><type ref="prev"/><name>n_ifs</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>asdl_seq</name> *</type><name>ifs</name></decl>;</decl_stmt>
<expr_stmt><expr><name>ch</name> = <call><name>CHILD</name><argument_list>(<argument><expr><name>ch</name></expr></argument>, <argument><expr>4</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>n_ifs</name> = <call><name>count_gen_ifs</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>ch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>n_ifs</name> == -1</expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>ifs</name> = <call><name>asdl_seq_new</name><argument_list>(<argument><expr><name>n_ifs</name></expr></argument>, <argument><expr><name><name>c</name>-&gt;<name>c_arena</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>ifs</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<for>for (<init><expr><name>j</name> = 0</expr>;</init> <condition><expr><name>j</name> &lt; <name>n_ifs</name></expr>;</condition> <incr><expr><name>j</name>++</expr></incr>) <block>{
<expr_stmt><expr><call><name>REQ</name><argument_list>(<argument><expr><name>ch</name></expr></argument>, <argument><expr><name>gen_iter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ch</name> = <call><name>CHILD</name><argument_list>(<argument><expr><name>ch</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>REQ</name><argument_list>(<argument><expr><name>ch</name></expr></argument>, <argument><expr><name>gen_if</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>expression</name> = <call><name>ast_for_expr</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>ch</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>expression</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><call><name>asdl_seq_SET</name><argument_list>(<argument><expr><name>ifs</name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><name>expression</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>NCH</name><argument_list>(<argument><expr><name>ch</name></expr></argument>)</argument_list></call> == 3</expr>)</condition><then>
<expr_stmt><expr><name>ch</name> = <call><name>CHILD</name><argument_list>(<argument><expr><name>ch</name></expr></argument>, <argument><expr>2</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
}</block></for>
<if>if <condition>(<expr><call><name>TYPE</name><argument_list>(<argument><expr><name>ch</name></expr></argument>)</argument_list></call> == <name>gen_iter</name></expr>)</condition><then>
<expr_stmt><expr><name>ch</name> = <call><name>CHILD</name><argument_list>(<argument><expr><name>ch</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<expr_stmt><expr><name><name>ge</name>-&gt;<name>ifs</name></name> = <name>ifs</name></expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><call><name>asdl_seq_SET</name><argument_list>(<argument><expr><name>genexps</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>ge</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></for>
<return>return <expr><call><name>GeneratorExp</name><argument_list>(<argument><expr><name>elt</name></expr></argument>, <argument><expr><name>genexps</name></expr></argument>, <argument><expr><call><name>LINENO</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>n</name>-&gt;<name>n_col_offset</name></name></expr></argument>, <argument><expr><name><name>c</name>-&gt;<name>c_arena</name></name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>expr_ty</name></type>
<name>ast_for_atom</name><parameter_list>(<param><decl><type>struct <name>compiling</name> *</type><name>c</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>node</name> *</type><name>n</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>node</name> *</type><name>ch</name> <init>= <expr><call><name>CHILD</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<switch>switch <condition>(<expr><call><name>TYPE</name><argument_list>(<argument><expr><name>ch</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{
<case>case <expr><name>NAME</name></expr>: <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>name</name> <init>= <expr><call><name>NEW_IDENTIFIER</name><argument_list>(<argument><expr><name>ch</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr>!<name>name</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<return>return <expr><call><name>Name</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>Load</name></expr></argument>, <argument><expr><call><name>LINENO</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>n</name>-&gt;<name>n_col_offset</name></name></expr></argument>, <argument><expr><name><name>c</name>-&gt;<name>c_arena</name></name></expr></argument>)</argument_list></call></expr>;</return>
}</block>
</case><case>case <expr><name>STRING</name></expr>: <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>str</name> <init>= <expr><call><name>parsestrplus</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr>!<name>str</name></expr>)</condition><then> <block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>Py_USING_UNICODE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if>if <condition>(<expr><call><name>PyErr_ExceptionMatches</name><argument_list>(<argument><expr><name>PyExc_UnicodeError</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>type</name></decl>, *<decl><type ref="prev"/><name>value</name></decl>, *<decl><type ref="prev"/><name>tback</name></decl>, *<decl><type ref="prev"/><name>errstr</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>PyErr_Fetch</name><argument_list>(<argument><expr>&amp;<name>type</name></expr></argument>, <argument><expr>&amp;<name>value</name></expr></argument>, <argument><expr>&amp;<name>tback</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>errstr</name> = <call><name>PyObject_Str</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>errstr</name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>char</name> *</type><name>s</name> <init>= <expr>""</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name><name>buf</name><index>[<expr>128</expr>]</index></name></decl>;</decl_stmt>
<expr_stmt><expr><name>s</name> = <call><name>PyString_AsString</name><argument_list>(<argument><expr><name>errstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyOS_snprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr>"(unicode error) %s"</expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ast_error</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>errstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr><call><name>ast_error</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr>"(unicode error) unknown error"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></else></if>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>tback</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><call><name>PyArena_AddPyObject</name><argument_list>(<argument><expr><name><name>c</name>-&gt;<name>c_arena</name></name></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>Str</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><call><name>LINENO</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>n</name>-&gt;<name>n_col_offset</name></name></expr></argument>, <argument><expr><name><name>c</name>-&gt;<name>c_arena</name></name></expr></argument>)</argument_list></call></expr>;</return>
}</block>
</case><case>case <expr><name>NUMBER</name></expr>: <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>pynum</name> <init>= <expr><call><name>parsenumber</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><call><name>STR</name><argument_list>(<argument><expr><name>ch</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr>!<name>pynum</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><call><name>PyArena_AddPyObject</name><argument_list>(<argument><expr><name><name>c</name>-&gt;<name>c_arena</name></name></expr></argument>, <argument><expr><name>pynum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>Num</name><argument_list>(<argument><expr><name>pynum</name></expr></argument>, <argument><expr><call><name>LINENO</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>n</name>-&gt;<name>n_col_offset</name></name></expr></argument>, <argument><expr><name><name>c</name>-&gt;<name>c_arena</name></name></expr></argument>)</argument_list></call></expr>;</return>
}</block>
</case><case>case <expr><name>LPAR</name></expr>:
<expr_stmt><expr><name>ch</name> = <call><name>CHILD</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>TYPE</name><argument_list>(<argument><expr><name>ch</name></expr></argument>)</argument_list></call> == <name>RPAR</name></expr>)</condition><then>
<return>return <expr><call><name>Tuple</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>Load</name></expr></argument>, <argument><expr><call><name>LINENO</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>n</name>-&gt;<name>n_col_offset</name></name></expr></argument>, <argument><expr><name><name>c</name>-&gt;<name>c_arena</name></name></expr></argument>)</argument_list></call></expr>;</return></then></if>
<if>if <condition>(<expr><call><name>TYPE</name><argument_list>(<argument><expr><name>ch</name></expr></argument>)</argument_list></call> == <name>yield_expr</name></expr>)</condition><then>
<return>return <expr><call><name>ast_for_expr</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>ch</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
<if>if <condition>(<expr>(<call><name>NCH</name><argument_list>(<argument><expr><name>ch</name></expr></argument>)</argument_list></call> &gt; 1) &amp;&amp; (<call><name>TYPE</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>ch</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> == <name>gen_for</name>)</expr>)</condition><then>
<return>return <expr><call><name>ast_for_genexp</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>ch</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
<return>return <expr><call><name>ast_for_testlist_gexp</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>ch</name></expr></argument>)</argument_list></call></expr>;</return>
</case><case>case <expr><name>LSQB</name></expr>:
<expr_stmt><expr><name>ch</name> = <call><name>CHILD</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>TYPE</name><argument_list>(<argument><expr><name>ch</name></expr></argument>)</argument_list></call> == <name>RSQB</name></expr>)</condition><then>
<return>return <expr><call><name>List</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>Load</name></expr></argument>, <argument><expr><call><name>LINENO</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>n</name>-&gt;<name>n_col_offset</name></name></expr></argument>, <argument><expr><name><name>c</name>-&gt;<name>c_arena</name></name></expr></argument>)</argument_list></call></expr>;</return></then></if>
<expr_stmt><expr><call><name>REQ</name><argument_list>(<argument><expr><name>ch</name></expr></argument>, <argument><expr><name>listmaker</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>NCH</name><argument_list>(<argument><expr><name>ch</name></expr></argument>)</argument_list></call> == 1 || <call><name>TYPE</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>ch</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> == <name>COMMA</name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>asdl_seq</name> *</type><name>elts</name> <init>= <expr><call><name>seq_for_testlist</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>ch</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr>!<name>elts</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<return>return <expr><call><name>List</name><argument_list>(<argument><expr><name>elts</name></expr></argument>, <argument><expr><name>Load</name></expr></argument>, <argument><expr><call><name>LINENO</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>n</name>-&gt;<name>n_col_offset</name></name></expr></argument>, <argument><expr><name><name>c</name>-&gt;<name>c_arena</name></name></expr></argument>)</argument_list></call></expr>;</return>
}</block></then> <else>else
<return>return <expr><call><name>ast_for_listcomp</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>ch</name></expr></argument>)</argument_list></call></expr>;</return></else></if>
</case><case>case <expr><name>LBRACE</name></expr>: <block>{
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>size</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>asdl_seq</name> *</type><name>keys</name></decl>, *<decl><type ref="prev"/><name>values</name></decl>;</decl_stmt>
<expr_stmt><expr><name>ch</name> = <call><name>CHILD</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>size</name> = (<call><name>NCH</name><argument_list>(<argument><expr><name>ch</name></expr></argument>)</argument_list></call> + 1) / 4</expr>;</expr_stmt>
<expr_stmt><expr><name>keys</name> = <call><name>asdl_seq_new</name><argument_list>(<argument><expr><name>size</name></expr></argument>, <argument><expr><name><name>c</name>-&gt;<name>c_arena</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>keys</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>values</name> = <call><name>asdl_seq_new</name><argument_list>(<argument><expr><name>size</name></expr></argument>, <argument><expr><name><name>c</name>-&gt;<name>c_arena</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>values</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <call><name>NCH</name><argument_list>(<argument><expr><name>ch</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name> += 4</expr></incr>) <block>{
<decl_stmt><decl><type><name>expr_ty</name></type> <name>expression</name></decl>;</decl_stmt>
<expr_stmt><expr><name>expression</name> = <call><name>ast_for_expr</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>ch</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>expression</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><call><name>asdl_seq_SET</name><argument_list>(<argument><expr><name>keys</name></expr></argument>, <argument><expr><name>i</name> / 4</expr></argument>, <argument><expr><name>expression</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>expression</name> = <call><name>ast_for_expr</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>ch</name></expr></argument>, <argument><expr><name>i</name> + 2</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>expression</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><call><name>asdl_seq_SET</name><argument_list>(<argument><expr><name>values</name></expr></argument>, <argument><expr><name>i</name> / 4</expr></argument>, <argument><expr><name>expression</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></for>
<return>return <expr><call><name>Dict</name><argument_list>(<argument><expr><name>keys</name></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><call><name>LINENO</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>n</name>-&gt;<name>n_col_offset</name></name></expr></argument>, <argument><expr><name><name>c</name>-&gt;<name>c_arena</name></name></expr></argument>)</argument_list></call></expr>;</return>
}</block>
</case><case>case <expr><name>BACKQUOTE</name></expr>: <block>{
<decl_stmt><decl><type><name>expr_ty</name></type> <name>expression</name></decl>;</decl_stmt>
<if>if <condition>(<expr><name>Py_Py3kWarningFlag</name> &amp;&amp;
!<call><name>ast_warn</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr>"backquote not supported in 3.x; use repr()"</expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>expression</name> = <call><name>ast_for_testlist</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>expression</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<return>return <expr><call><name>Repr</name><argument_list>(<argument><expr><name>expression</name></expr></argument>, <argument><expr><call><name>LINENO</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>n</name>-&gt;<name>n_col_offset</name></name></expr></argument>, <argument><expr><name><name>c</name>-&gt;<name>c_arena</name></name></expr></argument>)</argument_list></call></expr>;</return>
}</block>
</case><default>default:
<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_SystemError</name></expr></argument>, <argument><expr>"unhandled atom %d"</expr></argument>, <argument><expr><call><name>TYPE</name><argument_list>(<argument><expr><name>ch</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
</default>}</block></switch>
}</block></function>
<function><type><specifier>static</specifier> <name>slice_ty</name></type>
<name>ast_for_slice</name><parameter_list>(<param><decl><type>struct <name>compiling</name> *</type><name>c</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>node</name> *</type><name>n</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>node</name> *</type><name>ch</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>expr_ty</name></type> <name>lower</name> <init>= <expr><name>NULL</name></expr></init>, <name>upper</name> <init>= <expr><name>NULL</name></expr></init>, <name>step</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>REQ</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>subscript</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ch</name> = <call><name>CHILD</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>TYPE</name><argument_list>(<argument><expr><name>ch</name></expr></argument>)</argument_list></call> == <name>DOT</name></expr>)</condition><then>
<return>return <expr><call><name>Ellipsis</name><argument_list>(<argument><expr><name><name>c</name>-&gt;<name>c_arena</name></name></expr></argument>)</argument_list></call></expr>;</return></then></if>
<if>if <condition>(<expr><call><name>NCH</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call> == 1 &amp;&amp; <call><name>TYPE</name><argument_list>(<argument><expr><name>ch</name></expr></argument>)</argument_list></call> == <name>test</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>step</name> = <call><name>ast_for_expr</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>ch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>step</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<return>return <expr><call><name>Index</name><argument_list>(<argument><expr><name>step</name></expr></argument>, <argument><expr><name><name>c</name>-&gt;<name>c_arena</name></name></expr></argument>)</argument_list></call></expr>;</return>
}</block></then></if>
<if>if <condition>(<expr><call><name>TYPE</name><argument_list>(<argument><expr><name>ch</name></expr></argument>)</argument_list></call> == <name>test</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>lower</name> = <call><name>ast_for_expr</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>ch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>lower</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
}</block></then></if>
<if>if <condition>(<expr><call><name>TYPE</name><argument_list>(<argument><expr><name>ch</name></expr></argument>)</argument_list></call> == <name>COLON</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr><call><name>NCH</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call> &gt; 1</expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>node</name> *</type><name>n2</name> <init>= <expr><call><name>CHILD</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><call><name>TYPE</name><argument_list>(<argument><expr><name>n2</name></expr></argument>)</argument_list></call> == <name>test</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>upper</name> = <call><name>ast_for_expr</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>n2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>upper</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
}</block></then></if>
}</block></then></if>
}</block></then> <else>else <if>if <condition>(<expr><call><name>NCH</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call> &gt; 2</expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>node</name> *</type><name>n2</name> <init>= <expr><call><name>CHILD</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr>2</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><call><name>TYPE</name><argument_list>(<argument><expr><name>n2</name></expr></argument>)</argument_list></call> == <name>test</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>upper</name> = <call><name>ast_for_expr</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>n2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>upper</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
}</block></then></if>
}</block></then></if></else></if>
<expr_stmt><expr><name>ch</name> = <call><name>CHILD</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><call><name>NCH</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call> - 1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>TYPE</name><argument_list>(<argument><expr><name>ch</name></expr></argument>)</argument_list></call> == <name>sliceop</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr><call><name>NCH</name><argument_list>(<argument><expr><name>ch</name></expr></argument>)</argument_list></call> == 1</expr>)</condition><then> <block>{
<expr_stmt><expr><name>ch</name> = <call><name>CHILD</name><argument_list>(<argument><expr><name>ch</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>step</name> = <call><name>Name</name><argument_list>(<argument><expr><call><name>new_identifier</name><argument_list>(<argument><expr>"None"</expr></argument>, <argument><expr><name><name>c</name>-&gt;<name>c_arena</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>Load</name></expr></argument>,
<argument><expr><call><name>LINENO</name><argument_list>(<argument><expr><name>ch</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>ch</name>-&gt;<name>n_col_offset</name></name></expr></argument>, <argument><expr><name><name>c</name>-&gt;<name>c_arena</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>step</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
}</block></then> <else>else <block>{
<expr_stmt><expr><name>ch</name> = <call><name>CHILD</name><argument_list>(<argument><expr><name>ch</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>TYPE</name><argument_list>(<argument><expr><name>ch</name></expr></argument>)</argument_list></call> == <name>test</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>step</name> = <call><name>ast_for_expr</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>ch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>step</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
}</block></then></if>
}</block></else></if>
}</block></then></if>
<return>return <expr><call><name>Slice</name><argument_list>(<argument><expr><name>lower</name></expr></argument>, <argument><expr><name>upper</name></expr></argument>, <argument><expr><name>step</name></expr></argument>, <argument><expr><name><name>c</name>-&gt;<name>c_arena</name></name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>expr_ty</name></type>
<name>ast_for_binop</name><parameter_list>(<param><decl><type>struct <name>compiling</name> *</type><name>c</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>node</name> *</type><name>n</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>nops</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>expr_ty</name></type> <name>expr1</name></decl>, <decl><type ref="prev"/><name>expr2</name></decl>, <decl><type ref="prev"/><name>result</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>operator_ty</name></type> <name>newoperator</name></decl>;</decl_stmt>
<expr_stmt><expr><name>expr1</name> = <call><name>ast_for_expr</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>expr1</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>expr2</name> = <call><name>ast_for_expr</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr>2</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>expr2</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>newoperator</name> = <call><name>get_operator</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>newoperator</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>result</name> = <call><name>BinOp</name><argument_list>(<argument><expr><name>expr1</name></expr></argument>, <argument><expr><name>newoperator</name></expr></argument>, <argument><expr><name>expr2</name></expr></argument>, <argument><expr><call><name>LINENO</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>n</name>-&gt;<name>n_col_offset</name></name></expr></argument>,
<argument><expr><name><name>c</name>-&gt;<name>c_arena</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>result</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>nops</name> = (<call><name>NCH</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call> - 1) / 2</expr>;</expr_stmt>
<for>for (<init><expr><name>i</name> = 1</expr>;</init> <condition><expr><name>i</name> &lt; <name>nops</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
<decl_stmt><decl><type><name>expr_ty</name></type> <name>tmp_result</name></decl>, <decl><type ref="prev"/><name>tmp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>node</name>*</type> <name>next_oper</name> <init>= <expr><call><name>CHILD</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>i</name> * 2 + 1</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>newoperator</name> = <call><name>get_operator</name><argument_list>(<argument><expr><name>next_oper</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>newoperator</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>tmp</name> = <call><name>ast_for_expr</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>i</name> * 2 + 2</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>tmp</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>tmp_result</name> = <call><name>BinOp</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>newoperator</name></expr></argument>, <argument><expr><name>tmp</name></expr></argument>,
<argument><expr><call><name>LINENO</name><argument_list>(<argument><expr><name>next_oper</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>next_oper</name>-&gt;<name>n_col_offset</name></name></expr></argument>,
<argument><expr><name><name>c</name>-&gt;<name>c_arena</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>tmp_result</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>result</name> = <name>tmp_result</name></expr>;</expr_stmt>
}</block></for>
<return>return <expr><name>result</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>expr_ty</name></type>
<name>ast_for_trailer</name><parameter_list>(<param><decl><type>struct <name>compiling</name> *</type><name>c</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>node</name> *</type><name>n</name></decl></param>, <param><decl><type><name>expr_ty</name></type> <name>left_expr</name></decl></param>)</parameter_list> <block>{
<expr_stmt><expr><call><name>REQ</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>trailer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>TYPE</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> == <name>LPAR</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr><call><name>NCH</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call> == 2</expr>)</condition><then>
<return>return <expr><call><name>Call</name><argument_list>(<argument><expr><name>left_expr</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><call><name>LINENO</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name><name>n</name>-&gt;<name>n_col_offset</name></name></expr></argument>, <argument><expr><name><name>c</name>-&gt;<name>c_arena</name></name></expr></argument>)</argument_list></call></expr>;</return></then>
<else>else
<return>return <expr><call><name>ast_for_call</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>left_expr</name></expr></argument>)</argument_list></call></expr>;</return></else></if>
}</block></then> <else>else <if>if <condition>(<expr><call><name>TYPE</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> == <name>DOT</name></expr> )</condition><then> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>attr_id</name> <init>= <expr><call><name>NEW_IDENTIFIER</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr>!<name>attr_id</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<return>return <expr><call><name>Attribute</name><argument_list>(<argument><expr><name>left_expr</name></expr></argument>, <argument><expr><name>attr_id</name></expr></argument>, <argument><expr><name>Load</name></expr></argument>,
<argument><expr><call><name>LINENO</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>n</name>-&gt;<name>n_col_offset</name></name></expr></argument>, <argument><expr><name><name>c</name>-&gt;<name>c_arena</name></name></expr></argument>)</argument_list></call></expr>;</return>
}</block></then> <else>else <block>{
<expr_stmt><expr><call><name>REQ</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>LSQB</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>REQ</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr>2</expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>RSQB</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>n</name> = <call><name>CHILD</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>NCH</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call> == 1</expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>slice_ty</name></type> <name>slc</name> <init>= <expr><call><name>ast_for_slice</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr>!<name>slc</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<return>return <expr><call><name>Subscript</name><argument_list>(<argument><expr><name>left_expr</name></expr></argument>, <argument><expr><name>slc</name></expr></argument>, <argument><expr><name>Load</name></expr></argument>, <argument><expr><call><name>LINENO</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>n</name>-&gt;<name>n_col_offset</name></name></expr></argument>,
<argument><expr><name><name>c</name>-&gt;<name>c_arena</name></name></expr></argument>)</argument_list></call></expr>;</return>
}</block></then> <else>else <block>{
<decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>slice_ty</name></type> <name>slc</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>expr_ty</name></type> <name>e</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>simple</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>asdl_seq</name> *</type><name>slices</name></decl>, *<decl><type ref="prev"/><name>elts</name></decl>;</decl_stmt>
<expr_stmt><expr><name>slices</name> = <call><name>asdl_seq_new</name><argument_list>(<argument><expr>(<call><name>NCH</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call> + 1) / 2</expr></argument>, <argument><expr><name><name>c</name>-&gt;<name>c_arena</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>slices</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<for>for (<init><expr><name>j</name> = 0</expr>;</init> <condition><expr><name>j</name> &lt; <call><name>NCH</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>j</name> += 2</expr></incr>) <block>{
<expr_stmt><expr><name>slc</name> = <call><name>ast_for_slice</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>slc</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<if>if <condition>(<expr><name><name>slc</name>-&gt;<name>kind</name></name> != <name>Index_kind</name></expr>)</condition><then>
<expr_stmt><expr><name>simple</name> = <name>false</name></expr>;</expr_stmt></then></if>
<expr_stmt><expr><call><name>asdl_seq_SET</name><argument_list>(<argument><expr><name>slices</name></expr></argument>, <argument><expr><name>j</name> / 2</expr></argument>, <argument><expr><name>slc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></for>
<if>if <condition>(<expr>!<name>simple</name></expr>)</condition><then> <block>{
<return>return <expr><call><name>Subscript</name><argument_list>(<argument><expr><name>left_expr</name></expr></argument>, <argument><expr><call><name>ExtSlice</name><argument_list>(<argument><expr><name>slices</name></expr></argument>, <argument><expr><name><name>c</name>-&gt;<name>c_arena</name></name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>Load</name></expr></argument>, <argument><expr><call><name>LINENO</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>n</name>-&gt;<name>n_col_offset</name></name></expr></argument>, <argument><expr><name><name>c</name>-&gt;<name>c_arena</name></name></expr></argument>)</argument_list></call></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>elts</name> = <call><name>asdl_seq_new</name><argument_list>(<argument><expr><call><name>asdl_seq_LEN</name><argument_list>(<argument><expr><name>slices</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>c</name>-&gt;<name>c_arena</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>elts</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<for>for (<init><expr><name>j</name> = 0</expr>;</init> <condition><expr><name>j</name> &lt; <call><name>asdl_seq_LEN</name><argument_list>(<argument><expr><name>slices</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr>++<name>j</name></expr></incr>) <block>{
<expr_stmt><expr><name>slc</name> = (<name>slice_ty</name>)<call><name>asdl_seq_GET</name><argument_list>(<argument><expr><name>slices</name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>slc</name>-&gt;<name>kind</name></name> == <name>Index_kind</name> &amp;&amp; <name><name>slc</name>-&gt;<name>v</name>.<name>Index</name>.<name>value</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>asdl_seq_SET</name><argument_list>(<argument><expr><name>elts</name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><name><name>slc</name>-&gt;<name>v</name>.<name>Index</name>.<name>value</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></for>
<expr_stmt><expr><name>e</name> = <call><name>Tuple</name><argument_list>(<argument><expr><name>elts</name></expr></argument>, <argument><expr><name>Load</name></expr></argument>, <argument><expr><call><name>LINENO</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>n</name>-&gt;<name>n_col_offset</name></name></expr></argument>, <argument><expr><name><name>c</name>-&gt;<name>c_arena</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>e</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<return>return <expr><call><name>Subscript</name><argument_list>(<argument><expr><name>left_expr</name></expr></argument>, <argument><expr><call><name>Index</name><argument_list>(<argument><expr><name>e</name></expr></argument>, <argument><expr><name><name>c</name>-&gt;<name>c_arena</name></name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>Load</name></expr></argument>, <argument><expr><call><name>LINENO</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>n</name>-&gt;<name>n_col_offset</name></name></expr></argument>, <argument><expr><name><name>c</name>-&gt;<name>c_arena</name></name></expr></argument>)</argument_list></call></expr>;</return>
}</block></else></if>
}</block></else></if></else></if>
}</block></function>
<function><type><specifier>static</specifier> <name>expr_ty</name></type>
<name>ast_for_factor</name><parameter_list>(<param><decl><type>struct <name>compiling</name> *</type><name>c</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>node</name> *</type><name>n</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>node</name> *</type><name>pfactor</name></decl>, *<decl><type ref="prev"/><name>ppower</name></decl>, *<decl><type ref="prev"/><name>patom</name></decl>, *<decl><type ref="prev"/><name>pnum</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>expr_ty</name></type> <name>expression</name></decl>;</decl_stmt>
<if>if <condition>(<expr><call><name>TYPE</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> == <name>MINUS</name> &amp;&amp;
<call><name>NCH</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call> == 2 &amp;&amp;
<call><name>TYPE</name><argument_list>(<argument><expr>(<name>pfactor</name> = <call><name>CHILD</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call>)</expr></argument>)</argument_list></call> == <name>factor</name> &amp;&amp;
<call><name>NCH</name><argument_list>(<argument><expr><name>pfactor</name></expr></argument>)</argument_list></call> == 1 &amp;&amp;
<call><name>TYPE</name><argument_list>(<argument><expr>(<name>ppower</name> = <call><name>CHILD</name><argument_list>(<argument><expr><name>pfactor</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call>)</expr></argument>)</argument_list></call> == <name>power</name> &amp;&amp;
<call><name>NCH</name><argument_list>(<argument><expr><name>ppower</name></expr></argument>)</argument_list></call> == 1 &amp;&amp;
<call><name>TYPE</name><argument_list>(<argument><expr>(<name>patom</name> = <call><name>CHILD</name><argument_list>(<argument><expr><name>ppower</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call>)</expr></argument>)</argument_list></call> == <name>atom</name> &amp;&amp;
<call><name>TYPE</name><argument_list>(<argument><expr>(<name>pnum</name> = <call><name>CHILD</name><argument_list>(<argument><expr><name>patom</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call>)</expr></argument>)</argument_list></call> == <name>NUMBER</name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>char</name> *</type><name>s</name> <init>= <expr><call><name>PyObject_MALLOC</name><argument_list>(<argument><expr><call><name>strlen</name><argument_list>(<argument><expr><call><name>STR</name><argument_list>(<argument><expr><name>pnum</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> + 2</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>s</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name><name>s</name><index>[<expr>0</expr>]</index></name> = '-'</expr>;</expr_stmt>
<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>s</name> + 1</expr></argument>, <argument><expr><call><name>STR</name><argument_list>(<argument><expr><name>pnum</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyObject_FREE</name><argument_list>(<argument><expr><call><name>STR</name><argument_list>(<argument><expr><name>pnum</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>STR</name><argument_list>(<argument><expr><name>pnum</name></expr></argument>)</argument_list></call> = <name>s</name></expr>;</expr_stmt>
<return>return <expr><call><name>ast_for_atom</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>patom</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>expression</name> = <call><name>ast_for_expr</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>expression</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<switch>switch <condition>(<expr><call><name>TYPE</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{
<case>case <expr><name>PLUS</name></expr>:
<return>return <expr><call><name>UnaryOp</name><argument_list>(<argument><expr><name>UAdd</name></expr></argument>, <argument><expr><name>expression</name></expr></argument>, <argument><expr><call><name>LINENO</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>n</name>-&gt;<name>n_col_offset</name></name></expr></argument>,
<argument><expr><name><name>c</name>-&gt;<name>c_arena</name></name></expr></argument>)</argument_list></call></expr>;</return>
</case><case>case <expr><name>MINUS</name></expr>:
<return>return <expr><call><name>UnaryOp</name><argument_list>(<argument><expr><name>USub</name></expr></argument>, <argument><expr><name>expression</name></expr></argument>, <argument><expr><call><name>LINENO</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>n</name>-&gt;<name>n_col_offset</name></name></expr></argument>,
<argument><expr><name><name>c</name>-&gt;<name>c_arena</name></name></expr></argument>)</argument_list></call></expr>;</return>
</case><case>case <expr><name>TILDE</name></expr>:
<return>return <expr><call><name>UnaryOp</name><argument_list>(<argument><expr><name>Invert</name></expr></argument>, <argument><expr><name>expression</name></expr></argument>, <argument><expr><call><name>LINENO</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name><name>n</name>-&gt;<name>n_col_offset</name></name></expr></argument>, <argument><expr><name><name>c</name>-&gt;<name>c_arena</name></name></expr></argument>)</argument_list></call></expr>;</return>
</case>}</block></switch>
<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_SystemError</name></expr></argument>, <argument><expr>"unhandled factor: %d"</expr></argument>,
<argument><expr><call><name>TYPE</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>expr_ty</name></type>
<name>ast_for_power</name><parameter_list>(<param><decl><type>struct <name>compiling</name> *</type><name>c</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>node</name> *</type><name>n</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>expr_ty</name></type> <name>e</name></decl>, <decl><type ref="prev"/><name>tmp</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>REQ</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>power</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>e</name> = <call><name>ast_for_atom</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>e</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<if>if <condition>(<expr><call><name>NCH</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call> == 1</expr>)</condition><then>
<return>return <expr><name>e</name></expr>;</return></then></if>
<for>for (<init><expr><name>i</name> = 1</expr>;</init> <condition><expr><name>i</name> &lt; <call><name>NCH</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
<decl_stmt><decl><type><name>node</name> *</type><name>ch</name> <init>= <expr><call><name>CHILD</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><call><name>TYPE</name><argument_list>(<argument><expr><name>ch</name></expr></argument>)</argument_list></call> != <name>trailer</name></expr>)</condition><then>
<break>break;</break></then></if>
<expr_stmt><expr><name>tmp</name> = <call><name>ast_for_trailer</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>ch</name></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>tmp</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name><name>tmp</name>-&gt;<name>lineno</name></name> = <name><name>e</name>-&gt;<name>lineno</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tmp</name>-&gt;<name>col_offset</name></name> = <name><name>e</name>-&gt;<name>col_offset</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>e</name> = <name>tmp</name></expr>;</expr_stmt>
}</block></for>
<if>if <condition>(<expr><call><name>TYPE</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><call><name>NCH</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call> - 1</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> == <name>factor</name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>expr_ty</name></type> <name>f</name> <init>= <expr><call><name>ast_for_expr</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><call><name>NCH</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call> - 1</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr>!<name>f</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>tmp</name> = <call><name>BinOp</name><argument_list>(<argument><expr><name>e</name></expr></argument>, <argument><expr><name>Pow</name></expr></argument>, <argument><expr><name>f</name></expr></argument>, <argument><expr><call><name>LINENO</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>n</name>-&gt;<name>n_col_offset</name></name></expr></argument>, <argument><expr><name><name>c</name>-&gt;<name>c_arena</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>tmp</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>e</name> = <name>tmp</name></expr>;</expr_stmt>
}</block></then></if>
<return>return <expr><name>e</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>expr_ty</name></type>
<name>ast_for_expr</name><parameter_list>(<param><decl><type>struct <name>compiling</name> *</type><name>c</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>node</name> *</type><name>n</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>asdl_seq</name> *</type><name>seq</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<label><name>loop</name>:</label>
<switch>switch <condition>(<expr><call><name>TYPE</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{
<case>case <expr><name>test</name></expr>:
</case><case>case <expr><name>old_test</name></expr>:
<if>if <condition>(<expr><call><name>TYPE</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> == <name>lambdef</name> ||
<call><name>TYPE</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> == <name>old_lambdef</name></expr>)</condition><then>
<return>return <expr><call><name>ast_for_lambdef</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></then>
<else>else <if>if <condition>(<expr><call><name>NCH</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call> &gt; 1</expr>)</condition><then>
<return>return <expr><call><name>ast_for_ifexpr</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</return></then></if></else></if>
</case><case>case <expr><name>or_test</name></expr>:
</case><case>case <expr><name>and_test</name></expr>:
<if>if <condition>(<expr><call><name>NCH</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call> == 1</expr>)</condition><then> <block>{
<expr_stmt><expr><name>n</name> = <call><name>CHILD</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>loop</name>;</goto>
}</block></then></if>
<expr_stmt><expr><name>seq</name> = <call><name>asdl_seq_new</name><argument_list>(<argument><expr>(<call><name>NCH</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call> + 1) / 2</expr></argument>, <argument><expr><name><name>c</name>-&gt;<name>c_arena</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>seq</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <call><name>NCH</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name> += 2</expr></incr>) <block>{
<decl_stmt><decl><type><name>expr_ty</name></type> <name>e</name> <init>= <expr><call><name>ast_for_expr</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr>!<name>e</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><call><name>asdl_seq_SET</name><argument_list>(<argument><expr><name>seq</name></expr></argument>, <argument><expr><name>i</name> / 2</expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></for>
<if>if <condition>(<expr>!<call><name>strcmp</name><argument_list>(<argument><expr><call><name>STR</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>"and"</expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><call><name>BoolOp</name><argument_list>(<argument><expr><name>And</name></expr></argument>, <argument><expr><name>seq</name></expr></argument>, <argument><expr><call><name>LINENO</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>n</name>-&gt;<name>n_col_offset</name></name></expr></argument>,
<argument><expr><name><name>c</name>-&gt;<name>c_arena</name></name></expr></argument>)</argument_list></call></expr>;</return></then></if>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr>!<call><name>strcmp</name><argument_list>(<argument><expr><call><name>STR</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>"or"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>BoolOp</name><argument_list>(<argument><expr><name>Or</name></expr></argument>, <argument><expr><name>seq</name></expr></argument>, <argument><expr><call><name>LINENO</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>n</name>-&gt;<name>n_col_offset</name></name></expr></argument>, <argument><expr><name><name>c</name>-&gt;<name>c_arena</name></name></expr></argument>)</argument_list></call></expr>;</return>
</case><case>case <expr><name>not_test</name></expr>:
<if>if <condition>(<expr><call><name>NCH</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call> == 1</expr>)</condition><then> <block>{
<expr_stmt><expr><name>n</name> = <call><name>CHILD</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>loop</name>;</goto>
}</block></then> <else>else <block>{
<decl_stmt><decl><type><name>expr_ty</name></type> <name>expression</name> <init>= <expr><call><name>ast_for_expr</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr>!<name>expression</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<return>return <expr><call><name>UnaryOp</name><argument_list>(<argument><expr><name>Not</name></expr></argument>, <argument><expr><name>expression</name></expr></argument>, <argument><expr><call><name>LINENO</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>n</name>-&gt;<name>n_col_offset</name></name></expr></argument>,
<argument><expr><name><name>c</name>-&gt;<name>c_arena</name></name></expr></argument>)</argument_list></call></expr>;</return>
}</block></else></if>
</case><case>case <expr><name>comparison</name></expr>:
<if>if <condition>(<expr><call><name>NCH</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call> == 1</expr>)</condition><then> <block>{
<expr_stmt><expr><name>n</name> = <call><name>CHILD</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>loop</name>;</goto>
}</block></then> <else>else <block>{
<decl_stmt><decl><type><name>expr_ty</name></type> <name>expression</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>asdl_int_seq</name> *</type><name>ops</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>asdl_seq</name> *</type><name>cmps</name></decl>;</decl_stmt>
<expr_stmt><expr><name>ops</name> = <call><name>asdl_int_seq_new</name><argument_list>(<argument><expr><call><name>NCH</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call> / 2</expr></argument>, <argument><expr><name><name>c</name>-&gt;<name>c_arena</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>ops</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>cmps</name> = <call><name>asdl_seq_new</name><argument_list>(<argument><expr><call><name>NCH</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call> / 2</expr></argument>, <argument><expr><name><name>c</name>-&gt;<name>c_arena</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>cmps</name></expr>)</condition><then> <block>{
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<for>for (<init><expr><name>i</name> = 1</expr>;</init> <condition><expr><name>i</name> &lt; <call><name>NCH</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name> += 2</expr></incr>) <block>{
<decl_stmt><decl><type><name>cmpop_ty</name></type> <name>newoperator</name></decl>;</decl_stmt>
<expr_stmt><expr><name>newoperator</name> = <call><name>ast_for_comp_op</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>newoperator</name></expr>)</condition><then> <block>{
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>expression</name> = <call><name>ast_for_expr</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>i</name> + 1</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>expression</name></expr>)</condition><then> <block>{
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><call><name>asdl_seq_SET</name><argument_list>(<argument><expr><name>ops</name></expr></argument>, <argument><expr><name>i</name> / 2</expr></argument>, <argument><expr><name>newoperator</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>asdl_seq_SET</name><argument_list>(<argument><expr><name>cmps</name></expr></argument>, <argument><expr><name>i</name> / 2</expr></argument>, <argument><expr><name>expression</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></for>
<expr_stmt><expr><name>expression</name> = <call><name>ast_for_expr</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>expression</name></expr>)</condition><then> <block>{
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<return>return <expr><call><name>Compare</name><argument_list>(<argument><expr><name>expression</name></expr></argument>, <argument><expr><name>ops</name></expr></argument>, <argument><expr><name>cmps</name></expr></argument>, <argument><expr><call><name>LINENO</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name><name>n</name>-&gt;<name>n_col_offset</name></name></expr></argument>, <argument><expr><name><name>c</name>-&gt;<name>c_arena</name></name></expr></argument>)</argument_list></call></expr>;</return>
}</block></else></if>
<break>break;</break>
</case><case>case <expr><name>expr</name></expr>:
</case><case>case <expr><name>xor_expr</name></expr>:
</case><case>case <expr><name>and_expr</name></expr>:
</case><case>case <expr><name>shift_expr</name></expr>:
</case><case>case <expr><name>arith_expr</name></expr>:
</case><case>case <expr><name>term</name></expr>:
<if>if <condition>(<expr><call><name>NCH</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call> == 1</expr>)</condition><then> <block>{
<expr_stmt><expr><name>n</name> = <call><name>CHILD</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>loop</name>;</goto>
}</block></then></if>
<return>return <expr><call><name>ast_for_binop</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</return>
</case><case>case <expr><name>yield_expr</name></expr>: <block>{
<decl_stmt><decl><type><name>expr_ty</name></type> <name>exp</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><call><name>NCH</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call> == 2</expr>)</condition><then> <block>{
<expr_stmt><expr><name>exp</name> = <call><name>ast_for_testlist</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>exp</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
}</block></then></if>
<return>return <expr><call><name>Yield</name><argument_list>(<argument><expr><name>exp</name></expr></argument>, <argument><expr><call><name>LINENO</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>n</name>-&gt;<name>n_col_offset</name></name></expr></argument>, <argument><expr><name><name>c</name>-&gt;<name>c_arena</name></name></expr></argument>)</argument_list></call></expr>;</return>
}</block>
</case><case>case <expr><name>factor</name></expr>:
<if>if <condition>(<expr><call><name>NCH</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call> == 1</expr>)</condition><then> <block>{
<expr_stmt><expr><name>n</name> = <call><name>CHILD</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>loop</name>;</goto>
}</block></then></if>
<return>return <expr><call><name>ast_for_factor</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</return>
</case><case>case <expr><name>power</name></expr>:
<return>return <expr><call><name>ast_for_power</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</return>
</case><default>default:
<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_SystemError</name></expr></argument>, <argument><expr>"unhandled expr: %d"</expr></argument>, <argument><expr><call><name>TYPE</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
</default>}</block></switch>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>expr_ty</name></type>
<name>ast_for_call</name><parameter_list>(<param><decl><type>struct <name>compiling</name> *</type><name>c</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>node</name> *</type><name>n</name></decl></param>, <param><decl><type><name>expr_ty</name></type> <name>func</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>nargs</name></decl>, <decl><type ref="prev"/><name>nkeywords</name></decl>, <decl><type ref="prev"/><name>ngens</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>asdl_seq</name> *</type><name>args</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>asdl_seq</name> *</type><name>keywords</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>expr_ty</name></type> <name>vararg</name> <init>= <expr><name>NULL</name></expr></init>, <name>kwarg</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>REQ</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>arglist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>nargs</name> = 0</expr>;</expr_stmt>
<expr_stmt><expr><name>nkeywords</name> = 0</expr>;</expr_stmt>
<expr_stmt><expr><name>ngens</name> = 0</expr>;</expr_stmt>
<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <call><name>NCH</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
<decl_stmt><decl><type><name>node</name> *</type><name>ch</name> <init>= <expr><call><name>CHILD</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><call><name>TYPE</name><argument_list>(<argument><expr><name>ch</name></expr></argument>)</argument_list></call> == <name>argument</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr><call><name>NCH</name><argument_list>(<argument><expr><name>ch</name></expr></argument>)</argument_list></call> == 1</expr>)</condition><then>
<expr_stmt><expr><name>nargs</name>++</expr>;</expr_stmt></then>
<else>else <if>if <condition>(<expr><call><name>TYPE</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>ch</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> == <name>gen_for</name></expr>)</condition><then>
<expr_stmt><expr><name>ngens</name>++</expr>;</expr_stmt></then>
<else>else
<expr_stmt><expr><name>nkeywords</name>++</expr>;</expr_stmt></else></if></else></if>
}</block></then></if>
}</block></for>
<if>if <condition>(<expr><name>ngens</name> &gt; 1 || (<name>ngens</name> &amp;&amp; (<name>nargs</name> || <name>nkeywords</name>))</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>ast_error</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr>"Generator expression must be parenthesized "
"if not sole argument"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<if>if <condition>(<expr><name>nargs</name> + <name>nkeywords</name> + <name>ngens</name> &gt; 255</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>ast_error</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr>"more than 255 arguments"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>args</name> = <call><name>asdl_seq_new</name><argument_list>(<argument><expr><name>nargs</name> + <name>ngens</name></expr></argument>, <argument><expr><name><name>c</name>-&gt;<name>c_arena</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>args</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>keywords</name> = <call><name>asdl_seq_new</name><argument_list>(<argument><expr><name>nkeywords</name></expr></argument>, <argument><expr><name><name>c</name>-&gt;<name>c_arena</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>keywords</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>nargs</name> = 0</expr>;</expr_stmt>
<expr_stmt><expr><name>nkeywords</name> = 0</expr>;</expr_stmt>
<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <call><name>NCH</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
<decl_stmt><decl><type><name>node</name> *</type><name>ch</name> <init>= <expr><call><name>CHILD</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><call><name>TYPE</name><argument_list>(<argument><expr><name>ch</name></expr></argument>)</argument_list></call> == <name>argument</name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>expr_ty</name></type> <name>e</name></decl>;</decl_stmt>
<if>if <condition>(<expr><call><name>NCH</name><argument_list>(<argument><expr><name>ch</name></expr></argument>)</argument_list></call> == 1</expr>)</condition><then> <block>{
<if>if <condition>(<expr><name>nkeywords</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>ast_error</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>ch</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></argument>,
<argument><expr>"non-keyword arg after keyword arg"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<if>if <condition>(<expr><name>vararg</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>ast_error</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>ch</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></argument>,
<argument><expr>"only named arguments may follow *expression"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>e</name> = <call><name>ast_for_expr</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>ch</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>e</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><call><name>asdl_seq_SET</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>nargs</name>++</expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else <if>if <condition>(<expr><call><name>TYPE</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>ch</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> == <name>gen_for</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>e</name> = <call><name>ast_for_genexp</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>ch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>e</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><call><name>asdl_seq_SET</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>nargs</name>++</expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<decl_stmt><decl><type><name>keyword_ty</name></type> <name>kw</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>identifier</name></type> <name>key</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>k</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>tmp</name></decl>;</decl_stmt>
<expr_stmt><expr><name>e</name> = <call><name>ast_for_expr</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>ch</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>e</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<if>if <condition>(<expr><name><name>e</name>-&gt;<name>kind</name></name> == <name>Lambda_kind</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>ast_error</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>ch</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></argument>,
<argument><expr>"lambda cannot contain assignment"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then> <else>else <if>if <condition>(<expr><name><name>e</name>-&gt;<name>kind</name></name> != <name>Name_kind</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>ast_error</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>ch</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></argument>, <argument><expr>"keyword can't be an expression"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if></else></if>
<expr_stmt><expr><name>key</name> = <name><name>e</name>-&gt;<name>v</name>.<name>Name</name>.<name>id</name></name></expr>;</expr_stmt>
<if>if <condition>(<expr>!<call><name>forbidden_check</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>ch</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>PyBytes_AS_STRING</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<for>for (<init><expr><name>k</name> = 0</expr>;</init> <condition><expr><name>k</name> &lt; <name>nkeywords</name></expr>;</condition> <incr><expr><name>k</name>++</expr></incr>) <block>{
<expr_stmt><expr><name>tmp</name> = <call><name>PyString_AS_STRING</name><argument_list>(
<argument><expr>((<name>keyword_ty</name>)<call><name>asdl_seq_GET</name><argument_list>(<argument><expr><name>keywords</name></expr></argument>, <argument><expr><name>k</name></expr></argument>)</argument_list></call>)-&gt;<name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<call><name>strcmp</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>, <argument><expr><call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>ast_error</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>ch</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></argument>, <argument><expr>"keyword argument repeated"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
}</block></for>
<expr_stmt><expr><name>e</name> = <call><name>ast_for_expr</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>ch</name></expr></argument>, <argument><expr>2</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>e</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>kw</name> = <call><name>keyword</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><name>e</name></expr></argument>, <argument><expr><name><name>c</name>-&gt;<name>c_arena</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>kw</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><call><name>asdl_seq_SET</name><argument_list>(<argument><expr><name>keywords</name></expr></argument>, <argument><expr><name>nkeywords</name>++</expr></argument>, <argument><expr><name>kw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></else></if></else></if>
}</block></then> <else>else <if>if <condition>(<expr><call><name>TYPE</name><argument_list>(<argument><expr><name>ch</name></expr></argument>)</argument_list></call> == <name>STAR</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>vararg</name> = <call><name>ast_for_expr</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>i</name>+1</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>vararg</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>i</name>++</expr>;</expr_stmt>
}</block></then> <else>else <if>if <condition>(<expr><call><name>TYPE</name><argument_list>(<argument><expr><name>ch</name></expr></argument>)</argument_list></call> == <name>DOUBLESTAR</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>kwarg</name> = <call><name>ast_for_expr</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>i</name>+1</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>kwarg</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>i</name>++</expr>;</expr_stmt>
}</block></then></if></else></if></else></if>
}</block></for>
<return>return <expr><call><name>Call</name><argument_list>(<argument><expr><name>func</name></expr></argument>, <argument><expr><name>args</name></expr></argument>, <argument><expr><name>keywords</name></expr></argument>, <argument><expr><name>vararg</name></expr></argument>, <argument><expr><name>kwarg</name></expr></argument>, <argument><expr><name><name>func</name>-&gt;<name>lineno</name></name></expr></argument>,
<argument><expr><name><name>func</name>-&gt;<name>col_offset</name></name></expr></argument>, <argument><expr><name><name>c</name>-&gt;<name>c_arena</name></name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>expr_ty</name></type>
<name>ast_for_testlist</name><parameter_list>(<param><decl><type>struct <name>compiling</name> *</type><name>c</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>node</name>*</type> <name>n</name></decl></param>)</parameter_list> <block>{
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>NCH</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call> &gt; 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>TYPE</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call> == <name>testlist_gexp</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr><call><name>NCH</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call> &gt; 1</expr>)</condition><then>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>TYPE</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> != <name>gen_for</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
}</block></then> <else>else <block>{
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>TYPE</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call> == <name>testlist</name> ||
<call><name>TYPE</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call> == <name>testlist_safe</name> ||
<call><name>TYPE</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call> == <name>testlist1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></else></if>
<if>if <condition>(<expr><call><name>NCH</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call> == 1</expr>)</condition><then>
<return>return <expr><call><name>ast_for_expr</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></then>
<else>else <block>{
<decl_stmt><decl><type><name>asdl_seq</name> *</type><name>tmp</name> <init>= <expr><call><name>seq_for_testlist</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr>!<name>tmp</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<return>return <expr><call><name>Tuple</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>, <argument><expr><name>Load</name></expr></argument>, <argument><expr><call><name>LINENO</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>n</name>-&gt;<name>n_col_offset</name></name></expr></argument>, <argument><expr><name><name>c</name>-&gt;<name>c_arena</name></name></expr></argument>)</argument_list></call></expr>;</return>
}</block></else></if>
}</block></function>
<function><type><specifier>static</specifier> <name>expr_ty</name></type>
<name>ast_for_testlist_gexp</name><parameter_list>(<param><decl><type>struct <name>compiling</name> *</type><name>c</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>node</name>*</type> <name>n</name></decl></param>)</parameter_list> <block>{
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>TYPE</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call> == <name>testlist_gexp</name> || <call><name>TYPE</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call> == <name>argument</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>NCH</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call> &gt; 1 &amp;&amp; <call><name>TYPE</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> == <name>gen_for</name></expr>)</condition><then>
<return>return <expr><call><name>ast_for_genexp</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
<return>return <expr><call><name>ast_for_testlist</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>asdl_seq</name>*</type>
<name>ast_for_class_bases</name><parameter_list>(<param><decl><type>struct <name>compiling</name> *</type><name>c</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>node</name>*</type> <name>n</name></decl></param>)</parameter_list> <block>{
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>NCH</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call> &gt; 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>REQ</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>testlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>NCH</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call> == 1</expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>expr_ty</name></type> <name>base</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>asdl_seq</name> *</type><name>bases</name> <init>= <expr><call><name>asdl_seq_new</name><argument_list>(<argument><expr>1</expr></argument>, <argument><expr><name><name>c</name>-&gt;<name>c_arena</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr>!<name>bases</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>base</name> = <call><name>ast_for_expr</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>base</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><call><name>asdl_seq_SET</name><argument_list>(<argument><expr><name>bases</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>base</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>bases</name></expr>;</return>
}</block></then></if>
<return>return <expr><call><name>seq_for_testlist</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>stmt_ty</name></type>
<name>ast_for_expr_stmt</name><parameter_list>(<param><decl><type>struct <name>compiling</name> *</type><name>c</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>node</name> *</type><name>n</name></decl></param>)</parameter_list> <block>{
<expr_stmt><expr><call><name>REQ</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>expr_stmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>NCH</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call> == 1</expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>expr_ty</name></type> <name>e</name> <init>= <expr><call><name>ast_for_testlist</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr>!<name>e</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<return>return <expr><call><name>Expr</name><argument_list>(<argument><expr><name>e</name></expr></argument>, <argument><expr><call><name>LINENO</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>n</name>-&gt;<name>n_col_offset</name></name></expr></argument>, <argument><expr><name><name>c</name>-&gt;<name>c_arena</name></name></expr></argument>)</argument_list></call></expr>;</return>
}</block></then> <else>else <if>if <condition>(<expr><call><name>TYPE</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> == <name>augassign</name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>expr_ty</name></type> <name>expr1</name></decl>, <decl><type ref="prev"/><name>expr2</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>operator_ty</name></type> <name>newoperator</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>node</name> *</type><name>ch</name> <init>= <expr><call><name>CHILD</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>expr1</name> = <call><name>ast_for_testlist</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>ch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>expr1</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<switch>switch <condition>(<expr><name><name>expr1</name>-&gt;<name>kind</name></name></expr>)</condition> <block>{
<case>case <expr><name>GeneratorExp_kind</name></expr>:
<expr_stmt><expr><call><name>ast_error</name><argument_list>(<argument><expr><name>ch</name></expr></argument>, <argument><expr>"augmented assignment to generator "
"expression not possible"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
</case><case>case <expr><name>Yield_kind</name></expr>:
<expr_stmt><expr><call><name>ast_error</name><argument_list>(<argument><expr><name>ch</name></expr></argument>, <argument><expr>"augmented assignment to yield "
"expression not possible"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
</case><case>case <expr><name>Name_kind</name></expr>: <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>var_name</name> <init>= <expr><call><name>PyBytes_AS_STRING</name><argument_list>(<argument><expr><name><name>expr1</name>-&gt;<name>v</name>.<name>Name</name>.<name>id</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr>(<name><name>var_name</name><index>[<expr>0</expr>]</index></name> == 'N' || <name><name>var_name</name><index>[<expr>0</expr>]</index></name> == 'T' || <name><name>var_name</name><index>[<expr>0</expr>]</index></name> == 'F') &amp;&amp;
!<call><name>forbidden_check</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>ch</name></expr></argument>, <argument><expr><name>var_name</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<break>break;</break>
}</block>
</case><case>case <expr><name>Attribute_kind</name></expr>:
</case><case>case <expr><name>Subscript_kind</name></expr>:
<break>break;</break>
</case><default>default:
<expr_stmt><expr><call><name>ast_error</name><argument_list>(<argument><expr><name>ch</name></expr></argument>, <argument><expr>"illegal expression for augmented "
"assignment"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
</default>}</block></switch>
<if>if<condition>(<expr>!<call><name>set_context</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>expr1</name></expr></argument>, <argument><expr><name>Store</name></expr></argument>, <argument><expr><name>ch</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>ch</name> = <call><name>CHILD</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr>2</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>TYPE</name><argument_list>(<argument><expr><name>ch</name></expr></argument>)</argument_list></call> == <name>testlist</name></expr>)</condition><then>
<expr_stmt><expr><name>expr2</name> = <call><name>ast_for_testlist</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>ch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
<else>else
<expr_stmt><expr><name>expr2</name> = <call><name>ast_for_expr</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>ch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
<if>if <condition>(<expr>!<name>expr2</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>newoperator</name> = <call><name>ast_for_augassign</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>newoperator</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<return>return <expr><call><name>AugAssign</name><argument_list>(<argument><expr><name>expr1</name></expr></argument>, <argument><expr><name>newoperator</name></expr></argument>, <argument><expr><name>expr2</name></expr></argument>, <argument><expr><call><name>LINENO</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>n</name>-&gt;<name>n_col_offset</name></name></expr></argument>,
<argument><expr><name><name>c</name>-&gt;<name>c_arena</name></name></expr></argument>)</argument_list></call></expr>;</return>
}</block></then> <else>else <block>{
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>asdl_seq</name> *</type><name>targets</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>node</name> *</type><name>value</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>expr_ty</name></type> <name>expression</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>REQ</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>EQUAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>targets</name> = <call><name>asdl_seq_new</name><argument_list>(<argument><expr><call><name>NCH</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call> / 2</expr></argument>, <argument><expr><name><name>c</name>-&gt;<name>c_arena</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>targets</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <call><name>NCH</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call> - 2</expr>;</condition> <incr><expr><name>i</name> += 2</expr></incr>) <block>{
<decl_stmt><decl><type><name>expr_ty</name></type> <name>e</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>node</name> *</type><name>ch</name> <init>= <expr><call><name>CHILD</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><call><name>TYPE</name><argument_list>(<argument><expr><name>ch</name></expr></argument>)</argument_list></call> == <name>yield_expr</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>ast_error</name><argument_list>(<argument><expr><name>ch</name></expr></argument>, <argument><expr>"assignment to yield expression not possible"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>e</name> = <call><name>ast_for_testlist</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>ch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>e</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<if>if <condition>(<expr>!<call><name>set_context</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>e</name></expr></argument>, <argument><expr><name>Store</name></expr></argument>, <argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><call><name>asdl_seq_SET</name><argument_list>(<argument><expr><name>targets</name></expr></argument>, <argument><expr><name>i</name> / 2</expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></for>
<expr_stmt><expr><name>value</name> = <call><name>CHILD</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><call><name>NCH</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call> - 1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>TYPE</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call> == <name>testlist</name></expr>)</condition><then>
<expr_stmt><expr><name>expression</name> = <call><name>ast_for_testlist</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
<else>else
<expr_stmt><expr><name>expression</name> = <call><name>ast_for_expr</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
<if>if <condition>(<expr>!<name>expression</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<return>return <expr><call><name>Assign</name><argument_list>(<argument><expr><name>targets</name></expr></argument>, <argument><expr><name>expression</name></expr></argument>, <argument><expr><call><name>LINENO</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>n</name>-&gt;<name>n_col_offset</name></name></expr></argument>,
<argument><expr><name><name>c</name>-&gt;<name>c_arena</name></name></expr></argument>)</argument_list></call></expr>;</return>
}</block></else></if></else></if>
}</block></function>
<function><type><specifier>static</specifier> <name>stmt_ty</name></type>
<name>ast_for_print_stmt</name><parameter_list>(<param><decl><type>struct <name>compiling</name> *</type><name>c</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>node</name> *</type><name>n</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>expr_ty</name></type> <name>dest</name> <init>= <expr><name>NULL</name></expr></init>, <name>expression</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>asdl_seq</name> *</type><name>seq</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>nl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>, <decl><type ref="prev"/><name>start</name> <init>= <expr>1</expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>REQ</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>print_stmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>NCH</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call> &gt;= 2 &amp;&amp; <call><name>TYPE</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> == <name>RIGHTSHIFT</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>dest</name> = <call><name>ast_for_expr</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr>2</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>dest</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>start</name> = 4</expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><name>seq</name> = <call><name>asdl_seq_new</name><argument_list>(<argument><expr>(<call><name>NCH</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call> + 1 - <name>start</name>) / 2</expr></argument>, <argument><expr><name><name>c</name>-&gt;<name>c_arena</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>seq</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<for>for (<init><expr><name>i</name> = <name>start</name></expr>, <expr><name>j</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <call><name>NCH</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name> += 2</expr>, <expr>++<name>j</name></expr></incr>) <block>{
<expr_stmt><expr><name>expression</name> = <call><name>ast_for_expr</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>expression</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><call><name>asdl_seq_SET</name><argument_list>(<argument><expr><name>seq</name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><name>expression</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></for>
<expr_stmt><expr><name>nl</name> = (<call><name>TYPE</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><call><name>NCH</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call> - 1</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> == <name>COMMA</name>) ? <name>false</name> : <name>true</name></expr>;</expr_stmt>
<return>return <expr><call><name>Print</name><argument_list>(<argument><expr><name>dest</name></expr></argument>, <argument><expr><name>seq</name></expr></argument>, <argument><expr><name>nl</name></expr></argument>, <argument><expr><call><name>LINENO</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>n</name>-&gt;<name>n_col_offset</name></name></expr></argument>, <argument><expr><name><name>c</name>-&gt;<name>c_arena</name></name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>asdl_seq</name> *</type>
<name>ast_for_exprlist</name><parameter_list>(<param><decl><type>struct <name>compiling</name> *</type><name>c</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>node</name> *</type><name>n</name></decl></param>, <param><decl><type><name>expr_context_ty</name></type> <name>context</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>asdl_seq</name> *</type><name>seq</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>expr_ty</name></type> <name>e</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>REQ</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>exprlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>seq</name> = <call><name>asdl_seq_new</name><argument_list>(<argument><expr>(<call><name>NCH</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call> + 1) / 2</expr></argument>, <argument><expr><name><name>c</name>-&gt;<name>c_arena</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>seq</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <call><name>NCH</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name> += 2</expr></incr>) <block>{
<expr_stmt><expr><name>e</name> = <call><name>ast_for_expr</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>e</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><call><name>asdl_seq_SET</name><argument_list>(<argument><expr><name>seq</name></expr></argument>, <argument><expr><name>i</name> / 2</expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>context</name> &amp;&amp; !<call><name>set_context</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>e</name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
}</block></for>
<return>return <expr><name>seq</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>stmt_ty</name></type>
<name>ast_for_del_stmt</name><parameter_list>(<param><decl><type>struct <name>compiling</name> *</type><name>c</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>node</name> *</type><name>n</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>asdl_seq</name> *</type><name>expr_list</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>REQ</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>del_stmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>expr_list</name> = <call><name>ast_for_exprlist</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>Del</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>expr_list</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<return>return <expr><call><name>Delete</name><argument_list>(<argument><expr><name>expr_list</name></expr></argument>, <argument><expr><call><name>LINENO</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>n</name>-&gt;<name>n_col_offset</name></name></expr></argument>, <argument><expr><name><name>c</name>-&gt;<name>c_arena</name></name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>stmt_ty</name></type>
<name>ast_for_flow_stmt</name><parameter_list>(<param><decl><type>struct <name>compiling</name> *</type><name>c</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>node</name> *</type><name>n</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>node</name> *</type><name>ch</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>REQ</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>flow_stmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ch</name> = <call><name>CHILD</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<switch>switch <condition>(<expr><call><name>TYPE</name><argument_list>(<argument><expr><name>ch</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{
<case>case <expr><name>break_stmt</name></expr>:
<return>return <expr><call><name>Break</name><argument_list>(<argument><expr><call><name>LINENO</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>n</name>-&gt;<name>n_col_offset</name></name></expr></argument>, <argument><expr><name><name>c</name>-&gt;<name>c_arena</name></name></expr></argument>)</argument_list></call></expr>;</return>
</case><case>case <expr><name>continue_stmt</name></expr>:
<return>return <expr><call><name>Continue</name><argument_list>(<argument><expr><call><name>LINENO</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>n</name>-&gt;<name>n_col_offset</name></name></expr></argument>, <argument><expr><name><name>c</name>-&gt;<name>c_arena</name></name></expr></argument>)</argument_list></call></expr>;</return>
</case><case>case <expr><name>yield_stmt</name></expr>: <block>{
<decl_stmt><decl><type><name>expr_ty</name></type> <name>exp</name> <init>= <expr><call><name>ast_for_expr</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>ch</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr>!<name>exp</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<return>return <expr><call><name>Expr</name><argument_list>(<argument><expr><name>exp</name></expr></argument>, <argument><expr><call><name>LINENO</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>n</name>-&gt;<name>n_col_offset</name></name></expr></argument>, <argument><expr><name><name>c</name>-&gt;<name>c_arena</name></name></expr></argument>)</argument_list></call></expr>;</return>
}</block>
</case><case>case <expr><name>return_stmt</name></expr>:
<if>if <condition>(<expr><call><name>NCH</name><argument_list>(<argument><expr><name>ch</name></expr></argument>)</argument_list></call> == 1</expr>)</condition><then>
<return>return <expr><call><name>Return</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><call><name>LINENO</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>n</name>-&gt;<name>n_col_offset</name></name></expr></argument>, <argument><expr><name><name>c</name>-&gt;<name>c_arena</name></name></expr></argument>)</argument_list></call></expr>;</return></then>
<else>else <block>{
<decl_stmt><decl><type><name>expr_ty</name></type> <name>expression</name> <init>= <expr><call><name>ast_for_testlist</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>ch</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr>!<name>expression</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<return>return <expr><call><name>Return</name><argument_list>(<argument><expr><name>expression</name></expr></argument>, <argument><expr><call><name>LINENO</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>n</name>-&gt;<name>n_col_offset</name></name></expr></argument>,
<argument><expr><name><name>c</name>-&gt;<name>c_arena</name></name></expr></argument>)</argument_list></call></expr>;</return>
}</block></else></if>
</case><case>case <expr><name>raise_stmt</name></expr>:
<if>if <condition>(<expr><call><name>NCH</name><argument_list>(<argument><expr><name>ch</name></expr></argument>)</argument_list></call> == 1</expr>)</condition><then>
<return>return <expr><call><name>Raise</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><call><name>LINENO</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>n</name>-&gt;<name>n_col_offset</name></name></expr></argument>,
<argument><expr><name><name>c</name>-&gt;<name>c_arena</name></name></expr></argument>)</argument_list></call></expr>;</return></then>
<else>else <if>if <condition>(<expr><call><name>NCH</name><argument_list>(<argument><expr><name>ch</name></expr></argument>)</argument_list></call> == 2</expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>expr_ty</name></type> <name>expression</name> <init>= <expr><call><name>ast_for_expr</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>ch</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr>!<name>expression</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<return>return <expr><call><name>Raise</name><argument_list>(<argument><expr><name>expression</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><call><name>LINENO</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name><name>n</name>-&gt;<name>n_col_offset</name></name></expr></argument>, <argument><expr><name><name>c</name>-&gt;<name>c_arena</name></name></expr></argument>)</argument_list></call></expr>;</return>
}</block></then> <else>else <if>if <condition>(<expr><call><name>NCH</name><argument_list>(<argument><expr><name>ch</name></expr></argument>)</argument_list></call> == 4</expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>expr_ty</name></type> <name>expr1</name></decl>, <decl><type ref="prev"/><name>expr2</name></decl>;</decl_stmt>
<expr_stmt><expr><name>expr1</name> = <call><name>ast_for_expr</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>ch</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>expr1</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>expr2</name> = <call><name>ast_for_expr</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>ch</name></expr></argument>, <argument><expr>3</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>expr2</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<return>return <expr><call><name>Raise</name><argument_list>(<argument><expr><name>expr1</name></expr></argument>, <argument><expr><name>expr2</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><call><name>LINENO</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>n</name>-&gt;<name>n_col_offset</name></name></expr></argument>,
<argument><expr><name><name>c</name>-&gt;<name>c_arena</name></name></expr></argument>)</argument_list></call></expr>;</return>
}</block></then> <else>else <if>if <condition>(<expr><call><name>NCH</name><argument_list>(<argument><expr><name>ch</name></expr></argument>)</argument_list></call> == 6</expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>expr_ty</name></type> <name>expr1</name></decl>, <decl><type ref="prev"/><name>expr2</name></decl>, <decl><type ref="prev"/><name>expr3</name></decl>;</decl_stmt>
<expr_stmt><expr><name>expr1</name> = <call><name>ast_for_expr</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>ch</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>expr1</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>expr2</name> = <call><name>ast_for_expr</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>ch</name></expr></argument>, <argument><expr>3</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>expr2</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>expr3</name> = <call><name>ast_for_expr</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>ch</name></expr></argument>, <argument><expr>5</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>expr3</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<return>return <expr><call><name>Raise</name><argument_list>(<argument><expr><name>expr1</name></expr></argument>, <argument><expr><name>expr2</name></expr></argument>, <argument><expr><name>expr3</name></expr></argument>, <argument><expr><call><name>LINENO</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>n</name>-&gt;<name>n_col_offset</name></name></expr></argument>,
<argument><expr><name><name>c</name>-&gt;<name>c_arena</name></name></expr></argument>)</argument_list></call></expr>;</return>
}</block></then></if></else></if></else></if></else></if>
</case><default>default:
<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_SystemError</name></expr></argument>,
<argument><expr>"unexpected flow_stmt: %d"</expr></argument>, <argument><expr><call><name>TYPE</name><argument_list>(<argument><expr><name>ch</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
</default>}</block></switch>
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_SystemError</name></expr></argument>, <argument><expr>"unhandled flow statement"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>alias_ty</name></type>
<name>alias_for_import_name</name><parameter_list>(<param><decl><type>struct <name>compiling</name> *</type><name>c</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>node</name> *</type><name>n</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>str</name></decl>, *<decl><type ref="prev"/><name>name</name></decl>;</decl_stmt>
<label><name>loop</name>:</label>
<switch>switch <condition>(<expr><call><name>TYPE</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{
<case>case <expr><name>import_as_name</name></expr>:
<expr_stmt><expr><name>str</name> = <name>NULL</name></expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>NCH</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call> == 3</expr>)</condition><then> <block>{
<expr_stmt><expr><name>str</name> = <call><name>NEW_IDENTIFIER</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr>2</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>str</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
}</block></then></if>
<expr_stmt><expr><name>name</name> = <call><name>NEW_IDENTIFIER</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>name</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<return>return <expr><call><name>alias</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>str</name></expr></argument>, <argument><expr><name><name>c</name>-&gt;<name>c_arena</name></name></expr></argument>)</argument_list></call></expr>;</return>
</case><case>case <expr><name>dotted_as_name</name></expr>:
<if>if <condition>(<expr><call><name>NCH</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call> == 1</expr>)</condition><then> <block>{
<expr_stmt><expr><name>n</name> = <call><name>CHILD</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>loop</name>;</goto>
}</block></then> <else>else <block>{
<decl_stmt><decl><type><name>alias_ty</name></type> <name>a</name> <init>= <expr><call><name>alias_for_import_name</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr>!<name>a</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr>!<name><name>a</name>-&gt;<name>asname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>a</name>-&gt;<name>asname</name></name> = <call><name>NEW_IDENTIFIER</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr>2</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name><name>a</name>-&gt;<name>asname</name></name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<return>return <expr><name>a</name></expr>;</return>
}</block></else></if>
<break>break;</break>
</case><case>case <expr><name>dotted_name</name></expr>:
<if>if <condition>(<expr><call><name>NCH</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call> == 1</expr>)</condition><then> <block>{
<expr_stmt><expr><name>name</name> = <call><name>NEW_IDENTIFIER</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>name</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<return>return <expr><call><name>alias</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name><name>c</name>-&gt;<name>c_arena</name></name></expr></argument>)</argument_list></call></expr>;</return>
}</block></then> <else>else <block>{
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>len</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>s</name></decl>;</decl_stmt>
<expr_stmt><expr><name>len</name> = 0</expr>;</expr_stmt>
<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <call><name>NCH</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name> += 2</expr></incr>)
<expr_stmt><expr><name>len</name> += <call><name>strlen</name><argument_list>(<argument><expr><call><name>STR</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> + 1</expr>;</expr_stmt></for>
<expr_stmt><expr><name>len</name>--</expr>;</expr_stmt>
<expr_stmt><expr><name>str</name> = <call><name>PyString_FromStringAndSize</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>str</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>s</name> = <call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>s</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <call><name>NCH</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name> += 2</expr></incr>) <block>{
<decl_stmt><decl><type><name>char</name> *</type><name>sch</name> <init>= <expr><call><name>STR</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><call><name>STR</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>s</name> += <call><name>strlen</name><argument_list>(<argument><expr><name>sch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr>*<name>s</name>++ = '.'</expr>;</expr_stmt>
}</block></for>
<expr_stmt><expr>--<name>s</name></expr>;</expr_stmt>
<expr_stmt><expr>*<name>s</name> = '\0'</expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyString_InternInPlace</name><argument_list>(<argument><expr>&amp;<name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyArena_AddPyObject</name><argument_list>(<argument><expr><name><name>c</name>-&gt;<name>c_arena</name></name></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>alias</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name><name>c</name>-&gt;<name>c_arena</name></name></expr></argument>)</argument_list></call></expr>;</return>
}</block></else></if>
<break>break;</break>
</case><case>case <expr><name>STAR</name></expr>:
<expr_stmt><expr><name>str</name> = <call><name>PyString_InternFromString</name><argument_list>(<argument><expr>"*"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyArena_AddPyObject</name><argument_list>(<argument><expr><name><name>c</name>-&gt;<name>c_arena</name></name></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>alias</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name><name>c</name>-&gt;<name>c_arena</name></name></expr></argument>)</argument_list></call></expr>;</return>
</case><default>default:
<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_SystemError</name></expr></argument>,
<argument><expr>"unexpected import name: %d"</expr></argument>, <argument><expr><call><name>TYPE</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
</default>}</block></switch>
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_SystemError</name></expr></argument>, <argument><expr>"unhandled import name condition"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>stmt_ty</name></type>
<name>ast_for_import_stmt</name><parameter_list>(<param><decl><type>struct <name>compiling</name> *</type><name>c</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>node</name> *</type><name>n</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>lineno</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>col_offset</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>asdl_seq</name> *</type><name>aliases</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>REQ</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>import_stmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>lineno</name> = <call><name>LINENO</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>col_offset</name> = <name><name>n</name>-&gt;<name>n_col_offset</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>n</name> = <call><name>CHILD</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>TYPE</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call> == <name>import_name</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>n</name> = <call><name>CHILD</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>REQ</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>dotted_as_names</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>aliases</name> = <call><name>asdl_seq_new</name><argument_list>(<argument><expr>(<call><name>NCH</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call> + 1) / 2</expr></argument>, <argument><expr><name><name>c</name>-&gt;<name>c_arena</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>aliases</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <call><name>NCH</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name> += 2</expr></incr>) <block>{
<decl_stmt><decl><type><name>alias_ty</name></type> <name>import_alias</name> <init>= <expr><call><name>alias_for_import_name</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr>!<name>import_alias</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><call><name>asdl_seq_SET</name><argument_list>(<argument><expr><name>aliases</name></expr></argument>, <argument><expr><name>i</name> / 2</expr></argument>, <argument><expr><name>import_alias</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></for>
<return>return <expr><call><name>Import</name><argument_list>(<argument><expr><name>aliases</name></expr></argument>, <argument><expr><name>lineno</name></expr></argument>, <argument><expr><name>col_offset</name></expr></argument>, <argument><expr><name><name>c</name>-&gt;<name>c_arena</name></name></expr></argument>)</argument_list></call></expr>;</return>
}</block></then> <else>else <if>if <condition>(<expr><call><name>TYPE</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call> == <name>import_from</name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>n_children</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>idx</name></decl>, <decl><type ref="prev"/><name>ndots</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>alias_ty</name></type> <name>mod</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>identifier</name></type> <name>modname</name></decl>;</decl_stmt>
<for>for (<init><expr><name>idx</name> = 1</expr>;</init> <condition><expr><name>idx</name> &lt; <call><name>NCH</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>idx</name>++</expr></incr>) <block>{
<if>if <condition>(<expr><call><name>TYPE</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>idx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> == <name>dotted_name</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>mod</name> = <call><name>alias_for_import_name</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>idx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>idx</name>++</expr>;</expr_stmt>
<break>break;</break>
}</block></then> <else>else <if>if <condition>(<expr><call><name>TYPE</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>idx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> != <name>DOT</name></expr>)</condition><then> <block>{
<break>break;</break>
}</block></then></if></else></if>
<expr_stmt><expr><name>ndots</name>++</expr>;</expr_stmt>
}</block></for>
<expr_stmt><expr><name>idx</name>++</expr>;</expr_stmt>
<switch>switch <condition>(<expr><call><name>TYPE</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>idx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{
<case>case <expr><name>STAR</name></expr>:
<expr_stmt><expr><name>n</name> = <call><name>CHILD</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>idx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>n_children</name> = 1</expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr><name>LPAR</name></expr>:
<expr_stmt><expr><name>n</name> = <call><name>CHILD</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>idx</name> + 1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>n_children</name> = <call><name>NCH</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr><name>import_as_names</name></expr>:
<expr_stmt><expr><name>n</name> = <call><name>CHILD</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>idx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>n_children</name> = <call><name>NCH</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>n_children</name> % 2 == 0</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>ast_error</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr>"trailing comma not allowed without"
" surrounding parentheses"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<break>break;</break>
</case><default>default:
<expr_stmt><expr><call><name>ast_error</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr>"Unexpected node-type in from-import"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
</default>}</block></switch>
<expr_stmt><expr><name>aliases</name> = <call><name>asdl_seq_new</name><argument_list>(<argument><expr>(<name>n_children</name> + 1) / 2</expr></argument>, <argument><expr><name><name>c</name>-&gt;<name>c_arena</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>aliases</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<if>if <condition>(<expr><call><name>TYPE</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call> == <name>STAR</name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>alias_ty</name></type> <name>import_alias</name> <init>= <expr><call><name>alias_for_import_name</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr>!<name>import_alias</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><call><name>asdl_seq_SET</name><argument_list>(<argument><expr><name>aliases</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>import_alias</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <call><name>NCH</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name> += 2</expr></incr>) <block>{
<decl_stmt><decl><type><name>alias_ty</name></type> <name>import_alias</name> <init>= <expr><call><name>alias_for_import_name</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr>!<name>import_alias</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><call><name>asdl_seq_SET</name><argument_list>(<argument><expr><name>aliases</name></expr></argument>, <argument><expr><name>i</name> / 2</expr></argument>, <argument><expr><name>import_alias</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></for>
}</block></else></if>
<if>if <condition>(<expr><name>mod</name> != <name>NULL</name></expr>)</condition><then>
<expr_stmt><expr><name>modname</name> = <name><name>mod</name>-&gt;<name>name</name></name></expr>;</expr_stmt></then>
<else>else
<expr_stmt><expr><name>modname</name> = <call><name>new_identifier</name><argument_list>(<argument><expr>""</expr></argument>, <argument><expr><name><name>c</name>-&gt;<name>c_arena</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
<return>return <expr><call><name>ImportFrom</name><argument_list>(<argument><expr><name>modname</name></expr></argument>, <argument><expr><name>aliases</name></expr></argument>, <argument><expr><name>ndots</name></expr></argument>, <argument><expr><name>lineno</name></expr></argument>, <argument><expr><name>col_offset</name></expr></argument>,
<argument><expr><name><name>c</name>-&gt;<name>c_arena</name></name></expr></argument>)</argument_list></call></expr>;</return>
}</block></then></if></else></if>
<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_SystemError</name></expr></argument>,
<argument><expr>"unknown import statement: starts with command '%s'"</expr></argument>,
<argument><expr><call><name>STR</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>stmt_ty</name></type>
<name>ast_for_global_stmt</name><parameter_list>(<param><decl><type>struct <name>compiling</name> *</type><name>c</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>node</name> *</type><name>n</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>identifier</name></type> <name>name</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>asdl_seq</name> *</type><name>s</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>REQ</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>global_stmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>s</name> = <call><name>asdl_seq_new</name><argument_list>(<argument><expr><call><name>NCH</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call> / 2</expr></argument>, <argument><expr><name><name>c</name>-&gt;<name>c_arena</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>s</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<for>for (<init><expr><name>i</name> = 1</expr>;</init> <condition><expr><name>i</name> &lt; <call><name>NCH</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name> += 2</expr></incr>) <block>{
<expr_stmt><expr><name>name</name> = <call><name>NEW_IDENTIFIER</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>name</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><call><name>asdl_seq_SET</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>i</name> / 2</expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></for>
<return>return <expr><call><name>Global</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><call><name>LINENO</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>n</name>-&gt;<name>n_col_offset</name></name></expr></argument>, <argument><expr><name><name>c</name>-&gt;<name>c_arena</name></name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>stmt_ty</name></type>
<name>ast_for_exec_stmt</name><parameter_list>(<param><decl><type>struct <name>compiling</name> *</type><name>c</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>node</name> *</type><name>n</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>expr_ty</name></type> <name>expr1</name></decl>, <decl><type ref="prev"/><name>globals</name> <init>= <expr><name>NULL</name></expr></init>, <name>locals</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>n_children</name> <init>= <expr><call><name>NCH</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>n_children</name> != 2 &amp;&amp; <name>n_children</name> != 4 &amp;&amp; <name>n_children</name> != 6</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_SystemError</name></expr></argument>,
<argument><expr>"poorly formed 'exec' statement: %d parts to statement"</expr></argument>,
<argument><expr><name>n_children</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><call><name>REQ</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>exec_stmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>expr1</name> = <call><name>ast_for_expr</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>expr1</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<if>if <condition>(<expr><name>n_children</name> &gt;= 4</expr>)</condition><then> <block>{
<expr_stmt><expr><name>globals</name> = <call><name>ast_for_expr</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr>3</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>globals</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
}</block></then></if>
<if>if <condition>(<expr><name>n_children</name> == 6</expr>)</condition><then> <block>{
<expr_stmt><expr><name>locals</name> = <call><name>ast_for_expr</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr>5</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>locals</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
}</block></then></if>
<return>return <expr><call><name>Exec</name><argument_list>(<argument><expr><name>expr1</name></expr></argument>, <argument><expr><name>globals</name></expr></argument>, <argument><expr><name>locals</name></expr></argument>, <argument><expr><call><name>LINENO</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>n</name>-&gt;<name>n_col_offset</name></name></expr></argument>,
<argument><expr><name><name>c</name>-&gt;<name>c_arena</name></name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>stmt_ty</name></type>
<name>ast_for_assert_stmt</name><parameter_list>(<param><decl><type>struct <name>compiling</name> *</type><name>c</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>node</name> *</type><name>n</name></decl></param>)</parameter_list> <block>{
<expr_stmt><expr><call><name>REQ</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>assert_stmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>NCH</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call> == 2</expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>expr_ty</name></type> <name>expression</name> <init>= <expr><call><name>ast_for_expr</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr>!<name>expression</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<return>return <expr><call><name>Assert</name><argument_list>(<argument><expr><name>expression</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><call><name>LINENO</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>n</name>-&gt;<name>n_col_offset</name></name></expr></argument>,
<argument><expr><name><name>c</name>-&gt;<name>c_arena</name></name></expr></argument>)</argument_list></call></expr>;</return>
}</block></then> <else>else <if>if <condition>(<expr><call><name>NCH</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call> == 4</expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>expr_ty</name></type> <name>expr1</name></decl>, <decl><type ref="prev"/><name>expr2</name></decl>;</decl_stmt>
<expr_stmt><expr><name>expr1</name> = <call><name>ast_for_expr</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>expr1</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>expr2</name> = <call><name>ast_for_expr</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr>3</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>expr2</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<return>return <expr><call><name>Assert</name><argument_list>(<argument><expr><name>expr1</name></expr></argument>, <argument><expr><name>expr2</name></expr></argument>, <argument><expr><call><name>LINENO</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>n</name>-&gt;<name>n_col_offset</name></name></expr></argument>, <argument><expr><name><name>c</name>-&gt;<name>c_arena</name></name></expr></argument>)</argument_list></call></expr>;</return>
}</block></then></if></else></if>
<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_SystemError</name></expr></argument>,
<argument><expr>"improper number of parts to 'assert' statement: %d"</expr></argument>,
<argument><expr><call><name>NCH</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>asdl_seq</name> *</type>
<name>ast_for_suite</name><parameter_list>(<param><decl><type>struct <name>compiling</name> *</type><name>c</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>node</name> *</type><name>n</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>asdl_seq</name> *</type><name>seq</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>stmt_ty</name></type> <name>s</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>total</name></decl>, <decl><type ref="prev"/><name>num</name></decl>, <decl><type ref="prev"/><name>end</name></decl>, <decl><type ref="prev"/><name>pos</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>node</name> *</type><name>ch</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>REQ</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>suite</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>total</name> = <call><name>num_stmts</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>seq</name> = <call><name>asdl_seq_new</name><argument_list>(<argument><expr><name>total</name></expr></argument>, <argument><expr><name><name>c</name>-&gt;<name>c_arena</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>seq</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<if>if <condition>(<expr><call><name>TYPE</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> == <name>simple_stmt</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>n</name> = <call><name>CHILD</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>end</name> = <call><name>NCH</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call> - 1</expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>TYPE</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>end</name> - 1</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> == <name>SEMI</name></expr>)</condition><then>
<expr_stmt><expr><name>end</name>--</expr>;</expr_stmt></then></if>
<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>end</name></expr>;</condition> <incr><expr><name>i</name> += 2</expr></incr>) <block>{
<expr_stmt><expr><name>ch</name> = <call><name>CHILD</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>s</name> = <call><name>ast_for_stmt</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>ch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>s</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><call><name>asdl_seq_SET</name><argument_list>(<argument><expr><name>seq</name></expr></argument>, <argument><expr><name>pos</name>++</expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></for>
}</block></then> <else>else <block>{
<for>for (<init><expr><name>i</name> = 2</expr>;</init> <condition><expr><name>i</name> &lt; (<call><name>NCH</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call> - 1)</expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
<expr_stmt><expr><name>ch</name> = <call><name>CHILD</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>REQ</name><argument_list>(<argument><expr><name>ch</name></expr></argument>, <argument><expr><name>stmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>num</name> = <call><name>num_stmts</name><argument_list>(<argument><expr><name>ch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>num</name> == 1</expr>)</condition><then> <block>{
<expr_stmt><expr><name>s</name> = <call><name>ast_for_stmt</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>ch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>s</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><call><name>asdl_seq_SET</name><argument_list>(<argument><expr><name>seq</name></expr></argument>, <argument><expr><name>pos</name>++</expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>;</decl_stmt>
<expr_stmt><expr><name>ch</name> = <call><name>CHILD</name><argument_list>(<argument><expr><name>ch</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>REQ</name><argument_list>(<argument><expr><name>ch</name></expr></argument>, <argument><expr><name>simple_stmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for (<init><expr><name>j</name> = 0</expr>;</init> <condition><expr><name>j</name> &lt; <call><name>NCH</name><argument_list>(<argument><expr><name>ch</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>j</name> += 2</expr></incr>) <block>{
<if>if <condition>(<expr><call><name>NCH</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>ch</name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> == 0</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr>(<name>j</name> + 1) == <call><name>NCH</name><argument_list>(<argument><expr><name>ch</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
}</block></then></if>
<expr_stmt><expr><name>s</name> = <call><name>ast_for_stmt</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>ch</name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>s</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><call><name>asdl_seq_SET</name><argument_list>(<argument><expr><name>seq</name></expr></argument>, <argument><expr><name>pos</name>++</expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></for>
}</block></else></if>
}</block></for>
}</block></else></if>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>pos</name> == <name><name>seq</name>-&gt;<name>size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>seq</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>stmt_ty</name></type>
<name>ast_for_if_stmt</name><parameter_list>(<param><decl><type>struct <name>compiling</name> *</type><name>c</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>node</name> *</type><name>n</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>char</name> *</type><name>s</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>REQ</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>if_stmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>NCH</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call> == 4</expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>expr_ty</name></type> <name>expression</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>asdl_seq</name> *</type><name>suite_seq</name></decl>;</decl_stmt>
<expr_stmt><expr><name>expression</name> = <call><name>ast_for_expr</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>expression</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>suite_seq</name> = <call><name>ast_for_suite</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr>3</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>suite_seq</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<return>return <expr><call><name>If</name><argument_list>(<argument><expr><name>expression</name></expr></argument>, <argument><expr><name>suite_seq</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><call><name>LINENO</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>n</name>-&gt;<name>n_col_offset</name></name></expr></argument>,
<argument><expr><name><name>c</name>-&gt;<name>c_arena</name></name></expr></argument>)</argument_list></call></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>s</name> = <call><name>STR</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr>4</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>s</name><index>[<expr>2</expr>]</index></name> == 's'</expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>expr_ty</name></type> <name>expression</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>asdl_seq</name> *</type><name>seq1</name></decl>, *<decl><type ref="prev"/><name>seq2</name></decl>;</decl_stmt>
<expr_stmt><expr><name>expression</name> = <call><name>ast_for_expr</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>expression</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>seq1</name> = <call><name>ast_for_suite</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr>3</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>seq1</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>seq2</name> = <call><name>ast_for_suite</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr>6</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>seq2</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<return>return <expr><call><name>If</name><argument_list>(<argument><expr><name>expression</name></expr></argument>, <argument><expr><name>seq1</name></expr></argument>, <argument><expr><name>seq2</name></expr></argument>, <argument><expr><call><name>LINENO</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>n</name>-&gt;<name>n_col_offset</name></name></expr></argument>,
<argument><expr><name><name>c</name>-&gt;<name>c_arena</name></name></expr></argument>)</argument_list></call></expr>;</return>
}</block></then> <else>else <if>if <condition>(<expr><name><name>s</name><index>[<expr>2</expr>]</index></name> == 'i'</expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>n_elif</name></decl>, <decl><type ref="prev"/><name>has_else</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>expr_ty</name></type> <name>expression</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>asdl_seq</name> *</type><name>suite_seq</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>asdl_seq</name> *</type><name>orelse</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>n_elif</name> = <call><name>NCH</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call> - 4</expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>TYPE</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr>(<name>n_elif</name> + 1)</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> == <name>NAME</name>
&amp;&amp; <call><name>STR</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr>(<name>n_elif</name> + 1)</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><index>[<expr>2</expr>]</index> == 's'</expr>)</condition><then> <block>{
<expr_stmt><expr><name>has_else</name> = 1</expr>;</expr_stmt>
<expr_stmt><expr><name>n_elif</name> -= 3</expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><name>n_elif</name> /= 4</expr>;</expr_stmt>
<if>if <condition>(<expr><name>has_else</name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>asdl_seq</name> *</type><name>suite_seq2</name></decl>;</decl_stmt>
<expr_stmt><expr><name>orelse</name> = <call><name>asdl_seq_new</name><argument_list>(<argument><expr>1</expr></argument>, <argument><expr><name><name>c</name>-&gt;<name>c_arena</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>orelse</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>expression</name> = <call><name>ast_for_expr</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><call><name>NCH</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call> - 6</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>expression</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>suite_seq</name> = <call><name>ast_for_suite</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><call><name>NCH</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call> - 4</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>suite_seq</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>suite_seq2</name> = <call><name>ast_for_suite</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><call><name>NCH</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call> - 1</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>suite_seq2</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><call><name>asdl_seq_SET</name><argument_list>(<argument><expr><name>orelse</name></expr></argument>, <argument><expr>0</expr></argument>,
<argument><expr><call><name>If</name><argument_list>(<argument><expr><name>expression</name></expr></argument>, <argument><expr><name>suite_seq</name></expr></argument>, <argument><expr><name>suite_seq2</name></expr></argument>,
<argument><expr><call><name>LINENO</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><call><name>NCH</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call> - 6</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><call><name>NCH</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call> - 6</expr></argument>)</argument_list></call>-&gt;<name>n_col_offset</name></expr></argument>,
<argument><expr><name><name>c</name>-&gt;<name>c_arena</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>n_elif</name>--</expr>;</expr_stmt>
}</block></then></if>
<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>n_elif</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
<decl_stmt><decl><type><name>int</name></type> <name>off</name> <init>= <expr>5 + (<name>n_elif</name> - <name>i</name> - 1) * 4</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>asdl_seq</name> *</type><name>newobj</name> <init>= <expr><call><name>asdl_seq_new</name><argument_list>(<argument><expr>1</expr></argument>, <argument><expr><name><name>c</name>-&gt;<name>c_arena</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr>!<name>newobj</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>expression</name> = <call><name>ast_for_expr</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>off</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>expression</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>suite_seq</name> = <call><name>ast_for_suite</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>off</name> + 2</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>suite_seq</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><call><name>asdl_seq_SET</name><argument_list>(<argument><expr><name>newobj</name></expr></argument>, <argument><expr>0</expr></argument>,
<argument><expr><call><name>If</name><argument_list>(<argument><expr><name>expression</name></expr></argument>, <argument><expr><name>suite_seq</name></expr></argument>, <argument><expr><name>orelse</name></expr></argument>,
<argument><expr><call><name>LINENO</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>off</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>off</name></expr></argument>)</argument_list></call>-&gt;<name>n_col_offset</name></expr></argument>, <argument><expr><name><name>c</name>-&gt;<name>c_arena</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>orelse</name> = <name>newobj</name></expr>;</expr_stmt>
}</block></for>
<expr_stmt><expr><name>expression</name> = <call><name>ast_for_expr</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>expression</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>suite_seq</name> = <call><name>ast_for_suite</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr>3</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>suite_seq</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<return>return <expr><call><name>If</name><argument_list>(<argument><expr><name>expression</name></expr></argument>, <argument><expr><name>suite_seq</name></expr></argument>, <argument><expr><name>orelse</name></expr></argument>,
<argument><expr><call><name>LINENO</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>n</name>-&gt;<name>n_col_offset</name></name></expr></argument>, <argument><expr><name><name>c</name>-&gt;<name>c_arena</name></name></expr></argument>)</argument_list></call></expr>;</return>
}</block></then></if></else></if>
<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_SystemError</name></expr></argument>,
<argument><expr>"unexpected token in 'if' statement: %s"</expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>stmt_ty</name></type>
<name>ast_for_while_stmt</name><parameter_list>(<param><decl><type>struct <name>compiling</name> *</type><name>c</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>node</name> *</type><name>n</name></decl></param>)</parameter_list> <block>{
<expr_stmt><expr><call><name>REQ</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>while_stmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>NCH</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call> == 4</expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>expr_ty</name></type> <name>expression</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>asdl_seq</name> *</type><name>suite_seq</name></decl>;</decl_stmt>
<expr_stmt><expr><name>expression</name> = <call><name>ast_for_expr</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>expression</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>suite_seq</name> = <call><name>ast_for_suite</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr>3</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>suite_seq</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<return>return <expr><call><name>While</name><argument_list>(<argument><expr><name>expression</name></expr></argument>, <argument><expr><name>suite_seq</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><call><name>LINENO</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>n</name>-&gt;<name>n_col_offset</name></name></expr></argument>,
<argument><expr><name><name>c</name>-&gt;<name>c_arena</name></name></expr></argument>)</argument_list></call></expr>;</return>
}</block></then> <else>else <if>if <condition>(<expr><call><name>NCH</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call> == 7</expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>expr_ty</name></type> <name>expression</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>asdl_seq</name> *</type><name>seq1</name></decl>, *<decl><type ref="prev"/><name>seq2</name></decl>;</decl_stmt>
<expr_stmt><expr><name>expression</name> = <call><name>ast_for_expr</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>expression</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>seq1</name> = <call><name>ast_for_suite</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr>3</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>seq1</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>seq2</name> = <call><name>ast_for_suite</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr>6</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>seq2</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<return>return <expr><call><name>While</name><argument_list>(<argument><expr><name>expression</name></expr></argument>, <argument><expr><name>seq1</name></expr></argument>, <argument><expr><name>seq2</name></expr></argument>, <argument><expr><call><name>LINENO</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>n</name>-&gt;<name>n_col_offset</name></name></expr></argument>,
<argument><expr><name><name>c</name>-&gt;<name>c_arena</name></name></expr></argument>)</argument_list></call></expr>;</return>
}</block></then></if></else></if>
<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_SystemError</name></expr></argument>,
<argument><expr>"wrong number of tokens for 'while' statement: %d"</expr></argument>,
<argument><expr><call><name>NCH</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>stmt_ty</name></type>
<name>ast_for_for_stmt</name><parameter_list>(<param><decl><type>struct <name>compiling</name> *</type><name>c</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>node</name> *</type><name>n</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>asdl_seq</name> *</type><name>_target</name></decl>, *<decl><type ref="prev"/><name>seq</name> <init>= <expr><name>NULL</name></expr></init>, *<name>suite_seq</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>expr_ty</name></type> <name>expression</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>expr_ty</name></type> <name>target</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>node</name> *</type><name>node_target</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>REQ</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>for_stmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>NCH</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call> == 9</expr>)</condition><then> <block>{
<expr_stmt><expr><name>seq</name> = <call><name>ast_for_suite</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr>8</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>seq</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
}</block></then></if>
<expr_stmt><expr><name>node_target</name> = <call><name>CHILD</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>_target</name> = <call><name>ast_for_exprlist</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>node_target</name></expr></argument>, <argument><expr><name>Store</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>_target</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<if>if <condition>(<expr><call><name>NCH</name><argument_list>(<argument><expr><name>node_target</name></expr></argument>)</argument_list></call> == 1</expr>)</condition><then>
<expr_stmt><expr><name>target</name> = (<name>expr_ty</name>)<call><name>asdl_seq_GET</name><argument_list>(<argument><expr><name>_target</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
<else>else
<expr_stmt><expr><name>target</name> = <call><name>Tuple</name><argument_list>(<argument><expr><name>_target</name></expr></argument>, <argument><expr><name>Store</name></expr></argument>, <argument><expr><call><name>LINENO</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>n</name>-&gt;<name>n_col_offset</name></name></expr></argument>, <argument><expr><name><name>c</name>-&gt;<name>c_arena</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
<expr_stmt><expr><name>expression</name> = <call><name>ast_for_testlist</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr>3</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>expression</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>suite_seq</name> = <call><name>ast_for_suite</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr>5</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>suite_seq</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<return>return <expr><call><name>For</name><argument_list>(<argument><expr><name>target</name></expr></argument>, <argument><expr><name>expression</name></expr></argument>, <argument><expr><name>suite_seq</name></expr></argument>, <argument><expr><name>seq</name></expr></argument>, <argument><expr><call><name>LINENO</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>n</name>-&gt;<name>n_col_offset</name></name></expr></argument>,
<argument><expr><name><name>c</name>-&gt;<name>c_arena</name></name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>excepthandler_ty</name></type>
<name>ast_for_except_clause</name><parameter_list>(<param><decl><type>struct <name>compiling</name> *</type><name>c</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>node</name> *</type><name>exc</name></decl></param>, <param><decl><type><name>node</name> *</type><name>body</name></decl></param>)</parameter_list> <block>{
<expr_stmt><expr><call><name>REQ</name><argument_list>(<argument><expr><name>exc</name></expr></argument>, <argument><expr><name>except_clause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>REQ</name><argument_list>(<argument><expr><name>body</name></expr></argument>, <argument><expr><name>suite</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>NCH</name><argument_list>(<argument><expr><name>exc</name></expr></argument>)</argument_list></call> == 1</expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>asdl_seq</name> *</type><name>suite_seq</name> <init>= <expr><call><name>ast_for_suite</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>body</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr>!<name>suite_seq</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<return>return <expr><call><name>ExceptHandler</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>suite_seq</name></expr></argument>, <argument><expr><call><name>LINENO</name><argument_list>(<argument><expr><name>exc</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name><name>exc</name>-&gt;<name>n_col_offset</name></name></expr></argument>, <argument><expr><name><name>c</name>-&gt;<name>c_arena</name></name></expr></argument>)</argument_list></call></expr>;</return>
}</block></then> <else>else <if>if <condition>(<expr><call><name>NCH</name><argument_list>(<argument><expr><name>exc</name></expr></argument>)</argument_list></call> == 2</expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>expr_ty</name></type> <name>expression</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>asdl_seq</name> *</type><name>suite_seq</name></decl>;</decl_stmt>
<expr_stmt><expr><name>expression</name> = <call><name>ast_for_expr</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>exc</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>expression</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>suite_seq</name> = <call><name>ast_for_suite</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>body</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>suite_seq</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<return>return <expr><call><name>ExceptHandler</name><argument_list>(<argument><expr><name>expression</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>suite_seq</name></expr></argument>, <argument><expr><call><name>LINENO</name><argument_list>(<argument><expr><name>exc</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name><name>exc</name>-&gt;<name>n_col_offset</name></name></expr></argument>, <argument><expr><name><name>c</name>-&gt;<name>c_arena</name></name></expr></argument>)</argument_list></call></expr>;</return>
}</block></then> <else>else <if>if <condition>(<expr><call><name>NCH</name><argument_list>(<argument><expr><name>exc</name></expr></argument>)</argument_list></call> == 4</expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>asdl_seq</name> *</type><name>suite_seq</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>expr_ty</name></type> <name>expression</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>expr_ty</name></type> <name>e</name> <init>= <expr><call><name>ast_for_expr</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>exc</name></expr></argument>, <argument><expr>3</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr>!<name>e</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<if>if <condition>(<expr>!<call><name>set_context</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>e</name></expr></argument>, <argument><expr><name>Store</name></expr></argument>, <argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>exc</name></expr></argument>, <argument><expr>3</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>expression</name> = <call><name>ast_for_expr</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>exc</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>expression</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>suite_seq</name> = <call><name>ast_for_suite</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>body</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>suite_seq</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<return>return <expr><call><name>ExceptHandler</name><argument_list>(<argument><expr><name>expression</name></expr></argument>, <argument><expr><name>e</name></expr></argument>, <argument><expr><name>suite_seq</name></expr></argument>, <argument><expr><call><name>LINENO</name><argument_list>(<argument><expr><name>exc</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name><name>exc</name>-&gt;<name>n_col_offset</name></name></expr></argument>, <argument><expr><name><name>c</name>-&gt;<name>c_arena</name></name></expr></argument>)</argument_list></call></expr>;</return>
}</block></then></if></else></if></else></if>
<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_SystemError</name></expr></argument>,
<argument><expr>"wrong number of children for 'except' clause: %d"</expr></argument>,
<argument><expr><call><name>NCH</name><argument_list>(<argument><expr><name>exc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>stmt_ty</name></type>
<name>ast_for_try_stmt</name><parameter_list>(<param><decl><type>struct <name>compiling</name> *</type><name>c</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>node</name> *</type><name>n</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>nch</name> <init>= <expr><call><name>NCH</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>n_except</name> <init>= <expr>(<name>nch</name> - 3)/3</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>asdl_seq</name> *</type><name>body</name></decl>, *<decl><type ref="prev"/><name>orelse</name> <init>= <expr><name>NULL</name></expr></init>, *<name>finally</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>REQ</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>try_stmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>body</name> = <call><name>ast_for_suite</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr>2</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>body</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<if>if <condition>(<expr><call><name>TYPE</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>nch</name> - 3</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> == <name>NAME</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><call><name>STR</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>nch</name> - 3</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>"finally"</expr></argument>)</argument_list></call> == 0</expr>)</condition><then> <block>{
<if>if <condition>(<expr><name>nch</name> &gt;= 9 &amp;&amp; <call><name>TYPE</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>nch</name> - 6</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> == <name>NAME</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>orelse</name> = <call><name>ast_for_suite</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>nch</name> - 4</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>orelse</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>n_except</name>--</expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><name>finally</name> = <call><name>ast_for_suite</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>nch</name> - 1</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>finally</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>n_except</name>--</expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr><name>orelse</name> = <call><name>ast_for_suite</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>nch</name> - 1</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>orelse</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>n_except</name>--</expr>;</expr_stmt>
}</block></else></if>
}</block></then> <else>else <if>if <condition>(<expr><call><name>TYPE</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>nch</name> - 3</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> != <name>except_clause</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>ast_error</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr>"malformed 'try' statement"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if></else></if>
<if>if <condition>(<expr><name>n_except</name> &gt; 0</expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>stmt_ty</name></type> <name>except_st</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>asdl_seq</name> *</type><name>handlers</name> <init>= <expr><call><name>asdl_seq_new</name><argument_list>(<argument><expr><name>n_except</name></expr></argument>, <argument><expr><name><name>c</name>-&gt;<name>c_arena</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>handlers</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>n_except</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
<decl_stmt><decl><type><name>excepthandler_ty</name></type> <name>e</name> <init>= <expr><call><name>ast_for_except_clause</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr>3 + <name>i</name> * 3</expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr>5 + <name>i</name> * 3</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr>!<name>e</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><call><name>asdl_seq_SET</name><argument_list>(<argument><expr><name>handlers</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></for>
<expr_stmt><expr><name>except_st</name> = <call><name>TryExcept</name><argument_list>(<argument><expr><name>body</name></expr></argument>, <argument><expr><name>handlers</name></expr></argument>, <argument><expr><name>orelse</name></expr></argument>, <argument><expr><call><name>LINENO</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name><name>n</name>-&gt;<name>n_col_offset</name></name></expr></argument>, <argument><expr><name><name>c</name>-&gt;<name>c_arena</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>finally</name></expr>)</condition><then>
<return>return <expr><name>except_st</name></expr>;</return></then></if>
<expr_stmt><expr><name>body</name> = <call><name>asdl_seq_new</name><argument_list>(<argument><expr>1</expr></argument>, <argument><expr><name><name>c</name>-&gt;<name>c_arena</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>body</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><call><name>asdl_seq_SET</name><argument_list>(<argument><expr><name>body</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>except_st</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>finally</name> != <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>TryFinally</name><argument_list>(<argument><expr><name>body</name></expr></argument>, <argument><expr><name>finally</name></expr></argument>, <argument><expr><call><name>LINENO</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>n</name>-&gt;<name>n_col_offset</name></name></expr></argument>, <argument><expr><name><name>c</name>-&gt;<name>c_arena</name></name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>expr_ty</name></type>
<name>ast_for_with_var</name><parameter_list>(<param><decl><type>struct <name>compiling</name> *</type><name>c</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>node</name> *</type><name>n</name></decl></param>)</parameter_list> <block>{
<expr_stmt><expr><call><name>REQ</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>with_var</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>ast_for_expr</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>stmt_ty</name></type>
<name>ast_for_with_stmt</name><parameter_list>(<param><decl><type>struct <name>compiling</name> *</type><name>c</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>node</name> *</type><name>n</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>expr_ty</name></type> <name>context_expr</name></decl>, <decl><type ref="prev"/><name>optional_vars</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>suite_index</name> <init>= <expr>3</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>asdl_seq</name> *</type><name>suite_seq</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>TYPE</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call> == <name>with_stmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>context_expr</name> = <call><name>ast_for_expr</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>context_expr</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<if>if <condition>(<expr><call><name>TYPE</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr>2</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> == <name>with_var</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>optional_vars</name> = <call><name>ast_for_with_var</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr>2</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>optional_vars</name></expr>)</condition><then> <block>{
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<if>if <condition>(<expr>!<call><name>set_context</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>optional_vars</name></expr></argument>, <argument><expr><name>Store</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>suite_index</name> = 4</expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><name>suite_seq</name> = <call><name>ast_for_suite</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>suite_index</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>suite_seq</name></expr>)</condition><then> <block>{
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<return>return <expr><call><name>With</name><argument_list>(<argument><expr><name>context_expr</name></expr></argument>, <argument><expr><name>optional_vars</name></expr></argument>, <argument><expr><name>suite_seq</name></expr></argument>, <argument><expr><call><name>LINENO</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name><name>n</name>-&gt;<name>n_col_offset</name></name></expr></argument>, <argument><expr><name><name>c</name>-&gt;<name>c_arena</name></name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>stmt_ty</name></type>
<name>ast_for_classdef</name><parameter_list>(<param><decl><type>struct <name>compiling</name> *</type><name>c</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>node</name> *</type><name>n</name></decl></param>, <param><decl><type><name>asdl_seq</name> *</type><name>decorator_seq</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>classname</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>asdl_seq</name> *</type><name>bases</name></decl>, *<decl><type ref="prev"/><name>s</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>REQ</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>classdef</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<call><name>forbidden_check</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><call><name>STR</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<if>if <condition>(<expr><call><name>NCH</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call> == 4</expr>)</condition><then> <block>{
<expr_stmt><expr><name>s</name> = <call><name>ast_for_suite</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr>3</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>s</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>classname</name> = <call><name>NEW_IDENTIFIER</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>classname</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<return>return <expr><call><name>ClassDef</name><argument_list>(<argument><expr><name>classname</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>decorator_seq</name></expr></argument>, <argument><expr><call><name>LINENO</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name><name>n</name>-&gt;<name>n_col_offset</name></name></expr></argument>, <argument><expr><name><name>c</name>-&gt;<name>c_arena</name></name></expr></argument>)</argument_list></call></expr>;</return>
}</block></then></if>
<if>if <condition>(<expr><call><name>TYPE</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>n</name></expr></argument>,<argument><expr>3</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> == <name>RPAR</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>s</name> = <call><name>ast_for_suite</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>n</name></expr></argument>,<argument><expr>5</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>s</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>classname</name> = <call><name>NEW_IDENTIFIER</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>classname</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<return>return <expr><call><name>ClassDef</name><argument_list>(<argument><expr><name>classname</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>decorator_seq</name></expr></argument>, <argument><expr><call><name>LINENO</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name><name>n</name>-&gt;<name>n_col_offset</name></name></expr></argument>, <argument><expr><name><name>c</name>-&gt;<name>c_arena</name></name></expr></argument>)</argument_list></call></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>bases</name> = <call><name>ast_for_class_bases</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr>3</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>bases</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>s</name> = <call><name>ast_for_suite</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr>6</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>s</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>classname</name> = <call><name>NEW_IDENTIFIER</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>classname</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<return>return <expr><call><name>ClassDef</name><argument_list>(<argument><expr><name>classname</name></expr></argument>, <argument><expr><name>bases</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>decorator_seq</name></expr></argument>,
<argument><expr><call><name>LINENO</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>n</name>-&gt;<name>n_col_offset</name></name></expr></argument>, <argument><expr><name><name>c</name>-&gt;<name>c_arena</name></name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>stmt_ty</name></type>
<name>ast_for_stmt</name><parameter_list>(<param><decl><type>struct <name>compiling</name> *</type><name>c</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>node</name> *</type><name>n</name></decl></param>)</parameter_list> <block>{
<if>if <condition>(<expr><call><name>TYPE</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call> == <name>stmt</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>NCH</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call> == 1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>n</name> = <call><name>CHILD</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<if>if <condition>(<expr><call><name>TYPE</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call> == <name>simple_stmt</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>num_stmts</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call> == 1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>n</name> = <call><name>CHILD</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<if>if <condition>(<expr><call><name>TYPE</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call> == <name>small_stmt</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>REQ</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>small_stmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>n</name> = <call><name>CHILD</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<switch>switch <condition>(<expr><call><name>TYPE</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{
<case>case <expr><name>expr_stmt</name></expr>:
<return>return <expr><call><name>ast_for_expr_stmt</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</return>
</case><case>case <expr><name>print_stmt</name></expr>:
<return>return <expr><call><name>ast_for_print_stmt</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</return>
</case><case>case <expr><name>del_stmt</name></expr>:
<return>return <expr><call><name>ast_for_del_stmt</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</return>
</case><case>case <expr><name>pass_stmt</name></expr>:
<return>return <expr><call><name>Pass</name><argument_list>(<argument><expr><call><name>LINENO</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>n</name>-&gt;<name>n_col_offset</name></name></expr></argument>, <argument><expr><name><name>c</name>-&gt;<name>c_arena</name></name></expr></argument>)</argument_list></call></expr>;</return>
</case><case>case <expr><name>flow_stmt</name></expr>:
<return>return <expr><call><name>ast_for_flow_stmt</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</return>
</case><case>case <expr><name>import_stmt</name></expr>:
<return>return <expr><call><name>ast_for_import_stmt</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</return>
</case><case>case <expr><name>global_stmt</name></expr>:
<return>return <expr><call><name>ast_for_global_stmt</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</return>
</case><case>case <expr><name>exec_stmt</name></expr>:
<return>return <expr><call><name>ast_for_exec_stmt</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</return>
</case><case>case <expr><name>assert_stmt</name></expr>:
<return>return <expr><call><name>ast_for_assert_stmt</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</return>
</case><default>default:
<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_SystemError</name></expr></argument>,
<argument><expr>"unhandled small_stmt: TYPE=%d NCH=%d\n"</expr></argument>,
<argument><expr><call><name>TYPE</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>NCH</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
</default>}</block></switch>
}</block></then> <else>else <block>{
<decl_stmt><decl><type><name>node</name> *</type><name>ch</name> <init>= <expr><call><name>CHILD</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>REQ</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>compound_stmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<switch>switch <condition>(<expr><call><name>TYPE</name><argument_list>(<argument><expr><name>ch</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{
<case>case <expr><name>if_stmt</name></expr>:
<return>return <expr><call><name>ast_for_if_stmt</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>ch</name></expr></argument>)</argument_list></call></expr>;</return>
</case><case>case <expr><name>while_stmt</name></expr>:
<return>return <expr><call><name>ast_for_while_stmt</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>ch</name></expr></argument>)</argument_list></call></expr>;</return>
</case><case>case <expr><name>for_stmt</name></expr>:
<return>return <expr><call><name>ast_for_for_stmt</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>ch</name></expr></argument>)</argument_list></call></expr>;</return>
</case><case>case <expr><name>try_stmt</name></expr>:
<return>return <expr><call><name>ast_for_try_stmt</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>ch</name></expr></argument>)</argument_list></call></expr>;</return>
</case><case>case <expr><name>with_stmt</name></expr>:
<return>return <expr><call><name>ast_for_with_stmt</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>ch</name></expr></argument>)</argument_list></call></expr>;</return>
</case><case>case <expr><name>funcdef</name></expr>:
<return>return <expr><call><name>ast_for_funcdef</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>ch</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
</case><case>case <expr><name>classdef</name></expr>:
<return>return <expr><call><name>ast_for_classdef</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>ch</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
</case><case>case <expr><name>decorated</name></expr>:
<return>return <expr><call><name>ast_for_decorated</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>ch</name></expr></argument>)</argument_list></call></expr>;</return>
</case><default>default:
<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_SystemError</name></expr></argument>,
<argument><expr>"unhandled small_stmt: TYPE=%d NCH=%d\n"</expr></argument>,
<argument><expr><call><name>TYPE</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>NCH</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
</default>}</block></switch>
}</block></else></if>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>parsenumber</name><parameter_list>(<param><decl><type>struct <name>compiling</name> *</type><name>c</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>s</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>end</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>long</name></type> <name>x</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>double</name></type> <name>dx</name></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>WITHOUT_COMPLEX</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>Py_complex</name></type> <name>complex</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>imflag</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><name>errno</name> = 0</expr>;</expr_stmt>
<expr_stmt><expr><name>end</name> = <name>s</name> + <call><name>strlen</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call> - 1</expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>WITHOUT_COMPLEX</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><name>imflag</name> = *<name>end</name> == 'j' || *<name>end</name> == 'J'</expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<if>if <condition>(<expr>*<name>end</name> == 'l' || *<name>end</name> == 'L'</expr>)</condition><then>
<return>return <expr><call><name>PyLong_FromString</name><argument_list>(<argument><expr>(<name>char</name> *)<name>s</name></expr></argument>, <argument><expr>(<name>char</name> **)0</expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</return></then></if>
<expr_stmt><expr><name>x</name> = <call><name>PyOS_strtol</name><argument_list>(<argument><expr>(<name>char</name> *)<name>s</name></expr></argument>, <argument><expr>(<name>char</name> **)&amp;<name>end</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>*<name>end</name> == '\0'</expr>)</condition><then> <block>{
<if>if <condition>(<expr><name>errno</name> != 0</expr>)</condition><then>
<return>return <expr><call><name>PyLong_FromString</name><argument_list>(<argument><expr>(<name>char</name> *)<name>s</name></expr></argument>, <argument><expr>(<name>char</name> **)0</expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</return></then></if>
<return>return <expr><call><name>PyInt_FromLong</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></then></if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>WITHOUT_COMPLEX</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if>if <condition>(<expr><name>imflag</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>complex</name>.<name>real</name></name> = 0.</expr>;</expr_stmt>
<macro><name>PyFPE_START_PROTECT</name><argument_list>(<argument>"atof"</argument>, <argument>return 0</argument>)</argument_list></macro>
<expr_stmt><expr><name><name>complex</name>.<name>imag</name></name> = <call><name>PyOS_ascii_atof</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<macro><name>PyFPE_END_PROTECT</name><argument_list>(<argument>complex</argument>)</argument_list></macro>
<return>return <expr><call><name>PyComplex_FromCComplex</name><argument_list>(<argument><expr><name>complex</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></then> <else>else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<block>{
<macro><name>PyFPE_START_PROTECT</name><argument_list>(<argument>"atof"</argument>, <argument>return 0</argument>)</argument_list></macro>
<expr_stmt><expr><name>dx</name> = <call><name>PyOS_ascii_atof</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<macro><name>PyFPE_END_PROTECT</name><argument_list>(<argument>dx</argument>)</argument_list></macro>
<return>return <expr><call><name>PyFloat_FromDouble</name><argument_list>(<argument><expr><name>dx</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></else></if>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>decode_utf8</name><parameter_list>(<param><decl><type>struct <name>compiling</name> *</type><name>c</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> **</type><name>sPtr</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>end</name></decl></param>, <param><decl><type><name>char</name>*</type> <name>encoding</name></decl></param>)</parameter_list> <block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>Py_USING_UNICODE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>Py_FatalError</name><argument_list>(<argument><expr>"decode_utf8 should not be called in this build."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>u</name></decl>, *<decl><type ref="prev"/><name>v</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>s</name></decl>, *<decl><type ref="prev"/><name>t</name></decl>;</decl_stmt>
<expr_stmt><expr><name>t</name> = <name>s</name> = (<name>char</name> *)*<name>sPtr</name></expr>;</expr_stmt>
<while>while <condition>(<expr><name>s</name> &lt; <name>end</name> &amp;&amp; (*<name>s</name> &amp; 0x80)</expr>)</condition> <expr_stmt><expr><name>s</name>++</expr>;</expr_stmt></while>
<expr_stmt><expr>*<name>sPtr</name> = <name>s</name></expr>;</expr_stmt>
<expr_stmt><expr><name>u</name> = <call><name>PyUnicode_DecodeUTF8</name><argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><name>s</name> - <name>t</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>u</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>v</name> = <call><name>PyUnicode_AsEncodedString</name><argument_list>(<argument><expr><name>u</name></expr></argument>, <argument><expr><name>encoding</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>u</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>v</name></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></function>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>Py_USING_UNICODE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>decode_unicode</name><parameter_list>(<param><decl><type>struct <name>compiling</name> *</type><name>c</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>s</name></decl></param>, <param><decl><type><name>size_t</name></type> <name>len</name></decl></param>, <param><decl><type><name>int</name></type> <name>rawmode</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>encoding</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>v</name></decl>, *<decl><type ref="prev"/><name>u</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>buf</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>p</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>end</name></decl>;</decl_stmt>
<if>if <condition>(<expr><name>encoding</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>buf</name> = (<name>char</name> *)<name>s</name></expr>;</expr_stmt>
<expr_stmt><expr><name>u</name> = <name>NULL</name></expr>;</expr_stmt>
}</block></then> <else>else <if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>encoding</name></expr></argument>, <argument><expr>"iso-8859-1"</expr></argument>)</argument_list></call> == 0</expr>)</condition><then> <block>{
<expr_stmt><expr><name>buf</name> = (<name>char</name> *)<name>s</name></expr>;</expr_stmt>
<expr_stmt><expr><name>u</name> = <name>NULL</name></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<if>if <condition>(<expr><name>len</name> &gt; <name>PY_SIZE_MAX</name> / 4</expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>u</name> = <call><name>PyString_FromStringAndSize</name><argument_list>(<argument><expr>(<name>char</name> *)<name>NULL</name></expr></argument>, <argument><expr><name>len</name> * 4</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>u</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>p</name> = <name>buf</name> = <call><name>PyString_AsString</name><argument_list>(<argument><expr><name>u</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>end</name> = <name>s</name> + <name>len</name></expr>;</expr_stmt>
<while>while <condition>(<expr><name>s</name> &lt; <name>end</name></expr>)</condition> <block>{
<if>if <condition>(<expr>*<name>s</name> == '\\'</expr>)</condition><then> <block>{
<expr_stmt><expr>*<name>p</name>++ = *<name>s</name>++</expr>;</expr_stmt>
<if>if <condition>(<expr>*<name>s</name> &amp; 0x80</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr>"u005c"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>p</name> += 5</expr>;</expr_stmt>
}</block></then></if>
}</block></then></if>
<if>if <condition>(<expr>*<name>s</name> &amp; 0x80</expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>w</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>r</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>rn</name></decl>, <decl><type ref="prev"/><name>i</name></decl>;</decl_stmt>
<expr_stmt><expr><name>w</name> = <call><name>decode_utf8</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr>&amp;<name>s</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr>"utf-16-be"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>w</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>u</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>r</name> = <call><name>PyString_AsString</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>rn</name> = <call><name>PyString_Size</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>rn</name> % 2 == 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>rn</name></expr>;</condition> <incr><expr><name>i</name> += 2</expr></incr>) <block>{
<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr>"\\u%02x%02x"</expr></argument>,
<argument><expr><name><name>r</name><index>[<expr><name>i</name> + 0</expr>]</index></name> &amp; 0xFF</expr></argument>,
<argument><expr><name><name>r</name><index>[<expr><name>i</name> + 1</expr>]</index></name> &amp; 0xFF</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>p</name> += 6</expr>;</expr_stmt>
}</block></for>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr>*<name>p</name>++ = *<name>s</name>++</expr>;</expr_stmt>
}</block></else></if>
}</block></while>
<expr_stmt><expr><name>len</name> = <name>p</name> - <name>buf</name></expr>;</expr_stmt>
<expr_stmt><expr><name>s</name> = <name>buf</name></expr>;</expr_stmt>
}</block></else></if></else></if>
<if>if <condition>(<expr><name>rawmode</name></expr>)</condition><then>
<expr_stmt><expr><name>v</name> = <call><name>PyUnicode_DecodeRawUnicodeEscape</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
<else>else
<expr_stmt><expr><name>v</name> = <call><name>PyUnicode_DecodeUnicodeEscape</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>u</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>v</name></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>parsestr</name><parameter_list>(<param><decl><type>struct <name>compiling</name> *</type><name>c</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>s</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>size_t</name></type> <name>len</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>quote</name> <init>= <expr><call><name>Py_CHARMASK</name><argument_list>(<argument><expr>*<name>s</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>rawmode</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>need_encoding</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>unicode</name> <init>= <expr><name><name>c</name>-&gt;<name>c_future_unicode</name></name></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><call><name>isalpha</name><argument_list>(<argument><expr><name>quote</name></expr></argument>)</argument_list></call> || <name>quote</name> == '_'</expr>)</condition><then> <block>{
<if>if <condition>(<expr><name>quote</name> == 'u' || <name>quote</name> == 'U'</expr>)</condition><then> <block>{
<expr_stmt><expr><name>quote</name> = *++<name>s</name></expr>;</expr_stmt>
<expr_stmt><expr><name>unicode</name> = 1</expr>;</expr_stmt>
}</block></then></if>
<if>if <condition>(<expr><name>quote</name> == 'b' || <name>quote</name> == 'B'</expr>)</condition><then> <block>{
<expr_stmt><expr><name>quote</name> = *++<name>s</name></expr>;</expr_stmt>
<expr_stmt><expr><name>unicode</name> = 0</expr>;</expr_stmt>
}</block></then></if>
<if>if <condition>(<expr><name>quote</name> == 'r' || <name>quote</name> == 'R'</expr>)</condition><then> <block>{
<expr_stmt><expr><name>quote</name> = *++<name>s</name></expr>;</expr_stmt>
<expr_stmt><expr><name>rawmode</name> = 1</expr>;</expr_stmt>
}</block></then></if>
}</block></then></if>
<if>if <condition>(<expr><name>quote</name> != '\'' &amp;&amp; <name>quote</name> != '\"'</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_BadInternalCall</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>s</name>++</expr>;</expr_stmt>
<expr_stmt><expr><name>len</name> = <call><name>strlen</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>len</name> &gt; <name>INT_MAX</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_OverflowError</name></expr></argument>,
<argument><expr>"string to parse is too long"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<if>if <condition>(<expr><name><name>s</name><index>[<expr>--<name>len</name></expr>]</index></name> != <name>quote</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_BadInternalCall</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<if>if <condition>(<expr><name>len</name> &gt;= 4 &amp;&amp; <name><name>s</name><index>[<expr>0</expr>]</index></name> == <name>quote</name> &amp;&amp; <name><name>s</name><index>[<expr>1</expr>]</index></name> == <name>quote</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>s</name> += 2</expr>;</expr_stmt>
<expr_stmt><expr><name>len</name> -= 2</expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>s</name><index>[<expr>--<name>len</name></expr>]</index></name> != <name>quote</name> || <name><name>s</name><index>[<expr>--<name>len</name></expr>]</index></name> != <name>quote</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_BadInternalCall</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
}</block></then></if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>Py_USING_UNICODE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if>if <condition>(<expr><name>unicode</name> || <name>Py_UnicodeFlag</name></expr>)</condition><then> <block>{
<return>return <expr><call><name>decode_unicode</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>rawmode</name></expr></argument>, <argument><expr><name><name>c</name>-&gt;<name>c_encoding</name></name></expr></argument>)</argument_list></call></expr>;</return>
}</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><name>need_encoding</name> = (<name><name>c</name>-&gt;<name>c_encoding</name></name> != <name>NULL</name> &amp;&amp;
<call><name>strcmp</name><argument_list>(<argument><expr><name><name>c</name>-&gt;<name>c_encoding</name></name></expr></argument>, <argument><expr>"utf-8"</expr></argument>)</argument_list></call> != 0 &amp;&amp;
<call><name>strcmp</name><argument_list>(<argument><expr><name><name>c</name>-&gt;<name>c_encoding</name></name></expr></argument>, <argument><expr>"iso-8859-1"</expr></argument>)</argument_list></call> != 0)</expr>;</expr_stmt>
<if>if <condition>(<expr><name>rawmode</name> || <call><name>strchr</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr>'\\'</expr></argument>)</argument_list></call> == <name>NULL</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr><name>need_encoding</name></expr>)</condition><then> <block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>Py_USING_UNICODE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>Py_FatalError</name><argument_list>(
<argument><expr>"cannot deal with encodings in this build."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>v</name></decl>, *<decl><type ref="prev"/><name>u</name> <init>= <expr><call><name>PyUnicode_DecodeUTF8</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>u</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>v</name> = <call><name>PyUnicode_AsEncodedString</name><argument_list>(<argument><expr><name>u</name></expr></argument>, <argument><expr><name><name>c</name>-&gt;<name>c_encoding</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>u</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>v</name></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></then> <else>else <block>{
<return>return <expr><call><name>PyString_FromStringAndSize</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></else></if>
}</block></then></if>
<return>return <expr><call><name>PyString_DecodeEscape</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>unicode</name></expr></argument>,
<argument><expr><name>need_encoding</name> ? <name><name>c</name>-&gt;<name>c_encoding</name></name> : <name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>parsestrplus</name><parameter_list>(<param><decl><type>struct <name>compiling</name> *</type><name>c</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>node</name> *</type><name>n</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>v</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>REQ</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>STRING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>(<name>v</name> = <call><name>parsestr</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><call><name>STR</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>) != <name>NULL</name></expr>)</condition><then> <block>{
<for>for (<init><expr><name>i</name> = 1</expr>;</init> <condition><expr><name>i</name> &lt; <call><name>NCH</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>s</name></decl>;</decl_stmt>
<expr_stmt><expr><name>s</name> = <call><name>parsestr</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><call><name>STR</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>s</name> == <name>NULL</name></expr>)</condition><then>
<goto>goto <name>onError</name>;</goto></then></if>
<if>if <condition>(<expr><call><name>PyString_Check</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call> &amp;&amp; <call><name>PyString_Check</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyString_ConcatAndDel</name><argument_list>(<argument><expr>&amp;<name>v</name></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>v</name> == <name>NULL</name></expr>)</condition><then>
<goto>goto <name>onError</name>;</goto></then></if>
}</block></then>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>Py_USING_UNICODE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<else>else <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>temp</name> <init>= <expr><call><name>PyUnicode_Concat</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>v</name> = <name>temp</name></expr>;</expr_stmt>
<if>if <condition>(<expr><name>v</name> == <name>NULL</name></expr>)</condition><then>
<goto>goto <name>onError</name>;</goto></then></if>
}</block></else></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></for>
}</block></then></if>
<return>return <expr><name>v</name></expr>;</return>
<label><name>onError</name>:</label>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></function>
</unit>
