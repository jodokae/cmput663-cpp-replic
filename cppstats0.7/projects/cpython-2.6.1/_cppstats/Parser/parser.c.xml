<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C" filename="projects/cpython-2.6.1/_cppstats/Parser/parser.c"><cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"Python.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgenheaders.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"token.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"grammar.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"node.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"errcode.h"</cpp:file></cpp:include>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>Py_DEBUG</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><specifier>extern</specifier> <name>int</name></type> <name>Py_DebugFlag</name></decl>;</decl_stmt>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>D</name><parameter_list>(<param><type><name>x</name></type></param>)</parameter_list></cpp:macro> <cpp:value>if (!Py_DebugFlag); else x</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>D</name><parameter_list>(<param><type><name>x</name></type></param>)</parameter_list></cpp:macro></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>s_reset</name><parameter_list>(<param><decl><type><name>stack</name> *</type></decl></param>)</parameter_list>;</function_decl>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>s_reset</name><parameter_list>(<param><decl><type><name>stack</name> *</type><name>s</name></decl></param>)</parameter_list> <block>{
<expr_stmt><expr><name><name>s</name>-&gt;<name>s_top</name></name> = &amp;<name><name>s</name>-&gt;<name>s_base</name><index>[<expr><name>MAXSTACK</name></expr>]</index></name></expr>;</expr_stmt>
}</block></function>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>s_empty</name><parameter_list>(<param><type><name>s</name></type></param>)</parameter_list></cpp:macro> <cpp:value>((s)-&gt;s_top == &amp;(s)-&gt;s_base[MAXSTACK])</cpp:value></cpp:define>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>s_push</name><parameter_list>(<param><decl><type><name>register</name> <name>stack</name> *</type><name>s</name></decl></param>, <param><decl><type><name>dfa</name> *</type><name>d</name></decl></param>, <param><decl><type><name>node</name> *</type><name>parent</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>register</name> <name>stackentry</name> *</type><name>top</name></decl>;</decl_stmt>
<if>if <condition>(<expr><name><name>s</name>-&gt;<name>s_top</name></name> == <name><name>s</name>-&gt;<name>s_base</name></name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr>"s_push: parser stack overflow\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>E_NOMEM</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>top</name> = --<name><name>s</name>-&gt;<name>s_top</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>top</name>-&gt;<name>s_dfa</name></name> = <name>d</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>top</name>-&gt;<name>s_parent</name></name> = <name>parent</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>top</name>-&gt;<name>s_state</name></name> = 0</expr>;</expr_stmt>
<return>return <expr>0</expr>;</return>
}</block></function>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>Py_DEBUG</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>s_pop</name><parameter_list>(<param><decl><type><name>register</name> <name>stack</name> *</type><name>s</name></decl></param>)</parameter_list> <block>{
<if>if <condition>(<expr><call><name>s_empty</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<expr_stmt><expr><call><name>Py_FatalError</name><argument_list>(<argument><expr>"s_pop: parser stack underflow -- FATAL"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<expr_stmt><expr><name><name>s</name>-&gt;<name>s_top</name></name>++</expr>;</expr_stmt>
}</block></function>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>s_pop</name><parameter_list>(<param><type><name>s</name></type></param>)</parameter_list></cpp:macro> <cpp:value>(s)-&gt;s_top++</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<function><type><name>parser_state</name> *</type>
<name>PyParser_New</name><parameter_list>(<param><decl><type><name>grammar</name> *</type><name>g</name></decl></param>, <param><decl><type><name>int</name></type> <name>start</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>parser_state</name> *</type><name>ps</name></decl>;</decl_stmt>
<if>if <condition>(<expr>!<name><name>g</name>-&gt;<name>g_accel</name></name></expr>)</condition><then>
<expr_stmt><expr><call><name>PyGrammar_AddAccelerators</name><argument_list>(<argument><expr><name>g</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<expr_stmt><expr><name>ps</name> = (<name>parser_state</name> *)<call><name>PyMem_MALLOC</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>parser_state</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>ps</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name><name>ps</name>-&gt;<name>p_grammar</name></name> = <name>g</name></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>PY_PARSER_REQUIRES_FUTURE_KEYWORD</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><name><name>ps</name>-&gt;<name>p_flags</name></name> = 0</expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><name><name>ps</name>-&gt;<name>p_tree</name></name> = <call><name>PyNode_New</name><argument_list>(<argument><expr><name>start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>ps</name>-&gt;<name>p_tree</name></name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyMem_FREE</name><argument_list>(<argument><expr><name>ps</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><call><name>s_reset</name><argument_list>(<argument><expr>&amp;<name><name>ps</name>-&gt;<name>p_stack</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr>(<name>void</name>) <call><name>s_push</name><argument_list>(<argument><expr>&amp;<name><name>ps</name>-&gt;<name>p_stack</name></name></expr></argument>, <argument><expr><call><name>PyGrammar_FindDFA</name><argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><name>start</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>ps</name>-&gt;<name>p_tree</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>ps</name></expr>;</return>
}</block></function>
<function><type><name>void</name></type>
<name>PyParser_Delete</name><parameter_list>(<param><decl><type><name>parser_state</name> *</type><name>ps</name></decl></param>)</parameter_list> <block>{
<expr_stmt><expr><call><name>PyNode_Free</name><argument_list>(<argument><expr><name><name>ps</name>-&gt;<name>p_tree</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyMem_FREE</name><argument_list>(<argument><expr><name>ps</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>shift</name><parameter_list>(<param><decl><type><name>register</name> <name>stack</name> *</type><name>s</name></decl></param>, <param><decl><type><name>int</name></type> <name>type</name></decl></param>, <param><decl><type><name>char</name> *</type><name>str</name></decl></param>, <param><decl><type><name>int</name></type> <name>newstate</name></decl></param>, <param><decl><type><name>int</name></type> <name>lineno</name></decl></param>, <param><decl><type><name>int</name></type> <name>col_offset</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>err</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr>!<call><name>s_empty</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>err</name> = <call><name>PyNode_AddChild</name><argument_list>(<argument><expr><name><name>s</name>-&gt;<name>s_top</name>-&gt;<name>s_parent</name></name></expr></argument>, <argument><expr><name>type</name></expr></argument>, <argument><expr><name>str</name></expr></argument>, <argument><expr><name>lineno</name></expr></argument>, <argument><expr><name>col_offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>err</name></expr>)</condition><then>
<return>return <expr><name>err</name></expr>;</return></then></if>
<expr_stmt><expr><name><name>s</name>-&gt;<name>s_top</name>-&gt;<name>s_state</name></name> = <name>newstate</name></expr>;</expr_stmt>
<return>return <expr>0</expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>push</name><parameter_list>(<param><decl><type><name>register</name> <name>stack</name> *</type><name>s</name></decl></param>, <param><decl><type><name>int</name></type> <name>type</name></decl></param>, <param><decl><type><name>dfa</name> *</type><name>d</name></decl></param>, <param><decl><type><name>int</name></type> <name>newstate</name></decl></param>, <param><decl><type><name>int</name></type> <name>lineno</name></decl></param>, <param><decl><type><name>int</name></type> <name>col_offset</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>err</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>register</name> <name>node</name> *</type><name>n</name></decl>;</decl_stmt>
<expr_stmt><expr><name>n</name> = <name><name>s</name>-&gt;<name>s_top</name>-&gt;<name>s_parent</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr>!<call><name>s_empty</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>err</name> = <call><name>PyNode_AddChild</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>type</name></expr></argument>, <argument><expr>(<name>char</name> *)<name>NULL</name></expr></argument>, <argument><expr><name>lineno</name></expr></argument>, <argument><expr><name>col_offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>err</name></expr>)</condition><then>
<return>return <expr><name>err</name></expr>;</return></then></if>
<expr_stmt><expr><name><name>s</name>-&gt;<name>s_top</name>-&gt;<name>s_state</name></name> = <name>newstate</name></expr>;</expr_stmt>
<return>return <expr><call><name>s_push</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>d</name></expr></argument>, <argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><call><name>NCH</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call>-1</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>classify</name><parameter_list>(<param><decl><type><name>parser_state</name> *</type><name>ps</name></decl></param>, <param><decl><type><name>int</name></type> <name>type</name></decl></param>, <param><decl><type><name>char</name> *</type><name>str</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>grammar</name> *</type><name>g</name> <init>= <expr><name><name>ps</name>-&gt;<name>p_grammar</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>register</name> <name>int</name></type> <name>n</name> <init>= <expr><name><name>g</name>-&gt;<name>g_ll</name>.<name>ll_nlabels</name></name></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>type</name> == <name>NAME</name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>register</name> <name>char</name> *</type><name>s</name> <init>= <expr><name>str</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>register</name> <name>label</name> *</type><name>l</name> <init>= <expr><name><name>g</name>-&gt;<name>g_ll</name>.<name>ll_label</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>register</name> <name>int</name></type> <name>i</name></decl>;</decl_stmt>
<for>for (<init><expr><name>i</name> = <name>n</name></expr>;</init> <condition><expr><name>i</name> &gt; 0</expr>;</condition> <incr><expr><name>i</name>--</expr>, <expr><name>l</name>++</expr></incr>) <block>{
<if>if <condition>(<expr><name><name>l</name>-&gt;<name>lb_type</name></name> != <name>NAME</name> || <name><name>l</name>-&gt;<name>lb_str</name></name> == <name>NULL</name> ||
<name><name>l</name>-&gt;<name>lb_str</name><index>[<expr>0</expr>]</index></name> != <name><name>s</name><index>[<expr>0</expr>]</index></name> ||
<call><name>strcmp</name><argument_list>(<argument><expr><name><name>l</name>-&gt;<name>lb_str</name></name></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call> != 0</expr>)</condition><then>
<continue>continue;</continue></then></if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>PY_PARSER_REQUIRES_FUTURE_KEYWORD</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if>if <condition>(<expr><name><name>ps</name>-&gt;<name>p_flags</name></name> &amp; <name>CO_FUTURE_PRINT_FUNCTION</name> &amp;&amp;
<name><name>s</name><index>[<expr>0</expr>]</index></name> == 'p' &amp;&amp; <call><name>strcmp</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr>"print"</expr></argument>)</argument_list></call> == 0</expr>)</condition><then> <block>{
<break>break;</break>
}</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><call><name>D</name><argument_list>(<argument><expr><call><name>printf</name><argument_list>(<argument><expr>"It's a keyword\n"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>n</name> - <name>i</name></expr>;</return>
}</block></for>
}</block></then></if>
<block>{
<decl_stmt><decl><type><name>register</name> <name>label</name> *</type><name>l</name> <init>= <expr><name><name>g</name>-&gt;<name>g_ll</name>.<name>ll_label</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>register</name> <name>int</name></type> <name>i</name></decl>;</decl_stmt>
<for>for (<init><expr><name>i</name> = <name>n</name></expr>;</init> <condition><expr><name>i</name> &gt; 0</expr>;</condition> <incr><expr><name>i</name>--</expr>, <expr><name>l</name>++</expr></incr>) <block>{
<if>if <condition>(<expr><name><name>l</name>-&gt;<name>lb_type</name></name> == <name>type</name> &amp;&amp; <name><name>l</name>-&gt;<name>lb_str</name></name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>D</name><argument_list>(<argument><expr><call><name>printf</name><argument_list>(<argument><expr>"It's a token we know\n"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>n</name> - <name>i</name></expr>;</return>
}</block></then></if>
}</block></for>
}</block>
<expr_stmt><expr><call><name>D</name><argument_list>(<argument><expr><call><name>printf</name><argument_list>(<argument><expr>"Illegal token\n"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>-1</expr>;</return>
}</block></function>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>PY_PARSER_REQUIRES_FUTURE_KEYWORD</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>future_hack</name><parameter_list>(<param><decl><type><name>parser_state</name> *</type><name>ps</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>node</name> *</type><name>n</name> <init>= <expr><name><name>ps</name>-&gt;<name>p_stack</name>.<name>s_top</name>-&gt;<name>s_parent</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>node</name> *</type><name>ch</name></decl>, *<decl><type ref="prev"/><name>cch</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<expr_stmt><expr><name>n</name> = <call><name>CHILD</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>NCH</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call> &lt; 4</expr>)</condition><then>
<return>return;</return></then></if>
<expr_stmt><expr><name>ch</name> = <call><name>CHILD</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>STR</name><argument_list>(<argument><expr><name>ch</name></expr></argument>)</argument_list></call> == <name>NULL</name> || <call><name>strcmp</name><argument_list>(<argument><expr><call><name>STR</name><argument_list>(<argument><expr><name>ch</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>"from"</expr></argument>)</argument_list></call> != 0</expr>)</condition><then>
<return>return;</return></then></if>
<expr_stmt><expr><name>ch</name> = <call><name>CHILD</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>NCH</name><argument_list>(<argument><expr><name>ch</name></expr></argument>)</argument_list></call> == 1 &amp;&amp; <call><name>STR</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>ch</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> &amp;&amp;
<call><name>strcmp</name><argument_list>(<argument><expr><call><name>STR</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>ch</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>"__future__"</expr></argument>)</argument_list></call> != 0</expr>)</condition><then>
<return>return;</return></then></if>
<expr_stmt><expr><name>ch</name> = <call><name>CHILD</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr>3</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>TYPE</name><argument_list>(<argument><expr><name>ch</name></expr></argument>)</argument_list></call> == <name>STAR</name></expr>)</condition><then>
<return>return;</return></then></if>
<if>if <condition>(<expr><call><name>TYPE</name><argument_list>(<argument><expr><name>ch</name></expr></argument>)</argument_list></call> == <name>LPAR</name></expr>)</condition><then>
<expr_stmt><expr><name>ch</name> = <call><name>CHILD</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr>4</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <call><name>NCH</name><argument_list>(<argument><expr><name>ch</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name> += 2</expr></incr>) <block>{
<expr_stmt><expr><name>cch</name> = <call><name>CHILD</name><argument_list>(<argument><expr><name>ch</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>NCH</name><argument_list>(<argument><expr><name>cch</name></expr></argument>)</argument_list></call> &gt;= 1 &amp;&amp; <call><name>TYPE</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>cch</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> == <name>NAME</name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>char</name> *</type><name>str_ch</name> <init>= <expr><call><name>STR</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>cch</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>str_ch</name></expr></argument>, <argument><expr><name>FUTURE_WITH_STATEMENT</name></expr></argument>)</argument_list></call> == 0</expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>ps</name>-&gt;<name>p_flags</name></name> |= <name>CO_FUTURE_WITH_STATEMENT</name></expr>;</expr_stmt>
}</block></then> <else>else <if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>str_ch</name></expr></argument>, <argument><expr><name>FUTURE_PRINT_FUNCTION</name></expr></argument>)</argument_list></call> == 0</expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>ps</name>-&gt;<name>p_flags</name></name> |= <name>CO_FUTURE_PRINT_FUNCTION</name></expr>;</expr_stmt>
}</block></then> <else>else <if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>str_ch</name></expr></argument>, <argument><expr><name>FUTURE_UNICODE_LITERALS</name></expr></argument>)</argument_list></call> == 0</expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>ps</name>-&gt;<name>p_flags</name></name> |= <name>CO_FUTURE_UNICODE_LITERALS</name></expr>;</expr_stmt>
}</block></then></if></else></if></else></if>
}</block></then></if>
}</block></for>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<function><type><name>int</name></type>
<name>PyParser_AddToken</name><parameter_list>(<param><decl><type><name>register</name> <name>parser_state</name> *</type><name>ps</name></decl></param>, <param><decl><type><name>register</name> <name>int</name></type> <name>type</name></decl></param>, <param><decl><type><name>char</name> *</type><name>str</name></decl></param>,
<param><decl><type><name>int</name></type> <name>lineno</name></decl></param>, <param><decl><type><name>int</name></type> <name>col_offset</name></decl></param>, <param><decl><type><name>int</name> *</type><name>expected_ret</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>register</name> <name>int</name></type> <name>ilabel</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>err</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>D</name><argument_list>(<argument><expr><call><name>printf</name><argument_list>(<argument><expr>"Token %s/'%s' ... "</expr></argument>, <argument><expr><name><name>_PyParser_TokenNames</name><index>[<expr><name>type</name></expr>]</index></name></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ilabel</name> = <call><name>classify</name><argument_list>(<argument><expr><name>ps</name></expr></argument>, <argument><expr><name>type</name></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>ilabel</name> &lt; 0</expr>)</condition><then>
<return>return <expr><name>E_SYNTAX</name></expr>;</return></then></if>
<for>for (<init>;</init><condition>;</condition><incr/>) <block>{
<decl_stmt><decl><type><name>register</name> <name>dfa</name> *</type><name>d</name> <init>= <expr><name><name>ps</name>-&gt;<name>p_stack</name>.<name>s_top</name>-&gt;<name>s_dfa</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>register</name> <name>state</name> *</type><name>s</name> <init>= <expr>&amp;<name><name>d</name>-&gt;<name>d_state</name><index>[<expr><name><name>ps</name>-&gt;<name>p_stack</name>.<name>s_top</name>-&gt;<name>s_state</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>D</name><argument_list>(<argument><expr><call><name>printf</name><argument_list>(<argument><expr>" DFA '%s', state %d:"</expr></argument>,
<argument><expr><name><name>d</name>-&gt;<name>d_name</name></name></expr></argument>, <argument><expr><name><name>ps</name>-&gt;<name>p_stack</name>.<name>s_top</name>-&gt;<name>s_state</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>s</name>-&gt;<name>s_lower</name></name> &lt;= <name>ilabel</name> &amp;&amp; <name>ilabel</name> &lt; <name><name>s</name>-&gt;<name>s_upper</name></name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>register</name> <name>int</name></type> <name>x</name> <init>= <expr><name><name>s</name>-&gt;<name>s_accel</name><index>[<expr><name>ilabel</name> - <name><name>s</name>-&gt;<name>s_lower</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>x</name> != -1</expr>)</condition><then> <block>{
<if>if <condition>(<expr><name>x</name> &amp; (1&lt;&lt;7)</expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>nt</name> <init>= <expr>(<name>x</name> &gt;&gt; 8) + <name>NT_OFFSET</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>arrow</name> <init>= <expr><name>x</name> &amp; ((1&lt;&lt;7)-1)</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>dfa</name> *</type><name>d1</name> <init>= <expr><call><name>PyGrammar_FindDFA</name><argument_list>(
<argument><expr><name><name>ps</name>-&gt;<name>p_grammar</name></name></expr></argument>, <argument><expr><name>nt</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr>(<name>err</name> = <call><name>push</name><argument_list>(<argument><expr>&amp;<name><name>ps</name>-&gt;<name>p_stack</name></name></expr></argument>, <argument><expr><name>nt</name></expr></argument>, <argument><expr><name>d1</name></expr></argument>,
<argument><expr><name>arrow</name></expr></argument>, <argument><expr><name>lineno</name></expr></argument>, <argument><expr><name>col_offset</name></expr></argument>)</argument_list></call>) &gt; 0</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>D</name><argument_list>(<argument><expr><call><name>printf</name><argument_list>(<argument><expr>" MemError: push\n"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>err</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><call><name>D</name><argument_list>(<argument><expr><call><name>printf</name><argument_list>(<argument><expr>" Push ...\n"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<continue>continue;</continue>
}</block></then></if>
<if>if <condition>(<expr>(<name>err</name> = <call><name>shift</name><argument_list>(<argument><expr>&amp;<name><name>ps</name>-&gt;<name>p_stack</name></name></expr></argument>, <argument><expr><name>type</name></expr></argument>, <argument><expr><name>str</name></expr></argument>,
<argument><expr><name>x</name></expr></argument>, <argument><expr><name>lineno</name></expr></argument>, <argument><expr><name>col_offset</name></expr></argument>)</argument_list></call>) &gt; 0</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>D</name><argument_list>(<argument><expr><call><name>printf</name><argument_list>(<argument><expr>" MemError: shift.\n"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>err</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><call><name>D</name><argument_list>(<argument><expr><call><name>printf</name><argument_list>(<argument><expr>" Shift.\n"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<while>while <condition>(<expr><name>s</name> = &amp;<name><name>d</name>-&gt;<name>d_state</name>
<index>[<expr><name><name>ps</name>-&gt;<name>p_stack</name>.<name>s_top</name>-&gt;<name>s_state</name></name></expr>]</index></name></expr>,
<expr><name><name>s</name>-&gt;<name>s_accept</name></name> &amp;&amp; <name><name>s</name>-&gt;<name>s_narcs</name></name> == 1</expr>)</condition> <block>{
<expr_stmt><expr><call><name>D</name><argument_list>(<argument><expr><call><name>printf</name><argument_list>(<argument><expr>" DFA '%s', state %d: "
"Direct pop.\n"</expr></argument>,
<argument><expr><name><name>d</name>-&gt;<name>d_name</name></name></expr></argument>,
<argument><expr><name><name>ps</name>-&gt;<name>p_stack</name>.<name>s_top</name>-&gt;<name>s_state</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>PY_PARSER_REQUIRES_FUTURE_KEYWORD</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if>if <condition>(<expr><name><name>d</name>-&gt;<name>d_name</name><index>[<expr>0</expr>]</index></name> == 'i' &amp;&amp;
<call><name>strcmp</name><argument_list>(<argument><expr><name><name>d</name>-&gt;<name>d_name</name></name></expr></argument>,
<argument><expr>"import_stmt"</expr></argument>)</argument_list></call> == 0</expr>)</condition><then>
<expr_stmt><expr><call><name>future_hack</name><argument_list>(<argument><expr><name>ps</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><call><name>s_pop</name><argument_list>(<argument><expr>&amp;<name><name>ps</name>-&gt;<name>p_stack</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>s_empty</name><argument_list>(<argument><expr>&amp;<name><name>ps</name>-&gt;<name>p_stack</name></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>D</name><argument_list>(<argument><expr><call><name>printf</name><argument_list>(<argument><expr>" ACCEPT.\n"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>E_DONE</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>d</name> = <name><name>ps</name>-&gt;<name>p_stack</name>.<name>s_top</name>-&gt;<name>s_dfa</name></name></expr>;</expr_stmt>
}</block></while>
<return>return <expr><name>E_OK</name></expr>;</return>
}</block></then></if>
}</block></then></if>
<if>if <condition>(<expr><name><name>s</name>-&gt;<name>s_accept</name></name></expr>)</condition><then> <block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>PY_PARSER_REQUIRES_FUTURE_KEYWORD</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if>if <condition>(<expr><name><name>d</name>-&gt;<name>d_name</name><index>[<expr>0</expr>]</index></name> == 'i' &amp;&amp;
<call><name>strcmp</name><argument_list>(<argument><expr><name><name>d</name>-&gt;<name>d_name</name></name></expr></argument>, <argument><expr>"import_stmt"</expr></argument>)</argument_list></call> == 0</expr>)</condition><then>
<expr_stmt><expr><call><name>future_hack</name><argument_list>(<argument><expr><name>ps</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><call><name>s_pop</name><argument_list>(<argument><expr>&amp;<name><name>ps</name>-&gt;<name>p_stack</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>D</name><argument_list>(<argument><expr><call><name>printf</name><argument_list>(<argument><expr>" Pop ...\n"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>s_empty</name><argument_list>(<argument><expr>&amp;<name><name>ps</name>-&gt;<name>p_stack</name></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>D</name><argument_list>(<argument><expr><call><name>printf</name><argument_list>(<argument><expr>" Error: bottom of stack.\n"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>E_SYNTAX</name></expr>;</return>
}</block></then></if>
<continue>continue;</continue>
}</block></then></if>
<expr_stmt><expr><call><name>D</name><argument_list>(<argument><expr><call><name>printf</name><argument_list>(<argument><expr>" Error.\n"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>expected_ret</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr><name><name>s</name>-&gt;<name>s_lower</name></name> == <name><name>s</name>-&gt;<name>s_upper</name></name> - 1</expr>)</condition><then> <block>{
<expr_stmt><expr>*<name>expected_ret</name> = <name><name>ps</name>-&gt;<name>p_grammar</name>-&gt;
<name>g_ll</name>.<name>ll_label</name><index>[<expr><name><name>s</name>-&gt;<name>s_lower</name></name></expr>]</index></name>.<name>lb_type</name></expr>;</expr_stmt>
}</block></then> <else>else
<expr_stmt><expr>*<name>expected_ret</name> = -1</expr>;</expr_stmt></else></if>
}</block></then></if>
<return>return <expr><name>E_SYNTAX</name></expr>;</return>
}</block></for>
}</block></function>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>Py_DEBUG</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function><type><name>void</name></type>
<name>dumptree</name><parameter_list>(<param><decl><type><name>grammar</name> *</type><name>g</name></decl></param>, <param><decl><type><name>node</name> *</type><name>n</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<if>if <condition>(<expr><name>n</name> == <name>NULL</name></expr>)</condition><then>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>"NIL"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
<else>else <block>{
<decl_stmt><decl><type><name>label</name></type> <name>l</name></decl>;</decl_stmt>
<expr_stmt><expr><name><name>l</name>.<name>lb_type</name></name> = <call><name>TYPE</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>l</name>.<name>lb_str</name></name> = <call><name>STR</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>"%s"</expr></argument>, <argument><expr><call><name>PyGrammar_LabelRepr</name><argument_list>(<argument><expr>&amp;<name>l</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>ISNONTERMINAL</name><argument_list>(<argument><expr><call><name>TYPE</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>"("</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <call><name>NCH</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
<if>if <condition>(<expr><name>i</name> &gt; 0</expr>)</condition><then>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>","</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<expr_stmt><expr><call><name>dumptree</name><argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></for>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>")"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
}</block></else></if>
}</block></function>
<function><type><name>void</name></type>
<name>showtree</name><parameter_list>(<param><decl><type><name>grammar</name> *</type><name>g</name></decl></param>, <param><decl><type><name>node</name> *</type><name>n</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<if>if <condition>(<expr><name>n</name> == <name>NULL</name></expr>)</condition><then>
<return>return;</return></then></if>
<if>if <condition>(<expr><call><name>ISNONTERMINAL</name><argument_list>(<argument><expr><call><name>TYPE</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <call><name>NCH</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
<expr_stmt><expr><call><name>showtree</name><argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></for>
}</block></then> <else>else <if>if <condition>(<expr><call><name>ISTERMINAL</name><argument_list>(<argument><expr><call><name>TYPE</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>"%s"</expr></argument>, <argument><expr><name><name>_PyParser_TokenNames</name><index>[<expr><call><name>TYPE</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>TYPE</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call> == <name>NUMBER</name> || <call><name>TYPE</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call> == <name>NAME</name></expr>)</condition><then>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>"(%s)"</expr></argument>, <argument><expr><call><name>STR</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>" "</expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>"? "</expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if></else></if>
}</block></function>
<function><type><name>void</name></type>
<name>printtree</name><parameter_list>(<param><decl><type><name>parser_state</name> *</type><name>ps</name></decl></param>)</parameter_list> <block>{
<if>if <condition>(<expr><name>Py_DebugFlag</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>"Parse tree:\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>dumptree</name><argument_list>(<argument><expr><name><name>ps</name>-&gt;<name>p_grammar</name></name></expr></argument>, <argument><expr><name><name>ps</name>-&gt;<name>p_tree</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>"\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>"Tokens:\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>showtree</name><argument_list>(<argument><expr><name><name>ps</name>-&gt;<name>p_grammar</name></name></expr></argument>, <argument><expr><name><name>ps</name>-&gt;<name>p_tree</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>"\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>"Listing:\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyNode_ListTree</name><argument_list>(<argument><expr><name><name>ps</name>-&gt;<name>p_tree</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>"\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</unit>
