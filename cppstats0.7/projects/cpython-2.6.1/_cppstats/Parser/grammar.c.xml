<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C" filename="Parser/grammar.c"><cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"Python.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgenheaders.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;ctype.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"token.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"grammar.h"</cpp:file></cpp:include>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>RISCOS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;unixlib.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<decl_stmt><decl><type><specifier>extern</specifier> <name>int</name></type> <name>Py_DebugFlag</name></decl>;</decl_stmt>
<function><type><name>grammar</name> *</type>
<name>newgrammar</name><parameter_list>(<param><decl><type><name>int</name></type> <name>start</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>grammar</name> *</type><name>g</name></decl>;</decl_stmt>
<expr_stmt><expr><name>g</name> = (<name>grammar</name> *)<call><name>PyObject_MALLOC</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>grammar</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>g</name> == <name>NULL</name></expr>)</condition><then>
<expr_stmt><expr><call><name>Py_FatalError</name><argument_list>(<argument><expr>"no mem for new grammar"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<expr_stmt><expr><name><name>g</name>-&gt;<name>g_ndfas</name></name> = 0</expr>;</expr_stmt>
<expr_stmt><expr><name><name>g</name>-&gt;<name>g_dfa</name></name> = <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>g</name>-&gt;<name>g_start</name></name> = <name>start</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>g</name>-&gt;<name>g_ll</name>.<name>ll_nlabels</name></name> = 0</expr>;</expr_stmt>
<expr_stmt><expr><name><name>g</name>-&gt;<name>g_ll</name>.<name>ll_label</name></name> = <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>g</name>-&gt;<name>g_accel</name></name> = 0</expr>;</expr_stmt>
<return>return <expr><name>g</name></expr>;</return>
}</block></function>
<function><type><name>dfa</name> *</type>
<name>adddfa</name><parameter_list>(<param><decl><type><name>grammar</name> *</type><name>g</name></decl></param>, <param><decl><type><name>int</name></type> <name>type</name></decl></param>, <param><decl><type><name>char</name> *</type><name>name</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>dfa</name> *</type><name>d</name></decl>;</decl_stmt>
<expr_stmt><expr><name><name>g</name>-&gt;<name>g_dfa</name></name> = (<name>dfa</name> *)<call><name>PyObject_REALLOC</name><argument_list>(<argument><expr><name><name>g</name>-&gt;<name>g_dfa</name></name></expr></argument>,
<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>dfa</name></expr></argument>)</argument_list></sizeof> * (<name><name>g</name>-&gt;<name>g_ndfas</name></name> + 1)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>g</name>-&gt;<name>g_dfa</name></name> == <name>NULL</name></expr>)</condition><then>
<expr_stmt><expr><call><name>Py_FatalError</name><argument_list>(<argument><expr>"no mem to resize dfa in adddfa"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<expr_stmt><expr><name>d</name> = &amp;<name><name>g</name>-&gt;<name>g_dfa</name><index>[<expr><name><name>g</name>-&gt;<name>g_ndfas</name></name>++</expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>d</name>-&gt;<name>d_type</name></name> = <name>type</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>d</name>-&gt;<name>d_name</name></name> = <call><name>strdup</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>d</name>-&gt;<name>d_nstates</name></name> = 0</expr>;</expr_stmt>
<expr_stmt><expr><name><name>d</name>-&gt;<name>d_state</name></name> = <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>d</name>-&gt;<name>d_initial</name></name> = -1</expr>;</expr_stmt>
<expr_stmt><expr><name><name>d</name>-&gt;<name>d_first</name></name> = <name>NULL</name></expr>;</expr_stmt>
<return>return <expr><name>d</name></expr>;</return>
}</block></function>
<function><type><name>int</name></type>
<name>addstate</name><parameter_list>(<param><decl><type><name>dfa</name> *</type><name>d</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>state</name> *</type><name>s</name></decl>;</decl_stmt>
<expr_stmt><expr><name><name>d</name>-&gt;<name>d_state</name></name> = (<name>state</name> *)<call><name>PyObject_REALLOC</name><argument_list>(<argument><expr><name><name>d</name>-&gt;<name>d_state</name></name></expr></argument>,
<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></sizeof> * (<name><name>d</name>-&gt;<name>d_nstates</name></name> + 1)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>d</name>-&gt;<name>d_state</name></name> == <name>NULL</name></expr>)</condition><then>
<expr_stmt><expr><call><name>Py_FatalError</name><argument_list>(<argument><expr>"no mem to resize state in addstate"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<expr_stmt><expr><name>s</name> = &amp;<name><name>d</name>-&gt;<name>d_state</name><index>[<expr><name><name>d</name>-&gt;<name>d_nstates</name></name>++</expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name>-&gt;<name>s_narcs</name></name> = 0</expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name>-&gt;<name>s_arc</name></name> = <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name>-&gt;<name>s_lower</name></name> = 0</expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name>-&gt;<name>s_upper</name></name> = 0</expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name>-&gt;<name>s_accel</name></name> = <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name>-&gt;<name>s_accept</name></name> = 0</expr>;</expr_stmt>
<return>return <expr><name>s</name> - <name><name>d</name>-&gt;<name>d_state</name></name></expr>;</return>
}</block></function>
<function><type><name>void</name></type>
<name>addarc</name><parameter_list>(<param><decl><type><name>dfa</name> *</type><name>d</name></decl></param>, <param><decl><type><name>int</name></type> <name>from</name></decl></param>, <param><decl><type><name>int</name></type> <name>to</name></decl></param>, <param><decl><type><name>int</name></type> <name>lbl</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>state</name> *</type><name>s</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>arc</name> *</type><name>a</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr>0 &lt;= <name>from</name> &amp;&amp; <name>from</name> &lt; <name><name>d</name>-&gt;<name>d_nstates</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr>0 &lt;= <name>to</name> &amp;&amp; <name>to</name> &lt; <name><name>d</name>-&gt;<name>d_nstates</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>s</name> = &amp;<name><name>d</name>-&gt;<name>d_state</name><index>[<expr><name>from</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name>-&gt;<name>s_arc</name></name> = (<name>arc</name> *)<call><name>PyObject_REALLOC</name><argument_list>(<argument><expr><name><name>s</name>-&gt;<name>s_arc</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>arc</name></expr></argument>)</argument_list></sizeof> * (<name><name>s</name>-&gt;<name>s_narcs</name></name> + 1)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>s</name>-&gt;<name>s_arc</name></name> == <name>NULL</name></expr>)</condition><then>
<expr_stmt><expr><call><name>Py_FatalError</name><argument_list>(<argument><expr>"no mem to resize arc list in addarc"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<expr_stmt><expr><name>a</name> = &amp;<name><name>s</name>-&gt;<name>s_arc</name><index>[<expr><name><name>s</name>-&gt;<name>s_narcs</name></name>++</expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>a</name>-&gt;<name>a_lbl</name></name> = <name>lbl</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>a</name>-&gt;<name>a_arrow</name></name> = <name>to</name></expr>;</expr_stmt>
}</block></function>
<function><type><name>int</name></type>
<name>addlabel</name><parameter_list>(<param><decl><type><name>labellist</name> *</type><name>ll</name></decl></param>, <param><decl><type><name>int</name></type> <name>type</name></decl></param>, <param><decl><type><name>char</name> *</type><name>str</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>label</name> *</type><name>lb</name></decl>;</decl_stmt>
<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name><name>ll</name>-&gt;<name>ll_nlabels</name></name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
<if>if <condition>(<expr><name><name>ll</name>-&gt;<name>ll_label</name><index>[<expr><name>i</name></expr>]</index></name>.<name>lb_type</name> == <name>type</name> &amp;&amp;
<call><name>strcmp</name><argument_list>(<argument><expr><name><name>ll</name>-&gt;<name>ll_label</name><index>[<expr><name>i</name></expr>]</index></name>.<name>lb_str</name></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call> == 0</expr>)</condition><then>
<return>return <expr><name>i</name></expr>;</return></then></if>
}</block></for>
<expr_stmt><expr><name><name>ll</name>-&gt;<name>ll_label</name></name> = (<name>label</name> *)<call><name>PyObject_REALLOC</name><argument_list>(<argument><expr><name><name>ll</name>-&gt;<name>ll_label</name></name></expr></argument>,
<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>label</name></expr></argument>)</argument_list></sizeof> * (<name><name>ll</name>-&gt;<name>ll_nlabels</name></name> + 1)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>ll</name>-&gt;<name>ll_label</name></name> == <name>NULL</name></expr>)</condition><then>
<expr_stmt><expr><call><name>Py_FatalError</name><argument_list>(<argument><expr>"no mem to resize labellist in addlabel"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<expr_stmt><expr><name>lb</name> = &amp;<name><name>ll</name>-&gt;<name>ll_label</name><index>[<expr><name><name>ll</name>-&gt;<name>ll_nlabels</name></name>++</expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>lb</name>-&gt;<name>lb_type</name></name> = <name>type</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>lb</name>-&gt;<name>lb_str</name></name> = <call><name>strdup</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>Py_DebugFlag</name></expr>)</condition><then>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>"Label @ %8p, %d: %s\n"</expr></argument>, <argument><expr><name>ll</name></expr></argument>, <argument><expr><name><name>ll</name>-&gt;<name>ll_nlabels</name></name></expr></argument>,
<argument><expr><call><name>PyGrammar_LabelRepr</name><argument_list>(<argument><expr><name>lb</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<return>return <expr><name>lb</name> - <name><name>ll</name>-&gt;<name>ll_label</name></name></expr>;</return>
}</block></function>
<function><type><name>int</name></type>
<name>findlabel</name><parameter_list>(<param><decl><type><name>labellist</name> *</type><name>ll</name></decl></param>, <param><decl><type><name>int</name></type> <name>type</name></decl></param>, <param><decl><type><name>char</name> *</type><name>str</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name><name>ll</name>-&gt;<name>ll_nlabels</name></name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
<if>if <condition>(<expr><name><name>ll</name>-&gt;<name>ll_label</name><index>[<expr><name>i</name></expr>]</index></name>.<name>lb_type</name> == <name>type</name></expr> )</condition><then>
<return>return <expr><name>i</name></expr>;</return></then></if>
}</block></for>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr>"Label %d/'%s' not found\n"</expr></argument>, <argument><expr><name>type</name></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_FatalError</name><argument_list>(<argument><expr>"grammar.c:findlabel()"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>0</expr>;</return>
}</block></function>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>translabel</name><parameter_list>(<param><decl><type><name>grammar</name> *</type></decl></param>, <param><decl><type><name>label</name> *</type></decl></param>)</parameter_list>;</function_decl>
<function><type><name>void</name></type>
<name>translatelabels</name><parameter_list>(<param><decl><type><name>grammar</name> *</type><name>g</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>Py_DEBUG</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>"Translating labels ...\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<for>for (<init><expr><name>i</name> = <name>EMPTY</name>+1</expr>;</init> <condition><expr><name>i</name> &lt; <name><name>g</name>-&gt;<name>g_ll</name>.<name>ll_nlabels</name></name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
<expr_stmt><expr><call><name>translabel</name><argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr>&amp;<name><name>g</name>-&gt;<name>g_ll</name>.<name>ll_label</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></for>
}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>translabel</name><parameter_list>(<param><decl><type><name>grammar</name> *</type><name>g</name></decl></param>, <param><decl><type><name>label</name> *</type><name>lb</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<if>if <condition>(<expr><name>Py_DebugFlag</name></expr>)</condition><then>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>"Translating label %s ...\n"</expr></argument>, <argument><expr><call><name>PyGrammar_LabelRepr</name><argument_list>(<argument><expr><name>lb</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<if>if <condition>(<expr><name><name>lb</name>-&gt;<name>lb_type</name></name> == <name>NAME</name></expr>)</condition><then> <block>{
<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name><name>g</name>-&gt;<name>g_ndfas</name></name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
<if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>lb</name>-&gt;<name>lb_str</name></name></expr></argument>, <argument><expr><name><name>g</name>-&gt;<name>g_dfa</name><index>[<expr><name>i</name></expr>]</index></name>.<name>d_name</name></expr></argument>)</argument_list></call> == 0</expr>)</condition><then> <block>{
<if>if <condition>(<expr><name>Py_DebugFlag</name></expr>)</condition><then>
<expr_stmt><expr><call><name>printf</name><argument_list>(
<argument><expr>"Label %s is non-terminal %d.\n"</expr></argument>,
<argument><expr><name><name>lb</name>-&gt;<name>lb_str</name></name></expr></argument>,
<argument><expr><name><name>g</name>-&gt;<name>g_dfa</name><index>[<expr><name>i</name></expr>]</index></name>.<name>d_type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<expr_stmt><expr><name><name>lb</name>-&gt;<name>lb_type</name></name> = <name><name>g</name>-&gt;<name>g_dfa</name><index>[<expr><name>i</name></expr>]</index></name>.<name>d_type</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>lb</name>-&gt;<name>lb_str</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>lb</name>-&gt;<name>lb_str</name></name> = <name>NULL</name></expr>;</expr_stmt>
<return>return;</return>
}</block></then></if>
}</block></for>
<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; (<name>int</name>)<name>N_TOKENS</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
<if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>lb</name>-&gt;<name>lb_str</name></name></expr></argument>, <argument><expr><name><name>_PyParser_TokenNames</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call> == 0</expr>)</condition><then> <block>{
<if>if <condition>(<expr><name>Py_DebugFlag</name></expr>)</condition><then>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>"Label %s is terminal %d.\n"</expr></argument>,
<argument><expr><name><name>lb</name>-&gt;<name>lb_str</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<expr_stmt><expr><name><name>lb</name>-&gt;<name>lb_type</name></name> = <name>i</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>lb</name>-&gt;<name>lb_str</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>lb</name>-&gt;<name>lb_str</name></name> = <name>NULL</name></expr>;</expr_stmt>
<return>return;</return>
}</block></then></if>
}</block></for>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>"Can't translate NAME label '%s'\n"</expr></argument>, <argument><expr><name><name>lb</name>-&gt;<name>lb_str</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
}</block></then></if>
<if>if <condition>(<expr><name><name>lb</name>-&gt;<name>lb_type</name></name> == <name>STRING</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr><call><name>isalpha</name><argument_list>(<argument><expr><call><name>Py_CHARMASK</name><argument_list>(<argument><expr><name><name>lb</name>-&gt;<name>lb_str</name><index>[<expr>1</expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> ||
<name><name>lb</name>-&gt;<name>lb_str</name><index>[<expr>1</expr>]</index></name> == '_'</expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>char</name> *</type><name>p</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>src</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>dest</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>name_len</name></decl>;</decl_stmt>
<if>if <condition>(<expr><name>Py_DebugFlag</name></expr>)</condition><then>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>"Label %s is a keyword\n"</expr></argument>, <argument><expr><name><name>lb</name>-&gt;<name>lb_str</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<expr_stmt><expr><name><name>lb</name>-&gt;<name>lb_type</name></name> = <name>NAME</name></expr>;</expr_stmt>
<expr_stmt><expr><name>src</name> = <name><name>lb</name>-&gt;<name>lb_str</name></name> + 1</expr>;</expr_stmt>
<expr_stmt><expr><name>p</name> = <call><name>strchr</name><argument_list>(<argument><expr><name>src</name></expr></argument>, <argument><expr>'\''</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>p</name></expr>)</condition><then>
<expr_stmt><expr><name>name_len</name> = <name>p</name> - <name>src</name></expr>;</expr_stmt></then>
<else>else
<expr_stmt><expr><name>name_len</name> = <call><name>strlen</name><argument_list>(<argument><expr><name>src</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
<expr_stmt><expr><name>dest</name> = (<name>char</name> *)<call><name>malloc</name><argument_list>(<argument><expr><name>name_len</name> + 1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>dest</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>"Can't alloc dest '%s'\n"</expr></argument>, <argument><expr><name>src</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
}</block></then></if>
<expr_stmt><expr><call><name>strncpy</name><argument_list>(<argument><expr><name>dest</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>name_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>dest</name><index>[<expr><name>name_len</name></expr>]</index></name> = '\0'</expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>lb</name>-&gt;<name>lb_str</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>lb</name>-&gt;<name>lb_str</name></name> = <name>dest</name></expr>;</expr_stmt>
}</block></then> <else>else <if>if <condition>(<expr><name><name>lb</name>-&gt;<name>lb_str</name><index>[<expr>2</expr>]</index></name> == <name><name>lb</name>-&gt;<name>lb_str</name><index>[<expr>0</expr>]</index></name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>type</name> <init>= <expr>(<name>int</name>) <call><name>PyToken_OneChar</name><argument_list>(<argument><expr><name><name>lb</name>-&gt;<name>lb_str</name><index>[<expr>1</expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>type</name> != <name>OP</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>lb</name>-&gt;<name>lb_type</name></name> = <name>type</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>lb</name>-&gt;<name>lb_str</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>lb</name>-&gt;<name>lb_str</name></name> = <name>NULL</name></expr>;</expr_stmt>
}</block></then> <else>else
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>"Unknown OP label %s\n"</expr></argument>,
<argument><expr><name><name>lb</name>-&gt;<name>lb_str</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
}</block></then> <else>else <if>if <condition>(<expr><name><name>lb</name>-&gt;<name>lb_str</name><index>[<expr>2</expr>]</index></name> &amp;&amp; <name><name>lb</name>-&gt;<name>lb_str</name><index>[<expr>3</expr>]</index></name> == <name><name>lb</name>-&gt;<name>lb_str</name><index>[<expr>0</expr>]</index></name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>type</name> <init>= <expr>(<name>int</name>) <call><name>PyToken_TwoChars</name><argument_list>(<argument><expr><name><name>lb</name>-&gt;<name>lb_str</name><index>[<expr>1</expr>]</index></name></expr></argument>,
<argument><expr><name><name>lb</name>-&gt;<name>lb_str</name><index>[<expr>2</expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>type</name> != <name>OP</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>lb</name>-&gt;<name>lb_type</name></name> = <name>type</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>lb</name>-&gt;<name>lb_str</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>lb</name>-&gt;<name>lb_str</name></name> = <name>NULL</name></expr>;</expr_stmt>
}</block></then> <else>else
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>"Unknown OP label %s\n"</expr></argument>,
<argument><expr><name><name>lb</name>-&gt;<name>lb_str</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
}</block></then> <else>else <if>if <condition>(<expr><name><name>lb</name>-&gt;<name>lb_str</name><index>[<expr>2</expr>]</index></name> &amp;&amp; <name><name>lb</name>-&gt;<name>lb_str</name><index>[<expr>3</expr>]</index></name> &amp;&amp; <name><name>lb</name>-&gt;<name>lb_str</name><index>[<expr>4</expr>]</index></name> == <name><name>lb</name>-&gt;<name>lb_str</name><index>[<expr>0</expr>]</index></name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>type</name> <init>= <expr>(<name>int</name>) <call><name>PyToken_ThreeChars</name><argument_list>(<argument><expr><name><name>lb</name>-&gt;<name>lb_str</name><index>[<expr>1</expr>]</index></name></expr></argument>,
<argument><expr><name><name>lb</name>-&gt;<name>lb_str</name><index>[<expr>2</expr>]</index></name></expr></argument>,
<argument><expr><name><name>lb</name>-&gt;<name>lb_str</name><index>[<expr>3</expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>type</name> != <name>OP</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>lb</name>-&gt;<name>lb_type</name></name> = <name>type</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>lb</name>-&gt;<name>lb_str</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>lb</name>-&gt;<name>lb_str</name></name> = <name>NULL</name></expr>;</expr_stmt>
}</block></then> <else>else
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>"Unknown OP label %s\n"</expr></argument>,
<argument><expr><name><name>lb</name>-&gt;<name>lb_str</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
}</block></then> <else>else
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>"Can't translate STRING label %s\n"</expr></argument>,
<argument><expr><name><name>lb</name>-&gt;<name>lb_str</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if></else></if></else></if></else></if>
}</block></then> <else>else
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>"Can't translate label '%s'\n"</expr></argument>,
<argument><expr><call><name>PyGrammar_LabelRepr</name><argument_list>(<argument><expr><name>lb</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
}</block></function>
</unit>
