<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C" filename="Parser/parsetok.c"><cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgenheaders.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"tokenizer.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"node.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"grammar.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parsetok.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"errcode.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"graminit.h"</cpp:file></cpp:include>
<decl_stmt><decl><type><name>int</name></type> <name>Py_TabcheckFlag</name></decl>;</decl_stmt>
<function_decl><type><specifier>static</specifier> <name>node</name> *</type><name>parsetok</name><parameter_list>(<param><decl><type>struct</type> <name>tok_state</name> *</decl></param>, <param><decl><type><name>grammar</name> *</type></decl></param>, <param><decl><type><name>int</name></type></decl></param>, <param><decl><type><name>perrdetail</name> *</type></decl></param>, <param><decl><type><name>int</name> *</type></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>initerr</name><parameter_list>(<param><decl><type><name>perrdetail</name> *</type><name>err_ret</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name>*</type> <name>filename</name></decl></param>)</parameter_list>;</function_decl>
<function><type><name>node</name> *</type>
<name>PyParser_ParseString</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>s</name></decl></param>, <param><decl><type><name>grammar</name> *</type><name>g</name></decl></param>, <param><decl><type><name>int</name></type> <name>start</name></decl></param>, <param><decl><type><name>perrdetail</name> *</type><name>err_ret</name></decl></param>)</parameter_list> <block>{
<return>return <expr><call><name>PyParser_ParseStringFlagsFilename</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>g</name></expr></argument>, <argument><expr><name>start</name></expr></argument>, <argument><expr><name>err_ret</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><name>node</name> *</type>
<name>PyParser_ParseStringFlags</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>s</name></decl></param>, <param><decl><type><name>grammar</name> *</type><name>g</name></decl></param>, <param><decl><type><name>int</name></type> <name>start</name></decl></param>,
<param><decl><type><name>perrdetail</name> *</type><name>err_ret</name></decl></param>, <param><decl><type><name>int</name></type> <name>flags</name></decl></param>)</parameter_list> <block>{
<return>return <expr><call><name>PyParser_ParseStringFlagsFilename</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
<argument><expr><name>g</name></expr></argument>, <argument><expr><name>start</name></expr></argument>, <argument><expr><name>err_ret</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><name>node</name> *</type>
<name>PyParser_ParseStringFlagsFilename</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>s</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>filename</name></decl></param>,
<param><decl><type><name>grammar</name> *</type><name>g</name></decl></param>, <param><decl><type><name>int</name></type> <name>start</name></decl></param>,
<param><decl><type><name>perrdetail</name> *</type><name>err_ret</name></decl></param>, <param><decl><type><name>int</name></type> <name>flags</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>iflags</name> <init>= <expr><name>flags</name></expr></init></decl>;</decl_stmt>
<return>return <expr><call><name>PyParser_ParseStringFlagsFilenameEx</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>filename</name></expr></argument>, <argument><expr><name>g</name></expr></argument>, <argument><expr><name>start</name></expr></argument>,
<argument><expr><name>err_ret</name></expr></argument>, <argument><expr>&amp;<name>iflags</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><name>node</name> *</type>
<name>PyParser_ParseStringFlagsFilenameEx</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>s</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>filename</name></decl></param>,
<param><decl><type><name>grammar</name> *</type><name>g</name></decl></param>, <param><decl><type><name>int</name></type> <name>start</name></decl></param>,
<param><decl><type><name>perrdetail</name> *</type><name>err_ret</name></decl></param>, <param><decl><type><name>int</name> *</type><name>flags</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type>struct <name>tok_state</name> *</type><name>tok</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>initerr</name><argument_list>(<argument><expr><name>err_ret</name></expr></argument>, <argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>(<name>tok</name> = <call><name>PyTokenizer_FromString</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call>) == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>err_ret</name>-&gt;<name>error</name></name> = <call><name>PyErr_Occurred</name><argument_list>()</argument_list></call> ? <name>E_DECODE</name> : <name>E_NOMEM</name></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name><name>tok</name>-&gt;<name>filename</name></name> = <name>filename</name> ? <name>filename</name> : "&lt;string&gt;"</expr>;</expr_stmt>
<if>if <condition>(<expr><name>Py_TabcheckFlag</name> || <name>Py_VerboseFlag</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>tok</name>-&gt;<name>altwarning</name></name> = (<name><name>tok</name>-&gt;<name>filename</name></name> != <name>NULL</name>)</expr>;</expr_stmt>
<if>if <condition>(<expr><name>Py_TabcheckFlag</name> &gt;= 2</expr>)</condition><then>
<expr_stmt><expr><name><name>tok</name>-&gt;<name>alterror</name></name>++</expr>;</expr_stmt></then></if>
}</block></then></if>
<return>return <expr><call><name>parsetok</name><argument_list>(<argument><expr><name>tok</name></expr></argument>, <argument><expr><name>g</name></expr></argument>, <argument><expr><name>start</name></expr></argument>, <argument><expr><name>err_ret</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><name>node</name> *</type>
<name>PyParser_ParseFile</name><parameter_list>(<param><decl><type><name>FILE</name> *</type><name>fp</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>filename</name></decl></param>, <param><decl><type><name>grammar</name> *</type><name>g</name></decl></param>, <param><decl><type><name>int</name></type> <name>start</name></decl></param>,
<param><decl><type><name>char</name> *</type><name>ps1</name></decl></param>, <param><decl><type><name>char</name> *</type><name>ps2</name></decl></param>, <param><decl><type><name>perrdetail</name> *</type><name>err_ret</name></decl></param>)</parameter_list> <block>{
<return>return <expr><call><name>PyParser_ParseFileFlags</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><name>filename</name></expr></argument>, <argument><expr><name>g</name></expr></argument>, <argument><expr><name>start</name></expr></argument>, <argument><expr><name>ps1</name></expr></argument>, <argument><expr><name>ps2</name></expr></argument>,
<argument><expr><name>err_ret</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><name>node</name> *</type>
<name>PyParser_ParseFileFlags</name><parameter_list>(<param><decl><type><name>FILE</name> *</type><name>fp</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>filename</name></decl></param>, <param><decl><type><name>grammar</name> *</type><name>g</name></decl></param>, <param><decl><type><name>int</name></type> <name>start</name></decl></param>,
<param><decl><type><name>char</name> *</type><name>ps1</name></decl></param>, <param><decl><type><name>char</name> *</type><name>ps2</name></decl></param>, <param><decl><type><name>perrdetail</name> *</type><name>err_ret</name></decl></param>, <param><decl><type><name>int</name></type> <name>flags</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>iflags</name> <init>= <expr><name>flags</name></expr></init></decl>;</decl_stmt>
<return>return <expr><call><name>PyParser_ParseFileFlagsEx</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><name>filename</name></expr></argument>, <argument><expr><name>g</name></expr></argument>, <argument><expr><name>start</name></expr></argument>, <argument><expr><name>ps1</name></expr></argument>, <argument><expr><name>ps2</name></expr></argument>, <argument><expr><name>err_ret</name></expr></argument>, <argument><expr>&amp;<name>iflags</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><name>node</name> *</type>
<name>PyParser_ParseFileFlagsEx</name><parameter_list>(<param><decl><type><name>FILE</name> *</type><name>fp</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>filename</name></decl></param>, <param><decl><type><name>grammar</name> *</type><name>g</name></decl></param>, <param><decl><type><name>int</name></type> <name>start</name></decl></param>,
<param><decl><type><name>char</name> *</type><name>ps1</name></decl></param>, <param><decl><type><name>char</name> *</type><name>ps2</name></decl></param>, <param><decl><type><name>perrdetail</name> *</type><name>err_ret</name></decl></param>, <param><decl><type><name>int</name> *</type><name>flags</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type>struct <name>tok_state</name> *</type><name>tok</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>initerr</name><argument_list>(<argument><expr><name>err_ret</name></expr></argument>, <argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>(<name>tok</name> = <call><name>PyTokenizer_FromFile</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><name>ps1</name></expr></argument>, <argument><expr><name>ps2</name></expr></argument>)</argument_list></call>) == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>err_ret</name>-&gt;<name>error</name></name> = <name>E_NOMEM</name></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name><name>tok</name>-&gt;<name>filename</name></name> = <name>filename</name></expr>;</expr_stmt>
<if>if <condition>(<expr><name>Py_TabcheckFlag</name> || <name>Py_VerboseFlag</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>tok</name>-&gt;<name>altwarning</name></name> = (<name>filename</name> != <name>NULL</name>)</expr>;</expr_stmt>
<if>if <condition>(<expr><name>Py_TabcheckFlag</name> &gt;= 2</expr>)</condition><then>
<expr_stmt><expr><name><name>tok</name>-&gt;<name>alterror</name></name>++</expr>;</expr_stmt></then></if>
}</block></then></if>
<return>return <expr><call><name>parsetok</name><argument_list>(<argument><expr><name>tok</name></expr></argument>, <argument><expr><name>g</name></expr></argument>, <argument><expr><name>start</name></expr></argument>, <argument><expr><name>err_ret</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>0</expr></cpp:if>
static char with_msg[] =
"%s:%d: Warning: 'with' will become a reserved keyword in Python 2.6\n";
static char as_msg[] =
"%s:%d: Warning: 'as' will become a reserved keyword in Python 2.6\n";
static void
warn(const char *msg, const char *filename, int lineno) {
if (filename == NULL)
filename = "&lt;string&gt;";
PySys_WriteStderr(msg, filename, lineno);
}
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<function><type><specifier>static</specifier> <name>node</name> *</type>
<name>parsetok</name><parameter_list>(<param><decl><type>struct <name>tok_state</name> *</type><name>tok</name></decl></param>, <param><decl><type><name>grammar</name> *</type><name>g</name></decl></param>, <param><decl><type><name>int</name></type> <name>start</name></decl></param>, <param><decl><type><name>perrdetail</name> *</type><name>err_ret</name></decl></param>,
<param><decl><type><name>int</name> *</type><name>flags</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>parser_state</name> *</type><name>ps</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>node</name> *</type><name>n</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>started</name> <init>= <expr>0</expr></init>, <name>handling_import</name> <init>= <expr>0</expr></init>, <name>handling_with</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr>(<name>ps</name> = <call><name>PyParser_New</name><argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><name>start</name></expr></argument>)</argument_list></call>) == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr>"no mem for new parser\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>err_ret</name>-&gt;<name>error</name></name> = <name>E_NOMEM</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyTokenizer_Free</name><argument_list>(<argument><expr><name>tok</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>PY_PARSER_REQUIRES_FUTURE_KEYWORD</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if>if <condition>(<expr>*<name>flags</name> &amp; <name>PyPARSE_PRINT_IS_FUNCTION</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>ps</name>-&gt;<name>p_flags</name></name> |= <name>CO_FUTURE_PRINT_FUNCTION</name></expr>;</expr_stmt>
}</block></then></if>
<if>if <condition>(<expr>*<name>flags</name> &amp; <name>PyPARSE_UNICODE_LITERALS</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>ps</name>-&gt;<name>p_flags</name></name> |= <name>CO_FUTURE_UNICODE_LITERALS</name></expr>;</expr_stmt>
}</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<for>for (<init>;</init><condition>;</condition><incr/>) <block>{
<decl_stmt><decl><type><name>char</name> *</type><name>a</name></decl>, *<decl><type ref="prev"/><name>b</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>type</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>len</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>str</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>col_offset</name></decl>;</decl_stmt>
<expr_stmt><expr><name>type</name> = <call><name>PyTokenizer_Get</name><argument_list>(<argument><expr><name>tok</name></expr></argument>, <argument><expr>&amp;<name>a</name></expr></argument>, <argument><expr>&amp;<name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>type</name> == <name>ERRORTOKEN</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>err_ret</name>-&gt;<name>error</name></name> = <name><name>tok</name>-&gt;<name>done</name></name></expr>;</expr_stmt>
<break>break;</break>
}</block></then></if>
<if>if <condition>(<expr><name>type</name> == <name>ENDMARKER</name> &amp;&amp; <name>started</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>type</name> = <name>NEWLINE</name></expr>;</expr_stmt>
<expr_stmt><expr><name>handling_with</name> = <name>handling_import</name> = 0</expr>;</expr_stmt>
<expr_stmt><expr><name>started</name> = 0</expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>tok</name>-&gt;<name>indent</name></name> &amp;&amp;
!(*<name>flags</name> &amp; <name>PyPARSE_DONT_IMPLY_DEDENT</name>)</expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>tok</name>-&gt;<name>pendin</name></name> = -<name><name>tok</name>-&gt;<name>indent</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tok</name>-&gt;<name>indent</name></name> = 0</expr>;</expr_stmt>
}</block></then></if>
}</block></then> <else>else
<expr_stmt><expr><name>started</name> = 1</expr>;</expr_stmt></else></if>
<expr_stmt><expr><name>len</name> = <name>b</name> - <name>a</name></expr>;</expr_stmt>
<expr_stmt><expr><name>str</name> = (<name>char</name> *) <call><name>PyObject_MALLOC</name><argument_list>(<argument><expr><name>len</name> + 1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>str</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr>"no mem for next token\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>err_ret</name>-&gt;<name>error</name></name> = <name>E_NOMEM</name></expr>;</expr_stmt>
<break>break;</break>
}</block></then></if>
<if>if <condition>(<expr><name>len</name> &gt; 0</expr>)</condition><then>
<expr_stmt><expr><call><name>strncpy</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<expr_stmt><expr><name><name>str</name><index>[<expr><name>len</name></expr>]</index></name> = '\0'</expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>PY_PARSER_REQUIRES_FUTURE_KEYWORD</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<if>if <condition>(<expr><name>a</name> &gt;= <name><name>tok</name>-&gt;<name>line_start</name></name></expr>)</condition><then>
<expr_stmt><expr><name>col_offset</name> = <name>a</name> - <name><name>tok</name>-&gt;<name>line_start</name></name></expr>;</expr_stmt></then>
<else>else
<expr_stmt><expr><name>col_offset</name> = -1</expr>;</expr_stmt></else></if>
<if>if <condition>(<expr>(<name><name>err_ret</name>-&gt;<name>error</name></name> =
<call><name>PyParser_AddToken</name><argument_list>(<argument><expr><name>ps</name></expr></argument>, <argument><expr>(<name>int</name>)<name>type</name></expr></argument>, <argument><expr><name>str</name></expr></argument>, <argument><expr><name><name>tok</name>-&gt;<name>lineno</name></name></expr></argument>, <argument><expr><name>col_offset</name></expr></argument>,
<argument><expr>&amp;(<name><name>err_ret</name>-&gt;<name>expected</name></name>)</expr></argument>)</argument_list></call>) != <name>E_OK</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr><name><name>err_ret</name>-&gt;<name>error</name></name> != <name>E_DONE</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyObject_FREE</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>err_ret</name>-&gt;<name>token</name></name> = <name>type</name></expr>;</expr_stmt>
}</block></then></if>
<break>break;</break>
}</block></then></if>
}</block></for>
<if>if <condition>(<expr><name><name>err_ret</name>-&gt;<name>error</name></name> == <name>E_DONE</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>n</name> = <name><name>ps</name>-&gt;<name>p_tree</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ps</name>-&gt;<name>p_tree</name></name> = <name>NULL</name></expr>;</expr_stmt>
}</block></then> <else>else
<expr_stmt><expr><name>n</name> = <name>NULL</name></expr>;</expr_stmt></else></if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>PY_PARSER_REQUIRES_FUTURE_KEYWORD</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr>*<name>flags</name> = <name><name>ps</name>-&gt;<name>p_flags</name></name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><call><name>PyParser_Delete</name><argument_list>(<argument><expr><name>ps</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>n</name> == <name>NULL</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr><name><name>tok</name>-&gt;<name>lineno</name></name> &lt;= 1 &amp;&amp; <name><name>tok</name>-&gt;<name>done</name></name> == <name>E_EOF</name></expr>)</condition><then>
<expr_stmt><expr><name><name>err_ret</name>-&gt;<name>error</name></name> = <name>E_EOF</name></expr>;</expr_stmt></then></if>
<expr_stmt><expr><name><name>err_ret</name>-&gt;<name>lineno</name></name> = <name><name>tok</name>-&gt;<name>lineno</name></name></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>tok</name>-&gt;<name>buf</name></name> != <name>NULL</name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>char</name> *</type><name>text</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>len</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>tok</name>-&gt;<name>cur</name></name> - <name><name>tok</name>-&gt;<name>buf</name></name> &lt; <name>INT_MAX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>err_ret</name>-&gt;<name>offset</name></name> = <call>(<name>int</name>)<argument_list>(<argument><expr><name><name>tok</name>-&gt;<name>cur</name></name> - <name><name>tok</name>-&gt;<name>buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>len</name> = <name><name>tok</name>-&gt;<name>inp</name></name> - <name><name>tok</name>-&gt;<name>buf</name></name></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>Py_USING_UNICODE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><name>text</name> = <call><name>PyTokenizer_RestoreEncoding</name><argument_list>(<argument><expr><name>tok</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr>&amp;<name><name>err_ret</name>-&gt;<name>offset</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<if>if <condition>(<expr><name>text</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>text</name> = (<name>char</name> *) <call><name>PyObject_MALLOC</name><argument_list>(<argument><expr><name>len</name> + 1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>text</name> != <name>NULL</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr><name>len</name> &gt; 0</expr>)</condition><then>
<expr_stmt><expr><call><name>strncpy</name><argument_list>(<argument><expr><name>text</name></expr></argument>, <argument><expr><name><name>tok</name>-&gt;<name>buf</name></name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<expr_stmt><expr><name><name>text</name><index>[<expr><name>len</name></expr>]</index></name> = '\0'</expr>;</expr_stmt>
}</block></then></if>
}</block></then></if>
<expr_stmt><expr><name><name>err_ret</name>-&gt;<name>text</name></name> = <name>text</name></expr>;</expr_stmt>
}</block></then></if>
}</block></then> <else>else <if>if <condition>(<expr><name><name>tok</name>-&gt;<name>encoding</name></name> != <name>NULL</name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>node</name>*</type> <name>r</name> <init>= <expr><call><name>PyNode_New</name><argument_list>(<argument><expr><name>encoding_decl</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr>!<name>r</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>err_ret</name>-&gt;<name>error</name></name> = <name>E_NOMEM</name></expr>;</expr_stmt>
<expr_stmt><expr><name>n</name> = <name>NULL</name></expr>;</expr_stmt>
<goto>goto <name>done</name>;</goto>
}</block></then></if>
<expr_stmt><expr><name><name>r</name>-&gt;<name>n_str</name></name> = <name><name>tok</name>-&gt;<name>encoding</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>r</name>-&gt;<name>n_nchildren</name></name> = 1</expr>;</expr_stmt>
<expr_stmt><expr><name><name>r</name>-&gt;<name>n_child</name></name> = <name>n</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tok</name>-&gt;<name>encoding</name></name> = <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name>n</name> = <name>r</name></expr>;</expr_stmt>
}</block></then></if></else></if>
<label><name>done</name>:</label>
<expr_stmt><expr><call><name>PyTokenizer_Free</name><argument_list>(<argument><expr><name>tok</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>n</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>initerr</name><parameter_list>(<param><decl><type><name>perrdetail</name> *</type><name>err_ret</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>filename</name></decl></param>)</parameter_list> <block>{
<expr_stmt><expr><name><name>err_ret</name>-&gt;<name>error</name></name> = <name>E_OK</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>err_ret</name>-&gt;<name>filename</name></name> = <name>filename</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>err_ret</name>-&gt;<name>lineno</name></name> = 0</expr>;</expr_stmt>
<expr_stmt><expr><name><name>err_ret</name>-&gt;<name>offset</name></name> = 0</expr>;</expr_stmt>
<expr_stmt><expr><name><name>err_ret</name>-&gt;<name>text</name></name> = <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>err_ret</name>-&gt;<name>token</name></name> = -1</expr>;</expr_stmt>
<expr_stmt><expr><name><name>err_ret</name>-&gt;<name>expected</name></name> = -1</expr>;</expr_stmt>
}</block></function>
</unit>
