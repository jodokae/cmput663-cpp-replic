<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C" filename="projects/cpython-2.6.1/_cppstats/Parser/pgen.c"><cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"Python.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgenheaders.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"token.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"node.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"grammar.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"metagrammar.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgen.h"</cpp:file></cpp:include>
<decl_stmt><decl><type><specifier>extern</specifier> <name>int</name></type> <name>Py_DebugFlag</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>extern</specifier> <name>int</name></type> <name>Py_IgnoreEnvironmentFlag</name></decl>;</decl_stmt>
<typedef>typedef <type><struct>struct <name>_nfaarc</name> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>ar_label</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>ar_arrow</name></decl>;</decl_stmt>
}</block></struct></type> <name>nfaarc</name>;</typedef>
<typedef>typedef <type><struct>struct <name>_nfastate</name> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>st_narcs</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>nfaarc</name> *</type><name>st_arc</name></decl>;</decl_stmt>
}</block></struct></type> <name>nfastate</name>;</typedef>
<typedef>typedef <type><struct>struct <name>_nfa</name> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>nf_type</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>nf_name</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>nf_nstates</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>nfastate</name> *</type><name>nf_state</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>nf_start</name></decl>, <name>nf_finish</name>;</decl_stmt>
}</block></struct></type> <name>nfa</name>;</typedef>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>compile_rhs</name><parameter_list>(<param><decl><type><name>labellist</name> *</type><name>ll</name></decl></param>,
<param><decl><type><name>nfa</name> *</type><name>nf</name></decl></param>, <param><decl><type><name>node</name> *</type><name>n</name></decl></param>, <param><decl><type><name>int</name> *</type><name>pa</name></decl></param>, <param><decl><type><name>int</name> *</type><name>pb</name></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>compile_alt</name><parameter_list>(<param><decl><type><name>labellist</name> *</type><name>ll</name></decl></param>,
<param><decl><type><name>nfa</name> *</type><name>nf</name></decl></param>, <param><decl><type><name>node</name> *</type><name>n</name></decl></param>, <param><decl><type><name>int</name> *</type><name>pa</name></decl></param>, <param><decl><type><name>int</name> *</type><name>pb</name></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>compile_item</name><parameter_list>(<param><decl><type><name>labellist</name> *</type><name>ll</name></decl></param>,
<param><decl><type><name>nfa</name> *</type><name>nf</name></decl></param>, <param><decl><type><name>node</name> *</type><name>n</name></decl></param>, <param><decl><type><name>int</name> *</type><name>pa</name></decl></param>, <param><decl><type><name>int</name> *</type><name>pb</name></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>compile_atom</name><parameter_list>(<param><decl><type><name>labellist</name> *</type><name>ll</name></decl></param>,
<param><decl><type><name>nfa</name> *</type><name>nf</name></decl></param>, <param><decl><type><name>node</name> *</type><name>n</name></decl></param>, <param><decl><type><name>int</name> *</type><name>pa</name></decl></param>, <param><decl><type><name>int</name> *</type><name>pb</name></decl></param>)</parameter_list>;</function_decl>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>addnfastate</name><parameter_list>(<param><decl><type><name>nfa</name> *</type><name>nf</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>nfastate</name> *</type><name>st</name></decl>;</decl_stmt>
<expr_stmt><expr><name><name>nf</name>-&gt;<name>nf_state</name></name> = (<name>nfastate</name> *)<call><name>PyObject_REALLOC</name><argument_list>(<argument><expr><name><name>nf</name>-&gt;<name>nf_state</name></name></expr></argument>,
<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>nfastate</name></expr></argument>)</argument_list></sizeof> * (<name><name>nf</name>-&gt;<name>nf_nstates</name></name> + 1)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>nf</name>-&gt;<name>nf_state</name></name> == <name>NULL</name></expr>)</condition><then>
<expr_stmt><expr><call><name>Py_FatalError</name><argument_list>(<argument><expr>"out of mem"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<expr_stmt><expr><name>st</name> = &amp;<name><name>nf</name>-&gt;<name>nf_state</name><index>[<expr><name><name>nf</name>-&gt;<name>nf_nstates</name></name>++</expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>st</name>-&gt;<name>st_narcs</name></name> = 0</expr>;</expr_stmt>
<expr_stmt><expr><name><name>st</name>-&gt;<name>st_arc</name></name> = <name>NULL</name></expr>;</expr_stmt>
<return>return <expr><name>st</name> - <name><name>nf</name>-&gt;<name>nf_state</name></name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>addnfaarc</name><parameter_list>(<param><decl><type><name>nfa</name> *</type><name>nf</name></decl></param>, <param><decl><type><name>int</name></type> <name>from</name></decl></param>, <param><decl><type><name>int</name></type> <name>to</name></decl></param>, <param><decl><type><name>int</name></type> <name>lbl</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>nfastate</name> *</type><name>st</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>nfaarc</name> *</type><name>ar</name></decl>;</decl_stmt>
<expr_stmt><expr><name>st</name> = &amp;<name><name>nf</name>-&gt;<name>nf_state</name><index>[<expr><name>from</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>st</name>-&gt;<name>st_arc</name></name> = (<name>nfaarc</name> *)<call><name>PyObject_REALLOC</name><argument_list>(<argument><expr><name><name>st</name>-&gt;<name>st_arc</name></name></expr></argument>,
<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>nfaarc</name></expr></argument>)</argument_list></sizeof> * (<name><name>st</name>-&gt;<name>st_narcs</name></name> + 1)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>st</name>-&gt;<name>st_arc</name></name> == <name>NULL</name></expr>)</condition><then>
<expr_stmt><expr><call><name>Py_FatalError</name><argument_list>(<argument><expr>"out of mem"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<expr_stmt><expr><name>ar</name> = &amp;<name><name>st</name>-&gt;<name>st_arc</name><index>[<expr><name><name>st</name>-&gt;<name>st_narcs</name></name>++</expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ar</name>-&gt;<name>ar_label</name></name> = <name>lbl</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ar</name>-&gt;<name>ar_arrow</name></name> = <name>to</name></expr>;</expr_stmt>
}</block></function>
<function><type><specifier>static</specifier> <name>nfa</name> *</type>
<name>newnfa</name><parameter_list>(<param><decl><type><name>char</name> *</type><name>name</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>nfa</name> *</type><name>nf</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>type</name> <init>= <expr><name>NT_OFFSET</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>nf</name> = (<name>nfa</name> *)<call><name>PyObject_MALLOC</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>nfa</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>nf</name> == <name>NULL</name></expr>)</condition><then>
<expr_stmt><expr><call><name>Py_FatalError</name><argument_list>(<argument><expr>"no mem for new nfa"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<expr_stmt><expr><name><name>nf</name>-&gt;<name>nf_type</name></name> = <name>type</name>++</expr>;</expr_stmt>
<expr_stmt><expr><name><name>nf</name>-&gt;<name>nf_name</name></name> = <name>name</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>nf</name>-&gt;<name>nf_nstates</name></name> = 0</expr>;</expr_stmt>
<expr_stmt><expr><name><name>nf</name>-&gt;<name>nf_state</name></name> = <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>nf</name>-&gt;<name>nf_start</name></name> = <name><name>nf</name>-&gt;<name>nf_finish</name></name> = -1</expr>;</expr_stmt>
<return>return <expr><name>nf</name></expr>;</return>
}</block></function>
<typedef>typedef <type><struct>struct <name>_nfagrammar</name> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>gr_nnfas</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>nfa</name> **</type><name>gr_nfa</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>labellist</name></type> <name>gr_ll</name></decl>;</decl_stmt>
}</block></struct></type> <name>nfagrammar</name>;</typedef>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>compile_rule</name><parameter_list>(<param><decl><type><name>nfagrammar</name> *</type><name>gr</name></decl></param>, <param><decl><type><name>node</name> *</type><name>n</name></decl></param>)</parameter_list>;</function_decl>
<function><type><specifier>static</specifier> <name>nfagrammar</name> *</type>
<name>newnfagrammar</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>nfagrammar</name> *</type><name>gr</name></decl>;</decl_stmt>
<expr_stmt><expr><name>gr</name> = (<name>nfagrammar</name> *)<call><name>PyObject_MALLOC</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>nfagrammar</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>gr</name> == <name>NULL</name></expr>)</condition><then>
<expr_stmt><expr><call><name>Py_FatalError</name><argument_list>(<argument><expr>"no mem for new nfa grammar"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<expr_stmt><expr><name><name>gr</name>-&gt;<name>gr_nnfas</name></name> = 0</expr>;</expr_stmt>
<expr_stmt><expr><name><name>gr</name>-&gt;<name>gr_nfa</name></name> = <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>gr</name>-&gt;<name>gr_ll</name>.<name>ll_nlabels</name></name> = 0</expr>;</expr_stmt>
<expr_stmt><expr><name><name>gr</name>-&gt;<name>gr_ll</name>.<name>ll_label</name></name> = <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>addlabel</name><argument_list>(<argument><expr>&amp;<name><name>gr</name>-&gt;<name>gr_ll</name></name></expr></argument>, <argument><expr><name>ENDMARKER</name></expr></argument>, <argument><expr>"EMPTY"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>gr</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>nfa</name> *</type>
<name>addnfa</name><parameter_list>(<param><decl><type><name>nfagrammar</name> *</type><name>gr</name></decl></param>, <param><decl><type><name>char</name> *</type><name>name</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>nfa</name> *</type><name>nf</name></decl>;</decl_stmt>
<expr_stmt><expr><name>nf</name> = <call><name>newnfa</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>gr</name>-&gt;<name>gr_nfa</name></name> = (<name>nfa</name> **)<call><name>PyObject_REALLOC</name><argument_list>(<argument><expr><name><name>gr</name>-&gt;<name>gr_nfa</name></name></expr></argument>,
<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>nfa</name>*</expr></argument>)</argument_list></sizeof> * (<name><name>gr</name>-&gt;<name>gr_nnfas</name></name> + 1)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>gr</name>-&gt;<name>gr_nfa</name></name> == <name>NULL</name></expr>)</condition><then>
<expr_stmt><expr><call><name>Py_FatalError</name><argument_list>(<argument><expr>"out of mem"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<expr_stmt><expr><name><name>gr</name>-&gt;<name>gr_nfa</name><index>[<expr><name><name>gr</name>-&gt;<name>gr_nnfas</name></name>++</expr>]</index></name> = <name>nf</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>addlabel</name><argument_list>(<argument><expr>&amp;<name><name>gr</name>-&gt;<name>gr_ll</name></name></expr></argument>, <argument><expr><name>NAME</name></expr></argument>, <argument><expr><name><name>nf</name>-&gt;<name>nf_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>nf</name></expr>;</return>
}</block></function>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>Py_DEBUG</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name><name>REQNFMT</name><index>[]</index></name> <init>= <expr>"metacompile: less than %d children\n"</expr></init></decl>;</decl_stmt>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>REQN</name><parameter_list>(<param><type><name>i</name></type></param>, <param><type><name>count</name></type></param>)</parameter_list></cpp:macro> <cpp:value>if (i &lt; count) { fprintf(stderr, REQNFMT, count); Py_FatalError("REQN"); } else</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>REQN</name><parameter_list>(<param><type><name>i</name></type></param>, <param><type><name>count</name></type></param>)</parameter_list></cpp:macro></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<function><type><specifier>static</specifier> <name>nfagrammar</name> *</type>
<name>metacompile</name><parameter_list>(<param><decl><type><name>node</name> *</type><name>n</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>nfagrammar</name> *</type><name>gr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<if>if <condition>(<expr><name>Py_DebugFlag</name></expr>)</condition><then>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>"Compiling (meta-) parse tree into NFA grammar\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<expr_stmt><expr><name>gr</name> = <call><name>newnfagrammar</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>REQ</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>MSTART</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>i</name> = <name><name>n</name>-&gt;<name>n_nchildren</name></name> - 1</expr>;</expr_stmt>
<expr_stmt><expr><name>n</name> = <name><name>n</name>-&gt;<name>n_child</name></name></expr>;</expr_stmt>
<for>for (<init>;</init> <condition><expr>--<name>i</name> &gt;= 0</expr>;</condition> <incr><expr><name>n</name>++</expr></incr>) <block>{
<if>if <condition>(<expr><name><name>n</name>-&gt;<name>n_type</name></name> != <name>NEWLINE</name></expr>)</condition><then>
<expr_stmt><expr><call><name>compile_rule</name><argument_list>(<argument><expr><name>gr</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
}</block></for>
<return>return <expr><name>gr</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>compile_rule</name><parameter_list>(<param><decl><type><name>nfagrammar</name> *</type><name>gr</name></decl></param>, <param><decl><type><name>node</name> *</type><name>n</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>nfa</name> *</type><name>nf</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>REQ</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>RULE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>REQN</name><argument_list>(<argument><expr><name><name>n</name>-&gt;<name>n_nchildren</name></name></expr></argument>, <argument><expr>4</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>n</name> = <name><name>n</name>-&gt;<name>n_child</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>REQ</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>NAME</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>nf</name> = <call><name>addnfa</name><argument_list>(<argument><expr><name>gr</name></expr></argument>, <argument><expr><name><name>n</name>-&gt;<name>n_str</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>n</name>++</expr>;</expr_stmt>
<expr_stmt><expr><call><name>REQ</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>COLON</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>n</name>++</expr>;</expr_stmt>
<expr_stmt><expr><call><name>REQ</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>RHS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>compile_rhs</name><argument_list>(<argument><expr>&amp;<name><name>gr</name>-&gt;<name>gr_ll</name></name></expr></argument>, <argument><expr><name>nf</name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr>&amp;<name><name>nf</name>-&gt;<name>nf_start</name></name></expr></argument>, <argument><expr>&amp;<name><name>nf</name>-&gt;<name>nf_finish</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>n</name>++</expr>;</expr_stmt>
<expr_stmt><expr><call><name>REQ</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>NEWLINE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>compile_rhs</name><parameter_list>(<param><decl><type><name>labellist</name> *</type><name>ll</name></decl></param>, <param><decl><type><name>nfa</name> *</type><name>nf</name></decl></param>, <param><decl><type><name>node</name> *</type><name>n</name></decl></param>, <param><decl><type><name>int</name> *</type><name>pa</name></decl></param>, <param><decl><type><name>int</name> *</type><name>pb</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>a</name></decl>, <decl><type ref="prev"/><name>b</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>REQ</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>RHS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>i</name> = <name><name>n</name>-&gt;<name>n_nchildren</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>REQN</name><argument_list>(<argument><expr><name>i</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>n</name> = <name><name>n</name>-&gt;<name>n_child</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>REQ</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>ALT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>compile_alt</name><argument_list>(<argument><expr><name>ll</name></expr></argument>, <argument><expr><name>nf</name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><name>pa</name></expr></argument>, <argument><expr><name>pb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>--<name>i</name> &lt;= 0</expr>)</condition><then>
<return>return;</return></then></if>
<expr_stmt><expr><name>n</name>++</expr>;</expr_stmt>
<expr_stmt><expr><name>a</name> = *<name>pa</name></expr>;</expr_stmt>
<expr_stmt><expr><name>b</name> = *<name>pb</name></expr>;</expr_stmt>
<expr_stmt><expr>*<name>pa</name> = <call><name>addnfastate</name><argument_list>(<argument><expr><name>nf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr>*<name>pb</name> = <call><name>addnfastate</name><argument_list>(<argument><expr><name>nf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>addnfaarc</name><argument_list>(<argument><expr><name>nf</name></expr></argument>, <argument><expr>*<name>pa</name></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><name>EMPTY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>addnfaarc</name><argument_list>(<argument><expr><name>nf</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr>*<name>pb</name></expr></argument>, <argument><expr><name>EMPTY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for (<init>;</init> <condition><expr>--<name>i</name> &gt;= 0</expr>;</condition> <incr><expr><name>n</name>++</expr></incr>) <block>{
<expr_stmt><expr><call><name>REQ</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>VBAR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>REQN</name><argument_list>(<argument><expr><name>i</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr>--<name>i</name></expr>;</expr_stmt>
<expr_stmt><expr><name>n</name>++</expr>;</expr_stmt>
<expr_stmt><expr><call><name>REQ</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>ALT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>compile_alt</name><argument_list>(<argument><expr><name>ll</name></expr></argument>, <argument><expr><name>nf</name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr>&amp;<name>a</name></expr></argument>, <argument><expr>&amp;<name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>addnfaarc</name><argument_list>(<argument><expr><name>nf</name></expr></argument>, <argument><expr>*<name>pa</name></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><name>EMPTY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>addnfaarc</name><argument_list>(<argument><expr><name>nf</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr>*<name>pb</name></expr></argument>, <argument><expr><name>EMPTY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></for>
}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>compile_alt</name><parameter_list>(<param><decl><type><name>labellist</name> *</type><name>ll</name></decl></param>, <param><decl><type><name>nfa</name> *</type><name>nf</name></decl></param>, <param><decl><type><name>node</name> *</type><name>n</name></decl></param>, <param><decl><type><name>int</name> *</type><name>pa</name></decl></param>, <param><decl><type><name>int</name> *</type><name>pb</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>a</name></decl>, <decl><type ref="prev"/><name>b</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>REQ</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>ALT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>i</name> = <name><name>n</name>-&gt;<name>n_nchildren</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>REQN</name><argument_list>(<argument><expr><name>i</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>n</name> = <name><name>n</name>-&gt;<name>n_child</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>REQ</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>ITEM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>compile_item</name><argument_list>(<argument><expr><name>ll</name></expr></argument>, <argument><expr><name>nf</name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><name>pa</name></expr></argument>, <argument><expr><name>pb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr>--<name>i</name></expr>;</expr_stmt>
<expr_stmt><expr><name>n</name>++</expr>;</expr_stmt>
<for>for (<init>;</init> <condition><expr>--<name>i</name> &gt;= 0</expr>;</condition> <incr><expr><name>n</name>++</expr></incr>) <block>{
<expr_stmt><expr><call><name>REQ</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>ITEM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>compile_item</name><argument_list>(<argument><expr><name>ll</name></expr></argument>, <argument><expr><name>nf</name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr>&amp;<name>a</name></expr></argument>, <argument><expr>&amp;<name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>addnfaarc</name><argument_list>(<argument><expr><name>nf</name></expr></argument>, <argument><expr>*<name>pb</name></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><name>EMPTY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr>*<name>pb</name> = <name>b</name></expr>;</expr_stmt>
}</block></for>
}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>compile_item</name><parameter_list>(<param><decl><type><name>labellist</name> *</type><name>ll</name></decl></param>, <param><decl><type><name>nfa</name> *</type><name>nf</name></decl></param>, <param><decl><type><name>node</name> *</type><name>n</name></decl></param>, <param><decl><type><name>int</name> *</type><name>pa</name></decl></param>, <param><decl><type><name>int</name> *</type><name>pb</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>a</name></decl>, <decl><type ref="prev"/><name>b</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>REQ</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>ITEM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>i</name> = <name><name>n</name>-&gt;<name>n_nchildren</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>REQN</name><argument_list>(<argument><expr><name>i</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>n</name> = <name><name>n</name>-&gt;<name>n_child</name></name></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>n</name>-&gt;<name>n_type</name></name> == <name>LSQB</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>REQN</name><argument_list>(<argument><expr><name>i</name></expr></argument>, <argument><expr>3</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>n</name>++</expr>;</expr_stmt>
<expr_stmt><expr><call><name>REQ</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>RHS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr>*<name>pa</name> = <call><name>addnfastate</name><argument_list>(<argument><expr><name>nf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr>*<name>pb</name> = <call><name>addnfastate</name><argument_list>(<argument><expr><name>nf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>addnfaarc</name><argument_list>(<argument><expr><name>nf</name></expr></argument>, <argument><expr>*<name>pa</name></expr></argument>, <argument><expr>*<name>pb</name></expr></argument>, <argument><expr><name>EMPTY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>compile_rhs</name><argument_list>(<argument><expr><name>ll</name></expr></argument>, <argument><expr><name>nf</name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr>&amp;<name>a</name></expr></argument>, <argument><expr>&amp;<name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>addnfaarc</name><argument_list>(<argument><expr><name>nf</name></expr></argument>, <argument><expr>*<name>pa</name></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><name>EMPTY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>addnfaarc</name><argument_list>(<argument><expr><name>nf</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr>*<name>pb</name></expr></argument>, <argument><expr><name>EMPTY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>REQN</name><argument_list>(<argument><expr><name>i</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>n</name>++</expr>;</expr_stmt>
<expr_stmt><expr><call><name>REQ</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>RSQB</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr><call><name>compile_atom</name><argument_list>(<argument><expr><name>ll</name></expr></argument>, <argument><expr><name>nf</name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><name>pa</name></expr></argument>, <argument><expr><name>pb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>--<name>i</name> &lt;= 0</expr>)</condition><then>
<return>return;</return></then></if>
<expr_stmt><expr><name>n</name>++</expr>;</expr_stmt>
<expr_stmt><expr><call><name>addnfaarc</name><argument_list>(<argument><expr><name>nf</name></expr></argument>, <argument><expr>*<name>pb</name></expr></argument>, <argument><expr>*<name>pa</name></expr></argument>, <argument><expr><name>EMPTY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>n</name>-&gt;<name>n_type</name></name> == <name>STAR</name></expr>)</condition><then>
<expr_stmt><expr>*<name>pb</name> = *<name>pa</name></expr>;</expr_stmt></then>
<else>else
<expr_stmt><expr><call><name>REQ</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>PLUS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
}</block></else></if>
}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>compile_atom</name><parameter_list>(<param><decl><type><name>labellist</name> *</type><name>ll</name></decl></param>, <param><decl><type><name>nfa</name> *</type><name>nf</name></decl></param>, <param><decl><type><name>node</name> *</type><name>n</name></decl></param>, <param><decl><type><name>int</name> *</type><name>pa</name></decl></param>, <param><decl><type><name>int</name> *</type><name>pb</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>REQ</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>ATOM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>i</name> = <name><name>n</name>-&gt;<name>n_nchildren</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>REQN</name><argument_list>(<argument><expr><name>i</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>n</name> = <name><name>n</name>-&gt;<name>n_child</name></name></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>n</name>-&gt;<name>n_type</name></name> == <name>LPAR</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>REQN</name><argument_list>(<argument><expr><name>i</name></expr></argument>, <argument><expr>3</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>n</name>++</expr>;</expr_stmt>
<expr_stmt><expr><call><name>REQ</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>RHS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>compile_rhs</name><argument_list>(<argument><expr><name>ll</name></expr></argument>, <argument><expr><name>nf</name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><name>pa</name></expr></argument>, <argument><expr><name>pb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>n</name>++</expr>;</expr_stmt>
<expr_stmt><expr><call><name>REQ</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>RPAR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else <if>if <condition>(<expr><name><name>n</name>-&gt;<name>n_type</name></name> == <name>NAME</name> || <name><name>n</name>-&gt;<name>n_type</name></name> == <name>STRING</name></expr>)</condition><then> <block>{
<expr_stmt><expr>*<name>pa</name> = <call><name>addnfastate</name><argument_list>(<argument><expr><name>nf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr>*<name>pb</name> = <call><name>addnfastate</name><argument_list>(<argument><expr><name>nf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>addnfaarc</name><argument_list>(<argument><expr><name>nf</name></expr></argument>, <argument><expr>*<name>pa</name></expr></argument>, <argument><expr>*<name>pb</name></expr></argument>, <argument><expr><call><name>addlabel</name><argument_list>(<argument><expr><name>ll</name></expr></argument>, <argument><expr><name><name>n</name>-&gt;<name>n_type</name></name></expr></argument>, <argument><expr><name><name>n</name>-&gt;<name>n_str</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else
<expr_stmt><expr><call><name>REQ</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>NAME</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if></else></if>
}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>dumpstate</name><parameter_list>(<param><decl><type><name>labellist</name> *</type><name>ll</name></decl></param>, <param><decl><type><name>nfa</name> *</type><name>nf</name></decl></param>, <param><decl><type><name>int</name></type> <name>istate</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>nfastate</name> *</type><name>st</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>nfaarc</name> *</type><name>ar</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>"%c%2d%c"</expr></argument>,
<argument><expr><name>istate</name> == <name><name>nf</name>-&gt;<name>nf_start</name></name> ? '*' : ' '</expr></argument>,
<argument><expr><name>istate</name></expr></argument>,
<argument><expr><name>istate</name> == <name><name>nf</name>-&gt;<name>nf_finish</name></name> ? '.' : ' '</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>st</name> = &amp;<name><name>nf</name>-&gt;<name>nf_state</name><index>[<expr><name>istate</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name>ar</name> = <name><name>st</name>-&gt;<name>st_arc</name></name></expr>;</expr_stmt>
<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name><name>st</name>-&gt;<name>st_narcs</name></name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
<if>if <condition>(<expr><name>i</name> &gt; 0</expr>)</condition><then>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>"\n "</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>"-&gt; %2d %s"</expr></argument>, <argument><expr><name><name>ar</name>-&gt;<name>ar_arrow</name></name></expr></argument>,
<argument><expr><call><name>PyGrammar_LabelRepr</name><argument_list>(<argument><expr>&amp;<name><name>ll</name>-&gt;<name>ll_label</name><index>[<expr><name><name>ar</name>-&gt;<name>ar_label</name></name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ar</name>++</expr>;</expr_stmt>
}</block></for>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>"\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>dumpnfa</name><parameter_list>(<param><decl><type><name>labellist</name> *</type><name>ll</name></decl></param>, <param><decl><type><name>nfa</name> *</type><name>nf</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>"NFA '%s' has %d states; start %d, finish %d\n"</expr></argument>,
<argument><expr><name><name>nf</name>-&gt;<name>nf_name</name></name></expr></argument>, <argument><expr><name><name>nf</name>-&gt;<name>nf_nstates</name></name></expr></argument>, <argument><expr><name><name>nf</name>-&gt;<name>nf_start</name></name></expr></argument>, <argument><expr><name><name>nf</name>-&gt;<name>nf_finish</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name><name>nf</name>-&gt;<name>nf_nstates</name></name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
<expr_stmt><expr><call><name>dumpstate</name><argument_list>(<argument><expr><name>ll</name></expr></argument>, <argument><expr><name>nf</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></for>
}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>addclosure</name><parameter_list>(<param><decl><type><name>bitset</name></type> <name>ss</name></decl></param>, <param><decl><type><name>nfa</name> *</type><name>nf</name></decl></param>, <param><decl><type><name>int</name></type> <name>istate</name></decl></param>)</parameter_list> <block>{
<if>if <condition>(<expr><call><name>addbit</name><argument_list>(<argument><expr><name>ss</name></expr></argument>, <argument><expr><name>istate</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>nfastate</name> *</type><name>st</name> <init>= <expr>&amp;<name><name>nf</name>-&gt;<name>nf_state</name><index>[<expr><name>istate</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>nfaarc</name> *</type><name>ar</name> <init>= <expr><name><name>st</name>-&gt;<name>st_arc</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<for>for (<init><expr><name>i</name> = <name><name>st</name>-&gt;<name>st_narcs</name></name></expr>;</init> <condition><expr>--<name>i</name> &gt;= 0</expr>;</condition> <incr/>) <block>{
<if>if <condition>(<expr><name><name>ar</name>-&gt;<name>ar_label</name></name> == <name>EMPTY</name></expr>)</condition><then>
<expr_stmt><expr><call><name>addclosure</name><argument_list>(<argument><expr><name>ss</name></expr></argument>, <argument><expr><name>nf</name></expr></argument>, <argument><expr><name><name>ar</name>-&gt;<name>ar_arrow</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<expr_stmt><expr><name>ar</name>++</expr>;</expr_stmt>
}</block></for>
}</block></then></if>
}</block></function>
<typedef>typedef <type><struct>struct <name>_ss_arc</name> <block>{
<decl_stmt><decl><type><name>bitset</name></type> <name>sa_bitset</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>sa_arrow</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>sa_label</name></decl>;</decl_stmt>
}</block></struct></type> <name>ss_arc</name>;</typedef>
<typedef>typedef <type><struct>struct <name>_ss_state</name> <block>{
<decl_stmt><decl><type><name>bitset</name></type> <name>ss_ss</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>ss_narcs</name></decl>;</decl_stmt>
<decl_stmt><decl><type>struct <name>_ss_arc</name> *</type><name>ss_arc</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>ss_deleted</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>ss_finish</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>ss_rename</name></decl>;</decl_stmt>
}</block></struct></type> <name>ss_state</name>;</typedef>
<typedef>typedef <type><struct>struct <name>_ss_dfa</name> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>sd_nstates</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ss_state</name> *</type><name>sd_state</name></decl>;</decl_stmt>
}</block></struct></type> <name>ss_dfa</name>;</typedef>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>printssdfa</name><parameter_list>(<param><decl><type><name>int</name></type> <name>xx_nstates</name></decl></param>, <param><decl><type><name>ss_state</name> *</type><name>xx_state</name></decl></param>, <param><decl><type><name>int</name></type> <name>nbits</name></decl></param>,
<param><decl><type><name>labellist</name> *</type><name>ll</name></decl></param>, <param><decl><type><name>char</name> *</type><name>msg</name></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>simplify</name><parameter_list>(<param><decl><type><name>int</name></type> <name>xx_nstates</name></decl></param>, <param><decl><type><name>ss_state</name> *</type><name>xx_state</name></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>convert</name><parameter_list>(<param><decl><type><name>dfa</name> *</type><name>d</name></decl></param>, <param><decl><type><name>int</name></type> <name>xx_nstates</name></decl></param>, <param><decl><type><name>ss_state</name> *</type><name>xx_state</name></decl></param>)</parameter_list>;</function_decl>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>makedfa</name><parameter_list>(<param><decl><type><name>nfagrammar</name> *</type><name>gr</name></decl></param>, <param><decl><type><name>nfa</name> *</type><name>nf</name></decl></param>, <param><decl><type><name>dfa</name> *</type><name>d</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>nbits</name> <init>= <expr><name><name>nf</name>-&gt;<name>nf_nstates</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bitset</name></type> <name>ss</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>xx_nstates</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ss_state</name> *</type><name>xx_state</name></decl>, *<decl><type ref="prev"/><name>yy</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ss_arc</name> *</type><name>zz</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>istate</name></decl>, <decl><type ref="prev"/><name>jstate</name></decl>, <decl><type ref="prev"/><name>iarc</name></decl>, <decl><type ref="prev"/><name>jarc</name></decl>, <decl><type ref="prev"/><name>ibit</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>nfastate</name> *</type><name>st</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>nfaarc</name> *</type><name>ar</name></decl>;</decl_stmt>
<expr_stmt><expr><name>ss</name> = <call><name>newbitset</name><argument_list>(<argument><expr><name>nbits</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>addclosure</name><argument_list>(<argument><expr><name>ss</name></expr></argument>, <argument><expr><name>nf</name></expr></argument>, <argument><expr><name><name>nf</name>-&gt;<name>nf_start</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>xx_state</name> = (<name>ss_state</name> *)<call><name>PyObject_MALLOC</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ss_state</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>xx_state</name> == <name>NULL</name></expr>)</condition><then>
<expr_stmt><expr><call><name>Py_FatalError</name><argument_list>(<argument><expr>"no mem for xx_state in makedfa"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<expr_stmt><expr><name>xx_nstates</name> = 1</expr>;</expr_stmt>
<expr_stmt><expr><name>yy</name> = &amp;<name><name>xx_state</name><index>[<expr>0</expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>yy</name>-&gt;<name>ss_ss</name></name> = <name>ss</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>yy</name>-&gt;<name>ss_narcs</name></name> = 0</expr>;</expr_stmt>
<expr_stmt><expr><name><name>yy</name>-&gt;<name>ss_arc</name></name> = <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>yy</name>-&gt;<name>ss_deleted</name></name> = 0</expr>;</expr_stmt>
<expr_stmt><expr><name><name>yy</name>-&gt;<name>ss_finish</name></name> = <call><name>testbit</name><argument_list>(<argument><expr><name>ss</name></expr></argument>, <argument><expr><name><name>nf</name>-&gt;<name>nf_finish</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>yy</name>-&gt;<name>ss_finish</name></name></expr>)</condition><then>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>"Error: nonterminal '%s' may produce empty.\n"</expr></argument>,
<argument><expr><name><name>nf</name>-&gt;<name>nf_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<for>for (<init><expr><name>istate</name> = 0</expr>;</init> <condition><expr><name>istate</name> &lt; <name>xx_nstates</name></expr>;</condition> <incr><expr>++<name>istate</name></expr></incr>) <block>{
<decl_stmt><decl><type><name>size_t</name></type> <name>size</name></decl>;</decl_stmt>
<expr_stmt><expr><name>yy</name> = &amp;<name><name>xx_state</name><index>[<expr><name>istate</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name>ss</name> = <name><name>yy</name>-&gt;<name>ss_ss</name></name></expr>;</expr_stmt>
<for>for (<init><expr><name>ibit</name> = 0</expr>;</init> <condition><expr><name>ibit</name> &lt; <name><name>nf</name>-&gt;<name>nf_nstates</name></name></expr>;</condition> <incr><expr>++<name>ibit</name></expr></incr>) <block>{
<if>if <condition>(<expr>!<call><name>testbit</name><argument_list>(<argument><expr><name>ss</name></expr></argument>, <argument><expr><name>ibit</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<continue>continue;</continue></then></if>
<expr_stmt><expr><name>st</name> = &amp;<name><name>nf</name>-&gt;<name>nf_state</name><index>[<expr><name>ibit</name></expr>]</index></name></expr>;</expr_stmt>
<for>for (<init><expr><name>iarc</name> = 0</expr>;</init> <condition><expr><name>iarc</name> &lt; <name><name>st</name>-&gt;<name>st_narcs</name></name></expr>;</condition> <incr><expr><name>iarc</name>++</expr></incr>) <block>{
<expr_stmt><expr><name>ar</name> = &amp;<name><name>st</name>-&gt;<name>st_arc</name><index>[<expr><name>iarc</name></expr>]</index></name></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>ar</name>-&gt;<name>ar_label</name></name> == <name>EMPTY</name></expr>)</condition><then>
<continue>continue;</continue></then></if>
<for>for (<init><expr><name>jarc</name> = 0</expr>;</init> <condition><expr><name>jarc</name> &lt; <name><name>yy</name>-&gt;<name>ss_narcs</name></name></expr>;</condition> <incr><expr>++<name>jarc</name></expr></incr>) <block>{
<expr_stmt><expr><name>zz</name> = &amp;<name><name>yy</name>-&gt;<name>ss_arc</name><index>[<expr><name>jarc</name></expr>]</index></name></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>ar</name>-&gt;<name>ar_label</name></name> == <name><name>zz</name>-&gt;<name>sa_label</name></name></expr>)</condition><then>
<goto>goto <name>found</name>;</goto></then></if>
}</block></for>
<expr_stmt><expr><name>size</name> = <sizeof>sizeof<argument_list>(<argument><expr><name>ss_arc</name></expr></argument>)</argument_list></sizeof> * (<name><name>yy</name>-&gt;<name>ss_narcs</name></name> + 1)</expr>;</expr_stmt>
<expr_stmt><expr><name><name>yy</name>-&gt;<name>ss_arc</name></name> = (<name>ss_arc</name> *)<call><name>PyObject_REALLOC</name><argument_list>(
<argument><expr><name><name>yy</name>-&gt;<name>ss_arc</name></name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>yy</name>-&gt;<name>ss_arc</name></name> == <name>NULL</name></expr>)</condition><then>
<expr_stmt><expr><call><name>Py_FatalError</name><argument_list>(<argument><expr>"out of mem"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<expr_stmt><expr><name>zz</name> = &amp;<name><name>yy</name>-&gt;<name>ss_arc</name><index>[<expr><name><name>yy</name>-&gt;<name>ss_narcs</name></name>++</expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>zz</name>-&gt;<name>sa_label</name></name> = <name><name>ar</name>-&gt;<name>ar_label</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>zz</name>-&gt;<name>sa_bitset</name></name> = <call><name>newbitset</name><argument_list>(<argument><expr><name>nbits</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>zz</name>-&gt;<name>sa_arrow</name></name> = -1</expr>;</expr_stmt>
<label><name>found</name>:</label>
<empty_stmt>;</empty_stmt>
<expr_stmt><expr><call><name>addclosure</name><argument_list>(<argument><expr><name><name>zz</name>-&gt;<name>sa_bitset</name></name></expr></argument>, <argument><expr><name>nf</name></expr></argument>, <argument><expr><name><name>ar</name>-&gt;<name>ar_arrow</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></for>
}</block></for>
<for>for (<init><expr><name>jarc</name> = 0</expr>;</init> <condition><expr><name>jarc</name> &lt; <name><name>xx_state</name><index>[<expr><name>istate</name></expr>]</index></name>.<name>ss_narcs</name></expr>;</condition> <incr><expr><name>jarc</name>++</expr></incr>) <block>{
<expr_stmt><expr><name>zz</name> = &amp;<name><name>xx_state</name><index>[<expr><name>istate</name></expr>]</index></name>.<name><name>ss_arc</name><index>[<expr><name>jarc</name></expr>]</index></name></expr>;</expr_stmt>
<for>for (<init><expr><name>jstate</name> = 0</expr>;</init> <condition><expr><name>jstate</name> &lt; <name>xx_nstates</name></expr>;</condition> <incr><expr><name>jstate</name>++</expr></incr>) <block>{
<if>if <condition>(<expr><call><name>samebitset</name><argument_list>(<argument><expr><name><name>zz</name>-&gt;<name>sa_bitset</name></name></expr></argument>,
<argument><expr><name><name>xx_state</name><index>[<expr><name>jstate</name></expr>]</index></name>.<name>ss_ss</name></expr></argument>, <argument><expr><name>nbits</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>zz</name>-&gt;<name>sa_arrow</name></name> = <name>jstate</name></expr>;</expr_stmt>
<goto>goto <name>done</name>;</goto>
}</block></then></if>
}</block></for>
<expr_stmt><expr><name>size</name> = <sizeof>sizeof<argument_list>(<argument><expr><name>ss_state</name></expr></argument>)</argument_list></sizeof> * (<name>xx_nstates</name> + 1)</expr>;</expr_stmt>
<expr_stmt><expr><name>xx_state</name> = (<name>ss_state</name> *)<call><name>PyObject_REALLOC</name><argument_list>(<argument><expr><name>xx_state</name></expr></argument>,
<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>xx_state</name> == <name>NULL</name></expr>)</condition><then>
<expr_stmt><expr><call><name>Py_FatalError</name><argument_list>(<argument><expr>"out of mem"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<expr_stmt><expr><name><name>zz</name>-&gt;<name>sa_arrow</name></name> = <name>xx_nstates</name></expr>;</expr_stmt>
<expr_stmt><expr><name>yy</name> = &amp;<name><name>xx_state</name><index>[<expr><name>xx_nstates</name>++</expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>yy</name>-&gt;<name>ss_ss</name></name> = <name><name>zz</name>-&gt;<name>sa_bitset</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>yy</name>-&gt;<name>ss_narcs</name></name> = 0</expr>;</expr_stmt>
<expr_stmt><expr><name><name>yy</name>-&gt;<name>ss_arc</name></name> = <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>yy</name>-&gt;<name>ss_deleted</name></name> = 0</expr>;</expr_stmt>
<expr_stmt><expr><name><name>yy</name>-&gt;<name>ss_finish</name></name> = <call><name>testbit</name><argument_list>(<argument><expr><name><name>yy</name>-&gt;<name>ss_ss</name></name></expr></argument>, <argument><expr><name><name>nf</name>-&gt;<name>nf_finish</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<label><name>done</name>:</label>
<empty_stmt>;</empty_stmt>
}</block></for>
}</block></for>
<if>if <condition>(<expr><name>Py_DebugFlag</name></expr>)</condition><then>
<expr_stmt><expr><call><name>printssdfa</name><argument_list>(<argument><expr><name>xx_nstates</name></expr></argument>, <argument><expr><name>xx_state</name></expr></argument>, <argument><expr><name>nbits</name></expr></argument>, <argument><expr>&amp;<name><name>gr</name>-&gt;<name>gr_ll</name></name></expr></argument>,
<argument><expr>"before minimizing"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<expr_stmt><expr><call><name>simplify</name><argument_list>(<argument><expr><name>xx_nstates</name></expr></argument>, <argument><expr><name>xx_state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>Py_DebugFlag</name></expr>)</condition><then>
<expr_stmt><expr><call><name>printssdfa</name><argument_list>(<argument><expr><name>xx_nstates</name></expr></argument>, <argument><expr><name>xx_state</name></expr></argument>, <argument><expr><name>nbits</name></expr></argument>, <argument><expr>&amp;<name><name>gr</name>-&gt;<name>gr_ll</name></name></expr></argument>,
<argument><expr>"after minimizing"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<expr_stmt><expr><call><name>convert</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr><name>xx_nstates</name></expr></argument>, <argument><expr><name>xx_state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyObject_FREE</name><argument_list>(<argument><expr><name>xx_state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>printssdfa</name><parameter_list>(<param><decl><type><name>int</name></type> <name>xx_nstates</name></decl></param>, <param><decl><type><name>ss_state</name> *</type><name>xx_state</name></decl></param>, <param><decl><type><name>int</name></type> <name>nbits</name></decl></param>,
<param><decl><type><name>labellist</name> *</type><name>ll</name></decl></param>, <param><decl><type><name>char</name> *</type><name>msg</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>ibit</name></decl>, <decl><type ref="prev"/><name>iarc</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ss_state</name> *</type><name>yy</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ss_arc</name> *</type><name>zz</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>"Subset DFA %s\n"</expr></argument>, <argument><expr><name>msg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>xx_nstates</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
<expr_stmt><expr><name>yy</name> = &amp;<name><name>xx_state</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>yy</name>-&gt;<name>ss_deleted</name></name></expr>)</condition><then>
<continue>continue;</continue></then></if>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>" Subset %d"</expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>yy</name>-&gt;<name>ss_finish</name></name></expr>)</condition><then>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>" (finish)"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>" { "</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for (<init><expr><name>ibit</name> = 0</expr>;</init> <condition><expr><name>ibit</name> &lt; <name>nbits</name></expr>;</condition> <incr><expr><name>ibit</name>++</expr></incr>) <block>{
<if>if <condition>(<expr><call><name>testbit</name><argument_list>(<argument><expr><name><name>yy</name>-&gt;<name>ss_ss</name></name></expr></argument>, <argument><expr><name>ibit</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>"%d "</expr></argument>, <argument><expr><name>ibit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
}</block></for>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>"}\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for (<init><expr><name>iarc</name> = 0</expr>;</init> <condition><expr><name>iarc</name> &lt; <name><name>yy</name>-&gt;<name>ss_narcs</name></name></expr>;</condition> <incr><expr><name>iarc</name>++</expr></incr>) <block>{
<expr_stmt><expr><name>zz</name> = &amp;<name><name>yy</name>-&gt;<name>ss_arc</name><index>[<expr><name>iarc</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>" Arc to state %d, label %s\n"</expr></argument>,
<argument><expr><name><name>zz</name>-&gt;<name>sa_arrow</name></name></expr></argument>,
<argument><expr><call><name>PyGrammar_LabelRepr</name><argument_list>(
<argument><expr>&amp;<name><name>ll</name>-&gt;<name>ll_label</name><index>[<expr><name><name>zz</name>-&gt;<name>sa_label</name></name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></for>
}</block></for>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>samestate</name><parameter_list>(<param><decl><type><name>ss_state</name> *</type><name>s1</name></decl></param>, <param><decl><type><name>ss_state</name> *</type><name>s2</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<if>if <condition>(<expr><name><name>s1</name>-&gt;<name>ss_narcs</name></name> != <name><name>s2</name>-&gt;<name>ss_narcs</name></name> || <name><name>s1</name>-&gt;<name>ss_finish</name></name> != <name><name>s2</name>-&gt;<name>ss_finish</name></name></expr>)</condition><then>
<return>return <expr>0</expr>;</return></then></if>
<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name><name>s1</name>-&gt;<name>ss_narcs</name></name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
<if>if <condition>(<expr><name><name>s1</name>-&gt;<name>ss_arc</name><index>[<expr><name>i</name></expr>]</index></name>.<name>sa_arrow</name> != <name><name>s2</name>-&gt;<name>ss_arc</name><index>[<expr><name>i</name></expr>]</index></name>.<name>sa_arrow</name> ||
<name><name>s1</name>-&gt;<name>ss_arc</name><index>[<expr><name>i</name></expr>]</index></name>.<name>sa_label</name> != <name><name>s2</name>-&gt;<name>ss_arc</name><index>[<expr><name>i</name></expr>]</index></name>.<name>sa_label</name></expr>)</condition><then>
<return>return <expr>0</expr>;</return></then></if>
}</block></for>
<return>return <expr>1</expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>renamestates</name><parameter_list>(<param><decl><type><name>int</name></type> <name>xx_nstates</name></decl></param>, <param><decl><type><name>ss_state</name> *</type><name>xx_state</name></decl></param>, <param><decl><type><name>int</name></type> <name>from</name></decl></param>, <param><decl><type><name>int</name></type> <name>to</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>
<if>if <condition>(<expr><name>Py_DebugFlag</name></expr>)</condition><then>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>"Rename state %d to %d.\n"</expr></argument>, <argument><expr><name>from</name></expr></argument>, <argument><expr><name>to</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>xx_nstates</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
<if>if <condition>(<expr><name><name>xx_state</name><index>[<expr><name>i</name></expr>]</index></name>.<name>ss_deleted</name></expr>)</condition><then>
<continue>continue;</continue></then></if>
<for>for (<init><expr><name>j</name> = 0</expr>;</init> <condition><expr><name>j</name> &lt; <name><name>xx_state</name><index>[<expr><name>i</name></expr>]</index></name>.<name>ss_narcs</name></expr>;</condition> <incr><expr><name>j</name>++</expr></incr>) <block>{
<if>if <condition>(<expr><name><name>xx_state</name><index>[<expr><name>i</name></expr>]</index></name>.<name><name>ss_arc</name><index>[<expr><name>j</name></expr>]</index></name>.<name>sa_arrow</name> == <name>from</name></expr>)</condition><then>
<expr_stmt><expr><name><name>xx_state</name><index>[<expr><name>i</name></expr>]</index></name>.<name><name>ss_arc</name><index>[<expr><name>j</name></expr>]</index></name>.<name>sa_arrow</name> = <name>to</name></expr>;</expr_stmt></then></if>
}</block></for>
}</block></for>
}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>simplify</name><parameter_list>(<param><decl><type><name>int</name></type> <name>xx_nstates</name></decl></param>, <param><decl><type><name>ss_state</name> *</type><name>xx_state</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>changes</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>
<do>do <block>{
<expr_stmt><expr><name>changes</name> = 0</expr>;</expr_stmt>
<for>for (<init><expr><name>i</name> = 1</expr>;</init> <condition><expr><name>i</name> &lt; <name>xx_nstates</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
<if>if <condition>(<expr><name><name>xx_state</name><index>[<expr><name>i</name></expr>]</index></name>.<name>ss_deleted</name></expr>)</condition><then>
<continue>continue;</continue></then></if>
<for>for (<init><expr><name>j</name> = 0</expr>;</init> <condition><expr><name>j</name> &lt; <name>i</name></expr>;</condition> <incr><expr><name>j</name>++</expr></incr>) <block>{
<if>if <condition>(<expr><name><name>xx_state</name><index>[<expr><name>j</name></expr>]</index></name>.<name>ss_deleted</name></expr>)</condition><then>
<continue>continue;</continue></then></if>
<if>if <condition>(<expr><call><name>samestate</name><argument_list>(<argument><expr>&amp;<name><name>xx_state</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr>&amp;<name><name>xx_state</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>xx_state</name><index>[<expr><name>i</name></expr>]</index></name>.<name>ss_deleted</name>++</expr>;</expr_stmt>
<expr_stmt><expr><call><name>renamestates</name><argument_list>(<argument><expr><name>xx_nstates</name></expr></argument>, <argument><expr><name>xx_state</name></expr></argument>,
<argument><expr><name>i</name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>changes</name>++</expr>;</expr_stmt>
<break>break;</break>
}</block></then></if>
}</block></for>
}</block></for>
}</block> while <condition>(<expr><name>changes</name></expr>)</condition>;</do>
}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>convert</name><parameter_list>(<param><decl><type><name>dfa</name> *</type><name>d</name></decl></param>, <param><decl><type><name>int</name></type> <name>xx_nstates</name></decl></param>, <param><decl><type><name>ss_state</name> *</type><name>xx_state</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ss_state</name> *</type><name>yy</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ss_arc</name> *</type><name>zz</name></decl>;</decl_stmt>
<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>xx_nstates</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
<expr_stmt><expr><name>yy</name> = &amp;<name><name>xx_state</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>yy</name>-&gt;<name>ss_deleted</name></name></expr>)</condition><then>
<continue>continue;</continue></then></if>
<expr_stmt><expr><name><name>yy</name>-&gt;<name>ss_rename</name></name> = <call><name>addstate</name><argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></for>
<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>xx_nstates</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
<expr_stmt><expr><name>yy</name> = &amp;<name><name>xx_state</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>yy</name>-&gt;<name>ss_deleted</name></name></expr>)</condition><then>
<continue>continue;</continue></then></if>
<for>for (<init><expr><name>j</name> = 0</expr>;</init> <condition><expr><name>j</name> &lt; <name><name>yy</name>-&gt;<name>ss_narcs</name></name></expr>;</condition> <incr><expr><name>j</name>++</expr></incr>) <block>{
<expr_stmt><expr><name>zz</name> = &amp;<name><name>yy</name>-&gt;<name>ss_arc</name><index>[<expr><name>j</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>addarc</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr><name><name>yy</name>-&gt;<name>ss_rename</name></name></expr></argument>,
<argument><expr><name><name>xx_state</name><index>[<expr><name><name>zz</name>-&gt;<name>sa_arrow</name></name></expr>]</index></name>.<name>ss_rename</name></expr></argument>,
<argument><expr><name><name>zz</name>-&gt;<name>sa_label</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></for>
<if>if <condition>(<expr><name><name>yy</name>-&gt;<name>ss_finish</name></name></expr>)</condition><then>
<expr_stmt><expr><call><name>addarc</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr><name><name>yy</name>-&gt;<name>ss_rename</name></name></expr></argument>, <argument><expr><name><name>yy</name>-&gt;<name>ss_rename</name></name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
}</block></for>
<expr_stmt><expr><name><name>d</name>-&gt;<name>d_initial</name></name> = 0</expr>;</expr_stmt>
}</block></function>
<function><type><specifier>static</specifier> <name>grammar</name> *</type>
<name>maketables</name><parameter_list>(<param><decl><type><name>nfagrammar</name> *</type><name>gr</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>nfa</name> *</type><name>nf</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>dfa</name> *</type><name>d</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>grammar</name> *</type><name>g</name></decl>;</decl_stmt>
<if>if <condition>(<expr><name><name>gr</name>-&gt;<name>gr_nnfas</name></name> == 0</expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>g</name> = <call><name>newgrammar</name><argument_list>(<argument><expr><name><name>gr</name>-&gt;<name>gr_nfa</name><index>[<expr>0</expr>]</index></name>-&gt;<name>nf_type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>g</name>-&gt;<name>g_ll</name></name> = <name><name>gr</name>-&gt;<name>gr_ll</name></name></expr>;</expr_stmt>
<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name><name>gr</name>-&gt;<name>gr_nnfas</name></name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
<expr_stmt><expr><name>nf</name> = <name><name>gr</name>-&gt;<name>gr_nfa</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
<if>if <condition>(<expr><name>Py_DebugFlag</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>"Dump of NFA for '%s' ...\n"</expr></argument>, <argument><expr><name><name>nf</name>-&gt;<name>nf_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>dumpnfa</name><argument_list>(<argument><expr>&amp;<name><name>gr</name>-&gt;<name>gr_ll</name></name></expr></argument>, <argument><expr><name>nf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>"Making DFA for '%s' ...\n"</expr></argument>, <argument><expr><name><name>nf</name>-&gt;<name>nf_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><name>d</name> = <call><name>adddfa</name><argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><name><name>nf</name>-&gt;<name>nf_type</name></name></expr></argument>, <argument><expr><name><name>nf</name>-&gt;<name>nf_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>makedfa</name><argument_list>(<argument><expr><name>gr</name></expr></argument>, <argument><expr><name><name>gr</name>-&gt;<name>gr_nfa</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></for>
<return>return <expr><name>g</name></expr>;</return>
}</block></function>
<function><type><name>grammar</name> *</type>
<name>pgen</name><parameter_list>(<param><decl><type><name>node</name> *</type><name>n</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>nfagrammar</name> *</type><name>gr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>grammar</name> *</type><name>g</name></decl>;</decl_stmt>
<expr_stmt><expr><name>gr</name> = <call><name>metacompile</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>g</name> = <call><name>maketables</name><argument_list>(<argument><expr><name>gr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>translatelabels</name><argument_list>(<argument><expr><name>g</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>addfirstsets</name><argument_list>(<argument><expr><name>g</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyObject_FREE</name><argument_list>(<argument><expr><name>gr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>g</name></expr>;</return>
}</block></function>
<function><type><name>grammar</name> *</type>
<name>Py_pgen</name><parameter_list>(<param><decl><type><name>node</name> *</type><name>n</name></decl></param>)</parameter_list> <block>{
<return>return <expr><call><name>pgen</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
</unit>
