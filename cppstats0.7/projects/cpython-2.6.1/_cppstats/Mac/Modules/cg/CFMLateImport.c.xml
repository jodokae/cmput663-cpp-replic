<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C" filename="projects/cpython-2.6.1/_cppstats/Mac/Modules/cg/CFMLateImport.c"><cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MoreAssert</name><parameter_list>(<param><type><name>x</name></type></param>)</parameter_list></cpp:macro> <cpp:value>(true)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MoreAssertQ</name><parameter_list>(<param><type><name>x</name></type></param>)</parameter_list></cpp:macro></cpp:define>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>! <name>MORE_FRAMEWORK_INCLUDES</name></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;CodeFragments.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;PEFBinaryFormat.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string.h&gt;</cpp:file></cpp:include>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MoreBlockZero</name></cpp:macro> <cpp:value>BlockZero</cpp:value></cpp:define>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"CFMLateImport.h"</cpp:file></cpp:include>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>TARGET_RT_MAC_MACHO</name></expr></cpp:if>
<cpp:error>#<cpp:directive>error</cpp:directive> CFMLateImport is not suitable for use in a Mach-O project.</cpp:error>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr>!<name>TARGET_RT_MAC_CFM</name> || !<name>TARGET_CPU_PPC</name></expr></cpp:elif>
<cpp:error>#<cpp:directive>error</cpp:directive> CFMLateImport has not been qualified for 68K or CFM-68K use.</cpp:error>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:pragma>#<cpp:directive>pragma</cpp:directive> mark ----- Utility Routines -----</cpp:pragma>
<function><type><specifier>static</specifier> <name>OSStatus</name></type> <name>FSReadAtOffset</name><parameter_list>(<param><decl><type><name>SInt16</name></type> <name>refNum</name></decl></param>, <param><decl><type><name>SInt32</name></type> <name>offset</name></decl></param>, <param><decl><type><name>SInt32</name></type> <name>count</name></decl></param>, <param><decl><type><name>void</name> *</type><name>buffer</name></decl></param>)</parameter_list>
<block>{
<decl_stmt><decl><type><name>ParamBlockRec</name></type> <name>pb</name></decl>;</decl_stmt>
<expr_stmt><expr><name><name>pb</name>.<name>ioParam</name>.<name>ioRefNum</name></name> = <name>refNum</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>pb</name>.<name>ioParam</name>.<name>ioBuffer</name></name> = (<name>Ptr</name>) <name>buffer</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>pb</name>.<name>ioParam</name>.<name>ioReqCount</name></name> = <name>count</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>pb</name>.<name>ioParam</name>.<name>ioPosMode</name></name> = <name>fsFromStart</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>pb</name>.<name>ioParam</name>.<name>ioPosOffset</name></name> = <name>offset</name></expr>;</expr_stmt>
<return>return <expr><call><name>PBReadSync</name><argument_list>(<argument><expr>&amp;<name>pb</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<cpp:pragma>#<cpp:directive>pragma</cpp:directive> mark ----- Late Import Engine -----</cpp:pragma>
<struct>struct <name>FragToFixInfo</name> <block>{
<decl_stmt><decl><type><name>CFragSystem7DiskFlatLocator</name></type> <name>locator</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>CFragConnectionID</name></type> <name>connID</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>CFragInitFunction</name></type> <name>initRoutine</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PEFContainerHeader</name></type> <name>containerHeader</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PEFSectionHeader</name> *</type><name>sectionHeaders</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PEFLoaderInfoHeader</name> *</type><name>loaderSection</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>SInt16</name></type> <name>fileRef</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>void</name> *</type><name>section0Base</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>void</name> *</type><name>section1Base</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Boolean</name></type> <name>disposeSectionPointers</name></decl>;</decl_stmt>
}</block>;</struct>
<typedef>typedef <type>struct <name>FragToFixInfo</name></type> <name>FragToFixInfo</name>;</typedef>
<function><type><specifier>static</specifier> <name>OSStatus</name></type> <name>ReadContainerBasics</name><parameter_list>(<param><decl><type><name>FragToFixInfo</name> *</type><name>fragToFix</name></decl></param>)</parameter_list>
<block>{
<decl_stmt><decl><type><name>OSStatus</name></type> <name>err</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>UInt16</name></type> <name>sectionIndex</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Boolean</name></type> <name>found</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>MoreAssertQ</name><argument_list>(<argument><expr><name>fragToFix</name> != <name>nil</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>MoreAssertQ</name><argument_list>(<argument><expr><name><name>fragToFix</name>-&gt;<name>locator</name>.<name>fileSpec</name></name> != <name>nil</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>MoreAssertQ</name><argument_list>(<argument><expr><name><name>fragToFix</name>-&gt;<name>connID</name></name> != <name>nil</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>MoreAssertQ</name><argument_list>(<argument><expr><name><name>fragToFix</name>-&gt;<name>loaderSection</name></name> == <name>nil</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>MoreAssertQ</name><argument_list>(<argument><expr><name><name>fragToFix</name>-&gt;<name>sectionHeaders</name></name> == <name>nil</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>MoreAssertQ</name><argument_list>(<argument><expr><name><name>fragToFix</name>-&gt;<name>fileRef</name></name> == 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>fragToFix</name>-&gt;<name>disposeSectionPointers</name></name> = <name>true</name></expr>;</expr_stmt>
<expr_stmt><expr><name>err</name> = <call><name>FSpOpenDF</name><argument_list>(<argument><expr><name><name>fragToFix</name>-&gt;<name>locator</name>.<name>fileSpec</name></name></expr></argument>, <argument><expr><name>fsRdPerm</name></expr></argument>, <argument><expr>&amp;<name><name>fragToFix</name>-&gt;<name>fileRef</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>err</name> == <name>noErr</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>err</name> = <call><name>FSReadAtOffset</name><argument_list>(<argument><expr><name><name>fragToFix</name>-&gt;<name>fileRef</name></name></expr></argument>,
<argument><expr><name><name>fragToFix</name>-&gt;<name>locator</name>.<name>offset</name></name></expr></argument>,
<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>fragToFix</name>-&gt;<name>containerHeader</name></name></expr></argument>)</argument_list></sizeof></expr></argument>,
<argument><expr>&amp;<name><name>fragToFix</name>-&gt;<name>containerHeader</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>err</name> == <name>noErr</name></expr>)</condition><then> <block>{
<if>if <condition>( <expr><name><name>fragToFix</name>-&gt;<name>containerHeader</name>.<name>tag1</name></name> != <name>kPEFTag1</name>
|| <name><name>fragToFix</name>-&gt;<name>containerHeader</name>.<name>tag2</name></name> != <name>kPEFTag2</name>
|| <name><name>fragToFix</name>-&gt;<name>containerHeader</name>.<name>architecture</name></name> != <name>kCompiledCFragArch</name>
|| <name><name>fragToFix</name>-&gt;<name>containerHeader</name>.<name>formatVersion</name></name> != <name>kPEFVersion</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>err</name> = <name>cfragFragmentFormatErr</name></expr>;</expr_stmt>
}</block></then></if>
}</block></then></if>
<if>if <condition>(<expr><name>err</name> == <name>noErr</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>fragToFix</name>-&gt;<name>sectionHeaders</name></name> = (<name>PEFSectionHeader</name> *) <call><name>NewPtr</name><argument_list>(<argument><expr><name><name>fragToFix</name>-&gt;<name>containerHeader</name>.<name>sectionCount</name></name> * <sizeof>sizeof<argument_list>(<argument><expr><name>PEFSectionHeader</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>err</name> = <call><name>MemError</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<if>if <condition>(<expr><name>err</name> == <name>noErr</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>err</name> = <call><name>FSReadAtOffset</name><argument_list>(<argument><expr><name><name>fragToFix</name>-&gt;<name>fileRef</name></name></expr></argument>,
<argument><expr><name><name>fragToFix</name>-&gt;<name>locator</name>.<name>offset</name></name> + <sizeof>sizeof<argument_list>(<argument><expr><name><name>fragToFix</name>-&gt;<name>containerHeader</name></name></expr></argument>)</argument_list></sizeof></expr></argument>,
<argument><expr><name><name>fragToFix</name>-&gt;<name>containerHeader</name>.<name>sectionCount</name></name> * <sizeof>sizeof<argument_list>(<argument><expr><name>PEFSectionHeader</name></expr></argument>)</argument_list></sizeof></expr></argument>,
<argument><expr><name><name>fragToFix</name>-&gt;<name>sectionHeaders</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<if>if <condition>(<expr><name>err</name> == <name>noErr</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>sectionIndex</name> = 0</expr>;</expr_stmt>
<expr_stmt><expr><name>found</name> = <name>false</name></expr>;</expr_stmt>
<while>while <condition>( <expr><name>sectionIndex</name> &lt; <name><name>fragToFix</name>-&gt;<name>containerHeader</name>.<name>sectionCount</name></name> &amp;&amp; ! <name>found</name></expr> )</condition> <block>{
<expr_stmt><expr><name>found</name> = (<name><name>fragToFix</name>-&gt;<name>sectionHeaders</name><index>[<expr><name>sectionIndex</name></expr>]</index></name>.<name>sectionKind</name> == <name>kPEFLoaderSection</name>)</expr>;</expr_stmt>
<if>if <condition>( <expr>! <name>found</name></expr> )</condition><then> <block>{
<expr_stmt><expr><name>sectionIndex</name> += 1</expr>;</expr_stmt>
}</block></then></if>
}</block></while>
}</block></then></if>
<if>if <condition>(<expr><name>err</name> == <name>noErr</name> &amp;&amp; ! <name>found</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>err</name> = <name>cfragNoSectionErr</name></expr>;</expr_stmt>
}</block></then></if>
<if>if <condition>(<expr><name>err</name> == <name>noErr</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>fragToFix</name>-&gt;<name>loaderSection</name></name> = (<name>PEFLoaderInfoHeader</name> *) <call><name>NewPtr</name><argument_list>(<argument><expr><name><name>fragToFix</name>-&gt;<name>sectionHeaders</name><index>[<expr><name>sectionIndex</name></expr>]</index></name>.<name>containerLength</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>err</name> = <call><name>MemError</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<if>if <condition>(<expr><name>err</name> == <name>noErr</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>err</name> = <call><name>FSReadAtOffset</name><argument_list>(<argument><expr><name><name>fragToFix</name>-&gt;<name>fileRef</name></name></expr></argument>,
<argument><expr><name><name>fragToFix</name>-&gt;<name>locator</name>.<name>offset</name></name> + <name><name>fragToFix</name>-&gt;<name>sectionHeaders</name><index>[<expr><name>sectionIndex</name></expr>]</index></name>.<name>containerOffset</name></expr></argument>,
<argument><expr><name><name>fragToFix</name>-&gt;<name>sectionHeaders</name><index>[<expr><name>sectionIndex</name></expr>]</index></name>.<name>containerLength</name></expr></argument>,
<argument><expr><name><name>fragToFix</name>-&gt;<name>loaderSection</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
}</block></then></if>
<return>return <expr><name>err</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>UInt32</name></type> <name>DecodeVCountValue</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>UInt8</name> *</type><name>start</name></decl></param>, <param><decl><type><name>UInt32</name> *</type><name>outCount</name></decl></param>)</parameter_list>
<block>{
<decl_stmt><decl><type><name>UInt8</name> *</type> <name>bytePtr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>UInt8</name></type> <name>byte</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>UInt32</name></type> <name>count</name></decl>;</decl_stmt>
<expr_stmt><expr><name>bytePtr</name> = (<name>UInt8</name> *)<name>start</name></expr>;</expr_stmt>
<expr_stmt><expr><name>count</name> = 0</expr>;</expr_stmt>
<do>do <block>{
<expr_stmt><expr><name>byte</name> = *<name>bytePtr</name>++</expr>;</expr_stmt>
<expr_stmt><expr><name>count</name> = (<name>count</name> &lt;&lt; <name>kPEFPkDataVCountShift</name>) | (<name>byte</name> &amp; <name>kPEFPkDataVCountMask</name>)</expr>;</expr_stmt>
}</block> while <condition>(<expr>(<name>byte</name> &amp; <name>kPEFPkDataVCountEndMask</name>) != 0</expr>)</condition>;</do>
<expr_stmt><expr>*<name>outCount</name> = <name>count</name></expr>;</expr_stmt>
<return>return <expr><name>bytePtr</name> - <name>start</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>UInt32</name></type> <name>DecodeInstrCountValue</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>UInt8</name> *</type><name>inOpStart</name></decl></param>, <param><decl><type><name>UInt32</name> *</type><name>outCount</name></decl></param>)</parameter_list>
<block>{
<expr_stmt><expr><call><name>MoreAssertQ</name><argument_list>(<argument><expr><name>inOpStart</name> != <name>nil</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>MoreAssertQ</name><argument_list>(<argument><expr><name>outCount</name> != <name>nil</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>PEFPkDataCount5</name><argument_list>(<argument><expr>*<name>inOpStart</name></expr></argument>)</argument_list></call> != 0</expr>)</condition><then> <block>{
<expr_stmt><expr>*<name>outCount</name> = <call><name>PEFPkDataCount5</name><argument_list>(<argument><expr>*<name>inOpStart</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>1</expr>;</return>
}</block></then> <else>else <block>{
<return>return <expr>1 + <call><name>DecodeVCountValue</name><argument_list>(<argument><expr><name>inOpStart</name> + 1</expr></argument>, <argument><expr><name>outCount</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></else></if>
}</block></function>
<function><type><specifier>static</specifier> <name>OSStatus</name></type> <name>UnpackPEFDataSection</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>UInt8</name> * <specifier>const</specifier></type> <name>packedData</name></decl></param>, <param><decl><type><name>UInt32</name></type> <name>packedSize</name></decl></param>,
<param><decl><type><name>UInt8</name> * <specifier>const</specifier></type> <name>unpackedData</name></decl></param>, <param><decl><type><name>UInt32</name></type> <name>unpackedSize</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>OSErr</name></type> <name>err</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>UInt32</name></type> <name>offset</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>UInt8</name></type> <name>opCode</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>UInt8</name> *</type> <name>unpackCursor</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>MoreAssertQ</name><argument_list>(<argument><expr><name>packedData</name> != <name>nil</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>MoreAssertQ</name><argument_list>(<argument><expr><name>unpackedData</name> != <name>nil</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>MoreAssertQ</name><argument_list>(<argument><expr><name>unpackedSize</name> &gt;= <name>packedSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>MoreAssertQ</name><argument_list>( <argument><expr><name>packedSize</name> == <call><name>GetPtrSize</name><argument_list>( <argument><expr>(<name>Ptr</name>) <name>packedData</name></expr></argument> )</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>MoreAssertQ</name><argument_list>( <argument><expr><name>unpackedSize</name> == <call><name>GetPtrSize</name><argument_list>( <argument><expr>(<name>Ptr</name>) <name>unpackedData</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>err</name> = <name>noErr</name></expr>;</expr_stmt>
<expr_stmt><expr><name>offset</name> = 0</expr>;</expr_stmt>
<expr_stmt><expr><name>unpackCursor</name> = <name>unpackedData</name></expr>;</expr_stmt>
<while>while <condition>(<expr><name>offset</name> &lt; <name>packedSize</name></expr>)</condition> <block>{
<expr_stmt><expr><call><name>MoreAssertQ</name><argument_list>(<argument><expr><name>unpackCursor</name> &lt; &amp;<name><name>unpackedData</name><index>[<expr><name>unpackedSize</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>opCode</name> = <name><name>packedData</name><index>[<expr><name>offset</name></expr>]</index></name></expr>;</expr_stmt>
<switch>switch <condition>(<expr><call><name>PEFPkDataOpcode</name><argument_list>(<argument><expr><name>opCode</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{
<case>case <expr><name>kPEFPkDataZero</name></expr>: <block>{
<decl_stmt><decl><type><name>UInt32</name></type> <name>count</name></decl>;</decl_stmt>
<expr_stmt><expr><name>offset</name> += <call><name>DecodeInstrCountValue</name><argument_list>(<argument><expr>&amp;<name><name>packedData</name><index>[<expr><name>offset</name></expr>]</index></name></expr></argument>, <argument><expr>&amp;<name>count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>MoreBlockZero</name><argument_list>(<argument><expr><name>unpackCursor</name></expr></argument>, <argument><expr><name>count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>unpackCursor</name> += <name>count</name></expr>;</expr_stmt>
}</block>
<break>break;</break>
</case><case>case <expr><name>kPEFPkDataBlock</name></expr>: <block>{
<decl_stmt><decl><type><name>UInt32</name></type> <name>blockSize</name></decl>;</decl_stmt>
<expr_stmt><expr><name>offset</name> += <call><name>DecodeInstrCountValue</name><argument_list>(<argument><expr>&amp;<name><name>packedData</name><index>[<expr><name>offset</name></expr>]</index></name></expr></argument>, <argument><expr>&amp;<name>blockSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>BlockMoveData</name><argument_list>(<argument><expr>&amp;<name><name>packedData</name><index>[<expr><name>offset</name></expr>]</index></name></expr></argument>, <argument><expr><name>unpackCursor</name></expr></argument>, <argument><expr><name>blockSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>unpackCursor</name> += <name>blockSize</name></expr>;</expr_stmt>
<expr_stmt><expr><name>offset</name> += <name>blockSize</name></expr>;</expr_stmt>
}</block>
<break>break;</break>
</case><case>case <expr><name>kPEFPkDataRepeat</name></expr>: <block>{
<decl_stmt><decl><type><name>UInt32</name></type> <name>blockSize</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>UInt32</name></type> <name>repeatCount</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>UInt32</name></type> <name>loopCounter</name></decl>;</decl_stmt>
<expr_stmt><expr><name>offset</name> += <call><name>DecodeInstrCountValue</name><argument_list>(<argument><expr>&amp;<name><name>packedData</name><index>[<expr><name>offset</name></expr>]</index></name></expr></argument>, <argument><expr>&amp;<name>blockSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>offset</name> += <call><name>DecodeVCountValue</name><argument_list>(<argument><expr>&amp;<name><name>packedData</name><index>[<expr><name>offset</name></expr>]</index></name></expr></argument>, <argument><expr>&amp;<name>repeatCount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>repeatCount</name> += 1</expr>;</expr_stmt>
<for>for (<init><expr><name>loopCounter</name> = 0</expr>;</init> <condition><expr><name>loopCounter</name> &lt; <name>repeatCount</name></expr>;</condition> <incr><expr><name>loopCounter</name>++</expr></incr>) <block>{
<expr_stmt><expr><call><name>BlockMoveData</name><argument_list>(<argument><expr>&amp;<name><name>packedData</name><index>[<expr><name>offset</name></expr>]</index></name></expr></argument>, <argument><expr><name>unpackCursor</name></expr></argument>, <argument><expr><name>blockSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>unpackCursor</name> += <name>blockSize</name></expr>;</expr_stmt>
}</block></for>
<expr_stmt><expr><name>offset</name> += <name>blockSize</name></expr>;</expr_stmt>
}</block>
<break>break;</break>
</case><case>case <expr><name>kPEFPkDataRepeatBlock</name></expr>: <block>{
<decl_stmt><decl><type><name>UInt32</name></type> <name>commonSize</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>UInt32</name></type> <name>customSize</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>UInt32</name></type> <name>repeatCount</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>UInt8</name> *</type><name>commonData</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>UInt8</name> *</type><name>customData</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>UInt32</name></type> <name>loopCounter</name></decl>;</decl_stmt>
<expr_stmt><expr><name>offset</name> += <call><name>DecodeInstrCountValue</name><argument_list>(<argument><expr>&amp;<name><name>packedData</name><index>[<expr><name>offset</name></expr>]</index></name></expr></argument>, <argument><expr>&amp;<name>commonSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>offset</name> += <call><name>DecodeVCountValue</name><argument_list>(<argument><expr>&amp;<name><name>packedData</name><index>[<expr><name>offset</name></expr>]</index></name></expr></argument>, <argument><expr>&amp;<name>customSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>offset</name> += <call><name>DecodeVCountValue</name><argument_list>(<argument><expr>&amp;<name><name>packedData</name><index>[<expr><name>offset</name></expr>]</index></name></expr></argument>, <argument><expr>&amp;<name>repeatCount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>commonData</name> = &amp;<name><name>packedData</name><index>[<expr><name>offset</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name>customData</name> = &amp;<name><name>packedData</name><index>[<expr><name>offset</name> + <name>commonSize</name></expr>]</index></name></expr>;</expr_stmt>
<for>for (<init><expr><name>loopCounter</name> = 0</expr>;</init> <condition><expr><name>loopCounter</name> &lt; <name>repeatCount</name></expr>;</condition> <incr><expr><name>loopCounter</name>++</expr></incr>) <block>{
<expr_stmt><expr><call><name>BlockMoveData</name><argument_list>(<argument><expr><name>commonData</name></expr></argument>, <argument><expr><name>unpackCursor</name></expr></argument>, <argument><expr><name>commonSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>unpackCursor</name> += <name>commonSize</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>BlockMoveData</name><argument_list>(<argument><expr><name>customData</name></expr></argument>, <argument><expr><name>unpackCursor</name></expr></argument>, <argument><expr><name>customSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>unpackCursor</name> += <name>customSize</name></expr>;</expr_stmt>
<expr_stmt><expr><name>customData</name> += <name>customSize</name></expr>;</expr_stmt>
}</block></for>
<expr_stmt><expr><call><name>BlockMoveData</name><argument_list>(<argument><expr><name>commonData</name></expr></argument>, <argument><expr><name>unpackCursor</name></expr></argument>, <argument><expr><name>commonSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>unpackCursor</name> += <name>commonSize</name></expr>;</expr_stmt>
<expr_stmt><expr><name>offset</name> += (<call><name>repeatCount</name> * <argument_list>(<argument><expr><name>commonSize</name> + <name>customSize</name></expr></argument>)</argument_list></call>) + <name>commonSize</name></expr>;</expr_stmt>
}</block>
<break>break;</break>
</case><case>case <expr><name>kPEFPkDataRepeatZero</name></expr>: <block>{
<decl_stmt><decl><type><name>UInt32</name></type> <name>commonSize</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>UInt32</name></type> <name>customSize</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>UInt32</name></type> <name>repeatCount</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>UInt8</name> *</type><name>customData</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>UInt32</name></type> <name>loopCounter</name></decl>;</decl_stmt>
<expr_stmt><expr><name>offset</name> += <call><name>DecodeInstrCountValue</name><argument_list>(<argument><expr>&amp;<name><name>packedData</name><index>[<expr><name>offset</name></expr>]</index></name></expr></argument>, <argument><expr>&amp;<name>commonSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>offset</name> += <call><name>DecodeVCountValue</name><argument_list>(<argument><expr>&amp;<name><name>packedData</name><index>[<expr><name>offset</name></expr>]</index></name></expr></argument>, <argument><expr>&amp;<name>customSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>offset</name> += <call><name>DecodeVCountValue</name><argument_list>(<argument><expr>&amp;<name><name>packedData</name><index>[<expr><name>offset</name></expr>]</index></name></expr></argument>, <argument><expr>&amp;<name>repeatCount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>customData</name> = &amp;<name><name>packedData</name><index>[<expr><name>offset</name></expr>]</index></name></expr>;</expr_stmt>
<for>for (<init><expr><name>loopCounter</name> = 0</expr>;</init> <condition><expr><name>loopCounter</name> &lt; <name>repeatCount</name></expr>;</condition> <incr><expr><name>loopCounter</name>++</expr></incr>) <block>{
<expr_stmt><expr><call><name>MoreBlockZero</name><argument_list>(<argument><expr><name>unpackCursor</name></expr></argument>, <argument><expr><name>commonSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>unpackCursor</name> += <name>commonSize</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>BlockMoveData</name><argument_list>(<argument><expr><name>customData</name></expr></argument>, <argument><expr><name>unpackCursor</name></expr></argument>, <argument><expr><name>customSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>unpackCursor</name> += <name>customSize</name></expr>;</expr_stmt>
<expr_stmt><expr><name>customData</name> += <name>customSize</name></expr>;</expr_stmt>
}</block></for>
<expr_stmt><expr><call><name>MoreBlockZero</name><argument_list>(<argument><expr><name>unpackCursor</name></expr></argument>, <argument><expr><name>commonSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>unpackCursor</name> += <name>commonSize</name></expr>;</expr_stmt>
<expr_stmt><expr><name>offset</name> += <name>repeatCount</name> * <name>customSize</name></expr>;</expr_stmt>
}</block>
<break>break;</break>
</case><default>default:
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>MORE_DEBUG</name></expr></cpp:if>
<expr_stmt><expr><call><name>DebugStr</name><argument_list>(<argument><expr>"\pUnpackPEFDataSection: Unexpected data opcode"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><name>err</name> = <name>cfragFragmentCorruptErr</name></expr>;</expr_stmt>
<goto>goto <name>leaveNow</name>;</goto>
<break>break;</break>
</default>}</block></switch>
}</block></while>
<label><name>leaveNow</name>:</label>
<return>return <expr><name>err</name></expr>;</return>
}</block></function>
<struct>struct <name>TVector</name> <block>{
<decl_stmt><decl><type><name>void</name> *</type><name>codePtr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>void</name> *</type><name>tocPtr</name></decl>;</decl_stmt>
}</block>;</struct>
<typedef>typedef <type>struct <name>TVector</name></type> <name>TVector</name>;</typedef>
<function><type><specifier>static</specifier> <name>OSStatus</name></type> <name>SetupSectionBaseAddresses</name><parameter_list>(<param><decl><type><name>FragToFixInfo</name> *</type><name>fragToFix</name></decl></param>)</parameter_list>
<block>{
<decl_stmt><decl><type><name>OSStatus</name></type> <name>err</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>TVector</name> *</type> <name>relocatedExport</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>SInt32</name></type> <name>initSection</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>UInt32</name></type> <name>initOffset</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PEFSectionHeader</name> *</type> <name>initSectionHeader</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Ptr</name></type> <name>packedDataSection</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Ptr</name></type> <name>unpackedDataSection</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>TVector</name></type> <name>originalOffsets</name></decl>;</decl_stmt>
<expr_stmt><expr><name>packedDataSection</name> = <name>nil</name></expr>;</expr_stmt>
<expr_stmt><expr><name>unpackedDataSection</name> = <name>nil</name></expr>;</expr_stmt>
<expr_stmt><expr><name>relocatedExport</name> = (<name>TVector</name> *) <name><name>fragToFix</name>-&gt;<name>initRoutine</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>err</name> = <name>noErr</name></expr>;</expr_stmt>
<expr_stmt><expr><name>initSection</name> = <name><name>fragToFix</name>-&gt;<name>loaderSection</name>-&gt;<name>initSection</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>initOffset</name> = <name><name>fragToFix</name>-&gt;<name>loaderSection</name>-&gt;<name>initOffset</name></name></expr>;</expr_stmt>
<if>if <condition>(<expr><name>initSection</name> == -1</expr>)</condition><then> <block>{
<expr_stmt><expr><name>err</name> = <name>cfragFragmentUsageErr</name></expr>;</expr_stmt>
}</block></then></if>
<if>if <condition>(<expr><name>err</name> == <name>noErr</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>MoreAssertQ</name><argument_list>( <argument><expr><name>initSection</name> &gt;= 0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>MoreAssertQ</name><argument_list>( <argument><expr><name>initSection</name> &lt; <name><name>fragToFix</name>-&gt;<name>containerHeader</name>.<name>sectionCount</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>initSectionHeader</name> = &amp;<name><name>fragToFix</name>-&gt;<name>sectionHeaders</name><index>[<expr><name>initSection</name></expr>]</index></name></expr>;</expr_stmt>
<if>if <condition>( <expr><name><name>initSectionHeader</name>-&gt;<name>sectionKind</name></name> == <name>kPEFPackedDataSection</name></expr> )</condition><then> <block>{
<expr_stmt><expr><name>packedDataSection</name> = <call><name>NewPtr</name><argument_list>(<argument><expr><name><name>initSectionHeader</name>-&gt;<name>containerLength</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>err</name> = <call><name>MemError</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>err</name> == <name>noErr</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>unpackedDataSection</name> = <call><name>NewPtr</name><argument_list>(<argument><expr><name><name>initSectionHeader</name>-&gt;<name>unpackedLength</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>err</name> = <call><name>MemError</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<if>if <condition>(<expr><name>err</name> == <name>noErr</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>err</name> = <call><name>FSReadAtOffset</name><argument_list>( <argument><expr><name><name>fragToFix</name>-&gt;<name>fileRef</name></name></expr></argument>,
<argument><expr><name><name>fragToFix</name>-&gt;<name>locator</name>.<name>offset</name></name>
+ <name><name>initSectionHeader</name>-&gt;<name>containerOffset</name></name></expr></argument>,
<argument><expr><name><name>initSectionHeader</name>-&gt;<name>containerLength</name></name></expr></argument>,
<argument><expr><name>packedDataSection</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<if>if <condition>(<expr><name>err</name> == <name>noErr</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>err</name> = <call><name>UnpackPEFDataSection</name><argument_list>( <argument><expr>(<name>UInt8</name> *) <name>packedDataSection</name></expr></argument>, <argument><expr><name><name>initSectionHeader</name>-&gt;<name>containerLength</name></name></expr></argument>,
<argument><expr>(<name>UInt8</name> *) <name>unpackedDataSection</name></expr></argument>, <argument><expr><name><name>initSectionHeader</name>-&gt;<name>unpackedLength</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<if>if <condition>(<expr><name>err</name> == <name>noErr</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>BlockMoveData</name><argument_list>(<argument><expr><name>unpackedDataSection</name> + <name>initOffset</name></expr></argument>, <argument><expr>&amp;<name>originalOffsets</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>TVector</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
}</block></then> <else>else <block>{
<expr_stmt><expr><call><name>MoreAssertQ</name><argument_list>(<argument><expr><name><name>fragToFix</name>-&gt;<name>sectionHeaders</name><index>[<expr><name>initSection</name></expr>]</index></name>.<name>sectionKind</name> == <name>kPEFUnpackedDataSection</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>err</name> = <call><name>FSReadAtOffset</name><argument_list>(<argument><expr><name><name>fragToFix</name>-&gt;<name>fileRef</name></name></expr></argument>,
<argument><expr><name><name>fragToFix</name>-&gt;<name>locator</name>.<name>offset</name></name>
+ <name><name>fragToFix</name>-&gt;<name>sectionHeaders</name><index>[<expr><name>initSection</name></expr>]</index></name>.<name>containerOffset</name>
+ <name>initOffset</name></expr></argument>,
<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>TVector</name></expr></argument>)</argument_list></sizeof></expr></argument>,
<argument><expr>&amp;<name>originalOffsets</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></else></if>
}</block></then></if>
<if>if <condition>(<expr><name>err</name> == <name>noErr</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>fragToFix</name>-&gt;<name>section0Base</name></name> = ((<name>char</name> *) <name><name>relocatedExport</name>-&gt;<name>codePtr</name></name>) - (<name>UInt32</name>) <name><name>originalOffsets</name>.<name>codePtr</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>fragToFix</name>-&gt;<name>section1Base</name></name> = ((<name>char</name> *) <name><name>relocatedExport</name>-&gt;<name>tocPtr</name></name>) - (<name>UInt32</name>) <name><name>originalOffsets</name>.<name>tocPtr</name></name></expr>;</expr_stmt>
}</block></then></if>
<if>if <condition>(<expr><name>packedDataSection</name> != <name>nil</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>DisposePtr</name><argument_list>(<argument><expr><name>packedDataSection</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>MoreAssertQ</name><argument_list>( <argument><expr><call><name>MemError</name><argument_list>()</argument_list></call> == <name>noErr</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<if>if <condition>(<expr><name>unpackedDataSection</name> != <name>nil</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>DisposePtr</name><argument_list>(<argument><expr><name>unpackedDataSection</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>MoreAssertQ</name><argument_list>( <argument><expr><call><name>MemError</name><argument_list>()</argument_list></call> == <name>noErr</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<return>return <expr><name>err</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>void</name> *</type><name>GetSectionBaseAddress</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>FragToFixInfo</name> *</type><name>fragToFix</name></decl></param>, <param><decl><type><name>UInt16</name></type> <name>sectionIndex</name></decl></param>)</parameter_list>
<block>{
<decl_stmt><decl><type><name>void</name> *</type><name>result</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>MoreAssertQ</name><argument_list>(<argument><expr><name>fragToFix</name> != <name>nil</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>MoreAssertQ</name><argument_list>(<argument><expr><name><name>fragToFix</name>-&gt;<name>containerHeader</name>.<name>tag1</name></name> == <name>kPEFTag1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<switch>switch <condition>(<expr><name>sectionIndex</name></expr>)</condition> <block>{
<case>case <expr>0</expr>:
<expr_stmt><expr><name>result</name> = <name><name>fragToFix</name>-&gt;<name>section0Base</name></name></expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr>1</expr>:
<expr_stmt><expr><name>result</name> = <name><name>fragToFix</name>-&gt;<name>section1Base</name></name></expr>;</expr_stmt>
<break>break;</break>
</case><default>default:
<expr_stmt><expr><name>result</name> = <name>nil</name></expr>;</expr_stmt>
<break>break;</break>
</default>}</block></switch>
<return>return <expr><name>result</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>OSStatus</name></type> <name>FindImportLibrary</name><parameter_list>(<param><decl><type><name>PEFLoaderInfoHeader</name> *</type><name>loaderSection</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>libraryName</name></decl></param>, <param><decl><type><name>PEFImportedLibrary</name> **</type><name>importLibrary</name></decl></param>)</parameter_list>
<block>{
<decl_stmt><decl><type><name>OSStatus</name></type> <name>err</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>UInt32</name></type> <name>librariesRemaining</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PEFImportedLibrary</name> *</type><name>thisImportLibrary</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Boolean</name></type> <name>found</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>MoreAssertQ</name><argument_list>(<argument><expr><name>loaderSection</name> != <name>nil</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>MoreAssertQ</name><argument_list>(<argument><expr><name>libraryName</name> != <name>nil</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>MoreAssertQ</name><argument_list>(<argument><expr><name>importLibrary</name> != <name>nil</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>thisImportLibrary</name> = <call>(<name>PEFImportedLibrary</name> *) <argument_list>(<argument><expr><name>loaderSection</name> + 1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>librariesRemaining</name> = <name><name>loaderSection</name>-&gt;<name>importedLibraryCount</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>found</name> = <name>false</name></expr>;</expr_stmt>
<while>while <condition>( <expr><name>librariesRemaining</name> &gt; 0 &amp;&amp; ! <name>found</name></expr> )</condition> <block>{
<expr_stmt><expr><name>found</name> = (<call><name>strcmp</name><argument_list>( <argument><expr><name>libraryName</name></expr></argument>,
<argument><expr>((<name>char</name> *)<name>loaderSection</name>)
+ <name><name>loaderSection</name>-&gt;<name>loaderStringsOffset</name></name>
+ <name><name>thisImportLibrary</name>-&gt;<name>nameOffset</name></name></expr></argument>)</argument_list></call> == 0)</expr>;</expr_stmt>
<if>if <condition>( <expr>! <name>found</name></expr> )</condition><then> <block>{
<expr_stmt><expr><name>thisImportLibrary</name> += 1</expr>;</expr_stmt>
<expr_stmt><expr><name>librariesRemaining</name> -= 1</expr>;</expr_stmt>
}</block></then></if>
}</block></while>
<if>if <condition>(<expr><name>found</name></expr>)</condition><then> <block>{
<expr_stmt><expr>*<name>importLibrary</name> = <name>thisImportLibrary</name></expr>;</expr_stmt>
<expr_stmt><expr><name>err</name> = <name>noErr</name></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr>*<name>importLibrary</name> = <name>nil</name></expr>;</expr_stmt>
<expr_stmt><expr><name>err</name> = <name>cfragNoLibraryErr</name></expr>;</expr_stmt>
}</block></else></if>
<return>return <expr><name>err</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>OSStatus</name></type> <name>LookupSymbol</name><parameter_list>(<param><decl><type><name>CFMLateImportLookupProc</name></type> <name>lookup</name></decl></param>, <param><decl><type><name>void</name> *</type><name>refCon</name></decl></param>,
<param><decl><type><name>PEFLoaderInfoHeader</name> *</type><name>loaderSection</name></decl></param>,
<param><decl><type><name>UInt32</name></type> <name>symbolIndex</name></decl></param>,
<param><decl><type><name>UInt32</name> *</type><name>symbolValue</name></decl></param>)</parameter_list>
<block>{
<decl_stmt><decl><type><name>OSStatus</name></type> <name>err</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>UInt32</name> *</type><name>importSymbolTable</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>UInt32</name></type> <name>symbolStringOffset</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Boolean</name></type> <name>symbolIsWeak</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>CFragSymbolClass</name></type> <name>symbolClass</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>symbolStringAddress</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Str255</name></type> <name>symbolString</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>MoreAssertQ</name><argument_list>(<argument><expr><name>lookup</name> != <name>nil</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>MoreAssertQ</name><argument_list>(<argument><expr><name>loaderSection</name> != <name>nil</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>MoreAssertQ</name><argument_list>(<argument><expr><name>symbolIndex</name> &lt; <name><name>loaderSection</name>-&gt;<name>totalImportedSymbolCount</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>MoreAssertQ</name><argument_list>(<argument><expr><name>symbolValue</name> != <name>nil</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>importSymbolTable</name> = <call>(<name>UInt32</name> *)<argument_list>(<argument><expr>(<call>(<name>char</name> *)<argument_list>(<argument><expr><name>loaderSection</name> + 1</expr></argument>)</argument_list></call>) + (<name><name>loaderSection</name>-&gt;<name>importedLibraryCount</name></name> * <sizeof>sizeof<argument_list>(<argument><expr><name>PEFImportedLibrary</name></expr></argument>)</argument_list></sizeof>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>symbolStringOffset</name> = <name><name>importSymbolTable</name><index>[<expr><name>symbolIndex</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name>symbolClass</name> = <call><name>PEFImportedSymbolClass</name><argument_list>(<argument><expr><name>symbolStringOffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>symbolIsWeak</name> = ((<name>symbolClass</name> &amp; <name>kPEFWeakImportSymMask</name>) != 0)</expr>;</expr_stmt>
<expr_stmt><expr><name>symbolClass</name> = <name>symbolClass</name> &amp; ~<name>kPEFWeakImportSymMask</name></expr>;</expr_stmt>
<expr_stmt><expr><name>symbolStringOffset</name> = <call><name>PEFImportedSymbolNameOffset</name><argument_list>(<argument><expr><name>symbolStringOffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>symbolStringAddress</name> = ((<name>char</name> *)<name>loaderSection</name>) + <name><name>loaderSection</name>-&gt;<name>loaderStringsOffset</name></name> + <name>symbolStringOffset</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>symbolString</name><index>[<expr>0</expr>]</index></name> = <call><name>strlen</name><argument_list>(<argument><expr><name>symbolStringAddress</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>BlockMoveData</name><argument_list>(<argument><expr><name>symbolStringAddress</name></expr></argument>, <argument><expr>&amp;<name><name>symbolString</name><index>[<expr>1</expr>]</index></name></expr></argument>, <argument><expr><name><name>symbolString</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>err</name> = <call><name>lookup</name><argument_list>(<argument><expr><name>symbolString</name></expr></argument>, <argument><expr><name>symbolClass</name></expr></argument>, <argument><expr>(<name>void</name> **) <name>symbolValue</name></expr></argument>, <argument><expr><name>refCon</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>err</name> != <name>noErr</name></expr>)</condition><then> <block>{
<expr_stmt><expr>*<name>symbolValue</name> = 0</expr>;</expr_stmt>
<if>if <condition>(<expr><name>symbolIsWeak</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>err</name> = <name>noErr</name></expr>;</expr_stmt>
}</block></then></if>
}</block></then></if>
<return>return <expr><name>err</name></expr>;</return>
}</block></function>
<struct>struct <name>EngineState</name> <block>{
<decl_stmt><decl><type><name>UInt32</name></type> <name>currentReloc</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>UInt32</name></type> <name>terminatingReloc</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>UInt32</name> *</type><name>sectionBase</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>UInt32</name> *</type><name>relocAddress</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>UInt32</name></type> <name>importIndex</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>void</name> *</type><name>sectionC</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>void</name> *</type><name>sectionD</name></decl>;</decl_stmt>
}</block>;</struct>
<typedef>typedef <type>struct <name>EngineState</name></type> <name>EngineState</name>;</typedef>
<function><type><specifier>static</specifier> <name>OSStatus</name></type> <name>InitEngineState</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>FragToFixInfo</name> *</type><name>fragToFix</name></decl></param>,
<param><decl><type><name>UInt16</name></type> <name>relocHeaderIndex</name></decl></param>,
<param><decl><type><name>EngineState</name> *</type><name>state</name></decl></param>)</parameter_list>
<block>{
<decl_stmt><decl><type><name>OSStatus</name></type> <name>err</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PEFLoaderRelocationHeader</name> *</type><name>relocHeader</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>MoreAssertQ</name><argument_list>(<argument><expr><name>fragToFix</name> != <name>nil</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>MoreAssertQ</name><argument_list>(<argument><expr><name>state</name> != <name>nil</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>relocHeader</name> = <call>(<name>PEFLoaderRelocationHeader</name> *) <argument_list>(<argument><expr>((<name>char</name> *) <name><name>fragToFix</name>-&gt;<name>loaderSection</name></name>) + <name><name>fragToFix</name>-&gt;<name>loaderSection</name>-&gt;<name>relocInstrOffset</name></name> - <name>relocHeaderIndex</name> * <sizeof>sizeof<argument_list>(<argument><expr><name>PEFLoaderRelocationHeader</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>MoreAssertQ</name><argument_list>(<argument><expr><name><name>relocHeader</name>-&gt;<name>reservedA</name></name> == 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>state</name>-&gt;<name>currentReloc</name></name> = <name><name>relocHeader</name>-&gt;<name>firstRelocOffset</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>state</name>-&gt;<name>terminatingReloc</name></name> = <name><name>relocHeader</name>-&gt;<name>firstRelocOffset</name></name> + <name><name>relocHeader</name>-&gt;<name>relocCount</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>state</name>-&gt;<name>sectionBase</name></name> = (<name>UInt32</name> *) <call><name>GetSectionBaseAddress</name><argument_list>(<argument><expr><name>fragToFix</name></expr></argument>, <argument><expr><name><name>relocHeader</name>-&gt;<name>sectionIndex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>state</name>-&gt;<name>relocAddress</name></name> = <name><name>state</name>-&gt;<name>sectionBase</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>state</name>-&gt;<name>importIndex</name></name> = 0</expr>;</expr_stmt>
<expr_stmt><expr><name><name>state</name>-&gt;<name>sectionC</name></name> = <call><name>GetSectionBaseAddress</name><argument_list>(<argument><expr><name>fragToFix</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>state</name>-&gt;<name>sectionC</name></name> != <name>nil</name></expr>)</condition><then> <block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>MORE_DEBUG</name></expr></cpp:if>
<if>if <condition>(<expr><name><name>fragToFix</name>-&gt;<name>sectionHeaders</name><index>[<expr>0</expr>]</index></name>.<name>defaultAddress</name> != 0</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>DebugStr</name><argument_list>(<argument><expr>"\pInitEngineState: Executing weird case."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr>(<name>char</name> *) <name><name>state</name>-&gt;<name>sectionC</name></name> -= <name><name>fragToFix</name>-&gt;<name>sectionHeaders</name><index>[<expr>0</expr>]</index></name>.<name>defaultAddress</name></expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><name><name>state</name>-&gt;<name>sectionD</name></name> = <call><name>GetSectionBaseAddress</name><argument_list>(<argument><expr><name>fragToFix</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>state</name>-&gt;<name>sectionD</name></name> != <name>nil</name></expr>)</condition><then> <block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>MORE_DEBUG</name></expr></cpp:if>
<if>if <condition>(<expr><name><name>fragToFix</name>-&gt;<name>sectionHeaders</name><index>[<expr>1</expr>]</index></name>.<name>defaultAddress</name> != 0</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>DebugStr</name><argument_list>(<argument><expr>"\pInitEngineState: Executing weird case."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr>(<name>char</name> *) <name><name>state</name>-&gt;<name>sectionD</name></name> -= <name><name>fragToFix</name>-&gt;<name>sectionHeaders</name><index>[<expr>1</expr>]</index></name>.<name>defaultAddress</name></expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><name>err</name> = <name>noErr</name></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>state</name>-&gt;<name>relocAddress</name></name> == <name>nil</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>err</name> = <name>cfragFragmentUsageErr</name></expr>;</expr_stmt>
}</block></then></if>
<return>return <expr><name>err</name></expr>;</return>
}</block></function>
<decl_stmt><decl><type><specifier>static</specifier> <name>UInt8</name></type> <name><name>kPEFRelocBasicOpcodes</name><index>[<expr><name>kPEFRelocBasicOpcodeRange</name></expr>]</index></name> <init>= <expr><block>{ <expr><name>PEFMaskedBasicOpcodes</name></expr> }</block></expr></init></decl>;</decl_stmt>
<function><type><specifier>static</specifier> <name>OSStatus</name></type> <name>RunRelocationEngine</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>FragToFixInfo</name> *</type><name>fragToFix</name></decl></param>,
<param><decl><type><name>PEFImportedLibrary</name> *</type><name>importLibrary</name></decl></param>,
<param><decl><type><name>CFMLateImportLookupProc</name></type> <name>lookup</name></decl></param>, <param><decl><type><name>void</name> *</type><name>refCon</name></decl></param>)</parameter_list>
<block>{
<decl_stmt><decl><type><name>OSStatus</name></type> <name>err</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>EngineState</name></type> <name>state</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>UInt16</name></type> <name>sectionsLeftToRelocate</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>UInt32</name></type> <name>totalRelocs</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>UInt16</name> *</type><name>relocInstrTable</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>UInt16</name></type> <name>opCode</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>MoreAssertQ</name><argument_list>(<argument><expr><name>fragToFix</name> != <name>nil</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>MoreAssertQ</name><argument_list>(<argument><expr><name><name>fragToFix</name>-&gt;<name>containerHeader</name>.<name>tag1</name></name> == <name>kPEFTag1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>MoreAssertQ</name><argument_list>(<argument><expr><name><name>fragToFix</name>-&gt;<name>sectionHeaders</name></name> != <name>nil</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>MoreAssertQ</name><argument_list>(<argument><expr><name><name>fragToFix</name>-&gt;<name>loaderSection</name></name> != <name>nil</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>MoreAssertQ</name><argument_list>(<argument><expr><name><name>fragToFix</name>-&gt;<name>section0Base</name></name> != <name>nil</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>MoreAssertQ</name><argument_list>(<argument><expr><name><name>fragToFix</name>-&gt;<name>section1Base</name></name> != <name>nil</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>MoreAssertQ</name><argument_list>(<argument><expr><name>importLibrary</name> != <name>nil</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>MoreAssertQ</name><argument_list>(<argument><expr><name>lookup</name> != <name>nil</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>totalRelocs</name> = (<name><name>fragToFix</name>-&gt;<name>loaderSection</name>-&gt;<name>loaderStringsOffset</name></name> - <name><name>fragToFix</name>-&gt;<name>loaderSection</name>-&gt;<name>relocInstrOffset</name></name>) / <sizeof>sizeof<argument_list>(<argument><expr><name>UInt16</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
<expr_stmt><expr><name>relocInstrTable</name> = <call>(<name>UInt16</name> *)<argument_list>(<argument><expr>(<name>char</name> *) <name><name>fragToFix</name>-&gt;<name>loaderSection</name></name> + <name><name>fragToFix</name>-&gt;<name>loaderSection</name>-&gt;<name>relocInstrOffset</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>MoreAssertQ</name><argument_list>(<argument><expr><name><name>fragToFix</name>-&gt;<name>loaderSection</name>-&gt;<name>relocSectionCount</name></name> &lt;= 0x0FFFF</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>sectionsLeftToRelocate</name> = <name><name>fragToFix</name>-&gt;<name>loaderSection</name>-&gt;<name>relocSectionCount</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>err</name> = <name>noErr</name></expr>;</expr_stmt>
<while>while <condition>( <expr><name>sectionsLeftToRelocate</name> &gt; 0</expr> )</condition> <block>{
<expr_stmt><expr><name>err</name> = <call><name>InitEngineState</name><argument_list>(<argument><expr><name>fragToFix</name></expr></argument>, <argument><expr><name>sectionsLeftToRelocate</name></expr></argument>, <argument><expr>&amp;<name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>err</name> != <name>noErr</name></expr>)</condition><then> <block>{
<goto>goto <name>leaveNow</name>;</goto>
}</block></then></if>
<while>while <condition>( <expr><name><name>state</name>.<name>currentReloc</name></name> != <name><name>state</name>.<name>terminatingReloc</name></name></expr> )</condition> <block>{
<expr_stmt><expr><call><name>MoreAssertQ</name><argument_list>( <argument><expr><name><name>state</name>.<name>currentReloc</name></name> &lt; <name>totalRelocs</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>opCode</name> = <name><name>relocInstrTable</name><index>[<expr><name><name>state</name>.<name>currentReloc</name></name></expr>]</index></name></expr>;</expr_stmt>
<switch>switch <condition>( <expr><call><name>PEFRelocBasicOpcode</name><argument_list>(<argument><expr><name>opCode</name></expr></argument>)</argument_list></call></expr> )</condition> <block>{
<case>case <expr><name>kPEFRelocBySectDWithSkip</name></expr>: <block>{
<decl_stmt><decl><type><name>UInt16</name></type> <name>skipCount</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>UInt16</name></type> <name>relocCount</name></decl>;</decl_stmt>
<expr_stmt><expr><name>skipCount</name> = ((<name>opCode</name> &gt;&gt; 6) &amp; 0x00FF)</expr>;</expr_stmt>
<expr_stmt><expr><name>relocCount</name> = (<name>opCode</name> &amp; 0x003F)</expr>;</expr_stmt>
<expr_stmt><expr><name><name>state</name>.<name>relocAddress</name></name> += <name>skipCount</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>state</name>.<name>relocAddress</name></name> += <name>relocCount</name></expr>;</expr_stmt>
}</block>
<break>break;</break>
</case><case>case <expr><name>kPEFRelocBySectC</name></expr>:
</case><case>case <expr><name>kPEFRelocBySectD</name></expr>: <block>{
<decl_stmt><decl><type><name>UInt16</name></type> <name>runLength</name></decl>;</decl_stmt>
<expr_stmt><expr><name>runLength</name> = (<name>opCode</name> &amp; 0x01FF) + 1</expr>;</expr_stmt>
<expr_stmt><expr><name><name>state</name>.<name>relocAddress</name></name> += <name>runLength</name></expr>;</expr_stmt>
}</block>
<break>break;</break>
</case><case>case <expr><name>kPEFRelocTVector12</name></expr>: <block>{
<decl_stmt><decl><type><name>UInt16</name></type> <name>runLength</name></decl>;</decl_stmt>
<expr_stmt><expr><name>runLength</name> = (<name>opCode</name> &amp; 0x01FF) + 1</expr>;</expr_stmt>
<expr_stmt><expr><name><name>state</name>.<name>relocAddress</name></name> += (<name>runLength</name> * 3)</expr>;</expr_stmt>
}</block>
<break>break;</break>
</case><case>case <expr><name>kPEFRelocTVector8</name></expr>:
</case><case>case <expr><name>kPEFRelocVTable8</name></expr>: <block>{
<decl_stmt><decl><type><name>UInt16</name></type> <name>runLength</name></decl>;</decl_stmt>
<expr_stmt><expr><name>runLength</name> = (<name>opCode</name> &amp; 0x01FF) + 1</expr>;</expr_stmt>
<expr_stmt><expr><name><name>state</name>.<name>relocAddress</name></name> += (<name>runLength</name> * 2)</expr>;</expr_stmt>
}</block>
<break>break;</break>
</case><case>case <expr><name>kPEFRelocImportRun</name></expr>: <block>{
<decl_stmt><decl><type><name>UInt32</name></type> <name>symbolValue</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>UInt16</name></type> <name>runLength</name></decl>;</decl_stmt>
<expr_stmt><expr><name>runLength</name> = (<name>opCode</name> &amp; 0x01FF) + 1</expr>;</expr_stmt>
<while>while <condition>(<expr><name>runLength</name> &gt; 0</expr>)</condition> <block>{
<if>if <condition>( <expr><name><name>state</name>.<name>importIndex</name></name> &gt;= <name><name>importLibrary</name>-&gt;<name>firstImportedSymbol</name></name> &amp;&amp; <name><name>state</name>.<name>importIndex</name></name> &lt; (<name><name>importLibrary</name>-&gt;<name>firstImportedSymbol</name></name> + <name><name>importLibrary</name>-&gt;<name>importedSymbolCount</name></name>)</expr> )</condition><then> <block>{
<expr_stmt><expr><name>err</name> = <call><name>LookupSymbol</name><argument_list>(<argument><expr><name>lookup</name></expr></argument>, <argument><expr><name>refCon</name></expr></argument>, <argument><expr><name><name>fragToFix</name>-&gt;<name>loaderSection</name></name></expr></argument>, <argument><expr><name><name>state</name>.<name>importIndex</name></name></expr></argument>, <argument><expr>&amp;<name>symbolValue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>err</name> != <name>noErr</name></expr>)</condition><then> <block>{
<goto>goto <name>leaveNow</name>;</goto>
}</block></then></if>
<expr_stmt><expr>*(<name><name>state</name>.<name>relocAddress</name></name>) += <name>symbolValue</name></expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><name><name>state</name>.<name>importIndex</name></name> += 1</expr>;</expr_stmt>
<expr_stmt><expr><name><name>state</name>.<name>relocAddress</name></name> += 1</expr>;</expr_stmt>
<expr_stmt><expr><name>runLength</name> -= 1</expr>;</expr_stmt>
}</block></while>
}</block>
<break>break;</break>
</case><case>case <expr><name>kPEFRelocSmByImport</name></expr>: <block>{
<decl_stmt><decl><type><name>UInt32</name></type> <name>symbolValue</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>UInt32</name></type> <name>index</name></decl>;</decl_stmt>
<expr_stmt><expr><name>index</name> = (<name>opCode</name> &amp; 0x01FF)</expr>;</expr_stmt>
<if>if <condition>( <expr><name>index</name> &gt;= <name><name>importLibrary</name>-&gt;<name>firstImportedSymbol</name></name> &amp;&amp; <name>index</name> &lt; (<name><name>importLibrary</name>-&gt;<name>firstImportedSymbol</name></name> + <name><name>importLibrary</name>-&gt;<name>importedSymbolCount</name></name>)</expr> )</condition><then> <block>{
<expr_stmt><expr><name>err</name> = <call><name>LookupSymbol</name><argument_list>(<argument><expr><name>lookup</name></expr></argument>, <argument><expr><name>refCon</name></expr></argument>, <argument><expr><name><name>fragToFix</name>-&gt;<name>loaderSection</name></name></expr></argument>, <argument><expr><name>index</name></expr></argument>, <argument><expr>&amp;<name>symbolValue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>err</name> != <name>noErr</name></expr>)</condition><then> <block>{
<goto>goto <name>leaveNow</name>;</goto>
}</block></then></if>
<expr_stmt><expr>*(<name><name>state</name>.<name>relocAddress</name></name>) += <name>symbolValue</name></expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><name><name>state</name>.<name>importIndex</name></name> = <name>index</name> + 1</expr>;</expr_stmt>
<expr_stmt><expr><name><name>state</name>.<name>relocAddress</name></name> += 1</expr>;</expr_stmt>
}</block>
<break>break;</break>
</case><case>case <expr><name>kPEFRelocSmSetSectC</name></expr>: <block>{
<decl_stmt><decl><type><name>UInt32</name></type> <name>index</name></decl>;</decl_stmt>
<expr_stmt><expr><name>index</name> = (<name>opCode</name> &amp; 0x01FF)</expr>;</expr_stmt>
<expr_stmt><expr><name><name>state</name>.<name>sectionC</name></name> = <call><name>GetSectionBaseAddress</name><argument_list>(<argument><expr><name>fragToFix</name></expr></argument>, <argument><expr><name>index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>MoreAssertQ</name><argument_list>(<argument><expr><name><name>state</name>.<name>sectionC</name></name> != <name>nil</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block>
<break>break;</break>
</case><case>case <expr><name>kPEFRelocSmSetSectD</name></expr>: <block>{
<decl_stmt><decl><type><name>UInt32</name></type> <name>index</name></decl>;</decl_stmt>
<expr_stmt><expr><name>index</name> = (<name>opCode</name> &amp; 0x01FF)</expr>;</expr_stmt>
<expr_stmt><expr><name><name>state</name>.<name>sectionD</name></name> = <call><name>GetSectionBaseAddress</name><argument_list>(<argument><expr><name>fragToFix</name></expr></argument>, <argument><expr><name>index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>MoreAssertQ</name><argument_list>(<argument><expr><name><name>state</name>.<name>sectionD</name></name> != <name>nil</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block>
<break>break;</break>
</case><case>case <expr><name>kPEFRelocSmBySection</name></expr>:
<expr_stmt><expr><name><name>state</name>.<name>relocAddress</name></name> += 1</expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr><name>kPEFRelocIncrPosition</name></expr>: <block>{
<decl_stmt><decl><type><name>UInt16</name></type> <name>offset</name></decl>;</decl_stmt>
<expr_stmt><expr><name>offset</name> = (<name>opCode</name> &amp; 0x0FFF) + 1</expr>;</expr_stmt>
<expr_stmt><expr>((<name>char</name> *) <name><name>state</name>.<name>relocAddress</name></name>) += <name>offset</name></expr>;</expr_stmt>
}</block>
<break>break;</break>
</case><case>case <expr><name>kPEFRelocSmRepeat</name></expr>:
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>MORE_DEBUG</name></expr></cpp:if>
<expr_stmt><expr><call><name>DebugStr</name><argument_list>(<argument><expr>"\pRunRelocationEngine: kPEFRelocSmRepeat not yet implemented"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><name>err</name> = <name>unimpErr</name></expr>;</expr_stmt>
<goto>goto <name>leaveNow</name>;</goto>
<break>break;</break>
</case><case>case <expr><name>kPEFRelocSetPosition</name></expr>: <block>{
<decl_stmt><decl><type><name>UInt32</name></type> <name>offset</name></decl>;</decl_stmt>
<expr_stmt><expr><name><name>state</name>.<name>currentReloc</name></name> += 1</expr>;</expr_stmt>
<expr_stmt><expr><name>offset</name> = <call><name>PEFRelocSetPosFullOffset</name><argument_list>(<argument><expr><name>opCode</name></expr></argument>, <argument><expr><name><name>relocInstrTable</name><index>[<expr><name><name>state</name>.<name>currentReloc</name></name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>state</name>.<name>relocAddress</name></name> = <call>(<name>UInt32</name> *) <argument_list>( <argument><expr>((<name>char</name> *) <name><name>state</name>.<name>sectionBase</name></name>) + <name>offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block>
<break>break;</break>
</case><case>case <expr><name>kPEFRelocLgByImport</name></expr>: <block>{
<decl_stmt><decl><type><name>UInt32</name></type> <name>symbolValue</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>UInt32</name></type> <name>index</name></decl>;</decl_stmt>
<expr_stmt><expr><name><name>state</name>.<name>currentReloc</name></name> += 1</expr>;</expr_stmt>
<expr_stmt><expr><name>index</name> = <call><name>PEFRelocLgByImportFullIndex</name><argument_list>(<argument><expr><name>opCode</name></expr></argument>, <argument><expr><name><name>relocInstrTable</name><index>[<expr><name><name>state</name>.<name>currentReloc</name></name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>( <expr><name>index</name> &gt;= <name><name>importLibrary</name>-&gt;<name>firstImportedSymbol</name></name> &amp;&amp; <name>index</name> &lt; (<name><name>importLibrary</name>-&gt;<name>firstImportedSymbol</name></name> + <name><name>importLibrary</name>-&gt;<name>importedSymbolCount</name></name>)</expr> )</condition><then> <block>{
<expr_stmt><expr><name>err</name> = <call><name>LookupSymbol</name><argument_list>(<argument><expr><name>lookup</name></expr></argument>, <argument><expr><name>refCon</name></expr></argument>, <argument><expr><name><name>fragToFix</name>-&gt;<name>loaderSection</name></name></expr></argument>, <argument><expr><name>index</name></expr></argument>, <argument><expr>&amp;<name>symbolValue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>err</name> != <name>noErr</name></expr>)</condition><then> <block>{
<goto>goto <name>leaveNow</name>;</goto>
}</block></then></if>
<expr_stmt><expr>*(<name><name>state</name>.<name>relocAddress</name></name>) += <name>symbolValue</name></expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><name><name>state</name>.<name>importIndex</name></name> = <name>index</name> + 1</expr>;</expr_stmt>
<expr_stmt><expr><name><name>state</name>.<name>relocAddress</name></name> += 1</expr>;</expr_stmt>
}</block>
<break>break;</break>
</case><case>case <expr><name>kPEFRelocLgRepeat</name></expr>:
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>MORE_DEBUG</name></expr></cpp:if>
<expr_stmt><expr><call><name>DebugStr</name><argument_list>(<argument><expr>"\pRunRelocationEngine: kPEFRelocLgRepeat not yet implemented"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><name>err</name> = <name>unimpErr</name></expr>;</expr_stmt>
<goto>goto <name>leaveNow</name>;</goto>
<break>break;</break>
</case><case>case <expr><name>kPEFRelocLgSetOrBySection</name></expr>:
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>MORE_DEBUG</name></expr></cpp:if>
<expr_stmt><expr><call><name>DebugStr</name><argument_list>(<argument><expr>"\pRunRelocationEngine: kPEFRelocLgSetOrBySection not yet implemented"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><name>err</name> = <name>unimpErr</name></expr>;</expr_stmt>
<goto>goto <name>leaveNow</name>;</goto>
<break>break;</break>
</case><case>case <expr><name>kPEFRelocUndefinedOpcode</name></expr>:
<expr_stmt><expr><name>err</name> = <name>cfragFragmentCorruptErr</name></expr>;</expr_stmt>
<goto>goto <name>leaveNow</name>;</goto>
<break>break;</break>
</case><default>default:
<expr_stmt><expr><call><name>MoreAssertQ</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>err</name> = <name>cfragFragmentCorruptErr</name></expr>;</expr_stmt>
<goto>goto <name>leaveNow</name>;</goto>
<break>break;</break>
</default>}</block></switch>
<expr_stmt><expr><name><name>state</name>.<name>currentReloc</name></name> += 1</expr>;</expr_stmt>
}</block></while>
<expr_stmt><expr><name>sectionsLeftToRelocate</name> -= 1</expr>;</expr_stmt>
}</block></while>
<label><name>leaveNow</name>:</label>
<return>return <expr><name>err</name></expr>;</return>
}</block></function>
<function><type><specifier>extern</specifier> <name>pascal</name> <name>OSStatus</name></type> <name>CFMLateImportCore</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>CFragSystem7DiskFlatLocator</name> *</type><name>fragToFixLocator</name></decl></param>,
<param><decl><type><name>CFragConnectionID</name></type> <name>fragToFixConnID</name></decl></param>,
<param><decl><type><name>CFragInitFunction</name></type> <name>fragToFixInitRoutine</name></decl></param>,
<param><decl><type><name>ConstStr255Param</name></type> <name>weakLinkedLibraryName</name></decl></param>,
<param><decl><type><name>CFMLateImportLookupProc</name></type> <name>lookup</name></decl></param>,
<param><decl><type><name>void</name> *</type><name>refCon</name></decl></param>)</parameter_list>
<block>{
<decl_stmt><decl><type><name>OSStatus</name></type> <name>err</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>OSStatus</name></type> <name>junk</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>FragToFixInfo</name></type> <name>fragToFix</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PEFImportedLibrary</name> *</type><name>importLibrary</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name><name>weakLinkedLibraryNameCString</name><index>[<expr>256</expr>]</index></name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>MoreAssertQ</name><argument_list>(<argument><expr><name>fragToFixLocator</name> != <name>nil</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>MoreAssertQ</name><argument_list>(<argument><expr><name>fragToFixConnID</name> != <name>nil</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>MoreAssertQ</name><argument_list>(<argument><expr><name>fragToFixInitRoutine</name> != <name>nil</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>MoreAssertQ</name><argument_list>(<argument><expr><name>weakLinkedLibraryName</name> != <name>nil</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>MoreAssertQ</name><argument_list>(<argument><expr><name>lookup</name> != <name>nil</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>MoreBlockZero</name><argument_list>(<argument><expr>&amp;<name>fragToFix</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>fragToFix</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>fragToFix</name>.<name>locator</name></name> = *<name>fragToFixLocator</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>fragToFix</name>.<name>connID</name></name> = <name>fragToFixConnID</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>fragToFix</name>.<name>initRoutine</name></name> = <name>fragToFixInitRoutine</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>BlockMoveData</name><argument_list>(<argument><expr><name>weakLinkedLibraryName</name> + 1</expr></argument>, <argument><expr><name>weakLinkedLibraryNameCString</name></expr></argument>, <argument><expr><name><name>weakLinkedLibraryName</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>weakLinkedLibraryNameCString</name><index>[<expr><name><name>weakLinkedLibraryName</name><index>[<expr>0</expr>]</index></name></expr>]</index></name> = 0</expr>;</expr_stmt>
<expr_stmt><expr><name>err</name> = <call><name>ReadContainerBasics</name><argument_list>(<argument><expr>&amp;<name>fragToFix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>err</name> == <name>noErr</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>err</name> = <call><name>SetupSectionBaseAddresses</name><argument_list>(<argument><expr>&amp;<name>fragToFix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<if>if <condition>(<expr><name>err</name> == <name>noErr</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>err</name> = <call><name>FindImportLibrary</name><argument_list>(<argument><expr><name><name>fragToFix</name>.<name>loaderSection</name></name></expr></argument>, <argument><expr><name>weakLinkedLibraryNameCString</name></expr></argument>, <argument><expr>&amp;<name>importLibrary</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<if>if <condition>(<expr><name>err</name> == <name>noErr</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr>(<name><name>importLibrary</name>-&gt;<name>options</name></name> &amp; <name>kPEFWeakImportLibMask</name>) == 0</expr>)</condition><then> <block>{
<expr_stmt><expr><name>err</name> = <name>cfragFragmentUsageErr</name></expr>;</expr_stmt>
}</block></then></if>
}</block></then></if>
<if>if <condition>(<expr><name>err</name> == <name>noErr</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>err</name> = <call><name>RunRelocationEngine</name><argument_list>(<argument><expr>&amp;<name>fragToFix</name></expr></argument>, <argument><expr><name>importLibrary</name></expr></argument>, <argument><expr><name>lookup</name></expr></argument>, <argument><expr><name>refCon</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<if>if <condition>(<expr><name><name>fragToFix</name>.<name>disposeSectionPointers</name></name></expr>)</condition><then> <block>{
<if>if <condition>(<expr><name><name>fragToFix</name>.<name>fileRef</name></name> != 0</expr>)</condition><then> <block>{
<expr_stmt><expr><name>junk</name> = <call><name>FSClose</name><argument_list>(<argument><expr><name><name>fragToFix</name>.<name>fileRef</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>MoreAssertQ</name><argument_list>(<argument><expr><name>junk</name> == <name>noErr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<if>if <condition>(<expr><name><name>fragToFix</name>.<name>loaderSection</name></name> != <name>nil</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>DisposePtr</name><argument_list>( <argument><expr>(<name>Ptr</name>) <name><name>fragToFix</name>.<name>loaderSection</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>MoreAssertQ</name><argument_list>(<argument><expr><call><name>MemError</name><argument_list>()</argument_list></call> == <name>noErr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<if>if <condition>(<expr><name><name>fragToFix</name>.<name>sectionHeaders</name></name> != <name>nil</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>DisposePtr</name><argument_list>( <argument><expr>(<name>Ptr</name>) <name><name>fragToFix</name>.<name>sectionHeaders</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>MoreAssertQ</name><argument_list>(<argument><expr><call><name>MemError</name><argument_list>()</argument_list></call> == <name>noErr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
}</block></then></if>
<return>return <expr><name>err</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>pascal</name> <name>OSStatus</name></type> <name>FragmentLookup</name><parameter_list>(<param><decl><type><name>ConstStr255Param</name></type> <name>symName</name></decl></param>, <param><decl><type><name>CFragSymbolClass</name></type> <name>symClass</name></decl></param>,
<param><decl><type><name>void</name> **</type><name>symAddr</name></decl></param>, <param><decl><type><name>void</name> *</type><name>refCon</name></decl></param>)</parameter_list>
<block>{
<decl_stmt><decl><type><name>OSStatus</name></type> <name>err</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>CFragConnectionID</name></type> <name>connIDToImport</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>CFragSymbolClass</name></type> <name>foundSymClass</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>MoreAssertQ</name><argument_list>(<argument><expr><name>symName</name> != <name>nil</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>MoreAssertQ</name><argument_list>(<argument><expr><name>symAddr</name> != <name>nil</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>MoreAssertQ</name><argument_list>(<argument><expr><name>refCon</name> != <name>nil</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>connIDToImport</name> = (<name>CFragConnectionID</name>) <name>refCon</name></expr>;</expr_stmt>
<expr_stmt><expr><name>err</name> = <call><name>FindSymbol</name><argument_list>(<argument><expr><name>connIDToImport</name></expr></argument>, <argument><expr><name>symName</name></expr></argument>, <argument><expr>(<name>Ptr</name> *) <name>symAddr</name></expr></argument>, <argument><expr>&amp;<name>foundSymClass</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>err</name> == <name>noErr</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr><name>foundSymClass</name> != <name>symClass</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>MoreAssertQ</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr>*<name>symAddr</name> = <name>nil</name></expr>;</expr_stmt>
<expr_stmt><expr><name>err</name> = <name>cfragNoSymbolErr</name></expr>;</expr_stmt>
}</block></then></if>
}</block></then></if>
<return>return <expr><name>err</name></expr>;</return>
}</block></function>
<function><type><specifier>extern</specifier> <name>pascal</name> <name>OSStatus</name></type> <name>CFMLateImportLibrary</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>CFragSystem7DiskFlatLocator</name> *</type><name>fragToFixLocator</name></decl></param>,
<param><decl><type><name>CFragConnectionID</name></type> <name>fragToFixConnID</name></decl></param>,
<param><decl><type><name>CFragInitFunction</name></type> <name>fragToFixInitRoutine</name></decl></param>,
<param><decl><type><name>ConstStr255Param</name></type> <name>weakLinkedLibraryName</name></decl></param>,
<param><decl><type><name>CFragConnectionID</name></type> <name>connIDToImport</name></decl></param>)</parameter_list>
<block>{
<expr_stmt><expr><call><name>MoreAssertQ</name><argument_list>(<argument><expr><name>connIDToImport</name> != <name>nil</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>CFMLateImportCore</name><argument_list>(<argument><expr><name>fragToFixLocator</name></expr></argument>, <argument><expr><name>fragToFixConnID</name></expr></argument>, <argument><expr><name>fragToFixInitRoutine</name></expr></argument>,
<argument><expr><name>weakLinkedLibraryName</name></expr></argument>, <argument><expr><name>FragmentLookup</name></expr></argument>, <argument><expr><name>connIDToImport</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>pascal</name> <name>OSStatus</name></type> <name>BundleLookup</name><parameter_list>(<param><decl><type><name>ConstStr255Param</name></type> <name>symName</name></decl></param>, <param><decl><type><name>CFragSymbolClass</name></type> <name>symClass</name></decl></param>,
<param><decl><type><name>void</name> **</type><name>symAddr</name></decl></param>, <param><decl><type><name>void</name> *</type><name>refCon</name></decl></param>)</parameter_list>
<block>{
<decl_stmt><decl><type><name>OSStatus</name></type> <name>err</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>CFBundleRef</name></type> <name>bundleToImport</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>CFStringRef</name></type> <name>symNameStr</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>MoreAssertQ</name><argument_list>(<argument><expr><name>symName</name> != <name>nil</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>MoreAssertQ</name><argument_list>(<argument><expr><name>symAddr</name> != <name>nil</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>MoreAssertQ</name><argument_list>(<argument><expr><name>refCon</name> != <name>nil</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>symNameStr</name> = <name>nil</name></expr>;</expr_stmt>
<expr_stmt><expr><name>bundleToImport</name> = (<name>CFBundleRef</name>) <name>refCon</name></expr>;</expr_stmt>
<expr_stmt><expr><name>err</name> = <name>noErr</name></expr>;</expr_stmt>
<if>if <condition>(<expr><name>symClass</name> != <name>kTVectorCFragSymbol</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>MoreAssertQ</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>err</name> = <name>cfragNoSymbolErr</name></expr>;</expr_stmt>
}</block></then></if>
<if>if <condition>(<expr><name>err</name> == <name>noErr</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>symNameStr</name> = <call><name>CFStringCreateWithPascalString</name><argument_list>(<argument><expr><name>kCFAllocatorSystemDefault</name></expr></argument>,
<argument><expr><name>symName</name></expr></argument>, <argument><expr><name>kCFStringEncodingMacRoman</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>symNameStr</name> == <name>nil</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>err</name> = <name>coreFoundationUnknownErr</name></expr>;</expr_stmt>
}</block></then></if>
}</block></then></if>
<if>if <condition>(<expr><name>err</name> == <name>noErr</name></expr>)</condition><then> <block>{
<expr_stmt><expr>*<name>symAddr</name> = <call><name>CFBundleGetFunctionPointerForName</name><argument_list>(<argument><expr><name>bundleToImport</name></expr></argument>, <argument><expr><name>symNameStr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>*<name>symAddr</name> == <name>nil</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>err</name> = <name>cfragNoSymbolErr</name></expr>;</expr_stmt>
}</block></then></if>
}</block></then></if>
<if>if <condition>(<expr><name>symNameStr</name> != <name>nil</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>CFRelease</name><argument_list>(<argument><expr><name>symNameStr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<return>return <expr><name>err</name></expr>;</return>
}</block></function>
<function><type><specifier>extern</specifier> <name>pascal</name> <name>OSStatus</name></type> <name>CFMLateImportBundle</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>CFragSystem7DiskFlatLocator</name> *</type><name>fragToFixLocator</name></decl></param>,
<param><decl><type><name>CFragConnectionID</name></type> <name>fragToFixConnID</name></decl></param>,
<param><decl><type><name>CFragInitFunction</name></type> <name>fragToFixInitRoutine</name></decl></param>,
<param><decl><type><name>ConstStr255Param</name></type> <name>weakLinkedLibraryName</name></decl></param>,
<param><decl><type><name>CFBundleRef</name></type> <name>bundleToImport</name></decl></param>)</parameter_list>
<block>{
<expr_stmt><expr><call><name>MoreAssertQ</name><argument_list>(<argument><expr><name>bundleToImport</name> != <name>nil</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>CFMLateImportCore</name><argument_list>(<argument><expr><name>fragToFixLocator</name></expr></argument>, <argument><expr><name>fragToFixConnID</name></expr></argument>, <argument><expr><name>fragToFixInitRoutine</name></expr></argument>,
<argument><expr><name>weakLinkedLibraryName</name></expr></argument>, <argument><expr><name>BundleLookup</name></expr></argument>, <argument><expr><name>bundleToImport</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
</unit>
