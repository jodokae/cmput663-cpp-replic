<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C" filename="projects/cpython-2.6.1/_cppstats/Modules/_ctypes/callproc.c"><cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"Python.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"structmember.h"</cpp:file></cpp:include>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MS_WIN32</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;windows.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;tchar.h&gt;</cpp:file></cpp:include>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ctypes_dlfcn.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MS_WIN32</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;malloc.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;ffi.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ctypes.h"</cpp:file></cpp:include>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_DEBUG</name></expr></argument>)</argument_list></call> || <call><name>defined</name><argument_list>(<argument><expr><name>__MINGW32__</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DONT_USE_SEH</name></cpp:macro></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<function><type><name>PyObject</name> *</type>
<name>get_error_object</name><parameter_list>(<param><decl><type><name>int</name> **</type><name>pspace</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>dict</name> <init>= <expr><call><name>PyThreadState_GetDict</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>errobj</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>PyObject</name> *</type><name>error_object_name</name></decl>;</decl_stmt>
<if>if <condition>(<expr><name>dict</name> == 0</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_RuntimeError</name></expr></argument>,
<argument><expr>"cannot get thread state"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<if>if <condition>(<expr><name>error_object_name</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>error_object_name</name> = <call><name>PyString_InternFromString</name><argument_list>(<argument><expr>"ctypes.error_object"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>error_object_name</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
}</block></then></if>
<expr_stmt><expr><name>errobj</name> = <call><name>PyDict_GetItem</name><argument_list>(<argument><expr><name>dict</name></expr></argument>, <argument><expr><name>error_object_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>errobj</name></expr>)</condition><then>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>errobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
<else>else <block>{
<decl_stmt><decl><type><name>void</name> *</type><name>space</name> <init>= <expr><call><name>PyMem_Malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof> * 2</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>space</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>space</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof> * 2</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>errobj</name> = <call><name>PyCObject_FromVoidPtr</name><argument_list>(<argument><expr><name>space</name></expr></argument>, <argument><expr><name>PyMem_Free</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>errobj</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<if>if <condition>(<expr>-1 == <call><name>PyDict_SetItem</name><argument_list>(<argument><expr><name>dict</name></expr></argument>, <argument><expr><name>error_object_name</name></expr></argument>,
<argument><expr><name>errobj</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>errobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
}</block></else></if>
<expr_stmt><expr>*<name>pspace</name> = (<name>int</name> *)<call><name>PyCObject_AsVoidPtr</name><argument_list>(<argument><expr><name>errobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>errobj</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>get_error_internal</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>, <param><decl><type><name>int</name></type> <name>index</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>int</name> *</type><name>space</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>errobj</name> <init>= <expr><call><name>get_error_object</name><argument_list>(<argument><expr>&amp;<name>space</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>result</name></decl>;</decl_stmt>
<if>if <condition>(<expr><name>errobj</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>result</name> = <call><name>PyInt_FromLong</name><argument_list>(<argument><expr><name><name>space</name><index>[<expr><name>index</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>errobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>result</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>set_error_internal</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>, <param><decl><type><name>int</name></type> <name>index</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>new_errno</name></decl>, <decl><type ref="prev"/><name>old_errno</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>errobj</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name> *</type><name>space</name></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"i"</expr></argument>, <argument><expr>&amp;<name>new_errno</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>errobj</name> = <call><name>get_error_object</name><argument_list>(<argument><expr>&amp;<name>space</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>errobj</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>old_errno</name> = <name><name>space</name><index>[<expr><name>index</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>space</name><index>[<expr><name>index</name></expr>]</index></name> = <name>new_errno</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>errobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>PyInt_FromLong</name><argument_list>(<argument><expr><name>old_errno</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>get_errno</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<return>return <expr><call><name>get_error_internal</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>args</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>set_errno</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<return>return <expr><call><name>set_error_internal</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>args</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MS_WIN32</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>get_last_error</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<return>return <expr><call><name>get_error_internal</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>args</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>set_last_error</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<return>return <expr><call><name>set_error_internal</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>args</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>ComError</name></decl>;</decl_stmt>
<function><type><specifier>static</specifier> <name>TCHAR</name> *</type><name>FormatError</name><parameter_list>(<param><decl><type><name>DWORD</name></type> <name>code</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>TCHAR</name> *</type><name>lpMsgBuf</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>DWORD</name></type> <name>n</name></decl>;</decl_stmt>
<expr_stmt><expr><name>n</name> = <call><name>FormatMessage</name><argument_list>(<argument><expr><name>FORMAT_MESSAGE_ALLOCATE_BUFFER</name> | <name>FORMAT_MESSAGE_FROM_SYSTEM</name></expr></argument>,
<argument><expr><name>NULL</name></expr></argument>,
<argument><expr><name>code</name></expr></argument>,
<argument><expr><call><name>MAKELANGID</name><argument_list>(<argument><expr><name>LANG_NEUTRAL</name></expr></argument>, <argument><expr><name>SUBLANG_DEFAULT</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr>(<name>LPTSTR</name>) &amp;<name>lpMsgBuf</name></expr></argument>,
<argument><expr>0</expr></argument>,
<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>n</name></expr>)</condition><then> <block>{
<while>while <condition>(<expr><call><name>_istspace</name><argument_list>(<argument><expr><name><name>lpMsgBuf</name><index>[<expr><name>n</name>-1</expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition>
<expr_stmt><expr>--<name>n</name></expr>;</expr_stmt></while>
<expr_stmt><expr><name><name>lpMsgBuf</name><index>[<expr><name>n</name></expr>]</index></name> = <call><name>_T</name><argument_list>(<argument><expr>'\0'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<return>return <expr><name>lpMsgBuf</name></expr>;</return>
}</block></function>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>DONT_USE_SEH</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function><type><name>void</name></type> <name>SetException</name><parameter_list>(<param><decl><type><name>DWORD</name></type> <name>code</name></decl></param>, <param><decl><type><name>EXCEPTION_RECORD</name> *</type><name>pr</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>TCHAR</name> *</type><name>lpMsgBuf</name></decl>;</decl_stmt>
<expr_stmt><expr><name>lpMsgBuf</name> = <call><name>FormatError</name><argument_list>(<argument><expr><name>code</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if<condition>(<expr><name>lpMsgBuf</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetFromWindowsErr</name><argument_list>(<argument><expr><name>code</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>LocalFree</name><argument_list>(<argument><expr><name>lpMsgBuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<switch>switch <condition>(<expr><name>code</name></expr>)</condition> <block>{
<case>case <expr><name>EXCEPTION_ACCESS_VIOLATION</name></expr>:
<if>if <condition>(<expr><name><name>pr</name>-&gt;<name>ExceptionInformation</name><index>[<expr>0</expr>]</index></name> == 0</expr>)</condition><then>
<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_WindowsError</name></expr></argument>,
<argument><expr>"exception: access violation reading %p"</expr></argument>,
<argument><expr><name><name>pr</name>-&gt;<name>ExceptionInformation</name><index>[<expr>1</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
<else>else
<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_WindowsError</name></expr></argument>,
<argument><expr>"exception: access violation writing %p"</expr></argument>,
<argument><expr><name><name>pr</name>-&gt;<name>ExceptionInformation</name><index>[<expr>1</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
<break>break;</break>
</case><case>case <expr><name>EXCEPTION_BREAKPOINT</name></expr>:
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_WindowsError</name></expr></argument>,
<argument><expr>"exception: breakpoint encountered"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr><name>EXCEPTION_DATATYPE_MISALIGNMENT</name></expr>:
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_WindowsError</name></expr></argument>,
<argument><expr>"exception: datatype misalignment"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr><name>EXCEPTION_SINGLE_STEP</name></expr>:
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_WindowsError</name></expr></argument>,
<argument><expr>"exception: single step"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr><name>EXCEPTION_ARRAY_BOUNDS_EXCEEDED</name></expr>:
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_WindowsError</name></expr></argument>,
<argument><expr>"exception: array bounds exceeded"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr><name>EXCEPTION_FLT_DENORMAL_OPERAND</name></expr>:
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_WindowsError</name></expr></argument>,
<argument><expr>"exception: floating-point operand denormal"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr><name>EXCEPTION_FLT_DIVIDE_BY_ZERO</name></expr>:
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_WindowsError</name></expr></argument>,
<argument><expr>"exception: float divide by zero"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr><name>EXCEPTION_FLT_INEXACT_RESULT</name></expr>:
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_WindowsError</name></expr></argument>,
<argument><expr>"exception: float inexact"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr><name>EXCEPTION_FLT_INVALID_OPERATION</name></expr>:
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_WindowsError</name></expr></argument>,
<argument><expr>"exception: float invalid operation"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr><name>EXCEPTION_FLT_OVERFLOW</name></expr>:
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_WindowsError</name></expr></argument>,
<argument><expr>"exception: float overflow"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr><name>EXCEPTION_FLT_STACK_CHECK</name></expr>:
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_WindowsError</name></expr></argument>,
<argument><expr>"exception: stack over/underflow"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr><name>EXCEPTION_STACK_OVERFLOW</name></expr>:
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_WindowsError</name></expr></argument>,
<argument><expr>"exception: stack overflow"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr><name>EXCEPTION_FLT_UNDERFLOW</name></expr>:
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_WindowsError</name></expr></argument>,
<argument><expr>"exception: float underflow"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr><name>EXCEPTION_INT_DIVIDE_BY_ZERO</name></expr>:
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_WindowsError</name></expr></argument>,
<argument><expr>"exception: integer divide by zero"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr><name>EXCEPTION_INT_OVERFLOW</name></expr>:
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_WindowsError</name></expr></argument>,
<argument><expr>"exception: integer overflow"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr><name>EXCEPTION_PRIV_INSTRUCTION</name></expr>:
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_WindowsError</name></expr></argument>,
<argument><expr>"exception: priviledged instruction"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr><name>EXCEPTION_NONCONTINUABLE_EXCEPTION</name></expr>:
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_WindowsError</name></expr></argument>,
<argument><expr>"exception: nocontinuable"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</case><default>default:
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>"error %d\n"</expr></argument>, <argument><expr><name>code</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_WindowsError</name></expr></argument>,
<argument><expr>"exception code 0x%08x"</expr></argument>,
<argument><expr><name>code</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</default>}</block></switch>
}</block></else></if>
}</block></function>
<function><type><specifier>static</specifier> <name>DWORD</name></type> <name>HandleException</name><parameter_list>(<param><decl><type><name>EXCEPTION_POINTERS</name> *</type><name>ptrs</name></decl></param>,
<param><decl><type><name>DWORD</name> *</type><name>pdw</name></decl></param>, <param><decl><type><name>EXCEPTION_RECORD</name> *</type><name>record</name></decl></param>)</parameter_list> <block>{
<expr_stmt><expr>*<name>pdw</name> = <name><name>ptrs</name>-&gt;<name>ExceptionRecord</name>-&gt;<name>ExceptionCode</name></name></expr>;</expr_stmt>
<expr_stmt><expr>*<name>record</name> = *<name><name>ptrs</name>-&gt;<name>ExceptionRecord</name></name></expr>;</expr_stmt>
<return>return <expr><name>EXCEPTION_EXECUTE_HANDLER</name></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>check_hresult</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>HRESULT</name></type> <name>hr</name></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"i"</expr></argument>, <argument><expr>&amp;<name>hr</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<if>if <condition>(<expr><call><name>FAILED</name><argument_list>(<argument><expr><name>hr</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><call><name>PyErr_SetFromWindowsErr</name><argument_list>(<argument><expr><name>hr</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
<return>return <expr><call><name>PyInt_FromLong</name><argument_list>(<argument><expr><name>hr</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<function><type><name>PyCArgObject</name> *</type>
<name>new_CArgObject</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyCArgObject</name> *</type><name>p</name></decl>;</decl_stmt>
<expr_stmt><expr><name>p</name> = <call><name>PyObject_New</name><argument_list>(<argument><expr><name>PyCArgObject</name></expr></argument>, <argument><expr>&amp;<name>PyCArg_Type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>p</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name><name>p</name>-&gt;<name>pffi_type</name></name> = <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>p</name>-&gt;<name>tag</name></name> = '\0'</expr>;</expr_stmt>
<expr_stmt><expr><name><name>p</name>-&gt;<name>obj</name></name> = <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr>&amp;<name><name>p</name>-&gt;<name>value</name></name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>p</name>-&gt;<name>value</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>p</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>PyCArg_dealloc</name><parameter_list>(<param><decl><type><name>PyCArgObject</name> *</type><name>self</name></decl></param>)</parameter_list> <block>{
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>obj</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyObject_Del</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>PyCArg_repr</name><parameter_list>(<param><decl><type><name>PyCArgObject</name> *</type><name>self</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>char</name></type> <name><name>buffer</name><index>[<expr>256</expr>]</index></name></decl>;</decl_stmt>
<switch>switch<condition>(<expr><name><name>self</name>-&gt;<name>tag</name></name></expr>)</condition> <block>{
<case>case <expr>'b'</expr>:
</case><case>case <expr>'B'</expr>:
<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr>"&lt;cparam '%c' (%d)&gt;"</expr></argument>,
<argument><expr><name><name>self</name>-&gt;<name>tag</name></name></expr></argument>, <argument><expr><name><name>self</name>-&gt;<name>value</name>.<name>b</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr>'h'</expr>:
</case><case>case <expr>'H'</expr>:
<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr>"&lt;cparam '%c' (%d)&gt;"</expr></argument>,
<argument><expr><name><name>self</name>-&gt;<name>tag</name></name></expr></argument>, <argument><expr><name><name>self</name>-&gt;<name>value</name>.<name>h</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr>'i'</expr>:
</case><case>case <expr>'I'</expr>:
<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr>"&lt;cparam '%c' (%d)&gt;"</expr></argument>,
<argument><expr><name><name>self</name>-&gt;<name>tag</name></name></expr></argument>, <argument><expr><name><name>self</name>-&gt;<name>value</name>.<name>i</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr>'l'</expr>:
</case><case>case <expr>'L'</expr>:
<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr>"&lt;cparam '%c' (%ld)&gt;"</expr></argument>,
<argument><expr><name><name>self</name>-&gt;<name>tag</name></name></expr></argument>, <argument><expr><name><name>self</name>-&gt;<name>value</name>.<name>l</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_LONG_LONG</name></expr></argument>)</argument_list></call></expr></cpp:if>
</case><case>case <expr>'q'</expr>:
</case><case>case <expr>'Q'</expr>:
<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>,
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MS_WIN32</name></expr></argument>)</argument_list></call></expr></cpp:if>
<argument><expr>"&lt;cparam '%c' (%I64d)&gt;"</expr></argument>,
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<argument><expr>"&lt;cparam '%c' (%qd)&gt;"</expr></argument>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<argument><expr><name><name>self</name>-&gt;<name>tag</name></name></expr></argument>, <argument><expr><name><name>self</name>-&gt;<name>value</name>.<name>q</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</case><case>case <expr>'d'</expr>:
<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr>"&lt;cparam '%c' (%f)&gt;"</expr></argument>,
<argument><expr><name><name>self</name>-&gt;<name>tag</name></name></expr></argument>, <argument><expr><name><name>self</name>-&gt;<name>value</name>.<name>d</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr>'f'</expr>:
<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr>"&lt;cparam '%c' (%f)&gt;"</expr></argument>,
<argument><expr><name><name>self</name>-&gt;<name>tag</name></name></expr></argument>, <argument><expr><name><name>self</name>-&gt;<name>value</name>.<name>f</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr>'c'</expr>:
<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr>"&lt;cparam '%c' (%c)&gt;"</expr></argument>,
<argument><expr><name><name>self</name>-&gt;<name>tag</name></name></expr></argument>, <argument><expr><name><name>self</name>-&gt;<name>value</name>.<name>c</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr>'z'</expr>:
</case><case>case <expr>'Z'</expr>:
</case><case>case <expr>'P'</expr>:
<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr>"&lt;cparam '%c' (%p)&gt;"</expr></argument>,
<argument><expr><name><name>self</name>-&gt;<name>tag</name></name></expr></argument>, <argument><expr><name><name>self</name>-&gt;<name>value</name>.<name>p</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</case><default>default:
<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr>"&lt;cparam '%c' at %p&gt;"</expr></argument>,
<argument><expr><name><name>self</name>-&gt;<name>tag</name></name></expr></argument>, <argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</default>}</block></switch>
<return>return <expr><call><name>PyString_FromString</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<decl_stmt><decl><type><specifier>static</specifier> <name>PyMemberDef</name></type> <name><name>PyCArgType_members</name><index>[]</index></name> <init>= <expr><block>{
<expr><block>{
<expr>"_obj"</expr>, <expr><name>T_OBJECT</name></expr>,
<expr><call><name>offsetof</name><argument_list>(<argument><expr><name>PyCArgObject</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>, <expr><name>READONLY</name></expr>,
<expr>"the wrapped object"</expr>
}</block></expr>,
<expr><block>{ <expr><name>NULL</name></expr> }</block></expr>,
}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyTypeObject</name></type> <name>PyCArg_Type</name> <init>= <expr><block>{
<expr><call><name>PyVarObject_HEAD_INIT</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call>
"CArgObject"</expr>,
<expr><sizeof>sizeof<argument_list>(<argument><expr><name>PyCArgObject</name></expr></argument>)</argument_list></sizeof></expr>,
<expr>0</expr>,
<expr>(<name>destructor</name>)<name>PyCArg_dealloc</name></expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>(<name>reprfunc</name>)<name>PyCArg_repr</name></expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr><name>Py_TPFLAGS_DEFAULT</name></expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr><name>PyCArgType_members</name></expr>,
}</block></expr></init></decl>;</decl_stmt>
<union>union <name>result</name> <block>{
<decl_stmt><decl><type><name>char</name></type> <name>c</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name>b</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>short</name></type> <name>h</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>long</name></type> <name>l</name></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_LONG_LONG</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>PY_LONG_LONG</name></type> <name>q</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<decl_stmt><decl><type><name>long</name> <name>double</name></type> <name>D</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>double</name></type> <name>d</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>float</name></type> <name>f</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>void</name> *</type><name>p</name></decl>;</decl_stmt>
}</block>;</union>
<struct>struct <name>argument</name> <block>{
<decl_stmt><decl><type><name>ffi_type</name> *</type><name>ffi_type</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>keep</name></decl>;</decl_stmt>
<decl_stmt><decl><type>union <name>result</name></type> <name>value</name></decl>;</decl_stmt>
}</block>;</struct>
<function><type><specifier>static</specifier> <name>int</name></type> <name>ConvParam</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>obj</name></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>index</name></decl></param>, <param><decl><type>struct <name>argument</name> *</type><name>pa</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>StgDictObject</name> *</type><name>dict</name></decl>;</decl_stmt>
<expr_stmt><expr><name><name>pa</name>-&gt;<name>keep</name></name> = <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name>dict</name> = <call><name>PyObject_stgdict</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>dict</name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>PyCArgObject</name> *</type><name>carg</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>dict</name>-&gt;<name>paramfunc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>carg</name> = <call><name><name>dict</name>-&gt;<name>paramfunc</name></name><argument_list>(<argument><expr>(<name>CDataObject</name> *)<name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>pa</name>-&gt;<name>ffi_type</name></name> = <name><name>carg</name>-&gt;<name>pffi_type</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name><name>pa</name>-&gt;<name>value</name></name></expr></argument>, <argument><expr>&amp;<name><name>carg</name>-&gt;<name>value</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>pa</name>-&gt;<name>value</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>pa</name>-&gt;<name>keep</name></name> = (<name>PyObject</name> *)<name>carg</name></expr>;</expr_stmt>
<return>return <expr>0</expr>;</return>
}</block></then></if>
<if>if <condition>(<expr><call><name>PyCArg_CheckExact</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>PyCArgObject</name> *</type><name>carg</name> <init>= <expr>(<name>PyCArgObject</name> *)<name>obj</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>pa</name>-&gt;<name>ffi_type</name></name> = <name><name>carg</name>-&gt;<name>pffi_type</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>pa</name>-&gt;<name>keep</name></name> = <name>obj</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name><name>pa</name>-&gt;<name>value</name></name></expr></argument>, <argument><expr>&amp;<name><name>carg</name>-&gt;<name>value</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>pa</name>-&gt;<name>value</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>0</expr>;</return>
}</block></then></if>
<if>if <condition>(<expr><name>obj</name> == <name>Py_None</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>pa</name>-&gt;<name>ffi_type</name></name> = &amp;<name>ffi_type_pointer</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>pa</name>-&gt;<name>value</name>.<name>p</name></name> = <name>NULL</name></expr>;</expr_stmt>
<return>return <expr>0</expr>;</return>
}</block></then></if>
<if>if <condition>(<expr><call><name>PyInt_Check</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>pa</name>-&gt;<name>ffi_type</name></name> = &amp;<name>ffi_type_sint</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>pa</name>-&gt;<name>value</name>.<name>i</name></name> = <call><name>PyInt_AS_LONG</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>0</expr>;</return>
}</block></then></if>
<if>if <condition>(<expr><call><name>PyLong_Check</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>pa</name>-&gt;<name>ffi_type</name></name> = &amp;<name>ffi_type_sint</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>pa</name>-&gt;<name>value</name>.<name>i</name></name> = (<name>long</name>)<call><name>PyLong_AsUnsignedLong</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>pa</name>-&gt;<name>value</name>.<name>i</name></name> == -1 &amp;&amp; <call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_Clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>pa</name>-&gt;<name>value</name>.<name>i</name></name> = <call><name>PyLong_AsLong</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>pa</name>-&gt;<name>value</name>.<name>i</name></name> == -1 &amp;&amp; <call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_OverflowError</name></expr></argument>,
<argument><expr>"long int too long to convert"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>-1</expr>;</return>
}</block></then></if>
}</block></then></if>
<return>return <expr>0</expr>;</return>
}</block></then></if>
<if>if <condition>(<expr><call><name>PyString_Check</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>pa</name>-&gt;<name>ffi_type</name></name> = &amp;<name>ffi_type_pointer</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>pa</name>-&gt;<name>value</name>.<name>p</name></name> = <call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>pa</name>-&gt;<name>keep</name></name> = <name>obj</name></expr>;</expr_stmt>
<return>return <expr>0</expr>;</return>
}</block></then></if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>CTYPES_UNICODE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if>if <condition>(<expr><call><name>PyUnicode_Check</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_USABLE_WCHAR_T</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><name><name>pa</name>-&gt;<name>ffi_type</name></name> = &amp;<name>ffi_type_pointer</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>pa</name>-&gt;<name>value</name>.<name>p</name></name> = <call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>pa</name>-&gt;<name>keep</name></name> = <name>obj</name></expr>;</expr_stmt>
<return>return <expr>0</expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<decl_stmt><decl><type><name>int</name></type> <name>size</name> <init>= <expr><call><name>PyUnicode_GET_SIZE</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>size</name> += 1</expr>;</expr_stmt>
<expr_stmt><expr><name>size</name> *= <sizeof>sizeof<argument_list>(<argument><expr><name>wchar_t</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
<expr_stmt><expr><name><name>pa</name>-&gt;<name>value</name>.<name>p</name></name> = <call><name>PyMem_Malloc</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name><name>pa</name>-&gt;<name>value</name>.<name>p</name></name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_NoMemory</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<return>return <expr>-1</expr>;</return>
}</block></then></if>
<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>pa</name>-&gt;<name>value</name>.<name>p</name></name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>pa</name>-&gt;<name>keep</name></name> = <call><name>PyCObject_FromVoidPtr</name><argument_list>(<argument><expr><name><name>pa</name>-&gt;<name>value</name>.<name>p</name></name></expr></argument>, <argument><expr><name>PyMem_Free</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name><name>pa</name>-&gt;<name>keep</name></name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyMem_Free</name><argument_list>(<argument><expr><name><name>pa</name>-&gt;<name>value</name>.<name>p</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>-1</expr>;</return>
}</block></then></if>
<if>if <condition>(<expr>-1 == <call><name>PyUnicode_AsWideChar</name><argument_list>(<argument><expr>(<name>PyUnicodeObject</name> *)<name>obj</name></expr></argument>,
<argument><expr><name><name>pa</name>-&gt;<name>value</name>.<name>p</name></name></expr></argument>, <argument><expr><call><name>PyUnicode_GET_SIZE</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr>-1</expr>;</return></then></if>
<return>return <expr>0</expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>arg</name></decl>;</decl_stmt>
<expr_stmt><expr><name>arg</name> = <call><name>PyObject_GetAttrString</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr>"_as_parameter_"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>arg</name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>result</name></decl>;</decl_stmt>
<expr_stmt><expr><name>result</name> = <call><name>ConvParam</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><name>index</name></expr></argument>, <argument><expr><name>pa</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>result</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
<argument><expr>"Don't know how to convert parameter %d"</expr></argument>,
<argument><expr><call><name>Py_SAFE_DOWNCAST</name><argument_list>(<argument><expr><name>index</name></expr></argument>, <argument><expr><name>Py_ssize_t</name></expr></argument>, <argument><expr><name>int</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>-1</expr>;</return>
}</block>
}</block></function>
<function><type><name>ffi_type</name> *</type><name>GetType</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>obj</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>StgDictObject</name> *</type><name>dict</name></decl>;</decl_stmt>
<if>if <condition>(<expr><name>obj</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr>&amp;<name>ffi_type_sint</name></expr>;</return></then></if>
<expr_stmt><expr><name>dict</name> = <call><name>PyType_stgdict</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>dict</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr>&amp;<name>ffi_type_sint</name></expr>;</return></then></if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MS_WIN32</name></expr></argument>)</argument_list></call> &amp;&amp; !<call><name>defined</name><argument_list>(<argument><expr><name>_WIN32_WCE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if>if <condition>(<expr><name><name>dict</name>-&gt;<name>ffi_type_pointer</name>.<name>type</name></name> == <name>FFI_TYPE_STRUCT</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr><name><name>dict</name>-&gt;<name>ffi_type_pointer</name>.<name>size</name></name> &lt;= 4</expr>)</condition><then>
<return>return <expr>&amp;<name>ffi_type_sint32</name></expr>;</return></then>
<else>else <if>if <condition>(<expr><name><name>dict</name>-&gt;<name>ffi_type_pointer</name>.<name>size</name></name> &lt;= 8</expr>)</condition><then>
<return>return <expr>&amp;<name>ffi_type_sint64</name></expr>;</return></then></if></else></if>
}</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<return>return <expr>&amp;<name><name>dict</name>-&gt;<name>ffi_type_pointer</name></name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>_call_function_pointer</name><parameter_list>(<param><decl><type><name>int</name></type> <name>flags</name></decl></param>,
<param><decl><type><name>PPROC</name></type> <name>pProc</name></decl></param>,
<param><decl><type><name>void</name> **</type><name>avalues</name></decl></param>,
<param><decl><type><name>ffi_type</name> **</type><name>atypes</name></decl></param>,
<param><decl><type><name>ffi_type</name> *</type><name>restype</name></decl></param>,
<param><decl><type><name>void</name> *</type><name>resmem</name></decl></param>,
<param><decl><type><name>int</name></type> <name>argcount</name></decl></param>)</parameter_list> <block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>WITH_THREAD</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>PyThreadState</name> *</type><name>_save</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>error_object</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name> *</type><name>space</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ffi_cif</name></type> <name>cif</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>cc</name></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MS_WIN32</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>int</name></type> <name>delta</name></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>DONT_USE_SEH</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>DWORD</name></type> <name>dwExceptionCode</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>EXCEPTION_RECORD</name></type> <name>record</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<if>if <condition>(<expr><name>restype</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_RuntimeError</name></expr></argument>,
<argument><expr>"No ffi_type for result"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>-1</expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>cc</name> = <name>FFI_DEFAULT_ABI</name></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MS_WIN32</name></expr></argument>)</argument_list></call> &amp;&amp; !<call><name>defined</name><argument_list>(<argument><expr><name>MS_WIN64</name></expr></argument>)</argument_list></call> &amp;&amp; !<call><name>defined</name><argument_list>(<argument><expr><name>_WIN32_WCE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if>if <condition>(<expr>(<name>flags</name> &amp; <name>FUNCFLAG_CDECL</name>) == 0</expr>)</condition><then>
<expr_stmt><expr><name>cc</name> = <name>FFI_STDCALL</name></expr>;</expr_stmt></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<if>if <condition>(<expr><name>FFI_OK</name> != <call><name>ffi_prep_cif</name><argument_list>(<argument><expr>&amp;<name>cif</name></expr></argument>,
<argument><expr><name>cc</name></expr></argument>,
<argument><expr><name>argcount</name></expr></argument>,
<argument><expr><name>restype</name></expr></argument>,
<argument><expr><name>atypes</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_RuntimeError</name></expr></argument>,
<argument><expr>"ffi_prep_cif failed"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>-1</expr>;</return>
}</block></then></if>
<if>if <condition>(<expr><name>flags</name> &amp; (<name>FUNCFLAG_USE_ERRNO</name> | <name>FUNCFLAG_USE_LASTERROR</name>)</expr>)</condition><then> <block>{
<expr_stmt><expr><name>error_object</name> = <call><name>get_error_object</name><argument_list>(<argument><expr>&amp;<name>space</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>error_object</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr>-1</expr>;</return></then></if>
}</block></then></if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>WITH_THREAD</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if>if <condition>(<expr>(<name>flags</name> &amp; <name>FUNCFLAG_PYTHONAPI</name>) == 0</expr>)</condition><then>
<macro><name>Py_UNBLOCK_THREADS</name></macro>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<if>if <condition>(<expr><name>flags</name> &amp; <name>FUNCFLAG_USE_ERRNO</name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>temp</name> <init>= <expr><name><name>space</name><index>[<expr>0</expr>]</index></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>space</name><index>[<expr>0</expr>]</index></name> = <name>errno</name></expr>;</expr_stmt>
<expr_stmt><expr><name>errno</name> = <name>temp</name></expr>;</expr_stmt>
}</block></then></if></then></if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MS_WIN32</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if>if <condition>(<expr><name>flags</name> &amp; <name>FUNCFLAG_USE_LASTERROR</name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>temp</name> <init>= <expr><name><name>space</name><index>[<expr>1</expr>]</index></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>space</name><index>[<expr>1</expr>]</index></name> = <call><name>GetLastError</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SetLastError</name><argument_list>(<argument><expr><name>temp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>DONT_USE_SEH</name></expr></argument>)</argument_list></call></expr></cpp:if>
<macro><name>__try</name></macro> <block>{
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><name>delta</name> =
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<call><name>ffi_call</name><argument_list>(<argument><expr>&amp;<name>cif</name></expr></argument>, <argument><expr>(<name>void</name> *)<name>pProc</name></expr></argument>, <argument><expr><name>resmem</name></expr></argument>, <argument><expr><name>avalues</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MS_WIN32</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>DONT_USE_SEH</name></expr></argument>)</argument_list></call></expr></cpp:if>
}</block> <macro><name>__except</name> <argument_list>(<argument>HandleException(GetExceptionInformation(),
&amp;dwExceptionCode, &amp;record)</argument>)</argument_list></macro> <block>{
<empty_stmt>;</empty_stmt>
}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<if>if <condition>(<expr><name>flags</name> &amp; <name>FUNCFLAG_USE_LASTERROR</name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>temp</name> <init>= <expr><name><name>space</name><index>[<expr>1</expr>]</index></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>space</name><index>[<expr>1</expr>]</index></name> = <call><name>GetLastError</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SetLastError</name><argument_list>(<argument><expr><name>temp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<if>if <condition>(<expr><name>flags</name> &amp; <name>FUNCFLAG_USE_ERRNO</name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>temp</name> <init>= <expr><name><name>space</name><index>[<expr>0</expr>]</index></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>space</name><index>[<expr>0</expr>]</index></name> = <name>errno</name></expr>;</expr_stmt>
<expr_stmt><expr><name>errno</name> = <name>temp</name></expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>error_object</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>WITH_THREAD</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if>if <condition>(<expr>(<name>flags</name> &amp; <name>FUNCFLAG_PYTHONAPI</name>) == 0</expr>)</condition><then>
<macro><name>Py_BLOCK_THREADS</name></macro>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MS_WIN32</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>DONT_USE_SEH</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if>if <condition>(<expr><name>dwExceptionCode</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>SetException</name><argument_list>(<argument><expr><name>dwExceptionCode</name></expr></argument>, <argument><expr>&amp;<name>record</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>-1</expr>;</return>
}</block></then></if></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MS_WIN64</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if>if <condition>(<expr><name>delta</name> != 0</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_RuntimeError</name></expr></argument>,
<argument><expr>"ffi_call failed with code %d"</expr></argument>,
<argument><expr><name>delta</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>-1</expr>;</return>
}</block></then></if>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<if>if <condition>(<expr><name>delta</name> &lt; 0</expr>)</condition><then> <block>{
<if>if <condition>(<expr><name>flags</name> &amp; <name>FUNCFLAG_CDECL</name></expr>)</condition><then>
<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>,
<argument><expr>"Procedure called with not enough "
"arguments (%d bytes missing) "
"or wrong calling convention"</expr></argument>,
<argument><expr>-<name>delta</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
<else>else
<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>,
<argument><expr>"Procedure probably called with not enough "
"arguments (%d bytes missing)"</expr></argument>,
<argument><expr>-<name>delta</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
<return>return <expr>-1</expr>;</return>
}</block></then> <else>else <if>if <condition>(<expr><name>delta</name> &gt; 0</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>,
<argument><expr>"Procedure probably called with too many "
"arguments (%d bytes in excess)"</expr></argument>,
<argument><expr><name>delta</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>-1</expr>;</return>
}</block></then></if></else></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<if>if <condition>(<expr>(<name>flags</name> &amp; <name>FUNCFLAG_PYTHONAPI</name>) &amp;&amp; <call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then>
<return>return <expr>-1</expr>;</return></then></if>
<return>return <expr>0</expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type><name>GetResult</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>restype</name></decl></param>, <param><decl><type><name>void</name> *</type><name>result</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>checker</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>StgDictObject</name> *</type><name>dict</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>retval</name></decl>, *<decl><type ref="prev"/><name>v</name></decl>;</decl_stmt>
<if>if <condition>(<expr><name>restype</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><call><name>PyInt_FromLong</name><argument_list>(<argument><expr>*(<name>int</name> *)<name>result</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
<if>if <condition>(<expr><name>restype</name> == <name>Py_None</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>Py_None</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>dict</name> = <call><name>PyType_stgdict</name><argument_list>(<argument><expr><name>restype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>dict</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><call><name>PyObject_CallFunction</name><argument_list>(<argument><expr><name>restype</name></expr></argument>, <argument><expr>"i"</expr></argument>, <argument><expr>*(<name>int</name> *)<name>result</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
<if>if <condition>(<expr><name><name>dict</name>-&gt;<name>getfunc</name></name> &amp;&amp; !<call><name>IsSimpleSubType</name><argument_list>(<argument><expr><name>restype</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><name>retval</name> = <call><name><name>dict</name>-&gt;<name>getfunc</name></name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name><name>dict</name>-&gt;<name>size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>dict</name>-&gt;<name>getfunc</name></name> == <call><name>getentry</name><argument_list>(<argument><expr>"O"</expr></argument>)</argument_list></call>-&gt;<name>getfunc</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>retval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
}</block></then> <else>else
<expr_stmt><expr><name>retval</name> = <call><name>CData_FromBaseObj</name><argument_list>(<argument><expr><name>restype</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
<if>if <condition>(<expr>!<name>checker</name> || !<name>retval</name></expr>)</condition><then>
<return>return <expr><name>retval</name></expr>;</return></then></if>
<expr_stmt><expr><name>v</name> = <call><name>PyObject_CallFunctionObjArgs</name><argument_list>(<argument><expr><name>checker</name></expr></argument>, <argument><expr><name>retval</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>v</name> == <name>NULL</name></expr>)</condition><then>
<expr_stmt><expr><call><name>_AddTraceback</name><argument_list>(<argument><expr>"GetResult"</expr></argument>, <argument><expr>"_ctypes/callproc.c"</expr></argument>, <argument><expr><name>__LINE__</name>-2</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>retval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>v</name></expr>;</return>
}</block></function>
<function><type><name>void</name></type> <name>Extend_Error_Info</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>exc_class</name></decl></param>, <param><decl><type><name>char</name> *</type><name>fmt</name></decl></param>, <param><decl><type>...</type></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>va_list</name></type> <name>vargs</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>tp</name></decl>, *<decl><type ref="prev"/><name>v</name></decl>, *<decl><type ref="prev"/><name>tb</name></decl>, *<decl><type ref="prev"/><name>s</name></decl>, *<decl><type ref="prev"/><name>cls_str</name></decl>, *<decl><type ref="prev"/><name>msg_str</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>vargs</name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>s</name> = <call><name>PyString_FromFormatV</name><argument_list>(<argument><expr><name>fmt</name></expr></argument>, <argument><expr><name>vargs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>vargs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>s</name></expr>)</condition><then>
<return>return;</return></then></if>
<expr_stmt><expr><call><name>PyErr_Fetch</name><argument_list>(<argument><expr>&amp;<name>tp</name></expr></argument>, <argument><expr>&amp;<name>v</name></expr></argument>, <argument><expr>&amp;<name>tb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyErr_NormalizeException</name><argument_list>(<argument><expr>&amp;<name>tp</name></expr></argument>, <argument><expr>&amp;<name>v</name></expr></argument>, <argument><expr>&amp;<name>tb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>cls_str</name> = <call><name>PyObject_Str</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>cls_str</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyString_ConcatAndDel</name><argument_list>(<argument><expr>&amp;<name>s</name></expr></argument>, <argument><expr><name>cls_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyString_ConcatAndDel</name><argument_list>(<argument><expr>&amp;<name>s</name></expr></argument>, <argument><expr><call><name>PyString_FromString</name><argument_list>(<argument><expr>": "</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>s</name> == <name>NULL</name></expr>)</condition><then>
<goto>goto <name>error</name>;</goto></then></if>
}</block></then> <else>else
<expr_stmt><expr><call><name>PyErr_Clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt></else></if>
<expr_stmt><expr><name>msg_str</name> = <call><name>PyObject_Str</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>msg_str</name></expr>)</condition><then>
<expr_stmt><expr><call><name>PyString_ConcatAndDel</name><argument_list>(<argument><expr>&amp;<name>s</name></expr></argument>, <argument><expr><name>msg_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
<else>else <block>{
<expr_stmt><expr><call><name>PyErr_Clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyString_ConcatAndDel</name><argument_list>(<argument><expr>&amp;<name>s</name></expr></argument>, <argument><expr><call><name>PyString_FromString</name><argument_list>(<argument><expr>"???"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>s</name> == <name>NULL</name></expr>)</condition><then>
<goto>goto <name>error</name>;</goto></then></if>
}</block></else></if>
<expr_stmt><expr><call><name>PyErr_SetObject</name><argument_list>(<argument><expr><name>exc_class</name></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<label><name>error</name>:</label>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>tb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MS_WIN32</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>GetComError</name><parameter_list>(<param><decl><type><name>HRESULT</name></type> <name>errcode</name></decl></param>, <param><decl><type><name>GUID</name> *</type><name>riid</name></decl></param>, <param><decl><type><name>IUnknown</name> *</type><name>pIunk</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>HRESULT</name></type> <name>hr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ISupportErrorInfo</name> *</type><name>psei</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>IErrorInfo</name> *</type><name>pei</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BSTR</name></type> <name>descr</name><init>=<expr><name>NULL</name></expr></init>, <name>helpfile</name><init>=<expr><name>NULL</name></expr></init>, <name>source</name><init>=<expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>GUID</name></type> <name>guid</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>DWORD</name></type> <name>helpcontext</name><init>=<expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>LPOLESTR</name></type> <name>progid</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>obj</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>TCHAR</name> *</type><name>text</name></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>WITH_THREAD</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>Py_BEGIN_ALLOW_THREADS</name></type>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<name>hr</name> <init>= <expr><call><name><name>pIunk</name>-&gt;<name>lpVtbl</name>-&gt;<name>QueryInterface</name></name><argument_list>(<argument><expr><name>pIunk</name></expr></argument>, <argument><expr>&amp;<name>IID_ISupportErrorInfo</name></expr></argument>, <argument><expr>(<name>void</name> **)&amp;<name>psei</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><call><name>FAILED</name><argument_list>(<argument><expr><name>hr</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<goto>goto <name>failed</name>;</goto></then></if>
<expr_stmt><expr><name>hr</name> = <call><name><name>psei</name>-&gt;<name>lpVtbl</name>-&gt;<name>InterfaceSupportsErrorInfo</name></name><argument_list>(<argument><expr><name>psei</name></expr></argument>, <argument><expr><name>riid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>psei</name>-&gt;<name>lpVtbl</name>-&gt;<name>Release</name></name><argument_list>(<argument><expr><name>psei</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>FAILED</name><argument_list>(<argument><expr><name>hr</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<goto>goto <name>failed</name>;</goto></then></if>
<expr_stmt><expr><name>hr</name> = <call><name>GetErrorInfo</name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr>&amp;<name>pei</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>hr</name> != <name>S_OK</name></expr>)</condition><then>
<goto>goto <name>failed</name>;</goto></then></if>
<expr_stmt><expr><call><name><name>pei</name>-&gt;<name>lpVtbl</name>-&gt;<name>GetDescription</name></name><argument_list>(<argument><expr><name>pei</name></expr></argument>, <argument><expr>&amp;<name>descr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>pei</name>-&gt;<name>lpVtbl</name>-&gt;<name>GetGUID</name></name><argument_list>(<argument><expr><name>pei</name></expr></argument>, <argument><expr>&amp;<name>guid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>pei</name>-&gt;<name>lpVtbl</name>-&gt;<name>GetHelpContext</name></name><argument_list>(<argument><expr><name>pei</name></expr></argument>, <argument><expr>&amp;<name>helpcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>pei</name>-&gt;<name>lpVtbl</name>-&gt;<name>GetHelpFile</name></name><argument_list>(<argument><expr><name>pei</name></expr></argument>, <argument><expr>&amp;<name>helpfile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>pei</name>-&gt;<name>lpVtbl</name>-&gt;<name>GetSource</name></name><argument_list>(<argument><expr><name>pei</name></expr></argument>, <argument><expr>&amp;<name>source</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>pei</name>-&gt;<name>lpVtbl</name>-&gt;<name>Release</name></name><argument_list>(<argument><expr><name>pei</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<label><name>failed</name>:</label>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>WITH_THREAD</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>Py_END_ALLOW_THREADS</name></type>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<name>progid</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>ProgIDFromCLSID</name><argument_list>(<argument><expr>&amp;<name>guid</name></expr></argument>, <argument><expr>&amp;<name>progid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>text</name> = <call><name>FormatError</name><argument_list>(<argument><expr><name>errcode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>obj</name> = <call><name>Py_BuildValue</name><argument_list>(
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_UNICODE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<argument><expr>"iu(uuuiu)"</expr></argument>,
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<argument><expr>"is(uuuiu)"</expr></argument>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<argument><expr><name>errcode</name></expr></argument>,
<argument><expr><name>text</name></expr></argument>,
<argument><expr><name>descr</name></expr></argument>, <argument><expr><name>source</name></expr></argument>, <argument><expr><name>helpfile</name></expr></argument>, <argument><expr><name>helpcontext</name></expr></argument>,
<argument><expr><name>progid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>obj</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetObject</name><argument_list>(<argument><expr><name>ComError</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><call><name>LocalFree</name><argument_list>(<argument><expr><name>text</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>descr</name></expr>)</condition><then>
<expr_stmt><expr><call><name>SysFreeString</name><argument_list>(<argument><expr><name>descr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<if>if <condition>(<expr><name>helpfile</name></expr>)</condition><then>
<expr_stmt><expr><call><name>SysFreeString</name><argument_list>(<argument><expr><name>helpfile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<if>if <condition>(<expr><name>source</name></expr>)</condition><then>
<expr_stmt><expr><call><name>SysFreeString</name><argument_list>(<argument><expr><name>source</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<function><type><name>PyObject</name> *</type><name>_CallProc</name><parameter_list>(<param><decl><type><name>PPROC</name></type> <name>pProc</name></decl></param>,
<param><decl><type><name>PyObject</name> *</type><name>argtuple</name></decl></param>,
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MS_WIN32</name></expr></argument>)</argument_list></call></expr></cpp:if>
<param><decl><type><name>IUnknown</name> *</type><name>pIunk</name></decl></param>,
<param><decl><type><name>GUID</name> *</type><name>iid</name></decl></param>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<param><decl><type><name>int</name></type> <name>flags</name></decl></param>,
<param><decl><type><name>PyObject</name> *</type><name>argtypes</name></decl></param>,
<param><decl><type><name>PyObject</name> *</type><name>restype</name></decl></param>,
<param><decl><type><name>PyObject</name> *</type><name>checker</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>n</name></decl>, <decl><type ref="prev"/><name>argcount</name></decl>, <decl><type ref="prev"/><name>argtype_count</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>void</name> *</type><name>resbuf</name></decl>;</decl_stmt>
<decl_stmt><decl><type>struct <name>argument</name> *</type><name>args</name></decl>, *<decl><type ref="prev"/><name>pa</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ffi_type</name> **</type><name>atypes</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ffi_type</name> *</type><name>rtype</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>void</name> **</type><name>avalues</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>retval</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>n</name> = <name>argcount</name> = <call><name>PyTuple_GET_SIZE</name><argument_list>(<argument><expr><name>argtuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MS_WIN32</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if>if <condition>(<expr><name>pIunk</name></expr>)</condition><then>
<expr_stmt><expr>++<name>argcount</name></expr>;</expr_stmt></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><name>args</name> = (struct <name>argument</name> *)<call><name>alloca</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument>struct <expr><name>argument</name></expr></argument>)</argument_list></sizeof> * <name>argcount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>args</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_NoMemory</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument>struct <expr><name>argument</name></expr></argument>)</argument_list></sizeof> * <name>argcount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>argtype_count</name> = <name>argtypes</name> ? <call><name>PyTuple_GET_SIZE</name><argument_list>(<argument><expr><name>argtypes</name></expr></argument>)</argument_list></call> : 0</expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MS_WIN32</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if>if <condition>(<expr><name>pIunk</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>args</name><index>[<expr>0</expr>]</index></name>.<name>ffi_type</name> = &amp;<name>ffi_type_pointer</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>args</name><index>[<expr>0</expr>]</index></name>.<name><name>value</name>.<name>p</name></name> = <name>pIunk</name></expr>;</expr_stmt>
<expr_stmt><expr><name>pa</name> = &amp;<name><name>args</name><index>[<expr>1</expr>]</index></name></expr>;</expr_stmt>
}</block></then> <else>else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><name>pa</name> = &amp;<name><name>args</name><index>[<expr>0</expr>]</index></name></expr>;</expr_stmt></else></if>
<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>n</name></expr>;</condition> <incr><expr>++<name>i</name></expr>, <expr>++<name>pa</name></expr></incr>) <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>converter</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>arg</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>err</name></decl>;</decl_stmt>
<expr_stmt><expr><name>arg</name> = <call><name>PyTuple_GET_ITEM</name><argument_list>(<argument><expr><name>argtuple</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>argtypes</name> &amp;&amp; <name>argtype_count</name> &gt; <name>i</name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>v</name></decl>;</decl_stmt>
<expr_stmt><expr><name>converter</name> = <call><name>PyTuple_GET_ITEM</name><argument_list>(<argument><expr><name>argtypes</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>v</name> = <call><name>PyObject_CallFunctionObjArgs</name><argument_list>(<argument><expr><name>converter</name></expr></argument>,
<argument><expr><name>arg</name></expr></argument>,
<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>v</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Extend_Error_Info</name><argument_list>(<argument><expr><name>PyExc_ArgError</name></expr></argument>, <argument><expr>"argument %d: "</expr></argument>, <argument><expr><name>i</name>+1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>cleanup</name>;</goto>
}</block></then></if>
<expr_stmt><expr><name>err</name> = <call><name>ConvParam</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>i</name>+1</expr></argument>, <argument><expr><name>pa</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>-1 == <name>err</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Extend_Error_Info</name><argument_list>(<argument><expr><name>PyExc_ArgError</name></expr></argument>, <argument><expr>"argument %d: "</expr></argument>, <argument><expr><name>i</name>+1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>cleanup</name>;</goto>
}</block></then></if>
}</block></then> <else>else <block>{
<expr_stmt><expr><name>err</name> = <call><name>ConvParam</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><name>i</name>+1</expr></argument>, <argument><expr><name>pa</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>-1 == <name>err</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Extend_Error_Info</name><argument_list>(<argument><expr><name>PyExc_ArgError</name></expr></argument>, <argument><expr>"argument %d: "</expr></argument>, <argument><expr><name>i</name>+1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>cleanup</name>;</goto>
}</block></then></if>
}</block></else></if>
}</block></for>
<expr_stmt><expr><name>rtype</name> = <call><name>GetType</name><argument_list>(<argument><expr><name>restype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>resbuf</name> = <call><name>alloca</name><argument_list>(<argument><expr><call><name>max</name><argument_list>(<argument><expr><name><name>rtype</name>-&gt;<name>size</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ffi_arg</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>avalues</name> = (<name>void</name> **)<call><name>alloca</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>void</name> *</expr></argument>)</argument_list></sizeof> * <name>argcount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>atypes</name> = (<name>ffi_type</name> **)<call><name>alloca</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ffi_type</name> *</expr></argument>)</argument_list></sizeof> * <name>argcount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>resbuf</name> || !<name>avalues</name> || !<name>atypes</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_NoMemory</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>cleanup</name>;</goto>
}</block></then></if>
<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>argcount</name></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>) <block>{
<expr_stmt><expr><name><name>atypes</name><index>[<expr><name>i</name></expr>]</index></name> = <name><name>args</name><index>[<expr><name>i</name></expr>]</index></name>.<name>ffi_type</name></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>atypes</name><index>[<expr><name>i</name></expr>]</index></name>-&gt;<name>type</name> == <name>FFI_TYPE_STRUCT</name>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_WIN64</name></expr></argument>)</argument_list></call></expr></cpp:if>
&amp;&amp; <name><name>atypes</name><index>[<expr><name>i</name></expr>]</index></name>-&gt;<name>size</name> &lt;= <sizeof>sizeof<argument_list>(<argument><expr><name>void</name> *</expr></argument>)</argument_list></sizeof></expr>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
)</condition><then>
<expr_stmt><expr><name><name>avalues</name><index>[<expr><name>i</name></expr>]</index></name> = (<name>void</name> *)<name><name>args</name><index>[<expr><name>i</name></expr>]</index></name>.<name><name>value</name>.<name>p</name></name></expr>;</expr_stmt></then>
<else>else
<expr_stmt><expr><name><name>avalues</name><index>[<expr><name>i</name></expr>]</index></name> = (<name>void</name> *)&amp;<name><name>args</name><index>[<expr><name>i</name></expr>]</index></name>.<name>value</name></expr>;</expr_stmt></else></if>
}</block></for>
<if>if <condition>(<expr>-1 == <call><name>_call_function_pointer</name><argument_list>(<argument><expr><name>flags</name></expr></argument>, <argument><expr><name>pProc</name></expr></argument>, <argument><expr><name>avalues</name></expr></argument>, <argument><expr><name>atypes</name></expr></argument>,
<argument><expr><name>rtype</name></expr></argument>, <argument><expr><name>resbuf</name></expr></argument>,
<argument><expr><call><name>Py_SAFE_DOWNCAST</name><argument_list>(<argument><expr><name>argcount</name></expr></argument>,
<argument><expr><name>Py_ssize_t</name></expr></argument>,
<argument><expr><name>int</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then>
<goto>goto <name>cleanup</name>;</goto></then></if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>WORDS_BIGENDIAN</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if>if <condition>(<expr><name><name>rtype</name>-&gt;<name>type</name></name> != <name>FFI_TYPE_FLOAT</name>
&amp;&amp; <name><name>rtype</name>-&gt;<name>type</name></name> != <name>FFI_TYPE_STRUCT</name>
&amp;&amp; <name><name>rtype</name>-&gt;<name>size</name></name> &lt; <sizeof>sizeof<argument_list>(<argument><expr><name>ffi_arg</name></expr></argument>)</argument_list></sizeof></expr>)</condition><then>
<expr_stmt><expr><name>resbuf</name> = (<name>char</name> *)<name>resbuf</name> + <sizeof>sizeof<argument_list>(<argument><expr><name>ffi_arg</name></expr></argument>)</argument_list></sizeof> - <name><name>rtype</name>-&gt;<name>size</name></name></expr>;</expr_stmt></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MS_WIN32</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if>if <condition>(<expr><name>iid</name> &amp;&amp; <name>pIunk</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr>*(<name>int</name> *)<name>resbuf</name> &amp; 0x80000000</expr>)</condition><then>
<expr_stmt><expr><name>retval</name> = <call><name>GetComError</name><argument_list>(<argument><expr>*(<name>HRESULT</name> *)<name>resbuf</name></expr></argument>, <argument><expr><name>iid</name></expr></argument>, <argument><expr><name>pIunk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
<else>else
<expr_stmt><expr><name>retval</name> = <call><name>PyInt_FromLong</name><argument_list>(<argument><expr>*(<name>int</name> *)<name>resbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
}</block></then> <else>else <if>if <condition>(<expr><name>flags</name> &amp; <name>FUNCFLAG_HRESULT</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr>*(<name>int</name> *)<name>resbuf</name> &amp; 0x80000000</expr>)</condition><then>
<expr_stmt><expr><name>retval</name> = <call><name>PyErr_SetFromWindowsErr</name><argument_list>(<argument><expr>*(<name>int</name> *)<name>resbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
<else>else
<expr_stmt><expr><name>retval</name> = <call><name>PyInt_FromLong</name><argument_list>(<argument><expr>*(<name>int</name> *)<name>resbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
}</block></then> <else>else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><name>retval</name> = <call><name>GetResult</name><argument_list>(<argument><expr><name>restype</name></expr></argument>, <argument><expr><name>resbuf</name></expr></argument>, <argument><expr><name>checker</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if></else></if>
<label><name>cleanup</name>:</label>
<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>argcount</name></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>)
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name><name>args</name><index>[<expr><name>i</name></expr>]</index></name>.<name>keep</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></for>
<return>return <expr><name>retval</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>_parse_voidp</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>obj</name></decl></param>, <param><decl><type><name>void</name> **</type><name>address</name></decl></param>)</parameter_list> <block>{
<expr_stmt><expr>*<name>address</name> = <call><name>PyLong_AsVoidPtr</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>*<name>address</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr>0</expr>;</return></then></if>
<return>return <expr>1</expr>;</return>
}</block></function>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MS_WIN32</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_UNICODE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PYBUILD_TSTR</name></cpp:macro> <cpp:value>"u"</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PYBUILD_TSTR</name></cpp:macro> <cpp:value>"s"</cpp:value></cpp:define>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>_T</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>_T</name><parameter_list>(<param><type><name>text</name></type></param>)</parameter_list></cpp:macro> <cpp:value>text</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name><name>format_error_doc</name><index>[]</index></name> <init>=
<expr>"FormatError([integer]) -&gt; string\n\
\n\
Convert a win32 error code into a string. If the error code is not\n\
given, the return value of a call to GetLastError() is used.\n"</expr></init></decl>;</decl_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type><name>format_error</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>result</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>TCHAR</name> *</type><name>lpMsgBuf</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>DWORD</name></type> <name>code</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"|i:FormatError"</expr></argument>, <argument><expr>&amp;<name>code</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<if>if <condition>(<expr><name>code</name> == 0</expr>)</condition><then>
<expr_stmt><expr><name>code</name> = <call><name>GetLastError</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>
<expr_stmt><expr><name>lpMsgBuf</name> = <call><name>FormatError</name><argument_list>(<argument><expr><name>code</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>lpMsgBuf</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>result</name> = <call><name>Py_BuildValue</name><argument_list>(<argument><expr><name>PYBUILD_TSTR</name></expr></argument>, <argument><expr><name>lpMsgBuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>LocalFree</name><argument_list>(<argument><expr><name>lpMsgBuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr><name>result</name> = <call><name>Py_BuildValue</name><argument_list>(<argument><expr>"s"</expr></argument>, <argument><expr>"&lt;no description&gt;"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></else></if>
<return>return <expr><name>result</name></expr>;</return>
}</block></function>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name><name>load_library_doc</name><index>[]</index></name> <init>=
<expr>"LoadLibrary(name) -&gt; handle\n\
\n\
Load an executable (usually a DLL), and return a handle to it.\n\
The handle may be used to locate exported functions in this\n\
module.\n"</expr></init></decl>;</decl_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type><name>load_library</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>TCHAR</name> *</type><name>name</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>nameobj</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>ignored</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>HMODULE</name></type> <name>hMod</name></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"O|O:LoadLibrary"</expr></argument>, <argument><expr>&amp;<name>nameobj</name></expr></argument>, <argument><expr>&amp;<name>ignored</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_UNICODE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><name>name</name> = <call><name>alloca</name><argument_list>(<argument><expr>(<call><name>PyString_Size</name><argument_list>(<argument><expr><name>nameobj</name></expr></argument>)</argument_list></call> + 1) * <sizeof>sizeof<argument_list>(<argument><expr><name>WCHAR</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>name</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_NoMemory</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<block>{
<decl_stmt><decl><type><name>int</name></type> <name>r</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>aname</name> <init>= <expr><call><name>PyString_AsString</name><argument_list>(<argument><expr><name>nameobj</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if<condition>(<expr>!<name>aname</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>r</name> = <call><name>MultiByteToWideChar</name><argument_list>(<argument><expr><name>CP_ACP</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>aname</name></expr></argument>, <argument><expr>-1</expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><call><name>PyString_Size</name><argument_list>(<argument><expr><name>nameobj</name></expr></argument>)</argument_list></call> + 1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>name</name><index>[<expr><name>r</name></expr>]</index></name> = 0</expr>;</expr_stmt>
}</block>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<expr_stmt><expr><name>name</name> = <call><name>PyString_AsString</name><argument_list>(<argument><expr><name>nameobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if<condition>(<expr>!<name>name</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><name>hMod</name> = <call><name>LoadLibrary</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>hMod</name></expr>)</condition><then>
<return>return <expr><call><name>PyErr_SetFromWindowsErr</name><argument_list>(<argument><expr><call><name>GetLastError</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></then></if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_WIN64</name></expr></argument>)</argument_list></call></expr></cpp:if>
<return>return <expr><call><name>PyLong_FromVoidPtr</name><argument_list>(<argument><expr><name>hMod</name></expr></argument>)</argument_list></call></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<return>return <expr><call><name>Py_BuildValue</name><argument_list>(<argument><expr>"i"</expr></argument>, <argument><expr><name>hMod</name></expr></argument>)</argument_list></call></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></function>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name><name>free_library_doc</name><index>[]</index></name> <init>=
<expr>"FreeLibrary(handle) -&gt; void\n\
\n\
Free the handle of an executable previously loaded by LoadLibrary.\n"</expr></init></decl>;</decl_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type><name>free_library</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>void</name> *</type><name>hMod</name></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"O&amp;:FreeLibrary"</expr></argument>, <argument><expr>&amp;<name>_parse_voidp</name></expr></argument>, <argument><expr>&amp;<name>hMod</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<if>if <condition>(<expr>!<call><name>FreeLibrary</name><argument_list>(<argument><expr>(<name>HMODULE</name>)<name>hMod</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><call><name>PyErr_SetFromWindowsErr</name><argument_list>(<argument><expr><call><name>GetLastError</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></then></if>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>Py_None</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>call_commethod</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>IUnknown</name> *</type><name>pIunk</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>index</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>arguments</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PPROC</name> *</type><name>lpVtbl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>result</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>CDataObject</name> *</type><name>pcom</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>argtypes</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>,
<argument><expr>"OiO!|O!"</expr></argument>,
<argument><expr>&amp;<name>pcom</name></expr></argument>, <argument><expr>&amp;<name>index</name></expr></argument>,
<argument><expr>&amp;<name>PyTuple_Type</name></expr></argument>, <argument><expr>&amp;<name>arguments</name></expr></argument>,
<argument><expr>&amp;<name>PyTuple_Type</name></expr></argument>, <argument><expr>&amp;<name>argtypes</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<if>if <condition>(<expr><name>argtypes</name> &amp;&amp; (<call><name>PyTuple_GET_SIZE</name><argument_list>(<argument><expr><name>arguments</name></expr></argument>)</argument_list></call> != <call><name>PyTuple_GET_SIZE</name><argument_list>(<argument><expr><name>argtypes</name></expr></argument>)</argument_list></call>)</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
<argument><expr>"Method takes %d arguments (%d given)"</expr></argument>,
<argument><expr><call><name>PyTuple_GET_SIZE</name><argument_list>(<argument><expr><name>argtypes</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>PyTuple_GET_SIZE</name><argument_list>(<argument><expr><name>arguments</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<if>if <condition>(<expr>!<call><name>CDataObject_Check</name><argument_list>(<argument><expr><name>pcom</name></expr></argument>)</argument_list></call> || (<name><name>pcom</name>-&gt;<name>b_size</name></name> != <sizeof>sizeof<argument_list>(<argument><expr><name>void</name> *</expr></argument>)</argument_list></sizeof>)</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
<argument><expr>"COM Pointer expected instead of %s instance"</expr></argument>,
<argument><expr><call><name>Py_TYPE</name><argument_list>(<argument><expr><name>pcom</name></expr></argument>)</argument_list></call>-&gt;<name>tp_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<if>if <condition>(<expr>(*<call>(<name>void</name> **)<argument_list>(<argument><expr><name><name>pcom</name>-&gt;<name>b_ptr</name></name></expr></argument>)</argument_list></call>) == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>,
<argument><expr>"The COM 'this' pointer is NULL"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>pIunk</name> = <call>(<name>IUnknown</name> *)<argument_list>(<argument><expr>*<call>(<name>void</name> **)<argument_list>(<argument><expr><name><name>pcom</name>-&gt;<name>b_ptr</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>lpVtbl</name> = <call>(<name>PPROC</name> *)<argument_list>(<argument><expr><name><name>pIunk</name>-&gt;<name>lpVtbl</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>result</name> = <call><name>_CallProc</name><argument_list>(<argument><expr><name><name>lpVtbl</name><index>[<expr><name>index</name></expr>]</index></name></expr></argument>,
<argument><expr><name>arguments</name></expr></argument>,
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MS_WIN32</name></expr></argument>)</argument_list></call></expr></cpp:if>
<argument><expr><name>pIunk</name></expr></argument>,
<argument><expr><name>NULL</name></expr></argument>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<argument><expr><name>FUNCFLAG_HRESULT</name></expr></argument>,
<argument><expr><name>argtypes</name></expr></argument>,
<argument><expr><name>NULL</name></expr></argument>,
<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>result</name></expr>;</return>
}</block></function>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name><name>copy_com_pointer_doc</name><index>[]</index></name> <init>=
<expr>"CopyComPointer(src, dst) -&gt; HRESULT value\n"</expr></init></decl>;</decl_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>copy_com_pointer</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>p1</name></decl>, *<decl><type ref="prev"/><name>p2</name></decl>, *<decl><type ref="prev"/><name>r</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type>struct <name>argument</name></type> <name>a</name></decl>, <decl><type ref="prev"/><name>b</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>IUnknown</name> *</type><name>src</name></decl>, **<decl><type ref="prev"/><name>pdst</name></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"OO:CopyComPointer"</expr></argument>, <argument><expr>&amp;<name>p1</name></expr></argument>, <argument><expr>&amp;<name>p2</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name><name>a</name>.<name>keep</name></name> = <name><name>b</name>.<name>keep</name></name> = <name>NULL</name></expr>;</expr_stmt>
<if>if <condition>(<expr>-1 == <call><name>ConvParam</name><argument_list>(<argument><expr><name>p1</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>&amp;<name>a</name></expr></argument>)</argument_list></call> || -1 == <call><name>ConvParam</name><argument_list>(<argument><expr><name>p2</name></expr></argument>, <argument><expr>1</expr></argument>, <argument><expr>&amp;<name>b</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<goto>goto <name>done</name>;</goto></then></if>
<expr_stmt><expr><name>src</name> = (<name>IUnknown</name> *)<name><name>a</name>.<name>value</name>.<name>p</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>pdst</name> = (<name>IUnknown</name> **)<name><name>b</name>.<name>value</name>.<name>p</name></name></expr>;</expr_stmt>
<if>if <condition>(<expr><name>pdst</name> == <name>NULL</name></expr>)</condition><then>
<expr_stmt><expr><name>r</name> = <call><name>PyInt_FromLong</name><argument_list>(<argument><expr><name>E_POINTER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
<else>else <block>{
<if>if <condition>(<expr><name>src</name></expr>)</condition><then>
<expr_stmt><expr><call><name><name>src</name>-&gt;<name>lpVtbl</name>-&gt;<name>AddRef</name></name><argument_list>(<argument><expr><name>src</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<expr_stmt><expr>*<name>pdst</name> = <name>src</name></expr>;</expr_stmt>
<expr_stmt><expr><name>r</name> = <call><name>PyInt_FromLong</name><argument_list>(<argument><expr><name>S_OK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></else></if>
<label><name>done</name>:</label>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name><name>a</name>.<name>keep</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name><name>b</name>.<name>keep</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>r</name></expr>;</return>
}</block></function>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type><name>py_dl_open</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>char</name> *</type><name>name</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>void</name> *</type> <name>handle</name></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>RTLD_LOCAL</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>int</name></type> <name>mode</name> <init>= <expr><name>RTLD_NOW</name> | <name>RTLD_LOCAL</name></expr></init></decl>;</decl_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<decl_stmt><decl><type><name>int</name></type> <name>mode</name> <init>= <expr><name>RTLD_NOW</name></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"z|i:dlopen"</expr></argument>, <argument><expr>&amp;<name>name</name></expr></argument>, <argument><expr>&amp;<name>mode</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>mode</name> |= <name>RTLD_NOW</name></expr>;</expr_stmt>
<expr_stmt><expr><name>handle</name> = <call><name>ctypes_dlopen</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>mode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>handle</name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>char</name> *</type><name>errmsg</name> <init>= <expr><call><name>ctypes_dlerror</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr>!<name>errmsg</name></expr>)</condition><then>
<expr_stmt><expr><name>errmsg</name> = "dlopen() error"</expr>;</expr_stmt></then></if>
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_OSError</name></expr></argument>,
<argument><expr><name>errmsg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<return>return <expr><call><name>PyLong_FromVoidPtr</name><argument_list>(<argument><expr><name>handle</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type><name>py_dl_close</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>void</name> *</type><name>handle</name></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"O&amp;:dlclose"</expr></argument>, <argument><expr>&amp;<name>_parse_voidp</name></expr></argument>, <argument><expr>&amp;<name>handle</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<if>if <condition>(<expr><call><name>dlclose</name><argument_list>(<argument><expr><name>handle</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_OSError</name></expr></argument>,
<argument><expr><call><name>ctypes_dlerror</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>Py_None</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type><name>py_dl_sym</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>char</name> *</type><name>name</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>void</name> *</type><name>handle</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>void</name> *</type><name>ptr</name></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"O&amp;s:dlsym"</expr></argument>,
<argument><expr>&amp;<name>_parse_voidp</name></expr></argument>, <argument><expr>&amp;<name>handle</name></expr></argument>, <argument><expr>&amp;<name>name</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>ptr</name> = <call><name>ctypes_dlsym</name><argument_list>(<argument><expr>(<name>void</name>*)<name>handle</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>ptr</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_OSError</name></expr></argument>,
<argument><expr><call><name>ctypes_dlerror</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<return>return <expr><call><name>PyLong_FromVoidPtr</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>call_function</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>void</name> *</type><name>func</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>arguments</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>result</name></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>,
<argument><expr>"O&amp;O!"</expr></argument>,
<argument><expr>&amp;<name>_parse_voidp</name></expr></argument>, <argument><expr>&amp;<name>func</name></expr></argument>,
<argument><expr>&amp;<name>PyTuple_Type</name></expr></argument>, <argument><expr>&amp;<name>arguments</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>result</name> = <call><name>_CallProc</name><argument_list>(<argument><expr>(<name>PPROC</name>)<name>func</name></expr></argument>,
<argument><expr><name>arguments</name></expr></argument>,
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MS_WIN32</name></expr></argument>)</argument_list></call></expr></cpp:if>
<argument><expr><name>NULL</name></expr></argument>,
<argument><expr><name>NULL</name></expr></argument>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<argument><expr>0</expr></argument>,
<argument><expr><name>NULL</name></expr></argument>,
<argument><expr><name>NULL</name></expr></argument>,
<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>result</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>call_cdeclfunction</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>void</name> *</type><name>func</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>arguments</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>result</name></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>,
<argument><expr>"O&amp;O!"</expr></argument>,
<argument><expr>&amp;<name>_parse_voidp</name></expr></argument>, <argument><expr>&amp;<name>func</name></expr></argument>,
<argument><expr>&amp;<name>PyTuple_Type</name></expr></argument>, <argument><expr>&amp;<name>arguments</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>result</name> = <call><name>_CallProc</name><argument_list>(<argument><expr>(<name>PPROC</name>)<name>func</name></expr></argument>,
<argument><expr><name>arguments</name></expr></argument>,
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MS_WIN32</name></expr></argument>)</argument_list></call></expr></cpp:if>
<argument><expr><name>NULL</name></expr></argument>,
<argument><expr><name>NULL</name></expr></argument>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<argument><expr><name>FUNCFLAG_CDECL</name></expr></argument>,
<argument><expr><name>NULL</name></expr></argument>,
<argument><expr><name>NULL</name></expr></argument>,
<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>result</name></expr>;</return>
}</block></function>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name><name>sizeof_doc</name><index>[]</index></name> <init>=
<expr>"sizeof(C type) -&gt; integer\n"
"sizeof(C instance) -&gt; integer\n"
"Return the size in bytes of a C instance"</expr></init></decl>;</decl_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>sizeof_func</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>obj</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>StgDictObject</name> *</type><name>dict</name></decl>;</decl_stmt>
<expr_stmt><expr><name>dict</name> = <call><name>PyType_stgdict</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>dict</name></expr>)</condition><then>
<return>return <expr><call><name>PyInt_FromSsize_t</name><argument_list>(<argument><expr><name><name>dict</name>-&gt;<name>size</name></name></expr></argument>)</argument_list></call></expr>;</return></then></if>
<if>if <condition>(<expr><call><name>CDataObject_Check</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><call><name>PyInt_FromSsize_t</name><argument_list>(<argument><expr>((<name>CDataObject</name> *)<name>obj</name>)-&gt;<name>b_size</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
<argument><expr>"this type has no size"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></function>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name><name>alignment_doc</name><index>[]</index></name> <init>=
<expr>"alignment(C type) -&gt; integer\n"
"alignment(C instance) -&gt; integer\n"
"Return the alignment requirements of a C instance"</expr></init></decl>;</decl_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>align_func</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>obj</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>StgDictObject</name> *</type><name>dict</name></decl>;</decl_stmt>
<expr_stmt><expr><name>dict</name> = <call><name>PyType_stgdict</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>dict</name></expr>)</condition><then>
<return>return <expr><call><name>PyInt_FromSsize_t</name><argument_list>(<argument><expr><name><name>dict</name>-&gt;<name>align</name></name></expr></argument>)</argument_list></call></expr>;</return></then></if>
<expr_stmt><expr><name>dict</name> = <call><name>PyObject_stgdict</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>dict</name></expr>)</condition><then>
<return>return <expr><call><name>PyInt_FromSsize_t</name><argument_list>(<argument><expr><name><name>dict</name>-&gt;<name>align</name></name></expr></argument>)</argument_list></call></expr>;</return></then></if>
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
<argument><expr>"no alignment info"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></function>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name><name>byref_doc</name><index>[]</index></name> <init>=
<expr>"byref(C instance[, offset=0]) -&gt; byref-object\n"
"Return a pointer lookalike to a C instance, only usable\n"
"as function argument"</expr></init></decl>;</decl_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>byref</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyCArgObject</name> *</type><name>parg</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>obj</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>pyoffset</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>offset</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>PyArg_UnpackTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"byref"</expr></argument>, <argument><expr>1</expr></argument>, <argument><expr>2</expr></argument>,
<argument><expr>&amp;<name>obj</name></expr></argument>, <argument><expr>&amp;<name>pyoffset</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<if>if <condition>(<expr><name>pyoffset</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>offset</name> = <call><name>PyNumber_AsSsize_t</name><argument_list>(<argument><expr><name>pyoffset</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>offset</name> == -1 &amp;&amp; <call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
}</block></then></if>
<if>if <condition>(<expr>!<call><name>CDataObject_Check</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
<argument><expr>"byref() argument must be a ctypes instance, not '%s'"</expr></argument>,
<argument><expr><call><name>Py_TYPE</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call>-&gt;<name>tp_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>parg</name> = <call><name>new_CArgObject</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>parg</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name><name>parg</name>-&gt;<name>tag</name></name> = 'P'</expr>;</expr_stmt>
<expr_stmt><expr><name><name>parg</name>-&gt;<name>pffi_type</name></name> = &amp;<name>ffi_type_pointer</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>parg</name>-&gt;<name>obj</name></name> = <name>obj</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>parg</name>-&gt;<name>value</name>.<name>p</name></name> = <call>(<name>char</name> *)<argument_list>(<argument><expr>(<name>CDataObject</name> *)<name>obj</name></expr></argument>)</argument_list></call>-&gt;<name>b_ptr</name> + <name>offset</name></expr>;</expr_stmt>
<return>return <expr>(<name>PyObject</name> *)<name>parg</name></expr>;</return>
}</block></function>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name><name>addressof_doc</name><index>[]</index></name> <init>=
<expr>"addressof(C instance) -&gt; integer\n"
"Return the address of the C instance internal buffer"</expr></init></decl>;</decl_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>addressof</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>obj</name></decl></param>)</parameter_list> <block>{
<if>if <condition>(<expr><call><name>CDataObject_Check</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><call><name>PyLong_FromVoidPtr</name><argument_list>(<argument><expr>((<name>CDataObject</name> *)<name>obj</name>)-&gt;<name>b_ptr</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
<argument><expr>"invalid type"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>converter</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>obj</name></decl></param>, <param><decl><type><name>void</name> **</type><name>address</name></decl></param>)</parameter_list> <block>{
<expr_stmt><expr>*<name>address</name> = <call><name>PyLong_AsVoidPtr</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>*<name>address</name> != <name>NULL</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>My_PyObj_FromPtr</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>ob</name></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"O&amp;:PyObj_FromPtr"</expr></argument>, <argument><expr><name>converter</name></expr></argument>, <argument><expr>&amp;<name>ob</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>ob</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>ob</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>My_Py_INCREF</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>arg</name></decl></param>)</parameter_list> <block>{
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>arg</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>My_Py_DECREF</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>arg</name></decl></param>)</parameter_list> <block>{
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>arg</name></expr>;</return>
}</block></function>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>CTYPES_UNICODE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name><name>set_conversion_mode_doc</name><index>[]</index></name> <init>=
<expr>"set_conversion_mode(encoding, errors) -&gt; (previous-encoding, previous-errors)\n\
\n\
Set the encoding and error handling ctypes uses when converting\n\
between unicode and strings. Returns the previous values.\n"</expr></init></decl>;</decl_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>set_conversion_mode</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>char</name> *</type><name>coding</name></decl>, *<decl><type ref="prev"/><name>mode</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>result</name></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"zs:set_conversion_mode"</expr></argument>, <argument><expr>&amp;<name>coding</name></expr></argument>, <argument><expr>&amp;<name>mode</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>result</name> = <call><name>Py_BuildValue</name><argument_list>(<argument><expr>"(zz)"</expr></argument>, <argument><expr><name>conversion_mode_encoding</name></expr></argument>, <argument><expr><name>conversion_mode_errors</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>coding</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyMem_Free</name><argument_list>(<argument><expr><name>conversion_mode_encoding</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>conversion_mode_encoding</name> = <call><name>PyMem_Malloc</name><argument_list>(<argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>coding</name></expr></argument>)</argument_list></call> + 1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>conversion_mode_encoding</name></expr></argument>, <argument><expr><name>coding</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr><name>conversion_mode_encoding</name> = <name>NULL</name></expr>;</expr_stmt>
}</block></else></if>
<expr_stmt><expr><call><name>PyMem_Free</name><argument_list>(<argument><expr><name>conversion_mode_errors</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>conversion_mode_errors</name> = <call><name>PyMem_Malloc</name><argument_list>(<argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>mode</name></expr></argument>)</argument_list></call> + 1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>conversion_mode_errors</name></expr></argument>, <argument><expr><name>mode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>result</name></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>resize</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>CDataObject</name> *</type><name>obj</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>StgDictObject</name> *</type><name>dict</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>size</name></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>,
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>(<name>PY_VERSION_HEX</name> &lt; 0x02050000)</expr></cpp:if>
<argument><expr>"Oi:resize"</expr></argument>,
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<argument><expr>"On:resize"</expr></argument>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<argument><expr>&amp;<name>obj</name></expr></argument>, <argument><expr>&amp;<name>size</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>dict</name> = <call><name>PyObject_stgdict</name><argument_list>(<argument><expr>(<name>PyObject</name> *)<name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>dict</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
<argument><expr>"excepted ctypes instance"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<if>if <condition>(<expr><name>size</name> &lt; <name><name>dict</name>-&gt;<name>size</name></name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>,
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PY_VERSION_HEX</name> &lt; 0x02050000</expr></cpp:if>
<argument><expr>"minimum size is %d"</expr></argument>,
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<argument><expr>"minimum size is %zd"</expr></argument>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<argument><expr><name><name>dict</name>-&gt;<name>size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<if>if <condition>(<expr><name><name>obj</name>-&gt;<name>b_needsfree</name></name> == 0</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>,
<argument><expr>"Memory cannot be resized because this object doesn't own it"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<if>if <condition>(<expr><name>size</name> &lt;= <sizeof>sizeof<argument_list>(<argument><expr><name><name>obj</name>-&gt;<name>b_value</name></name></expr></argument>)</argument_list></sizeof></expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>obj</name>-&gt;<name>b_size</name></name> = <name>size</name></expr>;</expr_stmt>
<goto>goto <name>done</name>;</goto>
}</block></then></if>
<if>if <condition>(<expr><name><name>obj</name>-&gt;<name>b_size</name></name> &lt;= <sizeof>sizeof<argument_list>(<argument><expr><name><name>obj</name>-&gt;<name>b_value</name></name></expr></argument>)</argument_list></sizeof></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>void</name> *</type><name>ptr</name> <init>= <expr><call><name>PyMem_Malloc</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>ptr</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><call><name>PyErr_NoMemory</name><argument_list>()</argument_list></call></expr>;</return></then></if>
<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><name><name>obj</name>-&gt;<name>b_ptr</name></name></expr></argument>, <argument><expr><name><name>obj</name>-&gt;<name>b_size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>obj</name>-&gt;<name>b_ptr</name></name> = <name>ptr</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>obj</name>-&gt;<name>b_size</name></name> = <name>size</name></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<decl_stmt><decl><type><name>void</name> *</type> <name>ptr</name> <init>= <expr><call><name>PyMem_Realloc</name><argument_list>(<argument><expr><name><name>obj</name>-&gt;<name>b_ptr</name></name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>ptr</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><call><name>PyErr_NoMemory</name><argument_list>()</argument_list></call></expr>;</return></then></if>
<expr_stmt><expr><name><name>obj</name>-&gt;<name>b_ptr</name></name> = <name>ptr</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>obj</name>-&gt;<name>b_size</name></name> = <name>size</name></expr>;</expr_stmt>
}</block></else></if>
<label><name>done</name>:</label>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>Py_None</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>unpickle</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>typ</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>state</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>result</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>tmp</name></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"OO"</expr></argument>, <argument><expr>&amp;<name>typ</name></expr></argument>, <argument><expr>&amp;<name>state</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>result</name> = <call><name>PyObject_CallMethod</name><argument_list>(<argument><expr><name>typ</name></expr></argument>, <argument><expr>"__new__"</expr></argument>, <argument><expr>"O"</expr></argument>, <argument><expr><name>typ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>result</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>tmp</name> = <call><name>PyObject_CallMethod</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr>"__setstate__"</expr></argument>, <argument><expr>"O"</expr></argument>, <argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>tmp</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>result</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>POINTER</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>cls</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>result</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyTypeObject</name> *</type><name>typ</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>key</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>buf</name></decl>;</decl_stmt>
<expr_stmt><expr><name>result</name> = <call><name>PyDict_GetItem</name><argument_list>(<argument><expr><name>_pointer_type_cache</name></expr></argument>, <argument><expr><name>cls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>result</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>result</name></expr>;</return>
}</block></then></if>
<if>if <condition>(<expr><call><name>PyString_CheckExact</name><argument_list>(<argument><expr><name>cls</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><name>buf</name> = <call><name>alloca</name><argument_list>(<argument><expr><call><name>strlen</name><argument_list>(<argument><expr><call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>cls</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> + 3 + 1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr>"LP_%s"</expr></argument>, <argument><expr><call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>cls</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>result</name> = <call><name>PyObject_CallFunction</name><argument_list>(<argument><expr>(<name>PyObject</name> *)<call><name>Py_TYPE</name><argument_list>(<argument><expr>&amp;<name>Pointer_Type</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr>"s(O){}"</expr></argument>,
<argument><expr><name>buf</name></expr></argument>,
<argument><expr>&amp;<name>Pointer_Type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>result</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>result</name></expr>;</return></then></if>
<expr_stmt><expr><name>key</name> = <call><name>PyLong_FromVoidPtr</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else <if>if <condition>(<expr><call><name>PyType_Check</name><argument_list>(<argument><expr><name>cls</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><name>typ</name> = (<name>PyTypeObject</name> *)<name>cls</name></expr>;</expr_stmt>
<expr_stmt><expr><name>buf</name> = <call><name>alloca</name><argument_list>(<argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name><name>typ</name>-&gt;<name>tp_name</name></name></expr></argument>)</argument_list></call> + 3 + 1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr>"LP_%s"</expr></argument>, <argument><expr><name><name>typ</name>-&gt;<name>tp_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>result</name> = <call><name>PyObject_CallFunction</name><argument_list>(<argument><expr>(<name>PyObject</name> *)<call><name>Py_TYPE</name><argument_list>(<argument><expr>&amp;<name>Pointer_Type</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr>"s(O){sO}"</expr></argument>,
<argument><expr><name>buf</name></expr></argument>,
<argument><expr>&amp;<name>Pointer_Type</name></expr></argument>,
<argument><expr>"_type_"</expr></argument>, <argument><expr><name>cls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>result</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>result</name></expr>;</return></then></if>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>cls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>key</name> = <name>cls</name></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>, <argument><expr>"must be a ctypes type"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></else></if></else></if>
<if>if <condition>(<expr>-1 == <call><name>PyDict_SetItem</name><argument_list>(<argument><expr><name>_pointer_type_cache</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>result</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>pointer</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>arg</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>result</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>typ</name></decl>;</decl_stmt>
<expr_stmt><expr><name>typ</name> = <call><name>PyDict_GetItem</name><argument_list>(<argument><expr><name>_pointer_type_cache</name></expr></argument>, <argument><expr>(<name>PyObject</name> *)<call><name>Py_TYPE</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>typ</name></expr>)</condition><then>
<return>return <expr><call><name>PyObject_CallFunctionObjArgs</name><argument_list>(<argument><expr><name>typ</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
<expr_stmt><expr><name>typ</name> = <call><name>POINTER</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr>(<name>PyObject</name> *)<call><name>Py_TYPE</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>typ</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>result</name> = <call><name>PyObject_CallFunctionObjArgs</name><argument_list>(<argument><expr><name>typ</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>typ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>result</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>buffer_info</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>arg</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>StgDictObject</name> *</type><name>dict</name> <init>= <expr><call><name>PyType_stgdict</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>shape</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>i</name></decl>;</decl_stmt>
<if>if <condition>(<expr><name>dict</name> == <name>NULL</name></expr>)</condition><then>
<expr_stmt><expr><name>dict</name> = <call><name>PyObject_stgdict</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<if>if <condition>(<expr><name>dict</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
<argument><expr>"not a ctypes type or object"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>shape</name> = <call><name>PyTuple_New</name><argument_list>(<argument><expr><name><name>dict</name>-&gt;<name>ndim</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>shape</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; (<name>int</name>)<name><name>dict</name>-&gt;<name>ndim</name></name></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>)
<expr_stmt><expr><call><name>PyTuple_SET_ITEM</name><argument_list>(<argument><expr><name>shape</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><call><name>PyLong_FromSsize_t</name><argument_list>(<argument><expr><name><name>dict</name>-&gt;<name>shape</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></for>
<if>if <condition>(<expr><call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>shape</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<return>return <expr><call><name>Py_BuildValue</name><argument_list>(<argument><expr>"siN"</expr></argument>, <argument><expr><name><name>dict</name>-&gt;<name>format</name></name></expr></argument>, <argument><expr><name><name>dict</name>-&gt;<name>ndim</name></name></expr></argument>, <argument><expr><name>shape</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<decl_stmt><decl><type><name>PyMethodDef</name></type> <name><name>module_methods</name><index>[]</index></name> <init>= <expr><block>{
<expr><block>{<expr>"get_errno"</expr>, <expr><name>get_errno</name></expr>, <expr><name>METH_NOARGS</name></expr>}</block></expr>,
<expr><block>{<expr>"set_errno"</expr>, <expr><name>set_errno</name></expr>, <expr><name>METH_VARARGS</name></expr>}</block></expr>,
<expr><block>{<expr>"POINTER"</expr>, <expr><name>POINTER</name></expr>, <expr><name>METH_O</name></expr> }</block></expr>,
<expr><block>{<expr>"pointer"</expr>, <expr><name>pointer</name></expr>, <expr><name>METH_O</name></expr> }</block></expr>,
<expr><block>{<expr>"_unpickle"</expr>, <expr><name>unpickle</name></expr>, <expr><name>METH_VARARGS</name></expr> }</block></expr>,
<expr><block>{
<expr>"_buffer_info"</expr>, <expr><name>buffer_info</name></expr>, <expr><name>METH_O</name></expr>,
<expr>"Return buffer interface information (for testing only)"</expr>
}</block></expr>,
<expr><block>{<expr>"resize"</expr>, <expr><name>resize</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr>"Resize the memory buffer of a ctypes instance"</expr>}</block></expr>,
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>CTYPES_UNICODE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"set_conversion_mode"</expr>, <expr><name>set_conversion_mode</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>set_conversion_mode_doc</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MS_WIN32</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"get_last_error"</expr>, <expr><name>get_last_error</name></expr>, <expr><name>METH_NOARGS</name></expr>}</block></expr>,
<expr><block>{<expr>"set_last_error"</expr>, <expr><name>set_last_error</name></expr>, <expr><name>METH_VARARGS</name></expr>}</block></expr>,
<expr><block>{<expr>"CopyComPointer"</expr>, <expr><name>copy_com_pointer</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>copy_com_pointer_doc</name></expr>}</block></expr>,
<expr><block>{<expr>"FormatError"</expr>, <expr><name>format_error</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>format_error_doc</name></expr>}</block></expr>,
<expr><block>{<expr>"LoadLibrary"</expr>, <expr><name>load_library</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>load_library_doc</name></expr>}</block></expr>,
<expr><block>{<expr>"FreeLibrary"</expr>, <expr><name>free_library</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>free_library_doc</name></expr>}</block></expr>,
<expr><block>{<expr>"call_commethod"</expr>, <expr><name>call_commethod</name></expr>, <expr><name>METH_VARARGS</name></expr> }</block></expr>,
<expr><block>{<expr>"_check_HRESULT"</expr>, <expr><name>check_hresult</name></expr>, <expr><name>METH_VARARGS</name></expr>}</block></expr>,
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<expr><block>{
<expr>"dlopen"</expr>, <expr><name>py_dl_open</name></expr>, <expr><name>METH_VARARGS</name></expr>,
<expr>"dlopen(name, flag={RTLD_GLOBAL|RTLD_LOCAL}) open a shared library"</expr>
}</block></expr>,
<expr><block>{<expr>"dlclose"</expr>, <expr><name>py_dl_close</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr>"dlclose a library"</expr>}</block></expr>,
<expr><block>{<expr>"dlsym"</expr>, <expr><name>py_dl_sym</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr>"find symbol in shared library"</expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr><block>{<expr>"alignment"</expr>, <expr><name>align_func</name></expr>, <expr><name>METH_O</name></expr>, <expr><name>alignment_doc</name></expr>}</block></expr>,
<expr><block>{<expr>"sizeof"</expr>, <expr><name>sizeof_func</name></expr>, <expr><name>METH_O</name></expr>, <expr><name>sizeof_doc</name></expr>}</block></expr>,
<expr><block>{<expr>"byref"</expr>, <expr><name>byref</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>byref_doc</name></expr>}</block></expr>,
<expr><block>{<expr>"addressof"</expr>, <expr><name>addressof</name></expr>, <expr><name>METH_O</name></expr>, <expr><name>addressof_doc</name></expr>}</block></expr>,
<expr><block>{<expr>"call_function"</expr>, <expr><name>call_function</name></expr>, <expr><name>METH_VARARGS</name></expr> }</block></expr>,
<expr><block>{<expr>"call_cdeclfunction"</expr>, <expr><name>call_cdeclfunction</name></expr>, <expr><name>METH_VARARGS</name></expr> }</block></expr>,
<expr><block>{<expr>"PyObj_FromPtr"</expr>, <expr><name>My_PyObj_FromPtr</name></expr>, <expr><name>METH_VARARGS</name></expr> }</block></expr>,
<expr><block>{<expr>"Py_INCREF"</expr>, <expr><name>My_Py_INCREF</name></expr>, <expr><name>METH_O</name></expr> }</block></expr>,
<expr><block>{<expr>"Py_DECREF"</expr>, <expr><name>My_Py_DECREF</name></expr>, <expr><name>METH_O</name></expr> }</block></expr>,
<expr><block>{<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>}</block></expr>
}</block></expr></init></decl>;</decl_stmt>
</unit>
