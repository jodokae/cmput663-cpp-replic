<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C" filename="projects/cpython-2.6.1/_cppstats/Modules/_ctypes/libffi/src/pa/ffi.c"><cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;ffi.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;ffi_common.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdlib.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdio.h&gt;</cpp:file></cpp:include>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ROUND_UP</name><parameter_list>(<param><type><name>v</name></type></param>, <param><type><name>a</name></type></param>)</parameter_list></cpp:macro> <cpp:value>(((size_t)(v) + (a) - 1) &amp; ~((a) - 1))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MIN_STACK_SIZE</name></cpp:macro> <cpp:value>64</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FIRST_ARG_SLOT</name></cpp:macro> <cpp:value>9</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DEBUG_LEVEL</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>fldw</name><parameter_list>(<param><type><name>addr</name></type></param>, <param><type><name>fpreg</name></type></param>)</parameter_list></cpp:macro> <cpp:value>__asm__ volatile ("fldw 0(%0), %%" #fpreg "L" : : "r"(addr) : #fpreg)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>fstw</name><parameter_list>(<param><type><name>fpreg</name></type></param>, <param><type><name>addr</name></type></param>)</parameter_list></cpp:macro> <cpp:value>__asm__ volatile ("fstw %%" #fpreg "L, 0(%0)" : : "r"(addr))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>fldd</name><parameter_list>(<param><type><name>addr</name></type></param>, <param><type><name>fpreg</name></type></param>)</parameter_list></cpp:macro> <cpp:value>__asm__ volatile ("fldd 0(%0), %%" #fpreg : : "r"(addr) : #fpreg)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>fstd</name><parameter_list>(<param><type><name>fpreg</name></type></param>, <param><type><name>addr</name></type></param>)</parameter_list></cpp:macro> <cpp:value>__asm__ volatile ("fstd %%" #fpreg "L, 0(%0)" : : "r"(addr))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>debug</name><parameter_list>(<param><type><name>lvl</name></type></param>, <param><type><name>x</name>...</type></param>)</parameter_list></cpp:macro> <cpp:value>do { if (lvl &lt;= DEBUG_LEVEL) { printf(x); } } while (0)</cpp:value></cpp:define>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>int</name></type> <name>ffi_struct_type</name><parameter_list>(<param><decl><type><name>ffi_type</name> *</type><name>t</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>size_t</name></type> <name>sz</name> <init>= <expr><name><name>t</name>-&gt;<name>size</name></name></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>sz</name> &lt;= 1</expr>)</condition><then>
<return>return <expr><name>FFI_TYPE_UINT8</name></expr>;</return></then>
<else>else <if>if <condition>(<expr><name>sz</name> == 2</expr>)</condition><then>
<return>return <expr><name>FFI_TYPE_SMALL_STRUCT2</name></expr>;</return></then>
<else>else <if>if <condition>(<expr><name>sz</name> == 3</expr>)</condition><then>
<return>return <expr><name>FFI_TYPE_SMALL_STRUCT3</name></expr>;</return></then>
<else>else <if>if <condition>(<expr><name>sz</name> == 4</expr>)</condition><then>
<return>return <expr><name>FFI_TYPE_SMALL_STRUCT4</name></expr>;</return></then>
<else>else <if>if <condition>(<expr><name>sz</name> == 5</expr>)</condition><then>
<return>return <expr><name>FFI_TYPE_SMALL_STRUCT5</name></expr>;</return></then>
<else>else <if>if <condition>(<expr><name>sz</name> == 6</expr>)</condition><then>
<return>return <expr><name>FFI_TYPE_SMALL_STRUCT6</name></expr>;</return></then>
<else>else <if>if <condition>(<expr><name>sz</name> == 7</expr>)</condition><then>
<return>return <expr><name>FFI_TYPE_SMALL_STRUCT7</name></expr>;</return></then>
<else>else <if>if <condition>(<expr><name>sz</name> &lt;= 8</expr>)</condition><then>
<return>return <expr><name>FFI_TYPE_SMALL_STRUCT8</name></expr>;</return></then>
<else>else
<return>return <expr><name>FFI_TYPE_STRUCT</name></expr>;</return></else></if></else></if></else></if></else></if></else></if></else></if></else></if></else></if>
}</block></function>
<function><type><name>void</name></type> <name>ffi_prep_args_pa32</name><parameter_list>(<param><decl><type><name>UINT32</name> *</type><name>stack</name></decl></param>, <param><decl><type><name>extended_cif</name> *</type><name>ecif</name></decl></param>, <param><decl><type><name>unsigned</name></type> <name>bytes</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>register</name> <name>unsigned</name> <name>int</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>register</name> <name>ffi_type</name> **</type><name>p_arg</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>register</name> <name>void</name> **</type><name>p_argv</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>slot</name> <init>= <expr><name>FIRST_ARG_SLOT</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>dest_cpy</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>len</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>debug</name><argument_list>(<argument><expr>1</expr></argument>, <argument><expr>"%s: stack = %p, ecif = %p, bytes = %u\n"</expr></argument>, <argument><expr><name>__FUNCTION__</name></expr></argument>, <argument><expr><name>stack</name></expr></argument>,
<argument><expr><name>ecif</name></expr></argument>, <argument><expr><name>bytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>p_arg</name> = <name><name>ecif</name>-&gt;<name>cif</name>-&gt;<name>arg_types</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>p_argv</name> = <name><name>ecif</name>-&gt;<name>avalue</name></name></expr>;</expr_stmt>
<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name><name>ecif</name>-&gt;<name>cif</name>-&gt;<name>nargs</name></name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
<decl_stmt><decl><type><name>int</name></type> <name>type</name> <init>= <expr><name>(*<name>p_arg</name>)-&gt;<name>type</name></name></expr></init></decl>;</decl_stmt>
<switch>switch <condition>(<expr><name>type</name></expr>)</condition> <block>{
<case>case <expr><name>FFI_TYPE_SINT8</name></expr>:
<expr_stmt><expr>*<call>(<name>SINT32</name> *)<argument_list>(<argument><expr><name>stack</name> - <name>slot</name></expr></argument>)</argument_list></call> = *<call>(<name>SINT8</name> *)<argument_list>(<argument><expr>*<name>p_argv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr><name>FFI_TYPE_UINT8</name></expr>:
<expr_stmt><expr>*<call>(<name>UINT32</name> *)<argument_list>(<argument><expr><name>stack</name> - <name>slot</name></expr></argument>)</argument_list></call> = *<call>(<name>UINT8</name> *)<argument_list>(<argument><expr>*<name>p_argv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr><name>FFI_TYPE_SINT16</name></expr>:
<expr_stmt><expr>*<call>(<name>SINT32</name> *)<argument_list>(<argument><expr><name>stack</name> - <name>slot</name></expr></argument>)</argument_list></call> = *<call>(<name>SINT16</name> *)<argument_list>(<argument><expr>*<name>p_argv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr><name>FFI_TYPE_UINT16</name></expr>:
<expr_stmt><expr>*<call>(<name>UINT32</name> *)<argument_list>(<argument><expr><name>stack</name> - <name>slot</name></expr></argument>)</argument_list></call> = *<call>(<name>UINT16</name> *)<argument_list>(<argument><expr>*<name>p_argv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr><name>FFI_TYPE_UINT32</name></expr>:
</case><case>case <expr><name>FFI_TYPE_SINT32</name></expr>:
</case><case>case <expr><name>FFI_TYPE_POINTER</name></expr>:
<expr_stmt><expr><call><name>debug</name><argument_list>(<argument><expr>3</expr></argument>, <argument><expr>"Storing UINT32 %u in slot %u\n"</expr></argument>, <argument><expr>*<call>(<name>UINT32</name> *)<argument_list>(<argument><expr>*<name>p_argv</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr>*<call>(<name>UINT32</name> *)<argument_list>(<argument><expr><name>stack</name> - <name>slot</name></expr></argument>)</argument_list></call> = *<call>(<name>UINT32</name> *)<argument_list>(<argument><expr>*<name>p_argv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr><name>FFI_TYPE_UINT64</name></expr>:
</case><case>case <expr><name>FFI_TYPE_SINT64</name></expr>:
<expr_stmt><expr><name>slot</name> += (<name>slot</name> &amp; 1) ? 1 : 2</expr>;</expr_stmt>
<expr_stmt><expr>*<call>(<name>UINT64</name> *)<argument_list>(<argument><expr><name>stack</name> - <name>slot</name></expr></argument>)</argument_list></call> = *<call>(<name>UINT64</name> *)<argument_list>(<argument><expr>*<name>p_argv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr><name>FFI_TYPE_FLOAT</name></expr>:
<expr_stmt><expr><call><name>debug</name><argument_list>(<argument><expr>3</expr></argument>, <argument><expr>"Storing UINT32(float) in slot %u\n"</expr></argument>, <argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr>*<call>(<name>UINT32</name> *)<argument_list>(<argument><expr><name>stack</name> - <name>slot</name></expr></argument>)</argument_list></call> = *<call>(<name>UINT32</name> *)<argument_list>(<argument><expr>*<name>p_argv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<switch>switch <condition>(<expr><name>slot</name> - <name>FIRST_ARG_SLOT</name></expr>)</condition> <block>{
<case>case <expr>0</expr>:
<expr_stmt><expr><call><name>fldw</name><argument_list>(<argument><expr><name>stack</name> - <name>slot</name></expr></argument>, <argument><expr><name>fr4</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr>1</expr>:
<expr_stmt><expr><call><name>fldw</name><argument_list>(<argument><expr><name>stack</name> - <name>slot</name></expr></argument>, <argument><expr><name>fr5</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr>2</expr>:
<expr_stmt><expr><call><name>fldw</name><argument_list>(<argument><expr><name>stack</name> - <name>slot</name></expr></argument>, <argument><expr><name>fr6</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr>3</expr>:
<expr_stmt><expr><call><name>fldw</name><argument_list>(<argument><expr><name>stack</name> - <name>slot</name></expr></argument>, <argument><expr><name>fr7</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</case>}</block></switch>
<break>break;</break>
</case><case>case <expr><name>FFI_TYPE_DOUBLE</name></expr>:
<expr_stmt><expr><name>slot</name> += (<name>slot</name> &amp; 1) ? 1 : 2</expr>;</expr_stmt>
<expr_stmt><expr><call><name>debug</name><argument_list>(<argument><expr>3</expr></argument>, <argument><expr>"Storing UINT64(double) at slot %u\n"</expr></argument>, <argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr>*<call>(<name>UINT64</name> *)<argument_list>(<argument><expr><name>stack</name> - <name>slot</name></expr></argument>)</argument_list></call> = *<call>(<name>UINT64</name> *)<argument_list>(<argument><expr>*<name>p_argv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<switch>switch <condition>(<expr><name>slot</name> - <name>FIRST_ARG_SLOT</name></expr>)</condition> <block>{
<case>case <expr>1</expr>:
<expr_stmt><expr><call><name>fldd</name><argument_list>(<argument><expr><name>stack</name> - <name>slot</name></expr></argument>, <argument><expr><name>fr5</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr>3</expr>:
<expr_stmt><expr><call><name>fldd</name><argument_list>(<argument><expr><name>stack</name> - <name>slot</name></expr></argument>, <argument><expr><name>fr7</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</case>}</block></switch>
<break>break;</break>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>PA_HPUX</name></expr></argument>)</argument_list></call></expr></cpp:if>
</case><case>case <expr><name>FFI_TYPE_LONGDOUBLE</name></expr>:
<expr_stmt><expr>*<call>(<name>UINT32</name> *)<argument_list>(<argument><expr><name>stack</name> - <name>slot</name></expr></argument>)</argument_list></call> = <call>(<name>UINT32</name>)<argument_list>(<argument><expr>*<name>p_argv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</case><case>case <expr><name>FFI_TYPE_STRUCT</name></expr>:
<expr_stmt><expr><name>len</name> = <name>(*<name>p_arg</name>)-&gt;<name>size</name></name></expr>;</expr_stmt>
<if>if <condition>(<expr><name>len</name> &lt;= 4</expr>)</condition><then> <block>{
<expr_stmt><expr><name>dest_cpy</name> = <call>(<name>char</name> *)<argument_list>(<argument><expr><name>stack</name> - <name>slot</name></expr></argument>)</argument_list></call> + 4 - <name>len</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>dest_cpy</name></expr></argument>, <argument><expr>(<name>char</name> *)*<name>p_argv</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else <if>if <condition>(<expr><name>len</name> &lt;= 8</expr>)</condition><then> <block>{
<expr_stmt><expr><name>slot</name> += (<name>slot</name> &amp; 1) ? 1 : 2</expr>;</expr_stmt>
<expr_stmt><expr><name>dest_cpy</name> = <call>(<name>char</name> *)<argument_list>(<argument><expr><name>stack</name> - <name>slot</name></expr></argument>)</argument_list></call> + 8 - <name>len</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>dest_cpy</name></expr></argument>, <argument><expr>(<name>char</name> *)*<name>p_argv</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else
<expr_stmt><expr>*<call>(<name>UINT32</name> *)<argument_list>(<argument><expr><name>stack</name> - <name>slot</name></expr></argument>)</argument_list></call> = <call>(<name>UINT32</name>)<argument_list>(<argument><expr>*<name>p_argv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if></else></if>
<break>break;</break>
</case><default>default:
<expr_stmt><expr><call><name>FFI_ASSERT</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
</default>}</block></switch>
<expr_stmt><expr><name>slot</name>++</expr>;</expr_stmt>
<expr_stmt><expr><name>p_arg</name>++</expr>;</expr_stmt>
<expr_stmt><expr><name>p_argv</name>++</expr>;</expr_stmt>
}</block></for>
<block>{
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>n</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>debug</name><argument_list>(<argument><expr>5</expr></argument>, <argument><expr>"Stack setup:\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for (<init><expr><name>n</name> = 0</expr>;</init> <condition><expr><name>n</name> &lt; (<name>bytes</name> + 3) / 4</expr>;</condition> <incr><expr><name>n</name>++</expr></incr>) <block>{
<if>if <condition>(<expr>(<name>n</name>%4) == 0</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>debug</name><argument_list>(<argument><expr>5</expr></argument>, <argument><expr>"\n%08x: "</expr></argument>, <argument><expr><call>(<name>unsigned</name> <name>int</name>)<argument_list>(<argument><expr><name>stack</name> - <name>n</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><call><name>debug</name><argument_list>(<argument><expr>5</expr></argument>, <argument><expr>"%08x "</expr></argument>, <argument><expr>*(<name>stack</name> - <name>n</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></for>
<expr_stmt><expr><call><name>debug</name><argument_list>(<argument><expr>5</expr></argument>, <argument><expr>"\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block>
<expr_stmt><expr><call><name>FFI_ASSERT</name><argument_list>(<argument><expr><name>slot</name> * 4 &lt;= <name>bytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>ffi_size_stack_pa32</name><parameter_list>(<param><decl><type><name>ffi_cif</name> *</type><name>cif</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>ffi_type</name> **</type><name>ptr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>z</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<for>for (<init><expr><name>ptr</name> = <name><name>cif</name>-&gt;<name>arg_types</name></name></expr>, <expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name><name>cif</name>-&gt;<name>nargs</name></name></expr>;</condition> <incr><expr><name>ptr</name>++</expr>, <expr><name>i</name>++</expr></incr>) <block>{
<decl_stmt><decl><type><name>int</name></type> <name>type</name> <init>= <expr><name>(*<name>ptr</name>)-&gt;<name>type</name></name></expr></init></decl>;</decl_stmt>
<switch>switch <condition>(<expr><name>type</name></expr>)</condition> <block>{
<case>case <expr><name>FFI_TYPE_DOUBLE</name></expr>:
</case><case>case <expr><name>FFI_TYPE_UINT64</name></expr>:
</case><case>case <expr><name>FFI_TYPE_SINT64</name></expr>:
<expr_stmt><expr><name>z</name> += 2 + (<name>z</name> &amp; 1)</expr>;</expr_stmt>
<break>break;</break>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>PA_HPUX</name></expr></argument>)</argument_list></call></expr></cpp:if>
</case><case>case <expr><name>FFI_TYPE_LONGDOUBLE</name></expr>:
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</case><case>case <expr><name>FFI_TYPE_STRUCT</name></expr>:
<expr_stmt><expr><name>z</name> += 1</expr>;</expr_stmt>
<break>break;</break>
</case><default>default:
<expr_stmt><expr><name>z</name>++</expr>;</expr_stmt>
</default>}</block></switch>
}</block></for>
<if>if <condition>(<expr><name>z</name> &lt;= 6</expr>)</condition><then>
<expr_stmt><expr><name><name>cif</name>-&gt;<name>bytes</name></name> = <name>MIN_STACK_SIZE</name></expr>;</expr_stmt></then>
<else>else
<expr_stmt><expr><name><name>cif</name>-&gt;<name>bytes</name></name> = 64 + <call><name>ROUND_UP</name><argument_list>(<argument><expr>(<name>z</name> - 6) * <sizeof>sizeof<argument_list>(<argument><expr><name>UINT32</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>MIN_STACK_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
<expr_stmt><expr><call><name>debug</name><argument_list>(<argument><expr>3</expr></argument>, <argument><expr>"Calculated stack size is %u bytes\n"</expr></argument>, <argument><expr><name><name>cif</name>-&gt;<name>bytes</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>
<function><type><name>ffi_status</name></type> <name>ffi_prep_cif_machdep</name><parameter_list>(<param><decl><type><name>ffi_cif</name> *</type><name>cif</name></decl></param>)</parameter_list> <block>{
<switch>switch <condition>(<expr><name><name>cif</name>-&gt;<name>rtype</name>-&gt;<name>type</name></name></expr>)</condition> <block>{
<case>case <expr><name>FFI_TYPE_VOID</name></expr>:
</case><case>case <expr><name>FFI_TYPE_FLOAT</name></expr>:
</case><case>case <expr><name>FFI_TYPE_DOUBLE</name></expr>:
<expr_stmt><expr><name><name>cif</name>-&gt;<name>flags</name></name> = (<name>unsigned</name>) <name><name>cif</name>-&gt;<name>rtype</name>-&gt;<name>type</name></name></expr>;</expr_stmt>
<break>break;</break>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>PA_HPUX</name></expr></argument>)</argument_list></call></expr></cpp:if>
</case><case>case <expr><name>FFI_TYPE_LONGDOUBLE</name></expr>:
<expr_stmt><expr><name><name>cif</name>-&gt;<name>flags</name></name> = <name>FFI_TYPE_STRUCT</name></expr>;</expr_stmt>
<break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</case><case>case <expr><name>FFI_TYPE_STRUCT</name></expr>:
<expr_stmt><expr><name><name>cif</name>-&gt;<name>flags</name></name> = <call><name>ffi_struct_type</name><argument_list>(<argument><expr><name><name>cif</name>-&gt;<name>rtype</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr><name>FFI_TYPE_UINT64</name></expr>:
</case><case>case <expr><name>FFI_TYPE_SINT64</name></expr>:
<expr_stmt><expr><name><name>cif</name>-&gt;<name>flags</name></name> = <name>FFI_TYPE_UINT64</name></expr>;</expr_stmt>
<break>break;</break>
</case><default>default:
<expr_stmt><expr><name><name>cif</name>-&gt;<name>flags</name></name> = <name>FFI_TYPE_INT</name></expr>;</expr_stmt>
<break>break;</break>
</default>}</block></switch>
<switch>switch <condition>(<expr><name><name>cif</name>-&gt;<name>abi</name></name></expr>)</condition> <block>{
<case>case <expr><name>FFI_PA32</name></expr>:
<expr_stmt><expr><call><name>ffi_size_stack_pa32</name><argument_list>(<argument><expr><name>cif</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</case><default>default:
<expr_stmt><expr><call><name>FFI_ASSERT</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</default>}</block></switch>
<return>return <expr><name>FFI_OK</name></expr>;</return>
}</block></function>
<function_decl><type><specifier>extern</specifier> <name>void</name></type> <name>ffi_call_pa32</name><parameter_list>(<param><function_decl><type><name>void</name></type> (*)<parameter_list>(<param><decl><type><name>UINT32</name> *</type></decl></param>, <param><decl><type><name>extended_cif</name> *</type></decl></param>, <param><decl><type><name>unsigned</name></type></decl></param>)</parameter_list></function_decl></param>,
<param><decl><type><name>extended_cif</name> *</type></decl></param>, <param><decl><type><name>unsigned</name></type></decl></param>, <param><decl><type><name>unsigned</name></type></decl></param>, <param><decl><type><name>unsigned</name> *</type></decl></param>,
<param><function_decl><type><name>void</name></type> (*<name>fn</name>)<parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list></function_decl></param>)</parameter_list>;</function_decl>
<function><type><name>void</name></type> <name>ffi_call</name><parameter_list>(<param><decl><type><name>ffi_cif</name> *</type><name>cif</name></decl></param>, <param><function_decl><type><name>void</name></type> (*<name>fn</name>)<parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list></function_decl></param>, <param><decl><type><name>void</name> *</type><name>rvalue</name></decl></param>, <param><decl><type><name>void</name> **</type><name>avalue</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>extended_cif</name></type> <name>ecif</name></decl>;</decl_stmt>
<expr_stmt><expr><name><name>ecif</name>.<name>cif</name></name> = <name>cif</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ecif</name>.<name>avalue</name></name> = <name>avalue</name></expr>;</expr_stmt>
<if>if <condition>(<expr><name>rvalue</name> == <name>NULL</name>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>PA_HPUX</name></expr></argument>)</argument_list></call></expr></cpp:if>
&amp;&amp; (<name><name>cif</name>-&gt;<name>rtype</name>-&gt;<name>type</name></name> == <name>FFI_TYPE_STRUCT</name>
|| <name><name>cif</name>-&gt;<name>rtype</name>-&gt;<name>type</name></name> == <name>FFI_TYPE_LONGDOUBLE</name>)</expr>)</condition><then>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<expr_stmt><expr>&amp;&amp; <name><name>cif</name>-&gt;<name>rtype</name>-&gt;<name>type</name></name> == <name>FFI_TYPE_STRUCT</name></expr></expr_stmt></then></if>)</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<block>{
<expr_stmt><expr><name><name>ecif</name>.<name>rvalue</name></name> = <call><name>alloca</name><argument_list>(<argument><expr><name><name>cif</name>-&gt;<name>rtype</name>-&gt;<name>size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function> <else>else
<expr_stmt><expr><name><name>ecif</name>.<name>rvalue</name></name> = <name>rvalue</name></expr>;</expr_stmt></else>
<switch>switch <condition>(<expr><name><name>cif</name>-&gt;<name>abi</name></name></expr>)</condition> <block>{
<case>case <expr><name>FFI_PA32</name></expr>:
<expr_stmt><expr><call><name>debug</name><argument_list>(<argument><expr>3</expr></argument>, <argument><expr>"Calling ffi_call_pa32: ecif=%p, bytes=%u, flags=%u, rvalue=%p, fn=%p\n"</expr></argument>, <argument><expr>&amp;<name>ecif</name></expr></argument>, <argument><expr><name><name>cif</name>-&gt;<name>bytes</name></name></expr></argument>, <argument><expr><name><name>cif</name>-&gt;<name>flags</name></name></expr></argument>, <argument><expr><name><name>ecif</name>.<name>rvalue</name></name></expr></argument>, <argument><expr>(<name>void</name> *)<name>fn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ffi_call_pa32</name><argument_list>(<argument><expr><name>ffi_prep_args_pa32</name></expr></argument>, <argument><expr>&amp;<name>ecif</name></expr></argument>, <argument><expr><name><name>cif</name>-&gt;<name>bytes</name></name></expr></argument>,
<argument><expr><name><name>cif</name>-&gt;<name>flags</name></name></expr></argument>, <argument><expr><name><name>ecif</name>.<name>rvalue</name></name></expr></argument>, <argument><expr><name>fn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</case><default>default:
<expr_stmt><expr><call><name>FFI_ASSERT</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</default>}</block></switch>
}
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>FFI_CLOSURES</name></expr></cpp:if>
ffi_status <macro><name>ffi_closure_inner_pa32</name><argument_list>(<argument>ffi_closure *closure</argument>, <argument>UINT32 *stack</argument>)</argument_list></macro> <block>{
<decl_stmt><decl><type><name>ffi_cif</name> *</type><name>cif</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>void</name> **</type><name>avalue</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>void</name> *</type><name>rvalue</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>UINT32</name></type> <name><name>ret</name><index>[<expr>2</expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ffi_type</name> **</type><name>p_arg</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>tmp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>avn</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>slot</name> <init>= <expr><name>FIRST_ARG_SLOT</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>register</name> <name>UINT32</name> <name>r28</name></type> <name>asm</name><argument_list>(<argument><expr>"r28"</expr></argument>)</argument_list></decl>;</decl_stmt>
<expr_stmt><expr><name>cif</name> = <name><name>closure</name>-&gt;<name>cif</name></name></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>cif</name>-&gt;<name>flags</name></name> == <name>FFI_TYPE_STRUCT</name></expr>)</condition><then>
<expr_stmt><expr><name>rvalue</name> = (<name>void</name> *)<name>r28</name></expr>;</expr_stmt></then>
<else>else
<expr_stmt><expr><name>rvalue</name> = &amp;<name><name>ret</name><index>[<expr>0</expr>]</index></name></expr>;</expr_stmt></else></if>
<expr_stmt><expr><name>avalue</name> = (<name>void</name> **)<call><name>alloca</name><argument_list>(<argument><expr><name><name>cif</name>-&gt;<name>nargs</name></name> * <name>FFI_SIZEOF_ARG</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>avn</name> = <name><name>cif</name>-&gt;<name>nargs</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>p_arg</name> = <name><name>cif</name>-&gt;<name>arg_types</name></name></expr>;</expr_stmt>
<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>avn</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
<decl_stmt><decl><type><name>int</name></type> <name>type</name> <init>= <expr><name>(*<name>p_arg</name>)-&gt;<name>type</name></name></expr></init></decl>;</decl_stmt>
<switch>switch <condition>(<expr><name>type</name></expr>)</condition> <block>{
<case>case <expr><name>FFI_TYPE_SINT8</name></expr>:
</case><case>case <expr><name>FFI_TYPE_UINT8</name></expr>:
</case><case>case <expr><name>FFI_TYPE_SINT16</name></expr>:
</case><case>case <expr><name>FFI_TYPE_UINT16</name></expr>:
</case><case>case <expr><name>FFI_TYPE_SINT32</name></expr>:
</case><case>case <expr><name>FFI_TYPE_UINT32</name></expr>:
</case><case>case <expr><name>FFI_TYPE_POINTER</name></expr>:
<expr_stmt><expr><name><name>avalue</name><index>[<expr><name>i</name></expr>]</index></name> = <call>(<name>char</name> *)<argument_list>(<argument><expr><name>stack</name> - <name>slot</name></expr></argument>)</argument_list></call> + <sizeof>sizeof<argument_list>(<argument><expr><name>UINT32</name></expr></argument>)</argument_list></sizeof> - <name>(*<name>p_arg</name>)-&gt;<name>size</name></name></expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr><name>FFI_TYPE_SINT64</name></expr>:
</case><case>case <expr><name>FFI_TYPE_UINT64</name></expr>:
<expr_stmt><expr><name>slot</name> += (<name>slot</name> &amp; 1) ? 1 : 2</expr>;</expr_stmt>
<expr_stmt><expr><name><name>avalue</name><index>[<expr><name>i</name></expr>]</index></name> = <call>(<name>void</name> *)<argument_list>(<argument><expr><name>stack</name> - <name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr><name>FFI_TYPE_FLOAT</name></expr>:
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>PA_LINUX</name></expr></argument>)</argument_list></call></expr></cpp:if>
<switch>switch <condition>(<expr><name>slot</name> - <name>FIRST_ARG_SLOT</name></expr>)</condition> <block>{
<case>case <expr>0</expr>:
<expr_stmt><expr><call><name>fstw</name><argument_list>(<argument><expr><name>fr4</name></expr></argument>, <argument><expr><call>(<name>void</name> *)<argument_list>(<argument><expr><name>stack</name> - <name>slot</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr>1</expr>:
<expr_stmt><expr><call><name>fstw</name><argument_list>(<argument><expr><name>fr5</name></expr></argument>, <argument><expr><call>(<name>void</name> *)<argument_list>(<argument><expr><name>stack</name> - <name>slot</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr>2</expr>:
<expr_stmt><expr><call><name>fstw</name><argument_list>(<argument><expr><name>fr6</name></expr></argument>, <argument><expr><call>(<name>void</name> *)<argument_list>(<argument><expr><name>stack</name> - <name>slot</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr>3</expr>:
<expr_stmt><expr><call><name>fstw</name><argument_list>(<argument><expr><name>fr7</name></expr></argument>, <argument><expr><call>(<name>void</name> *)<argument_list>(<argument><expr><name>stack</name> - <name>slot</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</case>}</block></switch>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><name><name>avalue</name><index>[<expr><name>i</name></expr>]</index></name> = <call>(<name>void</name> *)<argument_list>(<argument><expr><name>stack</name> - <name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr><name>FFI_TYPE_DOUBLE</name></expr>:
<expr_stmt><expr><name>slot</name> += (<name>slot</name> &amp; 1) ? 1 : 2</expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>PA_LINUX</name></expr></argument>)</argument_list></call></expr></cpp:if>
<switch>switch <condition>(<expr><name>slot</name> - <name>FIRST_ARG_SLOT</name></expr>)</condition> <block>{
<case>case <expr>1</expr>:
<expr_stmt><expr><call><name>fstd</name><argument_list>(<argument><expr><name>fr5</name></expr></argument>, <argument><expr><call>(<name>void</name> *)<argument_list>(<argument><expr><name>stack</name> - <name>slot</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr>3</expr>:
<expr_stmt><expr><call><name>fstd</name><argument_list>(<argument><expr><name>fr7</name></expr></argument>, <argument><expr><call>(<name>void</name> *)<argument_list>(<argument><expr><name>stack</name> - <name>slot</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</case>}</block></switch>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><name><name>avalue</name><index>[<expr><name>i</name></expr>]</index></name> = <call>(<name>void</name> *)<argument_list>(<argument><expr><name>stack</name> - <name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr><name>FFI_TYPE_STRUCT</name></expr>:
<if>if<condition>(<expr><name>(*<name>p_arg</name>)-&gt;<name>size</name></name> &lt;= 4</expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>avalue</name><index>[<expr><name>i</name></expr>]</index></name> = <call>(<name>void</name> *)<argument_list>(<argument><expr><name>stack</name> - <name>slot</name></expr></argument>)</argument_list></call> + <sizeof>sizeof<argument_list>(<argument><expr><name>UINT32</name></expr></argument>)</argument_list></sizeof> -
<name>(*<name>p_arg</name>)-&gt;<name>size</name></name></expr>;</expr_stmt>
}</block></then> <else>else <if>if <condition>(<expr><name>(*<name>p_arg</name>)-&gt;<name>size</name></name> &lt;= 8</expr>)</condition><then> <block>{
<expr_stmt><expr><name>slot</name> += (<name>slot</name> &amp; 1) ? 1 : 2</expr>;</expr_stmt>
<expr_stmt><expr><name><name>avalue</name><index>[<expr><name>i</name></expr>]</index></name> = <call>(<name>void</name> *)<argument_list>(<argument><expr><name>stack</name> - <name>slot</name></expr></argument>)</argument_list></call> + <sizeof>sizeof<argument_list>(<argument><expr><name>UINT64</name></expr></argument>)</argument_list></sizeof> -
<name>(*<name>p_arg</name>)-&gt;<name>size</name></name></expr>;</expr_stmt>
}</block></then> <else>else
<expr_stmt><expr><name><name>avalue</name><index>[<expr><name>i</name></expr>]</index></name> = (<name>void</name> *) *(<name>stack</name> - <name>slot</name>)</expr>;</expr_stmt></else></if></else></if>
<break>break;</break>
</case><default>default:
<expr_stmt><expr><call><name>FFI_ASSERT</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
</default>}</block></switch>
<expr_stmt><expr><name>slot</name>++</expr>;</expr_stmt>
<expr_stmt><expr><name>p_arg</name>++</expr>;</expr_stmt>
}</block></for>
<expr_stmt><expr><call>(<name><name>closure</name>-&gt;<name>fun</name></name>) <argument_list>(<argument><expr><name>cif</name></expr></argument>, <argument><expr><name>rvalue</name></expr></argument>, <argument><expr><name>avalue</name></expr></argument>, <argument><expr><name><name>closure</name>-&gt;<name>user_data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>debug</name><argument_list>(<argument><expr>3</expr></argument>, <argument><expr>"after calling function, ret[0] = %08x, ret[1] = %08x\n"</expr></argument>, <argument><expr><name><name>ret</name><index>[<expr>0</expr>]</index></name></expr></argument>,
<argument><expr><name><name>ret</name><index>[<expr>1</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<switch>switch <condition>(<expr><name><name>cif</name>-&gt;<name>flags</name></name></expr>)</condition> <block>{
<case>case <expr><name>FFI_TYPE_UINT8</name></expr>:
<expr_stmt><expr>*(<name>stack</name> - <name>FIRST_ARG_SLOT</name>) = <call>(<name>UINT8</name>)<argument_list>(<argument><expr><name><name>ret</name><index>[<expr>0</expr>]</index></name> &gt;&gt; 24</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr><name>FFI_TYPE_SINT8</name></expr>:
<expr_stmt><expr>*(<name>stack</name> - <name>FIRST_ARG_SLOT</name>) = <call>(<name>SINT8</name>)<argument_list>(<argument><expr><name><name>ret</name><index>[<expr>0</expr>]</index></name> &gt;&gt; 24</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr><name>FFI_TYPE_UINT16</name></expr>:
<expr_stmt><expr>*(<name>stack</name> - <name>FIRST_ARG_SLOT</name>) = <call>(<name>UINT16</name>)<argument_list>(<argument><expr><name><name>ret</name><index>[<expr>0</expr>]</index></name> &gt;&gt; 16</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr><name>FFI_TYPE_SINT16</name></expr>:
<expr_stmt><expr>*(<name>stack</name> - <name>FIRST_ARG_SLOT</name>) = <call>(<name>SINT16</name>)<argument_list>(<argument><expr><name><name>ret</name><index>[<expr>0</expr>]</index></name> &gt;&gt; 16</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr><name>FFI_TYPE_INT</name></expr>:
</case><case>case <expr><name>FFI_TYPE_SINT32</name></expr>:
</case><case>case <expr><name>FFI_TYPE_UINT32</name></expr>:
<expr_stmt><expr>*(<name>stack</name> - <name>FIRST_ARG_SLOT</name>) = <name><name>ret</name><index>[<expr>0</expr>]</index></name></expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr><name>FFI_TYPE_SINT64</name></expr>:
</case><case>case <expr><name>FFI_TYPE_UINT64</name></expr>:
<expr_stmt><expr>*(<name>stack</name> - <name>FIRST_ARG_SLOT</name>) = <name><name>ret</name><index>[<expr>0</expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr>*(<name>stack</name> - <name>FIRST_ARG_SLOT</name> - 1) = <name><name>ret</name><index>[<expr>1</expr>]</index></name></expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr><name>FFI_TYPE_DOUBLE</name></expr>:
<expr_stmt><expr><call><name>fldd</name><argument_list>(<argument><expr><name>rvalue</name></expr></argument>, <argument><expr><name>fr4</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr><name>FFI_TYPE_FLOAT</name></expr>:
<expr_stmt><expr><call><name>fldw</name><argument_list>(<argument><expr><name>rvalue</name></expr></argument>, <argument><expr><name>fr4</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr><name>FFI_TYPE_STRUCT</name></expr>:
<break>break;</break>
</case><case>case <expr><name>FFI_TYPE_SMALL_STRUCT2</name></expr>:
</case><case>case <expr><name>FFI_TYPE_SMALL_STRUCT3</name></expr>:
</case><case>case <expr><name>FFI_TYPE_SMALL_STRUCT4</name></expr>:
<expr_stmt><expr><name>tmp</name> = <call>(<name>void</name>*)<argument_list>(<argument><expr><name>stack</name> - <name>FIRST_ARG_SLOT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>tmp</name> += 4 - <name><name>cif</name>-&gt;<name>rtype</name>-&gt;<name>size</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>(<name>void</name>*)<name>tmp</name></expr></argument>, <argument><expr>&amp;<name><name>ret</name><index>[<expr>0</expr>]</index></name></expr></argument>, <argument><expr><name><name>cif</name>-&gt;<name>rtype</name>-&gt;<name>size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr><name>FFI_TYPE_SMALL_STRUCT5</name></expr>:
</case><case>case <expr><name>FFI_TYPE_SMALL_STRUCT6</name></expr>:
</case><case>case <expr><name>FFI_TYPE_SMALL_STRUCT7</name></expr>:
</case><case>case <expr><name>FFI_TYPE_SMALL_STRUCT8</name></expr>: <block>{
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name><name>ret2</name><index>[<expr>2</expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>off</name></decl>;</decl_stmt>
<switch>switch <condition>(<expr><name><name>cif</name>-&gt;<name>flags</name></name></expr>)</condition> <block>{
<case>case <expr><name>FFI_TYPE_SMALL_STRUCT5</name></expr>:
<expr_stmt><expr><name>off</name> = 3</expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr><name>FFI_TYPE_SMALL_STRUCT6</name></expr>:
<expr_stmt><expr><name>off</name> = 2</expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr><name>FFI_TYPE_SMALL_STRUCT7</name></expr>:
<expr_stmt><expr><name>off</name> = 1</expr>;</expr_stmt>
<break>break;</break>
</case><default>default:
<expr_stmt><expr><name>off</name> = 0</expr>;</expr_stmt>
<break>break;</break>
</default>}</block></switch>
<expr_stmt><expr><call><name>memset</name> <argument_list>(<argument><expr><name>ret2</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>ret2</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>memcpy</name> <argument_list>(<argument><expr>(<name>char</name> *)<name>ret2</name> + <name>off</name></expr></argument>, <argument><expr><name>ret</name></expr></argument>, <argument><expr>8 - <name>off</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr>*(<name>stack</name> - <name>FIRST_ARG_SLOT</name>) = <name><name>ret2</name><index>[<expr>0</expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr>*(<name>stack</name> - <name>FIRST_ARG_SLOT</name> - 1) = <name><name>ret2</name><index>[<expr>1</expr>]</index></name></expr>;</expr_stmt>
}</block>
<break>break;</break>
</case><case>case <expr><name>FFI_TYPE_POINTER</name></expr>:
</case><case>case <expr><name>FFI_TYPE_VOID</name></expr>:
<break>break;</break>
</case><default>default:
<expr_stmt><expr><call><name>debug</name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr>"assert with cif-&gt;flags: %d\n"</expr></argument>,<argument><expr><name><name>cif</name>-&gt;<name>flags</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>FFI_ASSERT</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</default>}</block></switch>
<return>return <expr><name>FFI_OK</name></expr>;</return>
}</block>
<function_decl><type><specifier>extern</specifier> <name>void</name></type> <name>ffi_closure_pa32</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list>;</function_decl>
<function><type><name>ffi_status</name></type>
<name>ffi_prep_closure_loc</name> <parameter_list>(<param><decl><type><name>ffi_closure</name>*</type> <name>closure</name></decl></param>,
<param><decl><type><name>ffi_cif</name>*</type> <name>cif</name></decl></param>,
<param><function_decl><type><name>void</name></type> (*<name>fun</name>)<parameter_list>(<param><decl><type><name>ffi_cif</name>*</type></decl></param>,<param><decl><type><name>void</name>*</type></decl></param>,<param><decl><type><name>void</name>**</type></decl></param>,<param><decl><type><name>void</name>*</type></decl></param>)</parameter_list></function_decl></param>,
<param><decl><type><name>void</name> *</type><name>user_data</name></decl></param>,
<param><decl><type><name>void</name> *</type><name>codeloc</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>UINT32</name> *</type><name>tramp</name> <init>= <expr><call>(<name>UINT32</name> *)<argument_list>(<argument><expr><name><name>closure</name>-&gt;<name>tramp</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>PA_HPUX</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>UINT32</name> *</type><name>tmp</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><call><name>FFI_ASSERT</name> <argument_list>(<argument><expr><name><name>cif</name>-&gt;<name>abi</name></name> == <name>FFI_PA32</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>PA_LINUX</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><name><name>tramp</name><index>[<expr>0</expr>]</index></name> = 0xeaa00000</expr>;</expr_stmt>
<expr_stmt><expr><name><name>tramp</name><index>[<expr>1</expr>]</index></name> = 0xd6a01c1e</expr>;</expr_stmt>
<expr_stmt><expr><name><name>tramp</name><index>[<expr>2</expr>]</index></name> = 0x4aa10028</expr>;</expr_stmt>
<expr_stmt><expr><name><name>tramp</name><index>[<expr>3</expr>]</index></name> = 0x36b53ff1</expr>;</expr_stmt>
<expr_stmt><expr><name><name>tramp</name><index>[<expr>4</expr>]</index></name> = 0x0c201096</expr>;</expr_stmt>
<expr_stmt><expr><name><name>tramp</name><index>[<expr>5</expr>]</index></name> = 0xeac0c000</expr>;</expr_stmt>
<expr_stmt><expr><name><name>tramp</name><index>[<expr>6</expr>]</index></name> = 0x0c281093</expr>;</expr_stmt>
<expr_stmt><expr><name><name>tramp</name><index>[<expr>7</expr>]</index></name> = (<call>(<name>UINT32</name>)<argument_list>(<argument><expr><name>ffi_closure_pa32</name></expr></argument>)</argument_list></call> &amp; ~2)</expr>;</expr_stmt>
<asm>__asm__ <specifier>volatile</specifier>(
"fdc 0(%0)\n\t"
"fdc %1(%0)\n\t"
"fic 0(%%sr4, %0)\n\t"
"fic %1(%%sr4, %0)\n\t"
"sync\n\t"
"nop\n\t"
"nop\n\t"
"nop\n\t"
"nop\n\t"
"nop\n\t"
"nop\n\t"
"nop\n"
:
: "r"((unsigned long)tramp &amp; ~31),
"r"(32 )
: "memory");</asm>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>PA_HPUX</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><name><name>tramp</name><index>[<expr>0</expr>]</index></name> = 0xeaa00000</expr>;</expr_stmt>
<expr_stmt><expr><name><name>tramp</name><index>[<expr>1</expr>]</index></name> = 0xd6a01c1e</expr>;</expr_stmt>
<expr_stmt><expr><name><name>tramp</name><index>[<expr>2</expr>]</index></name> = 0x4aa10038</expr>;</expr_stmt>
<expr_stmt><expr><name><name>tramp</name><index>[<expr>3</expr>]</index></name> = 0x36b53ff1</expr>;</expr_stmt>
<expr_stmt><expr><name><name>tramp</name><index>[<expr>4</expr>]</index></name> = 0x0c201096</expr>;</expr_stmt>
<expr_stmt><expr><name><name>tramp</name><index>[<expr>5</expr>]</index></name> = 0x02c010b4</expr>;</expr_stmt>
<expr_stmt><expr><name><name>tramp</name><index>[<expr>6</expr>]</index></name> = 0x00141820</expr>;</expr_stmt>
<expr_stmt><expr><name><name>tramp</name><index>[<expr>7</expr>]</index></name> = 0xe2c00000</expr>;</expr_stmt>
<expr_stmt><expr><name><name>tramp</name><index>[<expr>8</expr>]</index></name> = 0x0c281093</expr>;</expr_stmt>
<expr_stmt><expr><name><name>tramp</name><index>[<expr>9</expr>]</index></name> = (<call>(<name>UINT32</name>)<argument_list>(<argument><expr><name>ffi_closure_pa32</name></expr></argument>)</argument_list></call> &amp; ~2)</expr>;</expr_stmt>
<asm>__asm__ <specifier>volatile</specifier>(
"copy %1,%0\n\t"
"fdc,m %2(%0)\n\t"
"fdc,m %2(%0)\n\t"
"fdc,m %2(%0)\n\t"
"ldsid (%1),%0\n\t"
"mtsp %0,%%sr0\n\t"
"copy %1,%0\n\t"
"fic,m %2(%%sr0,%0)\n\t"
"fic,m %2(%%sr0,%0)\n\t"
"fic,m %2(%%sr0,%0)\n\t"
"sync\n\t"
"nop\n\t"
"nop\n\t"
"nop\n\t"
"nop\n\t"
"nop\n\t"
"nop\n\t"
"nop\n"
: "=&amp;r" ((unsigned long)tmp)
: "r" ((unsigned long)tramp &amp; ~31),
"r" (32)
: "memory");</asm>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><name><name>closure</name>-&gt;<name>cif</name></name> = <name>cif</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>closure</name>-&gt;<name>user_data</name></name> = <name>user_data</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>closure</name>-&gt;<name>fun</name></name> = <name>fun</name></expr>;</expr_stmt>
<return>return <expr><name>FFI_OK</name></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</unit>
