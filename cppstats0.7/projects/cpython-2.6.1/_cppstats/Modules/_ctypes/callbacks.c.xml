<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C" filename="projects/cpython-2.6.1/_cppstats/Modules/_ctypes/callbacks.c"><cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"Python.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"compile.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"frameobject.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;ffi.h&gt;</cpp:file></cpp:include>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MS_WIN32</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;windows.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ctypes.h"</cpp:file></cpp:include>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>CThunkObject_dealloc</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>_self</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>CThunkObject</name> *</type><name>self</name> <init>= <expr>(<name>CThunkObject</name> *)<name>_self</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>converters</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>callable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>restype</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>self</name>-&gt;<name>pcl</name></name></expr>)</condition><then>
<expr_stmt><expr><call><name>FreeClosure</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>pcl</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<expr_stmt><expr><call><name>PyObject_Del</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>CThunkObject_traverse</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>_self</name></decl></param>, <param><decl><type><name>visitproc</name></type> <name>visit</name></decl></param>, <param><decl><type><name>void</name> *</type><name>arg</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>CThunkObject</name> *</type><name>self</name> <init>= <expr>(<name>CThunkObject</name> *)<name>_self</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>Py_VISIT</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>converters</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_VISIT</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>callable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_VISIT</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>restype</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>0</expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>CThunkObject_clear</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>_self</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>CThunkObject</name> *</type><name>self</name> <init>= <expr>(<name>CThunkObject</name> *)<name>_self</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>Py_CLEAR</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>converters</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_CLEAR</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>callable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_CLEAR</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>restype</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>0</expr>;</return>
}</block></function>
<decl_stmt><decl><type><name>PyTypeObject</name></type> <name>CThunk_Type</name> <init>= <expr><block>{
<expr><call><name>PyVarObject_HEAD_INIT</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call>
"_ctypes.CThunkObject"</expr>,
<expr><sizeof>sizeof<argument_list>(<argument><expr><name>CThunkObject</name></expr></argument>)</argument_list></sizeof></expr>,
<expr><sizeof>sizeof<argument_list>(<argument><expr><name>ffi_type</name></expr></argument>)</argument_list></sizeof></expr>,
<expr><name>CThunkObject_dealloc</name></expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr><name>Py_TPFLAGS_DEFAULT</name></expr>,
<expr>"CThunkObject"</expr>,
<expr><name>CThunkObject_traverse</name></expr>,
<expr><name>CThunkObject_clear</name></expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
}</block></expr></init></decl>;</decl_stmt>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>PrintError</name><parameter_list>(<param><decl><type><name>char</name> *</type><name>msg</name></decl></param>, <param><decl><type>...</type></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>char</name></type> <name><name>buf</name><index>[<expr>512</expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>f</name> <init>= <expr><call><name>PySys_GetObject</name><argument_list>(<argument><expr>"stderr"</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>va_list</name></type> <name>marker</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>marker</name></expr></argument>, <argument><expr><name>msg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>vsnprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>msg</name></expr></argument>, <argument><expr><name>marker</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>marker</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>f</name></expr>)</condition><then>
<expr_stmt><expr><call><name>PyFile_WriteString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<expr_stmt><expr><call><name>PyErr_Print</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
}</block></function>
<function><type><name>void</name></type> <name>_AddTraceback</name><parameter_list>(<param><decl><type><name>char</name> *</type><name>funcname</name></decl></param>, <param><decl><type><name>char</name> *</type><name>filename</name></decl></param>, <param><decl><type><name>int</name></type> <name>lineno</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>py_srcfile</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>py_funcname</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>py_globals</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>empty_tuple</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>empty_string</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyCodeObject</name> *</type><name>py_code</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyFrameObject</name> *</type><name>py_frame</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>py_srcfile</name> = <call><name>PyString_FromString</name><argument_list>(<argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>py_srcfile</name></expr>)</condition><then> <goto>goto <name>bad</name>;</goto></then></if>
<expr_stmt><expr><name>py_funcname</name> = <call><name>PyString_FromString</name><argument_list>(<argument><expr><name>funcname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>py_funcname</name></expr>)</condition><then> <goto>goto <name>bad</name>;</goto></then></if>
<expr_stmt><expr><name>py_globals</name> = <call><name>PyDict_New</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>py_globals</name></expr>)</condition><then> <goto>goto <name>bad</name>;</goto></then></if>
<expr_stmt><expr><name>empty_tuple</name> = <call><name>PyTuple_New</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>empty_tuple</name></expr>)</condition><then> <goto>goto <name>bad</name>;</goto></then></if>
<expr_stmt><expr><name>empty_string</name> = <call><name>PyString_FromString</name><argument_list>(<argument><expr>""</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>empty_string</name></expr>)</condition><then> <goto>goto <name>bad</name>;</goto></then></if>
<expr_stmt><expr><name>py_code</name> = <call><name>PyCode_New</name><argument_list>(
<argument><expr>0</expr></argument>,
<argument><expr>0</expr></argument>,
<argument><expr>0</expr></argument>,
<argument><expr>0</expr></argument>,
<argument><expr><name>empty_string</name></expr></argument>,
<argument><expr><name>empty_tuple</name></expr></argument>,
<argument><expr><name>empty_tuple</name></expr></argument>,
<argument><expr><name>empty_tuple</name></expr></argument>,
<argument><expr><name>empty_tuple</name></expr></argument>,
<argument><expr><name>empty_tuple</name></expr></argument>,
<argument><expr><name>py_srcfile</name></expr></argument>,
<argument><expr><name>py_funcname</name></expr></argument>,
<argument><expr><name>lineno</name></expr></argument>,
<argument><expr><name>empty_string</name></expr></argument>
)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>py_code</name></expr>)</condition><then> <goto>goto <name>bad</name>;</goto></then></if>
<expr_stmt><expr><name>py_frame</name> = <call><name>PyFrame_New</name><argument_list>(
<argument><expr><call><name>PyThreadState_Get</name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><name>py_code</name></expr></argument>,
<argument><expr><name>py_globals</name></expr></argument>,
<argument><expr>0</expr></argument>
)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>py_frame</name></expr>)</condition><then> <goto>goto <name>bad</name>;</goto></then></if>
<expr_stmt><expr><name><name>py_frame</name>-&gt;<name>f_lineno</name></name> = <name>lineno</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyTraceBack_Here</name><argument_list>(<argument><expr><name>py_frame</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<label><name>bad</name>:</label>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>py_globals</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>py_srcfile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>py_funcname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>empty_tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>empty_string</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>py_code</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>py_frame</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MS_WIN32</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>TryAddRef</name><parameter_list>(<param><decl><type><name>StgDictObject</name> *</type><name>dict</name></decl></param>, <param><decl><type><name>CDataObject</name> *</type><name>obj</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>IUnknown</name> *</type><name>punk</name></decl>;</decl_stmt>
<if>if <condition>(<expr><name>NULL</name> == <call><name>PyDict_GetItemString</name><argument_list>(<argument><expr>(<name>PyObject</name> *)<name>dict</name></expr></argument>, <argument><expr>"_needs_com_addref_"</expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return;</return></then></if>
<expr_stmt><expr><name>punk</name> = *(<name>IUnknown</name> **)<name><name>obj</name>-&gt;<name>b_ptr</name></name></expr>;</expr_stmt>
<if>if <condition>(<expr><name>punk</name></expr>)</condition><then>
<expr_stmt><expr><call><name><name>punk</name>-&gt;<name>lpVtbl</name>-&gt;<name>AddRef</name></name><argument_list>(<argument><expr><name>punk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<return>return;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<function><type><specifier>static</specifier> <name>void</name></type> <name>_CallPythonObject</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>mem</name></decl></param>,
<param><decl><type><name>ffi_type</name> *</type><name>restype</name></decl></param>,
<param><decl><type><name>SETFUNC</name></type> <name>setfunc</name></decl></param>,
<param><decl><type><name>PyObject</name> *</type><name>callable</name></decl></param>,
<param><decl><type><name>PyObject</name> *</type><name>converters</name></decl></param>,
<param><decl><type><name>int</name></type> <name>flags</name></decl></param>,
<param><decl><type><name>void</name> **</type><name>pArgs</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>result</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>arglist</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>nArgs</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>error_object</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name> *</type><name>space</name></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>WITH_THREAD</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>PyGILState_STATE</name></type> <name>state</name> <init>= <expr><call><name>PyGILState_Ensure</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><name>nArgs</name> = <call><name>PySequence_Length</name><argument_list>(<argument><expr><name>converters</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>nArgs</name> &lt; 0</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PrintError</name><argument_list>(<argument><expr>"BUG: PySequence_Length"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>Done</name>;</goto>
}</block></then></if>
<expr_stmt><expr><name>arglist</name> = <call><name>PyTuple_New</name><argument_list>(<argument><expr><name>nArgs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>arglist</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PrintError</name><argument_list>(<argument><expr>"PyTuple_New()"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>Done</name>;</goto>
}</block></then></if>
<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>nArgs</name></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>) <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>cnv</name> <init>= <expr><call><name>PySequence_GetItem</name><argument_list>(<argument><expr><name>converters</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>StgDictObject</name> *</type><name>dict</name></decl>;</decl_stmt>
<if>if <condition>(<expr><name>cnv</name></expr>)</condition><then>
<expr_stmt><expr><name>dict</name> = <call><name>PyType_stgdict</name><argument_list>(<argument><expr><name>cnv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
<else>else <block>{
<expr_stmt><expr><call><name>PrintError</name><argument_list>(<argument><expr>"Getting argument converter %d\n"</expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>Done</name>;</goto>
}</block></else></if>
<if>if <condition>(<expr><name>dict</name> &amp;&amp; <name><name>dict</name>-&gt;<name>getfunc</name></name> &amp;&amp; !<call><name>IsSimpleSubType</name><argument_list>(<argument><expr><name>cnv</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>v</name> <init>= <expr><call><name><name>dict</name>-&gt;<name>getfunc</name></name><argument_list>(<argument><expr>*<name>pArgs</name></expr></argument>, <argument><expr><name><name>dict</name>-&gt;<name>size</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr>!<name>v</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PrintError</name><argument_list>(<argument><expr>"create argument %d:\n"</expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>cnv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>Done</name>;</goto>
}</block></then></if>
<expr_stmt><expr><call><name>PyTuple_SET_ITEM</name><argument_list>(<argument><expr><name>arglist</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else <if>if <condition>(<expr><name>dict</name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>CDataObject</name> *</type><name>obj</name> <init>= <expr>(<name>CDataObject</name> *)<call><name>PyObject_CallFunctionObjArgs</name><argument_list>(<argument><expr><name>cnv</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr>!<name>obj</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PrintError</name><argument_list>(<argument><expr>"create argument %d:\n"</expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>cnv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>Done</name>;</goto>
}</block></then></if>
<if>if <condition>(<expr>!<call><name>CDataObject_Check</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>cnv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PrintError</name><argument_list>(<argument><expr>"unexpected result of create argument %d:\n"</expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>Done</name>;</goto>
}</block></then></if>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>obj</name>-&gt;<name>b_ptr</name></name></expr></argument>, <argument><expr>*<name>pArgs</name></expr></argument>, <argument><expr><name><name>dict</name>-&gt;<name>size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyTuple_SET_ITEM</name><argument_list>(<argument><expr><name>arglist</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr>(<name>PyObject</name> *)<name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MS_WIN32</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>TryAddRef</name><argument_list>(<argument><expr><name>dict</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></then> <else>else <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
<argument><expr>"cannot build parameter"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PrintError</name><argument_list>(<argument><expr>"Parsing argument %d\n"</expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>cnv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>Done</name>;</goto>
}</block></else></if></else></if>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>cnv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>pArgs</name>++</expr>;</expr_stmt>
}</block></for>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CHECK</name><parameter_list>(<param><type><name>what</name></type></param>, <param><type><name>x</name></type></param>)</parameter_list></cpp:macro> <cpp:value>if (x == NULL) _AddTraceback(what, "_ctypes/callbacks.c", __LINE__ - 1), PyErr_Print()</cpp:value></cpp:define>
<if>if <condition>(<expr><name>flags</name> &amp; (<name>FUNCFLAG_USE_ERRNO</name> | <name>FUNCFLAG_USE_LASTERROR</name>)</expr>)</condition><then> <block>{
<expr_stmt><expr><name>error_object</name> = <call><name>get_error_object</name><argument_list>(<argument><expr>&amp;<name>space</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>error_object</name> == <name>NULL</name></expr>)</condition><then>
<goto>goto <name>Done</name>;</goto></then></if>
<if>if <condition>(<expr><name>flags</name> &amp; <name>FUNCFLAG_USE_ERRNO</name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>temp</name> <init>= <expr><name><name>space</name><index>[<expr>0</expr>]</index></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>space</name><index>[<expr>0</expr>]</index></name> = <name>errno</name></expr>;</expr_stmt>
<expr_stmt><expr><name>errno</name> = <name>temp</name></expr>;</expr_stmt>
}</block></then></if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MS_WIN32</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if>if <condition>(<expr><name>flags</name> &amp; <name>FUNCFLAG_USE_LASTERROR</name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>temp</name> <init>= <expr><name><name>space</name><index>[<expr>1</expr>]</index></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>space</name><index>[<expr>1</expr>]</index></name> = <call><name>GetLastError</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SetLastError</name><argument_list>(<argument><expr><name>temp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></then></if>
<expr_stmt><expr><name>result</name> = <call><name>PyObject_CallObject</name><argument_list>(<argument><expr><name>callable</name></expr></argument>, <argument><expr><name>arglist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>CHECK</name><argument_list>(<argument><expr>"'calling callback function'"</expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MS_WIN32</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if>if <condition>(<expr><name>flags</name> &amp; <name>FUNCFLAG_USE_LASTERROR</name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>temp</name> <init>= <expr><name><name>space</name><index>[<expr>1</expr>]</index></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>space</name><index>[<expr>1</expr>]</index></name> = <call><name>GetLastError</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SetLastError</name><argument_list>(<argument><expr><name>temp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<if>if <condition>(<expr><name>flags</name> &amp; <name>FUNCFLAG_USE_ERRNO</name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>temp</name> <init>= <expr><name><name>space</name><index>[<expr>0</expr>]</index></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>space</name><index>[<expr>0</expr>]</index></name> = <name>errno</name></expr>;</expr_stmt>
<expr_stmt><expr><name>errno</name> = <name>temp</name></expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>error_object</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>(<name>restype</name> != &amp;<name>ffi_type_void</name>) &amp;&amp; <name>result</name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>keep</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>setfunc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>WORDS_BIGENDIAN</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if>if <condition>(<expr><name><name>restype</name>-&gt;<name>type</name></name> != <name>FFI_TYPE_FLOAT</name> &amp;&amp; <name><name>restype</name>-&gt;<name>size</name></name> &lt; <sizeof>sizeof<argument_list>(<argument><expr><name>ffi_arg</name></expr></argument>)</argument_list></sizeof></expr>)</condition><then>
<expr_stmt><expr><name>mem</name> = (<name>char</name> *)<name>mem</name> + <sizeof>sizeof<argument_list>(<argument><expr><name>ffi_arg</name></expr></argument>)</argument_list></sizeof> - <name><name>restype</name>-&gt;<name>size</name></name></expr>;</expr_stmt></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><name>keep</name> = <call><name>setfunc</name><argument_list>(<argument><expr><name>mem</name></expr></argument>, <argument><expr><name>result</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>CHECK</name><argument_list>(<argument><expr>"'converting callback result'"</expr></argument>, <argument><expr><name>keep</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>keep</name> == <name>NULL</name></expr>)</condition><then>
<expr_stmt><expr><call><name>PyErr_WriteUnraisable</name><argument_list>(<argument><expr><name>callable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
<else>else <if>if <condition>(<expr><name>keep</name> == <name>Py_None</name></expr>)</condition><then>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>keep</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
<else>else <if>if <condition>(<expr><name>setfunc</name> != <call><name>getentry</name><argument_list>(<argument><expr>"O"</expr></argument>)</argument_list></call>-&gt;<name>setfunc</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr>-1 == <call><name>PyErr_Warn</name><argument_list>(<argument><expr><name>PyExc_RuntimeWarning</name></expr></argument>,
<argument><expr>"memory leak in callback function."</expr></argument>)</argument_list></call></expr>)</condition><then>
<expr_stmt><expr><call><name>PyErr_WriteUnraisable</name><argument_list>(<argument><expr><name>callable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
}</block></then></if></else></if></else></if>
}</block></then></if>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<label><name>Done</name>:</label>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>arglist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>WITH_THREAD</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyGILState_Release</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>closure_fcn</name><parameter_list>(<param><decl><type><name>ffi_cif</name> *</type><name>cif</name></decl></param>,
<param><decl><type><name>void</name> *</type><name>resp</name></decl></param>,
<param><decl><type><name>void</name> **</type><name>args</name></decl></param>,
<param><decl><type><name>void</name> *</type><name>userdata</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>CThunkObject</name> *</type><name>p</name> <init>= <expr>(<name>CThunkObject</name> *)<name>userdata</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>_CallPythonObject</name><argument_list>(<argument><expr><name>resp</name></expr></argument>,
<argument><expr><name><name>p</name>-&gt;<name>ffi_restype</name></name></expr></argument>,
<argument><expr><name><name>p</name>-&gt;<name>setfunc</name></name></expr></argument>,
<argument><expr><name><name>p</name>-&gt;<name>callable</name></name></expr></argument>,
<argument><expr><name><name>p</name>-&gt;<name>converters</name></name></expr></argument>,
<argument><expr><name><name>p</name>-&gt;<name>flags</name></name></expr></argument>,
<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>
<function><type><specifier>static</specifier> <name>CThunkObject</name>*</type> <name>CThunkObject_new</name><parameter_list>(<param><decl><type><name>Py_ssize_t</name></type> <name>nArgs</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>CThunkObject</name> *</type><name>p</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<expr_stmt><expr><name>p</name> = <call><name>PyObject_NewVar</name><argument_list>(<argument><expr><name>CThunkObject</name></expr></argument>, <argument><expr>&amp;<name>CThunk_Type</name></expr></argument>, <argument><expr><name>nArgs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>p</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_NoMemory</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name><name>p</name>-&gt;<name>pcl</name></name> = <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr>&amp;<name><name>p</name>-&gt;<name>cif</name></name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>p</name>-&gt;<name>cif</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>p</name>-&gt;<name>converters</name></name> = <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>p</name>-&gt;<name>callable</name></name> = <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>p</name>-&gt;<name>setfunc</name></name> = <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>p</name>-&gt;<name>ffi_restype</name></name> = <name>NULL</name></expr>;</expr_stmt>
<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>nArgs</name> + 1</expr>;</condition> <incr><expr>++<name>i</name></expr></incr>)
<expr_stmt><expr><name><name>p</name>-&gt;<name>atypes</name><index>[<expr><name>i</name></expr>]</index></name> = <name>NULL</name></expr>;</expr_stmt></for>
<return>return <expr><name>p</name></expr>;</return>
}</block></function>
<function><type><name>CThunkObject</name> *</type><name>AllocFunctionCallback</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>callable</name></decl></param>,
<param><decl><type><name>PyObject</name> *</type><name>converters</name></decl></param>,
<param><decl><type><name>PyObject</name> *</type><name>restype</name></decl></param>,
<param><decl><type><name>int</name></type> <name>flags</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>result</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>CThunkObject</name> *</type><name>p</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>nArgs</name></decl>, <decl><type ref="prev"/><name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ffi_abi</name></type> <name>cc</name></decl>;</decl_stmt>
<expr_stmt><expr><name>nArgs</name> = <call><name>PySequence_Size</name><argument_list>(<argument><expr><name>converters</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>p</name> = <call><name>CThunkObject_new</name><argument_list>(<argument><expr><name>nArgs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>p</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>CThunk_CheckExact</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>p</name>-&gt;<name>pcl</name></name> = <call><name>MallocClosure</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>p</name>-&gt;<name>pcl</name></name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_NoMemory</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>error</name>;</goto>
}</block></then></if>
<expr_stmt><expr><name><name>p</name>-&gt;<name>flags</name></name> = <name>flags</name></expr>;</expr_stmt>
<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>nArgs</name></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>) <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>cnv</name> <init>= <expr><call><name>PySequence_GetItem</name><argument_list>(<argument><expr><name>converters</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>cnv</name> == <name>NULL</name></expr>)</condition><then>
<goto>goto <name>error</name>;</goto></then></if>
<expr_stmt><expr><name><name>p</name>-&gt;<name>atypes</name><index>[<expr><name>i</name></expr>]</index></name> = <call><name>GetType</name><argument_list>(<argument><expr><name>cnv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>cnv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></for>
<expr_stmt><expr><name><name>p</name>-&gt;<name>atypes</name><index>[<expr><name>i</name></expr>]</index></name> = <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>restype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>p</name>-&gt;<name>restype</name></name> = <name>restype</name></expr>;</expr_stmt>
<if>if <condition>(<expr><name>restype</name> == <name>Py_None</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>p</name>-&gt;<name>setfunc</name></name> = <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>p</name>-&gt;<name>ffi_restype</name></name> = &amp;<name>ffi_type_void</name></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<decl_stmt><decl><type><name>StgDictObject</name> *</type><name>dict</name> <init>= <expr><call><name>PyType_stgdict</name><argument_list>(<argument><expr><name>restype</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>dict</name> == <name>NULL</name> || <name><name>dict</name>-&gt;<name>setfunc</name></name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
<argument><expr>"invalid result type for callback function"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>error</name>;</goto>
}</block></then></if>
<expr_stmt><expr><name><name>p</name>-&gt;<name>setfunc</name></name> = <name><name>dict</name>-&gt;<name>setfunc</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>p</name>-&gt;<name>ffi_restype</name></name> = &amp;<name><name>dict</name>-&gt;<name>ffi_type_pointer</name></name></expr>;</expr_stmt>
}</block></else></if>
<expr_stmt><expr><name>cc</name> = <name>FFI_DEFAULT_ABI</name></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MS_WIN32</name></expr></argument>)</argument_list></call> &amp;&amp; !<call><name>defined</name><argument_list>(<argument><expr><name>_WIN32_WCE</name></expr></argument>)</argument_list></call> &amp;&amp; !<call><name>defined</name><argument_list>(<argument><expr><name>MS_WIN64</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if>if <condition>(<expr>(<name>flags</name> &amp; <name>FUNCFLAG_CDECL</name>) == 0</expr>)</condition><then>
<expr_stmt><expr><name>cc</name> = <name>FFI_STDCALL</name></expr>;</expr_stmt></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><name>result</name> = <call><name>ffi_prep_cif</name><argument_list>(<argument><expr>&amp;<name><name>p</name>-&gt;<name>cif</name></name></expr></argument>, <argument><expr><name>cc</name></expr></argument>,
<argument><expr><call><name>Py_SAFE_DOWNCAST</name><argument_list>(<argument><expr><name>nArgs</name></expr></argument>, <argument><expr><name>Py_ssize_t</name></expr></argument>, <argument><expr><name>int</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name>GetType</name><argument_list>(<argument><expr><name>restype</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr>&amp;<name><name>p</name>-&gt;<name>atypes</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>result</name> != <name>FFI_OK</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_RuntimeError</name></expr></argument>,
<argument><expr>"ffi_prep_cif failed with %d"</expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>error</name>;</goto>
}</block></then></if>
<expr_stmt><expr><name>result</name> = <call><name>ffi_prep_closure</name><argument_list>(<argument><expr><name><name>p</name>-&gt;<name>pcl</name></name></expr></argument>, <argument><expr>&amp;<name><name>p</name>-&gt;<name>cif</name></name></expr></argument>, <argument><expr><name>closure_fcn</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>result</name> != <name>FFI_OK</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_RuntimeError</name></expr></argument>,
<argument><expr>"ffi_prep_closure failed with %d"</expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>error</name>;</goto>
}</block></then></if>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>converters</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>p</name>-&gt;<name>converters</name></name> = <name>converters</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>callable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>p</name>-&gt;<name>callable</name></name> = <name>callable</name></expr>;</expr_stmt>
<return>return <expr><name>p</name></expr>;</return>
<label><name>error</name>:</label>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></function>
<function><type><name>void</name></type> <name>init_callbacks_in_module</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>m</name></decl></param>)</parameter_list> <block>{
<if>if <condition>(<expr><call><name>PyType_Ready</name><argument_list>(<argument><expr>(<name>PyTypeObject</name> *)&amp;<name>PyType_Type</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
<return>return;</return></then></if>
}</block></function>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MS_WIN32</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function><type><specifier>static</specifier> <name>void</name></type> <name>LoadPython</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list> <block>{
<if>if <condition>(<expr>!<call><name>Py_IsInitialized</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>WITH_THREAD</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyEval_InitThreads</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><call><name>Py_Initialize</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
}</block></function>
<function><type><name>long</name></type> <name>Call_GetClassObject</name><parameter_list>(<param><decl><type><name>REFCLSID</name></type> <name>rclsid</name></decl></param>, <param><decl><type><name>REFIID</name></type> <name>riid</name></decl></param>, <param><decl><type><name>LPVOID</name> *</type><name>ppv</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>mod</name></decl>, *<decl><type ref="prev"/><name>func</name></decl>, *<decl><type ref="prev"/><name>result</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>long</name></type> <name>retval</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>PyObject</name> *</type><name>context</name></decl>;</decl_stmt>
<if>if <condition>(<expr><name>context</name> == <name>NULL</name></expr>)</condition><then>
<expr_stmt><expr><name>context</name> = <call><name>PyString_InternFromString</name><argument_list>(<argument><expr>"_ctypes.DllGetClassObject"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<expr_stmt><expr><name>mod</name> = <call><name>PyImport_ImportModuleNoBlock</name><argument_list>(<argument><expr>"ctypes"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>mod</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_WriteUnraisable</name><argument_list>(<argument><expr><name>context</name> ? <name>context</name> : <name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>E_FAIL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>func</name> = <call><name>PyObject_GetAttrString</name><argument_list>(<argument><expr><name>mod</name></expr></argument>, <argument><expr>"DllGetClassObject"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>mod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>func</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_WriteUnraisable</name><argument_list>(<argument><expr><name>context</name> ? <name>context</name> : <name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>E_FAIL</name></expr>;</return>
}</block></then></if>
<block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>py_rclsid</name> <init>= <expr><call><name>PyLong_FromVoidPtr</name><argument_list>(<argument><expr>(<name>void</name> *)<name>rclsid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>py_riid</name> <init>= <expr><call><name>PyLong_FromVoidPtr</name><argument_list>(<argument><expr>(<name>void</name> *)<name>riid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>py_ppv</name> <init>= <expr><call><name>PyLong_FromVoidPtr</name><argument_list>(<argument><expr><name>ppv</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr>!<name>py_rclsid</name> || !<name>py_riid</name> || !<name>py_ppv</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>py_rclsid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>py_riid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>py_ppv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>func</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyErr_WriteUnraisable</name><argument_list>(<argument><expr><name>context</name> ? <name>context</name> : <name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>E_FAIL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>result</name> = <call><name>PyObject_CallFunctionObjArgs</name><argument_list>(<argument><expr><name>func</name></expr></argument>,
<argument><expr><name>py_rclsid</name></expr></argument>,
<argument><expr><name>py_riid</name></expr></argument>,
<argument><expr><name>py_ppv</name></expr></argument>,
<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>py_rclsid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>py_riid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>py_ppv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>func</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>result</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_WriteUnraisable</name><argument_list>(<argument><expr><name>context</name> ? <name>context</name> : <name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>E_FAIL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>retval</name> = <call><name>PyInt_AsLong</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_WriteUnraisable</name><argument_list>(<argument><expr><name>context</name> ? <name>context</name> : <name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>retval</name> = <name>E_FAIL</name></expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>retval</name></expr>;</return>
}</block></function>
<function><type><name>STDAPI</name></type> <name>DllGetClassObject</name><parameter_list>(<param><decl><type><name>REFCLSID</name></type> <name>rclsid</name></decl></param>,
<param><decl><type><name>REFIID</name></type> <name>riid</name></decl></param>,
<param><decl><type><name>LPVOID</name> *</type><name>ppv</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>long</name></type> <name>result</name></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>WITH_THREAD</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>PyGILState_STATE</name></type> <name>state</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><call><name>LoadPython</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>WITH_THREAD</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><name>state</name> = <call><name>PyGILState_Ensure</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><name>result</name> = <call><name>Call_GetClassObject</name><argument_list>(<argument><expr><name>rclsid</name></expr></argument>, <argument><expr><name>riid</name></expr></argument>, <argument><expr><name>ppv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>WITH_THREAD</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyGILState_Release</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<return>return <expr><name>result</name></expr>;</return>
}</block></function>
<function><type><name>long</name></type> <name>Call_CanUnloadNow</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>mod</name></decl>, *<decl><type ref="prev"/><name>func</name></decl>, *<decl><type ref="prev"/><name>result</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>long</name></type> <name>retval</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>PyObject</name> *</type><name>context</name></decl>;</decl_stmt>
<if>if <condition>(<expr><name>context</name> == <name>NULL</name></expr>)</condition><then>
<expr_stmt><expr><name>context</name> = <call><name>PyString_InternFromString</name><argument_list>(<argument><expr>"_ctypes.DllCanUnloadNow"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<expr_stmt><expr><name>mod</name> = <call><name>PyImport_ImportModuleNoBlock</name><argument_list>(<argument><expr>"ctypes"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>mod</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_Clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>E_FAIL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>func</name> = <call><name>PyObject_GetAttrString</name><argument_list>(<argument><expr><name>mod</name></expr></argument>, <argument><expr>"DllCanUnloadNow"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>mod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>func</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_WriteUnraisable</name><argument_list>(<argument><expr><name>context</name> ? <name>context</name> : <name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>E_FAIL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>result</name> = <call><name>PyObject_CallFunction</name><argument_list>(<argument><expr><name>func</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>func</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>result</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_WriteUnraisable</name><argument_list>(<argument><expr><name>context</name> ? <name>context</name> : <name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>E_FAIL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>retval</name> = <call><name>PyInt_AsLong</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_WriteUnraisable</name><argument_list>(<argument><expr><name>context</name> ? <name>context</name> : <name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>retval</name> = <name>E_FAIL</name></expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>retval</name></expr>;</return>
}</block></function>
<function><type><name>STDAPI</name></type> <name>DllCanUnloadNow</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>long</name></type> <name>result</name></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>WITH_THREAD</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>PyGILState_STATE</name></type> <name>state</name> <init>= <expr><call><name>PyGILState_Ensure</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><name>result</name> = <call><name>Call_CanUnloadNow</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>WITH_THREAD</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyGILState_Release</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<return>return <expr><name>result</name></expr>;</return>
}</block></function>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>Py_NO_ENABLE_SHARED</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function><type><name>BOOL</name> <name>WINAPI</name></type> <name>DllMain</name><parameter_list>(<param><decl><type><name>HINSTANCE</name></type> <name>hinstDLL</name></decl></param>, <param><decl><type><name>DWORD</name></type> <name>fdwReason</name></decl></param>, <param><decl><type><name>LPVOID</name></type> <name>lpvRes</name></decl></param>)</parameter_list> <block>{
<switch>switch<condition>(<expr><name>fdwReason</name></expr>)</condition> <block>{
<case>case <expr><name>DLL_PROCESS_ATTACH</name></expr>:
<expr_stmt><expr><call><name>DisableThreadLibraryCalls</name><argument_list>(<argument><expr><name>hinstDLL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</case>}</block></switch>
<return>return <expr><name>TRUE</name></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</unit>
