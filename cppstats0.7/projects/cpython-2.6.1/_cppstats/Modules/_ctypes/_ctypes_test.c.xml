<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C" filename="projects/cpython-2.6.1/_cppstats/Modules/_ctypes/_ctypes_test.c"><cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;Python.h&gt;</cpp:file></cpp:include>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_LONG_LONG</name></expr></argument>)</argument_list></call> &amp;&amp; !<call><name>defined</name><argument_list>(<argument><expr><name>PY_LONG_LONG</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PY_LONG_LONG</name></cpp:macro> <cpp:value>LONG_LONG</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MS_WIN32</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;windows.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MS_WIN32</name></expr></argument>)</argument_list></call> || <call><name>defined</name><argument_list>(<argument><expr><name>__CYGWIN__</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>EXPORT</name><parameter_list>(<param><type><name>x</name></type></param>)</parameter_list></cpp:macro> <cpp:value>__declspec(dllexport) x</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>EXPORT</name><parameter_list>(<param><type><name>x</name></type></param>)</parameter_list></cpp:macro> <cpp:value>x</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<macro><name>EXPORT</name><argument_list>(<argument>void</argument>)</argument_list></macro><macro><name>testfunc_array</name><argument_list>(<argument>int values[4]</argument>)</argument_list></macro> <block>{
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>"testfunc_array %d %d %d %d\n"</expr></argument>,
<argument><expr><name><name>values</name><index>[<expr>0</expr>]</index></name></expr></argument>,
<argument><expr><name><name>values</name><index>[<expr>1</expr>]</index></name></expr></argument>,
<argument><expr><name><name>values</name><index>[<expr>2</expr>]</index></name></expr></argument>,
<argument><expr><name><name>values</name><index>[<expr>3</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block>
<macro><name>EXPORT</name><argument_list>(<argument>long double</argument>)</argument_list></macro><macro><name>testfunc_Ddd</name><argument_list>(<argument>double a</argument>, <argument>double b</argument>)</argument_list></macro> <block>{
<decl_stmt><decl><type><name>long</name> <name>double</name></type> <name>result</name> <init>= <expr><call>(<name>long</name> <name>double</name>)<argument_list>(<argument><expr><name>a</name> * <name>b</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>"testfunc_Ddd(%p, %p)\n"</expr></argument>, <argument><expr>&amp;<name>a</name></expr></argument>, <argument><expr>&amp;<name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>"testfunc_Ddd(%g, %g)\n"</expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>result</name></expr>;</return>
}</block>
<macro><name>EXPORT</name><argument_list>(<argument>long double</argument>)</argument_list></macro><macro><name>testfunc_DDD</name><argument_list>(<argument>long double a</argument>, <argument>long double b</argument>)</argument_list></macro> <block>{
<decl_stmt><decl><type><name>long</name> <name>double</name></type> <name>result</name> <init>= <expr><name>a</name> * <name>b</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>"testfunc_DDD(%p, %p)\n"</expr></argument>, <argument><expr>&amp;<name>a</name></expr></argument>, <argument><expr>&amp;<name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>"testfunc_DDD(%Lg, %Lg)\n"</expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>result</name></expr>;</return>
}</block>
<macro><name>EXPORT</name><argument_list>(<argument>int</argument>)</argument_list></macro><macro><name>testfunc_iii</name><argument_list>(<argument>int a</argument>, <argument>int b</argument>)</argument_list></macro> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>result</name> <init>= <expr><name>a</name> * <name>b</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>"testfunc_iii(%p, %p)\n"</expr></argument>, <argument><expr>&amp;<name>a</name></expr></argument>, <argument><expr>&amp;<name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>result</name></expr>;</return>
}</block>
<macro><name>EXPORT</name><argument_list>(<argument>int</argument>)</argument_list></macro><macro><name>myprintf</name><argument_list>(<argument>char *fmt</argument>, <argument>...</argument>)</argument_list></macro> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>result</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>va_list</name></type> <name>argptr</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>argptr</name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>result</name> = <call><name>vprintf</name><argument_list>(<argument><expr><name>fmt</name></expr></argument>, <argument><expr><name>argptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>argptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>result</name></expr>;</return>
}</block>
<macro><name>EXPORT</name><argument_list>(<argument>char *</argument>)</argument_list></macro><macro><name>my_strtok</name><argument_list>(<argument>char *token</argument>, <argument>const char *delim</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name>strtok</name><argument_list>(<argument><expr><name>token</name></expr></argument>, <argument><expr><name>delim</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<macro><name>EXPORT</name><argument_list>(<argument>char *</argument>)</argument_list></macro><macro><name>my_strchr</name><argument_list>(<argument>const char *s</argument>, <argument>int c</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name>strchr</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<macro><name>EXPORT</name><argument_list>(<argument>double</argument>)</argument_list></macro> <macro><name>my_sqrt</name><argument_list>(<argument>double a</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name>sqrt</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<macro><name>EXPORT</name><argument_list>(<argument>void</argument>)</argument_list></macro> <macro><name>my_qsort</name><argument_list>(<argument>void *base</argument>, <argument>size_t num</argument>, <argument>size_t width</argument>, <argument>int(*compare)(const void*, const void*)</argument>)</argument_list></macro> <block>{
<expr_stmt><expr><call><name>qsort</name><argument_list>(<argument><expr><name>base</name></expr></argument>, <argument><expr><name>num</name></expr></argument>, <argument><expr><name>width</name></expr></argument>, <argument><expr><name>compare</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block>
<macro><name>EXPORT</name><argument_list>(<argument>int *</argument>)</argument_list></macro> <macro><name>_testfunc_ai8</name><argument_list>(<argument>int a[8]</argument>)</argument_list></macro> <block>{
<return>return <expr><name>a</name></expr>;</return>
}</block>
<macro><name>EXPORT</name><argument_list>(<argument>void</argument>)</argument_list></macro> <macro><name>_testfunc_v</name><argument_list>(<argument>int a</argument>, <argument>int b</argument>, <argument>int *presult</argument>)</argument_list></macro> <block>{
<expr_stmt><expr>*<name>presult</name> = <name>a</name> + <name>b</name></expr>;</expr_stmt>
}</block>
<macro><name>EXPORT</name><argument_list>(<argument>int</argument>)</argument_list></macro> <macro><name>_testfunc_i_bhilfd</name><argument_list>(<argument>signed char b</argument>, <argument>short h</argument>, <argument>int i</argument>, <argument>long l</argument>, <argument>float f</argument>, <argument>double d</argument>)</argument_list></macro> <block>{
<return>return <expr><call>(<name>int</name>)<argument_list>(<argument><expr><name>b</name> + <name>h</name> + <name>i</name> + <name>l</name> + <name>f</name> + <name>d</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<macro><name>EXPORT</name><argument_list>(<argument>float</argument>)</argument_list></macro> <macro><name>_testfunc_f_bhilfd</name><argument_list>(<argument>signed char b</argument>, <argument>short h</argument>, <argument>int i</argument>, <argument>long l</argument>, <argument>float f</argument>, <argument>double d</argument>)</argument_list></macro> <block>{
<return>return <expr><call>(<name>float</name>)<argument_list>(<argument><expr><name>b</name> + <name>h</name> + <name>i</name> + <name>l</name> + <name>f</name> + <name>d</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<macro><name>EXPORT</name><argument_list>(<argument>double</argument>)</argument_list></macro> <macro><name>_testfunc_d_bhilfd</name><argument_list>(<argument>signed char b</argument>, <argument>short h</argument>, <argument>int i</argument>, <argument>long l</argument>, <argument>float f</argument>, <argument>double d</argument>)</argument_list></macro> <block>{
<return>return <expr><call>(<name>double</name>)<argument_list>(<argument><expr><name>b</name> + <name>h</name> + <name>i</name> + <name>l</name> + <name>f</name> + <name>d</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<macro><name>EXPORT</name><argument_list>(<argument>long double</argument>)</argument_list></macro> <macro><name>_testfunc_D_bhilfD</name><argument_list>(<argument>signed char b</argument>, <argument>short h</argument>, <argument>int i</argument>, <argument>long l</argument>, <argument>float f</argument>, <argument>long double d</argument>)</argument_list></macro> <block>{
<return>return <expr><call>(<name>long</name> <name>double</name>)<argument_list>(<argument><expr><name>b</name> + <name>h</name> + <name>i</name> + <name>l</name> + <name>f</name> + <name>d</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<macro><name>EXPORT</name><argument_list>(<argument>char *</argument>)</argument_list></macro> <macro><name>_testfunc_p_p</name><argument_list>(<argument>void *s</argument>)</argument_list></macro> <block>{
<return>return <expr>(<name>char</name> *)<name>s</name></expr>;</return>
}</block>
<macro><name>EXPORT</name><argument_list>(<argument>void *</argument>)</argument_list></macro> <macro><name>_testfunc_c_p_p</name><argument_list>(<argument>int *argcp</argument>, <argument>char **argv</argument>)</argument_list></macro> <block>{
<return>return <expr><name><name>argv</name><index>[<expr>(*<name>argcp</name>)-1</expr>]</index></name></expr>;</return>
}</block>
<macro><name>EXPORT</name><argument_list>(<argument>void *</argument>)</argument_list></macro> <macro><name>get_strchr</name><argument_list>(<argument>void</argument>)</argument_list></macro> <block>{
<return>return <expr>(<name>void</name> *)<name>strchr</name></expr>;</return>
}</block>
<macro><name>EXPORT</name><argument_list>(<argument>char *</argument>)</argument_list></macro> <macro><name>my_strdup</name><argument_list>(<argument>char *src</argument>)</argument_list></macro> <block>{
<decl_stmt><decl><type><name>char</name> *</type><name>dst</name> <init>= <expr>(<name>char</name> *)<call><name>malloc</name><argument_list>(<argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>src</name></expr></argument>)</argument_list></call>+1</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr>!<name>dst</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>dst</name></expr></argument>, <argument><expr><name>src</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>dst</name></expr>;</return>
}</block>
<macro><name>EXPORT</name><argument_list>(<argument>void</argument>)</argument_list></macro><macro><name>my_free</name><argument_list>(<argument>void *ptr</argument>)</argument_list></macro> <block>{
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_WCHAR_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<macro><name>EXPORT</name><argument_list>(<argument>wchar_t *</argument>)</argument_list></macro> <macro><name>my_wcsdup</name><argument_list>(<argument>wchar_t *src</argument>)</argument_list></macro> <block>{
<decl_stmt><decl><type><name>size_t</name></type> <name>len</name> <init>= <expr><call><name>wcslen</name><argument_list>(<argument><expr><name>src</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>wchar_t</name> *</type><name>ptr</name> <init>= <expr>(<name>wchar_t</name> *)<call><name>malloc</name><argument_list>(<argument><expr>(<name>len</name> + 1) * <sizeof>sizeof<argument_list>(<argument><expr><name>wchar_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>ptr</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr>(<name>len</name>+1) * <sizeof>sizeof<argument_list>(<argument><expr><name>wchar_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>ptr</name></expr>;</return>
}</block>
<macro><name>EXPORT</name><argument_list>(<argument>size_t</argument>)</argument_list></macro> <macro><name>my_wcslen</name><argument_list>(<argument>wchar_t *src</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name>wcslen</name><argument_list>(<argument><expr><name>src</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>MS_WIN32</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>__stdcall</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>__stdcall</name></cpp:macro></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<typedef>typedef <type><struct>struct <block>{
<function_decl><type><name>int</name></type> (*<name>c</name>)<parameter_list>(<param><decl><type><name>int</name></type></decl></param>, <param><decl><type><name>int</name></type></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><name>int</name></type> (<name>__stdcall</name> *<name>s</name>)<parameter_list>(<param><decl><type><name>int</name></type></decl></param>, <param><decl><type><name>int</name></type></decl></param>)</parameter_list>;</function_decl>
}</block></struct></type> <name>FUNCS</name>;</typedef>
<macro><name>EXPORT</name><argument_list>(<argument>int</argument>)</argument_list></macro> <macro><name>_testfunc_callfuncp</name><argument_list>(<argument>FUNCS *fp</argument>)</argument_list></macro> <block>{
<expr_stmt><expr><call><name><name>fp</name>-&gt;<name>c</name></name><argument_list>(<argument><expr>1</expr></argument>, <argument><expr>2</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>fp</name>-&gt;<name>s</name></name><argument_list>(<argument><expr>3</expr></argument>, <argument><expr>4</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>0</expr>;</return>
}</block>
<macro><name>EXPORT</name><argument_list>(<argument>int</argument>)</argument_list></macro> <macro><name>_testfunc_deref_pointer</name><argument_list>(<argument>int *pi</argument>)</argument_list></macro> <block>{
<return>return <expr>*<name>pi</name></expr>;</return>
}</block>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MS_WIN32</name></expr></argument>)</argument_list></call></expr></cpp:if>
<macro><name>EXPORT</name><argument_list>(<argument>int</argument>)</argument_list></macro> <macro><name>_testfunc_piunk</name><argument_list>(<argument>IUnknown FAR *piunk</argument>)</argument_list></macro> <block>{
<expr_stmt><expr><call><name><name>piunk</name>-&gt;<name>lpVtbl</name>-&gt;<name>AddRef</name></name><argument_list>(<argument><expr><name>piunk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name><name>piunk</name>-&gt;<name>lpVtbl</name>-&gt;<name>Release</name></name><argument_list>(<argument><expr><name>piunk</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<macro><name>EXPORT</name><argument_list>(<argument>int</argument>)</argument_list></macro> <macro><name>_testfunc_callback_with_pointer</name><argument_list>(<argument>int (*func)(int *)</argument>)</argument_list></macro> <block>{
<decl_stmt><decl><type><name>int</name></type> <name><name>table</name><index>[]</index></name> <init>= <expr><block>{<expr>1</expr>, <expr>2</expr>, <expr>3</expr>, <expr>4</expr>, <expr>5</expr>, <expr>6</expr>, <expr>7</expr>, <expr>8</expr>, <expr>9</expr>, <expr>10</expr>}</block></expr></init></decl>;</decl_stmt>
<return>return <expr><call>(*<name>func</name>)<argument_list>(<argument><expr><name>table</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_LONG_LONG</name></expr></argument>)</argument_list></call></expr></cpp:if>
<macro><name>EXPORT</name><argument_list>(<argument>PY_LONG_LONG</argument>)</argument_list></macro> <macro><name>_testfunc_q_bhilfdq</name><argument_list>(<argument>signed char b</argument>, <argument>short h</argument>, <argument>int i</argument>, <argument>long l</argument>, <argument>float f</argument>,
<argument>double d</argument>, <argument>PY_LONG_LONG q</argument>)</argument_list></macro> <block>{
<return>return <expr><call>(<name>PY_LONG_LONG</name>)<argument_list>(<argument><expr><name>b</name> + <name>h</name> + <name>i</name> + <name>l</name> + <name>f</name> + <name>d</name> + <name>q</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<macro><name>EXPORT</name><argument_list>(<argument>PY_LONG_LONG</argument>)</argument_list></macro> <macro><name>_testfunc_q_bhilfd</name><argument_list>(<argument>signed char b</argument>, <argument>short h</argument>, <argument>int i</argument>, <argument>long l</argument>, <argument>float f</argument>, <argument>double d</argument>)</argument_list></macro> <block>{
<return>return <expr><call>(<name>PY_LONG_LONG</name>)<argument_list>(<argument><expr><name>b</name> + <name>h</name> + <name>i</name> + <name>l</name> + <name>f</name> + <name>d</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<macro><name>EXPORT</name><argument_list>(<argument>int</argument>)</argument_list></macro> <macro><name>_testfunc_callback_i_if</name><argument_list>(<argument>int value</argument>, <argument>int (*func)(int)</argument>)</argument_list></macro> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>sum</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<while>while <condition>(<expr><name>value</name> != 0</expr>)</condition> <block>{
<expr_stmt><expr><name>sum</name> += <call><name>func</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>value</name> /= 2</expr>;</expr_stmt>
}</block></while>
<return>return <expr><name>sum</name></expr>;</return>
}</block>
<macro><name>EXPORT</name><argument_list>(<argument>PY_LONG_LONG</argument>)</argument_list></macro> <macro><name>_testfunc_callback_q_qf</name><argument_list>(<argument>PY_LONG_LONG value</argument>,
<argument>PY_LONG_LONG (*func)(PY_LONG_LONG)</argument>)</argument_list></macro> <block>{
<decl_stmt><decl><type><name>PY_LONG_LONG</name></type> <name>sum</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<while>while <condition>(<expr><name>value</name> != 0</expr>)</condition> <block>{
<expr_stmt><expr><name>sum</name> += <call><name>func</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>value</name> /= 2</expr>;</expr_stmt>
}</block></while>
<return>return <expr><name>sum</name></expr>;</return>
}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<typedef>typedef <type><struct>struct <block>{
<decl_stmt><decl><type><name>char</name> *</type><name>name</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>value</name></decl>;</decl_stmt>
}</block></struct></type> <name>SPAM</name>;</typedef>
<typedef>typedef <type><struct>struct <block>{
<decl_stmt><decl><type><name>char</name> *</type><name>name</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>num_spams</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>SPAM</name> *</type><name>spams</name></decl>;</decl_stmt>
}</block></struct></type> <name>EGG</name>;</typedef>
<decl_stmt><decl><type><name>SPAM</name></type> <name><name>my_spams</name><index>[<expr>2</expr>]</index></name> <init>= <expr><block>{
<expr><block>{ <expr>"name1"</expr>, <expr>"value1"</expr> }</block></expr>,
<expr><block>{ <expr>"name2"</expr>, <expr>"value2"</expr> }</block></expr>,
}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>EGG</name></type> <name><name>my_eggs</name><index>[<expr>1</expr>]</index></name> <init>= <expr><block>{
<expr><block>{ <expr>"first egg"</expr>, <expr>1</expr>, <expr><name>my_spams</name></expr> }</block></expr>
}</block></expr></init></decl>;</decl_stmt>
<macro><name>EXPORT</name><argument_list>(<argument>int</argument>)</argument_list></macro> <macro><name>getSPAMANDEGGS</name><argument_list>(<argument>EGG **eggs</argument>)</argument_list></macro> <block>{
<expr_stmt><expr>*<name>eggs</name> = <name>my_eggs</name></expr>;</expr_stmt>
<return>return <expr>1</expr>;</return>
}</block>
<typedef>typedef <type><struct>struct <name>tagpoint</name> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>x</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>y</name></decl>;</decl_stmt>
}</block></struct></type> <name>point</name>;</typedef>
<macro><name>EXPORT</name><argument_list>(<argument>int</argument>)</argument_list></macro> <macro><name>_testfunc_byval</name><argument_list>(<argument>point in</argument>, <argument>point *pout</argument>)</argument_list></macro> <block>{
<if>if <condition>(<expr><name>pout</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>pout</name>-&gt;<name>x</name></name> = <name><name>in</name>.<name>x</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>pout</name>-&gt;<name>y</name></name> = <name><name>in</name>.<name>y</name></name></expr>;</expr_stmt>
}</block></then></if>
<return>return <expr><name><name>in</name>.<name>x</name></name> + <name><name>in</name>.<name>y</name></name></expr>;</return>
}</block>
<macro><name>EXPORT</name> <argument_list>(<argument>int</argument>)</argument_list></macro> <expr_stmt><expr><name>an_integer</name> = 42</expr>;</expr_stmt>
<macro><name>EXPORT</name><argument_list>(<argument>int</argument>)</argument_list></macro> <macro><name>get_an_integer</name><argument_list>(<argument>void</argument>)</argument_list></macro> <block>{
<return>return <expr><name>an_integer</name></expr>;</return>
}</block>
<macro><name>EXPORT</name><argument_list>(<argument>double</argument>)</argument_list></macro>
<macro><name>integrate</name><argument_list>(<argument>double a</argument>, <argument>double b</argument>, <argument>double (*f)(double)</argument>, <argument>long nstep</argument>)</argument_list></macro> <block>{
<decl_stmt><decl><type><name>double</name></type> <name>x</name></decl>, <decl><type ref="prev"/><name>sum</name><init>=<expr>0.0</expr></init>, <name>dx</name><init>=<expr>(<name>b</name>-<name>a</name>)/(<name>double</name>)<name>nstep</name></expr></init></decl>;</decl_stmt>
<for>for(<init><expr><name>x</name>=<name>a</name>+0.5*<name>dx</name></expr>;</init> <condition><expr>(<name>b</name>-<name>x</name>)*(<name>x</name>-<name>a</name>)&gt;0.0</expr>;</condition> <incr><expr><name>x</name>+=<name>dx</name></expr></incr>)
<expr_stmt><expr><name>sum</name> += <call><name>f</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></for>
<return>return <expr><name>sum</name>/(<name>double</name>)<name>nstep</name></expr>;</return>
}</block>
<typedef>typedef <type><struct>struct <block>{
<function_decl><type><name>void</name></type> (*<name>initialize</name>)<parameter_list>(<param><function_decl><type><name>void</name> *</type>(*)<parameter_list>(<param><decl><type><name>int</name></type></decl></param>)</parameter_list></function_decl></param>, <param><function_decl><type><name>void</name></type>(*)<parameter_list>(<param><decl><type><name>void</name> *</type></decl></param>)</parameter_list></function_decl></param>)</parameter_list>;</function_decl>
}</block></struct></type> <name>xxx_library</name>;</typedef>
<function><type><specifier>static</specifier> <name>void</name></type> <name>_xxx_init</name><parameter_list>(<param><function_decl><type><name>void</name> *</type>(*<name>Xalloc</name>)<parameter_list>(<param><decl><type><name>int</name></type></decl></param>)</parameter_list></function_decl></param>, <param><function_decl><type><name>void</name></type> (*<name>Xfree</name>)<parameter_list>(<param><decl><type><name>void</name> *</type></decl></param>)</parameter_list></function_decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>void</name> *</type><name>ptr</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>"_xxx_init got %p %p\n"</expr></argument>, <argument><expr><name>Xalloc</name></expr></argument>, <argument><expr><name>Xfree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>"calling\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ptr</name> = <call><name>Xalloc</name><argument_list>(<argument><expr>32</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Xfree</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>"calls done, ptr was %p\n"</expr></argument>, <argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>
<decl_stmt><decl><type><name>xxx_library</name></type> <name>_xxx_lib</name> <init>= <expr><block>{
<expr><name>_xxx_init</name></expr>
}</block></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>EXPORT</name><argument_list>(<argument><expr><name>xxx_library</name></expr></argument>)</argument_list></call> *<macro><name>library_get</name><argument_list>(<argument>void</argument>)</argument_list></macro> <block>{
<return>return <expr>&amp;<name>_xxx_lib</name></expr>;</return>
}</block></expr></expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MS_WIN32</name></expr></argument>)</argument_list></call></expr></cpp:if>
<macro><name>EXPORT</name><argument_list>(<argument>void</argument>)</argument_list></macro> <macro><name>GetString</name><argument_list>(<argument>BSTR *pbstr</argument>)</argument_list></macro> <block>{
<expr_stmt><expr>*<name>pbstr</name> = <call><name>SysAllocString</name><argument_list>(<argument><expr>L"Goodbye!"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<function><type><name>PyObject</name> *</type><name>py_func_si</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>char</name> *</type><name>name</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"si"</expr></argument>, <argument><expr>&amp;<name>name</name></expr></argument>, <argument><expr>&amp;<name>i</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>Py_None</name></expr>;</return>
}</block></function>
<macro><name>EXPORT</name><argument_list>(<argument>void</argument>)</argument_list></macro> <macro><name>_py_func_si</name><argument_list>(<argument>char *s</argument>, <argument>int i</argument>)</argument_list></macro> <block>{
}</block>
<function><type><name>PyObject</name> *</type><name>py_func</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>Py_None</name></expr>;</return>
}</block></function>
<macro><name>EXPORT</name><argument_list>(<argument>void</argument>)</argument_list></macro> <macro><name>_py_func</name><argument_list>(<argument>void</argument>)</argument_list></macro> <block>{
}</block>
<macro><name>EXPORT</name><argument_list>(<argument>PY_LONG_LONG</argument>)</argument_list></macro> <expr_stmt><expr><name>last_tf_arg_s</name></expr>;</expr_stmt>
<macro><name>EXPORT</name><argument_list>(<argument>unsigned PY_LONG_LONG</argument>)</argument_list></macro> <expr_stmt><expr><name>last_tf_arg_u</name></expr>;</expr_stmt>
<struct>struct <name>BITS</name> <block>{
<expr_stmt><expr><name>int</name> <name>A</name>: 1</expr>, <expr><name>B</name>:2</expr>, <expr><name>C</name>:3</expr>, <expr><name>D</name>:4</expr>, <expr><name>E</name>: 5</expr>, <expr><name>F</name>: 6</expr>, <expr><name>G</name>: 7</expr>, <expr><name>H</name>: 8</expr>, <expr><name>I</name>: 9</expr>;</expr_stmt>
<expr_stmt><expr><name>short</name> <name>M</name>: 1</expr>, <expr><name>N</name>: 2</expr>, <expr><name>O</name>: 3</expr>, <expr><name>P</name>: 4</expr>, <expr><name>Q</name>: 5</expr>, <expr><name>R</name>: 6</expr>, <expr><name>S</name>: 7</expr>;</expr_stmt>
}</block>;</struct>
<macro><name>DL_EXPORT</name><argument_list>(<argument>void</argument>)</argument_list></macro> <macro><name>set_bitfields</name><argument_list>(<argument>struct BITS *bits</argument>, <argument>char name</argument>, <argument>int value</argument>)</argument_list></macro> <block>{
<switch>switch <condition>(<expr><name>name</name></expr>)</condition> <block>{
<case>case <expr>'A'</expr>:
<expr_stmt><expr><name><name>bits</name>-&gt;<name>A</name></name> = <name>value</name></expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr>'B'</expr>:
<expr_stmt><expr><name><name>bits</name>-&gt;<name>B</name></name> = <name>value</name></expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr>'C'</expr>:
<expr_stmt><expr><name><name>bits</name>-&gt;<name>C</name></name> = <name>value</name></expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr>'D'</expr>:
<expr_stmt><expr><name><name>bits</name>-&gt;<name>D</name></name> = <name>value</name></expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr>'E'</expr>:
<expr_stmt><expr><name><name>bits</name>-&gt;<name>E</name></name> = <name>value</name></expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr>'F'</expr>:
<expr_stmt><expr><name><name>bits</name>-&gt;<name>F</name></name> = <name>value</name></expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr>'G'</expr>:
<expr_stmt><expr><name><name>bits</name>-&gt;<name>G</name></name> = <name>value</name></expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr>'H'</expr>:
<expr_stmt><expr><name><name>bits</name>-&gt;<name>H</name></name> = <name>value</name></expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr>'I'</expr>:
<expr_stmt><expr><name><name>bits</name>-&gt;<name>I</name></name> = <name>value</name></expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr>'M'</expr>:
<expr_stmt><expr><name><name>bits</name>-&gt;<name>M</name></name> = <name>value</name></expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr>'N'</expr>:
<expr_stmt><expr><name><name>bits</name>-&gt;<name>N</name></name> = <name>value</name></expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr>'O'</expr>:
<expr_stmt><expr><name><name>bits</name>-&gt;<name>O</name></name> = <name>value</name></expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr>'P'</expr>:
<expr_stmt><expr><name><name>bits</name>-&gt;<name>P</name></name> = <name>value</name></expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr>'Q'</expr>:
<expr_stmt><expr><name><name>bits</name>-&gt;<name>Q</name></name> = <name>value</name></expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr>'R'</expr>:
<expr_stmt><expr><name><name>bits</name>-&gt;<name>R</name></name> = <name>value</name></expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr>'S'</expr>:
<expr_stmt><expr><name><name>bits</name>-&gt;<name>S</name></name> = <name>value</name></expr>;</expr_stmt>
<break>break;</break>
</case>}</block></switch>
}</block>
<macro><name>DL_EXPORT</name><argument_list>(<argument>int</argument>)</argument_list></macro> <macro><name>unpack_bitfields</name><argument_list>(<argument>struct BITS *bits</argument>, <argument>char name</argument>)</argument_list></macro> <block>{
<switch>switch <condition>(<expr><name>name</name></expr>)</condition> <block>{
<case>case <expr>'A'</expr>:
<return>return <expr><name><name>bits</name>-&gt;<name>A</name></name></expr>;</return>
</case><case>case <expr>'B'</expr>:
<return>return <expr><name><name>bits</name>-&gt;<name>B</name></name></expr>;</return>
</case><case>case <expr>'C'</expr>:
<return>return <expr><name><name>bits</name>-&gt;<name>C</name></name></expr>;</return>
</case><case>case <expr>'D'</expr>:
<return>return <expr><name><name>bits</name>-&gt;<name>D</name></name></expr>;</return>
</case><case>case <expr>'E'</expr>:
<return>return <expr><name><name>bits</name>-&gt;<name>E</name></name></expr>;</return>
</case><case>case <expr>'F'</expr>:
<return>return <expr><name><name>bits</name>-&gt;<name>F</name></name></expr>;</return>
</case><case>case <expr>'G'</expr>:
<return>return <expr><name><name>bits</name>-&gt;<name>G</name></name></expr>;</return>
</case><case>case <expr>'H'</expr>:
<return>return <expr><name><name>bits</name>-&gt;<name>H</name></name></expr>;</return>
</case><case>case <expr>'I'</expr>:
<return>return <expr><name><name>bits</name>-&gt;<name>I</name></name></expr>;</return>
</case><case>case <expr>'M'</expr>:
<return>return <expr><name><name>bits</name>-&gt;<name>M</name></name></expr>;</return>
</case><case>case <expr>'N'</expr>:
<return>return <expr><name><name>bits</name>-&gt;<name>N</name></name></expr>;</return>
</case><case>case <expr>'O'</expr>:
<return>return <expr><name><name>bits</name>-&gt;<name>O</name></name></expr>;</return>
</case><case>case <expr>'P'</expr>:
<return>return <expr><name><name>bits</name>-&gt;<name>P</name></name></expr>;</return>
</case><case>case <expr>'Q'</expr>:
<return>return <expr><name><name>bits</name>-&gt;<name>Q</name></name></expr>;</return>
</case><case>case <expr>'R'</expr>:
<return>return <expr><name><name>bits</name>-&gt;<name>R</name></name></expr>;</return>
</case><case>case <expr>'S'</expr>:
<return>return <expr><name><name>bits</name>-&gt;<name>S</name></name></expr>;</return>
</case>}</block></switch>
<return>return <expr>0</expr>;</return>
}</block>
<decl_stmt><decl><type><specifier>static</specifier> <name>PyMethodDef</name></type> <name><name>module_methods</name><index>[]</index></name> <init>= <expr><block>{
<expr><block>{<expr>"func_si"</expr>, <expr><name>py_func_si</name></expr>, <expr><name>METH_VARARGS</name></expr>}</block></expr>,
<expr><block>{<expr>"func"</expr>, <expr><name>py_func</name></expr>, <expr><name>METH_NOARGS</name></expr>}</block></expr>,
<expr><block>{ <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr>0</expr>, <expr><name>NULL</name></expr>}</block></expr>,
}</block></expr></init></decl>;</decl_stmt>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>S</name></cpp:macro> <cpp:value>last_tf_arg_s = (PY_LONG_LONG)c</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>U</name></cpp:macro> <cpp:value>last_tf_arg_u = (unsigned PY_LONG_LONG)c</cpp:value></cpp:define>
<macro><name>EXPORT</name><argument_list>(<argument>signed char</argument>)</argument_list></macro> <macro><name>tf_b</name><argument_list>(<argument>signed char c</argument>)</argument_list></macro> <block>{
<expr_stmt><expr><name>S</name></expr>;</expr_stmt>
<return>return <expr><name>c</name>/3</expr>;</return>
}</block>
<macro><name>EXPORT</name><argument_list>(<argument>unsigned char</argument>)</argument_list></macro> <macro><name>tf_B</name><argument_list>(<argument>unsigned char c</argument>)</argument_list></macro> <block>{
<expr_stmt><expr><name>U</name></expr>;</expr_stmt>
<return>return <expr><name>c</name>/3</expr>;</return>
}</block>
<macro><name>EXPORT</name><argument_list>(<argument>short</argument>)</argument_list></macro> <macro><name>tf_h</name><argument_list>(<argument>short c</argument>)</argument_list></macro> <block>{
<expr_stmt><expr><name>S</name></expr>;</expr_stmt>
<return>return <expr><name>c</name>/3</expr>;</return>
}</block>
<macro><name>EXPORT</name><argument_list>(<argument>unsigned short</argument>)</argument_list></macro> <macro><name>tf_H</name><argument_list>(<argument>unsigned short c</argument>)</argument_list></macro> <block>{
<expr_stmt><expr><name>U</name></expr>;</expr_stmt>
<return>return <expr><name>c</name>/3</expr>;</return>
}</block>
<macro><name>EXPORT</name><argument_list>(<argument>int</argument>)</argument_list></macro> <macro><name>tf_i</name><argument_list>(<argument>int c</argument>)</argument_list></macro> <block>{
<expr_stmt><expr><name>S</name></expr>;</expr_stmt>
<return>return <expr><name>c</name>/3</expr>;</return>
}</block>
<macro><name>EXPORT</name><argument_list>(<argument>unsigned int</argument>)</argument_list></macro> <macro><name>tf_I</name><argument_list>(<argument>unsigned int c</argument>)</argument_list></macro> <block>{
<expr_stmt><expr><name>U</name></expr>;</expr_stmt>
<return>return <expr><name>c</name>/3</expr>;</return>
}</block>
<macro><name>EXPORT</name><argument_list>(<argument>long</argument>)</argument_list></macro> <macro><name>tf_l</name><argument_list>(<argument>long c</argument>)</argument_list></macro> <block>{
<expr_stmt><expr><name>S</name></expr>;</expr_stmt>
<return>return <expr><name>c</name>/3</expr>;</return>
}</block>
<macro><name>EXPORT</name><argument_list>(<argument>unsigned long</argument>)</argument_list></macro> <macro><name>tf_L</name><argument_list>(<argument>unsigned long c</argument>)</argument_list></macro> <block>{
<expr_stmt><expr><name>U</name></expr>;</expr_stmt>
<return>return <expr><name>c</name>/3</expr>;</return>
}</block>
<macro><name>EXPORT</name><argument_list>(<argument>PY_LONG_LONG</argument>)</argument_list></macro> <macro><name>tf_q</name><argument_list>(<argument>PY_LONG_LONG c</argument>)</argument_list></macro> <block>{
<expr_stmt><expr><name>S</name></expr>;</expr_stmt>
<return>return <expr><name>c</name>/3</expr>;</return>
}</block>
<macro><name>EXPORT</name><argument_list>(<argument>unsigned PY_LONG_LONG</argument>)</argument_list></macro> <macro><name>tf_Q</name><argument_list>(<argument>unsigned PY_LONG_LONG c</argument>)</argument_list></macro> <block>{
<expr_stmt><expr><name>U</name></expr>;</expr_stmt>
<return>return <expr><name>c</name>/3</expr>;</return>
}</block>
<macro><name>EXPORT</name><argument_list>(<argument>float</argument>)</argument_list></macro> <macro><name>tf_f</name><argument_list>(<argument>float c</argument>)</argument_list></macro> <block>{
<expr_stmt><expr><name>S</name></expr>;</expr_stmt>
<return>return <expr><name>c</name>/3</expr>;</return>
}</block>
<macro><name>EXPORT</name><argument_list>(<argument>double</argument>)</argument_list></macro> <macro><name>tf_d</name><argument_list>(<argument>double c</argument>)</argument_list></macro> <block>{
<expr_stmt><expr><name>S</name></expr>;</expr_stmt>
<return>return <expr><name>c</name>/3</expr>;</return>
}</block>
<macro><name>EXPORT</name><argument_list>(<argument>long double</argument>)</argument_list></macro> <macro><name>tf_D</name><argument_list>(<argument>long double c</argument>)</argument_list></macro> <block>{
<expr_stmt><expr><name>S</name></expr>;</expr_stmt>
<return>return <expr><name>c</name>/3</expr>;</return>
}</block>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MS_WIN32</name></expr></argument>)</argument_list></call></expr></cpp:if>
<macro><name>EXPORT</name><argument_list>(<argument>signed char</argument>)</argument_list></macro> <function><type><name>__stdcall</name></type> <name>s_tf_b</name><parameter_list>(<param><decl><type><name>signed</name> <name>char</name></type> <name>c</name></decl></param>)</parameter_list> <block>{
<expr_stmt><expr><name>S</name></expr>;</expr_stmt>
<return>return <expr><name>c</name>/3</expr>;</return>
}</block></function>
<macro><name>EXPORT</name><argument_list>(<argument>unsigned char</argument>)</argument_list></macro> <function><type><name>__stdcall</name></type> <name>s_tf_B</name><parameter_list>(<param><decl><type><name>unsigned</name> <name>char</name></type> <name>c</name></decl></param>)</parameter_list> <block>{
<expr_stmt><expr><name>U</name></expr>;</expr_stmt>
<return>return <expr><name>c</name>/3</expr>;</return>
}</block></function>
<macro><name>EXPORT</name><argument_list>(<argument>short</argument>)</argument_list></macro> <function><type><name>__stdcall</name></type> <name>s_tf_h</name><parameter_list>(<param><decl><type><name>short</name></type> <name>c</name></decl></param>)</parameter_list> <block>{
<expr_stmt><expr><name>S</name></expr>;</expr_stmt>
<return>return <expr><name>c</name>/3</expr>;</return>
}</block></function>
<macro><name>EXPORT</name><argument_list>(<argument>unsigned short</argument>)</argument_list></macro> <function><type><name>__stdcall</name></type> <name>s_tf_H</name><parameter_list>(<param><decl><type><name>unsigned</name> <name>short</name></type> <name>c</name></decl></param>)</parameter_list> <block>{
<expr_stmt><expr><name>U</name></expr>;</expr_stmt>
<return>return <expr><name>c</name>/3</expr>;</return>
}</block></function>
<macro><name>EXPORT</name><argument_list>(<argument>int</argument>)</argument_list></macro> <function><type><name>__stdcall</name></type> <name>s_tf_i</name><parameter_list>(<param><decl><type><name>int</name></type> <name>c</name></decl></param>)</parameter_list> <block>{
<expr_stmt><expr><name>S</name></expr>;</expr_stmt>
<return>return <expr><name>c</name>/3</expr>;</return>
}</block></function>
<macro><name>EXPORT</name><argument_list>(<argument>unsigned int</argument>)</argument_list></macro> <function><type><name>__stdcall</name></type> <name>s_tf_I</name><parameter_list>(<param><decl><type><name>unsigned</name> <name>int</name></type> <name>c</name></decl></param>)</parameter_list> <block>{
<expr_stmt><expr><name>U</name></expr>;</expr_stmt>
<return>return <expr><name>c</name>/3</expr>;</return>
}</block></function>
<macro><name>EXPORT</name><argument_list>(<argument>long</argument>)</argument_list></macro> <function><type><name>__stdcall</name></type> <name>s_tf_l</name><parameter_list>(<param><decl><type><name>long</name></type> <name>c</name></decl></param>)</parameter_list> <block>{
<expr_stmt><expr><name>S</name></expr>;</expr_stmt>
<return>return <expr><name>c</name>/3</expr>;</return>
}</block></function>
<macro><name>EXPORT</name><argument_list>(<argument>unsigned long</argument>)</argument_list></macro> <function><type><name>__stdcall</name></type> <name>s_tf_L</name><parameter_list>(<param><decl><type><name>unsigned</name> <name>long</name></type> <name>c</name></decl></param>)</parameter_list> <block>{
<expr_stmt><expr><name>U</name></expr>;</expr_stmt>
<return>return <expr><name>c</name>/3</expr>;</return>
}</block></function>
<macro><name>EXPORT</name><argument_list>(<argument>PY_LONG_LONG</argument>)</argument_list></macro> <function><type><name>__stdcall</name></type> <name>s_tf_q</name><parameter_list>(<param><decl><type><name>PY_LONG_LONG</name></type> <name>c</name></decl></param>)</parameter_list> <block>{
<expr_stmt><expr><name>S</name></expr>;</expr_stmt>
<return>return <expr><name>c</name>/3</expr>;</return>
}</block></function>
<macro><name>EXPORT</name><argument_list>(<argument>unsigned PY_LONG_LONG</argument>)</argument_list></macro> <function><type><name>__stdcall</name></type> <name>s_tf_Q</name><parameter_list>(<param><decl><type><name>unsigned</name> <name>PY_LONG_LONG</name></type> <name>c</name></decl></param>)</parameter_list> <block>{
<expr_stmt><expr><name>U</name></expr>;</expr_stmt>
<return>return <expr><name>c</name>/3</expr>;</return>
}</block></function>
<macro><name>EXPORT</name><argument_list>(<argument>float</argument>)</argument_list></macro> <function><type><name>__stdcall</name></type> <name>s_tf_f</name><parameter_list>(<param><decl><type><name>float</name></type> <name>c</name></decl></param>)</parameter_list> <block>{
<expr_stmt><expr><name>S</name></expr>;</expr_stmt>
<return>return <expr><name>c</name>/3</expr>;</return>
}</block></function>
<macro><name>EXPORT</name><argument_list>(<argument>double</argument>)</argument_list></macro> <function><type><name>__stdcall</name></type> <name>s_tf_d</name><parameter_list>(<param><decl><type><name>double</name></type> <name>c</name></decl></param>)</parameter_list> <block>{
<expr_stmt><expr><name>S</name></expr>;</expr_stmt>
<return>return <expr><name>c</name>/3</expr>;</return>
}</block></function>
<macro><name>EXPORT</name><argument_list>(<argument>long double</argument>)</argument_list></macro> <function><type><name>__stdcall</name></type> <name>s_tf_D</name><parameter_list>(<param><decl><type><name>long</name> <name>double</name></type> <name>c</name></decl></param>)</parameter_list> <block>{
<expr_stmt><expr><name>S</name></expr>;</expr_stmt>
<return>return <expr><name>c</name>/3</expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<macro><name>EXPORT</name><argument_list>(<argument>signed char</argument>)</argument_list></macro> <macro><name>tf_bb</name><argument_list>(<argument>signed char x</argument>, <argument>signed char c</argument>)</argument_list></macro> <block>{
<expr_stmt><expr><name>S</name></expr>;</expr_stmt>
<return>return <expr><name>c</name>/3</expr>;</return>
}</block>
<macro><name>EXPORT</name><argument_list>(<argument>unsigned char</argument>)</argument_list></macro> <macro><name>tf_bB</name><argument_list>(<argument>signed char x</argument>, <argument>unsigned char c</argument>)</argument_list></macro> <block>{
<expr_stmt><expr><name>U</name></expr>;</expr_stmt>
<return>return <expr><name>c</name>/3</expr>;</return>
}</block>
<macro><name>EXPORT</name><argument_list>(<argument>short</argument>)</argument_list></macro> <macro><name>tf_bh</name><argument_list>(<argument>signed char x</argument>, <argument>short c</argument>)</argument_list></macro> <block>{
<expr_stmt><expr><name>S</name></expr>;</expr_stmt>
<return>return <expr><name>c</name>/3</expr>;</return>
}</block>
<macro><name>EXPORT</name><argument_list>(<argument>unsigned short</argument>)</argument_list></macro> <macro><name>tf_bH</name><argument_list>(<argument>signed char x</argument>, <argument>unsigned short c</argument>)</argument_list></macro> <block>{
<expr_stmt><expr><name>U</name></expr>;</expr_stmt>
<return>return <expr><name>c</name>/3</expr>;</return>
}</block>
<macro><name>EXPORT</name><argument_list>(<argument>int</argument>)</argument_list></macro> <macro><name>tf_bi</name><argument_list>(<argument>signed char x</argument>, <argument>int c</argument>)</argument_list></macro> <block>{
<expr_stmt><expr><name>S</name></expr>;</expr_stmt>
<return>return <expr><name>c</name>/3</expr>;</return>
}</block>
<macro><name>EXPORT</name><argument_list>(<argument>unsigned int</argument>)</argument_list></macro> <macro><name>tf_bI</name><argument_list>(<argument>signed char x</argument>, <argument>unsigned int c</argument>)</argument_list></macro> <block>{
<expr_stmt><expr><name>U</name></expr>;</expr_stmt>
<return>return <expr><name>c</name>/3</expr>;</return>
}</block>
<macro><name>EXPORT</name><argument_list>(<argument>long</argument>)</argument_list></macro> <macro><name>tf_bl</name><argument_list>(<argument>signed char x</argument>, <argument>long c</argument>)</argument_list></macro> <block>{
<expr_stmt><expr><name>S</name></expr>;</expr_stmt>
<return>return <expr><name>c</name>/3</expr>;</return>
}</block>
<macro><name>EXPORT</name><argument_list>(<argument>unsigned long</argument>)</argument_list></macro> <macro><name>tf_bL</name><argument_list>(<argument>signed char x</argument>, <argument>unsigned long c</argument>)</argument_list></macro> <block>{
<expr_stmt><expr><name>U</name></expr>;</expr_stmt>
<return>return <expr><name>c</name>/3</expr>;</return>
}</block>
<macro><name>EXPORT</name><argument_list>(<argument>PY_LONG_LONG</argument>)</argument_list></macro> <macro><name>tf_bq</name><argument_list>(<argument>signed char x</argument>, <argument>PY_LONG_LONG c</argument>)</argument_list></macro> <block>{
<expr_stmt><expr><name>S</name></expr>;</expr_stmt>
<return>return <expr><name>c</name>/3</expr>;</return>
}</block>
<macro><name>EXPORT</name><argument_list>(<argument>unsigned PY_LONG_LONG</argument>)</argument_list></macro> <macro><name>tf_bQ</name><argument_list>(<argument>signed char x</argument>, <argument>unsigned PY_LONG_LONG c</argument>)</argument_list></macro> <block>{
<expr_stmt><expr><name>U</name></expr>;</expr_stmt>
<return>return <expr><name>c</name>/3</expr>;</return>
}</block>
<macro><name>EXPORT</name><argument_list>(<argument>float</argument>)</argument_list></macro> <macro><name>tf_bf</name><argument_list>(<argument>signed char x</argument>, <argument>float c</argument>)</argument_list></macro> <block>{
<expr_stmt><expr><name>S</name></expr>;</expr_stmt>
<return>return <expr><name>c</name>/3</expr>;</return>
}</block>
<macro><name>EXPORT</name><argument_list>(<argument>double</argument>)</argument_list></macro> <macro><name>tf_bd</name><argument_list>(<argument>signed char x</argument>, <argument>double c</argument>)</argument_list></macro> <block>{
<expr_stmt><expr><name>S</name></expr>;</expr_stmt>
<return>return <expr><name>c</name>/3</expr>;</return>
}</block>
<macro><name>EXPORT</name><argument_list>(<argument>long double</argument>)</argument_list></macro> <macro><name>tf_bD</name><argument_list>(<argument>signed char x</argument>, <argument>long double c</argument>)</argument_list></macro> <block>{
<expr_stmt><expr><name>S</name></expr>;</expr_stmt>
<return>return <expr><name>c</name>/3</expr>;</return>
}</block>
<macro><name>EXPORT</name><argument_list>(<argument>void</argument>)</argument_list></macro> <macro><name>tv_i</name><argument_list>(<argument>int c</argument>)</argument_list></macro> <block>{
<expr_stmt><expr><name>S</name></expr>;</expr_stmt>
<return>return;</return>
}</block>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MS_WIN32</name></expr></argument>)</argument_list></call></expr></cpp:if>
<macro><name>EXPORT</name><argument_list>(<argument>signed char</argument>)</argument_list></macro> <function><type><name>__stdcall</name></type> <name>s_tf_bb</name><parameter_list>(<param><decl><type><name>signed</name> <name>char</name></type> <name>x</name></decl></param>, <param><decl><type><name>signed</name> <name>char</name></type> <name>c</name></decl></param>)</parameter_list> <block>{
<expr_stmt><expr><name>S</name></expr>;</expr_stmt>
<return>return <expr><name>c</name>/3</expr>;</return>
}</block></function>
<macro><name>EXPORT</name><argument_list>(<argument>unsigned char</argument>)</argument_list></macro> <function><type><name>__stdcall</name></type> <name>s_tf_bB</name><parameter_list>(<param><decl><type><name>signed</name> <name>char</name></type> <name>x</name></decl></param>, <param><decl><type><name>unsigned</name> <name>char</name></type> <name>c</name></decl></param>)</parameter_list> <block>{
<expr_stmt><expr><name>U</name></expr>;</expr_stmt>
<return>return <expr><name>c</name>/3</expr>;</return>
}</block></function>
<macro><name>EXPORT</name><argument_list>(<argument>short</argument>)</argument_list></macro> <function><type><name>__stdcall</name></type> <name>s_tf_bh</name><parameter_list>(<param><decl><type><name>signed</name> <name>char</name></type> <name>x</name></decl></param>, <param><decl><type><name>short</name></type> <name>c</name></decl></param>)</parameter_list> <block>{
<expr_stmt><expr><name>S</name></expr>;</expr_stmt>
<return>return <expr><name>c</name>/3</expr>;</return>
}</block></function>
<macro><name>EXPORT</name><argument_list>(<argument>unsigned short</argument>)</argument_list></macro> <function><type><name>__stdcall</name></type> <name>s_tf_bH</name><parameter_list>(<param><decl><type><name>signed</name> <name>char</name></type> <name>x</name></decl></param>, <param><decl><type><name>unsigned</name> <name>short</name></type> <name>c</name></decl></param>)</parameter_list> <block>{
<expr_stmt><expr><name>U</name></expr>;</expr_stmt>
<return>return <expr><name>c</name>/3</expr>;</return>
}</block></function>
<macro><name>EXPORT</name><argument_list>(<argument>int</argument>)</argument_list></macro> <function><type><name>__stdcall</name></type> <name>s_tf_bi</name><parameter_list>(<param><decl><type><name>signed</name> <name>char</name></type> <name>x</name></decl></param>, <param><decl><type><name>int</name></type> <name>c</name></decl></param>)</parameter_list> <block>{
<expr_stmt><expr><name>S</name></expr>;</expr_stmt>
<return>return <expr><name>c</name>/3</expr>;</return>
}</block></function>
<macro><name>EXPORT</name><argument_list>(<argument>unsigned int</argument>)</argument_list></macro> <function><type><name>__stdcall</name></type> <name>s_tf_bI</name><parameter_list>(<param><decl><type><name>signed</name> <name>char</name></type> <name>x</name></decl></param>, <param><decl><type><name>unsigned</name> <name>int</name></type> <name>c</name></decl></param>)</parameter_list> <block>{
<expr_stmt><expr><name>U</name></expr>;</expr_stmt>
<return>return <expr><name>c</name>/3</expr>;</return>
}</block></function>
<macro><name>EXPORT</name><argument_list>(<argument>long</argument>)</argument_list></macro> <function><type><name>__stdcall</name></type> <name>s_tf_bl</name><parameter_list>(<param><decl><type><name>signed</name> <name>char</name></type> <name>x</name></decl></param>, <param><decl><type><name>long</name></type> <name>c</name></decl></param>)</parameter_list> <block>{
<expr_stmt><expr><name>S</name></expr>;</expr_stmt>
<return>return <expr><name>c</name>/3</expr>;</return>
}</block></function>
<macro><name>EXPORT</name><argument_list>(<argument>unsigned long</argument>)</argument_list></macro> <function><type><name>__stdcall</name></type> <name>s_tf_bL</name><parameter_list>(<param><decl><type><name>signed</name> <name>char</name></type> <name>x</name></decl></param>, <param><decl><type><name>unsigned</name> <name>long</name></type> <name>c</name></decl></param>)</parameter_list> <block>{
<expr_stmt><expr><name>U</name></expr>;</expr_stmt>
<return>return <expr><name>c</name>/3</expr>;</return>
}</block></function>
<macro><name>EXPORT</name><argument_list>(<argument>PY_LONG_LONG</argument>)</argument_list></macro> <function><type><name>__stdcall</name></type> <name>s_tf_bq</name><parameter_list>(<param><decl><type><name>signed</name> <name>char</name></type> <name>x</name></decl></param>, <param><decl><type><name>PY_LONG_LONG</name></type> <name>c</name></decl></param>)</parameter_list> <block>{
<expr_stmt><expr><name>S</name></expr>;</expr_stmt>
<return>return <expr><name>c</name>/3</expr>;</return>
}</block></function>
<macro><name>EXPORT</name><argument_list>(<argument>unsigned PY_LONG_LONG</argument>)</argument_list></macro> <function><type><name>__stdcall</name></type> <name>s_tf_bQ</name><parameter_list>(<param><decl><type><name>signed</name> <name>char</name></type> <name>x</name></decl></param>, <param><decl><type><name>unsigned</name> <name>PY_LONG_LONG</name></type> <name>c</name></decl></param>)</parameter_list> <block>{
<expr_stmt><expr><name>U</name></expr>;</expr_stmt>
<return>return <expr><name>c</name>/3</expr>;</return>
}</block></function>
<macro><name>EXPORT</name><argument_list>(<argument>float</argument>)</argument_list></macro> <function><type><name>__stdcall</name></type> <name>s_tf_bf</name><parameter_list>(<param><decl><type><name>signed</name> <name>char</name></type> <name>x</name></decl></param>, <param><decl><type><name>float</name></type> <name>c</name></decl></param>)</parameter_list> <block>{
<expr_stmt><expr><name>S</name></expr>;</expr_stmt>
<return>return <expr><name>c</name>/3</expr>;</return>
}</block></function>
<macro><name>EXPORT</name><argument_list>(<argument>double</argument>)</argument_list></macro> <function><type><name>__stdcall</name></type> <name>s_tf_bd</name><parameter_list>(<param><decl><type><name>signed</name> <name>char</name></type> <name>x</name></decl></param>, <param><decl><type><name>double</name></type> <name>c</name></decl></param>)</parameter_list> <block>{
<expr_stmt><expr><name>S</name></expr>;</expr_stmt>
<return>return <expr><name>c</name>/3</expr>;</return>
}</block></function>
<macro><name>EXPORT</name><argument_list>(<argument>long double</argument>)</argument_list></macro> <function><type><name>__stdcall</name></type> <name>s_tf_bD</name><parameter_list>(<param><decl><type><name>signed</name> <name>char</name></type> <name>x</name></decl></param>, <param><decl><type><name>long</name> <name>double</name></type> <name>c</name></decl></param>)</parameter_list> <block>{
<expr_stmt><expr><name>S</name></expr>;</expr_stmt>
<return>return <expr><name>c</name>/3</expr>;</return>
}</block></function>
<macro><name>EXPORT</name><argument_list>(<argument>void</argument>)</argument_list></macro> <function><type><name>__stdcall</name></type> <name>s_tv_i</name><parameter_list>(<param><decl><type><name>int</name></type> <name>c</name></decl></param>)</parameter_list> <block>{
<expr_stmt><expr><name>S</name></expr>;</expr_stmt>
<return>return;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>MS_WIN32</name></expr></argument>)</argument_list></call></expr></cpp:if>
<typedef>typedef <type><struct>struct <block>{
<decl_stmt><decl><type><name>long</name></type> <name>x</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>long</name></type> <name>y</name></decl>;</decl_stmt>
}</block></struct></type> <name>POINT</name>;</typedef>
<typedef>typedef <type><struct>struct <block>{
<decl_stmt><decl><type><name>long</name></type> <name>left</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>long</name></type> <name>top</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>long</name></type> <name>right</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>long</name></type> <name>bottom</name></decl>;</decl_stmt>
}</block></struct></type> <name>RECT</name>;</typedef>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<macro><name>EXPORT</name><argument_list>(<argument>int</argument>)</argument_list></macro> <macro><name>PointInRect</name><argument_list>(<argument>RECT *prc</argument>, <argument>POINT pt</argument>)</argument_list></macro> <block>{
<if>if <condition>(<expr><name><name>pt</name>.<name>x</name></name> &lt; <name><name>prc</name>-&gt;<name>left</name></name></expr>)</condition><then>
<return>return <expr>0</expr>;</return></then></if>
<if>if <condition>(<expr><name><name>pt</name>.<name>x</name></name> &gt; <name><name>prc</name>-&gt;<name>right</name></name></expr>)</condition><then>
<return>return <expr>0</expr>;</return></then></if>
<if>if <condition>(<expr><name><name>pt</name>.<name>y</name></name> &lt; <name><name>prc</name>-&gt;<name>top</name></name></expr>)</condition><then>
<return>return <expr>0</expr>;</return></then></if>
<if>if <condition>(<expr><name><name>pt</name>.<name>y</name></name> &gt; <name><name>prc</name>-&gt;<name>bottom</name></name></expr>)</condition><then>
<return>return <expr>0</expr>;</return></then></if>
<return>return <expr>1</expr>;</return>
}</block>
<typedef>typedef <type><struct>struct <block>{
<decl_stmt><decl><type><name>short</name></type> <name>x</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>short</name></type> <name>y</name></decl>;</decl_stmt>
}</block></struct></type> <name>S2H</name>;</typedef>
<macro><name>EXPORT</name><argument_list>(<argument>S2H</argument>)</argument_list></macro> <macro><name>ret_2h_func</name><argument_list>(<argument>S2H inp</argument>)</argument_list></macro> <block>{
<expr_stmt><expr><name><name>inp</name>.<name>x</name></name> *= 2</expr>;</expr_stmt>
<expr_stmt><expr><name><name>inp</name>.<name>y</name></name> *= 3</expr>;</expr_stmt>
<return>return <expr><name>inp</name></expr>;</return>
}</block>
<typedef>typedef <type><struct>struct <block>{
<decl_stmt><decl><type><name>int</name></type> <name>a</name></decl>, <name>b</name>, <name>c</name>, <name>d</name>, <name>e</name>, <name>f</name>, <name>g</name>, <name>h</name>;</decl_stmt>
}</block></struct></type> <name>S8I</name>;</typedef>
<macro><name>EXPORT</name><argument_list>(<argument>S8I</argument>)</argument_list></macro> <macro><name>ret_8i_func</name><argument_list>(<argument>S8I inp</argument>)</argument_list></macro> <block>{
<expr_stmt><expr><name><name>inp</name>.<name>a</name></name> *= 2</expr>;</expr_stmt>
<expr_stmt><expr><name><name>inp</name>.<name>b</name></name> *= 3</expr>;</expr_stmt>
<expr_stmt><expr><name><name>inp</name>.<name>c</name></name> *= 4</expr>;</expr_stmt>
<expr_stmt><expr><name><name>inp</name>.<name>d</name></name> *= 5</expr>;</expr_stmt>
<expr_stmt><expr><name><name>inp</name>.<name>e</name></name> *= 6</expr>;</expr_stmt>
<expr_stmt><expr><name><name>inp</name>.<name>f</name></name> *= 7</expr>;</expr_stmt>
<expr_stmt><expr><name><name>inp</name>.<name>g</name></name> *= 8</expr>;</expr_stmt>
<expr_stmt><expr><name><name>inp</name>.<name>h</name></name> *= 9</expr>;</expr_stmt>
<return>return <expr><name>inp</name></expr>;</return>
}</block>
<macro><name>EXPORT</name><argument_list>(<argument>int</argument>)</argument_list></macro> <macro><name>GetRectangle</name><argument_list>(<argument>int flag</argument>, <argument>RECT *prect</argument>)</argument_list></macro> <block>{
<if>if <condition>(<expr><name>flag</name> == 0</expr>)</condition><then>
<return>return <expr>0</expr>;</return></then></if>
<expr_stmt><expr><name><name>prect</name>-&gt;<name>left</name></name> = (<name>int</name>)<name>flag</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>prect</name>-&gt;<name>top</name></name> = (<name>int</name>)<name>flag</name> + 1</expr>;</expr_stmt>
<expr_stmt><expr><name><name>prect</name>-&gt;<name>right</name></name> = (<name>int</name>)<name>flag</name> + 2</expr>;</expr_stmt>
<expr_stmt><expr><name><name>prect</name>-&gt;<name>bottom</name></name> = (<name>int</name>)<name>flag</name> + 3</expr>;</expr_stmt>
<return>return <expr>1</expr>;</return>
}</block>
<macro><name>EXPORT</name><argument_list>(<argument>void</argument>)</argument_list></macro> <macro><name>TwoOutArgs</name><argument_list>(<argument>int a</argument>, <argument>int *pi</argument>, <argument>int b</argument>, <argument>int *pj</argument>)</argument_list></macro> <block>{
<expr_stmt><expr>*<name>pi</name> += <name>a</name></expr>;</expr_stmt>
<expr_stmt><expr>*<name>pj</name> += <name>b</name></expr>;</expr_stmt>
}</block>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MS_WIN32</name></expr></argument>)</argument_list></call></expr></cpp:if>
<macro><name>EXPORT</name><argument_list>(<argument>S2H</argument>)</argument_list></macro> <function><type><name>__stdcall</name></type> <name>s_ret_2h_func</name><parameter_list>(<param><decl><type><name>S2H</name></type> <name>inp</name></decl></param>)</parameter_list> <block>{
<return>return <expr><call><name>ret_2h_func</name><argument_list>(<argument><expr><name>inp</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<macro><name>EXPORT</name><argument_list>(<argument>S8I</argument>)</argument_list></macro> <function><type><name>__stdcall</name></type> <name>s_ret_8i_func</name><parameter_list>(<param><decl><type><name>S8I</name></type> <name>inp</name></decl></param>)</parameter_list> <block>{
<return>return <expr><call><name>ret_8i_func</name><argument_list>(<argument><expr><name>inp</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MS_WIN32</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdlib.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;search.h&gt;</cpp:file></cpp:include>
<macro><name>EXPORT</name> <argument_list>(<argument>HRESULT</argument>)</argument_list></macro> <macro><name>KeepObject</name><argument_list>(<argument>IUnknown *punk</argument>)</argument_list></macro> <block>{
<decl_stmt><decl><type><specifier>static</specifier> <name>IUnknown</name> *</type><name>pobj</name></decl>;</decl_stmt>
<if>if <condition>(<expr><name>punk</name></expr>)</condition><then>
<expr_stmt><expr><call><name><name>punk</name>-&gt;<name>lpVtbl</name>-&gt;<name>AddRef</name></name><argument_list>(<argument><expr><name>punk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<if>if <condition>(<expr><name>pobj</name></expr>)</condition><then>
<expr_stmt><expr><call><name><name>pobj</name>-&gt;<name>lpVtbl</name>-&gt;<name>Release</name></name><argument_list>(<argument><expr><name>pobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<expr_stmt><expr><name>pobj</name> = <name>punk</name></expr>;</expr_stmt>
<return>return <expr><name>S_OK</name></expr>;</return>
}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<macro><name>DL_EXPORT</name><argument_list>(<argument>void</argument>)</argument_list></macro>
<macro><name>init_ctypes_test</name><argument_list>(<argument>void</argument>)</argument_list></macro> <block>{
<expr_stmt><expr><call><name>Py_InitModule</name><argument_list>(<argument><expr>"_ctypes_test"</expr></argument>, <argument><expr><name>module_methods</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block>
</unit>
