<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C" filename="projects/cpython-2.6.1/_cppstats/Modules/cjkcodecs/_codecs_iso2022.c"><cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>USING_IMPORTED_MAPS</name></cpp:macro></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>USING_BINARY_PAIR_SEARCH</name></cpp:macro></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>EXTERN_JISX0213_PAIR</name></cpp:macro></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>EMULATE_JISX0213_2000_ENCODE_INVALID</name></cpp:macro> <cpp:value>MAP_UNMAPPABLE</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>EMULATE_JISX0213_2000_DECODE_INVALID</name></cpp:macro> <cpp:value>MAP_UNMAPPABLE</cpp:value></cpp:define>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cjkcodecs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"alg_jisx0201.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"emu_jisx0213_2000.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"mappings_jisx0213_pair.h"</cpp:file></cpp:include>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ESC</name></cpp:macro> <cpp:value>0x1B</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SO</name></cpp:macro> <cpp:value>0x0E</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SI</name></cpp:macro> <cpp:value>0x0F</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LF</name></cpp:macro> <cpp:value>0x0A</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAX_ESCSEQLEN</name></cpp:macro> <cpp:value>16</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CHARSET_ISO8859_1</name></cpp:macro> <cpp:value>'A'</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CHARSET_ASCII</name></cpp:macro> <cpp:value>'B'</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CHARSET_ISO8859_7</name></cpp:macro> <cpp:value>'F'</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CHARSET_JISX0201_K</name></cpp:macro> <cpp:value>'I'</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CHARSET_JISX0201_R</name></cpp:macro> <cpp:value>'J'</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CHARSET_GB2312</name></cpp:macro> <cpp:value>('A'|CHARSET_DBCS)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CHARSET_JISX0208</name></cpp:macro> <cpp:value>('B'|CHARSET_DBCS)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CHARSET_KSX1001</name></cpp:macro> <cpp:value>('C'|CHARSET_DBCS)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CHARSET_JISX0212</name></cpp:macro> <cpp:value>('D'|CHARSET_DBCS)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CHARSET_GB2312_8565</name></cpp:macro> <cpp:value>('E'|CHARSET_DBCS)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CHARSET_CNS11643_1</name></cpp:macro> <cpp:value>('G'|CHARSET_DBCS)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CHARSET_CNS11643_2</name></cpp:macro> <cpp:value>('H'|CHARSET_DBCS)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CHARSET_JISX0213_2000_1</name></cpp:macro> <cpp:value>('O'|CHARSET_DBCS)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CHARSET_JISX0213_2</name></cpp:macro> <cpp:value>('P'|CHARSET_DBCS)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CHARSET_JISX0213_2004_1</name></cpp:macro> <cpp:value>('Q'|CHARSET_DBCS)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CHARSET_JISX0208_O</name></cpp:macro> <cpp:value>('@'|CHARSET_DBCS)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CHARSET_DBCS</name></cpp:macro> <cpp:value>0x80</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ESCMARK</name><parameter_list>(<param><type><name>mark</name></type></param>)</parameter_list></cpp:macro> <cpp:value>((mark) &amp; 0x7f)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IS_ESCEND</name><parameter_list>(<param><type><name>c</name></type></param>)</parameter_list></cpp:macro> <cpp:value>(((c) &gt;= 'A' &amp;&amp; (c) &lt;= 'Z') || (c) == '@')</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IS_ISO2022ESC</name><parameter_list>(<param><type><name>c2</name></type></param>)</parameter_list></cpp:macro> <cpp:value>((c2) == '(' || (c2) == ')' || (c2) == '$' || (c2) == '.' || (c2) == '&amp;')</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAP_UNMAPPABLE</name></cpp:macro> <cpp:value>0xFFFF</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAP_MULTIPLE_AVAIL</name></cpp:macro> <cpp:value>0xFFFE</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>F_SHIFTED</name></cpp:macro> <cpp:value>0x01</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>F_ESCTHROUGHOUT</name></cpp:macro> <cpp:value>0x02</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>STATE_SETG</name><parameter_list>(<param><type><name>dn</name></type></param>, <param><type><name>v</name></type></param>)</parameter_list></cpp:macro> <cpp:value>((state)-&gt;c[dn]) = (v);</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>STATE_GETG</name><parameter_list>(<param><type><name>dn</name></type></param>)</parameter_list></cpp:macro> <cpp:value>((state)-&gt;c[dn])</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>STATE_G0</name></cpp:macro> <cpp:value>STATE_GETG(0)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>STATE_G1</name></cpp:macro> <cpp:value>STATE_GETG(1)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>STATE_G2</name></cpp:macro> <cpp:value>STATE_GETG(2)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>STATE_G3</name></cpp:macro> <cpp:value>STATE_GETG(3)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>STATE_SETG0</name><parameter_list>(<param><type><name>v</name></type></param>)</parameter_list></cpp:macro> <cpp:value>STATE_SETG(0, v)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>STATE_SETG1</name><parameter_list>(<param><type><name>v</name></type></param>)</parameter_list></cpp:macro> <cpp:value>STATE_SETG(1, v)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>STATE_SETG2</name><parameter_list>(<param><type><name>v</name></type></param>)</parameter_list></cpp:macro> <cpp:value>STATE_SETG(2, v)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>STATE_SETG3</name><parameter_list>(<param><type><name>v</name></type></param>)</parameter_list></cpp:macro> <cpp:value>STATE_SETG(3, v)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>STATE_SETFLAG</name><parameter_list>(<param><type><name>f</name></type></param>)</parameter_list></cpp:macro> <cpp:value>((state)-&gt;c[4]) |= (f);</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>STATE_GETFLAG</name><parameter_list>(<param><type><name>f</name></type></param>)</parameter_list></cpp:macro> <cpp:value>((state)-&gt;c[4] &amp; (f))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>STATE_CLEARFLAG</name><parameter_list>(<param><type><name>f</name></type></param>)</parameter_list></cpp:macro> <cpp:value>((state)-&gt;c[4]) &amp;= ~(f);</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>STATE_CLEARFLAGS</name><parameter_list>()</parameter_list></cpp:macro> <cpp:value>((state)-&gt;c[4]) = 0;</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ISO2022_CONFIG</name></cpp:macro> <cpp:value>((const struct iso2022_config *)config)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CONFIG_ISSET</name><parameter_list>(<param><type><name>flag</name></type></param>)</parameter_list></cpp:macro> <cpp:value>(ISO2022_CONFIG-&gt;flags &amp; (flag))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CONFIG_DESIGNATIONS</name></cpp:macro> <cpp:value>(ISO2022_CONFIG-&gt;designations)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NO_SHIFT</name></cpp:macro> <cpp:value>0x01</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>USE_G2</name></cpp:macro> <cpp:value>0x02</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>USE_JISX0208_EXT</name></cpp:macro> <cpp:value>0x04</cpp:value></cpp:define>
<typedef>typedef <function_decl><type><name>int</name></type> (*<name>iso2022_init_func</name>)<parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list>;</function_decl></typedef>
<typedef>typedef <function_decl><type><name>ucs4_t</name></type> (*<name>iso2022_decode_func</name>)<parameter_list>(<param><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> *</type><name>data</name></decl></param>)</parameter_list>;</function_decl></typedef>
<typedef>typedef <function_decl><type><name>DBCHAR</name></type> (*<name>iso2022_encode_func</name>)<parameter_list>(<param><decl><type><specifier>const</specifier> <name>ucs4_t</name> *</type><name>data</name></decl></param>, <param><decl><type><name>Py_ssize_t</name> *</type><name>length</name></decl></param>)</parameter_list>;</function_decl></typedef>
<struct>struct <name>iso2022_designation</name> <block>{
<decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name>mark</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name>plane</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name>width</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>iso2022_init_func</name></type> <name>initializer</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>iso2022_decode_func</name></type> <name>decoder</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>iso2022_encode_func</name></type> <name>encoder</name></decl>;</decl_stmt>
}</block>;</struct>
<struct>struct <name>iso2022_config</name> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>flags</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> struct <name>iso2022_designation</name> *</type><name>designations</name></decl>;</decl_stmt>
}</block>;</struct>
<macro><name>CODEC_INIT</name><argument_list>(<argument>iso2022</argument>)</argument_list></macro> <block>{
<decl_stmt><decl><type><specifier>const</specifier> struct <name>iso2022_designation</name> *</type><name>desig</name> <init>= <expr><name>CONFIG_DESIGNATIONS</name></expr></init></decl>;</decl_stmt>
<for>for (<init><expr><name>desig</name> = <name>CONFIG_DESIGNATIONS</name></expr>;</init> <condition><expr><name><name>desig</name>-&gt;<name>mark</name></name></expr>;</condition> <incr><expr><name>desig</name>++</expr></incr>)
<if>if <condition>(<expr><name><name>desig</name>-&gt;<name>initializer</name></name> != <name>NULL</name> &amp;&amp; <call><name><name>desig</name>-&gt;<name>initializer</name></name><argument_list>()</argument_list></call> != 0</expr>)</condition><then>
<return>return <expr>-1</expr>;</return></then></if></for>
<return>return <expr>0</expr>;</return>
}</block>
<macro><name>ENCODER_INIT</name><argument_list>(<argument>iso2022</argument>)</argument_list></macro> <block>{
<macro><name>STATE_CLEARFLAGS</name><argument_list>()</argument_list></macro>
<macro><name>STATE_SETG0</name><argument_list>(<argument>CHARSET_ASCII</argument>)</argument_list></macro>
<macro><name>STATE_SETG1</name><argument_list>(<argument>CHARSET_ASCII</argument>)</argument_list></macro>
<return>return <expr>0</expr>;</return>
}</block>
<macro><name>ENCODER_RESET</name><argument_list>(<argument>iso2022</argument>)</argument_list></macro> <block>{
<if>if <condition>(<expr><call><name>STATE_GETFLAG</name><argument_list>(<argument><expr><name>F_SHIFTED</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<macro><name>WRITE1</name><argument_list>(<argument>SI</argument>)</argument_list></macro>
<macro><name>NEXT_OUT</name><argument_list>(<argument>1</argument>)</argument_list></macro>
<macro><name>STATE_CLEARFLAG</name><argument_list>(<argument>F_SHIFTED</argument>)</argument_list></macro>
}</block></then></if>
<if>if <condition>(<expr><name>STATE_G0</name> != <name>CHARSET_ASCII</name></expr>)</condition><then> <block>{
<macro><name>WRITE3</name><argument_list>(<argument>ESC</argument>, <argument>'('</argument>, <argument>'B'</argument>)</argument_list></macro>
<macro><name>NEXT_OUT</name><argument_list>(<argument>3</argument>)</argument_list></macro>
<macro><name>STATE_SETG0</name><argument_list>(<argument>CHARSET_ASCII</argument>)</argument_list></macro>
}</block></then></if>
<return>return <expr>0</expr>;</return>
}</block>
<macro><name>ENCODER</name><argument_list>(<argument>iso2022</argument>)</argument_list></macro> <block>{
<while>while <condition>(<expr><name>inleft</name> &gt; 0</expr>)</condition> <block>{
<decl_stmt><decl><type><specifier>const</specifier> struct <name>iso2022_designation</name> *</type><name>dsg</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>DBCHAR</name></type> <name>encoded</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ucs4_t</name></type> <name>c</name> <init>= <expr>**<name>inbuf</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>insize</name></decl>;</decl_stmt>
<if>if <condition>(<expr><name>c</name> &lt; 0x80</expr>)</condition><then> <block>{
<if>if <condition>(<expr><name>STATE_G0</name> != <name>CHARSET_ASCII</name></expr>)</condition><then> <block>{
<macro><name>WRITE3</name><argument_list>(<argument>ESC</argument>, <argument>'('</argument>, <argument>'B'</argument>)</argument_list></macro>
<macro><name>STATE_SETG0</name><argument_list>(<argument>CHARSET_ASCII</argument>)</argument_list></macro>
<macro><name>NEXT_OUT</name><argument_list>(<argument>3</argument>)</argument_list></macro>
}</block></then></if>
<if>if <condition>(<expr><call><name>STATE_GETFLAG</name><argument_list>(<argument><expr><name>F_SHIFTED</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<macro><name>WRITE1</name><argument_list>(<argument>SI</argument>)</argument_list></macro>
<macro><name>STATE_CLEARFLAG</name><argument_list>(<argument>F_SHIFTED</argument>)</argument_list></macro>
<macro><name>NEXT_OUT</name><argument_list>(<argument>1</argument>)</argument_list></macro>
}</block></then></if>
<macro><name>WRITE1</name><argument_list>(<argument>(unsigned char)c</argument>)</argument_list></macro>
<macro><name>NEXT</name><argument_list>(<argument>1</argument>, <argument>1</argument>)</argument_list></macro>
<continue>continue;</continue>
}</block></then></if>
<macro><name>DECODE_SURROGATE</name><argument_list>(<argument>c</argument>)</argument_list></macro>
<expr_stmt><expr><name>insize</name> = <call><name>GET_INSIZE</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>encoded</name> = <name>MAP_UNMAPPABLE</name></expr>;</expr_stmt>
<for>for (<init><expr><name>dsg</name> = <name>CONFIG_DESIGNATIONS</name></expr>;</init> <condition><expr><name><name>dsg</name>-&gt;<name>mark</name></name></expr>;</condition> <incr><expr><name>dsg</name>++</expr></incr>) <block>{
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>length</name> <init>= <expr>1</expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>encoded</name> = <call><name><name>dsg</name>-&gt;<name>encoder</name></name><argument_list>(<argument><expr>&amp;<name>c</name></expr></argument>, <argument><expr>&amp;<name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>encoded</name> == <name>MAP_MULTIPLE_AVAIL</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr><name>inleft</name> &lt; 2</expr>)</condition><then> <block>{
<if>if <condition>(<expr>!(<name>flags</name> &amp; <name>MBENC_FLUSH</name>)</expr>)</condition><then>
<return>return <expr><name>MBERR_TOOFEW</name></expr>;</return></then></if>
<expr_stmt><expr><name>length</name> = -1</expr>;</expr_stmt>
}</block></then> <else>else
<expr_stmt><expr><name>length</name> = 2</expr>;</expr_stmt></else></if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>Py_UNICODE_SIZE</name> == 2</expr></cpp:if>
<if>if <condition>(<expr><name>length</name> == 2</expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>ucs4_t</name></type> <name><name>u4in</name><index>[<expr>2</expr>]</index></name></decl>;</decl_stmt>
<expr_stmt><expr><name><name>u4in</name><index>[<expr>0</expr>]</index></name> = (<name>ucs4_t</name>)<name>IN1</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>u4in</name><index>[<expr>1</expr>]</index></name> = (<name>ucs4_t</name>)<name>IN2</name></expr>;</expr_stmt>
<expr_stmt><expr><name>encoded</name> = <call><name><name>dsg</name>-&gt;<name>encoder</name></name><argument_list>(<argument><expr><name>u4in</name></expr></argument>, <argument><expr>&amp;<name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else
<expr_stmt><expr><name>encoded</name> = <call><name><name>dsg</name>-&gt;<name>encoder</name></name><argument_list>(<argument><expr>&amp;<name>c</name></expr></argument>, <argument><expr>&amp;<name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<expr_stmt><expr><name>encoded</name> = <call><name><name>dsg</name>-&gt;<name>encoder</name></name><argument_list>(<argument><expr>&amp;<name>c</name></expr></argument>, <argument><expr>&amp;<name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<if>if <condition>(<expr><name>encoded</name> != <name>MAP_UNMAPPABLE</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>insize</name> = <name>length</name></expr>;</expr_stmt>
<break>break;</break>
}</block></then></if>
}</block></then> <else>else <if>if <condition>(<expr><name>encoded</name> != <name>MAP_UNMAPPABLE</name></expr>)</condition><then>
<break>break;</break></then></if></else></if>
}</block></for>
<if>if <condition>(<expr>!<name><name>dsg</name>-&gt;<name>mark</name></name></expr>)</condition><then>
<return>return <expr>1</expr>;</return></then></if>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>dsg</name>-&gt;<name>width</name></name> == 1 || <name><name>dsg</name>-&gt;<name>width</name></name> == 2</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<switch>switch <condition>(<expr><name><name>dsg</name>-&gt;<name>plane</name></name></expr>)</condition> <block>{
<case>case <expr>0</expr>:
<if>if <condition>(<expr><call><name>STATE_GETFLAG</name><argument_list>(<argument><expr><name>F_SHIFTED</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<macro><name>WRITE1</name><argument_list>(<argument>SI</argument>)</argument_list></macro>
<macro><name>STATE_CLEARFLAG</name><argument_list>(<argument>F_SHIFTED</argument>)</argument_list></macro>
<macro><name>NEXT_OUT</name><argument_list>(<argument>1</argument>)</argument_list></macro>
}</block></then></if>
<if>if <condition>(<expr><name>STATE_G0</name> != <name><name>dsg</name>-&gt;<name>mark</name></name></expr>)</condition><then> <block>{
<if>if <condition>(<expr><name><name>dsg</name>-&gt;<name>width</name></name> == 1</expr>)</condition><then> <block>{
<macro><name>WRITE3</name><argument_list>(<argument>ESC</argument>, <argument>'('</argument>, <argument>ESCMARK(dsg-&gt;mark)</argument>)</argument_list></macro>
<macro><name>STATE_SETG0</name><argument_list>(<argument>dsg-&gt;mark</argument>)</argument_list></macro>
<macro><name>NEXT_OUT</name><argument_list>(<argument>3</argument>)</argument_list></macro>
}</block></then> <else>else <if>if <condition>(<expr><name><name>dsg</name>-&gt;<name>mark</name></name> == <name>CHARSET_JISX0208</name></expr>)</condition><then> <block>{
<macro><name>WRITE3</name><argument_list>(<argument>ESC</argument>, <argument>'$'</argument>, <argument>ESCMARK(dsg-&gt;mark)</argument>)</argument_list></macro>
<macro><name>STATE_SETG0</name><argument_list>(<argument>dsg-&gt;mark</argument>)</argument_list></macro>
<macro><name>NEXT_OUT</name><argument_list>(<argument>3</argument>)</argument_list></macro>
}</block></then> <else>else <block>{
<macro><name>WRITE4</name><argument_list>(<argument>ESC</argument>, <argument>'$'</argument>, <argument>'('</argument>,
<argument>ESCMARK(dsg-&gt;mark)</argument>)</argument_list></macro>
<macro><name>STATE_SETG0</name><argument_list>(<argument>dsg-&gt;mark</argument>)</argument_list></macro>
<macro><name>NEXT_OUT</name><argument_list>(<argument>4</argument>)</argument_list></macro>
}</block></else></if></else></if>
}</block></then></if>
<break>break;</break>
</case><case>case <expr>1</expr>:
<if>if <condition>(<expr><name>STATE_G1</name> != <name><name>dsg</name>-&gt;<name>mark</name></name></expr>)</condition><then> <block>{
<if>if <condition>(<expr><name><name>dsg</name>-&gt;<name>width</name></name> == 1</expr>)</condition><then> <block>{
<macro><name>WRITE3</name><argument_list>(<argument>ESC</argument>, <argument>')'</argument>, <argument>ESCMARK(dsg-&gt;mark)</argument>)</argument_list></macro>
<macro><name>STATE_SETG1</name><argument_list>(<argument>dsg-&gt;mark</argument>)</argument_list></macro>
<macro><name>NEXT_OUT</name><argument_list>(<argument>3</argument>)</argument_list></macro>
}</block></then> <else>else <block>{
<macro><name>WRITE4</name><argument_list>(<argument>ESC</argument>, <argument>'$'</argument>, <argument>')'</argument>,
<argument>ESCMARK(dsg-&gt;mark)</argument>)</argument_list></macro>
<macro><name>STATE_SETG1</name><argument_list>(<argument>dsg-&gt;mark</argument>)</argument_list></macro>
<macro><name>NEXT_OUT</name><argument_list>(<argument>4</argument>)</argument_list></macro>
}</block></else></if>
}</block></then></if>
<if>if <condition>(<expr>!<call><name>STATE_GETFLAG</name><argument_list>(<argument><expr><name>F_SHIFTED</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<macro><name>WRITE1</name><argument_list>(<argument>SO</argument>)</argument_list></macro>
<macro><name>STATE_SETFLAG</name><argument_list>(<argument>F_SHIFTED</argument>)</argument_list></macro>
<macro><name>NEXT_OUT</name><argument_list>(<argument>1</argument>)</argument_list></macro>
}</block></then></if>
<break>break;</break>
</case><default>default:
<return>return <expr><name>MBERR_INTERNAL</name></expr>;</return>
</default>}</block></switch>
<if>if <condition>(<expr><name><name>dsg</name>-&gt;<name>width</name></name> == 1</expr>)</condition><then> <block>{
<macro><name>WRITE1</name><argument_list>(<argument>(unsigned char)encoded</argument>)</argument_list></macro>
<macro><name>NEXT_OUT</name><argument_list>(<argument>1</argument>)</argument_list></macro>
}</block></then> <else>else <block>{
<macro><name>WRITE2</name><argument_list>(<argument>encoded &gt;&gt; 8</argument>, <argument>encoded &amp; 0xff</argument>)</argument_list></macro>
<macro><name>NEXT_OUT</name><argument_list>(<argument>2</argument>)</argument_list></macro>
}</block></else></if>
<macro><name>NEXT_IN</name><argument_list>(<argument>insize</argument>)</argument_list></macro>
}</block></while>
<return>return <expr>0</expr>;</return>
}</block>
<macro><name>DECODER_INIT</name><argument_list>(<argument>iso2022</argument>)</argument_list></macro> <block>{
<macro><name>STATE_CLEARFLAGS</name><argument_list>()</argument_list></macro>
<macro><name>STATE_SETG0</name><argument_list>(<argument>CHARSET_ASCII</argument>)</argument_list></macro>
<macro><name>STATE_SETG1</name><argument_list>(<argument>CHARSET_ASCII</argument>)</argument_list></macro>
<macro><name>STATE_SETG2</name><argument_list>(<argument>CHARSET_ASCII</argument>)</argument_list></macro>
<return>return <expr>0</expr>;</return>
}</block>
<macro><name>DECODER_RESET</name><argument_list>(<argument>iso2022</argument>)</argument_list></macro> <block>{
<macro><name>STATE_SETG0</name><argument_list>(<argument>CHARSET_ASCII</argument>)</argument_list></macro>
<macro><name>STATE_CLEARFLAG</name><argument_list>(<argument>F_SHIFTED</argument>)</argument_list></macro>
<return>return <expr>0</expr>;</return>
}</block>
<function><type><specifier>static</specifier> <name>Py_ssize_t</name></type>
<name>iso2022processesc</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>void</name> *</type><name>config</name></decl></param>, <param><decl><type><name>MultibyteCodec_State</name> *</type><name>state</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> **</type><name>inbuf</name></decl></param>, <param><decl><type><name>Py_ssize_t</name> *</type><name>inleft</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name>charset</name></decl>, <decl><type ref="prev"/><name>designation</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>esclen</name></decl>;</decl_stmt>
<for>for (<init><expr><name>i</name> = 1</expr>;</init> <condition><expr><name>i</name> &lt; <name>MAX_ESCSEQLEN</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
<if>if <condition>(<expr><name>i</name> &gt;= *<name>inleft</name></expr>)</condition><then>
<return>return <expr><name>MBERR_TOOFEW</name></expr>;</return></then></if>
<if>if <condition>(<expr><call><name>IS_ESCEND</name><argument_list>(<argument><expr>(*<name>inbuf</name>)<index>[<expr><name>i</name></expr>]</index></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><name>esclen</name> = <name>i</name> + 1</expr>;</expr_stmt>
<break>break;</break>
}</block></then> <else>else <if>if <condition>(<expr><call><name>CONFIG_ISSET</name><argument_list>(<argument><expr><name>USE_JISX0208_EXT</name></expr></argument>)</argument_list></call> &amp;&amp; <name>i</name>+1 &lt; *<name>inleft</name> &amp;&amp;
(*<name>inbuf</name>)<index>[<expr><name>i</name></expr>]</index> == '&amp;' &amp;&amp; (*<name>inbuf</name>)<index>[<expr><name>i</name>+1</expr>]</index> == '@'</expr>)</condition><then>
<expr_stmt><expr><name>i</name> += 2</expr>;</expr_stmt></then></if></else></if>
}</block></for>
<if>if <condition>(<expr><name>i</name> &gt;= <name>MAX_ESCSEQLEN</name></expr>)</condition><then>
<return>return <expr>1</expr>;</return></then></if>
<switch>switch <condition>(<expr><name>esclen</name></expr>)</condition> <block>{
<case>case <expr>3</expr>:
<if>if <condition>(<expr><name>IN2</name> == '$'</expr>)</condition><then> <block>{
<expr_stmt><expr><name>charset</name> = <name>IN3</name> | <name>CHARSET_DBCS</name></expr>;</expr_stmt>
<expr_stmt><expr><name>designation</name> = 0</expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr><name>charset</name> = <name>IN3</name></expr>;</expr_stmt>
<if>if <condition>(<expr><name>IN2</name> == '('</expr>)</condition><then> <expr_stmt><expr><name>designation</name> = 0</expr>;</expr_stmt></then>
<else>else <if>if <condition>(<expr><name>IN2</name> == ')'</expr>)</condition><then> <expr_stmt><expr><name>designation</name> = 1</expr>;</expr_stmt></then>
<else>else <if>if <condition>(<expr><call><name>CONFIG_ISSET</name><argument_list>(<argument><expr><name>USE_G2</name></expr></argument>)</argument_list></call> &amp;&amp; <name>IN2</name> == '.'</expr>)</condition><then>
<expr_stmt><expr><name>designation</name> = 2</expr>;</expr_stmt></then>
<else>else <return>return <expr>3</expr>;</return></else></if></else></if></else></if>
}</block></else></if>
<break>break;</break>
</case><case>case <expr>4</expr>:
<if>if <condition>(<expr><name>IN2</name> != '$'</expr>)</condition><then>
<return>return <expr>4</expr>;</return></then></if>
<expr_stmt><expr><name>charset</name> = <name>IN4</name> | <name>CHARSET_DBCS</name></expr>;</expr_stmt>
<if>if <condition>(<expr><name>IN3</name> == '('</expr>)</condition><then> <expr_stmt><expr><name>designation</name> = 0</expr>;</expr_stmt></then>
<else>else <if>if <condition>(<expr><name>IN3</name> == ')'</expr>)</condition><then> <expr_stmt><expr><name>designation</name> = 1</expr>;</expr_stmt></then>
<else>else <return>return <expr>4</expr>;</return></else></if></else></if>
<break>break;</break>
</case><case>case <expr>6</expr>:
<if>if <condition>(<expr><call><name>CONFIG_ISSET</name><argument_list>(<argument><expr><name>USE_JISX0208_EXT</name></expr></argument>)</argument_list></call> &amp;&amp;
(*<name>inbuf</name>)<index>[<expr>3</expr>]</index> == <name>ESC</name> &amp;&amp; (*<name>inbuf</name>)<index>[<expr>4</expr>]</index> == '$' &amp;&amp;
(*<name>inbuf</name>)<index>[<expr>5</expr>]</index> == 'B'</expr>)</condition><then> <block>{
<expr_stmt><expr><name>charset</name> = 'B' | <name>CHARSET_DBCS</name></expr>;</expr_stmt>
<expr_stmt><expr><name>designation</name> = 0</expr>;</expr_stmt>
}</block></then> <else>else
<return>return <expr>6</expr>;</return></else></if>
<break>break;</break>
</case><default>default:
<return>return <expr><name>esclen</name></expr>;</return>
</default>}</block></switch>
<if>if <condition>(<expr><name>charset</name> != <name>CHARSET_ASCII</name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><specifier>const</specifier> struct <name>iso2022_designation</name> *</type><name>dsg</name></decl>;</decl_stmt>
<for>for (<init><expr><name>dsg</name> = <name>CONFIG_DESIGNATIONS</name></expr>;</init> <condition><expr><name><name>dsg</name>-&gt;<name>mark</name></name></expr>;</condition> <incr><expr><name>dsg</name>++</expr></incr>)
<if>if <condition>(<expr><name><name>dsg</name>-&gt;<name>mark</name></name> == <name>charset</name></expr>)</condition><then>
<break>break;</break></then></if></for>
<if>if <condition>(<expr>!<name><name>dsg</name>-&gt;<name>mark</name></name></expr>)</condition><then>
<return>return <expr><name>esclen</name></expr>;</return></then></if>
}</block></then></if>
<expr_stmt><expr><call><name>STATE_SETG</name><argument_list>(<argument><expr><name>designation</name></expr></argument>, <argument><expr><name>charset</name></expr></argument>)</argument_list></call>
*<name>inleft</name> -= <name>esclen</name></expr>;</expr_stmt>
<expr_stmt><expr>(*<name>inbuf</name>) += <name>esclen</name></expr>;</expr_stmt>
<return>return <expr>0</expr>;</return>
}</block></function>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ISO8859_7_DECODE</name><parameter_list>(<param><type><name>c</name></type></param>, <param><type><name>assi</name></type></param>)</parameter_list></cpp:macro> <cpp:value>if ((c) &lt; 0xa0) (assi) = (c); else if ((c) &lt; 0xc0 &amp;&amp; (0x288f3bc9L &amp; (1L &lt;&lt; ((c)-0xa0)))) (assi) = (c); else if ((c) &gt;= 0xb4 &amp;&amp; (c) &lt;= 0xfe &amp;&amp; ((c) &gt;= 0xd4 || (0xbffffd77L &amp; (1L &lt;&lt; ((c)-0xb4))))) (assi) = 0x02d0 + (c); else if ((c) == 0xa1) (assi) = 0x2018; else if ((c) == 0xa2) (assi) = 0x2019; else if ((c) == 0xaf) (assi) = 0x2015;</cpp:value></cpp:define>
<function><type><specifier>static</specifier> <name>Py_ssize_t</name></type>
<name>iso2022processg2</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>void</name> *</type><name>config</name></decl></param>, <param><decl><type><name>MultibyteCodec_State</name> *</type><name>state</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> **</type><name>inbuf</name></decl></param>, <param><decl><type><name>Py_ssize_t</name> *</type><name>inleft</name></decl></param>,
<param><decl><type><name>Py_UNICODE</name> **</type><name>outbuf</name></decl></param>, <param><decl><type><name>Py_ssize_t</name> *</type><name>outleft</name></decl></param>)</parameter_list> <block>{
<if>if <condition>(<expr><name>STATE_G2</name> == <name>CHARSET_ISO8859_1</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr><name>IN3</name> &lt; 0x80</expr>)</condition><then>
<macro><name>OUT1</name><argument_list>(<argument>IN3 + 0x80</argument>)</argument_list></macro></then>
<else>else
<return>return <expr>3</expr>;</return></else></if>
}</block></then> <else>else <if>if <condition>(<expr><name>STATE_G2</name> == <name>CHARSET_ISO8859_7</name></expr>)</condition><then> <block>{
<macro><name>ISO8859_7_DECODE</name><argument_list>(<argument>IN3 ^ 0x80</argument>, <argument>**outbuf</argument>)</argument_list></macro>
<else>else <return>return <expr>3</expr>;</return></else>
}</block></then> <else>else <if>if <condition>(<expr><name>STATE_G2</name> == <name>CHARSET_ASCII</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr><name>IN3</name> &amp; 0x80</expr>)</condition><then> <return>return <expr>3</expr>;</return></then>
<else>else <expr_stmt><expr>**<name>outbuf</name> = <name>IN3</name></expr>;</expr_stmt></else></if>
}</block></then> <else>else
<return>return <expr><name>MBERR_INTERNAL</name></expr>;</return></else></if></else></if></else></if>
<expr_stmt><expr>(*<name>inbuf</name>) += 3</expr>;</expr_stmt>
<expr_stmt><expr>*<name>inleft</name> -= 3</expr>;</expr_stmt>
<expr_stmt><expr>(*<name>outbuf</name>) += 1</expr>;</expr_stmt>
<expr_stmt><expr>*<name>outleft</name> -= 1</expr>;</expr_stmt>
<return>return <expr>0</expr>;</return>
}</block></function>
<macro><name>DECODER</name><argument_list>(<argument>iso2022</argument>)</argument_list></macro> <block>{
<decl_stmt><decl><type><specifier>const</specifier> struct <name>iso2022_designation</name> *</type><name>dsgcache</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<while>while <condition>(<expr><name>inleft</name> &gt; 0</expr>)</condition> <block>{
<decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name>c</name> <init>= <expr><name>IN1</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>err</name></decl>;</decl_stmt>
<if>if <condition>(<expr><call><name>STATE_GETFLAG</name><argument_list>(<argument><expr><name>F_ESCTHROUGHOUT</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<macro><name>WRITE1</name><argument_list>(<argument>c</argument>)</argument_list></macro>
<macro><name>NEXT</name><argument_list>(<argument>1</argument>, <argument>1</argument>)</argument_list></macro>
<if>if <condition>(<expr><call><name>IS_ESCEND</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<macro><name>STATE_CLEARFLAG</name><argument_list>(<argument>F_ESCTHROUGHOUT</argument>)</argument_list></macro>
}</block></then></if>
<continue>continue;</continue>
}</block></then></if>
<switch>switch <condition>(<expr><name>c</name></expr>)</condition> <block>{
<case>case <expr><name>ESC</name></expr>:
<macro><name>REQUIRE_INBUF</name><argument_list>(<argument>2</argument>)</argument_list></macro>
<if>if <condition>(<expr><call><name>IS_ISO2022ESC</name><argument_list>(<argument><expr><name>IN2</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><name>err</name> = <call><name>iso2022processesc</name><argument_list>(<argument><expr><name>config</name></expr></argument>, <argument><expr><name>state</name></expr></argument>,
<argument><expr><name>inbuf</name></expr></argument>, <argument><expr>&amp;<name>inleft</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>err</name> != 0</expr>)</condition><then>
<return>return <expr><name>err</name></expr>;</return></then></if>
}</block></then> <else>else <if>if <condition>(<expr><call><name>CONFIG_ISSET</name><argument_list>(<argument><expr><name>USE_G2</name></expr></argument>)</argument_list></call> &amp;&amp; <name>IN2</name> == 'N'</expr>)</condition><then> <block>{
<macro><name>REQUIRE_INBUF</name><argument_list>(<argument>3</argument>)</argument_list></macro>
<expr_stmt><expr><name>err</name> = <call><name>iso2022processg2</name><argument_list>(<argument><expr><name>config</name></expr></argument>, <argument><expr><name>state</name></expr></argument>,
<argument><expr><name>inbuf</name></expr></argument>, <argument><expr>&amp;<name>inleft</name></expr></argument>, <argument><expr><name>outbuf</name></expr></argument>, <argument><expr>&amp;<name>outleft</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>err</name> != 0</expr>)</condition><then>
<return>return <expr><name>err</name></expr>;</return></then></if>
}</block></then> <else>else <block>{
<macro><name>WRITE1</name><argument_list>(<argument>ESC</argument>)</argument_list></macro>
<macro><name>STATE_SETFLAG</name><argument_list>(<argument>F_ESCTHROUGHOUT</argument>)</argument_list></macro>
<macro><name>NEXT</name><argument_list>(<argument>1</argument>, <argument>1</argument>)</argument_list></macro>
}</block></else></if></else></if>
<break>break;</break>
</case><case>case <expr><name>SI</name></expr>:
<if>if <condition>(<expr><call><name>CONFIG_ISSET</name><argument_list>(<argument><expr><name>NO_SHIFT</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<goto>goto <name>bypass</name>;</goto></then></if>
<macro><name>STATE_CLEARFLAG</name><argument_list>(<argument>F_SHIFTED</argument>)</argument_list></macro>
<macro><name>NEXT_IN</name><argument_list>(<argument>1</argument>)</argument_list></macro>
<break>break;</break>
</case><case>case <expr><name>SO</name></expr>:
<if>if <condition>(<expr><call><name>CONFIG_ISSET</name><argument_list>(<argument><expr><name>NO_SHIFT</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<goto>goto <name>bypass</name>;</goto></then></if>
<macro><name>STATE_SETFLAG</name><argument_list>(<argument>F_SHIFTED</argument>)</argument_list></macro>
<macro><name>NEXT_IN</name><argument_list>(<argument>1</argument>)</argument_list></macro>
<break>break;</break>
</case><case>case <expr><name>LF</name></expr>:
<macro><name>STATE_CLEARFLAG</name><argument_list>(<argument>F_SHIFTED</argument>)</argument_list></macro>
<macro><name>WRITE1</name><argument_list>(<argument>LF</argument>)</argument_list></macro>
<macro><name>NEXT</name><argument_list>(<argument>1</argument>, <argument>1</argument>)</argument_list></macro>
<break>break;</break>
</case><default>default:
<if>if <condition>(<expr><name>c</name> &lt; 0x20</expr>)</condition><then>
<goto>goto <name>bypass</name>;</goto></then>
<else>else <if>if <condition>(<expr><name>c</name> &gt;= 0x80</expr>)</condition><then>
<return>return <expr>1</expr>;</return></then>
<else>else <block>{
<decl_stmt><decl><type><specifier>const</specifier> struct <name>iso2022_designation</name> *</type><name>dsg</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name>charset</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ucs4_t</name></type> <name>decoded</name></decl>;</decl_stmt>
<if>if <condition>(<expr><call><name>STATE_GETFLAG</name><argument_list>(<argument><expr><name>F_SHIFTED</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<expr_stmt><expr><name>charset</name> = <name>STATE_G1</name></expr>;</expr_stmt></then>
<else>else
<expr_stmt><expr><name>charset</name> = <name>STATE_G0</name></expr>;</expr_stmt></else></if>
<if>if <condition>(<expr><name>charset</name> == <name>CHARSET_ASCII</name></expr>)</condition><then> <block>{
<label><name>bypass</name>:</label>
<macro><name>WRITE1</name><argument_list>(<argument>c</argument>)</argument_list></macro>
<macro><name>NEXT</name><argument_list>(<argument>1</argument>, <argument>1</argument>)</argument_list></macro>
<break>break;</break>
}</block></then></if>
<if>if <condition>(<expr><name>dsgcache</name> != <name>NULL</name> &amp;&amp;
<name><name>dsgcache</name>-&gt;<name>mark</name></name> == <name>charset</name></expr>)</condition><then>
<expr_stmt><expr><name>dsg</name> = <name>dsgcache</name></expr>;</expr_stmt></then>
<else>else <block>{
<for>for (<init><expr><name>dsg</name> = <name>CONFIG_DESIGNATIONS</name></expr>;</init>
<condition><expr><name><name>dsg</name>-&gt;<name>mark</name></name> != <name>charset</name>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>Py_DEBUG</name></expr></argument>)</argument_list></call></expr></cpp:if>
&amp;&amp; <name><name>dsg</name>-&gt;<name>mark</name></name> != '\0'</expr>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
;</condition> <incr><expr><name>dsg</name>++</expr></incr>)
<empty_stmt>;</empty_stmt></for>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>dsg</name>-&gt;<name>mark</name></name> != '\0'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>dsgcache</name> = <name>dsg</name></expr>;</expr_stmt>
}</block></else></if>
<macro><name>REQUIRE_INBUF</name><argument_list>(<argument>dsg-&gt;width</argument>)</argument_list></macro>
<expr_stmt><expr><name>decoded</name> = <call><name><name>dsg</name>-&gt;<name>decoder</name></name><argument_list>(<argument><expr>*<name>inbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>decoded</name> == <name>MAP_UNMAPPABLE</name></expr>)</condition><then>
<return>return <expr><name><name>dsg</name>-&gt;<name>width</name></name></expr>;</return></then></if>
<if>if <condition>(<expr><name>decoded</name> &lt; 0x10000</expr>)</condition><then> <block>{
<macro><name>WRITE1</name><argument_list>(<argument>decoded</argument>)</argument_list></macro>
<macro><name>NEXT_OUT</name><argument_list>(<argument>1</argument>)</argument_list></macro>
}</block></then> <else>else <if>if <condition>(<expr><name>decoded</name> &lt; 0x30000</expr>)</condition><then> <block>{
<macro><name>WRITEUCS4</name><argument_list>(<argument>decoded</argument>)</argument_list></macro>
}</block></then> <else>else <block>{
<macro><name>WRITE2</name><argument_list>(<argument>decoded &gt;&gt; 16</argument>, <argument>decoded &amp; 0xffff</argument>)</argument_list></macro>
<macro><name>NEXT_OUT</name><argument_list>(<argument>2</argument>)</argument_list></macro>
}</block></else></if></else></if>
<macro><name>NEXT_IN</name><argument_list>(<argument>dsg-&gt;width</argument>)</argument_list></macro>
}</block></else></if></else></if>
<break>break;</break>
</default>}</block></switch>
}</block></while>
<return>return <expr>0</expr>;</return>
}</block>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ENCMAP</name><parameter_list>(<param><type><name>enc</name></type></param>)</parameter_list></cpp:macro> <cpp:value>static const encode_map *enc##_encmap = NULL;</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DECMAP</name><parameter_list>(<param><type><name>enc</name></type></param>)</parameter_list></cpp:macro> <cpp:value>static const decode_map *enc##_decmap = NULL;</cpp:value></cpp:define>
<macro><name>ENCMAP</name><argument_list>(<argument>cp949</argument>)</argument_list></macro>
<macro><name>DECMAP</name><argument_list>(<argument>ksx1001</argument>)</argument_list></macro>
<macro><name>ENCMAP</name><argument_list>(<argument>jisxcommon</argument>)</argument_list></macro>
<macro><name>DECMAP</name><argument_list>(<argument>jisx0208</argument>)</argument_list></macro>
<macro><name>DECMAP</name><argument_list>(<argument>jisx0212</argument>)</argument_list></macro>
<macro><name>ENCMAP</name><argument_list>(<argument>jisx0213_bmp</argument>)</argument_list></macro>
<macro><name>DECMAP</name><argument_list>(<argument>jisx0213_1_bmp</argument>)</argument_list></macro>
<macro><name>DECMAP</name><argument_list>(<argument>jisx0213_2_bmp</argument>)</argument_list></macro>
<macro><name>ENCMAP</name><argument_list>(<argument>jisx0213_emp</argument>)</argument_list></macro>
<macro><name>DECMAP</name><argument_list>(<argument>jisx0213_1_emp</argument>)</argument_list></macro>
<macro><name>DECMAP</name><argument_list>(<argument>jisx0213_2_emp</argument>)</argument_list></macro>
<macro><name>ENCMAP</name><argument_list>(<argument>gbcommon</argument>)</argument_list></macro>
<macro><name>DECMAP</name><argument_list>(<argument>gb2312</argument>)</argument_list></macro>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>ksx1001_init</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>initialized</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr>!<name>initialized</name> &amp;&amp; (
<call><name>IMPORT_MAP</name><argument_list>(<argument><expr><name>kr</name></expr></argument>, <argument><expr><name>cp949</name></expr></argument>, <argument><expr>&amp;<name>cp949_encmap</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call> ||
<call><name>IMPORT_MAP</name><argument_list>(<argument><expr><name>kr</name></expr></argument>, <argument><expr><name>ksx1001</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr>&amp;<name>ksx1001_decmap</name></expr></argument>)</argument_list></call>)</expr>)</condition><then>
<return>return <expr>-1</expr>;</return></then></if>
<expr_stmt><expr><name>initialized</name> = 1</expr>;</expr_stmt>
<return>return <expr>0</expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>ucs4_t</name></type>
<name>ksx1001_decoder</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> *</type><name>data</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>ucs4_t</name></type> <name>u</name></decl>;</decl_stmt>
<macro><name>TRYMAP_DEC</name><argument_list>(<argument>ksx1001</argument>, <argument>u</argument>, <argument>data[0]</argument>, <argument>data[1]</argument>)</argument_list></macro>
<return>return <expr><name>u</name></expr>;</return>
<else>else
<return>return <expr><name>MAP_UNMAPPABLE</name></expr>;</return></else>
}</block></function>
<function><type><specifier>static</specifier> <name>DBCHAR</name></type>
<name>ksx1001_encoder</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>ucs4_t</name> *</type><name>data</name></decl></param>, <param><decl><type><name>Py_ssize_t</name> *</type><name>length</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>DBCHAR</name></type> <name>coded</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr>*<name>length</name> == 1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>*<name>data</name> &lt; 0x10000</expr>)</condition><then> <block>{
<macro><name>TRYMAP_ENC</name><argument_list>(<argument>cp949</argument>, <argument>coded</argument>, <argument>*data</argument>)</argument_list></macro>
<if>if <condition>(<expr>!(<name>coded</name> &amp; 0x8000)</expr>)</condition><then>
<return>return <expr><name>coded</name></expr>;</return></then></if>
}</block></then></if>
<return>return <expr><name>MAP_UNMAPPABLE</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>jisx0208_init</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>initialized</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr>!<name>initialized</name> &amp;&amp; (
<call><name>IMPORT_MAP</name><argument_list>(<argument><expr><name>jp</name></expr></argument>, <argument><expr><name>jisxcommon</name></expr></argument>, <argument><expr>&amp;<name>jisxcommon_encmap</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call> ||
<call><name>IMPORT_MAP</name><argument_list>(<argument><expr><name>jp</name></expr></argument>, <argument><expr><name>jisx0208</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr>&amp;<name>jisx0208_decmap</name></expr></argument>)</argument_list></call>)</expr>)</condition><then>
<return>return <expr>-1</expr>;</return></then></if>
<expr_stmt><expr><name>initialized</name> = 1</expr>;</expr_stmt>
<return>return <expr>0</expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>ucs4_t</name></type>
<name>jisx0208_decoder</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> *</type><name>data</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>ucs4_t</name></type> <name>u</name></decl>;</decl_stmt>
<if>if <condition>(<expr><name><name>data</name><index>[<expr>0</expr>]</index></name> == 0x21 &amp;&amp; <name><name>data</name><index>[<expr>1</expr>]</index></name> == 0x40</expr>)</condition><then>
<return>return <expr>0xff3c</expr>;</return></then>
<else>else <macro><name>TRYMAP_DEC</name><argument_list>(<argument>jisx0208</argument>, <argument>u</argument>, <argument>data[0]</argument>, <argument>data[1]</argument>)</argument_list></macro>
<return>return <expr><name>u</name></expr>;</return></else></if>
<else>else
<return>return <expr><name>MAP_UNMAPPABLE</name></expr>;</return></else>
}</block></function>
<function><type><specifier>static</specifier> <name>DBCHAR</name></type>
<name>jisx0208_encoder</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>ucs4_t</name> *</type><name>data</name></decl></param>, <param><decl><type><name>Py_ssize_t</name> *</type><name>length</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>DBCHAR</name></type> <name>coded</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr>*<name>length</name> == 1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>*<name>data</name> &lt; 0x10000</expr>)</condition><then> <block>{
<if>if <condition>(<expr>*<name>data</name> == 0xff3c</expr>)</condition><then>
<return>return <expr>0x2140</expr>;</return></then>
<else>else <macro><name>TRYMAP_ENC</name><argument_list>(<argument>jisxcommon</argument>, <argument>coded</argument>, <argument>*data</argument>)</argument_list></macro> <block>{
<if>if <condition>(<expr>!(<name>coded</name> &amp; 0x8000)</expr>)</condition><then>
<return>return <expr><name>coded</name></expr>;</return></then></if>
}</block></else></if>
}</block></then></if>
<return>return <expr><name>MAP_UNMAPPABLE</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>jisx0212_init</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>initialized</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr>!<name>initialized</name> &amp;&amp; (
<call><name>IMPORT_MAP</name><argument_list>(<argument><expr><name>jp</name></expr></argument>, <argument><expr><name>jisxcommon</name></expr></argument>, <argument><expr>&amp;<name>jisxcommon_encmap</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call> ||
<call><name>IMPORT_MAP</name><argument_list>(<argument><expr><name>jp</name></expr></argument>, <argument><expr><name>jisx0212</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr>&amp;<name>jisx0212_decmap</name></expr></argument>)</argument_list></call>)</expr>)</condition><then>
<return>return <expr>-1</expr>;</return></then></if>
<expr_stmt><expr><name>initialized</name> = 1</expr>;</expr_stmt>
<return>return <expr>0</expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>ucs4_t</name></type>
<name>jisx0212_decoder</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> *</type><name>data</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>ucs4_t</name></type> <name>u</name></decl>;</decl_stmt>
<macro><name>TRYMAP_DEC</name><argument_list>(<argument>jisx0212</argument>, <argument>u</argument>, <argument>data[0]</argument>, <argument>data[1]</argument>)</argument_list></macro>
<return>return <expr><name>u</name></expr>;</return>
<else>else
<return>return <expr><name>MAP_UNMAPPABLE</name></expr>;</return></else>
}</block></function>
<function><type><specifier>static</specifier> <name>DBCHAR</name></type>
<name>jisx0212_encoder</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>ucs4_t</name> *</type><name>data</name></decl></param>, <param><decl><type><name>Py_ssize_t</name> *</type><name>length</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>DBCHAR</name></type> <name>coded</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr>*<name>length</name> == 1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>*<name>data</name> &lt; 0x10000</expr>)</condition><then> <block>{
<macro><name>TRYMAP_ENC</name><argument_list>(<argument>jisxcommon</argument>, <argument>coded</argument>, <argument>*data</argument>)</argument_list></macro> <block>{
<if>if <condition>(<expr><name>coded</name> &amp; 0x8000</expr>)</condition><then>
<return>return <expr><name>coded</name> &amp; 0x7fff</expr>;</return></then></if>
}</block>
}</block></then></if>
<return>return <expr><name>MAP_UNMAPPABLE</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>jisx0213_init</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>initialized</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr>!<name>initialized</name> &amp;&amp; (
<call><name>jisx0208_init</name><argument_list>()</argument_list></call> ||
<call><name>IMPORT_MAP</name><argument_list>(<argument><expr><name>jp</name></expr></argument>, <argument><expr><name>jisx0213_bmp</name></expr></argument>,
<argument><expr>&amp;<name>jisx0213_bmp_encmap</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call> ||
<call><name>IMPORT_MAP</name><argument_list>(<argument><expr><name>jp</name></expr></argument>, <argument><expr><name>jisx0213_1_bmp</name></expr></argument>,
<argument><expr><name>NULL</name></expr></argument>, <argument><expr>&amp;<name>jisx0213_1_bmp_decmap</name></expr></argument>)</argument_list></call> ||
<call><name>IMPORT_MAP</name><argument_list>(<argument><expr><name>jp</name></expr></argument>, <argument><expr><name>jisx0213_2_bmp</name></expr></argument>,
<argument><expr><name>NULL</name></expr></argument>, <argument><expr>&amp;<name>jisx0213_2_bmp_decmap</name></expr></argument>)</argument_list></call> ||
<call><name>IMPORT_MAP</name><argument_list>(<argument><expr><name>jp</name></expr></argument>, <argument><expr><name>jisx0213_emp</name></expr></argument>,
<argument><expr>&amp;<name>jisx0213_emp_encmap</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call> ||
<call><name>IMPORT_MAP</name><argument_list>(<argument><expr><name>jp</name></expr></argument>, <argument><expr><name>jisx0213_1_emp</name></expr></argument>,
<argument><expr><name>NULL</name></expr></argument>, <argument><expr>&amp;<name>jisx0213_1_emp_decmap</name></expr></argument>)</argument_list></call> ||
<call><name>IMPORT_MAP</name><argument_list>(<argument><expr><name>jp</name></expr></argument>, <argument><expr><name>jisx0213_2_emp</name></expr></argument>,
<argument><expr><name>NULL</name></expr></argument>, <argument><expr>&amp;<name>jisx0213_2_emp_decmap</name></expr></argument>)</argument_list></call> ||
<call><name>IMPORT_MAP</name><argument_list>(<argument><expr><name>jp</name></expr></argument>, <argument><expr><name>jisx0213_pair</name></expr></argument>, <argument><expr>&amp;<name>jisx0213_pair_encmap</name></expr></argument>,
<argument><expr>&amp;<name>jisx0213_pair_decmap</name></expr></argument>)</argument_list></call>)</expr>)</condition><then>
<return>return <expr>-1</expr>;</return></then></if>
<expr_stmt><expr><name>initialized</name> = 1</expr>;</expr_stmt>
<return>return <expr>0</expr>;</return>
}</block></function>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>config</name></cpp:macro> <cpp:value>((void *)2000)</cpp:value></cpp:define>
<function><type><specifier>static</specifier> <name>ucs4_t</name></type>
<name>jisx0213_2000_1_decoder</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> *</type><name>data</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>ucs4_t</name></type> <name>u</name></decl>;</decl_stmt>
<macro><name>EMULATE_JISX0213_2000_DECODE_PLANE1</name><argument_list>(<argument>u</argument>, <argument>data[0]</argument>, <argument>data[1]</argument>)</argument_list></macro>
<else>else <if>if <condition>(<expr><name><name>data</name><index>[<expr>0</expr>]</index></name> == 0x21 &amp;&amp; <name><name>data</name><index>[<expr>1</expr>]</index></name> == 0x40</expr>)</condition><then>
<return>return <expr>0xff3c</expr>;</return></then>
<else>else <expr_stmt><expr><call><name>TRYMAP_DEC</name><argument_list>(<argument><expr><name>jisx0208</name></expr></argument>, <argument><expr><name>u</name></expr></argument>, <argument><expr><name><name>data</name><index>[<expr>0</expr>]</index></name></expr></argument>, <argument><expr><name><name>data</name><index>[<expr>1</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if></else>
<else>else <expr_stmt><expr><call><name>TRYMAP_DEC</name><argument_list>(<argument><expr><name>jisx0213_1_bmp</name></expr></argument>, <argument><expr><name>u</name></expr></argument>, <argument><expr><name><name>data</name><index>[<expr>0</expr>]</index></name></expr></argument>, <argument><expr><name><name>data</name><index>[<expr>1</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else>
<else>else <macro><name>TRYMAP_DEC</name><argument_list>(<argument>jisx0213_1_emp</argument>, <argument>u</argument>, <argument>data[0]</argument>, <argument>data[1]</argument>)</argument_list></macro>
<expr_stmt><expr><name>u</name> |= 0x20000</expr>;</expr_stmt></else>
<else>else <expr_stmt><expr><call><name>TRYMAP_DEC</name><argument_list>(<argument><expr><name>jisx0213_pair</name></expr></argument>, <argument><expr><name>u</name></expr></argument>, <argument><expr><name><name>data</name><index>[<expr>0</expr>]</index></name></expr></argument>, <argument><expr><name><name>data</name><index>[<expr>1</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else>
<else>else
<return>return <expr><name>MAP_UNMAPPABLE</name></expr>;</return></else>
<return>return <expr><name>u</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>ucs4_t</name></type>
<name>jisx0213_2000_2_decoder</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> *</type><name>data</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>ucs4_t</name></type> <name>u</name></decl>;</decl_stmt>
<macro><name>EMULATE_JISX0213_2000_DECODE_PLANE2</name><argument_list>(<argument>u</argument>, <argument>data[0]</argument>, <argument>data[1]</argument>)</argument_list></macro>
<expr_stmt><expr><call><name>TRYMAP_DEC</name><argument_list>(<argument><expr><name>jisx0213_2_bmp</name></expr></argument>, <argument><expr><name>u</name></expr></argument>, <argument><expr><name><name>data</name><index>[<expr>0</expr>]</index></name></expr></argument>, <argument><expr><name><name>data</name><index>[<expr>1</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<else>else <macro><name>TRYMAP_DEC</name><argument_list>(<argument>jisx0213_2_emp</argument>, <argument>u</argument>, <argument>data[0]</argument>, <argument>data[1]</argument>)</argument_list></macro>
<expr_stmt><expr><name>u</name> |= 0x20000</expr>;</expr_stmt></else>
<else>else
<return>return <expr><name>MAP_UNMAPPABLE</name></expr>;</return></else>
<return>return <expr><name>u</name></expr>;</return>
}</block></function>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>config</name></cpp:undef>
<function><type><specifier>static</specifier> <name>ucs4_t</name></type>
<name>jisx0213_2004_1_decoder</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> *</type><name>data</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>ucs4_t</name></type> <name>u</name></decl>;</decl_stmt>
<if>if <condition>(<expr><name><name>data</name><index>[<expr>0</expr>]</index></name> == 0x21 &amp;&amp; <name><name>data</name><index>[<expr>1</expr>]</index></name> == 0x40</expr>)</condition><then>
<return>return <expr>0xff3c</expr>;</return></then>
<else>else <expr_stmt><expr><call><name>TRYMAP_DEC</name><argument_list>(<argument><expr><name>jisx0208</name></expr></argument>, <argument><expr><name>u</name></expr></argument>, <argument><expr><name><name>data</name><index>[<expr>0</expr>]</index></name></expr></argument>, <argument><expr><name><name>data</name><index>[<expr>1</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
<else>else <expr_stmt><expr><call><name>TRYMAP_DEC</name><argument_list>(<argument><expr><name>jisx0213_1_bmp</name></expr></argument>, <argument><expr><name>u</name></expr></argument>, <argument><expr><name><name>data</name><index>[<expr>0</expr>]</index></name></expr></argument>, <argument><expr><name><name>data</name><index>[<expr>1</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else>
<else>else <macro><name>TRYMAP_DEC</name><argument_list>(<argument>jisx0213_1_emp</argument>, <argument>u</argument>, <argument>data[0]</argument>, <argument>data[1]</argument>)</argument_list></macro>
<expr_stmt><expr><name>u</name> |= 0x20000</expr>;</expr_stmt></else>
<else>else <expr_stmt><expr><call><name>TRYMAP_DEC</name><argument_list>(<argument><expr><name>jisx0213_pair</name></expr></argument>, <argument><expr><name>u</name></expr></argument>, <argument><expr><name><name>data</name><index>[<expr>0</expr>]</index></name></expr></argument>, <argument><expr><name><name>data</name><index>[<expr>1</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else>
<else>else
<return>return <expr><name>MAP_UNMAPPABLE</name></expr>;</return></else>
<return>return <expr><name>u</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>ucs4_t</name></type>
<name>jisx0213_2004_2_decoder</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> *</type><name>data</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>ucs4_t</name></type> <name>u</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>TRYMAP_DEC</name><argument_list>(<argument><expr><name>jisx0213_2_bmp</name></expr></argument>, <argument><expr><name>u</name></expr></argument>, <argument><expr><name><name>data</name><index>[<expr>0</expr>]</index></name></expr></argument>, <argument><expr><name><name>data</name><index>[<expr>1</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<else>else <macro><name>TRYMAP_DEC</name><argument_list>(<argument>jisx0213_2_emp</argument>, <argument>u</argument>, <argument>data[0]</argument>, <argument>data[1]</argument>)</argument_list></macro>
<expr_stmt><expr><name>u</name> |= 0x20000</expr>;</expr_stmt></else>
<else>else
<return>return <expr><name>MAP_UNMAPPABLE</name></expr>;</return></else>
<return>return <expr><name>u</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>DBCHAR</name></type>
<name>jisx0213_encoder</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>ucs4_t</name> *</type><name>data</name></decl></param>, <param><decl><type><name>Py_ssize_t</name> *</type><name>length</name></decl></param>, <param><decl><type><name>void</name> *</type><name>config</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>DBCHAR</name></type> <name>coded</name></decl>;</decl_stmt>
<switch>switch <condition>(<expr>*<name>length</name></expr>)</condition> <block>{
<case>case <expr>1</expr>:
<if>if <condition>(<expr>*<name>data</name> &gt;= 0x10000</expr>)</condition><then> <block>{
<if>if <condition>(<expr>(*<name>data</name>) &gt;&gt; 16 == 0x20000 &gt;&gt; 16</expr>)</condition><then> <block>{
<macro><name>EMULATE_JISX0213_2000_ENCODE_EMP</name><argument_list>(<argument>coded</argument>, <argument>*data</argument>)</argument_list></macro>
<else>else <macro><name>TRYMAP_ENC</name><argument_list>(<argument>jisx0213_emp</argument>, <argument>coded</argument>,
<argument>(*data) &amp; 0xffff</argument>)</argument_list></macro>
<return>return <expr><name>coded</name></expr>;</return></else>
}</block></then></if>
<return>return <expr><name>MAP_UNMAPPABLE</name></expr>;</return>
}</block></then></if>
<macro><name>EMULATE_JISX0213_2000_ENCODE_BMP</name><argument_list>(<argument>coded</argument>, <argument>*data</argument>)</argument_list></macro>
<else>else <macro><name>TRYMAP_ENC</name><argument_list>(<argument>jisx0213_bmp</argument>, <argument>coded</argument>, <argument>*data</argument>)</argument_list></macro> <block>{
<if>if <condition>(<expr><name>coded</name> == <name>MULTIC</name></expr>)</condition><then>
<return>return <expr><name>MAP_MULTIPLE_AVAIL</name></expr>;</return></then></if>
}</block></else>
<else>else <macro><name>TRYMAP_ENC</name><argument_list>(<argument>jisxcommon</argument>, <argument>coded</argument>, <argument>*data</argument>)</argument_list></macro> <block>{
<if>if <condition>(<expr><name>coded</name> &amp; 0x8000</expr>)</condition><then>
<return>return <expr><name>MAP_UNMAPPABLE</name></expr>;</return></then></if>
}</block></else>
<else>else
<return>return <expr><name>MAP_UNMAPPABLE</name></expr>;</return></else>
<return>return <expr><name>coded</name></expr>;</return>
</case><case>case <expr>2</expr>:
<expr_stmt><expr><name>coded</name> = <call><name>find_pairencmap</name><argument_list>(<argument><expr>(<name>ucs2_t</name>)<name><name>data</name><index>[<expr>0</expr>]</index></name></expr></argument>, <argument><expr>(<name>ucs2_t</name>)<name><name>data</name><index>[<expr>1</expr>]</index></name></expr></argument>,
<argument><expr><name>jisx0213_pair_encmap</name></expr></argument>, <argument><expr><name>JISX0213_ENCPAIRS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>coded</name> == <name>DBCINV</name></expr>)</condition><then> <block>{
<expr_stmt><expr>*<name>length</name> = 1</expr>;</expr_stmt>
<expr_stmt><expr><name>coded</name> = <call><name>find_pairencmap</name><argument_list>(<argument><expr>(<name>ucs2_t</name>)<name><name>data</name><index>[<expr>0</expr>]</index></name></expr></argument>, <argument><expr>0</expr></argument>,
<argument><expr><name>jisx0213_pair_encmap</name></expr></argument>, <argument><expr><name>JISX0213_ENCPAIRS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>coded</name> == <name>DBCINV</name></expr>)</condition><then>
<return>return <expr><name>MAP_UNMAPPABLE</name></expr>;</return></then></if>
}</block></then> <else>else
<return>return <expr><name>coded</name></expr>;</return></else></if>
</case><case>case <expr>-1</expr>:
<expr_stmt><expr>*<name>length</name> = 1</expr>;</expr_stmt>
<expr_stmt><expr><name>coded</name> = <call><name>find_pairencmap</name><argument_list>(<argument><expr>(<name>ucs2_t</name>)<name><name>data</name><index>[<expr>0</expr>]</index></name></expr></argument>, <argument><expr>0</expr></argument>,
<argument><expr><name>jisx0213_pair_encmap</name></expr></argument>, <argument><expr><name>JISX0213_ENCPAIRS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>coded</name> == <name>DBCINV</name></expr>)</condition><then>
<return>return <expr><name>MAP_UNMAPPABLE</name></expr>;</return></then>
<else>else
<return>return <expr><name>coded</name></expr>;</return></else></if>
</case><default>default:
<return>return <expr><name>MAP_UNMAPPABLE</name></expr>;</return>
</default>}</block></switch>
}</block></function>
<function><type><specifier>static</specifier> <name>DBCHAR</name></type>
<name>jisx0213_2000_1_encoder</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>ucs4_t</name> *</type><name>data</name></decl></param>, <param><decl><type><name>Py_ssize_t</name> *</type><name>length</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>DBCHAR</name></type> <name>coded</name> <init>= <expr><call><name>jisx0213_encoder</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><name>length</name></expr></argument>, <argument><expr>(<name>void</name> *)2000</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>coded</name> == <name>MAP_UNMAPPABLE</name> || <name>coded</name> == <name>MAP_MULTIPLE_AVAIL</name></expr>)</condition><then>
<return>return <expr><name>coded</name></expr>;</return></then>
<else>else <if>if <condition>(<expr><name>coded</name> &amp; 0x8000</expr>)</condition><then>
<return>return <expr><name>MAP_UNMAPPABLE</name></expr>;</return></then>
<else>else
<return>return <expr><name>coded</name></expr>;</return></else></if></else></if>
}</block></function>
<function><type><specifier>static</specifier> <name>DBCHAR</name></type>
<name>jisx0213_2000_1_encoder_paironly</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>ucs4_t</name> *</type><name>data</name></decl></param>, <param><decl><type><name>Py_ssize_t</name> *</type><name>length</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>DBCHAR</name></type> <name>coded</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>ilength</name> <init>= <expr>*<name>length</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>coded</name> = <call><name>jisx0213_encoder</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><name>length</name></expr></argument>, <argument><expr>(<name>void</name> *)2000</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<switch>switch <condition>(<expr><name>ilength</name></expr>)</condition> <block>{
<case>case <expr>1</expr>:
<if>if <condition>(<expr><name>coded</name> == <name>MAP_MULTIPLE_AVAIL</name></expr>)</condition><then>
<return>return <expr><name>MAP_MULTIPLE_AVAIL</name></expr>;</return></then>
<else>else
<return>return <expr><name>MAP_UNMAPPABLE</name></expr>;</return></else></if>
</case><case>case <expr>2</expr>:
<if>if <condition>(<expr>*<name>length</name> != 2</expr>)</condition><then>
<return>return <expr><name>MAP_UNMAPPABLE</name></expr>;</return></then>
<else>else
<return>return <expr><name>coded</name></expr>;</return></else></if>
</case><default>default:
<return>return <expr><name>MAP_UNMAPPABLE</name></expr>;</return>
</default>}</block></switch>
}</block></function>
<function><type><specifier>static</specifier> <name>DBCHAR</name></type>
<name>jisx0213_2000_2_encoder</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>ucs4_t</name> *</type><name>data</name></decl></param>, <param><decl><type><name>Py_ssize_t</name> *</type><name>length</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>DBCHAR</name></type> <name>coded</name> <init>= <expr><call><name>jisx0213_encoder</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><name>length</name></expr></argument>, <argument><expr>(<name>void</name> *)2000</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>coded</name> == <name>MAP_UNMAPPABLE</name> || <name>coded</name> == <name>MAP_MULTIPLE_AVAIL</name></expr>)</condition><then>
<return>return <expr><name>coded</name></expr>;</return></then>
<else>else <if>if <condition>(<expr><name>coded</name> &amp; 0x8000</expr>)</condition><then>
<return>return <expr><name>coded</name> &amp; 0x7fff</expr>;</return></then>
<else>else
<return>return <expr><name>MAP_UNMAPPABLE</name></expr>;</return></else></if></else></if>
}</block></function>
<function><type><specifier>static</specifier> <name>DBCHAR</name></type>
<name>jisx0213_2004_1_encoder</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>ucs4_t</name> *</type><name>data</name></decl></param>, <param><decl><type><name>Py_ssize_t</name> *</type><name>length</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>DBCHAR</name></type> <name>coded</name> <init>= <expr><call><name>jisx0213_encoder</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><name>length</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>coded</name> == <name>MAP_UNMAPPABLE</name> || <name>coded</name> == <name>MAP_MULTIPLE_AVAIL</name></expr>)</condition><then>
<return>return <expr><name>coded</name></expr>;</return></then>
<else>else <if>if <condition>(<expr><name>coded</name> &amp; 0x8000</expr>)</condition><then>
<return>return <expr><name>MAP_UNMAPPABLE</name></expr>;</return></then>
<else>else
<return>return <expr><name>coded</name></expr>;</return></else></if></else></if>
}</block></function>
<function><type><specifier>static</specifier> <name>DBCHAR</name></type>
<name>jisx0213_2004_1_encoder_paironly</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>ucs4_t</name> *</type><name>data</name></decl></param>, <param><decl><type><name>Py_ssize_t</name> *</type><name>length</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>DBCHAR</name></type> <name>coded</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>ilength</name> <init>= <expr>*<name>length</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>coded</name> = <call><name>jisx0213_encoder</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><name>length</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<switch>switch <condition>(<expr><name>ilength</name></expr>)</condition> <block>{
<case>case <expr>1</expr>:
<if>if <condition>(<expr><name>coded</name> == <name>MAP_MULTIPLE_AVAIL</name></expr>)</condition><then>
<return>return <expr><name>MAP_MULTIPLE_AVAIL</name></expr>;</return></then>
<else>else
<return>return <expr><name>MAP_UNMAPPABLE</name></expr>;</return></else></if>
</case><case>case <expr>2</expr>:
<if>if <condition>(<expr>*<name>length</name> != 2</expr>)</condition><then>
<return>return <expr><name>MAP_UNMAPPABLE</name></expr>;</return></then>
<else>else
<return>return <expr><name>coded</name></expr>;</return></else></if>
</case><default>default:
<return>return <expr><name>MAP_UNMAPPABLE</name></expr>;</return>
</default>}</block></switch>
}</block></function>
<function><type><specifier>static</specifier> <name>DBCHAR</name></type>
<name>jisx0213_2004_2_encoder</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>ucs4_t</name> *</type><name>data</name></decl></param>, <param><decl><type><name>Py_ssize_t</name> *</type><name>length</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>DBCHAR</name></type> <name>coded</name> <init>= <expr><call><name>jisx0213_encoder</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><name>length</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>coded</name> == <name>MAP_UNMAPPABLE</name> || <name>coded</name> == <name>MAP_MULTIPLE_AVAIL</name></expr>)</condition><then>
<return>return <expr><name>coded</name></expr>;</return></then>
<else>else <if>if <condition>(<expr><name>coded</name> &amp; 0x8000</expr>)</condition><then>
<return>return <expr><name>coded</name> &amp; 0x7fff</expr>;</return></then>
<else>else
<return>return <expr><name>MAP_UNMAPPABLE</name></expr>;</return></else></if></else></if>
}</block></function>
<function><type><specifier>static</specifier> <name>ucs4_t</name></type>
<name>jisx0201_r_decoder</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> *</type><name>data</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>ucs4_t</name></type> <name>u</name></decl>;</decl_stmt>
<macro><name>JISX0201_R_DECODE</name><argument_list>(<argument>*data</argument>, <argument>u</argument>)</argument_list></macro>
<else>else <return>return <expr><name>MAP_UNMAPPABLE</name></expr>;</return></else>
<return>return <expr><name>u</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>DBCHAR</name></type>
<name>jisx0201_r_encoder</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>ucs4_t</name> *</type><name>data</name></decl></param>, <param><decl><type><name>Py_ssize_t</name> *</type><name>length</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>DBCHAR</name></type> <name>coded</name></decl>;</decl_stmt>
<macro><name>JISX0201_R_ENCODE</name><argument_list>(<argument>*data</argument>, <argument>coded</argument>)</argument_list></macro>
<else>else <return>return <expr><name>MAP_UNMAPPABLE</name></expr>;</return></else>
<return>return <expr><name>coded</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>ucs4_t</name></type>
<name>jisx0201_k_decoder</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> *</type><name>data</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>ucs4_t</name></type> <name>u</name></decl>;</decl_stmt>
<macro><name>JISX0201_K_DECODE</name><argument_list>(<argument>*data ^ 0x80</argument>, <argument>u</argument>)</argument_list></macro>
<else>else <return>return <expr><name>MAP_UNMAPPABLE</name></expr>;</return></else>
<return>return <expr><name>u</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>DBCHAR</name></type>
<name>jisx0201_k_encoder</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>ucs4_t</name> *</type><name>data</name></decl></param>, <param><decl><type><name>Py_ssize_t</name> *</type><name>length</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>DBCHAR</name></type> <name>coded</name></decl>;</decl_stmt>
<macro><name>JISX0201_K_ENCODE</name><argument_list>(<argument>*data</argument>, <argument>coded</argument>)</argument_list></macro>
<else>else <return>return <expr><name>MAP_UNMAPPABLE</name></expr>;</return></else>
<return>return <expr><name>coded</name> - 0x80</expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>gb2312_init</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>initialized</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr>!<name>initialized</name> &amp;&amp; (
<call><name>IMPORT_MAP</name><argument_list>(<argument><expr><name>cn</name></expr></argument>, <argument><expr><name>gbcommon</name></expr></argument>, <argument><expr>&amp;<name>gbcommon_encmap</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call> ||
<call><name>IMPORT_MAP</name><argument_list>(<argument><expr><name>cn</name></expr></argument>, <argument><expr><name>gb2312</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr>&amp;<name>gb2312_decmap</name></expr></argument>)</argument_list></call>)</expr>)</condition><then>
<return>return <expr>-1</expr>;</return></then></if>
<expr_stmt><expr><name>initialized</name> = 1</expr>;</expr_stmt>
<return>return <expr>0</expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>ucs4_t</name></type>
<name>gb2312_decoder</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> *</type><name>data</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>ucs4_t</name></type> <name>u</name></decl>;</decl_stmt>
<macro><name>TRYMAP_DEC</name><argument_list>(<argument>gb2312</argument>, <argument>u</argument>, <argument>data[0]</argument>, <argument>data[1]</argument>)</argument_list></macro>
<return>return <expr><name>u</name></expr>;</return>
<else>else
<return>return <expr><name>MAP_UNMAPPABLE</name></expr>;</return></else>
}</block></function>
<function><type><specifier>static</specifier> <name>DBCHAR</name></type>
<name>gb2312_encoder</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>ucs4_t</name> *</type><name>data</name></decl></param>, <param><decl><type><name>Py_ssize_t</name> *</type><name>length</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>DBCHAR</name></type> <name>coded</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr>*<name>length</name> == 1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>*<name>data</name> &lt; 0x10000</expr>)</condition><then> <block>{
<macro><name>TRYMAP_ENC</name><argument_list>(<argument>gbcommon</argument>, <argument>coded</argument>, <argument>*data</argument>)</argument_list></macro> <block>{
<if>if <condition>(<expr>!(<name>coded</name> &amp; 0x8000)</expr>)</condition><then>
<return>return <expr><name>coded</name></expr>;</return></then></if>
}</block>
}</block></then></if>
<return>return <expr><name>MAP_UNMAPPABLE</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>ucs4_t</name></type>
<name>dummy_decoder</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> *</type><name>data</name></decl></param>)</parameter_list> <block>{
<return>return <expr><name>MAP_UNMAPPABLE</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>DBCHAR</name></type>
<name>dummy_encoder</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>ucs4_t</name> *</type><name>data</name></decl></param>, <param><decl><type><name>Py_ssize_t</name> *</type><name>length</name></decl></param>)</parameter_list> <block>{
<return>return <expr><name>MAP_UNMAPPABLE</name></expr>;</return>
}</block></function>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>REGISTRY_KSX1001_G0</name></cpp:macro> <cpp:value>{ CHARSET_KSX1001, 0, 2, ksx1001_init, ksx1001_decoder, ksx1001_encoder }</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>REGISTRY_KSX1001_G1</name></cpp:macro> <cpp:value>{ CHARSET_KSX1001, 1, 2, ksx1001_init, ksx1001_decoder, ksx1001_encoder }</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>REGISTRY_JISX0201_R</name></cpp:macro> <cpp:value>{ CHARSET_JISX0201_R, 0, 1, NULL, jisx0201_r_decoder, jisx0201_r_encoder }</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>REGISTRY_JISX0201_K</name></cpp:macro> <cpp:value>{ CHARSET_JISX0201_K, 0, 1, NULL, jisx0201_k_decoder, jisx0201_k_encoder }</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>REGISTRY_JISX0208</name></cpp:macro> <cpp:value>{ CHARSET_JISX0208, 0, 2, jisx0208_init, jisx0208_decoder, jisx0208_encoder }</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>REGISTRY_JISX0208_O</name></cpp:macro> <cpp:value>{ CHARSET_JISX0208_O, 0, 2, jisx0208_init, jisx0208_decoder, jisx0208_encoder }</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>REGISTRY_JISX0212</name></cpp:macro> <cpp:value>{ CHARSET_JISX0212, 0, 2, jisx0212_init, jisx0212_decoder, jisx0212_encoder }</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>REGISTRY_JISX0213_2000_1</name></cpp:macro> <cpp:value>{ CHARSET_JISX0213_2000_1, 0, 2, jisx0213_init, jisx0213_2000_1_decoder, jisx0213_2000_1_encoder }</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>REGISTRY_JISX0213_2000_1_PAIRONLY</name></cpp:macro> <cpp:value>{ CHARSET_JISX0213_2000_1, 0, 2, jisx0213_init, jisx0213_2000_1_decoder, jisx0213_2000_1_encoder_paironly }</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>REGISTRY_JISX0213_2000_2</name></cpp:macro> <cpp:value>{ CHARSET_JISX0213_2, 0, 2, jisx0213_init, jisx0213_2000_2_decoder, jisx0213_2000_2_encoder }</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>REGISTRY_JISX0213_2004_1</name></cpp:macro> <cpp:value>{ CHARSET_JISX0213_2004_1, 0, 2, jisx0213_init, jisx0213_2004_1_decoder, jisx0213_2004_1_encoder }</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>REGISTRY_JISX0213_2004_1_PAIRONLY</name></cpp:macro> <cpp:value>{ CHARSET_JISX0213_2004_1, 0, 2, jisx0213_init, jisx0213_2004_1_decoder, jisx0213_2004_1_encoder_paironly }</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>REGISTRY_JISX0213_2004_2</name></cpp:macro> <cpp:value>{ CHARSET_JISX0213_2, 0, 2, jisx0213_init, jisx0213_2004_2_decoder, jisx0213_2004_2_encoder }</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>REGISTRY_GB2312</name></cpp:macro> <cpp:value>{ CHARSET_GB2312, 0, 2, gb2312_init, gb2312_decoder, gb2312_encoder }</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>REGISTRY_CNS11643_1</name></cpp:macro> <cpp:value>{ CHARSET_CNS11643_1, 1, 2, cns11643_init, cns11643_1_decoder, cns11643_1_encoder }</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>REGISTRY_CNS11643_2</name></cpp:macro> <cpp:value>{ CHARSET_CNS11643_2, 2, 2, cns11643_init, cns11643_2_decoder, cns11643_2_encoder }</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>REGISTRY_ISO8859_1</name></cpp:macro> <cpp:value>{ CHARSET_ISO8859_1, 2, 1, NULL, dummy_decoder, dummy_encoder }</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>REGISTRY_ISO8859_7</name></cpp:macro> <cpp:value>{ CHARSET_ISO8859_7, 2, 1, NULL, dummy_decoder, dummy_encoder }</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>REGISTRY_SENTINEL</name></cpp:macro> <cpp:value>{ 0, }</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CONFIGDEF</name><parameter_list>(<param><type><name>var</name></type></param>, <param><type><name>attrs</name></type></param>)</parameter_list></cpp:macro> <cpp:value>static const struct iso2022_config iso2022_##var##_config = { attrs, iso2022_##var##_designations };</cpp:value></cpp:define>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> struct <name>iso2022_designation</name></type> <name><name>iso2022_kr_designations</name><index>[]</index></name> <init>= <expr><block>{
<expr><name>REGISTRY_KSX1001_G1</name></expr>, <expr><name>REGISTRY_SENTINEL</name></expr>
}</block></expr></init></decl>;</decl_stmt>
<macro><name>CONFIGDEF</name><argument_list>(<argument>kr</argument>, <argument>0</argument>)</argument_list></macro>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> struct <name>iso2022_designation</name></type> <name><name>iso2022_jp_designations</name><index>[]</index></name> <init>= <expr><block>{
<expr><name>REGISTRY_JISX0208</name></expr>, <expr><name>REGISTRY_JISX0201_R</name></expr>, <expr><name>REGISTRY_JISX0208_O</name></expr>,
<expr><name>REGISTRY_SENTINEL</name></expr>
}</block></expr></init></decl>;</decl_stmt>
<macro><name>CONFIGDEF</name><argument_list>(<argument>jp</argument>, <argument>NO_SHIFT | USE_JISX0208_EXT</argument>)</argument_list></macro>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> struct <name>iso2022_designation</name></type> <name><name>iso2022_jp_1_designations</name><index>[]</index></name> <init>= <expr><block>{
<expr><name>REGISTRY_JISX0208</name></expr>, <expr><name>REGISTRY_JISX0212</name></expr>, <expr><name>REGISTRY_JISX0201_R</name></expr>,
<expr><name>REGISTRY_JISX0208_O</name></expr>, <expr><name>REGISTRY_SENTINEL</name></expr>
}</block></expr></init></decl>;</decl_stmt>
<macro><name>CONFIGDEF</name><argument_list>(<argument>jp_1</argument>, <argument>NO_SHIFT | USE_JISX0208_EXT</argument>)</argument_list></macro>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> struct <name>iso2022_designation</name></type> <name><name>iso2022_jp_2_designations</name><index>[]</index></name> <init>= <expr><block>{
<expr><name>REGISTRY_JISX0208</name></expr>, <expr><name>REGISTRY_JISX0212</name></expr>, <expr><name>REGISTRY_KSX1001_G0</name></expr>,
<expr><name>REGISTRY_GB2312</name></expr>, <expr><name>REGISTRY_JISX0201_R</name></expr>, <expr><name>REGISTRY_JISX0208_O</name></expr>,
<expr><name>REGISTRY_ISO8859_1</name></expr>, <expr><name>REGISTRY_ISO8859_7</name></expr>, <expr><name>REGISTRY_SENTINEL</name></expr>
}</block></expr></init></decl>;</decl_stmt>
<macro><name>CONFIGDEF</name><argument_list>(<argument>jp_2</argument>, <argument>NO_SHIFT | USE_G2 | USE_JISX0208_EXT</argument>)</argument_list></macro>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> struct <name>iso2022_designation</name></type> <name><name>iso2022_jp_2004_designations</name><index>[]</index></name> <init>= <expr><block>{
<expr><name>REGISTRY_JISX0213_2004_1_PAIRONLY</name></expr>, <expr><name>REGISTRY_JISX0208</name></expr>,
<expr><name>REGISTRY_JISX0213_2004_1</name></expr>, <expr><name>REGISTRY_JISX0213_2004_2</name></expr>, <expr><name>REGISTRY_SENTINEL</name></expr>
}</block></expr></init></decl>;</decl_stmt>
<macro><name>CONFIGDEF</name><argument_list>(<argument>jp_2004</argument>, <argument>NO_SHIFT | USE_JISX0208_EXT</argument>)</argument_list></macro>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> struct <name>iso2022_designation</name></type> <name><name>iso2022_jp_3_designations</name><index>[]</index></name> <init>= <expr><block>{
<expr><name>REGISTRY_JISX0213_2000_1_PAIRONLY</name></expr>, <expr><name>REGISTRY_JISX0208</name></expr>,
<expr><name>REGISTRY_JISX0213_2000_1</name></expr>, <expr><name>REGISTRY_JISX0213_2000_2</name></expr>, <expr><name>REGISTRY_SENTINEL</name></expr>
}</block></expr></init></decl>;</decl_stmt>
<macro><name>CONFIGDEF</name><argument_list>(<argument>jp_3</argument>, <argument>NO_SHIFT | USE_JISX0208_EXT</argument>)</argument_list></macro>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> struct <name>iso2022_designation</name></type> <name><name>iso2022_jp_ext_designations</name><index>[]</index></name> <init>= <expr><block>{
<expr><name>REGISTRY_JISX0208</name></expr>, <expr><name>REGISTRY_JISX0212</name></expr>, <expr><name>REGISTRY_JISX0201_R</name></expr>,
<expr><name>REGISTRY_JISX0201_K</name></expr>, <expr><name>REGISTRY_JISX0208_O</name></expr>, <expr><name>REGISTRY_SENTINEL</name></expr>
}</block></expr></init></decl>;</decl_stmt>
<macro><name>CONFIGDEF</name><argument_list>(<argument>jp_ext</argument>, <argument>NO_SHIFT | USE_JISX0208_EXT</argument>)</argument_list></macro>
<decl_stmt><decl><type><name>BEGIN_MAPPINGS_LIST</name>
<name>END_MAPPINGS_LIST</name>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ISO2022_CODEC</name><parameter_list>(<param><type><name>variation</name></type></param>)</parameter_list></cpp:macro> <cpp:value>{ "iso2022_" #variation, &amp;iso2022_##variation##_config, iso2022_codec_init, _STATEFUL_METHODS(iso2022) },</cpp:value></cpp:define>
<name>BEGIN_CODECS_LIST</name></type>
<name>ISO2022_CODEC</name><argument_list>(<argument><expr><name>kr</name></expr></argument>)</argument_list>
<name>ISO2022_CODEC</name><argument_list>(<argument><expr><name>jp</name></expr></argument>)</argument_list>
<name>ISO2022_CODEC</name><argument_list>(<argument><expr><name>jp_1</name></expr></argument>)</argument_list>
<name>ISO2022_CODEC</name><argument_list>(<argument><expr><name>jp_2</name></expr></argument>)</argument_list>
<name>ISO2022_CODEC</name><argument_list>(<argument><expr><name>jp_2004</name></expr></argument>)</argument_list>
<name>ISO2022_CODEC</name><argument_list>(<argument><expr><name>jp_3</name></expr></argument>)</argument_list>
<name>ISO2022_CODEC</name><argument_list>(<argument><expr><name>jp_ext</name></expr></argument>)</argument_list>
<name>END_CODECS_LIST</name>
<name>I_AM_A_MODULE_FOR</name><argument_list>(<argument><expr><name>iso2022</name></expr></argument>)</argument_list></decl></decl_stmt>
</unit>
