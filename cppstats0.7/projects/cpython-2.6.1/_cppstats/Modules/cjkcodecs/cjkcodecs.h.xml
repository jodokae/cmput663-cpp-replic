<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C" filename="projects/cpython-2.6.1/_cppstats/Modules/cjkcodecs/cjkcodecs.h"><cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>_CJKCODECS_H_</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>_CJKCODECS_H_</name></cpp:macro></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PY_SSIZE_T_CLEAN</name></cpp:macro></cpp:define>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"Python.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"multibytecodec.h"</cpp:file></cpp:include>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>UNIINV</name></cpp:macro> <cpp:value>0xFFFE</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NOCHAR</name></cpp:macro> <cpp:value>0xFFFF</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MULTIC</name></cpp:macro> <cpp:value>0xFFFE</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DBCINV</name></cpp:macro> <cpp:value>0xFFFD</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>U</name></cpp:macro> <cpp:value>UNIINV</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>N</name></cpp:macro> <cpp:value>NOCHAR</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>M</name></cpp:macro> <cpp:value>MULTIC</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>D</name></cpp:macro> <cpp:value>DBCINV</cpp:value></cpp:define>
<struct>struct <name>dbcs_index</name> <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>ucs2_t</name> *</type><name>map</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name>bottom</name></decl>, <decl><type ref="prev"/><name>top</name></decl>;</decl_stmt>
}</block>;</struct>
<typedef>typedef <type>struct <name>dbcs_index</name></type> <name>decode_map</name>;</typedef>
<struct>struct <name>widedbcs_index</name> <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>ucs4_t</name> *</type><name>map</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name>bottom</name></decl>, <decl><type ref="prev"/><name>top</name></decl>;</decl_stmt>
}</block>;</struct>
<typedef>typedef <type>struct <name>widedbcs_index</name></type> <name>widedecode_map</name>;</typedef>
<struct>struct <name>unim_index</name> <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>DBCHAR</name> *</type><name>map</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name>bottom</name></decl>, <decl><type ref="prev"/><name>top</name></decl>;</decl_stmt>
}</block>;</struct>
<typedef>typedef <type>struct <name>unim_index</name></type> <name>encode_map</name>;</typedef>
<struct>struct <name>unim_index_bytebased</name> <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> *</type><name>map</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name>bottom</name></decl>, <decl><type ref="prev"/><name>top</name></decl>;</decl_stmt>
}</block>;</struct>
<struct>struct <name>dbcs_map</name> <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>charset</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> struct <name>unim_index</name> *</type><name>encmap</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> struct <name>dbcs_index</name> *</type><name>decmap</name></decl>;</decl_stmt>
}</block>;</struct>
<struct>struct <name>pair_encodemap</name> <block>{
<decl_stmt><decl><type><name>ucs4_t</name></type> <name>uniseq</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>DBCHAR</name></type> <name>code</name></decl>;</decl_stmt>
}</block>;</struct>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>MultibyteCodec</name> *</type><name>codec_list</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> struct <name>dbcs_map</name> *</type><name>mapping_list</name></decl>;</decl_stmt>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CODEC_INIT</name><parameter_list>(<param><type><name>encoding</name></type></param>)</parameter_list></cpp:macro> <cpp:value>static int encoding##_codec_init(const void *config)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ENCODER_INIT</name><parameter_list>(<param><type><name>encoding</name></type></param>)</parameter_list></cpp:macro> <cpp:value>static int encoding##_encode_init( MultibyteCodec_State *state, const void *config)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ENCODER</name><parameter_list>(<param><type><name>encoding</name></type></param>)</parameter_list></cpp:macro> <cpp:value>static Py_ssize_t encoding##_encode( MultibyteCodec_State *state, const void *config, const Py_UNICODE **inbuf, Py_ssize_t inleft, unsigned char **outbuf, Py_ssize_t outleft, int flags)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ENCODER_RESET</name><parameter_list>(<param><type><name>encoding</name></type></param>)</parameter_list></cpp:macro> <cpp:value>static Py_ssize_t encoding##_encode_reset( MultibyteCodec_State *state, const void *config, unsigned char **outbuf, Py_ssize_t outleft)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DECODER_INIT</name><parameter_list>(<param><type><name>encoding</name></type></param>)</parameter_list></cpp:macro> <cpp:value>static int encoding##_decode_init( MultibyteCodec_State *state, const void *config)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DECODER</name><parameter_list>(<param><type><name>encoding</name></type></param>)</parameter_list></cpp:macro> <cpp:value>static Py_ssize_t encoding##_decode( MultibyteCodec_State *state, const void *config, const unsigned char **inbuf, Py_ssize_t inleft, Py_UNICODE **outbuf, Py_ssize_t outleft)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DECODER_RESET</name><parameter_list>(<param><type><name>encoding</name></type></param>)</parameter_list></cpp:macro> <cpp:value>static Py_ssize_t encoding##_decode_reset( MultibyteCodec_State *state, const void *config)</cpp:value></cpp:define>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>Py_UNICODE_SIZE</name> == 4</expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>UCS4INVALID</name><parameter_list>(<param><type><name>code</name></type></param>)</parameter_list></cpp:macro> <cpp:value>if ((code) &gt; 0xFFFF) return 1;</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>UCS4INVALID</name><parameter_list>(<param><type><name>code</name></type></param>)</parameter_list></cpp:macro> <cpp:value>if (0) ;</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NEXT_IN</name><parameter_list>(<param><type><name>i</name></type></param>)</parameter_list></cpp:macro> <cpp:value>(*inbuf) += (i); (inleft) -= (i);</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NEXT_OUT</name><parameter_list>(<param><type><name>o</name></type></param>)</parameter_list></cpp:macro> <cpp:value>(*outbuf) += (o); (outleft) -= (o);</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NEXT</name><parameter_list>(<param><type><name>i</name></type></param>, <param><type><name>o</name></type></param>)</parameter_list></cpp:macro> <cpp:value>NEXT_IN(i) NEXT_OUT(o)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>REQUIRE_INBUF</name><parameter_list>(<param><type><name>n</name></type></param>)</parameter_list></cpp:macro> <cpp:value>if (inleft &lt; (n)) return MBERR_TOOFEW;</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>REQUIRE_OUTBUF</name><parameter_list>(<param><type><name>n</name></type></param>)</parameter_list></cpp:macro> <cpp:value>if (outleft &lt; (n)) return MBERR_TOOSMALL;</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IN1</name></cpp:macro> <cpp:value>((*inbuf)[0])</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IN2</name></cpp:macro> <cpp:value>((*inbuf)[1])</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IN3</name></cpp:macro> <cpp:value>((*inbuf)[2])</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IN4</name></cpp:macro> <cpp:value>((*inbuf)[3])</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>OUT1</name><parameter_list>(<param><type><name>c</name></type></param>)</parameter_list></cpp:macro> <cpp:value>((*outbuf)[0]) = (c);</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>OUT2</name><parameter_list>(<param><type><name>c</name></type></param>)</parameter_list></cpp:macro> <cpp:value>((*outbuf)[1]) = (c);</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>OUT3</name><parameter_list>(<param><type><name>c</name></type></param>)</parameter_list></cpp:macro> <cpp:value>((*outbuf)[2]) = (c);</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>OUT4</name><parameter_list>(<param><type><name>c</name></type></param>)</parameter_list></cpp:macro> <cpp:value>((*outbuf)[3]) = (c);</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WRITE1</name><parameter_list>(<param><type><name>c1</name></type></param>)</parameter_list></cpp:macro> <cpp:value>REQUIRE_OUTBUF(1) (*outbuf)[0] = (c1);</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WRITE2</name><parameter_list>(<param><type><name>c1</name></type></param>, <param><type><name>c2</name></type></param>)</parameter_list></cpp:macro> <cpp:value>REQUIRE_OUTBUF(2) (*outbuf)[0] = (c1); (*outbuf)[1] = (c2);</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WRITE3</name><parameter_list>(<param><type><name>c1</name></type></param>, <param><type><name>c2</name></type></param>, <param><type><name>c3</name></type></param>)</parameter_list></cpp:macro> <cpp:value>REQUIRE_OUTBUF(3) (*outbuf)[0] = (c1); (*outbuf)[1] = (c2); (*outbuf)[2] = (c3);</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WRITE4</name><parameter_list>(<param><type><name>c1</name></type></param>, <param><type><name>c2</name></type></param>, <param><type><name>c3</name></type></param>, <param><type><name>c4</name></type></param>)</parameter_list></cpp:macro> <cpp:value>REQUIRE_OUTBUF(4) (*outbuf)[0] = (c1); (*outbuf)[1] = (c2); (*outbuf)[2] = (c3); (*outbuf)[3] = (c4);</cpp:value></cpp:define>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>Py_UNICODE_SIZE</name> == 2</expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WRITEUCS4</name><parameter_list>(<param><type><name>c</name></type></param>)</parameter_list></cpp:macro> <cpp:value>REQUIRE_OUTBUF(2) (*outbuf)[0] = 0xd800 + (((c) - 0x10000) &gt;&gt; 10); (*outbuf)[1] = 0xdc00 + (((c) - 0x10000) &amp; 0x3ff); NEXT_OUT(2)</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WRITEUCS4</name><parameter_list>(<param><type><name>c</name></type></param>)</parameter_list></cpp:macro> <cpp:value>REQUIRE_OUTBUF(1) **outbuf = (Py_UNICODE)(c); NEXT_OUT(1)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>_TRYMAP_ENC</name><parameter_list>(<param><type><name>m</name></type></param>, <param><type><name>assi</name></type></param>, <param><type><name>val</name></type></param>)</parameter_list></cpp:macro> <cpp:value>((m)-&gt;map != NULL &amp;&amp; (val) &gt;= (m)-&gt;bottom &amp;&amp; (val)&lt;= (m)-&gt;top &amp;&amp; ((assi) = (m)-&gt;map[(val) - (m)-&gt;bottom]) != NOCHAR)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TRYMAP_ENC_COND</name><parameter_list>(<param><type><name>charset</name></type></param>, <param><type><name>assi</name></type></param>, <param><type><name>uni</name></type></param>)</parameter_list></cpp:macro> <cpp:value>_TRYMAP_ENC(&amp;charset##_encmap[(uni) &gt;&gt; 8], assi, (uni) &amp; 0xff)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TRYMAP_ENC</name><parameter_list>(<param><type><name>charset</name></type></param>, <param><type><name>assi</name></type></param>, <param><type><name>uni</name></type></param>)</parameter_list></cpp:macro> <cpp:value>if TRYMAP_ENC_COND(charset, assi, uni)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>_TRYMAP_DEC</name><parameter_list>(<param><type><name>m</name></type></param>, <param><type><name>assi</name></type></param>, <param><type><name>val</name></type></param>)</parameter_list></cpp:macro> <cpp:value>((m)-&gt;map != NULL &amp;&amp; (val) &gt;= (m)-&gt;bottom &amp;&amp; (val)&lt;= (m)-&gt;top &amp;&amp; ((assi) = (m)-&gt;map[(val) - (m)-&gt;bottom]) != UNIINV)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TRYMAP_DEC</name><parameter_list>(<param><type><name>charset</name></type></param>, <param><type><name>assi</name></type></param>, <param><type><name>c1</name></type></param>, <param><type><name>c2</name></type></param>)</parameter_list></cpp:macro> <cpp:value>if _TRYMAP_DEC(&amp;charset##_decmap[c1], assi, c2)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>_TRYMAP_ENC_MPLANE</name><parameter_list>(<param><type><name>m</name></type></param>, <param><type><name>assplane</name></type></param>, <param><type><name>asshi</name></type></param>, <param><type><name>asslo</name></type></param>, <param><type><name>val</name></type></param>)</parameter_list></cpp:macro> <cpp:value>((m)-&gt;map != NULL &amp;&amp; (val) &gt;= (m)-&gt;bottom &amp;&amp; (val)&lt;= (m)-&gt;top &amp;&amp; ((assplane) = (m)-&gt;map[((val) - (m)-&gt;bottom)*3]) != 0 &amp;&amp; (((asshi) = (m)-&gt;map[((val) - (m)-&gt;bottom)*3 + 1]), 1) &amp;&amp; (((asslo) = (m)-&gt;map[((val) - (m)-&gt;bottom)*3 + 2]), 1))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TRYMAP_ENC_MPLANE</name><parameter_list>(<param><type><name>charset</name></type></param>, <param><type><name>assplane</name></type></param>, <param><type><name>asshi</name></type></param>, <param><type><name>asslo</name></type></param>, <param><type><name>uni</name></type></param>)</parameter_list></cpp:macro> <cpp:value>if _TRYMAP_ENC_MPLANE(&amp;charset##_encmap[(uni) &gt;&gt; 8], assplane, asshi, asslo, (uni) &amp; 0xff)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TRYMAP_DEC_MPLANE</name><parameter_list>(<param><type><name>charset</name></type></param>, <param><type><name>assi</name></type></param>, <param><type><name>plane</name></type></param>, <param><type><name>c1</name></type></param>, <param><type><name>c2</name></type></param>)</parameter_list></cpp:macro> <cpp:value>if _TRYMAP_DEC(&amp;charset##_decmap[plane][c1], assi, c2)</cpp:value></cpp:define>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>Py_UNICODE_SIZE</name> == 2</expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DECODE_SURROGATE</name><parameter_list>(<param><type><name>c</name></type></param>)</parameter_list></cpp:macro> <cpp:value>if (c &gt;&gt; 10 == 0xd800 &gt;&gt; 10) { REQUIRE_INBUF(2) if (IN2 &gt;&gt; 10 == 0xdc00 &gt;&gt; 10) { c = 0x10000 + ((ucs4_t)(c - 0xd800) &lt;&lt; 10) + ((ucs4_t)(IN2) - 0xdc00); } }</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GET_INSIZE</name><parameter_list>(<param><type><name>c</name></type></param>)</parameter_list></cpp:macro> <cpp:value>((c) &gt; 0xffff ? 2 : 1)</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DECODE_SURROGATE</name><parameter_list>(<param><type><name>c</name></type></param>)</parameter_list></cpp:macro> <cpp:value>{;}</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GET_INSIZE</name><parameter_list>(<param><type><name>c</name></type></param>)</parameter_list></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BEGIN_MAPPINGS_LIST</name></cpp:macro> <cpp:value>static const struct dbcs_map _mapping_list[] = {</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAPPING_ENCONLY</name><parameter_list>(<param><type><name>enc</name></type></param>)</parameter_list></cpp:macro> <cpp:value>{#enc, (void*)enc##_encmap, NULL},</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAPPING_DECONLY</name><parameter_list>(<param><type><name>enc</name></type></param>)</parameter_list></cpp:macro> <cpp:value>{#enc, NULL, (void*)enc##_decmap},</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAPPING_ENCDEC</name><parameter_list>(<param><type><name>enc</name></type></param>)</parameter_list></cpp:macro> <cpp:value>{#enc, (void*)enc##_encmap, (void*)enc##_decmap},</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>END_MAPPINGS_LIST</name></cpp:macro> <cpp:value>{"", NULL, NULL} }; static const struct dbcs_map *mapping_list = (const struct dbcs_map *)_mapping_list;</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BEGIN_CODECS_LIST</name></cpp:macro> <cpp:value>static const MultibyteCodec _codec_list[] = {</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>_STATEFUL_METHODS</name><parameter_list>(<param><type><name>enc</name></type></param>)</parameter_list></cpp:macro> <cpp:value>enc##_encode, enc##_encode_init, enc##_encode_reset, enc##_decode, enc##_decode_init, enc##_decode_reset,</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>_STATELESS_METHODS</name><parameter_list>(<param><type><name>enc</name></type></param>)</parameter_list></cpp:macro> <cpp:value>enc##_encode, NULL, NULL, enc##_decode, NULL, NULL,</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CODEC_STATEFUL</name><parameter_list>(<param><type><name>enc</name></type></param>)</parameter_list></cpp:macro> <cpp:value>{ #enc, NULL, NULL, _STATEFUL_METHODS(enc) },</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CODEC_STATELESS</name><parameter_list>(<param><type><name>enc</name></type></param>)</parameter_list></cpp:macro> <cpp:value>{ #enc, NULL, NULL, _STATELESS_METHODS(enc) },</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CODEC_STATELESS_WINIT</name><parameter_list>(<param><type><name>enc</name></type></param>)</parameter_list></cpp:macro> <cpp:value>{ #enc, NULL, enc##_codec_init, _STATELESS_METHODS(enc) },</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>END_CODECS_LIST</name></cpp:macro> <cpp:value>{"", NULL,} }; static const MultibyteCodec *codec_list = (const MultibyteCodec *)_codec_list;</cpp:value></cpp:define>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>getmultibytecodec</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><specifier>static</specifier> <name>PyObject</name> *</type><name>cofunc</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>cofunc</name> == <name>NULL</name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>mod</name> <init>= <expr><call><name>PyImport_ImportModuleNoBlock</name><argument_list>(<argument><expr>"_multibytecodec"</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>mod</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>cofunc</name> = <call><name>PyObject_GetAttrString</name><argument_list>(<argument><expr><name>mod</name></expr></argument>, <argument><expr>"__create_codec"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>mod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<return>return <expr><name>cofunc</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>getcodec</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>encoding</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>codecobj</name></decl>, *<decl><type ref="prev"/><name>r</name></decl>, *<decl><type ref="prev"/><name>cofunc</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>MultibyteCodec</name> *</type><name>codec</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>enc</name></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>PyString_Check</name><argument_list>(<argument><expr><name>encoding</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
<argument><expr>"encoding name must be a string."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>cofunc</name> = <call><name>getmultibytecodec</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>cofunc</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>enc</name> = <call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>encoding</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for (<init><expr><name>codec</name> = <name>codec_list</name></expr>;</init> <condition><expr><name><name>codec</name>-&gt;<name>encoding</name><index>[<expr>0</expr>]</index></name></expr>;</condition> <incr><expr><name>codec</name>++</expr></incr>)
<if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>codec</name>-&gt;<name>encoding</name></name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call> == 0</expr>)</condition><then>
<break>break;</break></then></if></for>
<if>if <condition>(<expr><name><name>codec</name>-&gt;<name>encoding</name><index>[<expr>0</expr>]</index></name> == '\0'</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_LookupError</name></expr></argument>,
<argument><expr>"no such codec is supported."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>codecobj</name> = <call><name>PyCObject_FromVoidPtr</name><argument_list>(<argument><expr>(<name>void</name> *)<name>codec</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>codecobj</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>r</name> = <call><name>PyObject_CallFunctionObjArgs</name><argument_list>(<argument><expr><name>cofunc</name></expr></argument>, <argument><expr><name>codecobj</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>codecobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>r</name></expr>;</return>
}</block></function>
<decl_stmt><decl><type><specifier>static</specifier> struct <name>PyMethodDef</name></type> <name><name>__methods</name><index>[]</index></name> <init>= <expr><block>{
<expr><block>{<expr>"getcodec"</expr>, <expr>(<name>PyCFunction</name>)<name>getcodec</name></expr>, <expr><name>METH_O</name></expr>, <expr>""</expr>}</block></expr>,
<expr><block>{<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>}</block></expr>,
}</block></expr></init></decl>;</decl_stmt>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>register_maps</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>module</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><specifier>const</specifier> struct <name>dbcs_map</name> *</type><name>h</name></decl>;</decl_stmt>
<for>for (<init><expr><name>h</name> = <name>mapping_list</name></expr>;</init> <condition><expr><name><name>h</name>-&gt;<name>charset</name><index>[<expr>0</expr>]</index></name> != '\0'</expr>;</condition> <incr><expr><name>h</name>++</expr></incr>) <block>{
<decl_stmt><decl><type><name>char</name></type> <name><name>mhname</name><index>[<expr>256</expr>]</index></name> <init>= <expr>"__map_"</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>r</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>mhname</name> + <sizeof>sizeof<argument_list>(<argument><expr>"__map_"</expr></argument>)</argument_list></sizeof> - 1</expr></argument>, <argument><expr><name><name>h</name>-&gt;<name>charset</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>r</name> = <call><name>PyModule_AddObject</name><argument_list>(<argument><expr><name>module</name></expr></argument>, <argument><expr><name>mhname</name></expr></argument>,
<argument><expr><call><name>PyCObject_FromVoidPtr</name><argument_list>(<argument><expr>(<name>void</name> *)<name>h</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>r</name> == -1</expr>)</condition><then>
<return>return <expr>-1</expr>;</return></then></if>
}</block></for>
<return>return <expr>0</expr>;</return>
}</block></function>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>USING_BINARY_PAIR_SEARCH</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function><type><specifier>static</specifier> <name>DBCHAR</name></type>
<name>find_pairencmap</name><parameter_list>(<param><decl><type><name>ucs2_t</name></type> <name>body</name></decl></param>, <param><decl><type><name>ucs2_t</name></type> <name>modifier</name></decl></param>,
<param><decl><type><specifier>const</specifier> struct <name>pair_encodemap</name> *</type><name>haystack</name></decl></param>, <param><decl><type><name>int</name></type> <name>haystacksize</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>pos</name></decl>, <decl><type ref="prev"/><name>min</name></decl>, <decl><type ref="prev"/><name>max</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ucs4_t</name></type> <name>value</name> <init>= <expr><name>body</name> &lt;&lt; 16 | <name>modifier</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>min</name> = 0</expr>;</expr_stmt>
<expr_stmt><expr><name>max</name> = <name>haystacksize</name></expr>;</expr_stmt>
<for>for (<init><expr><name>pos</name> = <name>haystacksize</name> &gt;&gt; 1</expr>;</init> <condition><expr><name>min</name> != <name>max</name></expr>;</condition> <incr><expr><name>pos</name> = (<name>min</name> + <name>max</name>) &gt;&gt; 1</expr></incr>)
<if>if <condition>(<expr><name>value</name> &lt; <name><name>haystack</name><index>[<expr><name>pos</name></expr>]</index></name>.<name>uniseq</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr><name>max</name> == <name>pos</name></expr>)</condition><then> <break>break;</break></then>
<else>else <expr_stmt><expr><name>max</name> = <name>pos</name></expr>;</expr_stmt></else></if>
}</block></then> <else>else <if>if <condition>(<expr><name>value</name> &gt; <name><name>haystack</name><index>[<expr><name>pos</name></expr>]</index></name>.<name>uniseq</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr><name>min</name> == <name>pos</name></expr>)</condition><then> <break>break;</break></then>
<else>else <expr_stmt><expr><name>min</name> = <name>pos</name></expr>;</expr_stmt></else></if>
}</block></then> <else>else
<break>break;</break></else></if></else></if></for>
<if>if <condition>(<expr><name>value</name> == <name><name>haystack</name><index>[<expr><name>pos</name></expr>]</index></name>.<name>uniseq</name></expr>)</condition><then>
<return>return <expr><name><name>haystack</name><index>[<expr><name>pos</name></expr>]</index></name>.<name>code</name></expr>;</return></then>
<else>else
<return>return <expr><name>DBCINV</name></expr>;</return></else></if>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>USING_IMPORTED_MAPS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IMPORT_MAP</name><parameter_list>(<param><type><name>locale</name></type></param>, <param><type><name>charset</name></type></param>, <param><type><name>encmap</name></type></param>, <param><type><name>decmap</name></type></param>)</parameter_list></cpp:macro> <cpp:value>importmap("_codecs_" #locale, "__map_" #charset, (const void**)encmap, (const void**)decmap)</cpp:value></cpp:define>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>importmap</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>modname</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>symbol</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>void</name> **</type><name>encmap</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>void</name> **</type><name>decmap</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>o</name></decl>, *<decl><type ref="prev"/><name>mod</name></decl>;</decl_stmt>
<expr_stmt><expr><name>mod</name> = <call><name>PyImport_ImportModule</name><argument_list>(<argument><expr>(<name>char</name> *)<name>modname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>mod</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr>-1</expr>;</return></then></if>
<expr_stmt><expr><name>o</name> = <call><name>PyObject_GetAttrString</name><argument_list>(<argument><expr><name>mod</name></expr></argument>, <argument><expr>(<name>char</name>*)<name>symbol</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>o</name> == <name>NULL</name></expr>)</condition><then>
<goto>goto <name>errorexit</name>;</goto></then>
<else>else <if>if <condition>(<expr>!<call><name>PyCObject_Check</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>,
<argument><expr>"map data must be a CObject."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>errorexit</name>;</goto>
}</block></then> <else>else <block>{
<decl_stmt><decl><type>struct <name>dbcs_map</name> *</type><name>map</name></decl>;</decl_stmt>
<expr_stmt><expr><name>map</name> = <call><name>PyCObject_AsVoidPtr</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>encmap</name> != <name>NULL</name></expr>)</condition><then>
<expr_stmt><expr>*<name>encmap</name> = <name><name>map</name>-&gt;<name>encmap</name></name></expr>;</expr_stmt></then></if>
<if>if <condition>(<expr><name>decmap</name> != <name>NULL</name></expr>)</condition><then>
<expr_stmt><expr>*<name>decmap</name> = <name><name>map</name>-&gt;<name>decmap</name></name></expr>;</expr_stmt></then></if>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></else></if></else></if>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>mod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>0</expr>;</return>
<label><name>errorexit</name>:</label>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>mod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>-1</expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>I_AM_A_MODULE_FOR</name><parameter_list>(<param><type><name>loc</name></type></param>)</parameter_list></cpp:macro> <cpp:value>void init_codecs_##loc(void) { PyObject *m = Py_InitModule("_codecs_" #loc, __methods);if (m != NULL) (void)register_maps(m); }</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</unit>
