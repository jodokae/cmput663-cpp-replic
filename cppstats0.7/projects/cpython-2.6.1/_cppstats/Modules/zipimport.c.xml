<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C" filename="projects/cpython-2.6.1/_cppstats/Modules/zipimport.c"><cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"Python.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"structmember.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"osdefs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"marshal.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;time.h&gt;</cpp:file></cpp:include>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IS_SOURCE</name></cpp:macro> <cpp:value>0x0</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IS_BYTECODE</name></cpp:macro> <cpp:value>0x1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IS_PACKAGE</name></cpp:macro> <cpp:value>0x2</cpp:value></cpp:define>
<struct>struct <name>st_zip_searchorder</name> <block>{
<decl_stmt><decl><type><name>char</name></type> <name><name>suffix</name><index>[<expr>14</expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>type</name></decl>;</decl_stmt>
}</block>;</struct>
<decl_stmt><decl><type><specifier>static</specifier> struct <name>st_zip_searchorder</name></type> <name><name>zip_searchorder</name><index>[]</index></name> <init>= <expr><block>{
<expr><block>{<expr>"/__init__.pyc"</expr>, <expr><name>IS_PACKAGE</name> | <name>IS_BYTECODE</name></expr>}</block></expr>,
<expr><block>{<expr>"/__init__.pyo"</expr>, <expr><name>IS_PACKAGE</name> | <name>IS_BYTECODE</name></expr>}</block></expr>,
<expr><block>{<expr>"/__init__.py"</expr>, <expr><name>IS_PACKAGE</name> | <name>IS_SOURCE</name></expr>}</block></expr>,
<expr><block>{<expr>".pyc"</expr>, <expr><name>IS_BYTECODE</name></expr>}</block></expr>,
<expr><block>{<expr>".pyo"</expr>, <expr><name>IS_BYTECODE</name></expr>}</block></expr>,
<expr><block>{<expr>".py"</expr>, <expr><name>IS_SOURCE</name></expr>}</block></expr>,
<expr><block>{<expr>""</expr>, <expr>0</expr>}</block></expr>
}</block></expr></init></decl>;</decl_stmt>
<typedef>typedef <type>struct <name>_zipimporter</name></type> <name>ZipImporter</name>;</typedef>
<struct>struct <name>_zipimporter</name> <block>{
<decl_stmt><decl><type><name>PyObject_HEAD</name>
<name>PyObject</name> *</type><name>archive</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>prefix</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>files</name></decl>;</decl_stmt>
}</block>;</struct>
<decl_stmt><decl><type><specifier>static</specifier> <name>PyObject</name> *</type><name>ZipImportError</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>PyObject</name> *</type><name>zip_directory_cache</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<function_decl><type><specifier>static</specifier> <name>PyObject</name> *</type><name>read_directory</name><parameter_list>(<param><decl><type><name>char</name> *</type><name>archive</name></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>PyObject</name> *</type><name>get_data</name><parameter_list>(<param><decl><type><name>char</name> *</type><name>archive</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>toc_entry</name></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>PyObject</name> *</type><name>get_module_code</name><parameter_list>(<param><decl><type><name>ZipImporter</name> *</type><name>self</name></decl></param>, <param><decl><type><name>char</name> *</type><name>fullname</name></decl></param>,
<param><decl><type><name>int</name> *</type><name>p_ispackage</name></decl></param>, <param><decl><type><name>char</name> **</type><name>p_modpath</name></decl></param>)</parameter_list>;</function_decl>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ZipImporter_Check</name><parameter_list>(<param><type><name>op</name></type></param>)</parameter_list></cpp:macro> <cpp:value>PyObject_TypeCheck(op, &amp;ZipImporter_Type)</cpp:value></cpp:define>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>zipimporter_init</name><parameter_list>(<param><decl><type><name>ZipImporter</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>kwds</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>char</name> *</type><name>path</name></decl>, *<decl><type ref="prev"/><name>p</name></decl>, *<decl><type ref="prev"/><name>prefix</name></decl>, <decl><type ref="prev"/><name><name>buf</name><index>[<expr><name>MAXPATHLEN</name>+2</expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>len</name></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>_PyArg_NoKeywords</name><argument_list>(<argument><expr>"zipimporter()"</expr></argument>, <argument><expr><name>kwds</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr>-1</expr>;</return></then></if>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"s:zipimporter"</expr></argument>,
<argument><expr>&amp;<name>path</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr>-1</expr>;</return></then></if>
<expr_stmt><expr><name>len</name> = <call><name>strlen</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>len</name> == 0</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>ZipImportError</name></expr></argument>, <argument><expr>"archive path is empty"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>-1</expr>;</return>
}</block></then></if>
<if>if <condition>(<expr><name>len</name> &gt;= <name>MAXPATHLEN</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>ZipImportError</name></expr></argument>,
<argument><expr>"archive path too long"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>-1</expr>;</return>
}</block></then></if>
<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>ALTSEP</name></expr></argument>)</argument_list></call></expr></cpp:if>
<for>for (<init><expr><name>p</name> = <name>buf</name></expr>;</init> <condition><expr>*<name>p</name></expr>;</condition> <incr><expr><name>p</name>++</expr></incr>) <block>{
<if>if <condition>(<expr>*<name>p</name> == <name>ALTSEP</name></expr>)</condition><then>
<expr_stmt><expr>*<name>p</name> = <name>SEP</name></expr>;</expr_stmt></then></if>
}</block></for>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><name>path</name> = <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name>prefix</name> = <name>NULL</name></expr>;</expr_stmt>
<for>for (<init>;</init><condition>;</condition><incr/>) <block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>RISCOS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type>struct <name>stat</name></type> <name>statbuf</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>rv</name></decl>;</decl_stmt>
<expr_stmt><expr><name>rv</name> = <call><name>stat</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr>&amp;<name>statbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>rv</name> == 0</expr>)</condition><then> <block>{
<if>if <condition>(<expr><call><name>S_ISREG</name><argument_list>(<argument><expr><name><name>statbuf</name>.<name>st_mode</name></name></expr></argument>)</argument_list></call></expr>)</condition><then>
<expr_stmt><expr><name>path</name> = <name>buf</name></expr>;</expr_stmt></then></if>
<break>break;</break>
}</block></then></if>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<if>if <condition>(<expr><call><name>object_exists</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<if>if <condition>(<expr><call><name>isfile</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<expr_stmt><expr><name>path</name> = <name>buf</name></expr>;</expr_stmt></then></if>
<break>break;</break>
}</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><name>p</name> = <call><name>strrchr</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>SEP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>prefix</name> != <name>NULL</name></expr>)</condition><then>
<expr_stmt><expr>*<name>prefix</name> = <name>SEP</name></expr>;</expr_stmt></then></if>
<if>if <condition>(<expr><name>p</name> == <name>NULL</name></expr>)</condition><then>
<break>break;</break></then></if>
<expr_stmt><expr>*<name>p</name> = '\0'</expr>;</expr_stmt>
<expr_stmt><expr><name>prefix</name> = <name>p</name></expr>;</expr_stmt>
}</block></for>
<if>if <condition>(<expr><name>path</name> != <name>NULL</name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>files</name></decl>;</decl_stmt>
<expr_stmt><expr><name>files</name> = <call><name>PyDict_GetItemString</name><argument_list>(<argument><expr><name>zip_directory_cache</name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>files</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>files</name> = <call><name>read_directory</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>files</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr>-1</expr>;</return></then></if>
<if>if <condition>(<expr><call><name>PyDict_SetItemString</name><argument_list>(<argument><expr><name>zip_directory_cache</name></expr></argument>, <argument><expr><name>path</name></expr></argument>,
<argument><expr><name>files</name></expr></argument>)</argument_list></call> != 0</expr>)</condition><then>
<return>return <expr>-1</expr>;</return></then></if>
}</block></then> <else>else
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>files</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
<expr_stmt><expr><name><name>self</name>-&gt;<name>files</name></name> = <name>files</name></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>ZipImportError</name></expr></argument>, <argument><expr>"not a Zip file"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>-1</expr>;</return>
}</block></else></if>
<if>if <condition>(<expr><name>prefix</name> == <name>NULL</name></expr>)</condition><then>
<expr_stmt><expr><name>prefix</name> = ""</expr>;</expr_stmt></then>
<else>else <block>{
<expr_stmt><expr><name>prefix</name>++</expr>;</expr_stmt>
<expr_stmt><expr><name>len</name> = <call><name>strlen</name><argument_list>(<argument><expr><name>prefix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>prefix</name><index>[<expr><name>len</name>-1</expr>]</index></name> != <name>SEP</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>prefix</name><index>[<expr><name>len</name></expr>]</index></name> = <name>SEP</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>prefix</name><index>[<expr><name>len</name> + 1</expr>]</index></name> = '\0'</expr>;</expr_stmt>
}</block></then></if>
}</block></else></if>
<expr_stmt><expr><name><name>self</name>-&gt;<name>archive</name></name> = <call><name>PyString_FromString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>self</name>-&gt;<name>archive</name></name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr>-1</expr>;</return></then></if>
<expr_stmt><expr><name><name>self</name>-&gt;<name>prefix</name></name> = <call><name>PyString_FromString</name><argument_list>(<argument><expr><name>prefix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>self</name>-&gt;<name>prefix</name></name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr>-1</expr>;</return></then></if>
<return>return <expr>0</expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>zipimporter_traverse</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>obj</name></decl></param>, <param><decl><type><name>visitproc</name></type> <name>visit</name></decl></param>, <param><decl><type><name>void</name> *</type><name>arg</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>ZipImporter</name> *</type><name>self</name> <init>= <expr>(<name>ZipImporter</name> *)<name>obj</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>Py_VISIT</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>files</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>0</expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>zipimporter_dealloc</name><parameter_list>(<param><decl><type><name>ZipImporter</name> *</type><name>self</name></decl></param>)</parameter_list> <block>{
<expr_stmt><expr><call><name>PyObject_GC_UnTrack</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>archive</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>prefix</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>files</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_TYPE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call>-&gt;<call><name>tp_free</name><argument_list>(<argument><expr>(<name>PyObject</name> *)<name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>zipimporter_repr</name><parameter_list>(<param><decl><type><name>ZipImporter</name> *</type><name>self</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>char</name></type> <name><name>buf</name><index>[<expr>500</expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>archive</name> <init>= <expr>"???"</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>prefix</name> <init>= <expr>""</expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name><name>self</name>-&gt;<name>archive</name></name> != <name>NULL</name> &amp;&amp; <call><name>PyString_Check</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>archive</name></name></expr></argument>)</argument_list></call></expr>)</condition><then>
<expr_stmt><expr><name>archive</name> = <call><name>PyString_AsString</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>archive</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<if>if <condition>(<expr><name><name>self</name>-&gt;<name>prefix</name></name> != <name>NULL</name> &amp;&amp; <call><name>PyString_Check</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>prefix</name></name></expr></argument>)</argument_list></call></expr>)</condition><then>
<expr_stmt><expr><name>prefix</name> = <call><name>PyString_AsString</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>prefix</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<if>if <condition>(<expr><name>prefix</name> != <name>NULL</name> &amp;&amp; *<name>prefix</name></expr>)</condition><then>
<expr_stmt><expr><call><name>PyOS_snprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>,
<argument><expr>"&lt;zipimporter object \"%.300s%c%.150s\"&gt;"</expr></argument>,
<argument><expr><name>archive</name></expr></argument>, <argument><expr><name>SEP</name></expr></argument>, <argument><expr><name>prefix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
<else>else
<expr_stmt><expr><call><name>PyOS_snprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>,
<argument><expr>"&lt;zipimporter object \"%.300s\"&gt;"</expr></argument>,
<argument><expr><name>archive</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
<return>return <expr><call><name>PyString_FromString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>char</name> *</type>
<name>get_subname</name><parameter_list>(<param><decl><type><name>char</name> *</type><name>fullname</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>char</name> *</type><name>subname</name> <init>= <expr><call><name>strrchr</name><argument_list>(<argument><expr><name>fullname</name></expr></argument>, <argument><expr>'.'</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>subname</name> == <name>NULL</name></expr>)</condition><then>
<expr_stmt><expr><name>subname</name> = <name>fullname</name></expr>;</expr_stmt></then>
<else>else
<expr_stmt><expr><name>subname</name>++</expr>;</expr_stmt></else></if>
<return>return <expr><name>subname</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>make_filename</name><parameter_list>(<param><decl><type><name>char</name> *</type><name>prefix</name></decl></param>, <param><decl><type><name>char</name> *</type><name>name</name></decl></param>, <param><decl><type><name>char</name> *</type><name>path</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>size_t</name></type> <name>len</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>p</name></decl>;</decl_stmt>
<expr_stmt><expr><name>len</name> = <call><name>strlen</name><argument_list>(<argument><expr><name>prefix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>len</name> + <call><name>strlen</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call> + 13 &gt;= <name>MAXPATHLEN</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>ZipImportError</name></expr></argument>, <argument><expr>"path too long"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>-1</expr>;</return>
}</block></then></if>
<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>prefix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>path</name> + <name>len</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for (<init><expr><name>p</name> = <name>path</name> + <name>len</name></expr>;</init> <condition><expr>*<name>p</name></expr>;</condition> <incr><expr><name>p</name>++</expr></incr>) <block>{
<if>if <condition>(<expr>*<name>p</name> == '.'</expr>)</condition><then>
<expr_stmt><expr>*<name>p</name> = <name>SEP</name></expr>;</expr_stmt></then></if>
}</block></for>
<expr_stmt><expr><name>len</name> += <call><name>strlen</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>len</name> &lt; <name>INT_MAX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>(<name>int</name>)<name>len</name></expr>;</return>
}</block></function>
<enum>enum <name>zi_module_info</name> <block>{
<decl><name>MI_ERROR</name></decl>,
<decl><name>MI_NOT_FOUND</name></decl>,
<decl><name>MI_MODULE</name></decl>,
<decl><name>MI_PACKAGE</name></decl>
}</block>;</enum>
<enum><specifier>static</specifier> enum <name>zi_module_info</name>
<name>get_module_info</name><expr_stmt><expr>(<name>ZipImporter</name> *<name>self</name>, <name>char</name> *<name>fullname</name>) <block>{
<expr><name>char</name> *<name>subname</name></expr>, <expr><name><name>path</name><index>[<expr><name>MAXPATHLEN</name> + 1</expr>]</index></name></expr>;
<expr><name>int</name> <name>len</name></expr>;
struct <expr><name>st_zip_searchorder</name> *<name>zso</name></expr>;
<expr><name>subname</name> = <call><name>get_subname</name><argument_list>(<argument><expr><name>fullname</name></expr></argument>)</argument_list></call></expr>;
<expr><name>len</name> = <call><name>make_filename</name><argument_list>(<argument><expr><call><name>PyString_AsString</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>prefix</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>subname</name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;
<if>if <condition>(<expr><name>len</name> &lt; 0</expr>)</condition><then>
<return>return <expr><name>MI_ERROR</name></expr>;</return></then></if></block></expr></expr_stmt></enum>
<for>for (<init><expr><name>zso</name> = <name>zip_searchorder</name></expr>;</init> <condition><expr>*<name><name>zso</name>-&gt;<name>suffix</name></name></expr>;</condition> <incr><expr><name>zso</name>++</expr></incr>) <block>{
<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>path</name> + <name>len</name></expr></argument>, <argument><expr><name><name>zso</name>-&gt;<name>suffix</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>PyDict_GetItemString</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>files</name></name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call> != <name>NULL</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr><name><name>zso</name>-&gt;<name>type</name></name> &amp; <name>IS_PACKAGE</name></expr>)</condition><then>
<return>return <expr><name>MI_PACKAGE</name></expr>;</return></then>
<else>else
<return>return <expr><name>MI_MODULE</name></expr>;</return></else></if>
}</block></then></if>
}</block></for>
<return>return <expr><name>MI_NOT_FOUND</name></expr>;</return>
}
static <function><type><name>PyObject</name> *</type>
<name>zipimporter_find_module</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>obj</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>ZipImporter</name> *</type><name>self</name> <init>= <expr>(<name>ZipImporter</name> *)<name>obj</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>path</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>fullname</name></decl>;</decl_stmt>
<enum>enum <name>zi_module_info</name> <name>mi</name>;</enum>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"s|O:zipimporter.find_module"</expr></argument>,
<argument><expr>&amp;<name>fullname</name></expr></argument>, <argument><expr>&amp;<name>path</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>mi</name> = <call><name>get_module_info</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>fullname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>mi</name> == <name>MI_ERROR</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<if>if <condition>(<expr><name>mi</name> == <name>MI_NOT_FOUND</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>Py_None</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>(<name>PyObject</name> *)<name>self</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>zipimporter_load_module</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>obj</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>ZipImporter</name> *</type><name>self</name> <init>= <expr>(<name>ZipImporter</name> *)<name>obj</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>code</name></decl>, *<decl><type ref="prev"/><name>mod</name></decl>, *<decl><type ref="prev"/><name>dict</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>fullname</name></decl>, *<decl><type ref="prev"/><name>modpath</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>ispackage</name></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"s:zipimporter.load_module"</expr></argument>,
<argument><expr>&amp;<name>fullname</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>code</name> = <call><name>get_module_code</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>fullname</name></expr></argument>, <argument><expr>&amp;<name>ispackage</name></expr></argument>, <argument><expr>&amp;<name>modpath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>code</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>mod</name> = <call><name>PyImport_AddModule</name><argument_list>(<argument><expr><name>fullname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>mod</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>code</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>dict</name> = <call><name>PyModule_GetDict</name><argument_list>(<argument><expr><name>mod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>PyDict_SetItemString</name><argument_list>(<argument><expr><name>dict</name></expr></argument>, <argument><expr>"__loader__"</expr></argument>, <argument><expr>(<name>PyObject</name> *)<name>self</name></expr></argument>)</argument_list></call> != 0</expr>)</condition><then>
<goto>goto <name>error</name>;</goto></then></if>
<if>if <condition>(<expr><name>ispackage</name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>pkgpath</name></decl>, *<decl><type ref="prev"/><name>fullpath</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>prefix</name> <init>= <expr><call><name>PyString_AsString</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>prefix</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>subname</name> <init>= <expr><call><name>get_subname</name><argument_list>(<argument><expr><name>fullname</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>err</name></decl>;</decl_stmt>
<expr_stmt><expr><name>fullpath</name> = <call><name>PyString_FromFormat</name><argument_list>(<argument><expr>"%s%c%s%s"</expr></argument>,
<argument><expr><call><name>PyString_AsString</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>archive</name></name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>SEP</name></expr></argument>,
<argument><expr>*<name>prefix</name> ? <name>prefix</name> : ""</expr></argument>,
<argument><expr><name>subname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>fullpath</name> == <name>NULL</name></expr>)</condition><then>
<goto>goto <name>error</name>;</goto></then></if>
<expr_stmt><expr><name>pkgpath</name> = <call><name>Py_BuildValue</name><argument_list>(<argument><expr>"[O]"</expr></argument>, <argument><expr><name>fullpath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>fullpath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>pkgpath</name> == <name>NULL</name></expr>)</condition><then>
<goto>goto <name>error</name>;</goto></then></if>
<expr_stmt><expr><name>err</name> = <call><name>PyDict_SetItemString</name><argument_list>(<argument><expr><name>dict</name></expr></argument>, <argument><expr>"__path__"</expr></argument>, <argument><expr><name>pkgpath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>pkgpath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>err</name> != 0</expr>)</condition><then>
<goto>goto <name>error</name>;</goto></then></if>
}</block></then></if>
<expr_stmt><expr><name>mod</name> = <call><name>PyImport_ExecCodeModuleEx</name><argument_list>(<argument><expr><name>fullname</name></expr></argument>, <argument><expr><name>code</name></expr></argument>, <argument><expr><name>modpath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>code</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>Py_VerboseFlag</name></expr>)</condition><then>
<expr_stmt><expr><call><name>PySys_WriteStderr</name><argument_list>(<argument><expr>"import %s #loaded from Zip %s\n"</expr></argument>,
<argument><expr><name>fullname</name></expr></argument>, <argument><expr><name>modpath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<return>return <expr><name>mod</name></expr>;</return>
<label><name>error</name>:</label>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>code</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>mod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>zipimporter_is_package</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>obj</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>ZipImporter</name> *</type><name>self</name> <init>= <expr>(<name>ZipImporter</name> *)<name>obj</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>fullname</name></decl>;</decl_stmt>
<enum>enum <name>zi_module_info</name> <name>mi</name>;</enum>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"s:zipimporter.is_package"</expr></argument>,
<argument><expr>&amp;<name>fullname</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>mi</name> = <call><name>get_module_info</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>fullname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>mi</name> == <name>MI_ERROR</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<if>if <condition>(<expr><name>mi</name> == <name>MI_NOT_FOUND</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>ZipImportError</name></expr></argument>, <argument><expr>"can't find module '%.200s'"</expr></argument>,
<argument><expr><name>fullname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<return>return <expr><call><name>PyBool_FromLong</name><argument_list>(<argument><expr><name>mi</name> == <name>MI_PACKAGE</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>zipimporter_get_data</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>obj</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>ZipImporter</name> *</type><name>self</name> <init>= <expr>(<name>ZipImporter</name> *)<name>obj</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>path</name></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>ALTSEP</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>char</name> *</type><name>p</name></decl>, <decl><type ref="prev"/><name><name>buf</name><index>[<expr><name>MAXPATHLEN</name> + 1</expr>]</index></name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>toc_entry</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>len</name></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"s:zipimporter.get_data"</expr></argument>, <argument><expr>&amp;<name>path</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>ALTSEP</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if>if <condition>(<expr><call><name>strlen</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call> &gt;= <name>MAXPATHLEN</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>ZipImportError</name></expr></argument>, <argument><expr>"path too long"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for (<init><expr><name>p</name> = <name>buf</name></expr>;</init> <condition><expr>*<name>p</name></expr>;</condition> <incr><expr><name>p</name>++</expr></incr>) <block>{
<if>if <condition>(<expr>*<name>p</name> == <name>ALTSEP</name></expr>)</condition><then>
<expr_stmt><expr>*<name>p</name> = <name>SEP</name></expr>;</expr_stmt></then></if>
}</block></for>
<expr_stmt><expr><name>path</name> = <name>buf</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><name>len</name> = <call><name>PyString_Size</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>archive</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>(<name>size_t</name>)<name>len</name> &lt; <call><name>strlen</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call> &amp;&amp;
<call><name>strncmp</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><call><name>PyString_AsString</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>archive</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call> == 0 &amp;&amp;
<name><name>path</name><index>[<expr><name>len</name></expr>]</index></name> == <name>SEP</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>path</name> = <name>path</name> + <name>len</name> + 1</expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><name>toc_entry</name> = <call><name>PyDict_GetItemString</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>files</name></name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>toc_entry</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetFromErrnoWithFilename</name><argument_list>(<argument><expr><name>PyExc_IOError</name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<return>return <expr><call><name>get_data</name><argument_list>(<argument><expr><call><name>PyString_AsString</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>archive</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>toc_entry</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>zipimporter_get_code</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>obj</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>ZipImporter</name> *</type><name>self</name> <init>= <expr>(<name>ZipImporter</name> *)<name>obj</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>fullname</name></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"s:zipimporter.get_code"</expr></argument>, <argument><expr>&amp;<name>fullname</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<return>return <expr><call><name>get_module_code</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>fullname</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>zipimporter_get_source</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>obj</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>ZipImporter</name> *</type><name>self</name> <init>= <expr>(<name>ZipImporter</name> *)<name>obj</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>toc_entry</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>fullname</name></decl>, *<decl><type ref="prev"/><name>subname</name></decl>, <decl><type ref="prev"/><name><name>path</name><index>[<expr><name>MAXPATHLEN</name>+1</expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>len</name></decl>;</decl_stmt>
<enum>enum <name>zi_module_info</name> <name>mi</name>;</enum>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"s:zipimporter.get_source"</expr></argument>, <argument><expr>&amp;<name>fullname</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>mi</name> = <call><name>get_module_info</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>fullname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>mi</name> == <name>MI_ERROR</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<if>if <condition>(<expr><name>mi</name> == <name>MI_NOT_FOUND</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>ZipImportError</name></expr></argument>, <argument><expr>"can't find module '%.200s'"</expr></argument>,
<argument><expr><name>fullname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>subname</name> = <call><name>get_subname</name><argument_list>(<argument><expr><name>fullname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>len</name> = <call><name>make_filename</name><argument_list>(<argument><expr><call><name>PyString_AsString</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>prefix</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>subname</name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>len</name> &lt; 0</expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<if>if <condition>(<expr><name>mi</name> == <name>MI_PACKAGE</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>path</name><index>[<expr><name>len</name></expr>]</index></name> = <name>SEP</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>path</name> + <name>len</name> + 1</expr></argument>, <argument><expr>"__init__.py"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else
<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>path</name> + <name>len</name></expr></argument>, <argument><expr>".py"</expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
<expr_stmt><expr><name>toc_entry</name> = <call><name>PyDict_GetItemString</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>files</name></name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>toc_entry</name> != <name>NULL</name></expr>)</condition><then>
<return>return <expr><call><name>get_data</name><argument_list>(<argument><expr><call><name>PyString_AsString</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>archive</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>toc_entry</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>Py_None</name></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>doc_find_module</name></expr></argument>,
<argument><expr>"find_module(fullname, path=None) -&gt; self or None.\n\
\n\
Search for a module specified by 'fullname'. 'fullname' must be the\n\
fully qualified (dotted) module name. It returns the zipimporter\n\
instance itself if the module was found, or None if it wasn't.\n\
The optional 'path' argument is ignored -- it's there for compatibility\n\
with the importer protocol."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>doc_load_module</name></expr></argument>,
<argument><expr>"load_module(fullname) -&gt; module.\n\
\n\
Load the module specified by 'fullname'. 'fullname' must be the\n\
fully qualified (dotted) module name. It returns the imported\n\
module, or raises ZipImportError if it wasn't found."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>doc_get_data</name></expr></argument>,
<argument><expr>"get_data(pathname) -&gt; string with file data.\n\
\n\
Return the data associated with 'pathname'. Raise IOError if\n\
the file wasn't found."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>doc_is_package</name></expr></argument>,
<argument><expr>"is_package(fullname) -&gt; bool.\n\
\n\
Return True if the module specified by fullname is a package.\n\
Raise ZipImportError is the module couldn't be found."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>doc_get_code</name></expr></argument>,
<argument><expr>"get_code(fullname) -&gt; code object.\n\
\n\
Return the code object for the specified module. Raise ZipImportError\n\
is the module couldn't be found."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>doc_get_source</name></expr></argument>,
<argument><expr>"get_source(fullname) -&gt; source string.\n\
\n\
Return the source code for the specified module. Raise ZipImportError\n\
is the module couldn't be found, return None if the archive does\n\
contain the module, but has no source for it."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>PyMethodDef</name></type> <name><name>zipimporter_methods</name><index>[]</index></name> <init>= <expr><block>{
<expr><block>{
<expr>"find_module"</expr>, <expr><name>zipimporter_find_module</name></expr>, <expr><name>METH_VARARGS</name></expr>,
<expr><name>doc_find_module</name></expr>
}</block></expr>,
<expr><block>{
<expr>"load_module"</expr>, <expr><name>zipimporter_load_module</name></expr>, <expr><name>METH_VARARGS</name></expr>,
<expr><name>doc_load_module</name></expr>
}</block></expr>,
<expr><block>{
<expr>"get_data"</expr>, <expr><name>zipimporter_get_data</name></expr>, <expr><name>METH_VARARGS</name></expr>,
<expr><name>doc_get_data</name></expr>
}</block></expr>,
<expr><block>{
<expr>"get_code"</expr>, <expr><name>zipimporter_get_code</name></expr>, <expr><name>METH_VARARGS</name></expr>,
<expr><name>doc_get_code</name></expr>
}</block></expr>,
<expr><block>{
<expr>"get_source"</expr>, <expr><name>zipimporter_get_source</name></expr>, <expr><name>METH_VARARGS</name></expr>,
<expr><name>doc_get_source</name></expr>
}</block></expr>,
<expr><block>{
<expr>"is_package"</expr>, <expr><name>zipimporter_is_package</name></expr>, <expr><name>METH_VARARGS</name></expr>,
<expr><name>doc_is_package</name></expr>
}</block></expr>,
<expr><block>{<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>}</block></expr>
}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>PyMemberDef</name></type> <name><name>zipimporter_members</name><index>[]</index></name> <init>= <expr><block>{
<expr><block>{<expr>"archive"</expr>, <expr><name>T_OBJECT</name></expr>, <expr><call><name>offsetof</name><argument_list>(<argument><expr><name>ZipImporter</name></expr></argument>, <argument><expr><name>archive</name></expr></argument>)</argument_list></call></expr>, <expr><name>READONLY</name></expr>}</block></expr>,
<expr><block>{<expr>"prefix"</expr>, <expr><name>T_OBJECT</name></expr>, <expr><call><name>offsetof</name><argument_list>(<argument><expr><name>ZipImporter</name></expr></argument>, <argument><expr><name>prefix</name></expr></argument>)</argument_list></call></expr>, <expr><name>READONLY</name></expr>}</block></expr>,
<expr><block>{<expr>"_files"</expr>, <expr><name>T_OBJECT</name></expr>, <expr><call><name>offsetof</name><argument_list>(<argument><expr><name>ZipImporter</name></expr></argument>, <argument><expr><name>files</name></expr></argument>)</argument_list></call></expr>, <expr><name>READONLY</name></expr>}</block></expr>,
<expr><block>{<expr><name>NULL</name></expr>}</block></expr>
}</block></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>zipimporter_doc</name></expr></argument>,
<argument><expr>"zipimporter(archivepath) -&gt; zipimporter object\n\
\n\
Create a new zipimporter instance. 'archivepath' must be a path to\n\
a zipfile, or to a specific path inside a zipfile. For example, it can be\n\
'/tmp/myimport.zip', or '/tmp/myimport.zip/mydirectory', if mydirectory is a\n\
valid directory inside the archive.\n\
\n\
'ZipImportError is raised if 'archivepath' doesn't point to a valid Zip\n\
archive.\n\
\n\
The 'archive' attribute of zipimporter objects contains the name of the\n\
zipfile targeted."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DEFERRED_ADDRESS</name><parameter_list>(<param><type><name>ADDR</name></type></param>)</parameter_list></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<decl_stmt><decl><type><specifier>static</specifier> <name>PyTypeObject</name></type> <name>ZipImporter_Type</name> <init>= <expr><block>{
<expr><call><name>PyVarObject_HEAD_INIT</name><argument_list>(<argument><expr><call><name>DEFERRED_ADDRESS</name><argument_list>(<argument><expr>&amp;<name>PyType_Type</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call>
"zipimport.zipimporter"</expr>,
<expr><sizeof>sizeof<argument_list>(<argument><expr><name>ZipImporter</name></expr></argument>)</argument_list></sizeof></expr>,
<expr>0</expr>,
<expr>(<name>destructor</name>)<name>zipimporter_dealloc</name></expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>(<name>reprfunc</name>)<name>zipimporter_repr</name></expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr><name>PyObject_GenericGetAttr</name></expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr><name>Py_TPFLAGS_DEFAULT</name> | <name>Py_TPFLAGS_BASETYPE</name> |
<name>Py_TPFLAGS_HAVE_GC</name></expr>,
<expr><name>zipimporter_doc</name></expr>,
<expr><name>zipimporter_traverse</name></expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr><name>zipimporter_methods</name></expr>,
<expr><name>zipimporter_members</name></expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>(<name>initproc</name>)<name>zipimporter_init</name></expr>,
<expr><name>PyType_GenericAlloc</name></expr>,
<expr><name>PyType_GenericNew</name></expr>,
<expr><name>PyObject_GC_Del</name></expr>,
}</block></expr></init></decl>;</decl_stmt>
<function><type><specifier>static</specifier> <name>long</name></type>
<name>get_long</name><parameter_list>(<param><decl><type><name>unsigned</name> <name>char</name> *</type><name>buf</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>long</name></type> <name>x</name></decl>;</decl_stmt>
<expr_stmt><expr><name>x</name> = <name><name>buf</name><index>[<expr>0</expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name>x</name> |= (<name>long</name>)<name><name>buf</name><index>[<expr>1</expr>]</index></name> &lt;&lt; 8</expr>;</expr_stmt>
<expr_stmt><expr><name>x</name> |= (<name>long</name>)<name><name>buf</name><index>[<expr>2</expr>]</index></name> &lt;&lt; 16</expr>;</expr_stmt>
<expr_stmt><expr><name>x</name> |= (<name>long</name>)<name><name>buf</name><index>[<expr>3</expr>]</index></name> &lt;&lt; 24</expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SIZEOF_LONG</name> &gt; 4</expr></cpp:if>
<expr_stmt><expr><name>x</name> |= -(<name>x</name> &amp; 0x80000000L)</expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<return>return <expr><name>x</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>read_directory</name><parameter_list>(<param><decl><type><name>char</name> *</type><name>archive</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>files</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>FILE</name> *</type><name>fp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>long</name></type> <name>compress</name></decl>, <decl><type ref="prev"/><name>crc</name></decl>, <decl><type ref="prev"/><name>data_size</name></decl>, <decl><type ref="prev"/><name>file_size</name></decl>, <decl><type ref="prev"/><name>file_offset</name></decl>, <decl><type ref="prev"/><name>date</name></decl>, <decl><type ref="prev"/><name>time</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>long</name></type> <name>header_offset</name></decl>, <decl><type ref="prev"/><name>name_size</name></decl>, <decl><type ref="prev"/><name>header_size</name></decl>, <decl><type ref="prev"/><name>header_position</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>long</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>l</name></decl>, <decl><type ref="prev"/><name>count</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>length</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name><name>path</name><index>[<expr><name>MAXPATHLEN</name> + 5</expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name><name>name</name><index>[<expr><name>MAXPATHLEN</name> + 5</expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>p</name></decl>, <decl><type ref="prev"/><name><name>endof_central_dir</name><index>[<expr>22</expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>long</name></type> <name>arc_offset</name></decl>;</decl_stmt>
<if>if <condition>(<expr><call><name>strlen</name><argument_list>(<argument><expr><name>archive</name></expr></argument>)</argument_list></call> &gt; <name>MAXPATHLEN</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_OverflowError</name></expr></argument>,
<argument><expr>"Zip path name is too long"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>archive</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>fp</name> = <call><name>fopen</name><argument_list>(<argument><expr><name>archive</name></expr></argument>, <argument><expr>"rb"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>fp</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>ZipImportError</name></expr></argument>, <argument><expr>"can't open Zip file: "
"'%.200s'"</expr></argument>, <argument><expr><name>archive</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><call><name>fseek</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr>-22</expr></argument>, <argument><expr><name>SEEK_END</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>header_position</name> = <call><name>ftell</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>fread</name><argument_list>(<argument><expr><name>endof_central_dir</name></expr></argument>, <argument><expr>1</expr></argument>, <argument><expr>22</expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call> != 22</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>ZipImportError</name></expr></argument>, <argument><expr>"can't read Zip file: "
"'%.200s'"</expr></argument>, <argument><expr><name>archive</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<if>if <condition>(<expr><call><name>get_long</name><argument_list>(<argument><expr>(<name>unsigned</name> <name>char</name> *)<name>endof_central_dir</name></expr></argument>)</argument_list></call> != 0x06054B50</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>ZipImportError</name></expr></argument>, <argument><expr>"not a Zip file: "
"'%.200s'"</expr></argument>, <argument><expr><name>archive</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>header_size</name> = <call><name>get_long</name><argument_list>(<argument><expr>(<name>unsigned</name> <name>char</name> *)<name>endof_central_dir</name> + 12</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>header_offset</name> = <call><name>get_long</name><argument_list>(<argument><expr>(<name>unsigned</name> <name>char</name> *)<name>endof_central_dir</name> + 16</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>arc_offset</name> = <name>header_position</name> - <name>header_offset</name> - <name>header_size</name></expr>;</expr_stmt>
<expr_stmt><expr><name>header_offset</name> += <name>arc_offset</name></expr>;</expr_stmt>
<expr_stmt><expr><name>files</name> = <call><name>PyDict_New</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>files</name> == <name>NULL</name></expr>)</condition><then>
<goto>goto <name>error</name>;</goto></then></if>
<expr_stmt><expr><name>length</name> = (<name>long</name>)<call><name>strlen</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>path</name><index>[<expr><name>length</name></expr>]</index></name> = <name>SEP</name></expr>;</expr_stmt>
<expr_stmt><expr><name>count</name> = 0</expr>;</expr_stmt>
<for>for (<init>;</init><condition>;</condition><incr/>) <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>t</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>err</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>fseek</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><name>header_offset</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>l</name> = <call><name>PyMarshal_ReadLongFromFile</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>l</name> != 0x02014B50</expr>)</condition><then>
<break>break;</break></then></if>
<expr_stmt><expr><call><name>fseek</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><name>header_offset</name> + 10</expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>compress</name> = <call><name>PyMarshal_ReadShortFromFile</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>time</name> = <call><name>PyMarshal_ReadShortFromFile</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>date</name> = <call><name>PyMarshal_ReadShortFromFile</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>crc</name> = <call><name>PyMarshal_ReadLongFromFile</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>data_size</name> = <call><name>PyMarshal_ReadLongFromFile</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>file_size</name> = <call><name>PyMarshal_ReadLongFromFile</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>name_size</name> = <call><name>PyMarshal_ReadShortFromFile</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>header_size</name> = 46 + <name>name_size</name> +
<call><name>PyMarshal_ReadShortFromFile</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call> +
<call><name>PyMarshal_ReadShortFromFile</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>fseek</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><name>header_offset</name> + 42</expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>file_offset</name> = <call><name>PyMarshal_ReadLongFromFile</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call> + <name>arc_offset</name></expr>;</expr_stmt>
<if>if <condition>(<expr><name>name_size</name> &gt; <name>MAXPATHLEN</name></expr>)</condition><then>
<expr_stmt><expr><name>name_size</name> = <name>MAXPATHLEN</name></expr>;</expr_stmt></then></if>
<expr_stmt><expr><name>p</name> = <name>name</name></expr>;</expr_stmt>
<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>name_size</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
<expr_stmt><expr>*<name>p</name> = (<name>char</name>)<call><name>getc</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>*<name>p</name> == '/'</expr>)</condition><then>
<expr_stmt><expr>*<name>p</name> = <name>SEP</name></expr>;</expr_stmt></then></if>
<expr_stmt><expr><name>p</name>++</expr>;</expr_stmt>
}</block></for>
<expr_stmt><expr>*<name>p</name> = 0</expr>;</expr_stmt>
<expr_stmt><expr><name>header_offset</name> += <name>header_size</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>strncpy</name><argument_list>(<argument><expr><name>path</name> + <name>length</name> + 1</expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>MAXPATHLEN</name> - <name>length</name> - 1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>t</name> = <call><name>Py_BuildValue</name><argument_list>(<argument><expr>"siiiiiii"</expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>compress</name></expr></argument>, <argument><expr><name>data_size</name></expr></argument>,
<argument><expr><name>file_size</name></expr></argument>, <argument><expr><name>file_offset</name></expr></argument>, <argument><expr><name>time</name></expr></argument>, <argument><expr><name>date</name></expr></argument>, <argument><expr><name>crc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>t</name> == <name>NULL</name></expr>)</condition><then>
<goto>goto <name>error</name>;</goto></then></if>
<expr_stmt><expr><name>err</name> = <call><name>PyDict_SetItemString</name><argument_list>(<argument><expr><name>files</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>err</name> != 0</expr>)</condition><then>
<goto>goto <name>error</name>;</goto></then></if>
<expr_stmt><expr><name>count</name>++</expr>;</expr_stmt>
}</block></for>
<expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>Py_VerboseFlag</name></expr>)</condition><then>
<expr_stmt><expr><call><name>PySys_WriteStderr</name><argument_list>(<argument><expr>"#zipimport: found %ld names in %s\n"</expr></argument>,
<argument><expr><name>count</name></expr></argument>, <argument><expr><name>archive</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<return>return <expr><name>files</name></expr>;</return>
<label><name>error</name>:</label>
<expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>files</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>get_decompress_func</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><specifier>static</specifier> <name>PyObject</name> *</type><name>decompress</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>decompress</name> == <name>NULL</name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>zlib</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>importing_zlib</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>importing_zlib</name> != 0</expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>importing_zlib</name> = 1</expr>;</expr_stmt>
<expr_stmt><expr><name>zlib</name> = <call><name>PyImport_ImportModuleNoBlock</name><argument_list>(<argument><expr>"zlib"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>importing_zlib</name> = 0</expr>;</expr_stmt>
<if>if <condition>(<expr><name>zlib</name> != <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>decompress</name> = <call><name>PyObject_GetAttrString</name><argument_list>(<argument><expr><name>zlib</name></expr></argument>,
<argument><expr>"decompress"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>zlib</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else
<expr_stmt><expr><call><name>PyErr_Clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt></else></if>
<if>if <condition>(<expr><name>Py_VerboseFlag</name></expr>)</condition><then>
<expr_stmt><expr><call><name>PySys_WriteStderr</name><argument_list>(<argument><expr>"#zipimport: zlib %s\n"</expr></argument>,
<argument><expr><name>zlib</name> != <name>NULL</name> ? "available": "UNAVAILABLE"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
}</block></then></if>
<return>return <expr><name>decompress</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>get_data</name><parameter_list>(<param><decl><type><name>char</name> *</type><name>archive</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>toc_entry</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>raw_data</name></decl>, *<decl><type ref="prev"/><name>data</name> <init>= <expr><name>NULL</name></expr></init>, *<name>decompress</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>buf</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>FILE</name> *</type><name>fp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>err</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>bytes_read</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>long</name></type> <name>l</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>datapath</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>long</name></type> <name>compress</name></decl>, <decl><type ref="prev"/><name>data_size</name></decl>, <decl><type ref="prev"/><name>file_size</name></decl>, <decl><type ref="prev"/><name>file_offset</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>long</name></type> <name>time</name></decl>, <decl><type ref="prev"/><name>date</name></decl>, <decl><type ref="prev"/><name>crc</name></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>toc_entry</name></expr></argument>, <argument><expr>"slllllll"</expr></argument>, <argument><expr>&amp;<name>datapath</name></expr></argument>, <argument><expr>&amp;<name>compress</name></expr></argument>,
<argument><expr>&amp;<name>data_size</name></expr></argument>, <argument><expr>&amp;<name>file_size</name></expr></argument>, <argument><expr>&amp;<name>file_offset</name></expr></argument>, <argument><expr>&amp;<name>time</name></expr></argument>,
<argument><expr>&amp;<name>date</name></expr></argument>, <argument><expr>&amp;<name>crc</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>fp</name> = <call><name>fopen</name><argument_list>(<argument><expr><name>archive</name></expr></argument>, <argument><expr>"rb"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>fp</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_IOError</name></expr></argument>,
<argument><expr>"zipimport: can not open file %s"</expr></argument>, <argument><expr><name>archive</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><call><name>fseek</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><name>file_offset</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>l</name> = <call><name>PyMarshal_ReadLongFromFile</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>l</name> != 0x04034B50</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>ZipImportError</name></expr></argument>,
<argument><expr>"bad local file header in %s"</expr></argument>,
<argument><expr><name>archive</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><call><name>fseek</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><name>file_offset</name> + 26</expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>l</name> = 30 + <call><name>PyMarshal_ReadShortFromFile</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call> +
<call><name>PyMarshal_ReadShortFromFile</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>file_offset</name> += <name>l</name></expr>;</expr_stmt>
<expr_stmt><expr><name>raw_data</name> = <call><name>PyString_FromStringAndSize</name><argument_list>(<argument><expr>(<name>char</name> *)<name>NULL</name></expr></argument>, <argument><expr><name>compress</name> == 0 ?
<name>data_size</name> : <name>data_size</name> + 1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>raw_data</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>buf</name> = <call><name>PyString_AsString</name><argument_list>(<argument><expr><name>raw_data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>err</name> = <call><name>fseek</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><name>file_offset</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>err</name> == 0</expr>)</condition><then>
<expr_stmt><expr><name>bytes_read</name> = <call><name>fread</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr>1</expr></argument>, <argument><expr><name>data_size</name></expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>err</name> || <name>bytes_read</name> != <name>data_size</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_IOError</name></expr></argument>,
<argument><expr>"zipimport: can't read data"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>raw_data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<if>if <condition>(<expr><name>compress</name> != 0</expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>buf</name><index>[<expr><name>data_size</name></expr>]</index></name> = 'Z'</expr>;</expr_stmt>
<expr_stmt><expr><name>data_size</name>++</expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><name><name>buf</name><index>[<expr><name>data_size</name></expr>]</index></name> = '\0'</expr>;</expr_stmt>
<if>if <condition>(<expr><name>compress</name> == 0</expr>)</condition><then>
<return>return <expr><name>raw_data</name></expr>;</return></then></if>
<expr_stmt><expr><name>decompress</name> = <call><name>get_decompress_func</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>decompress</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>ZipImportError</name></expr></argument>,
<argument><expr>"can't decompress data; "
"zlib not available"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>error</name>;</goto>
}</block></then></if>
<expr_stmt><expr><name>data</name> = <call><name>PyObject_CallFunction</name><argument_list>(<argument><expr><name>decompress</name></expr></argument>, <argument><expr>"Oi"</expr></argument>, <argument><expr><name>raw_data</name></expr></argument>, <argument><expr>-15</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<label><name>error</name>:</label>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>raw_data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>data</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>eq_mtime</name><parameter_list>(<param><decl><type><name>time_t</name></type> <name>t1</name></decl></param>, <param><decl><type><name>time_t</name></type> <name>t2</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>time_t</name></type> <name>d</name> <init>= <expr><name>t1</name> - <name>t2</name></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>d</name> &lt; 0</expr>)</condition><then>
<expr_stmt><expr><name>d</name> = -<name>d</name></expr>;</expr_stmt></then></if>
<return>return <expr><name>d</name> &lt;= 1</expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>unmarshal_code</name><parameter_list>(<param><decl><type><name>char</name> *</type><name>pathname</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>data</name></decl></param>, <param><decl><type><name>time_t</name></type> <name>mtime</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>code</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>buf</name> <init>= <expr><call><name>PyString_AsString</name><argument_list>(<argument><expr><name>data</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>size</name> <init>= <expr><call><name>PyString_Size</name><argument_list>(<argument><expr><name>data</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>size</name> &lt;= 9</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>ZipImportError</name></expr></argument>,
<argument><expr>"bad pyc data"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<if>if <condition>(<expr><call><name>get_long</name><argument_list>(<argument><expr>(<name>unsigned</name> <name>char</name> *)<name>buf</name></expr></argument>)</argument_list></call> != <call><name>PyImport_GetMagicNumber</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
<if>if <condition>(<expr><name>Py_VerboseFlag</name></expr>)</condition><then>
<expr_stmt><expr><call><name>PySys_WriteStderr</name><argument_list>(<argument><expr>"#%s has bad magic\n"</expr></argument>,
<argument><expr><name>pathname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>Py_None</name></expr>;</return>
}</block></then></if>
<if>if <condition>(<expr><name>mtime</name> != 0 &amp;&amp; !<call><name>eq_mtime</name><argument_list>(<argument><expr><call><name>get_long</name><argument_list>(<argument><expr>(<name>unsigned</name> <name>char</name> *)<name>buf</name> + 4</expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>mtime</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<if>if <condition>(<expr><name>Py_VerboseFlag</name></expr>)</condition><then>
<expr_stmt><expr><call><name>PySys_WriteStderr</name><argument_list>(<argument><expr>"#%s has bad mtime\n"</expr></argument>,
<argument><expr><name>pathname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>Py_None</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>code</name> = <call><name>PyMarshal_ReadObjectFromString</name><argument_list>(<argument><expr><name>buf</name> + 8</expr></argument>, <argument><expr><name>size</name> - 8</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>code</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<if>if <condition>(<expr>!<call><name>PyCode_Check</name><argument_list>(<argument><expr><name>code</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>code</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
<argument><expr>"compiled module %.200s is not a code object"</expr></argument>,
<argument><expr><name>pathname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<return>return <expr><name>code</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>normalize_line_endings</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>source</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>char</name> *</type><name>buf</name></decl>, *<decl><type ref="prev"/><name>q</name></decl>, *<decl><type ref="prev"/><name>p</name> <init>= <expr><call><name>PyString_AsString</name><argument_list>(<argument><expr><name>source</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>fixed_source</name></decl>;</decl_stmt>
<if>if <condition>(<expr>!<name>p</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>buf</name> = (<name>char</name> *)<call><name>PyMem_Malloc</name><argument_list>(<argument><expr><call><name>PyString_Size</name><argument_list>(<argument><expr><name>source</name></expr></argument>)</argument_list></call> + 2</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>buf</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_MemoryError</name></expr></argument>,
<argument><expr>"zipimport: no memory to allocate "
"source buffer"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<for>for (<init><expr><name>q</name> = <name>buf</name></expr>;</init> <condition><expr>*<name>p</name> != '\0'</expr>;</condition> <incr><expr><name>p</name>++</expr></incr>) <block>{
<if>if <condition>(<expr>*<name>p</name> == '\r'</expr>)</condition><then> <block>{
<expr_stmt><expr>*<name>q</name>++ = '\n'</expr>;</expr_stmt>
<if>if <condition>(<expr>*(<name>p</name> + 1) == '\n'</expr>)</condition><then>
<expr_stmt><expr><name>p</name>++</expr>;</expr_stmt></then></if>
}</block></then> <else>else
<expr_stmt><expr>*<name>q</name>++ = *<name>p</name></expr>;</expr_stmt></else></if>
}</block></for>
<expr_stmt><expr>*<name>q</name>++ = '\n'</expr>;</expr_stmt>
<expr_stmt><expr>*<name>q</name> = '\0'</expr>;</expr_stmt>
<expr_stmt><expr><name>fixed_source</name> = <call><name>PyString_FromString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyMem_Free</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>fixed_source</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>compile_source</name><parameter_list>(<param><decl><type><name>char</name> *</type><name>pathname</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>source</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>code</name></decl>, *<decl><type ref="prev"/><name>fixed_source</name></decl>;</decl_stmt>
<expr_stmt><expr><name>fixed_source</name> = <call><name>normalize_line_endings</name><argument_list>(<argument><expr><name>source</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>fixed_source</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>code</name> = <call><name>Py_CompileString</name><argument_list>(<argument><expr><call><name>PyString_AsString</name><argument_list>(<argument><expr><name>fixed_source</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>pathname</name></expr></argument>,
<argument><expr><name>Py_file_input</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>fixed_source</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>code</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>time_t</name></type>
<name>parse_dostime</name><parameter_list>(<param><decl><type><name>int</name></type> <name>dostime</name></decl></param>, <param><decl><type><name>int</name></type> <name>dosdate</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type>struct <name>tm</name></type> <name>stm</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr>(<name>void</name> *) &amp;<name>stm</name></expr></argument>, <argument><expr>'\0'</expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>stm</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>stm</name>.<name>tm_sec</name></name> = (<name>dostime</name> &amp; 0x1f) * 2</expr>;</expr_stmt>
<expr_stmt><expr><name><name>stm</name>.<name>tm_min</name></name> = (<name>dostime</name> &gt;&gt; 5) &amp; 0x3f</expr>;</expr_stmt>
<expr_stmt><expr><name><name>stm</name>.<name>tm_hour</name></name> = (<name>dostime</name> &gt;&gt; 11) &amp; 0x1f</expr>;</expr_stmt>
<expr_stmt><expr><name><name>stm</name>.<name>tm_mday</name></name> = <name>dosdate</name> &amp; 0x1f</expr>;</expr_stmt>
<expr_stmt><expr><name><name>stm</name>.<name>tm_mon</name></name> = ((<name>dosdate</name> &gt;&gt; 5) &amp; 0x0f) - 1</expr>;</expr_stmt>
<expr_stmt><expr><name><name>stm</name>.<name>tm_year</name></name> = ((<name>dosdate</name> &gt;&gt; 9) &amp; 0x7f) + 80</expr>;</expr_stmt>
<expr_stmt><expr><name><name>stm</name>.<name>tm_isdst</name></name> = -1</expr>;</expr_stmt>
<return>return <expr><call><name>mktime</name><argument_list>(<argument><expr>&amp;<name>stm</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>time_t</name></type>
<name>get_mtime_of_source</name><parameter_list>(<param><decl><type><name>ZipImporter</name> *</type><name>self</name></decl></param>, <param><decl><type><name>char</name> *</type><name>path</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>toc_entry</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>time_t</name></type> <name>mtime</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>lastchar</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call> - 1</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name>savechar</name> <init>= <expr><name><name>path</name><index>[<expr><name>lastchar</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>path</name><index>[<expr><name>lastchar</name></expr>]</index></name> = '\0'</expr>;</expr_stmt>
<expr_stmt><expr><name>toc_entry</name> = <call><name>PyDict_GetItemString</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>files</name></name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>toc_entry</name> != <name>NULL</name> &amp;&amp; <call><name>PyTuple_Check</name><argument_list>(<argument><expr><name>toc_entry</name></expr></argument>)</argument_list></call> &amp;&amp;
<call><name>PyTuple_Size</name><argument_list>(<argument><expr><name>toc_entry</name></expr></argument>)</argument_list></call> == 8</expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>time</name></decl>, <decl><type ref="prev"/><name>date</name></decl>;</decl_stmt>
<expr_stmt><expr><name>time</name> = <call><name>PyInt_AsLong</name><argument_list>(<argument><expr><call><name>PyTuple_GetItem</name><argument_list>(<argument><expr><name>toc_entry</name></expr></argument>, <argument><expr>5</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>date</name> = <call><name>PyInt_AsLong</name><argument_list>(<argument><expr><call><name>PyTuple_GetItem</name><argument_list>(<argument><expr><name>toc_entry</name></expr></argument>, <argument><expr>6</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>mtime</name> = <call><name>parse_dostime</name><argument_list>(<argument><expr><name>time</name></expr></argument>, <argument><expr><name>date</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><name><name>path</name><index>[<expr><name>lastchar</name></expr>]</index></name> = <name>savechar</name></expr>;</expr_stmt>
<return>return <expr><name>mtime</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>get_code_from_data</name><parameter_list>(<param><decl><type><name>ZipImporter</name> *</type><name>self</name></decl></param>, <param><decl><type><name>int</name></type> <name>ispackage</name></decl></param>, <param><decl><type><name>int</name></type> <name>isbytecode</name></decl></param>,
<param><decl><type><name>time_t</name></type> <name>mtime</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>toc_entry</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>data</name></decl>, *<decl><type ref="prev"/><name>code</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>modpath</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>archive</name> <init>= <expr><call><name>PyString_AsString</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>archive</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>archive</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>data</name> = <call><name>get_data</name><argument_list>(<argument><expr><name>archive</name></expr></argument>, <argument><expr><name>toc_entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>data</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>modpath</name> = <call><name>PyString_AsString</name><argument_list>(<argument><expr><call><name>PyTuple_GetItem</name><argument_list>(<argument><expr><name>toc_entry</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>isbytecode</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>code</name> = <call><name>unmarshal_code</name><argument_list>(<argument><expr><name>modpath</name></expr></argument>, <argument><expr><name>data</name></expr></argument>, <argument><expr><name>mtime</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr><name>code</name> = <call><name>compile_source</name><argument_list>(<argument><expr><name>modpath</name></expr></argument>, <argument><expr><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></else></if>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>code</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>get_module_code</name><parameter_list>(<param><decl><type><name>ZipImporter</name> *</type><name>self</name></decl></param>, <param><decl><type><name>char</name> *</type><name>fullname</name></decl></param>,
<param><decl><type><name>int</name> *</type><name>p_ispackage</name></decl></param>, <param><decl><type><name>char</name> **</type><name>p_modpath</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>toc_entry</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>subname</name></decl>, <decl><type ref="prev"/><name><name>path</name><index>[<expr><name>MAXPATHLEN</name> + 1</expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>len</name></decl>;</decl_stmt>
<decl_stmt><decl><type>struct <name>st_zip_searchorder</name> *</type><name>zso</name></decl>;</decl_stmt>
<expr_stmt><expr><name>subname</name> = <call><name>get_subname</name><argument_list>(<argument><expr><name>fullname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>len</name> = <call><name>make_filename</name><argument_list>(<argument><expr><call><name>PyString_AsString</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>prefix</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>subname</name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>len</name> &lt; 0</expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<for>for (<init><expr><name>zso</name> = <name>zip_searchorder</name></expr>;</init> <condition><expr>*<name><name>zso</name>-&gt;<name>suffix</name></name></expr>;</condition> <incr><expr><name>zso</name>++</expr></incr>) <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>code</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>path</name> + <name>len</name></expr></argument>, <argument><expr><name><name>zso</name>-&gt;<name>suffix</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>Py_VerboseFlag</name> &gt; 1</expr>)</condition><then>
<expr_stmt><expr><call><name>PySys_WriteStderr</name><argument_list>(<argument><expr>"#trying %s%c%s\n"</expr></argument>,
<argument><expr><call><name>PyString_AsString</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>archive</name></name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>SEP</name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<expr_stmt><expr><name>toc_entry</name> = <call><name>PyDict_GetItemString</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>files</name></name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>toc_entry</name> != <name>NULL</name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>time_t</name></type> <name>mtime</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>ispackage</name> <init>= <expr><name><name>zso</name>-&gt;<name>type</name></name> &amp; <name>IS_PACKAGE</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>isbytecode</name> <init>= <expr><name><name>zso</name>-&gt;<name>type</name></name> &amp; <name>IS_BYTECODE</name></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>isbytecode</name></expr>)</condition><then>
<expr_stmt><expr><name>mtime</name> = <call><name>get_mtime_of_source</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<if>if <condition>(<expr><name>p_ispackage</name> != <name>NULL</name></expr>)</condition><then>
<expr_stmt><expr>*<name>p_ispackage</name> = <name>ispackage</name></expr>;</expr_stmt></then></if>
<expr_stmt><expr><name>code</name> = <call><name>get_code_from_data</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>ispackage</name></expr></argument>,
<argument><expr><name>isbytecode</name></expr></argument>, <argument><expr><name>mtime</name></expr></argument>,
<argument><expr><name>toc_entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>code</name> == <name>Py_None</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>code</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<continue>continue;</continue>
}</block></then></if>
<if>if <condition>(<expr><name>code</name> != <name>NULL</name> &amp;&amp; <name>p_modpath</name> != <name>NULL</name></expr>)</condition><then>
<expr_stmt><expr>*<name>p_modpath</name> = <call><name>PyString_AsString</name><argument_list>(
<argument><expr><call><name>PyTuple_GetItem</name><argument_list>(<argument><expr><name>toc_entry</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<return>return <expr><name>code</name></expr>;</return>
}</block></then></if>
}</block></for>
<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>ZipImportError</name></expr></argument>, <argument><expr>"can't find module '%.200s'"</expr></argument>, <argument><expr><name>fullname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>zipimport_doc</name></expr></argument>,
<argument><expr>"zipimport provides support for importing Python modules from Zip archives.\n\
\n\
This module exports three objects:\n\
- zipimporter: a class; its constructor takes a path to a Zip archive.\n\
- ZipImportError: exception raised by zipimporter objects. It's a\n\
subclass of ImportError, so it can be caught as ImportError, too.\n\
- _zip_directory_cache: a dict, mapping archive paths to zip directory\n\
info dicts, as used in zipimporter._files.\n\
\n\
It is usually not needed to use the zipimport module explicitly; it is\n\
used by the builtin import mechanism for sys.path items that are paths\n\
to Zip archives."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><name>PyMODINIT_FUNC</name></type>
<name>initzipimport</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>mod</name></decl>;</decl_stmt>
<if>if <condition>(<expr><call><name>PyType_Ready</name><argument_list>(<argument><expr>&amp;<name>ZipImporter_Type</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
<return>return;</return></then></if>
<expr_stmt><expr><name><name>zip_searchorder</name><index>[<expr>0</expr>]</index></name>.<name><name>suffix</name><index>[<expr>0</expr>]</index></name> = <name>SEP</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>zip_searchorder</name><index>[<expr>1</expr>]</index></name>.<name><name>suffix</name><index>[<expr>0</expr>]</index></name> = <name>SEP</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>zip_searchorder</name><index>[<expr>2</expr>]</index></name>.<name><name>suffix</name><index>[<expr>0</expr>]</index></name> = <name>SEP</name></expr>;</expr_stmt>
<if>if <condition>(<expr><name>Py_OptimizeFlag</name></expr>)</condition><then> <block>{
<decl_stmt><decl><type>struct <name>st_zip_searchorder</name></type> <name>tmp</name></decl>;</decl_stmt>
<expr_stmt><expr><name>tmp</name> = <name><name>zip_searchorder</name><index>[<expr>0</expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>zip_searchorder</name><index>[<expr>0</expr>]</index></name> = <name><name>zip_searchorder</name><index>[<expr>1</expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>zip_searchorder</name><index>[<expr>1</expr>]</index></name> = <name>tmp</name></expr>;</expr_stmt>
<expr_stmt><expr><name>tmp</name> = <name><name>zip_searchorder</name><index>[<expr>3</expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>zip_searchorder</name><index>[<expr>3</expr>]</index></name> = <name><name>zip_searchorder</name><index>[<expr>4</expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>zip_searchorder</name><index>[<expr>4</expr>]</index></name> = <name>tmp</name></expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><name>mod</name> = <call><name>Py_InitModule4</name><argument_list>(<argument><expr>"zipimport"</expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>zipimport_doc</name></expr></argument>,
<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>PYTHON_API_VERSION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>mod</name> == <name>NULL</name></expr>)</condition><then>
<return>return;</return></then></if>
<expr_stmt><expr><name>ZipImportError</name> = <call><name>PyErr_NewException</name><argument_list>(<argument><expr>"zipimport.ZipImportError"</expr></argument>,
<argument><expr><name>PyExc_ImportError</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>ZipImportError</name> == <name>NULL</name></expr>)</condition><then>
<return>return;</return></then></if>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>ZipImportError</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>PyModule_AddObject</name><argument_list>(<argument><expr><name>mod</name></expr></argument>, <argument><expr>"ZipImportError"</expr></argument>,
<argument><expr><name>ZipImportError</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
<return>return;</return></then></if>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr>&amp;<name>ZipImporter_Type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>PyModule_AddObject</name><argument_list>(<argument><expr><name>mod</name></expr></argument>, <argument><expr>"zipimporter"</expr></argument>,
<argument><expr>(<name>PyObject</name> *)&amp;<name>ZipImporter_Type</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
<return>return;</return></then></if>
<expr_stmt><expr><name>zip_directory_cache</name> = <call><name>PyDict_New</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>zip_directory_cache</name> == <name>NULL</name></expr>)</condition><then>
<return>return;</return></then></if>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>zip_directory_cache</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>PyModule_AddObject</name><argument_list>(<argument><expr><name>mod</name></expr></argument>, <argument><expr>"_zip_directory_cache"</expr></argument>,
<argument><expr><name>zip_directory_cache</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
<return>return;</return></then></if>
}</block></function>
</unit>
