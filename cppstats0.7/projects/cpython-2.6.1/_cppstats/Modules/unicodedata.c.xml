<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C" filename="Modules/unicodedata.c"><cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"Python.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ucnhash.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"structmember.h"</cpp:file></cpp:include>
<typedef>typedef <type><struct>struct <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name></type> <name>category</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name></type> <name>combining</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name></type> <name>bidirectional</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name></type> <name>mirrored</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name></type> <name>east_asian_width</name></decl>;</decl_stmt>
}</block></struct></type> <name>_PyUnicode_DatabaseRecord</name>;</typedef>
<typedef>typedef <type><struct>struct <name>change_record</name> <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name></type> <name>bidir_changed</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name></type> <name>category_changed</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name></type> <name>decimal_changed</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name></type> <name>mirrored_changed</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>numeric_changed</name></decl>;</decl_stmt>
}</block></struct></type> <name>change_record</name>;</typedef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"unicodedata_db.h"</cpp:file></cpp:include>
<function><type><specifier>static</specifier> <specifier>const</specifier> <name>_PyUnicode_DatabaseRecord</name>*</type>
<name>_getrecord_ex</name><parameter_list>(<param><decl><type><name>Py_UCS4</name></type> <name>code</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>index</name></decl>;</decl_stmt>
<if>if <condition>(<expr><name>code</name> &gt;= 0x110000</expr>)</condition><then>
<expr_stmt><expr><name>index</name> = 0</expr>;</expr_stmt></then>
<else>else <block>{
<expr_stmt><expr><name>index</name> = <name><name>index1</name><index>[<expr>(<name>code</name>&gt;&gt;<name>SHIFT</name>)</expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name>index</name> = <name><name>index2</name><index>[<expr>(<name>index</name>&lt;&lt;<name>SHIFT</name>)+(<name>code</name>&amp;((1&lt;&lt;<name>SHIFT</name>)-1))</expr>]</index></name></expr>;</expr_stmt>
}</block></else></if>
<return>return <expr>&amp;<name><name>_PyUnicode_Database_Records</name><index>[<expr><name>index</name></expr>]</index></name></expr>;</return>
}</block></function>
<typedef>typedef <type><struct>struct <name>previous_version</name> <block>{
<decl_stmt><decl><type><name>PyObject_HEAD</name>
<specifier>const</specifier> <name>char</name> *</type><name>name</name></decl>;</decl_stmt>
<function_decl><type><specifier>const</specifier> <name>change_record</name>*</type> (*<name>getrecord</name>)<parameter_list>(<param><decl><type><name>Py_UCS4</name></type></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><name>Py_UCS4</name></type> (*<name>normalization</name>)<parameter_list>(<param><decl><type><name>Py_UCS4</name></type></decl></param>)</parameter_list>;</function_decl>
}</block></struct></type> <name>PreviousDBVersion</name>;</typedef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>get_old_record</name><parameter_list>(<param><type><name>self</name></type></param>, <param><type><name>v</name></type></param>)</parameter_list></cpp:macro> <cpp:value>((((PreviousDBVersion*)self)-&gt;getrecord)(v))</cpp:value></cpp:define>
<decl_stmt><decl><type><specifier>static</specifier> <name>PyMemberDef</name></type> <name><name>DB_members</name><index>[]</index></name> <init>= <expr><block>{
<expr><block>{<expr>"unidata_version"</expr>, <expr><name>T_STRING</name></expr>, <expr><call><name>offsetof</name><argument_list>(<argument><expr><name>PreviousDBVersion</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>, <expr><name>READONLY</name></expr>}</block></expr>,
<expr><block>{<expr><name>NULL</name></expr>}</block></expr>
}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>PyTypeObject</name></type> <name>UCD_Type</name></decl>;</decl_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name>*</type>
<name>new_previous_version</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name>*</type><name>name</name></decl></param>, <param><function_decl><type><specifier>const</specifier> <name>change_record</name>*</type> (*<name>getrecord</name>)<parameter_list>(<param><decl><type><name>Py_UCS4</name></type></decl></param>)</parameter_list></function_decl></param>,
<param><function_decl><type><name>Py_UCS4</name></type> (*<name>normalization</name>)<parameter_list>(<param><decl><type><name>Py_UCS4</name></type></decl></param>)</parameter_list></function_decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PreviousDBVersion</name> *</type><name>self</name></decl>;</decl_stmt>
<expr_stmt><expr><name>self</name> = <call><name>PyObject_New</name><argument_list>(<argument><expr><name>PreviousDBVersion</name></expr></argument>, <argument><expr>&amp;<name>UCD_Type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>self</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name><name>self</name>-&gt;<name>name</name></name> = <name>name</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>self</name>-&gt;<name>getrecord</name></name> = <name>getrecord</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>self</name>-&gt;<name>normalization</name></name> = <name>normalization</name></expr>;</expr_stmt>
<return>return <expr>(<name>PyObject</name>*)<name>self</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>Py_UCS4</name></type> <name>getuchar</name><parameter_list>(<param><decl><type><name>PyUnicodeObject</name> *</type><name>obj</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>Py_UNICODE</name> *</type><name>v</name> <init>= <expr><call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><call><name>PyUnicode_GET_SIZE</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call> == 1</expr>)</condition><then>
<return>return <expr>*<name>v</name></expr>;</return></then>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>Py_UNICODE_WIDE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<else>else <if>if <condition>(<expr>(<call><name>PyUnicode_GET_SIZE</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call> == 2) &amp;&amp;
(0xD800 &lt;= <name><name>v</name><index>[<expr>0</expr>]</index></name> &amp;&amp; <name><name>v</name><index>[<expr>0</expr>]</index></name> &lt;= 0xDBFF) &amp;&amp;
(0xDC00 &lt;= <name><name>v</name><index>[<expr>1</expr>]</index></name> &amp;&amp; <name><name>v</name><index>[<expr>1</expr>]</index></name> &lt;= 0xDFFF)</expr>)</condition><then>
<return>return <expr>(((<name><name>v</name><index>[<expr>0</expr>]</index></name> &amp; 0x3FF)&lt;&lt;10) | (<name><name>v</name><index>[<expr>1</expr>]</index></name> &amp; 0x3FF)) + 0x10000</expr>;</return></then></if></else></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
<argument><expr>"need a single Unicode character as parameter"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>(<name>Py_UCS4</name>)-1</expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>unicodedata_decimal__doc__</name></expr></argument>,
<argument><expr>"decimal(unichr[, default])\n\
\n\
Returns the decimal value assigned to the Unicode character unichr\n\
as integer. If no such value is defined, default is returned, or, if\n\
not given, ValueError is raised."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>unicodedata_decimal</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyUnicodeObject</name> *</type><name>v</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>defobj</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>have_old</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>long</name></type> <name>rc</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_UCS4</name></type> <name>c</name></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"O!|O:decimal"</expr></argument>, <argument><expr>&amp;<name>PyUnicode_Type</name></expr></argument>, <argument><expr>&amp;<name>v</name></expr></argument>, <argument><expr>&amp;<name>defobj</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>c</name> = <call><name>getuchar</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>c</name> == (<name>Py_UCS4</name>)-1</expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<if>if <condition>(<expr><name>self</name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>change_record</name> *</type><name>old</name> <init>= <expr><call><name>get_old_record</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name><name>old</name>-&gt;<name>category_changed</name></name> == 0</expr>)</condition><then> <block>{
<expr_stmt><expr><name>have_old</name> = 1</expr>;</expr_stmt>
<expr_stmt><expr><name>rc</name> = -1</expr>;</expr_stmt>
}</block></then> <else>else <if>if <condition>(<expr><name><name>old</name>-&gt;<name>decimal_changed</name></name> != 0xFF</expr>)</condition><then> <block>{
<expr_stmt><expr><name>have_old</name> = 1</expr>;</expr_stmt>
<expr_stmt><expr><name>rc</name> = <name><name>old</name>-&gt;<name>decimal_changed</name></name></expr>;</expr_stmt>
}</block></then></if></else></if>
}</block></then></if>
<if>if <condition>(<expr>!<name>have_old</name></expr>)</condition><then>
<expr_stmt><expr><name>rc</name> = <call><name>Py_UNICODE_TODECIMAL</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<if>if <condition>(<expr><name>rc</name> &lt; 0</expr>)</condition><then> <block>{
<if>if <condition>(<expr><name>defobj</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>,
<argument><expr>"not a decimal"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then> <else>else <block>{
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>defobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>defobj</name></expr>;</return>
}</block></else></if>
}</block></then></if>
<return>return <expr><call><name>PyInt_FromLong</name><argument_list>(<argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>unicodedata_digit__doc__</name></expr></argument>,
<argument><expr>"digit(unichr[, default])\n\
\n\
Returns the digit value assigned to the Unicode character unichr as\n\
integer. If no such value is defined, default is returned, or, if\n\
not given, ValueError is raised."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>unicodedata_digit</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyUnicodeObject</name> *</type><name>v</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>defobj</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>long</name></type> <name>rc</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_UCS4</name></type> <name>c</name></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"O!|O:digit"</expr></argument>, <argument><expr>&amp;<name>PyUnicode_Type</name></expr></argument>, <argument><expr>&amp;<name>v</name></expr></argument>, <argument><expr>&amp;<name>defobj</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>c</name> = <call><name>getuchar</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>c</name> == (<name>Py_UCS4</name>)-1</expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>rc</name> = <call><name>Py_UNICODE_TODIGIT</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>rc</name> &lt; 0</expr>)</condition><then> <block>{
<if>if <condition>(<expr><name>defobj</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>, <argument><expr>"not a digit"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then> <else>else <block>{
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>defobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>defobj</name></expr>;</return>
}</block></else></if>
}</block></then></if>
<return>return <expr><call><name>PyInt_FromLong</name><argument_list>(<argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>unicodedata_numeric__doc__</name></expr></argument>,
<argument><expr>"numeric(unichr[, default])\n\
\n\
Returns the numeric value assigned to the Unicode character unichr\n\
as float. If no such value is defined, default is returned, or, if\n\
not given, ValueError is raised."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>unicodedata_numeric</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyUnicodeObject</name> *</type><name>v</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>defobj</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>have_old</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>double</name></type> <name>rc</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_UCS4</name></type> <name>c</name></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"O!|O:numeric"</expr></argument>, <argument><expr>&amp;<name>PyUnicode_Type</name></expr></argument>, <argument><expr>&amp;<name>v</name></expr></argument>, <argument><expr>&amp;<name>defobj</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>c</name> = <call><name>getuchar</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>c</name> == (<name>Py_UCS4</name>)-1</expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<if>if <condition>(<expr><name>self</name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>change_record</name> *</type><name>old</name> <init>= <expr><call><name>get_old_record</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name><name>old</name>-&gt;<name>category_changed</name></name> == 0</expr>)</condition><then> <block>{
<expr_stmt><expr><name>have_old</name> = 1</expr>;</expr_stmt>
<expr_stmt><expr><name>rc</name> = -1.0</expr>;</expr_stmt>
}</block></then> <else>else <if>if <condition>(<expr><name><name>old</name>-&gt;<name>decimal_changed</name></name> != 0xFF</expr>)</condition><then> <block>{
<expr_stmt><expr><name>have_old</name> = 1</expr>;</expr_stmt>
<expr_stmt><expr><name>rc</name> = <name><name>old</name>-&gt;<name>decimal_changed</name></name></expr>;</expr_stmt>
}</block></then></if></else></if>
}</block></then></if>
<if>if <condition>(<expr>!<name>have_old</name></expr>)</condition><then>
<expr_stmt><expr><name>rc</name> = <call><name>Py_UNICODE_TONUMERIC</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<if>if <condition>(<expr><name>rc</name> == -1.0</expr>)</condition><then> <block>{
<if>if <condition>(<expr><name>defobj</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>, <argument><expr>"not a numeric character"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then> <else>else <block>{
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>defobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>defobj</name></expr>;</return>
}</block></else></if>
}</block></then></if>
<return>return <expr><call><name>PyFloat_FromDouble</name><argument_list>(<argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>unicodedata_category__doc__</name></expr></argument>,
<argument><expr>"category(unichr)\n\
\n\
Returns the general category assigned to the Unicode character\n\
unichr as string."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>unicodedata_category</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyUnicodeObject</name> *</type><name>v</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>index</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_UCS4</name></type> <name>c</name></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"O!:category"</expr></argument>,
<argument><expr>&amp;<name>PyUnicode_Type</name></expr></argument>, <argument><expr>&amp;<name>v</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>c</name> = <call><name>getuchar</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>c</name> == (<name>Py_UCS4</name>)-1</expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>index</name> = (<name>int</name>) <call><name>_getrecord_ex</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call>-&gt;<name>category</name></expr>;</expr_stmt>
<if>if <condition>(<expr><name>self</name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>change_record</name> *</type><name>old</name> <init>= <expr><call><name>get_old_record</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name><name>old</name>-&gt;<name>category_changed</name></name> != 0xFF</expr>)</condition><then>
<expr_stmt><expr><name>index</name> = <name><name>old</name>-&gt;<name>category_changed</name></name></expr>;</expr_stmt></then></if>
}</block></then></if>
<return>return <expr><call><name>PyString_FromString</name><argument_list>(<argument><expr><name><name>_PyUnicode_CategoryNames</name><index>[<expr><name>index</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>unicodedata_bidirectional__doc__</name></expr></argument>,
<argument><expr>"bidirectional(unichr)\n\
\n\
Returns the bidirectional category assigned to the Unicode character\n\
unichr as string. If no such value is defined, an empty string is\n\
returned."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>unicodedata_bidirectional</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyUnicodeObject</name> *</type><name>v</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>index</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_UCS4</name></type> <name>c</name></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"O!:bidirectional"</expr></argument>,
<argument><expr>&amp;<name>PyUnicode_Type</name></expr></argument>, <argument><expr>&amp;<name>v</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>c</name> = <call><name>getuchar</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>c</name> == (<name>Py_UCS4</name>)-1</expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>index</name> = (<name>int</name>) <call><name>_getrecord_ex</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call>-&gt;<name>bidirectional</name></expr>;</expr_stmt>
<if>if <condition>(<expr><name>self</name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>change_record</name> *</type><name>old</name> <init>= <expr><call><name>get_old_record</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name><name>old</name>-&gt;<name>category_changed</name></name> == 0</expr>)</condition><then>
<expr_stmt><expr><name>index</name> = 0</expr>;</expr_stmt></then>
<else>else <if>if <condition>(<expr><name><name>old</name>-&gt;<name>bidir_changed</name></name> != 0xFF</expr>)</condition><then>
<expr_stmt><expr><name>index</name> = <name><name>old</name>-&gt;<name>bidir_changed</name></name></expr>;</expr_stmt></then></if></else></if>
}</block></then></if>
<return>return <expr><call><name>PyString_FromString</name><argument_list>(<argument><expr><name><name>_PyUnicode_BidirectionalNames</name><index>[<expr><name>index</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>unicodedata_combining__doc__</name></expr></argument>,
<argument><expr>"combining(unichr)\n\
\n\
Returns the canonical combining class assigned to the Unicode\n\
character unichr as integer. Returns 0 if no combining class is\n\
defined."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>unicodedata_combining</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyUnicodeObject</name> *</type><name>v</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>index</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_UCS4</name></type> <name>c</name></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"O!:combining"</expr></argument>,
<argument><expr>&amp;<name>PyUnicode_Type</name></expr></argument>, <argument><expr>&amp;<name>v</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>c</name> = <call><name>getuchar</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>c</name> == (<name>Py_UCS4</name>)-1</expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>index</name> = (<name>int</name>) <call><name>_getrecord_ex</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call>-&gt;<name>combining</name></expr>;</expr_stmt>
<if>if <condition>(<expr><name>self</name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>change_record</name> *</type><name>old</name> <init>= <expr><call><name>get_old_record</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name><name>old</name>-&gt;<name>category_changed</name></name> == 0</expr>)</condition><then>
<expr_stmt><expr><name>index</name> = 0</expr>;</expr_stmt></then></if>
}</block></then></if>
<return>return <expr><call><name>PyInt_FromLong</name><argument_list>(<argument><expr><name>index</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>unicodedata_mirrored__doc__</name></expr></argument>,
<argument><expr>"mirrored(unichr)\n\
\n\
Returns the mirrored property assigned to the Unicode character\n\
unichr as integer. Returns 1 if the character has been identified as\n\
a \"mirrored\" character in bidirectional text, 0 otherwise."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>unicodedata_mirrored</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyUnicodeObject</name> *</type><name>v</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>index</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_UCS4</name></type> <name>c</name></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"O!:mirrored"</expr></argument>,
<argument><expr>&amp;<name>PyUnicode_Type</name></expr></argument>, <argument><expr>&amp;<name>v</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>c</name> = <call><name>getuchar</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>c</name> == (<name>Py_UCS4</name>)-1</expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>index</name> = (<name>int</name>) <call><name>_getrecord_ex</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call>-&gt;<name>mirrored</name></expr>;</expr_stmt>
<if>if <condition>(<expr><name>self</name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>change_record</name> *</type><name>old</name> <init>= <expr><call><name>get_old_record</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name><name>old</name>-&gt;<name>category_changed</name></name> == 0</expr>)</condition><then>
<expr_stmt><expr><name>index</name> = 0</expr>;</expr_stmt></then>
<else>else <if>if <condition>(<expr><name><name>old</name>-&gt;<name>mirrored_changed</name></name> != 0xFF</expr>)</condition><then>
<expr_stmt><expr><name>index</name> = <name><name>old</name>-&gt;<name>mirrored_changed</name></name></expr>;</expr_stmt></then></if></else></if>
}</block></then></if>
<return>return <expr><call><name>PyInt_FromLong</name><argument_list>(<argument><expr><name>index</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>unicodedata_east_asian_width__doc__</name></expr></argument>,
<argument><expr>"east_asian_width(unichr)\n\
\n\
Returns the east asian width assigned to the Unicode character\n\
unichr as string."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>unicodedata_east_asian_width</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyUnicodeObject</name> *</type><name>v</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>index</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_UCS4</name></type> <name>c</name></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"O!:east_asian_width"</expr></argument>,
<argument><expr>&amp;<name>PyUnicode_Type</name></expr></argument>, <argument><expr>&amp;<name>v</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>c</name> = <call><name>getuchar</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>c</name> == (<name>Py_UCS4</name>)-1</expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>index</name> = (<name>int</name>) <call><name>_getrecord_ex</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call>-&gt;<name>east_asian_width</name></expr>;</expr_stmt>
<if>if <condition>(<expr><name>self</name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>change_record</name> *</type><name>old</name> <init>= <expr><call><name>get_old_record</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name><name>old</name>-&gt;<name>category_changed</name></name> == 0</expr>)</condition><then>
<expr_stmt><expr><name>index</name> = 0</expr>;</expr_stmt></then></if>
}</block></then></if>
<return>return <expr><call><name>PyString_FromString</name><argument_list>(<argument><expr><name><name>_PyUnicode_EastAsianWidthNames</name><index>[<expr><name>index</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>unicodedata_decomposition__doc__</name></expr></argument>,
<argument><expr>"decomposition(unichr)\n\
\n\
Returns the character decomposition mapping assigned to the Unicode\n\
character unichr as string. An empty string is returned in case no\n\
such mapping is defined."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>unicodedata_decomposition</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyUnicodeObject</name> *</type><name>v</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name><name>decomp</name><index>[<expr>256</expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>code</name></decl>, <decl><type ref="prev"/><name>index</name></decl>, <decl><type ref="prev"/><name>count</name></decl>, <decl><type ref="prev"/><name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>prefix_index</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_UCS4</name></type> <name>c</name></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"O!:decomposition"</expr></argument>,
<argument><expr>&amp;<name>PyUnicode_Type</name></expr></argument>, <argument><expr>&amp;<name>v</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>c</name> = <call><name>getuchar</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>c</name> == (<name>Py_UCS4</name>)-1</expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>code</name> = (<name>int</name>)<name>c</name></expr>;</expr_stmt>
<if>if <condition>(<expr><name>self</name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>change_record</name> *</type><name>old</name> <init>= <expr><call><name>get_old_record</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name><name>old</name>-&gt;<name>category_changed</name></name> == 0</expr>)</condition><then>
<return>return <expr><call><name>PyString_FromString</name><argument_list>(<argument><expr>""</expr></argument>)</argument_list></call></expr>;</return></then></if>
}</block></then></if>
<if>if <condition>(<expr><name>code</name> &lt; 0 || <name>code</name> &gt;= 0x110000</expr>)</condition><then>
<expr_stmt><expr><name>index</name> = 0</expr>;</expr_stmt></then>
<else>else <block>{
<expr_stmt><expr><name>index</name> = <name><name>decomp_index1</name><index>[<expr>(<name>code</name>&gt;&gt;<name>DECOMP_SHIFT</name>)</expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name>index</name> = <name><name>decomp_index2</name><index>[<expr>(<name>index</name>&lt;&lt;<name>DECOMP_SHIFT</name>)+
(<name>code</name>&amp;((1&lt;&lt;<name>DECOMP_SHIFT</name>)-1))</expr>]</index></name></expr>;</expr_stmt>
}</block></else></if>
<expr_stmt><expr><name>count</name> = <name><name>decomp_data</name><index>[<expr><name>index</name></expr>]</index></name> &gt;&gt; 8</expr>;</expr_stmt>
<expr_stmt><expr><name>prefix_index</name> = <name><name>decomp_data</name><index>[<expr><name>index</name></expr>]</index></name> &amp; 255</expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>prefix_index</name> &lt; (<sizeof>sizeof<argument_list>(<argument><expr><name>decomp_prefix</name></expr></argument>)</argument_list></sizeof>/<sizeof>sizeof<argument_list>(<argument><expr>*<name>decomp_prefix</name></expr></argument>)</argument_list></sizeof>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>i</name> = <call><name>strlen</name><argument_list>(<argument><expr><name><name>decomp_prefix</name><index>[<expr><name>prefix_index</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>decomp</name></expr></argument>, <argument><expr><name><name>decomp_prefix</name><index>[<expr><name>prefix_index</name></expr>]</index></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<while>while <condition>(<expr><name>count</name>-- &gt; 0</expr>)</condition> <block>{
<if>if <condition>(<expr><name>i</name></expr>)</condition><then>
<expr_stmt><expr><name><name>decomp</name><index>[<expr><name>i</name>++</expr>]</index></name> = ' '</expr>;</expr_stmt></then></if>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr>(<name>size_t</name>)<name>i</name> &lt; <sizeof>sizeof<argument_list>(<argument><expr><name>decomp</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyOS_snprintf</name><argument_list>(<argument><expr><name>decomp</name> + <name>i</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>decomp</name></expr></argument>)</argument_list></sizeof> - <name>i</name></expr></argument>, <argument><expr>"%04X"</expr></argument>,
<argument><expr><name><name>decomp_data</name><index>[<expr>++<name>index</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>i</name> += <call><name>strlen</name><argument_list>(<argument><expr><name>decomp</name> + <name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></while>
<expr_stmt><expr><name><name>decomp</name><index>[<expr><name>i</name></expr>]</index></name> = '\0'</expr>;</expr_stmt>
<return>return <expr><call><name>PyString_FromString</name><argument_list>(<argument><expr><name>decomp</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>get_decomp_record</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>Py_UCS4</name></type> <name>code</name></decl></param>, <param><decl><type><name>int</name> *</type><name>index</name></decl></param>, <param><decl><type><name>int</name> *</type><name>prefix</name></decl></param>, <param><decl><type><name>int</name> *</type><name>count</name></decl></param>)</parameter_list> <block>{
<if>if <condition>(<expr><name>code</name> &gt;= 0x110000</expr>)</condition><then> <block>{
<expr_stmt><expr>*<name>index</name> = 0</expr>;</expr_stmt>
}</block></then> <else>else <if>if <condition>(<expr><name>self</name> &amp;&amp; <call><name>get_old_record</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>code</name></expr></argument>)</argument_list></call>-&gt;<name>category_changed</name>==0</expr>)</condition><then> <block>{
<expr_stmt><expr>*<name>index</name> = 0</expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr>*<name>index</name> = <name><name>decomp_index1</name><index>[<expr>(<name>code</name>&gt;&gt;<name>DECOMP_SHIFT</name>)</expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr>*<name>index</name> = <name><name>decomp_index2</name><index>[<expr>(*<name>index</name>&lt;&lt;<name>DECOMP_SHIFT</name>)+
(<name>code</name>&amp;((1&lt;&lt;<name>DECOMP_SHIFT</name>)-1))</expr>]</index></name></expr>;</expr_stmt>
}</block></else></if></else></if>
<expr_stmt><expr>*<name>count</name> = <name><name>decomp_data</name><index>[<expr>*<name>index</name></expr>]</index></name> &gt;&gt; 8</expr>;</expr_stmt>
<expr_stmt><expr>*<name>prefix</name> = <name><name>decomp_data</name><index>[<expr>*<name>index</name></expr>]</index></name> &amp; 255</expr>;</expr_stmt>
<expr_stmt><expr>(*<name>index</name>)++</expr>;</expr_stmt>
}</block></function>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SBase</name></cpp:macro> <cpp:value>0xAC00</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LBase</name></cpp:macro> <cpp:value>0x1100</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>VBase</name></cpp:macro> <cpp:value>0x1161</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TBase</name></cpp:macro> <cpp:value>0x11A7</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LCount</name></cpp:macro> <cpp:value>19</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>VCount</name></cpp:macro> <cpp:value>21</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TCount</name></cpp:macro> <cpp:value>28</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NCount</name></cpp:macro> <cpp:value>(VCount*TCount)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SCount</name></cpp:macro> <cpp:value>(LCount*NCount)</cpp:value></cpp:define>
<function><type><specifier>static</specifier> <name>PyObject</name>*</type>
<name>nfd_nfkd</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>input</name></decl></param>, <param><decl><type><name>int</name></type> <name>k</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>result</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_UNICODE</name> *</type><name>i</name></decl>, *<decl><type ref="prev"/><name>end</name></decl>, *<decl><type ref="prev"/><name>o</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_UNICODE</name></type> <name><name>stack</name><index>[<expr>20</expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>space</name></decl>, <decl><type ref="prev"/><name>isize</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>index</name></decl>, <decl><type ref="prev"/><name>prefix</name></decl>, <decl><type ref="prev"/><name>count</name></decl>, <decl><type ref="prev"/><name>stackptr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name>prev</name></decl>, <decl><type ref="prev"/><name>cur</name></decl>;</decl_stmt>
<expr_stmt><expr><name>stackptr</name> = 0</expr>;</expr_stmt>
<expr_stmt><expr><name>isize</name> = <call><name>PyUnicode_GET_SIZE</name><argument_list>(<argument><expr><name>input</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>space</name> = (<name>isize</name> &gt; 10 ? 10 : <name>isize</name>) + <name>isize</name></expr>;</expr_stmt>
<expr_stmt><expr><name>result</name> = <call><name>PyUnicode_FromUnicode</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>space</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>result</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>i</name> = <call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr><name>input</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>end</name> = <name>i</name> + <name>isize</name></expr>;</expr_stmt>
<expr_stmt><expr><name>o</name> = <call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<while>while <condition>(<expr><name>i</name> &lt; <name>end</name></expr>)</condition> <block>{
<expr_stmt><expr><name><name>stack</name><index>[<expr><name>stackptr</name>++</expr>]</index></name> = *<name>i</name>++</expr>;</expr_stmt>
<while>while<condition>(<expr><name>stackptr</name></expr>)</condition> <block>{
<decl_stmt><decl><type><name>Py_UNICODE</name></type> <name>code</name> <init>= <expr><name><name>stack</name><index>[<expr>--<name>stackptr</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>space</name> &lt; 3</expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>newsize</name> <init>= <expr><call><name>PyString_GET_SIZE</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call> + 10</expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>space</name> += 10</expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>PyUnicode_Resize</name><argument_list>(<argument><expr>&amp;<name>result</name></expr></argument>, <argument><expr><name>newsize</name></expr></argument>)</argument_list></call> == -1</expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>o</name> = <call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call> + <name>newsize</name> - <name>space</name></expr>;</expr_stmt>
}</block></then></if>
<if>if <condition>(<expr><name>SBase</name> &lt;= <name>code</name> &amp;&amp; <name>code</name> &lt; (<name>SBase</name>+<name>SCount</name>)</expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>SIndex</name> <init>= <expr><name>code</name> - <name>SBase</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>L</name> <init>= <expr><name>LBase</name> + <name>SIndex</name> / <name>NCount</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>V</name> <init>= <expr><name>VBase</name> + (<name>SIndex</name> % <name>NCount</name>) / <name>TCount</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>T</name> <init>= <expr><name>TBase</name> + <name>SIndex</name> % <name>TCount</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr>*<name>o</name>++ = <name>L</name></expr>;</expr_stmt>
<expr_stmt><expr>*<name>o</name>++ = <name>V</name></expr>;</expr_stmt>
<expr_stmt><expr><name>space</name> -= 2</expr>;</expr_stmt>
<if>if <condition>(<expr><name>T</name> != <name>TBase</name></expr>)</condition><then> <block>{
<expr_stmt><expr>*<name>o</name>++ = <name>T</name></expr>;</expr_stmt>
<expr_stmt><expr><name>space</name> --</expr>;</expr_stmt>
}</block></then></if>
<continue>continue;</continue>
}</block></then></if>
<if>if <condition>(<expr><name>self</name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>Py_UCS4</name></type> <name>value</name> <init>= <expr>((<name>PreviousDBVersion</name>*)<name>self</name>)-&gt;<call><name>normalization</name><argument_list>(<argument><expr><name>code</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>value</name> != 0</expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>stack</name><index>[<expr><name>stackptr</name>++</expr>]</index></name> = <name>value</name></expr>;</expr_stmt>
<continue>continue;</continue>
}</block></then></if>
}</block></then></if>
<expr_stmt><expr><call><name>get_decomp_record</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>code</name></expr></argument>, <argument><expr>&amp;<name>index</name></expr></argument>, <argument><expr>&amp;<name>prefix</name></expr></argument>, <argument><expr>&amp;<name>count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>count</name> || (<name>prefix</name> &amp;&amp; !<name>k</name>)</expr>)</condition><then> <block>{
<expr_stmt><expr>*<name>o</name>++ = <name>code</name></expr>;</expr_stmt>
<expr_stmt><expr><name>space</name>--</expr>;</expr_stmt>
<continue>continue;</continue>
}</block></then></if>
<while>while<condition>(<expr><name>count</name></expr>)</condition> <block>{
<expr_stmt><expr><name>code</name> = <name><name>decomp_data</name><index>[<expr><name>index</name> + (--<name>count</name>)</expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>stack</name><index>[<expr><name>stackptr</name>++</expr>]</index></name> = <name>code</name></expr>;</expr_stmt>
}</block></while>
}</block></while>
}</block></while>
<expr_stmt><expr><call><name>PyUnicode_Resize</name><argument_list>(<argument><expr>&amp;<name>result</name></expr></argument>, <argument><expr><call><name>PyUnicode_GET_SIZE</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call> - <name>space</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>i</name> = <call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>prev</name> = <call><name>_getrecord_ex</name><argument_list>(<argument><expr>*<name>i</name></expr></argument>)</argument_list></call>-&gt;<name>combining</name></expr>;</expr_stmt>
<expr_stmt><expr><name>end</name> = <name>i</name> + <call><name>PyUnicode_GET_SIZE</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for (<init><expr><name>i</name>++</expr>;</init> <condition><expr><name>i</name> &lt; <name>end</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
<expr_stmt><expr><name>cur</name> = <call><name>_getrecord_ex</name><argument_list>(<argument><expr>*<name>i</name></expr></argument>)</argument_list></call>-&gt;<name>combining</name></expr>;</expr_stmt>
<if>if <condition>(<expr><name>prev</name> == 0 || <name>cur</name> == 0 || <name>prev</name> &lt;= <name>cur</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>prev</name> = <name>cur</name></expr>;</expr_stmt>
<continue>continue;</continue>
}</block></then></if>
<expr_stmt><expr><name>o</name> = <name>i</name> - 1</expr>;</expr_stmt>
<while>while <condition>(<expr>1</expr>)</condition> <block>{
<decl_stmt><decl><type><name>Py_UNICODE</name></type> <name>tmp</name> <init>= <expr><name><name>o</name><index>[<expr>1</expr>]</index></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>o</name><index>[<expr>1</expr>]</index></name> = <name><name>o</name><index>[<expr>0</expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>o</name><index>[<expr>0</expr>]</index></name> = <name>tmp</name></expr>;</expr_stmt>
<expr_stmt><expr><name>o</name>--</expr>;</expr_stmt>
<if>if <condition>(<expr><name>o</name> &lt; <call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<break>break;</break></then></if>
<expr_stmt><expr><name>prev</name> = <call><name>_getrecord_ex</name><argument_list>(<argument><expr>*<name>o</name></expr></argument>)</argument_list></call>-&gt;<name>combining</name></expr>;</expr_stmt>
<if>if <condition>(<expr><name>prev</name> == 0 || <name>prev</name> &lt;= <name>cur</name></expr>)</condition><then>
<break>break;</break></then></if>
}</block></while>
<expr_stmt><expr><name>prev</name> = <call><name>_getrecord_ex</name><argument_list>(<argument><expr>*<name>i</name></expr></argument>)</argument_list></call>-&gt;<name>combining</name></expr>;</expr_stmt>
}</block></for>
<return>return <expr><name>result</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>find_nfc_index</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type>struct <name>reindex</name>*</type> <name>nfc</name></decl></param>, <param><decl><type><name>Py_UNICODE</name></type> <name>code</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>index</name></decl>;</decl_stmt>
<for>for (<init><expr><name>index</name> = 0</expr>;</init> <condition><expr><name><name>nfc</name><index>[<expr><name>index</name></expr>]</index></name>.<name>start</name></expr>;</condition> <incr><expr><name>index</name>++</expr></incr>) <block>{
<decl_stmt><decl><type><name>int</name></type> <name>start</name> <init>= <expr><name><name>nfc</name><index>[<expr><name>index</name></expr>]</index></name>.<name>start</name></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>code</name> &lt; <name>start</name></expr>)</condition><then>
<return>return <expr>-1</expr>;</return></then></if>
<if>if <condition>(<expr><name>code</name> &lt;= <name>start</name> + <name><name>nfc</name><index>[<expr><name>index</name></expr>]</index></name>.<name>count</name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>delta</name> <init>= <expr><name>code</name> - <name>start</name></expr></init></decl>;</decl_stmt>
<return>return <expr><name><name>nfc</name><index>[<expr><name>index</name></expr>]</index></name>.<name>index</name> + <name>delta</name></expr>;</return>
}</block></then></if>
}</block></for>
<return>return <expr>-1</expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name>*</type>
<name>nfc_nfkc</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>input</name></decl></param>, <param><decl><type><name>int</name></type> <name>k</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>result</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_UNICODE</name> *</type><name>i</name></decl>, *<decl><type ref="prev"/><name>i1</name></decl>, *<decl><type ref="prev"/><name>o</name></decl>, *<decl><type ref="prev"/><name>end</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>f</name></decl>,<decl><type ref="prev"/><name>l</name></decl>,<decl><type ref="prev"/><name>index</name></decl>,<decl><type ref="prev"/><name>index1</name></decl>,<decl><type ref="prev"/><name>comb</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_UNICODE</name></type> <name>code</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_UNICODE</name> *</type><name><name>skipped</name><index>[<expr>20</expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>cskipped</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>result</name> = <call><name>nfd_nfkd</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>input</name></expr></argument>, <argument><expr><name>k</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>result</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>result</name> != <name>input</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>i</name> = <call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>end</name> = <name>i</name> + <call><name>PyUnicode_GET_SIZE</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>o</name> = <call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<label><name>again</name>:</label>
<while>while <condition>(<expr><name>i</name> &lt; <name>end</name></expr>)</condition> <block>{
<for>for (<init><expr><name>index</name> = 0</expr>;</init> <condition><expr><name>index</name> &lt; <name>cskipped</name></expr>;</condition> <incr><expr><name>index</name>++</expr></incr>) <block>{
<if>if <condition>(<expr><name><name>skipped</name><index>[<expr><name>index</name></expr>]</index></name> == <name>i</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>skipped</name><index>[<expr><name>index</name></expr>]</index></name> = <name><name>skipped</name><index>[<expr><name>cskipped</name>-1</expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name>cskipped</name>--</expr>;</expr_stmt>
<expr_stmt><expr><name>i</name>++</expr>;</expr_stmt>
<goto>goto <name>again</name>;</goto>
}</block></then></if>
}</block></for>
<if>if <condition>(<expr><name>LBase</name> &lt;= *<name>i</name> &amp;&amp; *<name>i</name> &lt; (<name>LBase</name>+<name>LCount</name>) &amp;&amp;
<name>i</name> + 1 &lt; <name>end</name> &amp;&amp;
<name>VBase</name> &lt;= <name><name>i</name><index>[<expr>1</expr>]</index></name> &amp;&amp; <name><name>i</name><index>[<expr>1</expr>]</index></name> &lt;= (<name>VBase</name>+<name>VCount</name>)</expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>LIndex</name></decl>, <decl><type ref="prev"/><name>VIndex</name></decl>;</decl_stmt>
<expr_stmt><expr><name>LIndex</name> = <name><name>i</name><index>[<expr>0</expr>]</index></name> - <name>LBase</name></expr>;</expr_stmt>
<expr_stmt><expr><name>VIndex</name> = <name><name>i</name><index>[<expr>1</expr>]</index></name> - <name>VBase</name></expr>;</expr_stmt>
<expr_stmt><expr><name>code</name> = <name>SBase</name> + (<name>LIndex</name>*<name>VCount</name>+<name>VIndex</name>)*<name>TCount</name></expr>;</expr_stmt>
<expr_stmt><expr><name>i</name>+=2</expr>;</expr_stmt>
<if>if <condition>(<expr><name>i</name> &lt; <name>end</name> &amp;&amp;
<name>TBase</name> &lt;= *<name>i</name> &amp;&amp; *<name>i</name> &lt;= (<name>TBase</name>+<name>TCount</name>)</expr>)</condition><then> <block>{
<expr_stmt><expr><name>code</name> += *<name>i</name>-<name>TBase</name></expr>;</expr_stmt>
<expr_stmt><expr><name>i</name>++</expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr>*<name>o</name>++ = <name>code</name></expr>;</expr_stmt>
<continue>continue;</continue>
}</block></then></if>
<expr_stmt><expr><name>f</name> = <call><name>find_nfc_index</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>nfc_first</name></expr></argument>, <argument><expr>*<name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>f</name> == -1</expr>)</condition><then> <block>{
<expr_stmt><expr>*<name>o</name>++ = *<name>i</name>++</expr>;</expr_stmt>
<continue>continue;</continue>
}</block></then></if>
<expr_stmt><expr><name>i1</name> = <name>i</name>+1</expr>;</expr_stmt>
<expr_stmt><expr><name>comb</name> = 0</expr>;</expr_stmt>
<while>while <condition>(<expr><name>i1</name> &lt; <name>end</name></expr>)</condition> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>comb1</name> <init>= <expr><call><name>_getrecord_ex</name><argument_list>(<argument><expr>*<name>i1</name></expr></argument>)</argument_list></call>-&gt;<name>combining</name></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>comb1</name> &amp;&amp; <name>comb</name> == <name>comb1</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>i1</name>++</expr>;</expr_stmt>
<continue>continue;</continue>
}</block></then></if>
<expr_stmt><expr><name>l</name> = <call><name>find_nfc_index</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>nfc_last</name></expr></argument>, <argument><expr>*<name>i1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>l</name> == -1</expr>)</condition><then> <block>{
<label><name>not_combinable</name>:</label>
<if>if <condition>(<expr><name>comb1</name> == 0</expr>)</condition><then>
<break>break;</break></then></if>
<expr_stmt><expr><name>comb</name> = <name>comb1</name></expr>;</expr_stmt>
<expr_stmt><expr><name>i1</name>++</expr>;</expr_stmt>
<continue>continue;</continue>
}</block></then></if>
<expr_stmt><expr><name>index</name> = <name>f</name>*<name>TOTAL_LAST</name> + <name>l</name></expr>;</expr_stmt>
<expr_stmt><expr><name>index1</name> = <name><name>comp_index</name><index>[<expr><name>index</name> &gt;&gt; <name>COMP_SHIFT</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name>code</name> = <name><name>comp_data</name><index>[<expr>(<name>index1</name>&lt;&lt;<name>COMP_SHIFT</name>)+
(<name>index</name>&amp;((1&lt;&lt;<name>COMP_SHIFT</name>)-1))</expr>]</index></name></expr>;</expr_stmt>
<if>if <condition>(<expr><name>code</name> == 0</expr>)</condition><then>
<goto>goto <name>not_combinable</name>;</goto></then></if>
<expr_stmt><expr>*<name>i</name> = <name>code</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>skipped</name><index>[<expr><name>cskipped</name>++</expr>]</index></name> = <name>i1</name></expr>;</expr_stmt>
<expr_stmt><expr><name>i1</name>++</expr>;</expr_stmt>
<expr_stmt><expr><name>f</name> = <call><name>find_nfc_index</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>nfc_first</name></expr></argument>, <argument><expr>*<name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>f</name> == -1</expr>)</condition><then>
<break>break;</break></then></if>
}</block></while>
<expr_stmt><expr>*<name>o</name>++ = *<name>i</name>++</expr>;</expr_stmt>
}</block></while>
<if>if <condition>(<expr><name>o</name> != <name>end</name></expr>)</condition><then>
<expr_stmt><expr><call><name>PyUnicode_Resize</name><argument_list>(<argument><expr>&amp;<name>result</name></expr></argument>, <argument><expr><name>o</name> - <call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<return>return <expr><name>result</name></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>unicodedata_normalize__doc__</name></expr></argument>,
<argument><expr>"normalize(form, unistr)\n\
\n\
Return the normal form 'form' for the Unicode string unistr. Valid\n\
values for form are 'NFC', 'NFKC', 'NFD', and 'NFKD'."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name>*</type>
<name>unicodedata_normalize</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>char</name> *</type><name>form</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>input</name></decl>;</decl_stmt>
<if>if<condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"sO!:normalize"</expr></argument>,
<argument><expr>&amp;<name>form</name></expr></argument>, <argument><expr>&amp;<name>PyUnicode_Type</name></expr></argument>, <argument><expr>&amp;<name>input</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<if>if <condition>(<expr><call><name>PyUnicode_GetSize</name><argument_list>(<argument><expr><name>input</name></expr></argument>)</argument_list></call> == 0</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>input</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>input</name></expr>;</return>
}</block></then></if>
<if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>form</name></expr></argument>, <argument><expr>"NFC"</expr></argument>)</argument_list></call> == 0</expr>)</condition><then>
<return>return <expr><call><name>nfc_nfkc</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>input</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</return></then></if>
<if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>form</name></expr></argument>, <argument><expr>"NFKC"</expr></argument>)</argument_list></call> == 0</expr>)</condition><then>
<return>return <expr><call><name>nfc_nfkc</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>input</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</return></then></if>
<if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>form</name></expr></argument>, <argument><expr>"NFD"</expr></argument>)</argument_list></call> == 0</expr>)</condition><then>
<return>return <expr><call><name>nfd_nfkd</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>input</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</return></then></if>
<if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>form</name></expr></argument>, <argument><expr>"NFKD"</expr></argument>)</argument_list></call> == 0</expr>)</condition><then>
<return>return <expr><call><name>nfd_nfkd</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>input</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</return></then></if>
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>, <argument><expr>"invalid normalization form"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></function>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"unicodename_db.h"</cpp:file></cpp:include>
<function><type><specifier>static</specifier> <name>unsigned</name> <name>long</name></type>
<name>_gethash</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>s</name></decl></param>, <param><decl><type><name>int</name></type> <name>len</name></decl></param>, <param><decl><type><name>int</name></type> <name>scale</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>h</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>ix</name></decl>;</decl_stmt>
<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>len</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
<expr_stmt><expr><name>h</name> = (<name>h</name> * <name>scale</name>) + (<name>unsigned</name> <name>char</name>) <call><name>toupper</name><argument_list>(<argument><expr><call><name>Py_CHARMASK</name><argument_list>(<argument><expr><name><name>s</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ix</name> = <name>h</name> &amp; 0xff000000</expr>;</expr_stmt>
<if>if <condition>(<expr><name>ix</name></expr>)</condition><then>
<expr_stmt><expr><name>h</name> = (<name>h</name> ^ ((<name>ix</name>&gt;&gt;24) &amp; 0xff)) &amp; 0x00ffffff</expr>;</expr_stmt></then></if>
}</block></for>
<return>return <expr><name>h</name></expr>;</return>
}</block></function>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> *</type><name><name>hangul_syllables</name><index>[]</index><index>[<expr>3</expr>]</index></name> <init>= <expr><block>{
<expr><block>{ <expr>"G"</expr>, <expr>"A"</expr>, <expr>""</expr> }</block></expr>,
<expr><block>{ <expr>"GG"</expr>, <expr>"AE"</expr>, <expr>"G"</expr> }</block></expr>,
<expr><block>{ <expr>"N"</expr>, <expr>"YA"</expr>, <expr>"GG"</expr> }</block></expr>,
<expr><block>{ <expr>"D"</expr>, <expr>"YAE"</expr>, <expr>"GS"</expr> }</block></expr>,
<expr><block>{ <expr>"DD"</expr>, <expr>"EO"</expr>, <expr>"N"</expr>, }</block></expr>,
<expr><block>{ <expr>"R"</expr>, <expr>"E"</expr>, <expr>"NJ"</expr> }</block></expr>,
<expr><block>{ <expr>"M"</expr>, <expr>"YEO"</expr>, <expr>"NH"</expr> }</block></expr>,
<expr><block>{ <expr>"B"</expr>, <expr>"YE"</expr>, <expr>"D"</expr> }</block></expr>,
<expr><block>{ <expr>"BB"</expr>, <expr>"O"</expr>, <expr>"L"</expr> }</block></expr>,
<expr><block>{ <expr>"S"</expr>, <expr>"WA"</expr>, <expr>"LG"</expr> }</block></expr>,
<expr><block>{ <expr>"SS"</expr>, <expr>"WAE"</expr>, <expr>"LM"</expr> }</block></expr>,
<expr><block>{ <expr>""</expr>, <expr>"OE"</expr>, <expr>"LB"</expr> }</block></expr>,
<expr><block>{ <expr>"J"</expr>, <expr>"YO"</expr>, <expr>"LS"</expr> }</block></expr>,
<expr><block>{ <expr>"JJ"</expr>, <expr>"U"</expr>, <expr>"LT"</expr> }</block></expr>,
<expr><block>{ <expr>"C"</expr>, <expr>"WEO"</expr>, <expr>"LP"</expr> }</block></expr>,
<expr><block>{ <expr>"K"</expr>, <expr>"WE"</expr>, <expr>"LH"</expr> }</block></expr>,
<expr><block>{ <expr>"T"</expr>, <expr>"WI"</expr>, <expr>"M"</expr> }</block></expr>,
<expr><block>{ <expr>"P"</expr>, <expr>"YU"</expr>, <expr>"B"</expr> }</block></expr>,
<expr><block>{ <expr>"H"</expr>, <expr>"EU"</expr>, <expr>"BS"</expr> }</block></expr>,
<expr><block>{ <expr>0</expr>, <expr>"YI"</expr>, <expr>"S"</expr> }</block></expr>,
<expr><block>{ <expr>0</expr>, <expr>"I"</expr>, <expr>"SS"</expr> }</block></expr>,
<expr><block>{ <expr>0</expr>, <expr>0</expr>, <expr>"NG"</expr> }</block></expr>,
<expr><block>{ <expr>0</expr>, <expr>0</expr>, <expr>"J"</expr> }</block></expr>,
<expr><block>{ <expr>0</expr>, <expr>0</expr>, <expr>"C"</expr> }</block></expr>,
<expr><block>{ <expr>0</expr>, <expr>0</expr>, <expr>"K"</expr> }</block></expr>,
<expr><block>{ <expr>0</expr>, <expr>0</expr>, <expr>"T"</expr> }</block></expr>,
<expr><block>{ <expr>0</expr>, <expr>0</expr>, <expr>"P"</expr> }</block></expr>,
<expr><block>{ <expr>0</expr>, <expr>0</expr>, <expr>"H"</expr> }</block></expr>
}</block></expr></init></decl>;</decl_stmt>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>is_unified_ideograph</name><parameter_list>(<param><decl><type><name>Py_UCS4</name></type> <name>code</name></decl></param>)</parameter_list> <block>{
<return>return <expr>(
(0x3400 &lt;= <name>code</name> &amp;&amp; <name>code</name> &lt;= 0x4DB5) ||
(0x4E00 &lt;= <name>code</name> &amp;&amp; <name>code</name> &lt;= 0x9FBB) ||
(0x20000 &lt;= <name>code</name> &amp;&amp; <name>code</name> &lt;= 0x2A6D6))</expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>_getucname</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>Py_UCS4</name></type> <name>code</name></decl></param>, <param><decl><type><name>char</name>*</type> <name>buffer</name></decl></param>, <param><decl><type><name>int</name></type> <name>buflen</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>offset</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>word</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name>*</type> <name>w</name></decl>;</decl_stmt>
<if>if <condition>(<expr><name>code</name> &gt;= 0x110000</expr>)</condition><then>
<return>return <expr>0</expr>;</return></then></if>
<if>if <condition>(<expr><name>self</name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>change_record</name> *</type><name>old</name> <init>= <expr><call><name>get_old_record</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>code</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name><name>old</name>-&gt;<name>category_changed</name></name> == 0</expr>)</condition><then> <block>{
<return>return <expr>0</expr>;</return>
}</block></then></if>
}</block></then></if>
<if>if <condition>(<expr><name>SBase</name> &lt;= <name>code</name> &amp;&amp; <name>code</name> &lt; <name>SBase</name>+<name>SCount</name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>SIndex</name> <init>= <expr><name>code</name> - <name>SBase</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>L</name> <init>= <expr><name>SIndex</name> / <name>NCount</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>V</name> <init>= <expr>(<name>SIndex</name> % <name>NCount</name>) / <name>TCount</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>T</name> <init>= <expr><name>SIndex</name> % <name>TCount</name></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>buflen</name> &lt; 27</expr>)</condition><then>
<return>return <expr>0</expr>;</return></then></if>
<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr>"HANGUL SYLLABLE "</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>buffer</name> += 16</expr>;</expr_stmt>
<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name><name>hangul_syllables</name><index>[<expr><name>L</name></expr>]</index><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>buffer</name> += <call><name>strlen</name><argument_list>(<argument><expr><name><name>hangul_syllables</name><index>[<expr><name>L</name></expr>]</index><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name><name>hangul_syllables</name><index>[<expr><name>V</name></expr>]</index><index>[<expr>1</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>buffer</name> += <call><name>strlen</name><argument_list>(<argument><expr><name><name>hangul_syllables</name><index>[<expr><name>V</name></expr>]</index><index>[<expr>1</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name><name>hangul_syllables</name><index>[<expr><name>T</name></expr>]</index><index>[<expr>2</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>buffer</name> += <call><name>strlen</name><argument_list>(<argument><expr><name><name>hangul_syllables</name><index>[<expr><name>T</name></expr>]</index><index>[<expr>2</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr>*<name>buffer</name> = '\0'</expr>;</expr_stmt>
<return>return <expr>1</expr>;</return>
}</block></then></if>
<if>if <condition>(<expr><call><name>is_unified_ideograph</name><argument_list>(<argument><expr><name>code</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<if>if <condition>(<expr><name>buflen</name> &lt; 28</expr>)</condition><then>
<return>return <expr>0</expr>;</return></then></if>
<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr>"CJK UNIFIED IDEOGRAPH-%X"</expr></argument>, <argument><expr><name>code</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>1</expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>offset</name> = <name><name>phrasebook_offset1</name><index>[<expr>(<name>code</name>&gt;&gt;<name>phrasebook_shift</name>)</expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name>offset</name> = <name><name>phrasebook_offset2</name><index>[<expr>(<name>offset</name>&lt;&lt;<name>phrasebook_shift</name>) +
(<name>code</name>&amp;((1&lt;&lt;<name>phrasebook_shift</name>)-1))</expr>]</index></name></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>offset</name></expr>)</condition><then>
<return>return <expr>0</expr>;</return></then></if>
<expr_stmt><expr><name>i</name> = 0</expr>;</expr_stmt>
<for>for (<init>;</init><condition>;</condition><incr/>) <block>{
<expr_stmt><expr><name>word</name> = <name><name>phrasebook</name><index>[<expr><name>offset</name></expr>]</index></name> - <name>phrasebook_short</name></expr>;</expr_stmt>
<if>if <condition>(<expr><name>word</name> &gt;= 0</expr>)</condition><then> <block>{
<expr_stmt><expr><name>word</name> = (<name>word</name> &lt;&lt; 8) + <name><name>phrasebook</name><index>[<expr><name>offset</name>+1</expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name>offset</name> += 2</expr>;</expr_stmt>
}</block></then> <else>else
<expr_stmt><expr><name>word</name> = <name><name>phrasebook</name><index>[<expr><name>offset</name>++</expr>]</index></name></expr>;</expr_stmt></else></if>
<if>if <condition>(<expr><name>i</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr><name>i</name> &gt; <name>buflen</name></expr>)</condition><then>
<return>return <expr>0</expr>;</return></then></if>
<expr_stmt><expr><name><name>buffer</name><index>[<expr><name>i</name>++</expr>]</index></name> = ' '</expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><name>w</name> = <name>lexicon</name> + <name><name>lexicon_offset</name><index>[<expr><name>word</name></expr>]</index></name></expr>;</expr_stmt>
<while>while <condition>(<expr>*<name>w</name> &lt; 128</expr>)</condition> <block>{
<if>if <condition>(<expr><name>i</name> &gt;= <name>buflen</name></expr>)</condition><then>
<return>return <expr>0</expr>;</return></then></if>
<expr_stmt><expr><name><name>buffer</name><index>[<expr><name>i</name>++</expr>]</index></name> = *<name>w</name>++</expr>;</expr_stmt>
}</block></while>
<if>if <condition>(<expr><name>i</name> &gt;= <name>buflen</name></expr>)</condition><then>
<return>return <expr>0</expr>;</return></then></if>
<expr_stmt><expr><name><name>buffer</name><index>[<expr><name>i</name>++</expr>]</index></name> = *<name>w</name> &amp; 127</expr>;</expr_stmt>
<if>if <condition>(<expr>*<name>w</name> == 128</expr>)</condition><then>
<break>break;</break></then></if>
}</block></for>
<return>return <expr>1</expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>_cmpname</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>int</name></type> <name>code</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name>*</type> <name>name</name></decl></param>, <param><decl><type><name>int</name></type> <name>namelen</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name><name>buffer</name><index>[<expr><name>NAME_MAXLEN</name></expr>]</index></name></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>_getucname</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>code</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr>0</expr>;</return></then></if>
<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>namelen</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
<if>if <condition>(<expr><call><name>toupper</name><argument_list>(<argument><expr><call><name>Py_CHARMASK</name><argument_list>(<argument><expr><name><name>name</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> != <name><name>buffer</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><then>
<return>return <expr>0</expr>;</return></then></if>
}</block></for>
<return>return <expr><name><name>buffer</name><index>[<expr><name>namelen</name></expr>]</index></name> == '\0'</expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>find_syllable</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>str</name></decl></param>, <param><decl><type><name>int</name> *</type><name>len</name></decl></param>, <param><decl><type><name>int</name> *</type><name>pos</name></decl></param>, <param><decl><type><name>int</name></type> <name>count</name></decl></param>, <param><decl><type><name>int</name></type> <name>column</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>len1</name></decl>;</decl_stmt>
<expr_stmt><expr>*<name>len</name> = -1</expr>;</expr_stmt>
<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>count</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
<decl_stmt><decl><type><name>char</name> *</type><name>s</name> <init>= <expr><name><name>hangul_syllables</name><index>[<expr><name>i</name></expr>]</index><index>[<expr><name>column</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>len1</name> = <call><name>strlen</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>len1</name> &lt;= *<name>len</name></expr>)</condition><then>
<continue>continue;</continue></then></if>
<if>if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>len1</name></expr></argument>)</argument_list></call> == 0</expr>)</condition><then> <block>{
<expr_stmt><expr>*<name>len</name> = <name>len1</name></expr>;</expr_stmt>
<expr_stmt><expr>*<name>pos</name> = <name>i</name></expr>;</expr_stmt>
}</block></then></if>
}</block></for>
<if>if <condition>(<expr>*<name>len</name> == -1</expr>)</condition><then> <block>{
<expr_stmt><expr>*<name>len</name> = 0</expr>;</expr_stmt>
}</block></then></if>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>_getcode</name><parameter_list>(<param><decl><type><name>PyObject</name>*</type> <name>self</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name>*</type> <name>name</name></decl></param>, <param><decl><type><name>int</name></type> <name>namelen</name></decl></param>, <param><decl><type><name>Py_UCS4</name>*</type> <name>code</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>h</name></decl>, <decl><type ref="prev"/><name>v</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>mask</name> <init>= <expr><name>code_size</name>-1</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>incr</name></decl>;</decl_stmt>
<if>if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr>"HANGUL SYLLABLE "</expr></argument>, <argument><expr>16</expr></argument>)</argument_list></call> == 0</expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>len</name></decl>, <decl><type ref="prev"/><name>L</name> <init>= <expr>-1</expr></init>, <name>V</name> <init>= <expr>-1</expr></init>, <name>T</name> <init>= <expr>-1</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>pos</name> <init>= <expr><name>name</name> + 16</expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>find_syllable</name><argument_list>(<argument><expr><name>pos</name></expr></argument>, <argument><expr>&amp;<name>len</name></expr></argument>, <argument><expr>&amp;<name>L</name></expr></argument>, <argument><expr><name>LCount</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>pos</name> += <name>len</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>find_syllable</name><argument_list>(<argument><expr><name>pos</name></expr></argument>, <argument><expr>&amp;<name>len</name></expr></argument>, <argument><expr>&amp;<name>V</name></expr></argument>, <argument><expr><name>VCount</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>pos</name> += <name>len</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>find_syllable</name><argument_list>(<argument><expr><name>pos</name></expr></argument>, <argument><expr>&amp;<name>len</name></expr></argument>, <argument><expr>&amp;<name>T</name></expr></argument>, <argument><expr><name>TCount</name></expr></argument>, <argument><expr>2</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>pos</name> += <name>len</name></expr>;</expr_stmt>
<if>if <condition>(<expr><name>L</name> != -1 &amp;&amp; <name>V</name> != -1 &amp;&amp; <name>T</name> != -1 &amp;&amp; <name>pos</name>-<name>name</name> == <name>namelen</name></expr>)</condition><then> <block>{
<expr_stmt><expr>*<name>code</name> = <name>SBase</name> + (<name>L</name>*<name>VCount</name>+<name>V</name>)*<name>TCount</name> + <name>T</name></expr>;</expr_stmt>
<return>return <expr>1</expr>;</return>
}</block></then></if>
<return>return <expr>0</expr>;</return>
}</block></then></if>
<if>if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr>"CJK UNIFIED IDEOGRAPH-"</expr></argument>, <argument><expr>22</expr></argument>)</argument_list></call> == 0</expr>)</condition><then> <block>{
<expr_stmt><expr><name>v</name> = 0</expr>;</expr_stmt>
<expr_stmt><expr><name>name</name> += 22</expr>;</expr_stmt>
<expr_stmt><expr><name>namelen</name> -= 22</expr>;</expr_stmt>
<if>if <condition>(<expr><name>namelen</name> != 4 &amp;&amp; <name>namelen</name> != 5</expr>)</condition><then>
<return>return <expr>0</expr>;</return></then></if>
<while>while <condition>(<expr><name>namelen</name>--</expr>)</condition> <block>{
<expr_stmt><expr><name>v</name> *= 16</expr>;</expr_stmt>
<if>if <condition>(<expr>*<name>name</name> &gt;= '0' &amp;&amp; *<name>name</name> &lt;= '9'</expr>)</condition><then>
<expr_stmt><expr><name>v</name> += *<name>name</name> - '0'</expr>;</expr_stmt></then>
<else>else <if>if <condition>(<expr>*<name>name</name> &gt;= 'A' &amp;&amp; *<name>name</name> &lt;= 'F'</expr>)</condition><then>
<expr_stmt><expr><name>v</name> += *<name>name</name> - 'A' + 10</expr>;</expr_stmt></then>
<else>else
<return>return <expr>0</expr>;</return></else></if></else></if>
<expr_stmt><expr><name>name</name>++</expr>;</expr_stmt>
}</block></while>
<if>if <condition>(<expr>!<call><name>is_unified_ideograph</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr>0</expr>;</return></then></if>
<expr_stmt><expr>*<name>code</name> = <name>v</name></expr>;</expr_stmt>
<return>return <expr>1</expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>h</name> = (<name>unsigned</name> <name>int</name>) <call><name>_gethash</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>namelen</name></expr></argument>, <argument><expr><name>code_magic</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>i</name> = (~<name>h</name>) &amp; <name>mask</name></expr>;</expr_stmt>
<expr_stmt><expr><name>v</name> = <name><name>code_hash</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>v</name></expr>)</condition><then>
<return>return <expr>0</expr>;</return></then></if>
<if>if <condition>(<expr><call><name>_cmpname</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>v</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>namelen</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr>*<name>code</name> = <name>v</name></expr>;</expr_stmt>
<return>return <expr>1</expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>incr</name> = (<name>h</name> ^ (<name>h</name> &gt;&gt; 3)) &amp; <name>mask</name></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>incr</name></expr>)</condition><then>
<expr_stmt><expr><name>incr</name> = <name>mask</name></expr>;</expr_stmt></then></if>
<for>for (<init>;</init><condition>;</condition><incr/>) <block>{
<expr_stmt><expr><name>i</name> = (<name>i</name> + <name>incr</name>) &amp; <name>mask</name></expr>;</expr_stmt>
<expr_stmt><expr><name>v</name> = <name><name>code_hash</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>v</name></expr>)</condition><then>
<return>return <expr>0</expr>;</return></then></if>
<if>if <condition>(<expr><call><name>_cmpname</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>v</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>namelen</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr>*<name>code</name> = <name>v</name></expr>;</expr_stmt>
<return>return <expr>1</expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>incr</name> = <name>incr</name> &lt;&lt; 1</expr>;</expr_stmt>
<if>if <condition>(<expr><name>incr</name> &gt; <name>mask</name></expr>)</condition><then>
<expr_stmt><expr><name>incr</name> = <name>incr</name> ^ <name>code_poly</name></expr>;</expr_stmt></then></if>
}</block></for>
}</block></function>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>_PyUnicode_Name_CAPI</name></type> <name>hashAPI</name> <init>= <expr><block>{
<expr><sizeof>sizeof<argument_list>(<argument><expr><name>_PyUnicode_Name_CAPI</name></expr></argument>)</argument_list></sizeof></expr>,
<expr><name>_getucname</name></expr>,
<expr><name>_getcode</name></expr>
}</block></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>unicodedata_name__doc__</name></expr></argument>,
<argument><expr>"name(unichr[, default])\n\
Returns the name assigned to the Unicode character unichr as a\n\
string. If no name is defined, default is returned, or, if not\n\
given, ValueError is raised."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>unicodedata_name</name><parameter_list>(<param><decl><type><name>PyObject</name>*</type> <name>self</name></decl></param>, <param><decl><type><name>PyObject</name>*</type> <name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>char</name></type> <name><name>name</name><index>[<expr><name>NAME_MAXLEN</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_UCS4</name></type> <name>c</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyUnicodeObject</name>*</type> <name>v</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name>*</type> <name>defobj</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"O!|O:name"</expr></argument>, <argument><expr>&amp;<name>PyUnicode_Type</name></expr></argument>, <argument><expr>&amp;<name>v</name></expr></argument>, <argument><expr>&amp;<name>defobj</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>c</name> = <call><name>getuchar</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>c</name> == (<name>Py_UCS4</name>)-1</expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<if>if <condition>(<expr>!<call><name>_getucname</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<if>if <condition>(<expr><name>defobj</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>, <argument><expr>"no such name"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then> <else>else <block>{
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>defobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>defobj</name></expr>;</return>
}</block></else></if>
}</block></then></if>
<return>return <expr><call><name>Py_BuildValue</name><argument_list>(<argument><expr>"s"</expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>unicodedata_lookup__doc__</name></expr></argument>,
<argument><expr>"lookup(name)\n\
\n\
Look up character by name. If a character with the\n\
given name is found, return the corresponding Unicode\n\
character. If not found, KeyError is raised."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>unicodedata_lookup</name><parameter_list>(<param><decl><type><name>PyObject</name>*</type> <name>self</name></decl></param>, <param><decl><type><name>PyObject</name>*</type> <name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>Py_UCS4</name></type> <name>code</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_UNICODE</name></type> <name><name>str</name><index>[<expr>2</expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name>*</type> <name>name</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>namelen</name></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"s#:lookup"</expr></argument>, <argument><expr>&amp;<name>name</name></expr></argument>, <argument><expr>&amp;<name>namelen</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<if>if <condition>(<expr>!<call><name>_getcode</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>namelen</name></expr></argument>, <argument><expr>&amp;<name>code</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_KeyError</name></expr></argument>, <argument><expr>"undefined character name '%s'"</expr></argument>,
<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>Py_UNICODE_WIDE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if>if <condition>(<expr><name>code</name> &gt;= 0x10000</expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>str</name><index>[<expr>0</expr>]</index></name> = 0xd800 + ((<name>code</name> - 0x10000) &gt;&gt; 10)</expr>;</expr_stmt>
<expr_stmt><expr><name><name>str</name><index>[<expr>1</expr>]</index></name> = 0xdc00 + ((<name>code</name> - 0x10000) &amp; 0x3ff)</expr>;</expr_stmt>
<return>return <expr><call><name>PyUnicode_FromUnicode</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr>2</expr></argument>)</argument_list></call></expr>;</return>
}</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><name><name>str</name><index>[<expr>0</expr>]</index></name> = (<name>Py_UNICODE</name>) <name>code</name></expr>;</expr_stmt>
<return>return <expr><call><name>PyUnicode_FromUnicode</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<decl_stmt><decl><type><specifier>static</specifier> <name>PyMethodDef</name></type> <name><name>unicodedata_functions</name><index>[]</index></name> <init>= <expr><block>{
<expr><block>{<expr>"decimal"</expr>, <expr><name>unicodedata_decimal</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>unicodedata_decimal__doc__</name></expr>}</block></expr>,
<expr><block>{<expr>"digit"</expr>, <expr><name>unicodedata_digit</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>unicodedata_digit__doc__</name></expr>}</block></expr>,
<expr><block>{<expr>"numeric"</expr>, <expr><name>unicodedata_numeric</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>unicodedata_numeric__doc__</name></expr>}</block></expr>,
<expr><block>{
<expr>"category"</expr>, <expr><name>unicodedata_category</name></expr>, <expr><name>METH_VARARGS</name></expr>,
<expr><name>unicodedata_category__doc__</name></expr>
}</block></expr>,
<expr><block>{
<expr>"bidirectional"</expr>, <expr><name>unicodedata_bidirectional</name></expr>, <expr><name>METH_VARARGS</name></expr>,
<expr><name>unicodedata_bidirectional__doc__</name></expr>
}</block></expr>,
<expr><block>{
<expr>"combining"</expr>, <expr><name>unicodedata_combining</name></expr>, <expr><name>METH_VARARGS</name></expr>,
<expr><name>unicodedata_combining__doc__</name></expr>
}</block></expr>,
<expr><block>{
<expr>"mirrored"</expr>, <expr><name>unicodedata_mirrored</name></expr>, <expr><name>METH_VARARGS</name></expr>,
<expr><name>unicodedata_mirrored__doc__</name></expr>
}</block></expr>,
<expr><block>{
<expr>"east_asian_width"</expr>, <expr><name>unicodedata_east_asian_width</name></expr>, <expr><name>METH_VARARGS</name></expr>,
<expr><name>unicodedata_east_asian_width__doc__</name></expr>
}</block></expr>,
<expr><block>{
<expr>"decomposition"</expr>, <expr><name>unicodedata_decomposition</name></expr>, <expr><name>METH_VARARGS</name></expr>,
<expr><name>unicodedata_decomposition__doc__</name></expr>
}</block></expr>,
<expr><block>{<expr>"name"</expr>, <expr><name>unicodedata_name</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>unicodedata_name__doc__</name></expr>}</block></expr>,
<expr><block>{<expr>"lookup"</expr>, <expr><name>unicodedata_lookup</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>unicodedata_lookup__doc__</name></expr>}</block></expr>,
<expr><block>{
<expr>"normalize"</expr>, <expr><name>unicodedata_normalize</name></expr>, <expr><name>METH_VARARGS</name></expr>,
<expr><name>unicodedata_normalize__doc__</name></expr>
}</block></expr>,
<expr><block>{<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>}</block></expr>
}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>PyTypeObject</name></type> <name>UCD_Type</name> <init>= <expr><block>{
<expr><call><name>PyVarObject_HEAD_INIT</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call>
"unicodedata.UCD"</expr>,
<expr><sizeof>sizeof<argument_list>(<argument><expr><name>PreviousDBVersion</name></expr></argument>)</argument_list></sizeof></expr>,
<expr>0</expr>,
<expr>(<name>destructor</name>)<name>PyObject_Del</name></expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr><name>PyObject_GenericGetAttr</name></expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr><name>Py_TPFLAGS_DEFAULT</name></expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr><name>unicodedata_functions</name></expr>,
<expr><name>DB_members</name></expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
}</block></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>unicodedata_docstring</name></expr></argument>,
<argument><expr>"This module provides access to the Unicode Character Database which\n\
defines character properties for all Unicode characters. The data in\n\
this database is based on the UnicodeData.txt file version\n\
5.1.0 which is publically available from ftp://ftp.unicode.org/.\n\
\n\
The module uses the same names and symbols as defined by the\n\
UnicodeData File Format 5.1.0 (see\n\
http://www.unicode.org/Public/5.1.0/ucd/UCD.html)."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><name>PyMODINIT_FUNC</name></type>
<name>initunicodedata</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>m</name></decl>, *<decl><type ref="prev"/><name>v</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>Py_TYPE</name><argument_list>(<argument><expr>&amp;<name>UCD_Type</name></expr></argument>)</argument_list></call> = &amp;<name>PyType_Type</name></expr>;</expr_stmt>
<expr_stmt><expr><name>m</name> = <call><name>Py_InitModule3</name><argument_list>(
<argument><expr>"unicodedata"</expr></argument>, <argument><expr><name>unicodedata_functions</name></expr></argument>, <argument><expr><name>unicodedata_docstring</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>m</name></expr>)</condition><then>
<return>return;</return></then></if>
<expr_stmt><expr><call><name>PyModule_AddStringConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"unidata_version"</expr></argument>, <argument><expr><name>UNIDATA_VERSION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr>&amp;<name>UCD_Type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyModule_AddObject</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"UCD"</expr></argument>, <argument><expr>(<name>PyObject</name>*)&amp;<name>UCD_Type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>v</name> = <call><name>new_previous_version</name><argument_list>(<argument><expr>"3.2.0"</expr></argument>, <argument><expr><name>get_change_3_2_0</name></expr></argument>, <argument><expr><name>normalization_3_2_0</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>v</name> != <name>NULL</name></expr>)</condition><then>
<expr_stmt><expr><call><name>PyModule_AddObject</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"ucd_3_2_0"</expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<expr_stmt><expr><name>v</name> = <call><name>PyCObject_FromVoidPtr</name><argument_list>(<argument><expr>(<name>void</name> *) &amp;<name>hashAPI</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>v</name> != <name>NULL</name></expr>)</condition><then>
<expr_stmt><expr><call><name>PyModule_AddObject</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"ucnhash_CAPI"</expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
}</block></function>
</unit>
