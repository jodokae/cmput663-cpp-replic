<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C" filename="projects/cpython-2.6.1/_cppstats/Modules/gcmodule.c"><cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"Python.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"frameobject.h"</cpp:file></cpp:include>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AS_GC</name><parameter_list>(<param><type><name>o</name></type></param>)</parameter_list></cpp:macro> <cpp:value>((PyGC_Head *)(o)-1)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FROM_GC</name><parameter_list>(<param><type><name>g</name></type></param>)</parameter_list></cpp:macro> <cpp:value>((PyObject *)(((PyGC_Head *)g)+1))</cpp:value></cpp:define>
<struct>struct <name>gc_generation</name> <block>{
<decl_stmt><decl><type><name>PyGC_Head</name></type> <name>head</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>threshold</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>count</name></decl>;</decl_stmt>
}</block>;</struct>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NUM_GENERATIONS</name></cpp:macro> <cpp:value>3</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GEN_HEAD</name><parameter_list>(<param><type><name>n</name></type></param>)</parameter_list></cpp:macro> <cpp:value>(&amp;generations[n].head)</cpp:value></cpp:define>
<decl_stmt><decl><type><specifier>static</specifier> struct <name>gc_generation</name></type> <name><name>generations</name><index>[<expr><name>NUM_GENERATIONS</name></expr>]</index></name> <init>= <expr><block>{
<expr><block>{<expr><block>{<expr><block>{<expr><call><name>GEN_HEAD</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>, <expr><call><name>GEN_HEAD</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>, <expr>0</expr>}</block></expr>}</block></expr>, <expr>700</expr>, <expr>0</expr>}</block></expr>,
<expr><block>{<expr><block>{<expr><block>{<expr><call><name>GEN_HEAD</name><argument_list>(<argument><expr>1</expr></argument>)</argument_list></call></expr>, <expr><call><name>GEN_HEAD</name><argument_list>(<argument><expr>1</expr></argument>)</argument_list></call></expr>, <expr>0</expr>}</block></expr>}</block></expr>, <expr>10</expr>, <expr>0</expr>}</block></expr>,
<expr><block>{<expr><block>{<expr><block>{<expr><call><name>GEN_HEAD</name><argument_list>(<argument><expr>2</expr></argument>)</argument_list></call></expr>, <expr><call><name>GEN_HEAD</name><argument_list>(<argument><expr>2</expr></argument>)</argument_list></call></expr>, <expr>0</expr>}</block></expr>}</block></expr>, <expr>10</expr>, <expr>0</expr>}</block></expr>,
}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyGC_Head</name> *</type><name>_PyGC_generation0</name> <init>= <expr><call><name>GEN_HEAD</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>enabled</name> <init>= <expr>1</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>collecting</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>PyObject</name> *</type><name>garbage</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>PyObject</name> *</type><name>gc_str</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>PyObject</name> *</type><name>delstr</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DEBUG_STATS</name></cpp:macro> <cpp:value>(1&lt;&lt;0)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DEBUG_COLLECTABLE</name></cpp:macro> <cpp:value>(1&lt;&lt;1)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DEBUG_UNCOLLECTABLE</name></cpp:macro> <cpp:value>(1&lt;&lt;2)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DEBUG_INSTANCES</name></cpp:macro> <cpp:value>(1&lt;&lt;3)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DEBUG_OBJECTS</name></cpp:macro> <cpp:value>(1&lt;&lt;4)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DEBUG_SAVEALL</name></cpp:macro> <cpp:value>(1&lt;&lt;5)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DEBUG_LEAK</name></cpp:macro> <cpp:value>DEBUG_COLLECTABLE | DEBUG_UNCOLLECTABLE | DEBUG_INSTANCES | DEBUG_OBJECTS | DEBUG_SAVEALL</cpp:value></cpp:define>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>debug</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>PyObject</name> *</type><name>tmod</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GC_UNTRACKED</name></cpp:macro> <cpp:value>_PyGC_REFS_UNTRACKED</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GC_REACHABLE</name></cpp:macro> <cpp:value>_PyGC_REFS_REACHABLE</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GC_TENTATIVELY_UNREACHABLE</name></cpp:macro> <cpp:value>_PyGC_REFS_TENTATIVELY_UNREACHABLE</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IS_TRACKED</name><parameter_list>(<param><type><name>o</name></type></param>)</parameter_list></cpp:macro> <cpp:value>((AS_GC(o))-&gt;gc.gc_refs != GC_UNTRACKED)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IS_REACHABLE</name><parameter_list>(<param><type><name>o</name></type></param>)</parameter_list></cpp:macro> <cpp:value>((AS_GC(o))-&gt;gc.gc_refs == GC_REACHABLE)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IS_TENTATIVELY_UNREACHABLE</name><parameter_list>(<param><type><name>o</name></type></param>)</parameter_list></cpp:macro> <cpp:value>( (AS_GC(o))-&gt;gc.gc_refs == GC_TENTATIVELY_UNREACHABLE)</cpp:value></cpp:define>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>gc_list_init</name><parameter_list>(<param><decl><type><name>PyGC_Head</name> *</type><name>list</name></decl></param>)</parameter_list> <block>{
<expr_stmt><expr><name><name>list</name>-&gt;<name>gc</name>.<name>gc_prev</name></name> = <name>list</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>list</name>-&gt;<name>gc</name>.<name>gc_next</name></name> = <name>list</name></expr>;</expr_stmt>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>gc_list_is_empty</name><parameter_list>(<param><decl><type><name>PyGC_Head</name> *</type><name>list</name></decl></param>)</parameter_list> <block>{
<return>return <expr>(<name><name>list</name>-&gt;<name>gc</name>.<name>gc_next</name></name> == <name>list</name>)</expr>;</return>
}</block></function>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>0</expr></cpp:if>
static void
gc_list_append(PyGC_Head *node, PyGC_Head *list) {
node-&gt;gc.gc_next = list;
node-&gt;gc.gc_prev = list-&gt;gc.gc_prev;
node-&gt;gc.gc_prev-&gt;gc.gc_next = node;
list-&gt;gc.gc_prev = node;
}
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>gc_list_remove</name><parameter_list>(<param><decl><type><name>PyGC_Head</name> *</type><name>node</name></decl></param>)</parameter_list> <block>{
<expr_stmt><expr><name><name>node</name>-&gt;<name>gc</name>.<name>gc_prev</name>-&gt;<name>gc</name>.<name>gc_next</name></name> = <name><name>node</name>-&gt;<name>gc</name>.<name>gc_next</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>node</name>-&gt;<name>gc</name>.<name>gc_next</name>-&gt;<name>gc</name>.<name>gc_prev</name></name> = <name><name>node</name>-&gt;<name>gc</name>.<name>gc_prev</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>node</name>-&gt;<name>gc</name>.<name>gc_next</name></name> = <name>NULL</name></expr>;</expr_stmt>
}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>gc_list_move</name><parameter_list>(<param><decl><type><name>PyGC_Head</name> *</type><name>node</name></decl></param>, <param><decl><type><name>PyGC_Head</name> *</type><name>list</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyGC_Head</name> *</type><name>new_prev</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyGC_Head</name> *</type><name>current_prev</name> <init>= <expr><name><name>node</name>-&gt;<name>gc</name>.<name>gc_prev</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyGC_Head</name> *</type><name>current_next</name> <init>= <expr><name><name>node</name>-&gt;<name>gc</name>.<name>gc_next</name></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>current_prev</name>-&gt;<name>gc</name>.<name>gc_next</name></name> = <name>current_next</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>current_next</name>-&gt;<name>gc</name>.<name>gc_prev</name></name> = <name>current_prev</name></expr>;</expr_stmt>
<expr_stmt><expr><name>new_prev</name> = <name><name>node</name>-&gt;<name>gc</name>.<name>gc_prev</name></name> = <name><name>list</name>-&gt;<name>gc</name>.<name>gc_prev</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>new_prev</name>-&gt;<name>gc</name>.<name>gc_next</name></name> = <name><name>list</name>-&gt;<name>gc</name>.<name>gc_prev</name></name> = <name>node</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>node</name>-&gt;<name>gc</name>.<name>gc_next</name></name> = <name>list</name></expr>;</expr_stmt>
}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>gc_list_merge</name><parameter_list>(<param><decl><type><name>PyGC_Head</name> *</type><name>from</name></decl></param>, <param><decl><type><name>PyGC_Head</name> *</type><name>to</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyGC_Head</name> *</type><name>tail</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>from</name> != <name>to</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<call><name>gc_list_is_empty</name><argument_list>(<argument><expr><name>from</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><name>tail</name> = <name><name>to</name>-&gt;<name>gc</name>.<name>gc_prev</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tail</name>-&gt;<name>gc</name>.<name>gc_next</name></name> = <name><name>from</name>-&gt;<name>gc</name>.<name>gc_next</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tail</name>-&gt;<name>gc</name>.<name>gc_next</name>-&gt;<name>gc</name>.<name>gc_prev</name></name> = <name>tail</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>to</name>-&gt;<name>gc</name>.<name>gc_prev</name></name> = <name><name>from</name>-&gt;<name>gc</name>.<name>gc_prev</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>to</name>-&gt;<name>gc</name>.<name>gc_prev</name>-&gt;<name>gc</name>.<name>gc_next</name></name> = <name>to</name></expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><call><name>gc_list_init</name><argument_list>(<argument><expr><name>from</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>
<function><type><specifier>static</specifier> <name>Py_ssize_t</name></type>
<name>gc_list_size</name><parameter_list>(<param><decl><type><name>PyGC_Head</name> *</type><name>list</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyGC_Head</name> *</type><name>gc</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>n</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<for>for (<init><expr><name>gc</name> = <name><name>list</name>-&gt;<name>gc</name>.<name>gc_next</name></name></expr>;</init> <condition><expr><name>gc</name> != <name>list</name></expr>;</condition> <incr><expr><name>gc</name> = <name><name>gc</name>-&gt;<name>gc</name>.<name>gc_next</name></name></expr></incr>) <block>{
<expr_stmt><expr><name>n</name>++</expr>;</expr_stmt>
}</block></for>
<return>return <expr><name>n</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>append_objects</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>py_list</name></decl></param>, <param><decl><type><name>PyGC_Head</name> *</type><name>gc_list</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyGC_Head</name> *</type><name>gc</name></decl>;</decl_stmt>
<for>for (<init><expr><name>gc</name> = <name><name>gc_list</name>-&gt;<name>gc</name>.<name>gc_next</name></name></expr>;</init> <condition><expr><name>gc</name> != <name>gc_list</name></expr>;</condition> <incr><expr><name>gc</name> = <name><name>gc</name>-&gt;<name>gc</name>.<name>gc_next</name></name></expr></incr>) <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>op</name> <init>= <expr><call><name>FROM_GC</name><argument_list>(<argument><expr><name>gc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>op</name> != <name>py_list</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr><call><name>PyList_Append</name><argument_list>(<argument><expr><name>py_list</name></expr></argument>, <argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<return>return <expr>-1</expr>;</return>
}</block></then></if>
}</block></then></if>
}</block></for>
<return>return <expr>0</expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>update_refs</name><parameter_list>(<param><decl><type><name>PyGC_Head</name> *</type><name>containers</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyGC_Head</name> *</type><name>gc</name> <init>= <expr><name><name>containers</name>-&gt;<name>gc</name>.<name>gc_next</name></name></expr></init></decl>;</decl_stmt>
<for>for (<init>;</init> <condition><expr><name>gc</name> != <name>containers</name></expr>;</condition> <incr><expr><name>gc</name> = <name><name>gc</name>-&gt;<name>gc</name>.<name>gc_next</name></name></expr></incr>) <block>{
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>gc</name>-&gt;<name>gc</name>.<name>gc_refs</name></name> == <name>GC_REACHABLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>gc</name>-&gt;<name>gc</name>.<name>gc_refs</name></name> = <call><name>Py_REFCNT</name><argument_list>(<argument><expr><call><name>FROM_GC</name><argument_list>(<argument><expr><name>gc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>gc</name>-&gt;<name>gc</name>.<name>gc_refs</name></name> != 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></for>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>visit_decref</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>op</name></decl></param>, <param><decl><type><name>void</name> *</type><name>data</name></decl></param>)</parameter_list> <block>{
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>op</name> != <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>PyObject_IS_GC</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>PyGC_Head</name> *</type><name>gc</name> <init>= <expr><call><name>AS_GC</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>gc</name>-&gt;<name>gc</name>.<name>gc_refs</name></name> != 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>gc</name>-&gt;<name>gc</name>.<name>gc_refs</name></name> &gt; 0</expr>)</condition><then>
<expr_stmt><expr><name><name>gc</name>-&gt;<name>gc</name>.<name>gc_refs</name></name>--</expr>;</expr_stmt></then></if>
}</block></then></if>
<return>return <expr>0</expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>subtract_refs</name><parameter_list>(<param><decl><type><name>PyGC_Head</name> *</type><name>containers</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>traverseproc</name></type> <name>traverse</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyGC_Head</name> *</type><name>gc</name> <init>= <expr><name><name>containers</name>-&gt;<name>gc</name>.<name>gc_next</name></name></expr></init></decl>;</decl_stmt>
<for>for (<init>;</init> <condition><expr><name>gc</name> != <name>containers</name></expr>;</condition> <incr><expr><name>gc</name>=<name><name>gc</name>-&gt;<name>gc</name>.<name>gc_next</name></name></expr></incr>) <block>{
<expr_stmt><expr><name>traverse</name> = <call><name>Py_TYPE</name><argument_list>(<argument><expr><call><name>FROM_GC</name><argument_list>(<argument><expr><name>gc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>-&gt;<name>tp_traverse</name></expr>;</expr_stmt>
<expr_stmt><expr>(<name>void</name>) <call><name>traverse</name><argument_list>(<argument><expr><call><name>FROM_GC</name><argument_list>(<argument><expr><name>gc</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr>(<name>visitproc</name>)<name>visit_decref</name></expr></argument>,
<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></for>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>visit_reachable</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>op</name></decl></param>, <param><decl><type><name>PyGC_Head</name> *</type><name>reachable</name></decl></param>)</parameter_list> <block>{
<if>if <condition>(<expr><call><name>PyObject_IS_GC</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>PyGC_Head</name> *</type><name>gc</name> <init>= <expr><call><name>AS_GC</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>Py_ssize_t</name></type> <name>gc_refs</name> <init>= <expr><name><name>gc</name>-&gt;<name>gc</name>.<name>gc_refs</name></name></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>gc_refs</name> == 0</expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>gc</name>-&gt;<name>gc</name>.<name>gc_refs</name></name> = 1</expr>;</expr_stmt>
}</block></then> <else>else <if>if <condition>(<expr><name>gc_refs</name> == <name>GC_TENTATIVELY_UNREACHABLE</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>gc_list_move</name><argument_list>(<argument><expr><name>gc</name></expr></argument>, <argument><expr><name>reachable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>gc</name>-&gt;<name>gc</name>.<name>gc_refs</name></name> = 1</expr>;</expr_stmt>
}</block></then>
<else>else <block>{
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>gc_refs</name> &gt; 0
|| <name>gc_refs</name> == <name>GC_REACHABLE</name>
|| <name>gc_refs</name> == <name>GC_UNTRACKED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></else></if></else></if>
}</block></then></if>
<return>return <expr>0</expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>move_unreachable</name><parameter_list>(<param><decl><type><name>PyGC_Head</name> *</type><name>young</name></decl></param>, <param><decl><type><name>PyGC_Head</name> *</type><name>unreachable</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyGC_Head</name> *</type><name>gc</name> <init>= <expr><name><name>young</name>-&gt;<name>gc</name>.<name>gc_next</name></name></expr></init></decl>;</decl_stmt>
<while>while <condition>(<expr><name>gc</name> != <name>young</name></expr>)</condition> <block>{
<decl_stmt><decl><type><name>PyGC_Head</name> *</type><name>next</name></decl>;</decl_stmt>
<if>if <condition>(<expr><name><name>gc</name>-&gt;<name>gc</name>.<name>gc_refs</name></name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>op</name> <init>= <expr><call><name>FROM_GC</name><argument_list>(<argument><expr><name>gc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>traverseproc</name></type> <name>traverse</name> <init>= <expr><call><name>Py_TYPE</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call>-&gt;<name>tp_traverse</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>gc</name>-&gt;<name>gc</name>.<name>gc_refs</name></name> &gt; 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>gc</name>-&gt;<name>gc</name>.<name>gc_refs</name></name> = <name>GC_REACHABLE</name></expr>;</expr_stmt>
<expr_stmt><expr>(<name>void</name>) <call><name>traverse</name><argument_list>(<argument><expr><name>op</name></expr></argument>,
<argument><expr>(<name>visitproc</name>)<name>visit_reachable</name></expr></argument>,
<argument><expr>(<name>void</name> *)<name>young</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>next</name> = <name><name>gc</name>-&gt;<name>gc</name>.<name>gc_next</name></name></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr><name>next</name> = <name><name>gc</name>-&gt;<name>gc</name>.<name>gc_next</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>gc_list_move</name><argument_list>(<argument><expr><name>gc</name></expr></argument>, <argument><expr><name>unreachable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>gc</name>-&gt;<name>gc</name>.<name>gc_refs</name></name> = <name>GC_TENTATIVELY_UNREACHABLE</name></expr>;</expr_stmt>
}</block></else></if>
<expr_stmt><expr><name>gc</name> = <name>next</name></expr>;</expr_stmt>
}</block></while>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>has_finalizer</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>op</name></decl></param>)</parameter_list> <block>{
<if>if <condition>(<expr><call><name>PyInstance_Check</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>delstr</name> != <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>_PyInstance_Lookup</name><argument_list>(<argument><expr><name>op</name></expr></argument>, <argument><expr><name>delstr</name></expr></argument>)</argument_list></call> != <name>NULL</name></expr>;</return>
}</block></then> <else>else <if>if <condition>(<expr><call><name>PyType_HasFeature</name><argument_list>(<argument><expr><name><name>op</name>-&gt;<name>ob_type</name></name></expr></argument>, <argument><expr><name>Py_TPFLAGS_HEAPTYPE</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name><name>op</name>-&gt;<name>ob_type</name>-&gt;<name>tp_del</name></name> != <name>NULL</name></expr>;</return></then>
<else>else <if>if <condition>(<expr><call><name>PyGen_CheckExact</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><call><name>PyGen_NeedsFinalizing</name><argument_list>(<argument><expr>(<name>PyGenObject</name> *)<name>op</name></expr></argument>)</argument_list></call></expr>;</return></then>
<else>else
<return>return <expr>0</expr>;</return></else></if></else></if></else></if>
}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>move_finalizers</name><parameter_list>(<param><decl><type><name>PyGC_Head</name> *</type><name>unreachable</name></decl></param>, <param><decl><type><name>PyGC_Head</name> *</type><name>finalizers</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyGC_Head</name> *</type><name>gc</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyGC_Head</name> *</type><name>next</name></decl>;</decl_stmt>
<for>for (<init><expr><name>gc</name> = <name><name>unreachable</name>-&gt;<name>gc</name>.<name>gc_next</name></name></expr>;</init> <condition><expr><name>gc</name> != <name>unreachable</name></expr>;</condition> <incr><expr><name>gc</name> = <name>next</name></expr></incr>) <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>op</name> <init>= <expr><call><name>FROM_GC</name><argument_list>(<argument><expr><name>gc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>IS_TENTATIVELY_UNREACHABLE</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>next</name> = <name><name>gc</name>-&gt;<name>gc</name>.<name>gc_next</name></name></expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>has_finalizer</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>gc_list_move</name><argument_list>(<argument><expr><name>gc</name></expr></argument>, <argument><expr><name>finalizers</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>gc</name>-&gt;<name>gc</name>.<name>gc_refs</name></name> = <name>GC_REACHABLE</name></expr>;</expr_stmt>
}</block></then></if>
}</block></for>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>visit_move</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>op</name></decl></param>, <param><decl><type><name>PyGC_Head</name> *</type><name>tolist</name></decl></param>)</parameter_list> <block>{
<if>if <condition>(<expr><call><name>PyObject_IS_GC</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<if>if <condition>(<expr><call><name>IS_TENTATIVELY_UNREACHABLE</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>PyGC_Head</name> *</type><name>gc</name> <init>= <expr><call><name>AS_GC</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>gc_list_move</name><argument_list>(<argument><expr><name>gc</name></expr></argument>, <argument><expr><name>tolist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>gc</name>-&gt;<name>gc</name>.<name>gc_refs</name></name> = <name>GC_REACHABLE</name></expr>;</expr_stmt>
}</block></then></if>
}</block></then></if>
<return>return <expr>0</expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>move_finalizer_reachable</name><parameter_list>(<param><decl><type><name>PyGC_Head</name> *</type><name>finalizers</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>traverseproc</name></type> <name>traverse</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyGC_Head</name> *</type><name>gc</name> <init>= <expr><name><name>finalizers</name>-&gt;<name>gc</name>.<name>gc_next</name></name></expr></init></decl>;</decl_stmt>
<for>for (<init>;</init> <condition><expr><name>gc</name> != <name>finalizers</name></expr>;</condition> <incr><expr><name>gc</name> = <name><name>gc</name>-&gt;<name>gc</name>.<name>gc_next</name></name></expr></incr>) <block>{
<expr_stmt><expr><name>traverse</name> = <call><name>Py_TYPE</name><argument_list>(<argument><expr><call><name>FROM_GC</name><argument_list>(<argument><expr><name>gc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>-&gt;<name>tp_traverse</name></expr>;</expr_stmt>
<expr_stmt><expr>(<name>void</name>) <call><name>traverse</name><argument_list>(<argument><expr><call><name>FROM_GC</name><argument_list>(<argument><expr><name>gc</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr>(<name>visitproc</name>)<name>visit_move</name></expr></argument>,
<argument><expr>(<name>void</name> *)<name>finalizers</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></for>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>handle_weakrefs</name><parameter_list>(<param><decl><type><name>PyGC_Head</name> *</type><name>unreachable</name></decl></param>, <param><decl><type><name>PyGC_Head</name> *</type><name>old</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyGC_Head</name> *</type><name>gc</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>op</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyWeakReference</name> *</type><name>wr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyGC_Head</name></type> <name>wrcb_to_call</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyGC_Head</name> *</type><name>next</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>num_freed</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>gc_list_init</name><argument_list>(<argument><expr>&amp;<name>wrcb_to_call</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for (<init><expr><name>gc</name> = <name><name>unreachable</name>-&gt;<name>gc</name>.<name>gc_next</name></name></expr>;</init> <condition><expr><name>gc</name> != <name>unreachable</name></expr>;</condition> <incr><expr><name>gc</name> = <name>next</name></expr></incr>) <block>{
<decl_stmt><decl><type><name>PyWeakReference</name> **</type><name>wrlist</name></decl>;</decl_stmt>
<expr_stmt><expr><name>op</name> = <call><name>FROM_GC</name><argument_list>(<argument><expr><name>gc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>IS_TENTATIVELY_UNREACHABLE</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>next</name> = <name><name>gc</name>-&gt;<name>gc</name>.<name>gc_next</name></name></expr>;</expr_stmt>
<if>if <condition>(<expr>! <call><name>PyType_SUPPORTS_WEAKREFS</name><argument_list>(<argument><expr><call><name>Py_TYPE</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then>
<continue>continue;</continue></then></if>
<expr_stmt><expr><name>wrlist</name> = (<name>PyWeakReference</name> **)
<call><name>PyObject_GET_WEAKREFS_LISTPTR</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for (<init><expr><name>wr</name> = *<name>wrlist</name></expr>;</init> <condition><expr><name>wr</name> != <name>NULL</name></expr>;</condition> <incr><expr><name>wr</name> = *<name>wrlist</name></expr></incr>) <block>{
<decl_stmt><decl><type><name>PyGC_Head</name> *</type><name>wrasgc</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>wr</name>-&gt;<name>wr_object</name></name> == <name>op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>_PyWeakref_ClearRef</name><argument_list>(<argument><expr><name>wr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>wr</name>-&gt;<name>wr_object</name></name> == <name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>wr</name>-&gt;<name>wr_callback</name></name> == <name>NULL</name></expr>)</condition><then>
<continue>continue;</continue></then></if>
<if>if <condition>(<expr><call><name>IS_TENTATIVELY_UNREACHABLE</name><argument_list>(<argument><expr><name>wr</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<continue>continue;</continue></then></if>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>IS_REACHABLE</name><argument_list>(<argument><expr><name>wr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>wr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>wrasgc</name> = <call><name>AS_GC</name><argument_list>(<argument><expr><name>wr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>wrasgc</name> != <name>next</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>gc_list_move</name><argument_list>(<argument><expr><name>wrasgc</name></expr></argument>, <argument><expr>&amp;<name>wrcb_to_call</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></for>
}</block></for>
<while>while <condition>(<expr>! <call><name>gc_list_is_empty</name><argument_list>(<argument><expr>&amp;<name>wrcb_to_call</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>temp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>callback</name></decl>;</decl_stmt>
<expr_stmt><expr><name>gc</name> = <name><name>wrcb_to_call</name>.<name>gc</name>.<name>gc_next</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>op</name> = <call><name>FROM_GC</name><argument_list>(<argument><expr><name>gc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>IS_REACHABLE</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>PyWeakref_Check</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>wr</name> = (<name>PyWeakReference</name> *)<name>op</name></expr>;</expr_stmt>
<expr_stmt><expr><name>callback</name> = <name><name>wr</name>-&gt;<name>wr_callback</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>callback</name> != <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>temp</name> = <call><name>PyObject_CallFunctionObjArgs</name><argument_list>(<argument><expr><name>callback</name></expr></argument>, <argument><expr><name>wr</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>temp</name> == <name>NULL</name></expr>)</condition><then>
<expr_stmt><expr><call><name>PyErr_WriteUnraisable</name><argument_list>(<argument><expr><name>callback</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
<else>else
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>temp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>wrcb_to_call</name>.<name>gc</name>.<name>gc_next</name></name> == <name>gc</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>gc_list_move</name><argument_list>(<argument><expr><name>gc</name></expr></argument>, <argument><expr><name>old</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else
<expr_stmt><expr>++<name>num_freed</name></expr>;</expr_stmt></else></if>
}</block></while>
<return>return <expr><name>num_freed</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>debug_instance</name><parameter_list>(<param><decl><type><name>char</name> *</type><name>msg</name></decl></param>, <param><decl><type><name>PyInstanceObject</name> *</type><name>inst</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>char</name> *</type><name>cname</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>classname</name> <init>= <expr><name><name>inst</name>-&gt;<name>in_class</name>-&gt;<name>cl_name</name></name></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>classname</name> != <name>NULL</name> &amp;&amp; <call><name>PyString_Check</name><argument_list>(<argument><expr><name>classname</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<expr_stmt><expr><name>cname</name> = <call><name>PyString_AsString</name><argument_list>(<argument><expr><name>classname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
<else>else
<expr_stmt><expr><name>cname</name> = "?"</expr>;</expr_stmt></else></if>
<expr_stmt><expr><call><name>PySys_WriteStderr</name><argument_list>(<argument><expr>"gc: %.100s &lt;%.100s instance at %p&gt;\n"</expr></argument>,
<argument><expr><name>msg</name></expr></argument>, <argument><expr><name>cname</name></expr></argument>, <argument><expr><name>inst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>debug_cycle</name><parameter_list>(<param><decl><type><name>char</name> *</type><name>msg</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>op</name></decl></param>)</parameter_list> <block>{
<if>if <condition>(<expr>(<name>debug</name> &amp; <name>DEBUG_INSTANCES</name>) &amp;&amp; <call><name>PyInstance_Check</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>debug_instance</name><argument_list>(<argument><expr><name>msg</name></expr></argument>, <argument><expr>(<name>PyInstanceObject</name> *)<name>op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else <if>if <condition>(<expr><name>debug</name> &amp; <name>DEBUG_OBJECTS</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PySys_WriteStderr</name><argument_list>(<argument><expr>"gc: %.100s &lt;%.100s %p&gt;\n"</expr></argument>,
<argument><expr><name>msg</name></expr></argument>, <argument><expr><call><name>Py_TYPE</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call>-&gt;<name>tp_name</name></expr></argument>, <argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if></else></if>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>handle_finalizers</name><parameter_list>(<param><decl><type><name>PyGC_Head</name> *</type><name>finalizers</name></decl></param>, <param><decl><type><name>PyGC_Head</name> *</type><name>old</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyGC_Head</name> *</type><name>gc</name> <init>= <expr><name><name>finalizers</name>-&gt;<name>gc</name>.<name>gc_next</name></name></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>garbage</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>garbage</name> = <call><name>PyList_New</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>garbage</name> == <name>NULL</name></expr>)</condition><then>
<expr_stmt><expr><call><name>Py_FatalError</name><argument_list>(<argument><expr>"gc couldn't create gc.garbage list"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
}</block></then></if>
<for>for (<init>;</init> <condition><expr><name>gc</name> != <name>finalizers</name></expr>;</condition> <incr><expr><name>gc</name> = <name><name>gc</name>-&gt;<name>gc</name>.<name>gc_next</name></name></expr></incr>) <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>op</name> <init>= <expr><call><name>FROM_GC</name><argument_list>(<argument><expr><name>gc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr>(<name>debug</name> &amp; <name>DEBUG_SAVEALL</name>) || <call><name>has_finalizer</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<if>if <condition>(<expr><call><name>PyList_Append</name><argument_list>(<argument><expr><name>garbage</name></expr></argument>, <argument><expr><name>op</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
<return>return <expr>-1</expr>;</return></then></if>
}</block></then></if>
}</block></for>
<expr_stmt><expr><call><name>gc_list_merge</name><argument_list>(<argument><expr><name>finalizers</name></expr></argument>, <argument><expr><name>old</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>0</expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>delete_garbage</name><parameter_list>(<param><decl><type><name>PyGC_Head</name> *</type><name>collectable</name></decl></param>, <param><decl><type><name>PyGC_Head</name> *</type><name>old</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>inquiry</name></type> <name>clear</name></decl>;</decl_stmt>
<while>while <condition>(<expr>!<call><name>gc_list_is_empty</name><argument_list>(<argument><expr><name>collectable</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{
<decl_stmt><decl><type><name>PyGC_Head</name> *</type><name>gc</name> <init>= <expr><name><name>collectable</name>-&gt;<name>gc</name>.<name>gc_next</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>op</name> <init>= <expr><call><name>FROM_GC</name><argument_list>(<argument><expr><name>gc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>IS_TENTATIVELY_UNREACHABLE</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>debug</name> &amp; <name>DEBUG_SAVEALL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyList_Append</name><argument_list>(<argument><expr><name>garbage</name></expr></argument>, <argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<if>if <condition>(<expr>(<name>clear</name> = <call><name>Py_TYPE</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call>-&gt;<name>tp_clear</name>) != <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>clear</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
}</block></else></if>
<if>if <condition>(<expr><name><name>collectable</name>-&gt;<name>gc</name>.<name>gc_next</name></name> == <name>gc</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>gc_list_move</name><argument_list>(<argument><expr><name>gc</name></expr></argument>, <argument><expr><name>old</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>gc</name>-&gt;<name>gc</name>.<name>gc_refs</name></name> = <name>GC_REACHABLE</name></expr>;</expr_stmt>
}</block></then></if>
}</block></while>
}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>clear_freelists</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list> <block>{
<expr_stmt><expr>(<name>void</name>)<call><name>PyMethod_ClearFreeList</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr>(<name>void</name>)<call><name>PyFrame_ClearFreeList</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr>(<name>void</name>)<call><name>PyCFunction_ClearFreeList</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr>(<name>void</name>)<call><name>PyTuple_ClearFreeList</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr>(<name>void</name>)<call><name>PyUnicode_ClearFreeList</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr>(<name>void</name>)<call><name>PyInt_ClearFreeList</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr>(<name>void</name>)<call><name>PyFloat_ClearFreeList</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
}</block></function>
<function><type><specifier>static</specifier> <name>Py_ssize_t</name></type>
<name>collect</name><parameter_list>(<param><decl><type><name>int</name></type> <name>generation</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>m</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>n</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyGC_Head</name> *</type><name>young</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyGC_Head</name> *</type><name>old</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyGC_Head</name></type> <name>unreachable</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyGC_Head</name></type> <name>finalizers</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyGC_Head</name> *</type><name>gc</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>double</name></type> <name>t1</name> <init>= <expr>0.0</expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>delstr</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>delstr</name> = <call><name>PyString_InternFromString</name><argument_list>(<argument><expr>"__del__"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>delstr</name> == <name>NULL</name></expr>)</condition><then>
<expr_stmt><expr><call><name>Py_FatalError</name><argument_list>(<argument><expr>"gc couldn't allocate \"__del__\""</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
}</block></then></if>
<if>if <condition>(<expr><name>debug</name> &amp; <name>DEBUG_STATS</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr><name>tmod</name> != <name>NULL</name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>f</name> <init>= <expr><call><name>PyObject_CallMethod</name><argument_list>(<argument><expr><name>tmod</name></expr></argument>, <argument><expr>"time"</expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>f</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_Clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr><name>t1</name> = <call><name>PyFloat_AsDouble</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></else></if>
}</block></then></if>
<expr_stmt><expr><call><name>PySys_WriteStderr</name><argument_list>(<argument><expr>"gc: collecting generation %d...\n"</expr></argument>,
<argument><expr><name>generation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PySys_WriteStderr</name><argument_list>(<argument><expr>"gc: objects in each generation:"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>NUM_GENERATIONS</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
<expr_stmt><expr><call><name>PySys_WriteStderr</name><argument_list>(<argument><expr>" %" <name>PY_FORMAT_SIZE_T</name> "d"</expr></argument>,
<argument><expr><call><name>gc_list_size</name><argument_list>(<argument><expr><call><name>GEN_HEAD</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></for>
<expr_stmt><expr><call><name>PySys_WriteStderr</name><argument_list>(<argument><expr>"\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<if>if <condition>(<expr><name>generation</name>+1 &lt; <name>NUM_GENERATIONS</name></expr>)</condition><then>
<expr_stmt><expr><name><name>generations</name><index>[<expr><name>generation</name>+1</expr>]</index></name>.<name>count</name> += 1</expr>;</expr_stmt></then></if>
<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt;= <name>generation</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
<expr_stmt><expr><name><name>generations</name><index>[<expr><name>i</name></expr>]</index></name>.<name>count</name> = 0</expr>;</expr_stmt></for>
<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>generation</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
<expr_stmt><expr><call><name>gc_list_merge</name><argument_list>(<argument><expr><call><name>GEN_HEAD</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>GEN_HEAD</name><argument_list>(<argument><expr><name>generation</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></for>
<expr_stmt><expr><name>young</name> = <call><name>GEN_HEAD</name><argument_list>(<argument><expr><name>generation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>generation</name> &lt; <name>NUM_GENERATIONS</name>-1</expr>)</condition><then>
<expr_stmt><expr><name>old</name> = <call><name>GEN_HEAD</name><argument_list>(<argument><expr><name>generation</name>+1</expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
<else>else
<expr_stmt><expr><name>old</name> = <name>young</name></expr>;</expr_stmt></else></if>
<expr_stmt><expr><call><name>update_refs</name><argument_list>(<argument><expr><name>young</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>subtract_refs</name><argument_list>(<argument><expr><name>young</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>gc_list_init</name><argument_list>(<argument><expr>&amp;<name>unreachable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>move_unreachable</name><argument_list>(<argument><expr><name>young</name></expr></argument>, <argument><expr>&amp;<name>unreachable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>young</name> != <name>old</name></expr>)</condition><then>
<expr_stmt><expr><call><name>gc_list_merge</name><argument_list>(<argument><expr><name>young</name></expr></argument>, <argument><expr><name>old</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<expr_stmt><expr><call><name>gc_list_init</name><argument_list>(<argument><expr>&amp;<name>finalizers</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>move_finalizers</name><argument_list>(<argument><expr>&amp;<name>unreachable</name></expr></argument>, <argument><expr>&amp;<name>finalizers</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>move_finalizer_reachable</name><argument_list>(<argument><expr>&amp;<name>finalizers</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for (<init><expr><name>gc</name> = <name><name>unreachable</name>.<name>gc</name>.<name>gc_next</name></name></expr>;</init> <condition><expr><name>gc</name> != &amp;<name>unreachable</name></expr>;</condition>
<incr><expr><name>gc</name> = <name><name>gc</name>-&gt;<name>gc</name>.<name>gc_next</name></name></expr></incr>) <block>{
<expr_stmt><expr><name>m</name>++</expr>;</expr_stmt>
<if>if <condition>(<expr><name>debug</name> &amp; <name>DEBUG_COLLECTABLE</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>debug_cycle</name><argument_list>(<argument><expr>"collectable"</expr></argument>, <argument><expr><call><name>FROM_GC</name><argument_list>(<argument><expr><name>gc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<if>if <condition>(<expr><name>tmod</name> != <name>NULL</name> &amp;&amp; (<name>debug</name> &amp; <name>DEBUG_STATS</name>)</expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>f</name> <init>= <expr><call><name>PyObject_CallMethod</name><argument_list>(<argument><expr><name>tmod</name></expr></argument>, <argument><expr>"time"</expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>f</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_Clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr><name>t1</name> = <call><name>PyFloat_AsDouble</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call>-<name>t1</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PySys_WriteStderr</name><argument_list>(<argument><expr>"gc: %.4fs elapsed.\n"</expr></argument>, <argument><expr><name>t1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></else></if>
}</block></then></if>
}</block></for>
<expr_stmt><expr><name>m</name> += <call><name>handle_weakrefs</name><argument_list>(<argument><expr>&amp;<name>unreachable</name></expr></argument>, <argument><expr><name>old</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>delete_garbage</name><argument_list>(<argument><expr>&amp;<name>unreachable</name></expr></argument>, <argument><expr><name>old</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for (<init><expr><name>gc</name> = <name><name>finalizers</name>.<name>gc</name>.<name>gc_next</name></name></expr>;</init>
<condition><expr><name>gc</name> != &amp;<name>finalizers</name></expr>;</condition>
<incr><expr><name>gc</name> = <name><name>gc</name>-&gt;<name>gc</name>.<name>gc_next</name></name></expr></incr>) <block>{
<expr_stmt><expr><name>n</name>++</expr>;</expr_stmt>
<if>if <condition>(<expr><name>debug</name> &amp; <name>DEBUG_UNCOLLECTABLE</name></expr>)</condition><then>
<expr_stmt><expr><call><name>debug_cycle</name><argument_list>(<argument><expr>"uncollectable"</expr></argument>, <argument><expr><call><name>FROM_GC</name><argument_list>(<argument><expr><name>gc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
}</block></for>
<if>if <condition>(<expr><name>debug</name> &amp; <name>DEBUG_STATS</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr><name>m</name> == 0 &amp;&amp; <name>n</name> == 0</expr>)</condition><then>
<expr_stmt><expr><call><name>PySys_WriteStderr</name><argument_list>(<argument><expr>"gc: done.\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
<else>else
<expr_stmt><expr><call><name>PySys_WriteStderr</name><argument_list>(
<argument><expr>"gc: done, "
"%" <name>PY_FORMAT_SIZE_T</name> "d unreachable, "
"%" <name>PY_FORMAT_SIZE_T</name> "d uncollectable.\n"</expr></argument>,
<argument><expr><name>n</name>+<name>m</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
}</block></then></if>
<expr_stmt><expr>(<name>void</name>)<call><name>handle_finalizers</name><argument_list>(<argument><expr>&amp;<name>finalizers</name></expr></argument>, <argument><expr><name>old</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>generation</name> == <name>NUM_GENERATIONS</name>-1</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>clear_freelists</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<if>if <condition>(<expr><call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
<if>if <condition>(<expr><name>gc_str</name> == <name>NULL</name></expr>)</condition><then>
<expr_stmt><expr><name>gc_str</name> = <call><name>PyString_FromString</name><argument_list>(<argument><expr>"garbage collection"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<expr_stmt><expr><call><name>PyErr_WriteUnraisable</name><argument_list>(<argument><expr><name>gc_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_FatalError</name><argument_list>(<argument><expr>"unexpected exception during garbage collection"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<return>return <expr><name>n</name>+<name>m</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>Py_ssize_t</name></type>
<name>collect_generations</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>n</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<for>for (<init><expr><name>i</name> = <name>NUM_GENERATIONS</name>-1</expr>;</init> <condition><expr><name>i</name> &gt;= 0</expr>;</condition> <incr><expr><name>i</name>--</expr></incr>) <block>{
<if>if <condition>(<expr><name><name>generations</name><index>[<expr><name>i</name></expr>]</index></name>.<name>count</name> &gt; <name><name>generations</name><index>[<expr><name>i</name></expr>]</index></name>.<name>threshold</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>n</name> = <call><name>collect</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
}</block></then></if>
}</block></for>
<return>return <expr><name>n</name></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>gc_enable__doc__</name></expr></argument>,
<argument><expr>"enable() -&gt; None\n"
"\n"
"Enable automatic garbage collection.\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>gc_enable</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>noargs</name></decl></param>)</parameter_list> <block>{
<expr_stmt><expr><name>enabled</name> = 1</expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>Py_None</name></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>gc_disable__doc__</name></expr></argument>,
<argument><expr>"disable() -&gt; None\n"
"\n"
"Disable automatic garbage collection.\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>gc_disable</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>noargs</name></decl></param>)</parameter_list> <block>{
<expr_stmt><expr><name>enabled</name> = 0</expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>Py_None</name></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>gc_isenabled__doc__</name></expr></argument>,
<argument><expr>"isenabled() -&gt; status\n"
"\n"
"Returns true if automatic garbage collection is enabled.\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>gc_isenabled</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>noargs</name></decl></param>)</parameter_list> <block>{
<return>return <expr><call><name>PyBool_FromLong</name><argument_list>(<argument><expr>(<name>long</name>)<name>enabled</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>gc_collect__doc__</name></expr></argument>,
<argument><expr>"collect([generation]) -&gt; n\n"
"\n"
"With no arguments, run a full collection. The optional argument\n"
"may be an integer specifying which generation to collect. A ValueError\n"
"is raised if the generation number is invalid.\n\n"
"The number of unreachable objects is returned.\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>gc_collect</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>kws</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> *</type><name><name>keywords</name><index>[]</index></name> <init>= <expr><block>{<expr>"generation"</expr>, <expr><name>NULL</name></expr>}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>genarg</name> <init>= <expr><name>NUM_GENERATIONS</name> - 1</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>n</name></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTupleAndKeywords</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>kws</name></expr></argument>, <argument><expr>"|i"</expr></argument>, <argument><expr><name>keywords</name></expr></argument>, <argument><expr>&amp;<name>genarg</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then>
<else>else <if>if <condition>(<expr><name>genarg</name> &lt; 0 || <name>genarg</name> &gt;= <name>NUM_GENERATIONS</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>, <argument><expr>"invalid generation"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if></else></if>
<if>if <condition>(<expr><name>collecting</name></expr>)</condition><then>
<expr_stmt><expr><name>n</name> = 0</expr>;</expr_stmt></then>
<else>else <block>{
<expr_stmt><expr><name>collecting</name> = 1</expr>;</expr_stmt>
<expr_stmt><expr><name>n</name> = <call><name>collect</name><argument_list>(<argument><expr><name>genarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>collecting</name> = 0</expr>;</expr_stmt>
}</block></else></if>
<return>return <expr><call><name>PyInt_FromSsize_t</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>gc_set_debug__doc__</name></expr></argument>,
<argument><expr>"set_debug(flags) -&gt; None\n"
"\n"
"Set the garbage collection debugging flags. Debugging information is\n"
"written to sys.stderr.\n"
"\n"
"flags is an integer and can have the following bits turned on:\n"
"\n"
" DEBUG_STATS - Print statistics during collection.\n"
" DEBUG_COLLECTABLE - Print collectable objects found.\n"
" DEBUG_UNCOLLECTABLE - Print unreachable but uncollectable objects found.\n"
" DEBUG_INSTANCES - Print instance objects.\n"
" DEBUG_OBJECTS - Print objects other than instances.\n"
" DEBUG_SAVEALL - Save objects to gc.garbage rather than freeing them.\n"
" DEBUG_LEAK - Debug leaking programs (everything but STATS).\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>gc_set_debug</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"i:set_debug"</expr></argument>, <argument><expr>&amp;<name>debug</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>Py_None</name></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>gc_get_debug__doc__</name></expr></argument>,
<argument><expr>"get_debug() -&gt; flags\n"
"\n"
"Get the garbage collection debugging flags.\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>gc_get_debug</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>noargs</name></decl></param>)</parameter_list> <block>{
<return>return <expr><call><name>Py_BuildValue</name><argument_list>(<argument><expr>"i"</expr></argument>, <argument><expr><name>debug</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>gc_set_thresh__doc__</name></expr></argument>,
<argument><expr>"set_threshold(threshold0, [threshold1, threshold2]) -&gt; None\n"
"\n"
"Sets the collection thresholds. Setting threshold0 to zero disables\n"
"collection.\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>gc_set_thresh</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"i|ii:set_threshold"</expr></argument>,
<argument><expr>&amp;<name><name>generations</name><index>[<expr>0</expr>]</index></name>.<name>threshold</name></expr></argument>,
<argument><expr>&amp;<name><name>generations</name><index>[<expr>1</expr>]</index></name>.<name>threshold</name></expr></argument>,
<argument><expr>&amp;<name><name>generations</name><index>[<expr>2</expr>]</index></name>.<name>threshold</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<for>for (<init><expr><name>i</name> = 2</expr>;</init> <condition><expr><name>i</name> &lt; <name>NUM_GENERATIONS</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
<expr_stmt><expr><name><name>generations</name><index>[<expr><name>i</name></expr>]</index></name>.<name>threshold</name> = <name><name>generations</name><index>[<expr>2</expr>]</index></name>.<name>threshold</name></expr>;</expr_stmt>
}</block></for>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>Py_None</name></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>gc_get_thresh__doc__</name></expr></argument>,
<argument><expr>"get_threshold() -&gt; (threshold0, threshold1, threshold2)\n"
"\n"
"Return the current collection thresholds\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>gc_get_thresh</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>noargs</name></decl></param>)</parameter_list> <block>{
<return>return <expr><call><name>Py_BuildValue</name><argument_list>(<argument><expr>"(iii)"</expr></argument>,
<argument><expr><name><name>generations</name><index>[<expr>0</expr>]</index></name>.<name>threshold</name></expr></argument>,
<argument><expr><name><name>generations</name><index>[<expr>1</expr>]</index></name>.<name>threshold</name></expr></argument>,
<argument><expr><name><name>generations</name><index>[<expr>2</expr>]</index></name>.<name>threshold</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>gc_get_count__doc__</name></expr></argument>,
<argument><expr>"get_count() -&gt; (count0, count1, count2)\n"
"\n"
"Return the current collection counts\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>gc_get_count</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>noargs</name></decl></param>)</parameter_list> <block>{
<return>return <expr><call><name>Py_BuildValue</name><argument_list>(<argument><expr>"(iii)"</expr></argument>,
<argument><expr><name><name>generations</name><index>[<expr>0</expr>]</index></name>.<name>count</name></expr></argument>,
<argument><expr><name><name>generations</name><index>[<expr>1</expr>]</index></name>.<name>count</name></expr></argument>,
<argument><expr><name><name>generations</name><index>[<expr>2</expr>]</index></name>.<name>count</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>referrersvisit</name><parameter_list>(<param><decl><type><name>PyObject</name>*</type> <name>obj</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>objs</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>i</name></decl>;</decl_stmt>
<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <call><name>PyTuple_GET_SIZE</name><argument_list>(<argument><expr><name>objs</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
<if>if <condition>(<expr><call><name>PyTuple_GET_ITEM</name><argument_list>(<argument><expr><name>objs</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call> == <name>obj</name></expr>)</condition><then>
<return>return <expr>1</expr>;</return></then></if></for>
<return>return <expr>0</expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>gc_referrers_for</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>objs</name></decl></param>, <param><decl><type><name>PyGC_Head</name> *</type><name>list</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>resultlist</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyGC_Head</name> *</type><name>gc</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>obj</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>traverseproc</name></type> <name>traverse</name></decl>;</decl_stmt>
<for>for (<init><expr><name>gc</name> = <name><name>list</name>-&gt;<name>gc</name>.<name>gc_next</name></name></expr>;</init> <condition><expr><name>gc</name> != <name>list</name></expr>;</condition> <incr><expr><name>gc</name> = <name><name>gc</name>-&gt;<name>gc</name>.<name>gc_next</name></name></expr></incr>) <block>{
<expr_stmt><expr><name>obj</name> = <call><name>FROM_GC</name><argument_list>(<argument><expr><name>gc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>traverse</name> = <call><name>Py_TYPE</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call>-&gt;<name>tp_traverse</name></expr>;</expr_stmt>
<if>if <condition>(<expr><name>obj</name> == <name>objs</name> || <name>obj</name> == <name>resultlist</name></expr>)</condition><then>
<continue>continue;</continue></then></if>
<if>if <condition>(<expr><call><name>traverse</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr>(<name>visitproc</name>)<name>referrersvisit</name></expr></argument>, <argument><expr><name>objs</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<if>if <condition>(<expr><call><name>PyList_Append</name><argument_list>(<argument><expr><name>resultlist</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
<return>return <expr>0</expr>;</return></then></if>
}</block></then></if>
}</block></for>
<return>return <expr>1</expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>gc_get_referrers__doc__</name></expr></argument>,
<argument><expr>"get_referrers(*objs) -&gt; list\n\
Return the list of objects that directly refer to any of objs."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>gc_get_referrers</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>result</name> <init>= <expr><call><name>PyList_New</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr>!<name>result</name></expr>)</condition><then> <return>return <expr><name>NULL</name></expr>;</return></then></if>
<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>NUM_GENERATIONS</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
<if>if <condition>(<expr>!(<call><name>gc_referrers_for</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><call><name>GEN_HEAD</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call>)</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
}</block></for>
<return>return <expr><name>result</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>referentsvisit</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>obj</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>list</name></decl></param>)</parameter_list> <block>{
<return>return <expr><call><name>PyList_Append</name><argument_list>(<argument><expr><name>list</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call> &lt; 0</expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>gc_get_referents__doc__</name></expr></argument>,
<argument><expr>"get_referents(*objs) -&gt; list\n\
Return the list of objects that are directly referred to by objs."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>gc_get_referents</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>result</name> <init>= <expr><call><name>PyList_New</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>result</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <call><name>PyTuple_GET_SIZE</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
<decl_stmt><decl><type><name>traverseproc</name></type> <name>traverse</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>obj</name> <init>= <expr><call><name>PyTuple_GET_ITEM</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr>! <call><name>PyObject_IS_GC</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<continue>continue;</continue></then></if>
<expr_stmt><expr><name>traverse</name> = <call><name>Py_TYPE</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call>-&gt;<name>tp_traverse</name></expr>;</expr_stmt>
<if>if <condition>(<expr>! <name>traverse</name></expr>)</condition><then>
<continue>continue;</continue></then></if>
<if>if <condition>(<expr><call><name>traverse</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr>(<name>visitproc</name>)<name>referentsvisit</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
}</block></for>
<return>return <expr><name>result</name></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>gc_get_objects__doc__</name></expr></argument>,
<argument><expr>"get_objects() -&gt; [...]\n"
"\n"
"Return a list of objects tracked by the collector (excluding the list\n"
"returned).\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>gc_get_objects</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>noargs</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name>*</type> <name>result</name></decl>;</decl_stmt>
<expr_stmt><expr><name>result</name> = <call><name>PyList_New</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>result</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>NUM_GENERATIONS</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
<if>if <condition>(<expr><call><name>append_objects</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><call><name>GEN_HEAD</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
}</block></for>
<return>return <expr><name>result</name></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>gc__doc__</name></expr></argument>,
<argument><expr>"This module provides access to the garbage collector for reference cycles.\n"
"\n"
"enable() -- Enable automatic garbage collection.\n"
"disable() -- Disable automatic garbage collection.\n"
"isenabled() -- Returns true if automatic collection is enabled.\n"
"collect() -- Do a full collection right now.\n"
"get_count() -- Return the current collection counts.\n"
"set_debug() -- Set debugging flags.\n"
"get_debug() -- Get debugging flags.\n"
"set_threshold() -- Set the collection thresholds.\n"
"get_threshold() -- Return the current the collection thresholds.\n"
"get_objects() -- Return a list of all objects tracked by the collector.\n"
"get_referrers() -- Return the list of objects that refer to an object.\n"
"get_referents() -- Return the list of objects that an object refers to.\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>PyMethodDef</name></type> <name><name>GcMethods</name><index>[]</index></name> <init>= <expr><block>{
<expr><block>{<expr>"enable"</expr>, <expr><name>gc_enable</name></expr>, <expr><name>METH_NOARGS</name></expr>, <expr><name>gc_enable__doc__</name></expr>}</block></expr>,
<expr><block>{<expr>"disable"</expr>, <expr><name>gc_disable</name></expr>, <expr><name>METH_NOARGS</name></expr>, <expr><name>gc_disable__doc__</name></expr>}</block></expr>,
<expr><block>{<expr>"isenabled"</expr>, <expr><name>gc_isenabled</name></expr>, <expr><name>METH_NOARGS</name></expr>, <expr><name>gc_isenabled__doc__</name></expr>}</block></expr>,
<expr><block>{<expr>"set_debug"</expr>, <expr><name>gc_set_debug</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>gc_set_debug__doc__</name></expr>}</block></expr>,
<expr><block>{<expr>"get_debug"</expr>, <expr><name>gc_get_debug</name></expr>, <expr><name>METH_NOARGS</name></expr>, <expr><name>gc_get_debug__doc__</name></expr>}</block></expr>,
<expr><block>{<expr>"get_count"</expr>, <expr><name>gc_get_count</name></expr>, <expr><name>METH_NOARGS</name></expr>, <expr><name>gc_get_count__doc__</name></expr>}</block></expr>,
<expr><block>{<expr>"set_threshold"</expr>, <expr><name>gc_set_thresh</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>gc_set_thresh__doc__</name></expr>}</block></expr>,
<expr><block>{<expr>"get_threshold"</expr>, <expr><name>gc_get_thresh</name></expr>, <expr><name>METH_NOARGS</name></expr>, <expr><name>gc_get_thresh__doc__</name></expr>}</block></expr>,
<expr><block>{
<expr>"collect"</expr>, <expr>(<name>PyCFunction</name>)<name>gc_collect</name></expr>,
<expr><name>METH_VARARGS</name> | <name>METH_KEYWORDS</name></expr>, <expr><name>gc_collect__doc__</name></expr>
}</block></expr>,
<expr><block>{<expr>"get_objects"</expr>, <expr><name>gc_get_objects</name></expr>,<expr><name>METH_NOARGS</name></expr>, <expr><name>gc_get_objects__doc__</name></expr>}</block></expr>,
<expr><block>{
<expr>"get_referrers"</expr>, <expr><name>gc_get_referrers</name></expr>, <expr><name>METH_VARARGS</name></expr>,
<expr><name>gc_get_referrers__doc__</name></expr>
}</block></expr>,
<expr><block>{
<expr>"get_referents"</expr>, <expr><name>gc_get_referents</name></expr>, <expr><name>METH_VARARGS</name></expr>,
<expr><name>gc_get_referents__doc__</name></expr>
}</block></expr>,
<expr><block>{<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>}</block></expr>
}</block></expr></init></decl>;</decl_stmt>
<function><type><name>PyMODINIT_FUNC</name></type>
<name>initgc</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>m</name></decl>;</decl_stmt>
<expr_stmt><expr><name>m</name> = <call><name>Py_InitModule4</name><argument_list>(<argument><expr>"gc"</expr></argument>,
<argument><expr><name>GcMethods</name></expr></argument>,
<argument><expr><name>gc__doc__</name></expr></argument>,
<argument><expr><name>NULL</name></expr></argument>,
<argument><expr><name>PYTHON_API_VERSION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>m</name> == <name>NULL</name></expr>)</condition><then>
<return>return;</return></then></if>
<if>if <condition>(<expr><name>garbage</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>garbage</name> = <call><name>PyList_New</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>garbage</name> == <name>NULL</name></expr>)</condition><then>
<return>return;</return></then></if>
}</block></then></if>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>garbage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>PyModule_AddObject</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"garbage"</expr></argument>, <argument><expr><name>garbage</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
<return>return;</return></then></if>
<if>if <condition>(<expr><name>tmod</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>tmod</name> = <call><name>PyImport_ImportModuleNoBlock</name><argument_list>(<argument><expr>"time"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>tmod</name> == <name>NULL</name></expr>)</condition><then>
<expr_stmt><expr><call><name>PyErr_Clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>
}</block></then></if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ADD_INT</name><parameter_list>(<param><type><name>NAME</name></type></param>)</parameter_list></cpp:macro> <cpp:value>if (PyModule_AddIntConstant(m, #NAME, NAME) &lt; 0) return</cpp:value></cpp:define>
<expr_stmt><expr><call><name>ADD_INT</name><argument_list>(<argument><expr><name>DEBUG_STATS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ADD_INT</name><argument_list>(<argument><expr><name>DEBUG_COLLECTABLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ADD_INT</name><argument_list>(<argument><expr><name>DEBUG_UNCOLLECTABLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ADD_INT</name><argument_list>(<argument><expr><name>DEBUG_INSTANCES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ADD_INT</name><argument_list>(<argument><expr><name>DEBUG_OBJECTS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ADD_INT</name><argument_list>(<argument><expr><name>DEBUG_SAVEALL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ADD_INT</name><argument_list>(<argument><expr><name>DEBUG_LEAK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>ADD_INT</name></cpp:undef>
}</block></function>
<function><type><name>Py_ssize_t</name></type>
<name>PyGC_Collect</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>n</name></decl>;</decl_stmt>
<if>if <condition>(<expr><name>collecting</name></expr>)</condition><then>
<expr_stmt><expr><name>n</name> = 0</expr>;</expr_stmt></then>
<else>else <block>{
<expr_stmt><expr><name>collecting</name> = 1</expr>;</expr_stmt>
<expr_stmt><expr><name>n</name> = <call><name>collect</name><argument_list>(<argument><expr><name>NUM_GENERATIONS</name> - 1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>collecting</name> = 0</expr>;</expr_stmt>
}</block></else></if>
<return>return <expr><name>n</name></expr>;</return>
}</block></function>
<function><type><name>void</name></type>
<name>_PyGC_Dump</name><parameter_list>(<param><decl><type><name>PyGC_Head</name> *</type><name>g</name></decl></param>)</parameter_list> <block>{
<expr_stmt><expr><call><name>_PyObject_Dump</name><argument_list>(<argument><expr><call><name>FROM_GC</name><argument_list>(<argument><expr><name>g</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>PyObject_GC_Track</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>PyObject_GC_UnTrack</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>PyObject_GC_Del</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>_PyObject_GC_Malloc</name></cpp:undef>
<function><type><name>void</name></type>
<name>PyObject_GC_Track</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>op</name></decl></param>)</parameter_list> <block>{
<expr_stmt><expr><call><name>_PyObject_GC_TRACK</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>
<function><type><name>void</name></type>
<name>_PyObject_GC_Track</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>op</name></decl></param>)</parameter_list> <block>{
<expr_stmt><expr><call><name>PyObject_GC_Track</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>
<function><type><name>void</name></type>
<name>PyObject_GC_UnTrack</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>op</name></decl></param>)</parameter_list> <block>{
<if>if <condition>(<expr><call><name>IS_TRACKED</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<expr_stmt><expr><call><name>_PyObject_GC_UNTRACK</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
}</block></function>
<function><type><name>void</name></type>
<name>_PyObject_GC_UnTrack</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>op</name></decl></param>)</parameter_list> <block>{
<expr_stmt><expr><call><name>PyObject_GC_UnTrack</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>
<function><type><name>PyObject</name> *</type>
<name>_PyObject_GC_Malloc</name><parameter_list>(<param><decl><type><name>size_t</name></type> <name>basicsize</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>op</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyGC_Head</name> *</type><name>g</name></decl>;</decl_stmt>
<if>if <condition>(<expr><name>basicsize</name> &gt; <name>PY_SSIZE_T_MAX</name> - <sizeof>sizeof<argument_list>(<argument><expr><name>PyGC_Head</name></expr></argument>)</argument_list></sizeof></expr>)</condition><then>
<return>return <expr><call><name>PyErr_NoMemory</name><argument_list>()</argument_list></call></expr>;</return></then></if>
<expr_stmt><expr><name>g</name> = (<name>PyGC_Head</name> *)<call><name>PyObject_MALLOC</name><argument_list>(
<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PyGC_Head</name></expr></argument>)</argument_list></sizeof> + <name>basicsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>g</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><call><name>PyErr_NoMemory</name><argument_list>()</argument_list></call></expr>;</return></then></if>
<expr_stmt><expr><name><name>g</name>-&gt;<name>gc</name>.<name>gc_refs</name></name> = <name>GC_UNTRACKED</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>generations</name><index>[<expr>0</expr>]</index></name>.<name>count</name>++</expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>generations</name><index>[<expr>0</expr>]</index></name>.<name>count</name> &gt; <name><name>generations</name><index>[<expr>0</expr>]</index></name>.<name>threshold</name> &amp;&amp;
<name>enabled</name> &amp;&amp;
<name><name>generations</name><index>[<expr>0</expr>]</index></name>.<name>threshold</name> &amp;&amp;
!<name>collecting</name> &amp;&amp;
!<call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><name>collecting</name> = 1</expr>;</expr_stmt>
<expr_stmt><expr><call><name>collect_generations</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>collecting</name> = 0</expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><name>op</name> = <call><name>FROM_GC</name><argument_list>(<argument><expr><name>g</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>op</name></expr>;</return>
}</block></function>
<function><type><name>PyObject</name> *</type>
<name>_PyObject_GC_New</name><parameter_list>(<param><decl><type><name>PyTypeObject</name> *</type><name>tp</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>op</name> <init>= <expr><call><name>_PyObject_GC_Malloc</name><argument_list>(<argument><expr><call><name>_PyObject_SIZE</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>op</name> != <name>NULL</name></expr>)</condition><then>
<expr_stmt><expr><name>op</name> = <call><name>PyObject_INIT</name><argument_list>(<argument><expr><name>op</name></expr></argument>, <argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<return>return <expr><name>op</name></expr>;</return>
}</block></function>
<function><type><name>PyVarObject</name> *</type>
<name>_PyObject_GC_NewVar</name><parameter_list>(<param><decl><type><name>PyTypeObject</name> *</type><name>tp</name></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>nitems</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>size</name> <init>= <expr><call><name>_PyObject_VAR_SIZE</name><argument_list>(<argument><expr><name>tp</name></expr></argument>, <argument><expr><name>nitems</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyVarObject</name> *</type><name>op</name> <init>= <expr>(<name>PyVarObject</name> *) <call><name>_PyObject_GC_Malloc</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>op</name> != <name>NULL</name></expr>)</condition><then>
<expr_stmt><expr><name>op</name> = <call><name>PyObject_INIT_VAR</name><argument_list>(<argument><expr><name>op</name></expr></argument>, <argument><expr><name>tp</name></expr></argument>, <argument><expr><name>nitems</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<return>return <expr><name>op</name></expr>;</return>
}</block></function>
<function><type><name>PyVarObject</name> *</type>
<name>_PyObject_GC_Resize</name><parameter_list>(<param><decl><type><name>PyVarObject</name> *</type><name>op</name></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>nitems</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>basicsize</name> <init>= <expr><call><name>_PyObject_VAR_SIZE</name><argument_list>(<argument><expr><call><name>Py_TYPE</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>nitems</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyGC_Head</name> *</type><name>g</name> <init>= <expr><call><name>AS_GC</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>basicsize</name> &gt; <name>PY_SSIZE_T_MAX</name> - <sizeof>sizeof<argument_list>(<argument><expr><name>PyGC_Head</name></expr></argument>)</argument_list></sizeof></expr>)</condition><then>
<return>return <expr>(<name>PyVarObject</name> *)<call><name>PyErr_NoMemory</name><argument_list>()</argument_list></call></expr>;</return></then></if>
<expr_stmt><expr><name>g</name> = (<name>PyGC_Head</name> *)<call><name>PyObject_REALLOC</name><argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PyGC_Head</name></expr></argument>)</argument_list></sizeof> + <name>basicsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>g</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr>(<name>PyVarObject</name> *)<call><name>PyErr_NoMemory</name><argument_list>()</argument_list></call></expr>;</return></then></if>
<expr_stmt><expr><name>op</name> = (<name>PyVarObject</name> *) <call><name>FROM_GC</name><argument_list>(<argument><expr><name>g</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_SIZE</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call> = <name>nitems</name></expr>;</expr_stmt>
<return>return <expr><name>op</name></expr>;</return>
}</block></function>
<function><type><name>void</name></type>
<name>PyObject_GC_Del</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>op</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyGC_Head</name> *</type><name>g</name> <init>= <expr><call><name>AS_GC</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><call><name>IS_TRACKED</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<expr_stmt><expr><call><name>gc_list_remove</name><argument_list>(<argument><expr><name>g</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<if>if <condition>(<expr><name><name>generations</name><index>[<expr>0</expr>]</index></name>.<name>count</name> &gt; 0</expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>generations</name><index>[<expr>0</expr>]</index></name>.<name>count</name>--</expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><call><name>PyObject_FREE</name><argument_list>(<argument><expr><name>g</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>_PyObject_GC_Del</name></cpp:undef>
<function><type><name>void</name></type>
<name>_PyObject_GC_Del</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>op</name></decl></param>)</parameter_list> <block>{
<expr_stmt><expr><call><name>PyObject_GC_Del</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>
</unit>
