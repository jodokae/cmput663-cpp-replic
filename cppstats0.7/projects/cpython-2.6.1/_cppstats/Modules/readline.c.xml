<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C" filename="Modules/readline.c"><cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"Python.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;setjmp.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;signal.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;errno.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/time.h&gt;</cpp:file></cpp:include>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_SETLOCALE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SAVE_LOCALE</name></cpp:macro></cpp:define>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;locale.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SAVE_LOCALE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RESTORE_LOCALE</name><parameter_list>(<param><type><name>sl</name></type></param>)</parameter_list></cpp:macro> <cpp:value>{ setlocale(LC_CTYPE, sl); free(sl); }</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RESTORE_LOCALE</name><parameter_list>(<param><type><name>sl</name></type></param>)</parameter_list></cpp:macro></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>HAVE_CONFIG_H</name></cpp:undef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;readline/readline.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;readline/history.h&gt;</cpp:file></cpp:include>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_RL_COMPLETION_MATCHES</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>completion_matches</name><parameter_list>(<param><type><name>x</name></type></param>, <param><type><name>y</name></type></param>)</parameter_list></cpp:macro> <cpp:value>rl_completion_matches((x), ((rl_compentry_func_t *)(y)))</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_RL_FUNCTION_TYPEDEF</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function_decl><type><specifier>extern</specifier> <name>char</name> **</type><name>completion_matches</name><parameter_list>(<param><decl><type><name>char</name> *</type></decl></param>, <param><decl><type><name>rl_compentry_func_t</name> *</type></decl></param>)</parameter_list>;</function_decl>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<function_decl><type><specifier>extern</specifier> <name>char</name> **</type><name>completion_matches</name><parameter_list>(<param><decl><type><name>char</name> *</type></decl></param>, <param><decl><type><name>CPFunction</name> *</type></decl></param>)</parameter_list>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<function_decl><type><specifier>static</specifier> <name>void</name></type>
<name>on_completion_display_matches_hook</name><parameter_list>(<param><decl><type><name>char</name> **</type><name>matches</name></decl></param>,
<param><decl><type><name>int</name></type> <name>num_matches</name></decl></param>, <param><decl><type><name>int</name></type> <name>max_length</name></decl></param>)</parameter_list>;</function_decl>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>parse_and_bind</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>char</name> *</type><name>s</name></decl>, *<decl><type ref="prev"/><name>copy</name></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"s:parse_and_bind"</expr></argument>, <argument><expr>&amp;<name>s</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>copy</name> = <call><name>malloc</name><argument_list>(<argument><expr>1 + <call><name>strlen</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>copy</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><call><name>PyErr_NoMemory</name><argument_list>()</argument_list></call></expr>;</return></then></if>
<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>copy</name></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rl_parse_and_bind</name><argument_list>(<argument><expr><name>copy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>copy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>Py_RETURN_NONE</name></expr>;</expr_stmt>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>doc_parse_and_bind</name></expr></argument>,
<argument><expr>"parse_and_bind(string) -&gt; None\n\
Parse and execute single line of a readline init file."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>read_init_file</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>char</name> *</type><name>s</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"|z:read_init_file"</expr></argument>, <argument><expr>&amp;<name>s</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>errno</name> = <call><name>rl_read_init_file</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>errno</name></expr>)</condition><then>
<return>return <expr><call><name>PyErr_SetFromErrno</name><argument_list>(<argument><expr><name>PyExc_IOError</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
<expr_stmt><expr><name>Py_RETURN_NONE</name></expr>;</expr_stmt>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>doc_read_init_file</name></expr></argument>,
<argument><expr>"read_init_file([filename]) -&gt; None\n\
Parse a readline initialization file.\n\
The default filename is the last filename used."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>read_history_file</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>char</name> *</type><name>s</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"|z:read_history_file"</expr></argument>, <argument><expr>&amp;<name>s</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>errno</name> = <call><name>read_history</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>errno</name></expr>)</condition><then>
<return>return <expr><call><name>PyErr_SetFromErrno</name><argument_list>(<argument><expr><name>PyExc_IOError</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
<expr_stmt><expr><name>Py_RETURN_NONE</name></expr>;</expr_stmt>
}</block></function>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>_history_length</name> <init>= <expr>-1</expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>doc_read_history_file</name></expr></argument>,
<argument><expr>"read_history_file([filename]) -&gt; None\n\
Load a readline history file.\n\
The default filename is ~/.history."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>write_history_file</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>char</name> *</type><name>s</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"|z:write_history_file"</expr></argument>, <argument><expr>&amp;<name>s</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>errno</name> = <call><name>write_history</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>errno</name> &amp;&amp; <name>_history_length</name> &gt;= 0</expr>)</condition><then>
<expr_stmt><expr><call><name>history_truncate_file</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>_history_length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<if>if <condition>(<expr><name>errno</name></expr>)</condition><then>
<return>return <expr><call><name>PyErr_SetFromErrno</name><argument_list>(<argument><expr><name>PyExc_IOError</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
<expr_stmt><expr><name>Py_RETURN_NONE</name></expr>;</expr_stmt>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>doc_write_history_file</name></expr></argument>,
<argument><expr>"write_history_file([filename]) -&gt; None\n\
Save a readline history file.\n\
The default filename is ~/.history."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name>*</type>
<name>set_history_length</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>length</name> <init>= <expr><name>_history_length</name></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"i:set_history_length"</expr></argument>, <argument><expr>&amp;<name>length</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>_history_length</name> = <name>length</name></expr>;</expr_stmt>
<expr_stmt><expr><name>Py_RETURN_NONE</name></expr>;</expr_stmt>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>set_history_length_doc</name></expr></argument>,
<argument><expr>"set_history_length(length) -&gt; None\n\
set the maximal number of items which will be written to\n\
the history file. A negative length is used to inhibit\n\
history truncation."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name>*</type>
<name>get_history_length</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>noarg</name></decl></param>)</parameter_list> <block>{
<return>return <expr><call><name>PyInt_FromLong</name><argument_list>(<argument><expr><name>_history_length</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>get_history_length_doc</name></expr></argument>,
<argument><expr>"get_history_length() -&gt; int\n\
return the maximum number of items that will be written to\n\
the history file."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>set_hook</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>funcname</name></decl></param>, <param><decl><type><name>PyObject</name> **</type><name>hook_var</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>function</name> <init>= <expr><name>Py_None</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name><name>buf</name><index>[<expr>80</expr>]</index></name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>PyOS_snprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr>"|O:set_%.50s"</expr></argument>, <argument><expr><name>funcname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr>&amp;<name>function</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<if>if <condition>(<expr><name>function</name> == <name>Py_None</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr>*<name>hook_var</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr>*<name>hook_var</name> = <name>NULL</name></expr>;</expr_stmt>
}</block></then> <else>else <if>if <condition>(<expr><call><name>PyCallable_Check</name><argument_list>(<argument><expr><name>function</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>tmp</name> <init>= <expr>*<name>hook_var</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>function</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr>*<name>hook_var</name> = <name>function</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr><call><name>PyOS_snprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>,
<argument><expr>"set_%.50s(func): argument not callable"</expr></argument>,
<argument><expr><name>funcname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></else></if></else></if>
<expr_stmt><expr><name>Py_RETURN_NONE</name></expr>;</expr_stmt>
}</block></function>
<decl_stmt><decl><type><specifier>static</specifier> <name>PyObject</name> *</type><name>completion_display_matches_hook</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>PyObject</name> *</type><name>startup_hook</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_RL_PRE_INPUT_HOOK</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><specifier>static</specifier> <name>PyObject</name> *</type><name>pre_input_hook</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>set_completion_display_matches_hook</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>result</name> <init>= <expr><call><name>set_hook</name><argument_list>(<argument><expr>"completion_display_matches_hook"</expr></argument>,
<argument><expr>&amp;<name>completion_display_matches_hook</name></expr></argument>, <argument><expr><name>args</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_RL_COMPLETION_DISPLAY_MATCHES_HOOK</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><name>rl_completion_display_matches_hook</name> =
<name>completion_display_matches_hook</name> ?
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_RL_FUNCTION_TYPEDEF</name></expr></argument>)</argument_list></call></expr></cpp:if>
(<name>rl_compdisp_func_t</name> *)<name>on_completion_display_matches_hook</name> : 0</expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<expr_stmt><expr>(<name>VFunction</name> *)<name>on_completion_display_matches_hook</name> : 0</expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<return>return <expr><name>result</name></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>doc_set_completion_display_matches_hook</name></expr></argument>,
<argument><expr>"set_completion_display_matches_hook([function]) -&gt; None\n\
Set or remove the completion display function.\n\
The function is called as\n\
function(substitution, [matches], longest_match_length)\n\
once each time matches need to be displayed."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>set_startup_hook</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<return>return <expr><call><name>set_hook</name><argument_list>(<argument><expr>"startup_hook"</expr></argument>, <argument><expr>&amp;<name>startup_hook</name></expr></argument>, <argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>doc_set_startup_hook</name></expr></argument>,
<argument><expr>"set_startup_hook([function]) -&gt; None\n\
Set or remove the startup_hook function.\n\
The function is called with no arguments just\n\
before readline prints the first prompt."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_RL_PRE_INPUT_HOOK</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>set_pre_input_hook</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<return>return <expr><call><name>set_hook</name><argument_list>(<argument><expr>"pre_input_hook"</expr></argument>, <argument><expr>&amp;<name>pre_input_hook</name></expr></argument>, <argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>doc_set_pre_input_hook</name></expr></argument>,
<argument><expr>"set_pre_input_hook([function]) -&gt; None\n\
Set or remove the pre_input_hook function.\n\
The function is called with no arguments after the first prompt\n\
has been printed and just before readline starts reading input\n\
characters."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<decl_stmt><decl><type><specifier>static</specifier> <name>PyObject</name> *</type><name>completer</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>PyObject</name> *</type><name>begidx</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>PyObject</name> *</type><name>endidx</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>get_completion_type</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>noarg</name></decl></param>)</parameter_list> <block>{
<return>return <expr><call><name>PyInt_FromLong</name><argument_list>(<argument><expr><name>rl_completion_type</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>doc_get_completion_type</name></expr></argument>,
<argument><expr>"get_completion_type() -&gt; int\n\
Get the type of completion being attempted."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>get_begidx</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>noarg</name></decl></param>)</parameter_list> <block>{
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>begidx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>begidx</name></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>doc_get_begidx</name></expr></argument>,
<argument><expr>"get_begidx() -&gt; int\n\
get the beginning index of the readline tab-completion scope"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>get_endidx</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>noarg</name></decl></param>)</parameter_list> <block>{
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>endidx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>endidx</name></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>doc_get_endidx</name></expr></argument>,
<argument><expr>"get_endidx() -&gt; int\n\
get the ending index of the readline tab-completion scope"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>set_completer_delims</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>char</name> *</type><name>break_chars</name></decl>;</decl_stmt>
<if>if<condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"s:set_completer_delims"</expr></argument>, <argument><expr>&amp;<name>break_chars</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr>(<name>void</name>*)<name>rl_completer_word_break_characters</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>rl_completer_word_break_characters</name> = <call><name>strdup</name><argument_list>(<argument><expr><name>break_chars</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>Py_RETURN_NONE</name></expr>;</expr_stmt>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>doc_set_completer_delims</name></expr></argument>,
<argument><expr>"set_completer_delims(string) -&gt; None\n\
set the readline word delimiters for tab-completion"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>py_remove_history</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>entry_number</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>HIST_ENTRY</name> *</type><name>entry</name></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"i:remove_history"</expr></argument>, <argument><expr>&amp;<name>entry_number</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<if>if <condition>(<expr><name>entry_number</name> &lt; 0</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>,
<argument><expr>"History index cannot be negative"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>entry</name> = <call><name>remove_history</name><argument_list>(<argument><expr><name>entry_number</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>entry</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>,
<argument><expr>"No history item at position %d"</expr></argument>,
<argument><expr><name>entry_number</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<if>if <condition>(<expr><name><name>entry</name>-&gt;<name>line</name></name></expr>)</condition><then>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>entry</name>-&gt;<name>line</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<if>if <condition>(<expr><name><name>entry</name>-&gt;<name>data</name></name></expr>)</condition><then>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>entry</name>-&gt;<name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>Py_RETURN_NONE</name></expr>;</expr_stmt>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>doc_remove_history</name></expr></argument>,
<argument><expr>"remove_history_item(pos) -&gt; None\n\
remove history item given by its position"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>py_replace_history</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>entry_number</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>line</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>HIST_ENTRY</name> *</type><name>old_entry</name></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"is:replace_history"</expr></argument>, <argument><expr>&amp;<name>entry_number</name></expr></argument>,
<argument><expr>&amp;<name>line</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<if>if <condition>(<expr><name>entry_number</name> &lt; 0</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>,
<argument><expr>"History index cannot be negative"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>old_entry</name> = <call><name>replace_history_entry</name><argument_list>(<argument><expr><name>entry_number</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr>(<name>void</name> *)<name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>old_entry</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>,
<argument><expr>"No history item at position %d"</expr></argument>,
<argument><expr><name>entry_number</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<if>if <condition>(<expr><name><name>old_entry</name>-&gt;<name>line</name></name></expr>)</condition><then>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>old_entry</name>-&gt;<name>line</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<if>if <condition>(<expr><name><name>old_entry</name>-&gt;<name>data</name></name></expr>)</condition><then>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>old_entry</name>-&gt;<name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>old_entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>Py_RETURN_NONE</name></expr>;</expr_stmt>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>doc_replace_history</name></expr></argument>,
<argument><expr>"replace_history_item(pos, line) -&gt; None\n\
replaces history item given by its position with contents of line"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>py_add_history</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>char</name> *</type><name>line</name></decl>;</decl_stmt>
<if>if<condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"s:add_history"</expr></argument>, <argument><expr>&amp;<name>line</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><call><name>add_history</name><argument_list>(<argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>Py_RETURN_NONE</name></expr>;</expr_stmt>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>doc_add_history</name></expr></argument>,
<argument><expr>"add_history(string) -&gt; None\n\
add a line to the history buffer"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>get_completer_delims</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>noarg</name></decl></param>)</parameter_list> <block>{
<return>return <expr><call><name>PyString_FromString</name><argument_list>(<argument><expr><name>rl_completer_word_break_characters</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>doc_get_completer_delims</name></expr></argument>,
<argument><expr>"get_completer_delims() -&gt; string\n\
get the readline word delimiters for tab-completion"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>set_completer</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<return>return <expr><call><name>set_hook</name><argument_list>(<argument><expr>"completer"</expr></argument>, <argument><expr>&amp;<name>completer</name></expr></argument>, <argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>doc_set_completer</name></expr></argument>,
<argument><expr>"set_completer([function]) -&gt; None\n\
Set or remove the completer function.\n\
The function is called as function(text, state),\n\
for state in 0, 1, 2, ..., until it returns a non-string.\n\
It should return the next possible completion starting with 'text'."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>get_completer</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>noargs</name></decl></param>)</parameter_list> <block>{
<if>if <condition>(<expr><name>completer</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>Py_RETURN_NONE</name></expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>completer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>completer</name></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>doc_get_completer</name></expr></argument>,
<argument><expr>"get_completer() -&gt; function\n\
\n\
Returns current completer function."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>get_history_item</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>idx</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>HIST_ENTRY</name> *</type><name>hist_ent</name></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"i:index"</expr></argument>, <argument><expr>&amp;<name>idx</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<if>if <condition>(<expr>(<name>hist_ent</name> = <call><name>history_get</name><argument_list>(<argument><expr><name>idx</name></expr></argument>)</argument_list></call>)</expr>)</condition><then>
<return>return <expr><call><name>PyString_FromString</name><argument_list>(<argument><expr><name><name>hist_ent</name>-&gt;<name>line</name></name></expr></argument>)</argument_list></call></expr>;</return></then>
<else>else <block>{
<expr_stmt><expr><name>Py_RETURN_NONE</name></expr>;</expr_stmt>
}</block></else></if>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>doc_get_history_item</name></expr></argument>,
<argument><expr>"get_history_item() -&gt; string\n\
return the current contents of history item at index."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>get_current_history_length</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>noarg</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>HISTORY_STATE</name> *</type><name>hist_st</name></decl>;</decl_stmt>
<expr_stmt><expr><name>hist_st</name> = <call><name>history_get_history_state</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>PyInt_FromLong</name><argument_list>(<argument><expr><name>hist_st</name> ? (<name>long</name>) <name><name>hist_st</name>-&gt;<name>length</name></name> : (<name>long</name>) 0</expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>doc_get_current_history_length</name></expr></argument>,
<argument><expr>"get_current_history_length() -&gt; integer\n\
return the current (not the maximum) length of history."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>get_line_buffer</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>noarg</name></decl></param>)</parameter_list> <block>{
<return>return <expr><call><name>PyString_FromString</name><argument_list>(<argument><expr><name>rl_line_buffer</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>doc_get_line_buffer</name></expr></argument>,
<argument><expr>"get_line_buffer() -&gt; string\n\
return the current contents of the line buffer."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_RL_COMPLETION_APPEND_CHARACTER</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>py_clear_history</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>noarg</name></decl></param>)</parameter_list> <block>{
<expr_stmt><expr><call><name>clear_history</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>Py_RETURN_NONE</name></expr>;</expr_stmt>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>doc_clear_history</name></expr></argument>,
<argument><expr>"clear_history() -&gt; None\n\
Clear the current readline history."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>insert_text</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>char</name> *</type><name>s</name></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"s:insert_text"</expr></argument>, <argument><expr>&amp;<name>s</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><call><name>rl_insert_text</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>Py_RETURN_NONE</name></expr>;</expr_stmt>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>doc_insert_text</name></expr></argument>,
<argument><expr>"insert_text(string) -&gt; None\n\
Insert text into the command line."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>redisplay</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>noarg</name></decl></param>)</parameter_list> <block>{
<expr_stmt><expr><call><name>rl_redisplay</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>Py_RETURN_NONE</name></expr>;</expr_stmt>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>doc_redisplay</name></expr></argument>,
<argument><expr>"redisplay() -&gt; None\n\
Change what's displayed on the screen to reflect the current\n\
contents of the line buffer."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><specifier>static</specifier> struct <name>PyMethodDef</name></type> <name><name>readline_methods</name><index>[]</index></name> <init>= <expr><block>{
<expr><block>{<expr>"parse_and_bind"</expr>, <expr><name>parse_and_bind</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>doc_parse_and_bind</name></expr>}</block></expr>,
<expr><block>{<expr>"get_line_buffer"</expr>, <expr><name>get_line_buffer</name></expr>, <expr><name>METH_NOARGS</name></expr>, <expr><name>doc_get_line_buffer</name></expr>}</block></expr>,
<expr><block>{<expr>"insert_text"</expr>, <expr><name>insert_text</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>doc_insert_text</name></expr>}</block></expr>,
<expr><block>{<expr>"redisplay"</expr>, <expr><name>redisplay</name></expr>, <expr><name>METH_NOARGS</name></expr>, <expr><name>doc_redisplay</name></expr>}</block></expr>,
<expr><block>{<expr>"read_init_file"</expr>, <expr><name>read_init_file</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>doc_read_init_file</name></expr>}</block></expr>,
<expr><block>{
<expr>"read_history_file"</expr>, <expr><name>read_history_file</name></expr>,
<expr><name>METH_VARARGS</name></expr>, <expr><name>doc_read_history_file</name></expr>
}</block></expr>,
<expr><block>{
<expr>"write_history_file"</expr>, <expr><name>write_history_file</name></expr>,
<expr><name>METH_VARARGS</name></expr>, <expr><name>doc_write_history_file</name></expr>
}</block></expr>,
<expr><block>{
<expr>"get_history_item"</expr>, <expr><name>get_history_item</name></expr>,
<expr><name>METH_VARARGS</name></expr>, <expr><name>doc_get_history_item</name></expr>
}</block></expr>,
<expr><block>{
<expr>"get_current_history_length"</expr>, <expr>(<name>PyCFunction</name>)<name>get_current_history_length</name></expr>,
<expr><name>METH_NOARGS</name></expr>, <expr><name>doc_get_current_history_length</name></expr>
}</block></expr>,
<expr><block>{
<expr>"set_history_length"</expr>, <expr><name>set_history_length</name></expr>,
<expr><name>METH_VARARGS</name></expr>, <expr><name>set_history_length_doc</name></expr>
}</block></expr>,
<expr><block>{
<expr>"get_history_length"</expr>, <expr><name>get_history_length</name></expr>,
<expr><name>METH_NOARGS</name></expr>, <expr><name>get_history_length_doc</name></expr>
}</block></expr>,
<expr><block>{<expr>"set_completer"</expr>, <expr><name>set_completer</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>doc_set_completer</name></expr>}</block></expr>,
<expr><block>{<expr>"get_completer"</expr>, <expr><name>get_completer</name></expr>, <expr><name>METH_NOARGS</name></expr>, <expr><name>doc_get_completer</name></expr>}</block></expr>,
<expr><block>{
<expr>"get_completion_type"</expr>, <expr><name>get_completion_type</name></expr>,
<expr><name>METH_NOARGS</name></expr>, <expr><name>doc_get_completion_type</name></expr>
}</block></expr>,
<expr><block>{<expr>"get_begidx"</expr>, <expr><name>get_begidx</name></expr>, <expr><name>METH_NOARGS</name></expr>, <expr><name>doc_get_begidx</name></expr>}</block></expr>,
<expr><block>{<expr>"get_endidx"</expr>, <expr><name>get_endidx</name></expr>, <expr><name>METH_NOARGS</name></expr>, <expr><name>doc_get_endidx</name></expr>}</block></expr>,
<expr><block>{
<expr>"set_completer_delims"</expr>, <expr><name>set_completer_delims</name></expr>,
<expr><name>METH_VARARGS</name></expr>, <expr><name>doc_set_completer_delims</name></expr>
}</block></expr>,
<expr><block>{<expr>"add_history"</expr>, <expr><name>py_add_history</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>doc_add_history</name></expr>}</block></expr>,
<expr><block>{<expr>"remove_history_item"</expr>, <expr><name>py_remove_history</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>doc_remove_history</name></expr>}</block></expr>,
<expr><block>{<expr>"replace_history_item"</expr>, <expr><name>py_replace_history</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>doc_replace_history</name></expr>}</block></expr>,
<expr><block>{
<expr>"get_completer_delims"</expr>, <expr><name>get_completer_delims</name></expr>,
<expr><name>METH_NOARGS</name></expr>, <expr><name>doc_get_completer_delims</name></expr>
}</block></expr>,
<expr><block>{
<expr>"set_completion_display_matches_hook"</expr>, <expr><name>set_completion_display_matches_hook</name></expr>,
<expr><name>METH_VARARGS</name></expr>, <expr><name>doc_set_completion_display_matches_hook</name></expr>
}</block></expr>,
<expr><block>{
<expr>"set_startup_hook"</expr>, <expr><name>set_startup_hook</name></expr>,
<expr><name>METH_VARARGS</name></expr>, <expr><name>doc_set_startup_hook</name></expr>
}</block></expr>,
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_RL_PRE_INPUT_HOOK</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{
<expr>"set_pre_input_hook"</expr>, <expr><name>set_pre_input_hook</name></expr>,
<expr><name>METH_VARARGS</name></expr>, <expr><name>doc_set_pre_input_hook</name></expr>
}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_RL_COMPLETION_APPEND_CHARACTER</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"clear_history"</expr>, <expr><name>py_clear_history</name></expr>, <expr><name>METH_NOARGS</name></expr>, <expr><name>doc_clear_history</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr><block>{<expr>0</expr>, <expr>0</expr>}</block></expr>
}</block></expr></init></decl>;</decl_stmt>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>on_hook</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>func</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>result</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>func</name> != <name>NULL</name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>r</name></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>WITH_THREAD</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>PyGILState_STATE</name></type> <name>gilstate</name> <init>= <expr><call><name>PyGILState_Ensure</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><name>r</name> = <call><name>PyObject_CallFunction</name><argument_list>(<argument><expr><name>func</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>r</name> == <name>NULL</name></expr>)</condition><then>
<goto>goto <name>error</name>;</goto></then></if>
<if>if <condition>(<expr><name>r</name> == <name>Py_None</name></expr>)</condition><then>
<expr_stmt><expr><name>result</name> = 0</expr>;</expr_stmt></then>
<else>else <block>{
<expr_stmt><expr><name>result</name> = <call><name>PyInt_AsLong</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>result</name> == -1 &amp;&amp; <call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then>
<goto>goto <name>error</name>;</goto></then></if>
}</block></else></if>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>done</name>;</goto>
<label><name>error</name>:</label>
<expr_stmt><expr><call><name>PyErr_Clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<label><name>done</name>:</label>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>WITH_THREAD</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyGILState_Release</name><argument_list>(<argument><expr><name>gilstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<return>return <expr><name>result</name></expr>;</return>
}</block></then></if>
<return>return <expr><name>result</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>on_startup_hook</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list> <block>{
<return>return <expr><call><name>on_hook</name><argument_list>(<argument><expr><name>startup_hook</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_RL_PRE_INPUT_HOOK</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>on_pre_input_hook</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list> <block>{
<return>return <expr><call><name>on_hook</name><argument_list>(<argument><expr><name>pre_input_hook</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>on_completion_display_matches_hook</name><parameter_list>(<param><decl><type><name>char</name> **</type><name>matches</name></decl></param>,
<param><decl><type><name>int</name></type> <name>num_matches</name></decl></param>, <param><decl><type><name>int</name></type> <name>max_length</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>m</name><init>=<expr><name>NULL</name></expr></init>, *<name>s</name><init>=<expr><name>NULL</name></expr></init>, *<name>r</name><init>=<expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>WITH_THREAD</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>PyGILState_STATE</name></type> <name>gilstate</name> <init>= <expr><call><name>PyGILState_Ensure</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><name>m</name> = <call><name>PyList_New</name><argument_list>(<argument><expr><name>num_matches</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>m</name> == <name>NULL</name></expr>)</condition><then>
<goto>goto <name>error</name>;</goto></then></if>
<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>num_matches</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
<expr_stmt><expr><name>s</name> = <call><name>PyString_FromString</name><argument_list>(<argument><expr><name><name>matches</name><index>[<expr><name>i</name>+1</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>s</name> == <name>NULL</name></expr>)</condition><then>
<goto>goto <name>error</name>;</goto></then></if>
<if>if <condition>(<expr><call><name>PyList_SetItem</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call> == -1</expr>)</condition><then>
<goto>goto <name>error</name>;</goto></then></if>
}</block></for>
<expr_stmt><expr><name>r</name> = <call><name>PyObject_CallFunction</name><argument_list>(<argument><expr><name>completion_display_matches_hook</name></expr></argument>,
<argument><expr>"sOi"</expr></argument>, <argument><expr><name><name>matches</name><index>[<expr>0</expr>]</index></name></expr></argument>, <argument><expr><name>m</name></expr></argument>, <argument><expr><name>max_length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>m</name></expr></argument>)</argument_list></call></expr>, <expr><name>m</name>=<name>NULL</name></expr>;</expr_stmt>
<if>if <condition>(<expr><name>r</name> == <name>NULL</name> ||
(<name>r</name> != <name>Py_None</name> &amp;&amp; <call><name>PyInt_AsLong</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call> == -1 &amp;&amp; <call><name>PyErr_Occurred</name><argument_list>()</argument_list></call>)</expr>)</condition><then> <block>{
<goto>goto <name>error</name>;</goto>
}</block></then></if>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>, <expr><name>r</name>=<name>NULL</name></expr>;</expr_stmt>
<if>if <condition>(<expr>0</expr>)</condition><then> <block>{
<label><name>error</name>:</label>
<expr_stmt><expr><call><name>PyErr_Clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>m</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>WITH_THREAD</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyGILState_Release</name><argument_list>(<argument><expr><name>gilstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></function>
<function><type><specifier>static</specifier> <name>char</name> *</type>
<name>on_completion</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>text</name></decl></param>, <param><decl><type><name>int</name></type> <name>state</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>char</name> *</type><name>result</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>completer</name> != <name>NULL</name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>r</name></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>WITH_THREAD</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>PyGILState_STATE</name></type> <name>gilstate</name> <init>= <expr><call><name>PyGILState_Ensure</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><name>rl_attempted_completion_over</name> = 1</expr>;</expr_stmt>
<expr_stmt><expr><name>r</name> = <call><name>PyObject_CallFunction</name><argument_list>(<argument><expr><name>completer</name></expr></argument>, <argument><expr>"si"</expr></argument>, <argument><expr><name>text</name></expr></argument>, <argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>r</name> == <name>NULL</name></expr>)</condition><then>
<goto>goto <name>error</name>;</goto></then></if>
<if>if <condition>(<expr><name>r</name> == <name>Py_None</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>result</name> = <name>NULL</name></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<decl_stmt><decl><type><name>char</name> *</type><name>s</name> <init>= <expr><call><name>PyString_AsString</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>s</name> == <name>NULL</name></expr>)</condition><then>
<goto>goto <name>error</name>;</goto></then></if>
<expr_stmt><expr><name>result</name> = <call><name>strdup</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></else></if>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>done</name>;</goto>
<label><name>error</name>:</label>
<expr_stmt><expr><call><name>PyErr_Clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<label><name>done</name>:</label>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>WITH_THREAD</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyGILState_Release</name><argument_list>(<argument><expr><name>gilstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<return>return <expr><name>result</name></expr>;</return>
}</block></then></if>
<return>return <expr><name>result</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>char</name> **</type>
<name>flex_complete</name><parameter_list>(<param><decl><type><name>char</name> *</type><name>text</name></decl></param>, <param><decl><type><name>int</name></type> <name>start</name></decl></param>, <param><decl><type><name>int</name></type> <name>end</name></decl></param>)</parameter_list> <block>{
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>begidx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>endidx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>begidx</name> = <call><name>PyInt_FromLong</name><argument_list>(<argument><expr>(<name>long</name>) <name>start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>endidx</name> = <call><name>PyInt_FromLong</name><argument_list>(<argument><expr>(<name>long</name>) <name>end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>completion_matches</name><argument_list>(<argument><expr><name>text</name></expr></argument>, <argument><expr>*<name>on_completion</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>setup_readline</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list> <block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SAVE_LOCALE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>char</name> *</type><name>saved_locale</name> <init>= <expr><call><name>strdup</name><argument_list>(<argument><expr><call><name>setlocale</name><argument_list>(<argument><expr><name>LC_CTYPE</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr>!<name>saved_locale</name></expr>)</condition><then>
<expr_stmt><expr><call><name>Py_FatalError</name><argument_list>(<argument><expr>"not enough memory to save locale"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><call><name>using_history</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>rl_readline_name</name> = "python"</expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>PYOS_OS2</name></expr></argument>)</argument_list></call> &amp;&amp; <call><name>defined</name><argument_list>(<argument><expr><name>PYCC_GCC</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><name>rl_terminal_name</name> = <call><name>getenv</name><argument_list>(<argument><expr>"TERM"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><call><name>rl_bind_key</name><argument_list>(<argument><expr>'\t'</expr></argument>, <argument><expr><name>rl_insert</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rl_bind_key_in_map</name> <argument_list>(<argument><expr>'\t'</expr></argument>, <argument><expr><name>rl_complete</name></expr></argument>, <argument><expr><name>emacs_meta_keymap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rl_bind_key_in_map</name> <argument_list>(<argument><expr>'\033'</expr></argument>, <argument><expr><name>rl_complete</name></expr></argument>, <argument><expr><name>emacs_meta_keymap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>rl_startup_hook</name> = (<name>Function</name> *)<name>on_startup_hook</name></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_RL_PRE_INPUT_HOOK</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><name>rl_pre_input_hook</name> = (<name>Function</name> *)<name>on_pre_input_hook</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><name>rl_attempted_completion_function</name> = (<name>CPPFunction</name> *)<name>flex_complete</name></expr>;</expr_stmt>
<expr_stmt><expr><name>rl_completer_word_break_characters</name> =
<call><name>strdup</name><argument_list>(<argument><expr>" \t\n`~!@#$%^&amp;*()-=+[{]}\\|;:'\",&lt;&gt;/?"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_RL_COMPLETION_APPEND_CHARACTER</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><name>rl_completion_append_character</name> ='\0'</expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><name>begidx</name> = <call><name>PyInt_FromLong</name><argument_list>(<argument><expr>0L</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>endidx</name> = <call><name>PyInt_FromLong</name><argument_list>(<argument><expr>0L</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rl_initialize</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<macro><name>RESTORE_LOCALE</name><argument_list>(<argument>saved_locale</argument>)</argument_list></macro>
}</block></function>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_RL_CALLBACK</name></expr></argument>)</argument_list></call> &amp;&amp; <call><name>defined</name><argument_list>(<argument><expr><name>HAVE_SELECT</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> *</type><name>completed_input_string</name></decl>;</decl_stmt>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>rlhandler</name><parameter_list>(<param><decl><type><name>char</name> *</type><name>text</name></decl></param>)</parameter_list> <block>{
<expr_stmt><expr><name>completed_input_string</name> = <name>text</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rl_callback_handler_remove</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
}</block></function>
<decl_stmt><decl><type><specifier>extern</specifier> <name>PyThreadState</name>*</type> <name>_PyOS_ReadlineTState</name></decl>;</decl_stmt>
<function><type><specifier>static</specifier> <name>char</name> *</type>
<name>readline_until_enter_or_signal</name><parameter_list>(<param><decl><type><name>char</name> *</type><name>prompt</name></decl></param>, <param><decl><type><name>int</name> *</type><name>signal</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>char</name> *</type> <name>not_done_reading</name> <init>= <expr>""</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>fd_set</name></type> <name>selectset</name></decl>;</decl_stmt>
<expr_stmt><expr>*<name>signal</name> = 0</expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_RL_CATCH_SIGNAL</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><name>rl_catch_signals</name> = 0</expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><call><name>rl_callback_handler_install</name> <argument_list>(<argument><expr><name>prompt</name></expr></argument>, <argument><expr><name>rlhandler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>FD_ZERO</name><argument_list>(<argument><expr>&amp;<name>selectset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>completed_input_string</name> = <name>not_done_reading</name></expr>;</expr_stmt>
<while>while <condition>(<expr><name>completed_input_string</name> == <name>not_done_reading</name></expr>)</condition> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>has_input</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<while>while <condition>(<expr>!<name>has_input</name></expr>)</condition> <block>{
<decl_stmt><decl><type>struct <name>timeval</name></type> <name>timeout</name> <init>= <expr><block>{<expr>0</expr>, <expr>100000</expr>}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type>struct <name>timeval</name> *</type><name>timeoutp</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>PyOS_InputHook</name></expr>)</condition><then>
<expr_stmt><expr><name>timeoutp</name> = &amp;<name>timeout</name></expr>;</expr_stmt></then></if>
<expr_stmt><expr><call><name>FD_SET</name><argument_list>(<argument><expr><call><name>fileno</name><argument_list>(<argument><expr><name>rl_instream</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>&amp;<name>selectset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>has_input</name> = <call><name>select</name><argument_list>(<argument><expr><call><name>fileno</name><argument_list>(<argument><expr><name>rl_instream</name></expr></argument>)</argument_list></call> + 1</expr></argument>, <argument><expr>&amp;<name>selectset</name></expr></argument>,
<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>timeoutp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if<condition>(<expr><name>PyOS_InputHook</name></expr>)</condition><then> <expr_stmt><expr><call><name>PyOS_InputHook</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>
}</block></while>
<if>if<condition>(<expr><name>has_input</name> &gt; 0</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>rl_callback_read_char</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else <if>if <condition>(<expr><name>errno</name> == <name>EINTR</name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>s</name></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>WITH_THREAD</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyEval_RestoreThread</name><argument_list>(<argument><expr><name>_PyOS_ReadlineTState</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><name>s</name> = <call><name>PyErr_CheckSignals</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>WITH_THREAD</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyEval_SaveThread</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<if>if <condition>(<expr><name>s</name> &lt; 0</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>rl_free_line_state</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rl_cleanup_after_signal</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rl_callback_handler_remove</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr>*<name>signal</name> = 1</expr>;</expr_stmt>
<expr_stmt><expr><name>completed_input_string</name> = <name>NULL</name></expr>;</expr_stmt>
}</block></then></if>
}</block></then></if></else></if>
}</block></while>
<return>return <expr><name>completed_input_string</name></expr>;</return>
}</block></function>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<decl_stmt><decl><type><specifier>static</specifier> <name>jmp_buf</name></type> <name>jbuf</name></decl>;</decl_stmt>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>onintr</name><parameter_list>(<param><decl><type><name>int</name></type> <name>sig</name></decl></param>)</parameter_list> <block>{
<expr_stmt><expr><call><name>longjmp</name><argument_list>(<argument><expr><name>jbuf</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>
<function><type><specifier>static</specifier> <name>char</name> *</type>
<name>readline_until_enter_or_signal</name><parameter_list>(<param><decl><type><name>char</name> *</type><name>prompt</name></decl></param>, <param><decl><type><name>int</name> *</type><name>signal</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyOS_sighandler_t</name></type> <name>old_inthandler</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>p</name></decl>;</decl_stmt>
<expr_stmt><expr>*<name>signal</name> = 0</expr>;</expr_stmt>
<expr_stmt><expr><name>old_inthandler</name> = <call><name>PyOS_setsig</name><argument_list>(<argument><expr><name>SIGINT</name></expr></argument>, <argument><expr><name>onintr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>setjmp</name><argument_list>(<argument><expr><name>jbuf</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_SIGRELSE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>sigrelse</name><argument_list>(<argument><expr><name>SIGINT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><call><name>PyOS_setsig</name><argument_list>(<argument><expr><name>SIGINT</name></expr></argument>, <argument><expr><name>old_inthandler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr>*<name>signal</name> = 1</expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>rl_event_hook</name> = <name>PyOS_InputHook</name></expr>;</expr_stmt>
<expr_stmt><expr><name>p</name> = <call><name>readline</name><argument_list>(<argument><expr><name>prompt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyOS_setsig</name><argument_list>(<argument><expr><name>SIGINT</name></expr></argument>, <argument><expr><name>old_inthandler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>p</name></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<function><type><specifier>static</specifier> <name>char</name> *</type>
<name>call_readline</name><parameter_list>(<param><decl><type><name>FILE</name> *</type><name>sys_stdin</name></decl></param>, <param><decl><type><name>FILE</name> *</type><name>sys_stdout</name></decl></param>, <param><decl><type><name>char</name> *</type><name>prompt</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>size_t</name></type> <name>n</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>p</name></decl>, *<decl><type ref="prev"/><name>q</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>signal</name></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SAVE_LOCALE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>char</name> *</type><name>saved_locale</name> <init>= <expr><call><name>strdup</name><argument_list>(<argument><expr><call><name>setlocale</name><argument_list>(<argument><expr><name>LC_CTYPE</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr>!<name>saved_locale</name></expr>)</condition><then>
<expr_stmt><expr><call><name>Py_FatalError</name><argument_list>(<argument><expr>"not enough memory to save locale"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<expr_stmt><expr><call><name>setlocale</name><argument_list>(<argument><expr><name>LC_CTYPE</name></expr></argument>, <argument><expr>""</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<if>if <condition>(<expr><name>sys_stdin</name> != <name>rl_instream</name> || <name>sys_stdout</name> != <name>rl_outstream</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>rl_instream</name> = <name>sys_stdin</name></expr>;</expr_stmt>
<expr_stmt><expr><name>rl_outstream</name> = <name>sys_stdout</name></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_RL_COMPLETION_APPEND_CHARACTER</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>rl_prep_terminal</name> <argument_list>(<argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></then></if>
<expr_stmt><expr><name>p</name> = <call><name>readline_until_enter_or_signal</name><argument_list>(<argument><expr><name>prompt</name></expr></argument>, <argument><expr>&amp;<name>signal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>signal</name></expr>)</condition><then> <block>{
<macro><name>RESTORE_LOCALE</name><argument_list>(<argument>saved_locale</argument>)</argument_list></macro>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<if>if <condition>(<expr><name>p</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>p</name> = <call><name>PyMem_Malloc</name><argument_list>(<argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>p</name> != <name>NULL</name></expr>)</condition><then>
<expr_stmt><expr>*<name>p</name> = '\0'</expr>;</expr_stmt></then></if>
<macro><name>RESTORE_LOCALE</name><argument_list>(<argument>saved_locale</argument>)</argument_list></macro>
<return>return <expr><name>p</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>n</name> = <call><name>strlen</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>n</name> &gt; 0</expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>char</name> *</type><name>line</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>HISTORY_STATE</name> *</type><name>state</name> <init>= <expr><call><name>history_get_history_state</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name><name>state</name>-&gt;<name>length</name></name> &gt; 0</expr>)</condition><then>
<expr_stmt><expr><name>line</name> = <call><name>history_get</name><argument_list>(<argument><expr><name><name>state</name>-&gt;<name>length</name></name></expr></argument>)</argument_list></call>-&gt;<name>line</name></expr>;</expr_stmt></then>
<else>else
<expr_stmt><expr><name>line</name> = ""</expr>;</expr_stmt></else></if>
<if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<expr_stmt><expr><call><name>add_history</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><name>q</name> = <name>p</name></expr>;</expr_stmt>
<expr_stmt><expr><name>p</name> = <call><name>PyMem_Malloc</name><argument_list>(<argument><expr><name>n</name>+2</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>p</name> != <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>strncpy</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>q</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>p</name><index>[<expr><name>n</name></expr>]</index></name> = '\n'</expr>;</expr_stmt>
<expr_stmt><expr><name><name>p</name><index>[<expr><name>n</name>+1</expr>]</index></name> = '\0'</expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>q</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<macro><name>RESTORE_LOCALE</name><argument_list>(<argument>saved_locale</argument>)</argument_list></macro>
<return>return <expr><name>p</name></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>doc_module</name></expr></argument>,
<argument><expr>"Importing this module enables command line editing using GNU readline."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><name>PyMODINIT_FUNC</name></type>
<name>initreadline</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>m</name></decl>;</decl_stmt>
<expr_stmt><expr><name>m</name> = <call><name>Py_InitModule4</name><argument_list>(<argument><expr>"readline"</expr></argument>, <argument><expr><name>readline_methods</name></expr></argument>, <argument><expr><name>doc_module</name></expr></argument>,
<argument><expr>(<name>PyObject</name> *)<name>NULL</name></expr></argument>, <argument><expr><name>PYTHON_API_VERSION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>m</name> == <name>NULL</name></expr>)</condition><then>
<return>return;</return></then></if>
<expr_stmt><expr><name>PyOS_ReadlineFunctionPointer</name> = <name>call_readline</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>setup_readline</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
}</block></function>
</unit>
