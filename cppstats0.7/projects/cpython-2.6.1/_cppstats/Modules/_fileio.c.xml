<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C" filename="projects/cpython-2.6.1/_cppstats/Modules/_fileio.c"><cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PY_SSIZE_T_CLEAN</name></cpp:macro></cpp:define>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"Python.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/types.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/stat.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;fcntl.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stddef.h&gt;</cpp:file></cpp:include>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MS_WINDOWS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HAVE_FTRUNCATE</name></cpp:macro></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WIN32_LEAN_AND_MEAN</name></cpp:macro></cpp:define>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;windows.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<typedef>typedef <type><struct>struct <block>{
<decl_stmt><decl><type><name>PyObject_HEAD</name>
<name>int</name></type> <name>fd</name></decl>;</decl_stmt>
<expr_stmt><expr><name>unsigned</name> <name>readable</name> : 1</expr>;</expr_stmt>
<expr_stmt><expr><name>unsigned</name> <name>writable</name> : 1</expr>;</expr_stmt>
<expr_stmt><expr><name>int</name> <name>seekable</name> : 2</expr>;</expr_stmt>
<expr_stmt><expr><name>int</name> <name>closefd</name> : 1</expr>;</expr_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>weakreflist</name></decl>;</decl_stmt>
}</block></struct></type> <name>PyFileIOObject</name>;</typedef>
<decl_stmt><decl><type><name>PyTypeObject</name></type> <name>PyFileIO_Type</name></decl>;</decl_stmt>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PyFileIO_Check</name><parameter_list>(<param><type><name>op</name></type></param>)</parameter_list></cpp:macro> <cpp:value>(PyObject_TypeCheck((op), &amp;PyFileIO_Type))</cpp:value></cpp:define>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>internal_close</name><parameter_list>(<param><decl><type><name>PyFileIOObject</name> *</type><name>self</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>save_errno</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name><name>self</name>-&gt;<name>fd</name></name> &gt;= 0</expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>fd</name> <init>= <expr><name><name>self</name>-&gt;<name>fd</name></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>self</name>-&gt;<name>fd</name></name> = -1</expr>;</expr_stmt>
<macro><name>Py_BEGIN_ALLOW_THREADS</name></macro>
<if>if <condition>(<expr><call><name>close</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
<expr_stmt><expr><name>save_errno</name> = <name>errno</name></expr>;</expr_stmt></then></if>
<expr_stmt><expr><name>Py_END_ALLOW_THREADS</name></expr></expr_stmt>
}</block></then></if>
<return>return <expr><name>save_errno</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>fileio_close</name><parameter_list>(<param><decl><type><name>PyFileIOObject</name> *</type><name>self</name></decl></param>)</parameter_list> <block>{
<if>if <condition>(<expr>!<name><name>self</name>-&gt;<name>closefd</name></name></expr>)</condition><then> <block>{
<if>if <condition>(<expr><call><name>PyErr_WarnEx</name><argument_list>(<argument><expr><name>PyExc_RuntimeWarning</name></expr></argument>,
<argument><expr>"Trying to close unclosable fd!"</expr></argument>, <argument><expr>3</expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then> <block>{
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>Py_RETURN_NONE</name></expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><name>errno</name> = <call><name>internal_close</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>errno</name> &lt; 0</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetFromErrno</name><argument_list>(<argument><expr><name>PyExc_IOError</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>Py_RETURN_NONE</name></expr>;</expr_stmt>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>fileio_new</name><parameter_list>(<param><decl><type><name>PyTypeObject</name> *</type><name>type</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>kews</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyFileIOObject</name> *</type><name>self</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>type</name> != <name>NULL</name> &amp;&amp; <name><name>type</name>-&gt;<name>tp_alloc</name></name> != <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>self</name> = (<name>PyFileIOObject</name> *) <call><name><name>type</name>-&gt;<name>tp_alloc</name></name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>self</name> != <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>self</name>-&gt;<name>fd</name></name> = -1</expr>;</expr_stmt>
<expr_stmt><expr><name><name>self</name>-&gt;<name>readable</name></name> = 0</expr>;</expr_stmt>
<expr_stmt><expr><name><name>self</name>-&gt;<name>writable</name></name> = 0</expr>;</expr_stmt>
<expr_stmt><expr><name><name>self</name>-&gt;<name>seekable</name></name> = -1</expr>;</expr_stmt>
<expr_stmt><expr><name><name>self</name>-&gt;<name>closefd</name></name> = 1</expr>;</expr_stmt>
<expr_stmt><expr><name><name>self</name>-&gt;<name>weakreflist</name></name> = <name>NULL</name></expr>;</expr_stmt>
}</block></then></if>
<return>return <expr>(<name>PyObject</name> *) <name>self</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>dircheck</name><parameter_list>(<param><decl><type><name>PyFileIOObject</name>*</type> <name>self</name></decl></param>)</parameter_list> <block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_FSTAT</name></expr></argument>)</argument_list></call> &amp;&amp; <call><name>defined</name><argument_list>(<argument><expr><name>S_IFDIR</name></expr></argument>)</argument_list></call> &amp;&amp; <call><name>defined</name><argument_list>(<argument><expr><name>EISDIR</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type>struct <name>stat</name></type> <name>buf</name></decl>;</decl_stmt>
<if>if <condition>(<expr><name><name>self</name>-&gt;<name>fd</name></name> &lt; 0</expr>)</condition><then>
<return>return <expr>0</expr>;</return></then></if>
<if>if <condition>(<expr><call><name>fstat</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>fd</name></name></expr></argument>, <argument><expr>&amp;<name>buf</name></expr></argument>)</argument_list></call> == 0 &amp;&amp; <call><name>S_ISDIR</name><argument_list>(<argument><expr><name><name>buf</name>.<name>st_mode</name></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>char</name> *</type><name>msg</name> <init>= <expr><call><name>strerror</name><argument_list>(<argument><expr><name>EISDIR</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>exc</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>internal_close</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>exc</name> = <call><name>PyObject_CallFunction</name><argument_list>(<argument><expr><name>PyExc_IOError</name></expr></argument>, <argument><expr>"(is)"</expr></argument>,
<argument><expr><name>EISDIR</name></expr></argument>, <argument><expr><name>msg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyErr_SetObject</name><argument_list>(<argument><expr><name>PyExc_IOError</name></expr></argument>, <argument><expr><name>exc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>exc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>-1</expr>;</return>
}</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<return>return <expr>0</expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>fileio_init</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>oself</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>kwds</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyFileIOObject</name> *</type><name>self</name> <init>= <expr>(<name>PyFileIOObject</name> *) <name>oself</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> *</type><name><name>kwlist</name><index>[]</index></name> <init>= <expr><block>{<expr>"file"</expr>, <expr>"mode"</expr>, <expr>"closefd"</expr>, <expr><name>NULL</name></expr>}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>name</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>mode</name> <init>= <expr>"r"</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>s</name></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MS_WINDOWS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>Py_UNICODE</name> *</type><name>widename</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<decl_stmt><decl><type><name>int</name></type> <name>ret</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>rwa</name> <init>= <expr>0</expr></init>, <name>plus</name> <init>= <expr>0</expr></init>, <name>append</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>flags</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>fd</name> <init>= <expr>-1</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>closefd</name> <init>= <expr>1</expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>PyFileIO_Check</name><argument_list>(<argument><expr><name>oself</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>self</name>-&gt;<name>fd</name></name> &gt;= 0</expr>)</condition><then> <block>{
<if>if <condition>(<expr><call><name>internal_close</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
<return>return <expr>-1</expr>;</return></then></if>
}</block></then></if>
<if>if <condition>(<expr><call><name>PyArg_ParseTupleAndKeywords</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>kwds</name></expr></argument>, <argument><expr>"i|si:fileio"</expr></argument>,
<argument><expr><name>kwlist</name></expr></argument>, <argument><expr>&amp;<name>fd</name></expr></argument>, <argument><expr>&amp;<name>mode</name></expr></argument>, <argument><expr>&amp;<name>closefd</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<if>if <condition>(<expr><name>fd</name> &lt; 0</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>,
<argument><expr>"Negative filedescriptor"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>-1</expr>;</return>
}</block></then></if>
}</block></then> <else>else <block>{
<expr_stmt><expr><call><name>PyErr_Clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>Py_WIN_WIDE_FILENAMES</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if>if <condition>(<expr><call><name>GetVersion</name><argument_list>()</argument_list></call> &lt; 0x80000000</expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>po</name></decl>;</decl_stmt>
<if>if <condition>(<expr><call><name>PyArg_ParseTupleAndKeywords</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>kwds</name></expr></argument>, <argument><expr>"U|si:fileio"</expr></argument>,
<argument><expr><name>kwlist</name></expr></argument>, <argument><expr>&amp;<name>po</name></expr></argument>, <argument><expr>&amp;<name>mode</name></expr></argument>, <argument><expr>&amp;<name>closefd</name></expr></argument>)</argument_list></call></expr>
)</condition><then> <block>{
<expr_stmt><expr><name>widename</name> = <call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr><name>po</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr><call><name>PyErr_Clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
}</block></else></if>
}</block></then></if>
<if>if <condition>(<expr><name>widename</name> == <name>NULL</name></expr>)</condition><then>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<block>{
<if>if <condition>(<expr>!<call><name>PyArg_ParseTupleAndKeywords</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>kwds</name></expr></argument>, <argument><expr>"et|si:fileio"</expr></argument>,
<argument><expr><name>kwlist</name></expr></argument>,
<argument><expr><name>Py_FileSystemDefaultEncoding</name></expr></argument>,
<argument><expr>&amp;<name>name</name></expr></argument>, <argument><expr>&amp;<name>mode</name></expr></argument>, <argument><expr>&amp;<name>closefd</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr>-1</expr>;</return></then></if>
}</block></then></if>
}</block></else></if>
<expr_stmt><expr><name>s</name> = <name>mode</name></expr>;</expr_stmt>
<while>while <condition>(<expr>*<name>s</name></expr>)</condition> <block>{
<switch>switch <condition>(<expr>*<name>s</name>++</expr>)</condition> <block>{
<case>case <expr>'r'</expr>:
<if>if <condition>(<expr><name>rwa</name></expr>)</condition><then> <block>{
<label><name>bad_mode</name>:</label>
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>,
<argument><expr>"Must have exactly one of read/write/append mode"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>error</name>;</goto>
}</block></then></if>
<expr_stmt><expr><name>rwa</name> = 1</expr>;</expr_stmt>
<expr_stmt><expr><name><name>self</name>-&gt;<name>readable</name></name> = 1</expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr>'w'</expr>:
<if>if <condition>(<expr><name>rwa</name></expr>)</condition><then>
<goto>goto <name>bad_mode</name>;</goto></then></if>
<expr_stmt><expr><name>rwa</name> = 1</expr>;</expr_stmt>
<expr_stmt><expr><name><name>self</name>-&gt;<name>writable</name></name> = 1</expr>;</expr_stmt>
<expr_stmt><expr><name>flags</name> |= <name>O_CREAT</name> | <name>O_TRUNC</name></expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr>'a'</expr>:
<if>if <condition>(<expr><name>rwa</name></expr>)</condition><then>
<goto>goto <name>bad_mode</name>;</goto></then></if>
<expr_stmt><expr><name>rwa</name> = 1</expr>;</expr_stmt>
<expr_stmt><expr><name><name>self</name>-&gt;<name>writable</name></name> = 1</expr>;</expr_stmt>
<expr_stmt><expr><name>flags</name> |= <name>O_CREAT</name></expr>;</expr_stmt>
<expr_stmt><expr><name>append</name> = 1</expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr>'+'</expr>:
<if>if <condition>(<expr><name>plus</name></expr>)</condition><then>
<goto>goto <name>bad_mode</name>;</goto></then></if>
<expr_stmt><expr><name><name>self</name>-&gt;<name>readable</name></name> = <name><name>self</name>-&gt;<name>writable</name></name> = 1</expr>;</expr_stmt>
<expr_stmt><expr><name>plus</name> = 1</expr>;</expr_stmt>
<break>break;</break>
</case><default>default:
<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>,
<argument><expr>"invalid mode: %.200s"</expr></argument>, <argument><expr><name>mode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>error</name>;</goto>
</default>}</block></switch>
}</block></while>
<if>if <condition>(<expr>!<name>rwa</name></expr>)</condition><then>
<goto>goto <name>bad_mode</name>;</goto></then></if>
<if>if <condition>(<expr><name><name>self</name>-&gt;<name>readable</name></name> &amp;&amp; <name><name>self</name>-&gt;<name>writable</name></name></expr>)</condition><then>
<expr_stmt><expr><name>flags</name> |= <name>O_RDWR</name></expr>;</expr_stmt></then>
<else>else <if>if <condition>(<expr><name><name>self</name>-&gt;<name>readable</name></name></expr>)</condition><then>
<expr_stmt><expr><name>flags</name> |= <name>O_RDONLY</name></expr>;</expr_stmt></then>
<else>else
<expr_stmt><expr><name>flags</name> |= <name>O_WRONLY</name></expr>;</expr_stmt></else></if></else></if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>O_BINARY</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><name>flags</name> |= <name>O_BINARY</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>O_APPEND</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if>if <condition>(<expr><name>append</name></expr>)</condition><then>
<expr_stmt><expr><name>flags</name> |= <name>O_APPEND</name></expr>;</expr_stmt></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<if>if <condition>(<expr><name>fd</name> &gt;= 0</expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>self</name>-&gt;<name>fd</name></name> = <name>fd</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>self</name>-&gt;<name>closefd</name></name> = <name>closefd</name></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr><name><name>self</name>-&gt;<name>closefd</name></name> = 1</expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>closefd</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>,
<argument><expr>"Cannot use closefd=False with file name"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>error</name>;</goto>
}</block></then></if>
<decl_stmt><decl><type><name>Py_BEGIN_ALLOW_THREADS</name></type>
<name>errno</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MS_WINDOWS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if>if <condition>(<expr><name>widename</name> != <name>NULL</name></expr>)</condition><then>
<expr_stmt><expr><name><name>self</name>-&gt;<name>fd</name></name> = <call><name>_wopen</name><argument_list>(<argument><expr><name>widename</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>, <argument><expr>0666</expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
<else>else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><name><name>self</name>-&gt;<name>fd</name></name> = <call><name>open</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>, <argument><expr>0666</expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
<macro><name>Py_END_ALLOW_THREADS</name></macro>
<if>if <condition>(<expr><name><name>self</name>-&gt;<name>fd</name></name> &lt; 0</expr>)</condition><then> <block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MS_WINDOWS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyErr_SetFromErrnoWithUnicodeFilename</name><argument_list>(<argument><expr><name>PyExc_IOError</name></expr></argument>, <argument><expr><name>widename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<expr_stmt><expr><call><name>PyErr_SetFromErrnoWithFilename</name><argument_list>(<argument><expr><name>PyExc_IOError</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<goto>goto <name>error</name>;</goto>
}</block></then></if>
<if>if<condition>(<expr><call><name>dircheck</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
<goto>goto <name>error</name>;</goto></then></if>
}</block></else></if>
<goto>goto <name>done</name>;</goto>
<label><name>error</name>:</label>
<expr_stmt><expr><name>ret</name> = -1</expr>;</expr_stmt>
<label><name>done</name>:</label>
<expr_stmt><expr><call><name>PyMem_Free</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>ret</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>fileio_dealloc</name><parameter_list>(<param><decl><type><name>PyFileIOObject</name> *</type><name>self</name></decl></param>)</parameter_list> <block>{
<if>if <condition>(<expr><name><name>self</name>-&gt;<name>weakreflist</name></name> != <name>NULL</name></expr>)</condition><then>
<expr_stmt><expr><call><name>PyObject_ClearWeakRefs</name><argument_list>(<argument><expr>(<name>PyObject</name> *) <name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<if>if <condition>(<expr><name><name>self</name>-&gt;<name>fd</name></name> &gt;= 0 &amp;&amp; <name><name>self</name>-&gt;<name>closefd</name></name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>errno</name> = <call><name>internal_close</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>errno</name> &lt; 0</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PySys_WriteStderr</name><argument_list>(<argument><expr>"close failed: [Errno %d] %s\n"</expr></argument>,
<argument><expr><name>errno</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
}</block></then></if>
<expr_stmt><expr><call><name>Py_TYPE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call>-&gt;<call><name>tp_free</name><argument_list>(<argument><expr>(<name>PyObject</name> *)<name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>err_closed</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>, <argument><expr>"I/O operation on closed file"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>err_mode</name><parameter_list>(<param><decl><type><name>char</name> *</type><name>action</name></decl></param>)</parameter_list> <block>{
<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>, <argument><expr>"File not open for %s"</expr></argument>, <argument><expr><name>action</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>fileio_fileno</name><parameter_list>(<param><decl><type><name>PyFileIOObject</name> *</type><name>self</name></decl></param>)</parameter_list> <block>{
<if>if <condition>(<expr><name><name>self</name>-&gt;<name>fd</name></name> &lt; 0</expr>)</condition><then>
<return>return <expr><call><name>err_closed</name><argument_list>()</argument_list></call></expr>;</return></then></if>
<return>return <expr><call><name>PyInt_FromLong</name><argument_list>(<argument><expr>(<name>long</name>) <name><name>self</name>-&gt;<name>fd</name></name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>fileio_readable</name><parameter_list>(<param><decl><type><name>PyFileIOObject</name> *</type><name>self</name></decl></param>)</parameter_list> <block>{
<if>if <condition>(<expr><name><name>self</name>-&gt;<name>fd</name></name> &lt; 0</expr>)</condition><then>
<return>return <expr><call><name>err_closed</name><argument_list>()</argument_list></call></expr>;</return></then></if>
<return>return <expr><call><name>PyBool_FromLong</name><argument_list>(<argument><expr>(<name>long</name>) <name><name>self</name>-&gt;<name>readable</name></name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>fileio_writable</name><parameter_list>(<param><decl><type><name>PyFileIOObject</name> *</type><name>self</name></decl></param>)</parameter_list> <block>{
<if>if <condition>(<expr><name><name>self</name>-&gt;<name>fd</name></name> &lt; 0</expr>)</condition><then>
<return>return <expr><call><name>err_closed</name><argument_list>()</argument_list></call></expr>;</return></then></if>
<return>return <expr><call><name>PyBool_FromLong</name><argument_list>(<argument><expr>(<name>long</name>) <name><name>self</name>-&gt;<name>writable</name></name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>fileio_seekable</name><parameter_list>(<param><decl><type><name>PyFileIOObject</name> *</type><name>self</name></decl></param>)</parameter_list> <block>{
<if>if <condition>(<expr><name><name>self</name>-&gt;<name>fd</name></name> &lt; 0</expr>)</condition><then>
<return>return <expr><call><name>err_closed</name><argument_list>()</argument_list></call></expr>;</return></then></if>
<if>if <condition>(<expr><name><name>self</name>-&gt;<name>seekable</name></name> &lt; 0</expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_BEGIN_ALLOW_THREADS</name></type>
<name>ret</name> <init>= <expr><call><name>lseek</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>fd</name></name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>SEEK_CUR</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<macro><name>Py_END_ALLOW_THREADS</name></macro>
<if>if <condition>(<expr><name>ret</name> &lt; 0</expr>)</condition><then>
<expr_stmt><expr><name><name>self</name>-&gt;<name>seekable</name></name> = 0</expr>;</expr_stmt></then>
<else>else
<expr_stmt><expr><name><name>self</name>-&gt;<name>seekable</name></name> = 1</expr>;</expr_stmt></else></if>
}</block></then></if>
<return>return <expr><call><name>PyBool_FromLong</name><argument_list>(<argument><expr>(<name>long</name>) <name><name>self</name>-&gt;<name>seekable</name></name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>fileio_readinto</name><parameter_list>(<param><decl><type><name>PyFileIOObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>Py_buffer</name></type> <name>pbuf</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>n</name></decl>;</decl_stmt>
<if>if <condition>(<expr><name><name>self</name>-&gt;<name>fd</name></name> &lt; 0</expr>)</condition><then>
<return>return <expr><call><name>err_closed</name><argument_list>()</argument_list></call></expr>;</return></then></if>
<if>if <condition>(<expr>!<name><name>self</name>-&gt;<name>readable</name></name></expr>)</condition><then>
<return>return <expr><call><name>err_mode</name><argument_list>(<argument><expr>"reading"</expr></argument>)</argument_list></call></expr>;</return></then></if>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"w*"</expr></argument>, <argument><expr>&amp;<name>pbuf</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<decl_stmt><decl><type><name>Py_BEGIN_ALLOW_THREADS</name></type>
<name>errno</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>n</name> = <call><name>read</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>fd</name></name></expr></argument>, <argument><expr><name><name>pbuf</name>.<name>buf</name></name></expr></argument>, <argument><expr><name><name>pbuf</name>.<name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>Py_END_ALLOW_THREADS</name></type>
<name>PyBuffer_Release</name><argument_list>(<argument><expr>&amp;<name>pbuf</name></expr></argument>)</argument_list></decl>;</decl_stmt>
<if>if <condition>(<expr><name>n</name> &lt; 0</expr>)</condition><then> <block>{
<if>if <condition>(<expr><name>errno</name> == <name>EAGAIN</name></expr>)</condition><then>
<expr_stmt><expr><name>Py_RETURN_NONE</name></expr>;</expr_stmt></then></if>
<expr_stmt><expr><call><name>PyErr_SetFromErrno</name><argument_list>(<argument><expr><name>PyExc_IOError</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<return>return <expr><call><name>PyLong_FromSsize_t</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DEFAULT_BUFFER_SIZE</name></cpp:macro> <cpp:value>(8*1024)</cpp:value></cpp:define>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>fileio_readall</name><parameter_list>(<param><decl><type><name>PyFileIOObject</name> *</type><name>self</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>result</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>total</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>;</decl_stmt>
<expr_stmt><expr><name>result</name> = <call><name>PyString_FromStringAndSize</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>DEFAULT_BUFFER_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>result</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<while>while <condition>(<expr>1</expr>)</condition> <block>{
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>newsize</name> <init>= <expr><name>total</name> + <name>DEFAULT_BUFFER_SIZE</name></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><call><name>PyString_GET_SIZE</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call> &lt; <name>newsize</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr><call><name>_PyString_Resize</name><argument_list>(<argument><expr>&amp;<name>result</name></expr></argument>, <argument><expr><name>newsize</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then> <block>{
<if>if <condition>(<expr><name>total</name> == 0</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><call><name>PyErr_Clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
}</block></then></if>
}</block></then></if>
<decl_stmt><decl><type><name>Py_BEGIN_ALLOW_THREADS</name></type>
<name>errno</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>n</name> = <call><name>read</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>fd</name></name></expr></argument>,
<argument><expr><call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call> + <name>total</name></expr></argument>,
<argument><expr><name>newsize</name> - <name>total</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<macro><name>Py_END_ALLOW_THREADS</name></macro>
<if>if <condition>(<expr><name>n</name> == 0</expr>)</condition><then>
<break>break;</break></then></if>
<if>if <condition>(<expr><name>n</name> &lt; 0</expr>)</condition><then> <block>{
<if>if <condition>(<expr><name>total</name> &gt; 0</expr>)</condition><then>
<break>break;</break></then></if>
<if>if <condition>(<expr><name>errno</name> == <name>EAGAIN</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>Py_RETURN_NONE</name></expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyErr_SetFromErrno</name><argument_list>(<argument><expr><name>PyExc_IOError</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>total</name> += <name>n</name></expr>;</expr_stmt>
}</block></while>
<if>if <condition>(<expr><call><name>PyString_GET_SIZE</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call> &gt; <name>total</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr><call><name>_PyString_Resize</name><argument_list>(<argument><expr>&amp;<name>result</name></expr></argument>, <argument><expr><name>total</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
}</block></then></if>
<return>return <expr><name>result</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>fileio_read</name><parameter_list>(<param><decl><type><name>PyFileIOObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>char</name> *</type><name>ptr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>n</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>size</name> <init>= <expr>-1</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>bytes</name></decl>;</decl_stmt>
<if>if <condition>(<expr><name><name>self</name>-&gt;<name>fd</name></name> &lt; 0</expr>)</condition><then>
<return>return <expr><call><name>err_closed</name><argument_list>()</argument_list></call></expr>;</return></then></if>
<if>if <condition>(<expr>!<name><name>self</name>-&gt;<name>readable</name></name></expr>)</condition><then>
<return>return <expr><call><name>err_mode</name><argument_list>(<argument><expr>"reading"</expr></argument>)</argument_list></call></expr>;</return></then></if>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"|n"</expr></argument>, <argument><expr>&amp;<name>size</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<if>if <condition>(<expr><name>size</name> &lt; 0</expr>)</condition><then> <block>{
<return>return <expr><call><name>fileio_readall</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>bytes</name> = <call><name>PyString_FromStringAndSize</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>bytes</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>ptr</name> = <call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>bytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>Py_BEGIN_ALLOW_THREADS</name></type>
<name>errno</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>n</name> = <call><name>read</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>fd</name></name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<macro><name>Py_END_ALLOW_THREADS</name></macro>
<if>if <condition>(<expr><name>n</name> &lt; 0</expr>)</condition><then> <block>{
<if>if <condition>(<expr><name>errno</name> == <name>EAGAIN</name></expr>)</condition><then>
<expr_stmt><expr><name>Py_RETURN_NONE</name></expr>;</expr_stmt></then></if>
<expr_stmt><expr><call><name>PyErr_SetFromErrno</name><argument_list>(<argument><expr><name>PyExc_IOError</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<if>if <condition>(<expr><name>n</name> != <name>size</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr><call><name>_PyString_Resize</name><argument_list>(<argument><expr>&amp;<name>bytes</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>bytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
}</block></then></if>
<return>return <expr>(<name>PyObject</name> *) <name>bytes</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>fileio_write</name><parameter_list>(<param><decl><type><name>PyFileIOObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>Py_buffer</name></type> <name>pbuf</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>n</name></decl>;</decl_stmt>
<if>if <condition>(<expr><name><name>self</name>-&gt;<name>fd</name></name> &lt; 0</expr>)</condition><then>
<return>return <expr><call><name>err_closed</name><argument_list>()</argument_list></call></expr>;</return></then></if>
<if>if <condition>(<expr>!<name><name>self</name>-&gt;<name>writable</name></name></expr>)</condition><then>
<return>return <expr><call><name>err_mode</name><argument_list>(<argument><expr>"writing"</expr></argument>)</argument_list></call></expr>;</return></then></if>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"s*"</expr></argument>, <argument><expr>&amp;<name>pbuf</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<decl_stmt><decl><type><name>Py_BEGIN_ALLOW_THREADS</name></type>
<name>errno</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>n</name> = <call><name>write</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>fd</name></name></expr></argument>, <argument><expr><name><name>pbuf</name>.<name>buf</name></name></expr></argument>, <argument><expr><name><name>pbuf</name>.<name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>Py_END_ALLOW_THREADS</name></type>
<name>PyBuffer_Release</name><argument_list>(<argument><expr>&amp;<name>pbuf</name></expr></argument>)</argument_list></decl>;</decl_stmt>
<if>if <condition>(<expr><name>n</name> &lt; 0</expr>)</condition><then> <block>{
<if>if <condition>(<expr><name>errno</name> == <name>EAGAIN</name></expr>)</condition><then>
<expr_stmt><expr><name>Py_RETURN_NONE</name></expr>;</expr_stmt></then></if>
<expr_stmt><expr><call><name>PyErr_SetFromErrno</name><argument_list>(<argument><expr><name>PyExc_IOError</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<return>return <expr><call><name>PyLong_FromSsize_t</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MS_WIN64</name></expr></argument>)</argument_list></call> || <call><name>defined</name><argument_list>(<argument><expr><name>MS_WINDOWS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<typedef>typedef <type><name>PY_LONG_LONG</name></type> <name>Py_off_t</name>;</typedef>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<typedef>typedef <type><name>off_t</name></type> <name>Py_off_t</name>;</typedef>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>portable_lseek</name><parameter_list>(<param><decl><type><name>int</name></type> <name>fd</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>posobj</name></decl></param>, <param><decl><type><name>int</name></type> <name>whence</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>Py_off_t</name></type> <name>pos</name></decl>, <decl><type ref="prev"/><name>res</name></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SEEK_SET</name></expr></argument>)</argument_list></call></expr></cpp:if>
<switch>switch <condition>(<expr><name>whence</name></expr>)</condition> <block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SEEK_SET</name> != 0</expr></cpp:if>
<case>case <expr>0</expr>:
<expr_stmt><expr><name>whence</name> = <name>SEEK_SET</name></expr>;</expr_stmt>
<break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SEEK_CUR</name> != 1</expr></cpp:if>
</case><case>case <expr>1</expr>:
<expr_stmt><expr><name>whence</name> = <name>SEEK_CUR</name></expr>;</expr_stmt>
<break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SEEL_END</name> != 2</expr></cpp:if>
</case><case>case <expr>2</expr>:
<expr_stmt><expr><name>whence</name> = <name>SEEK_END</name></expr>;</expr_stmt>
<break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</case>}</block></switch>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<if>if <condition>(<expr><name>posobj</name> == <name>NULL</name></expr>)</condition><then>
<expr_stmt><expr><name>pos</name> = 0</expr>;</expr_stmt></then>
<else>else <block>{
<if>if<condition>(<expr><call><name>PyFloat_Check</name><argument_list>(<argument><expr><name>posobj</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>, <argument><expr>"an integer is required"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_LARGEFILE_SUPPORT</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><name>pos</name> = <call><name>PyLong_AsLongLong</name><argument_list>(<argument><expr><name>posobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<expr_stmt><expr><name>pos</name> = <call><name>PyLong_AsLong</name><argument_list>(<argument><expr><name>posobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<if>if <condition>(<expr><call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
}</block></else></if>
<decl_stmt><decl><type><name>Py_BEGIN_ALLOW_THREADS</name></type>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MS_WIN64</name></expr></argument>)</argument_list></call> || <call><name>defined</name><argument_list>(<argument><expr><name>MS_WINDOWS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<name>res</name> <init>= <expr><call><name>_lseeki64</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>pos</name></expr></argument>, <argument><expr><name>whence</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<expr_stmt><expr><name>res</name> = <call><name>lseek</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>pos</name></expr></argument>, <argument><expr><name>whence</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<macro><name>Py_END_ALLOW_THREADS</name></macro>
<if>if <condition>(<expr><name>res</name> &lt; 0</expr>)</condition><then>
<return>return <expr><call><name>PyErr_SetFromErrno</name><argument_list>(<argument><expr><name>PyExc_IOError</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_LARGEFILE_SUPPORT</name></expr></argument>)</argument_list></call></expr></cpp:if>
<return>return <expr><call><name>PyLong_FromLongLong</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<return>return <expr><call><name>PyLong_FromLong</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>fileio_seek</name><parameter_list>(<param><decl><type><name>PyFileIOObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>posobj</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>whence</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name><name>self</name>-&gt;<name>fd</name></name> &lt; 0</expr>)</condition><then>
<return>return <expr><call><name>err_closed</name><argument_list>()</argument_list></call></expr>;</return></then></if>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"O|i"</expr></argument>, <argument><expr>&amp;<name>posobj</name></expr></argument>, <argument><expr>&amp;<name>whence</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<return>return <expr><call><name>portable_lseek</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>fd</name></name></expr></argument>, <argument><expr><name>posobj</name></expr></argument>, <argument><expr><name>whence</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>fileio_tell</name><parameter_list>(<param><decl><type><name>PyFileIOObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<if>if <condition>(<expr><name><name>self</name>-&gt;<name>fd</name></name> &lt; 0</expr>)</condition><then>
<return>return <expr><call><name>err_closed</name><argument_list>()</argument_list></call></expr>;</return></then></if>
<return>return <expr><call><name>portable_lseek</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>fd</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_FTRUNCATE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>fileio_truncate</name><parameter_list>(<param><decl><type><name>PyFileIOObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>posobj</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_off_t</name></type> <name>pos</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>fd</name></decl>;</decl_stmt>
<expr_stmt><expr><name>fd</name> = <name><name>self</name>-&gt;<name>fd</name></name></expr>;</expr_stmt>
<if>if <condition>(<expr><name>fd</name> &lt; 0</expr>)</condition><then>
<return>return <expr><call><name>err_closed</name><argument_list>()</argument_list></call></expr>;</return></then></if>
<if>if <condition>(<expr>!<name><name>self</name>-&gt;<name>writable</name></name></expr>)</condition><then>
<return>return <expr><call><name>err_mode</name><argument_list>(<argument><expr>"writing"</expr></argument>)</argument_list></call></expr>;</return></then></if>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"|O"</expr></argument>, <argument><expr>&amp;<name>posobj</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<if>if <condition>(<expr><name>posobj</name> == <name>Py_None</name> || <name>posobj</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>posobj</name> = <call><name>portable_lseek</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>posobj</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
}</block></then> <else>else <block>{
<expr_stmt><expr><name>posobj</name> = <call><name>portable_lseek</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>posobj</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></else></if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_LARGEFILE_SUPPORT</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><name>pos</name> = <call><name>PyLong_AsLongLong</name><argument_list>(<argument><expr><name>posobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<expr_stmt><expr><name>pos</name> = <call><name>PyLong_AsLong</name><argument_list>(<argument><expr><name>posobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<if>if <condition>(<expr><call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MS_WINDOWS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<block>{
<decl_stmt><decl><type><name>HANDLE</name></type> <name>hFile</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_BEGIN_ALLOW_THREADS</name></type>
<name>errno</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>hFile</name> = (<name>HANDLE</name>)<call><name>_get_osfhandle</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ret</name> = <name>hFile</name> == (<name>HANDLE</name>)-1</expr>;</expr_stmt>
<if>if <condition>(<expr><name>ret</name> == 0</expr>)</condition><then> <block>{
<expr_stmt><expr><name>ret</name> = <call><name>SetEndOfFile</name><argument_list>(<argument><expr><name>hFile</name></expr></argument>)</argument_list></call> == 0</expr>;</expr_stmt>
<if>if <condition>(<expr><name>ret</name></expr>)</condition><then>
<expr_stmt><expr><name>errno</name> = <name>EACCES</name></expr>;</expr_stmt></then></if>
}</block></then></if>
<expr_stmt><expr><name>Py_END_ALLOW_THREADS</name></expr></expr_stmt>
}</block>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<decl_stmt><decl><type><name>Py_BEGIN_ALLOW_THREADS</name></type>
<name>errno</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>ret</name> = <call><name>ftruncate</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>pos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<macro><name>Py_END_ALLOW_THREADS</name></macro>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<if>if <condition>(<expr><name>ret</name> != 0</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetFromErrno</name><argument_list>(<argument><expr><name>PyExc_IOError</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<return>return <expr><name>posobj</name></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<function><type><specifier>static</specifier> <name>char</name> *</type>
<name>mode_string</name><parameter_list>(<param><decl><type><name>PyFileIOObject</name> *</type><name>self</name></decl></param>)</parameter_list> <block>{
<if>if <condition>(<expr><name><name>self</name>-&gt;<name>readable</name></name></expr>)</condition><then> <block>{
<if>if <condition>(<expr><name><name>self</name>-&gt;<name>writable</name></name></expr>)</condition><then>
<return>return <expr>"r+"</expr>;</return></then>
<else>else
<return>return <expr>"r"</expr>;</return></else></if>
}</block></then> <else>else
<return>return <expr>"w"</expr>;</return></else></if>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>fileio_repr</name><parameter_list>(<param><decl><type><name>PyFileIOObject</name> *</type><name>self</name></decl></param>)</parameter_list> <block>{
<if>if <condition>(<expr><name><name>self</name>-&gt;<name>fd</name></name> &lt; 0</expr>)</condition><then>
<return>return <expr><call><name>PyString_FromFormat</name><argument_list>(<argument><expr>"_fileio._FileIO(-1)"</expr></argument>)</argument_list></call></expr>;</return></then></if>
<return>return <expr><call><name>PyString_FromFormat</name><argument_list>(<argument><expr>"_fileio._FileIO(%d, '%s')"</expr></argument>,
<argument><expr><name><name>self</name>-&gt;<name>fd</name></name></expr></argument>, <argument><expr><call><name>mode_string</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>fileio_isatty</name><parameter_list>(<param><decl><type><name>PyFileIOObject</name> *</type><name>self</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>long</name></type> <name>res</name></decl>;</decl_stmt>
<if>if <condition>(<expr><name><name>self</name>-&gt;<name>fd</name></name> &lt; 0</expr>)</condition><then>
<return>return <expr><call><name>err_closed</name><argument_list>()</argument_list></call></expr>;</return></then></if>
<decl_stmt><decl><type><name>Py_BEGIN_ALLOW_THREADS</name></type>
<name>res</name> <init>= <expr><call><name>isatty</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>fd</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<macro><name>Py_END_ALLOW_THREADS</name></macro>
<return>return <expr><call><name>PyBool_FromLong</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>fileio_doc</name></expr></argument>,
<argument><expr>"file(name: str[, mode: str]) -&gt; file IO object\n"
"\n"
"Open a file. The mode can be 'r', 'w' or 'a' for reading (default),\n"
"writing or appending. The file will be created if it doesn't exist\n"
"when opened for writing or appending; it will be truncated when\n"
"opened for writing. Add a '+' to the mode to allow simultaneous\n"
"reading and writing."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>read_doc</name></expr></argument>,
<argument><expr>"read(size: int) -&gt; bytes. read at most size bytes, returned as bytes.\n"
"\n"
"Only makes one system call, so less data may be returned than requested\n"
"In non-blocking mode, returns None if no data is available.\n"
"On end-of-file, returns ''."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>readall_doc</name></expr></argument>,
<argument><expr>"readall() -&gt; bytes. read all data from the file, returned as bytes.\n"
"\n"
"In non-blocking mode, returns as much as is immediately available,\n"
"or None if no data is available. On end-of-file, returns ''."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>write_doc</name></expr></argument>,
<argument><expr>"write(b: bytes) -&gt; int. Write bytes b to file, return number written.\n"
"\n"
"Only makes one system call, so not all of the data may be written.\n"
"The number of bytes actually written is returned."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>fileno_doc</name></expr></argument>,
<argument><expr>"fileno() -&gt; int. \"file descriptor\".\n"
"\n"
"This is needed for lower-level file interfaces, such the fcntl module."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>seek_doc</name></expr></argument>,
<argument><expr>"seek(offset: int[, whence: int]) -&gt; None. Move to new file position.\n"
"\n"
"Argument offset is a byte count. Optional argument whence defaults to\n"
"0 (offset from start of file, offset should be &gt;= 0); other values are 1\n"
"(move relative to current position, positive or negative), and 2 (move\n"
"relative to end of file, usually negative, although many platforms allow\n"
"seeking beyond the end of a file)."
"\n"
"Note that not all file objects are seekable."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_FTRUNCATE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>truncate_doc</name></expr></argument>,
<argument><expr>"truncate([size: int]) -&gt; None. Truncate the file to at most size bytes.\n"
"\n"
"Size defaults to the current file position, as returned by tell()."
"The current file position is changed to the value of size."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>tell_doc</name></expr></argument>,
<argument><expr>"tell() -&gt; int. Current file position"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>readinto_doc</name></expr></argument>,
<argument><expr>"readinto() -&gt; Undocumented. Don't use this; it may go away."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>close_doc</name></expr></argument>,
<argument><expr>"close() -&gt; None. Close the file.\n"
"\n"
"A closed file cannot be used for further I/O operations. close() may be\n"
"called more than once without error. Changes the fileno to -1."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>isatty_doc</name></expr></argument>,
<argument><expr>"isatty() -&gt; bool. True if the file is connected to a tty device."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>seekable_doc</name></expr></argument>,
<argument><expr>"seekable() -&gt; bool. True if file supports random-access."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>readable_doc</name></expr></argument>,
<argument><expr>"readable() -&gt; bool. True if file was opened in a read mode."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>writable_doc</name></expr></argument>,
<argument><expr>"writable() -&gt; bool. True if file was opened in a write mode."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>PyMethodDef</name></type> <name><name>fileio_methods</name><index>[]</index></name> <init>= <expr><block>{
<expr><block>{<expr>"read"</expr>, <expr>(<name>PyCFunction</name>)<name>fileio_read</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>read_doc</name></expr>}</block></expr>,
<expr><block>{<expr>"readall"</expr>, <expr>(<name>PyCFunction</name>)<name>fileio_readall</name></expr>, <expr><name>METH_NOARGS</name></expr>, <expr><name>readall_doc</name></expr>}</block></expr>,
<expr><block>{<expr>"readinto"</expr>, <expr>(<name>PyCFunction</name>)<name>fileio_readinto</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>readinto_doc</name></expr>}</block></expr>,
<expr><block>{<expr>"write"</expr>, <expr>(<name>PyCFunction</name>)<name>fileio_write</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>write_doc</name></expr>}</block></expr>,
<expr><block>{<expr>"seek"</expr>, <expr>(<name>PyCFunction</name>)<name>fileio_seek</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>seek_doc</name></expr>}</block></expr>,
<expr><block>{<expr>"tell"</expr>, <expr>(<name>PyCFunction</name>)<name>fileio_tell</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>tell_doc</name></expr>}</block></expr>,
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_FTRUNCATE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"truncate"</expr>, <expr>(<name>PyCFunction</name>)<name>fileio_truncate</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>truncate_doc</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr><block>{<expr>"close"</expr>, <expr>(<name>PyCFunction</name>)<name>fileio_close</name></expr>, <expr><name>METH_NOARGS</name></expr>, <expr><name>close_doc</name></expr>}</block></expr>,
<expr><block>{<expr>"seekable"</expr>, <expr>(<name>PyCFunction</name>)<name>fileio_seekable</name></expr>, <expr><name>METH_NOARGS</name></expr>, <expr><name>seekable_doc</name></expr>}</block></expr>,
<expr><block>{<expr>"readable"</expr>, <expr>(<name>PyCFunction</name>)<name>fileio_readable</name></expr>, <expr><name>METH_NOARGS</name></expr>, <expr><name>readable_doc</name></expr>}</block></expr>,
<expr><block>{<expr>"writable"</expr>, <expr>(<name>PyCFunction</name>)<name>fileio_writable</name></expr>, <expr><name>METH_NOARGS</name></expr>, <expr><name>writable_doc</name></expr>}</block></expr>,
<expr><block>{<expr>"fileno"</expr>, <expr>(<name>PyCFunction</name>)<name>fileio_fileno</name></expr>, <expr><name>METH_NOARGS</name></expr>, <expr><name>fileno_doc</name></expr>}</block></expr>,
<expr><block>{<expr>"isatty"</expr>, <expr>(<name>PyCFunction</name>)<name>fileio_isatty</name></expr>, <expr><name>METH_NOARGS</name></expr>, <expr><name>isatty_doc</name></expr>}</block></expr>,
<expr><block>{<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>}</block></expr>
}</block></expr></init></decl>;</decl_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>get_closed</name><parameter_list>(<param><decl><type><name>PyFileIOObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>void</name> *</type><name>closure</name></decl></param>)</parameter_list> <block>{
<return>return <expr><call><name>PyBool_FromLong</name><argument_list>(<argument><expr><call>(<name>long</name>)<argument_list>(<argument><expr><name><name>self</name>-&gt;<name>fd</name></name> &lt; 0</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>get_mode</name><parameter_list>(<param><decl><type><name>PyFileIOObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>void</name> *</type><name>closure</name></decl></param>)</parameter_list> <block>{
<return>return <expr><call><name>PyString_FromString</name><argument_list>(<argument><expr><call><name>mode_string</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<decl_stmt><decl><type><specifier>static</specifier> <name>PyGetSetDef</name></type> <name><name>fileio_getsetlist</name><index>[]</index></name> <init>= <expr><block>{
<expr><block>{<expr>"closed"</expr>, <expr>(<name>getter</name>)<name>get_closed</name></expr>, <expr><name>NULL</name></expr>, <expr>"True if the file is closed"</expr>}</block></expr>,
<expr><block>{<expr>"mode"</expr>, <expr>(<name>getter</name>)<name>get_mode</name></expr>, <expr><name>NULL</name></expr>, <expr>"String giving the file mode"</expr>}</block></expr>,
<expr><block>{<expr>0</expr>}</block></expr>,
}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyTypeObject</name></type> <name>PyFileIO_Type</name> <init>= <expr><block>{
<expr><call><name>PyVarObject_HEAD_INIT</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call>
"_FileIO"</expr>,
<expr><sizeof>sizeof<argument_list>(<argument><expr><name>PyFileIOObject</name></expr></argument>)</argument_list></sizeof></expr>,
<expr>0</expr>,
<expr>(<name>destructor</name>)<name>fileio_dealloc</name></expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>(<name>reprfunc</name>)<name>fileio_repr</name></expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr><name>PyObject_GenericGetAttr</name></expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr><name>Py_TPFLAGS_DEFAULT</name> | <name>Py_TPFLAGS_BASETYPE</name></expr>,
<expr><name>fileio_doc</name></expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr><call><name>offsetof</name><argument_list>(<argument><expr><name>PyFileIOObject</name></expr></argument>, <argument><expr><name>weakreflist</name></expr></argument>)</argument_list></call></expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr><name>fileio_methods</name></expr>,
<expr>0</expr>,
<expr><name>fileio_getsetlist</name></expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr><name>fileio_init</name></expr>,
<expr><name>PyType_GenericAlloc</name></expr>,
<expr><name>fileio_new</name></expr>,
<expr><name>PyObject_Del</name></expr>,
}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>PyMethodDef</name></type> <name><name>module_methods</name><index>[]</index></name> <init>= <expr><block>{
<expr><block>{<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>}</block></expr>
}</block></expr></init></decl>;</decl_stmt>
<function><type><name>PyMODINIT_FUNC</name></type>
<name>init_fileio</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>m</name></decl>;</decl_stmt>
<expr_stmt><expr><name>m</name> = <call><name>Py_InitModule3</name><argument_list>(<argument><expr>"_fileio"</expr></argument>, <argument><expr><name>module_methods</name></expr></argument>,
<argument><expr>"Fast implementation of io.FileIO."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>m</name> == <name>NULL</name></expr>)</condition><then>
<return>return;</return></then></if>
<if>if <condition>(<expr><call><name>PyType_Ready</name><argument_list>(<argument><expr>&amp;<name>PyFileIO_Type</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
<return>return;</return></then></if>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr>&amp;<name>PyFileIO_Type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyModule_AddObject</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"_FileIO"</expr></argument>, <argument><expr>(<name>PyObject</name> *) &amp;<name>PyFileIO_Type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>
</unit>
