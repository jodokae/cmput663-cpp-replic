<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C" filename="projects/cpython-2.6.1/_cppstats/Modules/_hashopenssl.c"><cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PY_SSIZE_T_CLEAN</name></cpp:macro></cpp:define>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"Python.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"structmember.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;openssl/evp.h&gt;</cpp:file></cpp:include>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MUNCH_SIZE</name></cpp:macro> <cpp:value>INT_MAX</cpp:value></cpp:define>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>HASH_OBJ_CONSTRUCTOR</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HASH_OBJ_CONSTRUCTOR</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<typedef>typedef <type><struct>struct <block>{
<decl_stmt><decl><type><name>PyObject_HEAD</name>
<name>PyObject</name> *</type><name>name</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>EVP_MD_CTX</name></type> <name>ctx</name></decl>;</decl_stmt>
}</block></struct></type> <name>EVPobject</name>;</typedef>
<decl_stmt><decl><type><specifier>static</specifier> <name>PyTypeObject</name></type> <name>EVPtype</name></decl>;</decl_stmt>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DEFINE_CONSTS_FOR_NEW</name><parameter_list>(<param><type><name>Name</name></type></param>)</parameter_list></cpp:macro> <cpp:value>static PyObject *CONST_ ##Name ##_name_obj; static EVP_MD_CTX CONST_new_ ##Name ##_ctx; static EVP_MD_CTX *CONST_new_ ##Name ##_ctx_p = NULL;</cpp:value></cpp:define>
<macro><name>DEFINE_CONSTS_FOR_NEW</name><argument_list>(<argument>md5</argument>)</argument_list></macro>
<macro><name>DEFINE_CONSTS_FOR_NEW</name><argument_list>(<argument>sha1</argument>)</argument_list></macro>
<macro><name>DEFINE_CONSTS_FOR_NEW</name><argument_list>(<argument>sha224</argument>)</argument_list></macro>
<macro><name>DEFINE_CONSTS_FOR_NEW</name><argument_list>(<argument>sha256</argument>)</argument_list></macro>
<macro><name>DEFINE_CONSTS_FOR_NEW</name><argument_list>(<argument>sha384</argument>)</argument_list></macro>
<macro><name>DEFINE_CONSTS_FOR_NEW</name><argument_list>(<argument>sha512</argument>)</argument_list></macro>
<function><type><specifier>static</specifier> <name>EVPobject</name> *</type>
<name>newEVPobject</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>name</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>EVPobject</name> *</type><name>retval</name> <init>= <expr>(<name>EVPobject</name> *)<call><name>PyObject_New</name><argument_list>(<argument><expr><name>EVPobject</name></expr></argument>, <argument><expr>&amp;<name>EVPtype</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>retval</name> != <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>retval</name>-&gt;<name>name</name></name> = <name>name</name></expr>;</expr_stmt>
}</block></then></if>
<return>return <expr><name>retval</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>EVP_dealloc</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>ptr</name></decl></param>)</parameter_list> <block>{
<expr_stmt><expr><call><name>EVP_MD_CTX_cleanup</name><argument_list>(<argument><expr>&amp;((<name>EVPobject</name> *)<name>ptr</name>)-&gt;<name>ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr>((<name>EVPobject</name> *)<name>ptr</name>)-&gt;<name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyObject_Del</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>EVP_copy__doc__</name></expr></argument>, <argument><expr>"Return a copy of the hash object."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>EVP_copy</name><parameter_list>(<param><decl><type><name>EVPobject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>unused</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>EVPobject</name> *</type><name>newobj</name></decl>;</decl_stmt>
<if>if <condition>( <expr>(<name>newobj</name> = <call><name>newEVPobject</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>name</name></name></expr></argument>)</argument_list></call>)==<name>NULL</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><call><name>EVP_MD_CTX_copy</name><argument_list>(<argument><expr>&amp;<name><name>newobj</name>-&gt;<name>ctx</name></name></expr></argument>, <argument><expr>&amp;<name><name>self</name>-&gt;<name>ctx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>(<name>PyObject</name> *)<name>newobj</name></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>EVP_digest__doc__</name></expr></argument>,
<argument><expr>"Return the digest value as a string of binary data."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>EVP_digest</name><parameter_list>(<param><decl><type><name>EVPobject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>unused</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name><name>digest</name><index>[<expr><name>EVP_MAX_MD_SIZE</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>EVP_MD_CTX</name></type> <name>temp_ctx</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>retval</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>digest_size</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>EVP_MD_CTX_copy</name><argument_list>(<argument><expr>&amp;<name>temp_ctx</name></expr></argument>, <argument><expr>&amp;<name><name>self</name>-&gt;<name>ctx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>digest_size</name> = <call><name>EVP_MD_CTX_size</name><argument_list>(<argument><expr>&amp;<name>temp_ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>EVP_DigestFinal</name><argument_list>(<argument><expr>&amp;<name>temp_ctx</name></expr></argument>, <argument><expr><name>digest</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>retval</name> = <call><name>PyString_FromStringAndSize</name><argument_list>(<argument><expr>(const <name>char</name> *)<name>digest</name></expr></argument>, <argument><expr><name>digest_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>EVP_MD_CTX_cleanup</name><argument_list>(<argument><expr>&amp;<name>temp_ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>retval</name></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>EVP_hexdigest__doc__</name></expr></argument>,
<argument><expr>"Return the digest value as a string of hexadecimal digits."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>EVP_hexdigest</name><parameter_list>(<param><decl><type><name>EVPobject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>unused</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name><name>digest</name><index>[<expr><name>EVP_MAX_MD_SIZE</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>EVP_MD_CTX</name></type> <name>temp_ctx</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>retval</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>hex_digest</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>, <decl><type ref="prev"/><name>digest_size</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>EVP_MD_CTX_copy</name><argument_list>(<argument><expr>&amp;<name>temp_ctx</name></expr></argument>, <argument><expr>&amp;<name><name>self</name>-&gt;<name>ctx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>digest_size</name> = <call><name>EVP_MD_CTX_size</name><argument_list>(<argument><expr>&amp;<name>temp_ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>EVP_DigestFinal</name><argument_list>(<argument><expr>&amp;<name>temp_ctx</name></expr></argument>, <argument><expr><name>digest</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>EVP_MD_CTX_cleanup</name><argument_list>(<argument><expr>&amp;<name>temp_ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>retval</name> = <call><name>PyString_FromStringAndSize</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>digest_size</name> * 2</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>retval</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>hex_digest</name> = <call><name>PyString_AsString</name><argument_list>(<argument><expr><name>retval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>hex_digest</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>retval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<for>for(<init><expr><name>i</name>=<name>j</name>=0</expr>;</init> <condition><expr><name>i</name>&lt;<name>digest_size</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
<decl_stmt><decl><type><name>char</name></type> <name>c</name></decl>;</decl_stmt>
<expr_stmt><expr><name>c</name> = (<name><name>digest</name><index>[<expr><name>i</name></expr>]</index></name> &gt;&gt; 4) &amp; 0xf</expr>;</expr_stmt>
<expr_stmt><expr><name>c</name> = (<name>c</name>&gt;9) ? <name>c</name>+'a'-10 : <name>c</name> + '0'</expr>;</expr_stmt>
<expr_stmt><expr><name><name>hex_digest</name><index>[<expr><name>j</name>++</expr>]</index></name> = <name>c</name></expr>;</expr_stmt>
<expr_stmt><expr><name>c</name> = (<name><name>digest</name><index>[<expr><name>i</name></expr>]</index></name> &amp; 0xf)</expr>;</expr_stmt>
<expr_stmt><expr><name>c</name> = (<name>c</name>&gt;9) ? <name>c</name>+'a'-10 : <name>c</name> + '0'</expr>;</expr_stmt>
<expr_stmt><expr><name><name>hex_digest</name><index>[<expr><name>j</name>++</expr>]</index></name> = <name>c</name></expr>;</expr_stmt>
}</block></for>
<return>return <expr><name>retval</name></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>EVP_update__doc__</name></expr></argument>,
<argument><expr>"Update this hash object's state with the provided string."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>EVP_update</name><parameter_list>(<param><decl><type><name>EVPobject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>unsigned</name> <name>char</name> *</type><name>cp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>len</name></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"s#:update"</expr></argument>, <argument><expr>&amp;<name>cp</name></expr></argument>, <argument><expr>&amp;<name>len</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<if>if <condition>(<expr><name>len</name> &gt; 0 &amp;&amp; <name>len</name> &lt;= <name>MUNCH_SIZE</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>EVP_DigestUpdate</name><argument_list>(<argument><expr>&amp;<name><name>self</name>-&gt;<name>ctx</name></name></expr></argument>, <argument><expr><name>cp</name></expr></argument>, <argument><expr><macro><name>Py_SAFE_DOWNCAST</name><argument_list>(<argument>len</argument>, <argument>Py_ssize_t</argument>,
<argument>unsigned int</argument>)</argument_list></macro></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>offset</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<while>while <condition>(<expr><name>len</name></expr>)</condition> <block>{
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>process</name> <init>= <expr><name>len</name> &gt; <name>MUNCH_SIZE</name> ? <name>MUNCH_SIZE</name> : <name>len</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>EVP_DigestUpdate</name><argument_list>(<argument><expr>&amp;<name><name>self</name>-&gt;<name>ctx</name></name></expr></argument>, <argument><expr><name>cp</name> + <name>offset</name></expr></argument>, <argument><expr><name>process</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>len</name> -= <name>process</name></expr>;</expr_stmt>
<expr_stmt><expr><name>offset</name> += <name>process</name></expr>;</expr_stmt>
}</block></while>
}</block></else></if>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>Py_None</name></expr>;</return>
}</block></function>
<decl_stmt><decl><type><specifier>static</specifier> <name>PyMethodDef</name></type> <name><name>EVP_methods</name><index>[]</index></name> <init>= <expr><block>{
<expr><block>{<expr>"update"</expr>, <expr>(<name>PyCFunction</name>)<name>EVP_update</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>EVP_update__doc__</name></expr>}</block></expr>,
<expr><block>{<expr>"digest"</expr>, <expr>(<name>PyCFunction</name>)<name>EVP_digest</name></expr>, <expr><name>METH_NOARGS</name></expr>, <expr><name>EVP_digest__doc__</name></expr>}</block></expr>,
<expr><block>{<expr>"hexdigest"</expr>, <expr>(<name>PyCFunction</name>)<name>EVP_hexdigest</name></expr>, <expr><name>METH_NOARGS</name></expr>, <expr><name>EVP_hexdigest__doc__</name></expr>}</block></expr>,
<expr><block>{<expr>"copy"</expr>, <expr>(<name>PyCFunction</name>)<name>EVP_copy</name></expr>, <expr><name>METH_NOARGS</name></expr>, <expr><name>EVP_copy__doc__</name></expr>}</block></expr>,
<expr><block>{<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>}</block></expr>
}</block></expr></init></decl>;</decl_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>EVP_get_block_size</name><parameter_list>(<param><decl><type><name>EVPobject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>void</name> *</type><name>closure</name></decl></param>)</parameter_list> <block>{
<return>return <expr><call><name>PyInt_FromLong</name><argument_list>(<argument><expr><call><name>EVP_MD_CTX_block_size</name><argument_list>(<argument><expr>&amp;((<name>EVPobject</name> *)<name>self</name>)-&gt;<name>ctx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>EVP_get_digest_size</name><parameter_list>(<param><decl><type><name>EVPobject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>void</name> *</type><name>closure</name></decl></param>)</parameter_list> <block>{
<return>return <expr><call><name>PyInt_FromLong</name><argument_list>(<argument><expr><call><name>EVP_MD_CTX_size</name><argument_list>(<argument><expr>&amp;((<name>EVPobject</name> *)<name>self</name>)-&gt;<name>ctx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<decl_stmt><decl><type><specifier>static</specifier> <name>PyMemberDef</name></type> <name><name>EVP_members</name><index>[]</index></name> <init>= <expr><block>{
<expr><block>{<expr>"name"</expr>, <expr><name>T_OBJECT</name></expr>, <expr><call><name>offsetof</name><argument_list>(<argument><expr><name>EVPobject</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>, <expr><name>READONLY</name></expr>, <macro><name>PyDoc_STR</name><argument_list>(<argument>"algorithm name."</argument>)</argument_list></macro>}</block></expr>,
<expr><block>{<expr><name>NULL</name></expr>}</block></expr>
}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>PyGetSetDef</name></type> <name><name>EVP_getseters</name><index>[]</index></name> <init>= <expr><block>{
<expr><block>{
<expr>"digest_size"</expr>,
<expr>(<name>getter</name>)<name>EVP_get_digest_size</name></expr>, <expr><name>NULL</name></expr>,
<expr><name>NULL</name></expr>,
<expr><name>NULL</name></expr>
}</block></expr>,
<expr><block>{
<expr>"block_size"</expr>,
<expr>(<name>getter</name>)<name>EVP_get_block_size</name></expr>, <expr><name>NULL</name></expr>,
<expr><name>NULL</name></expr>,
<expr><name>NULL</name></expr>
}</block></expr>,
<expr><block>{
<expr>"digestsize"</expr>,
<expr>(<name>getter</name>)<name>EVP_get_digest_size</name></expr>, <expr><name>NULL</name></expr>,
<expr><name>NULL</name></expr>,
<expr><name>NULL</name></expr>
}</block></expr>,
<expr><block>{<expr><name>NULL</name></expr>}</block></expr>
}</block></expr></init></decl>;</decl_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>EVP_repr</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>char</name></type> <name><name>buf</name><index>[<expr>100</expr>]</index></name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>PyOS_snprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr>"&lt;%s HASH object @ %p&gt;"</expr></argument>,
<argument><expr><call><name>PyString_AsString</name><argument_list>(<argument><expr>((<name>EVPobject</name> *)<name>self</name>)-&gt;<name>name</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>PyString_FromString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>HASH_OBJ_CONSTRUCTOR</name></expr></cpp:if>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>EVP_tp_init</name><parameter_list>(<param><decl><type><name>EVPobject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>kwds</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> *</type><name><name>kwlist</name><index>[]</index></name> <init>= <expr><block>{<expr>"name"</expr>, <expr>"string"</expr>, <expr><name>NULL</name></expr>}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>name_obj</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>nameStr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name> *</type><name>cp</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>len</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>EVP_MD</name> *</type><name>digest</name></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTupleAndKeywords</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>kwds</name></expr></argument>, <argument><expr>"O|s#:HASH"</expr></argument>, <argument><expr><name>kwlist</name></expr></argument>,
<argument><expr>&amp;<name>name_obj</name></expr></argument>, <argument><expr>&amp;<name>cp</name></expr></argument>, <argument><expr>&amp;<name>len</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<return>return <expr>-1</expr>;</return>
}</block></then></if>
<if>if <condition>(<expr>!<call><name>PyArg_Parse</name><argument_list>(<argument><expr><name>name_obj</name></expr></argument>, <argument><expr>"s"</expr></argument>, <argument><expr>&amp;<name>nameStr</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>, <argument><expr>"name must be a string"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>-1</expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>digest</name> = <call><name>EVP_get_digestbyname</name><argument_list>(<argument><expr><name>nameStr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>digest</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>, <argument><expr>"unknown hash function"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>-1</expr>;</return>
}</block></then></if>
<expr_stmt><expr><call><name>EVP_DigestInit</name><argument_list>(<argument><expr>&amp;<name><name>self</name>-&gt;<name>ctx</name></name></expr></argument>, <argument><expr><name>digest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>self</name>-&gt;<name>name</name></name> = <name>name_obj</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>cp</name> &amp;&amp; <name>len</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr><name>len</name> &gt; 0 &amp;&amp; <name>len</name> &lt;= <name>MUNCH_SIZE</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>EVP_DigestUpdate</name><argument_list>(<argument><expr>&amp;<name><name>self</name>-&gt;<name>ctx</name></name></expr></argument>, <argument><expr><name>cp</name></expr></argument>, <argument><expr><macro><name>Py_SAFE_DOWNCAST</name><argument_list>(<argument>len</argument>, <argument>Py_ssize_t</argument>,
<argument>unsigned int</argument>)</argument_list></macro></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>offset</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<while>while <condition>(<expr><name>len</name></expr>)</condition> <block>{
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>process</name> <init>= <expr><name>len</name> &gt; <name>MUNCH_SIZE</name> ? <name>MUNCH_SIZE</name> : <name>len</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>EVP_DigestUpdate</name><argument_list>(<argument><expr>&amp;<name><name>self</name>-&gt;<name>ctx</name></name></expr></argument>, <argument><expr><name>cp</name> + <name>offset</name></expr></argument>, <argument><expr><name>process</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>len</name> -= <name>process</name></expr>;</expr_stmt>
<expr_stmt><expr><name>offset</name> += <name>process</name></expr>;</expr_stmt>
}</block></while>
}</block></else></if>
}</block></then></if>
<return>return <expr>0</expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>hashtype_doc</name></expr></argument>,
<argument><expr>"A hash represents the object used to calculate a checksum of a\n\
string of information.\n\
\n\
Methods:\n\
\n\
update() -- updates the current digest with an additional string\n\
digest() -- return the current digest value\n\
hexdigest() -- return the current digest as a string of hexadecimal digits\n\
copy() -- return a copy of the current hash object\n\
\n\
Attributes:\n\
\n\
name -- the hash algorithm being used by this object\n\
digest_size -- number of bytes in this hashes output\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>PyTypeObject</name></type> <name>EVPtype</name> <init>= <expr><block>{
<expr><call><name>PyVarObject_HEAD_INIT</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call>
"_hashlib.HASH"</expr>,
<expr><sizeof>sizeof<argument_list>(<argument><expr><name>EVPobject</name></expr></argument>)</argument_list></sizeof></expr>,
<expr>0</expr>,
<expr><name>EVP_dealloc</name></expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr><name>EVP_repr</name></expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr><name>Py_TPFLAGS_DEFAULT</name> | <name>Py_TPFLAGS_BASETYPE</name></expr>,
<expr><name>hashtype_doc</name></expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr><name>EVP_methods</name></expr>,
<expr><name>EVP_members</name></expr>,
<expr><name>EVP_getseters</name></expr>,
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>1</expr></cpp:if>
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>HASH_OBJ_CONSTRUCTOR</name></expr></cpp:if>
<expr>(<name>initproc</name>)<name>EVP_tp_init</name></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></expr></init></decl>;</decl_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>EVPnew</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>name_obj</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>EVP_MD</name> *</type><name>digest</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>EVP_MD_CTX</name> *</type><name>initial_ctx</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> *</type><name>cp</name></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>len</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>EVPobject</name> *</type><name>self</name></decl>;</decl_stmt>
<if>if <condition>(<expr>!<name>digest</name> &amp;&amp; !<name>initial_ctx</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>, <argument><expr>"unsupported hash type"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<if>if <condition>(<expr>(<name>self</name> = <call><name>newEVPobject</name><argument_list>(<argument><expr><name>name_obj</name></expr></argument>)</argument_list></call>) == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<if>if <condition>(<expr><name>initial_ctx</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>EVP_MD_CTX_copy</name><argument_list>(<argument><expr>&amp;<name><name>self</name>-&gt;<name>ctx</name></name></expr></argument>, <argument><expr><name>initial_ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr><call><name>EVP_DigestInit</name><argument_list>(<argument><expr>&amp;<name><name>self</name>-&gt;<name>ctx</name></name></expr></argument>, <argument><expr><name>digest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></else></if>
<if>if <condition>(<expr><name>cp</name> &amp;&amp; <name>len</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr><name>len</name> &gt; 0 &amp;&amp; <name>len</name> &lt;= <name>MUNCH_SIZE</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>EVP_DigestUpdate</name><argument_list>(<argument><expr>&amp;<name><name>self</name>-&gt;<name>ctx</name></name></expr></argument>, <argument><expr><name>cp</name></expr></argument>, <argument><expr><macro><name>Py_SAFE_DOWNCAST</name><argument_list>(<argument>len</argument>, <argument>Py_ssize_t</argument>,
<argument>unsigned int</argument>)</argument_list></macro></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>offset</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<while>while <condition>(<expr><name>len</name></expr>)</condition> <block>{
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>process</name> <init>= <expr><name>len</name> &gt; <name>MUNCH_SIZE</name> ? <name>MUNCH_SIZE</name> : <name>len</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>EVP_DigestUpdate</name><argument_list>(<argument><expr>&amp;<name><name>self</name>-&gt;<name>ctx</name></name></expr></argument>, <argument><expr><name>cp</name> + <name>offset</name></expr></argument>, <argument><expr><name>process</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>len</name> -= <name>process</name></expr>;</expr_stmt>
<expr_stmt><expr><name>offset</name> += <name>process</name></expr>;</expr_stmt>
}</block></while>
}</block></else></if>
}</block></then></if>
<return>return <expr>(<name>PyObject</name> *)<name>self</name></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>EVP_new__doc__</name></expr></argument>,
<argument><expr>"Return a new hash object using the named algorithm.\n\
An optional string argument may be provided and will be\n\
automatically hashed.\n\
\n\
The MD5 and SHA1 algorithms are always supported.\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>EVP_new</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>kwdict</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> *</type><name><name>kwlist</name><index>[]</index></name> <init>= <expr><block>{<expr>"name"</expr>, <expr>"string"</expr>, <expr><name>NULL</name></expr>}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>name_obj</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>name</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>EVP_MD</name> *</type><name>digest</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name> *</type><name>cp</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>len</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTupleAndKeywords</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>kwdict</name></expr></argument>, <argument><expr>"O|s#:new"</expr></argument>, <argument><expr><name>kwlist</name></expr></argument>,
<argument><expr>&amp;<name>name_obj</name></expr></argument>, <argument><expr>&amp;<name>cp</name></expr></argument>, <argument><expr>&amp;<name>len</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<if>if <condition>(<expr>!<call><name>PyArg_Parse</name><argument_list>(<argument><expr><name>name_obj</name></expr></argument>, <argument><expr>"s"</expr></argument>, <argument><expr>&amp;<name>name</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>, <argument><expr>"name must be a string"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>digest</name> = <call><name>EVP_get_digestbyname</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>EVPnew</name><argument_list>(<argument><expr><name>name_obj</name></expr></argument>, <argument><expr><name>digest</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>cp</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GEN_CONSTRUCTOR</name><parameter_list>(<param><type><name>NAME</name></type></param>)</parameter_list></cpp:macro> <cpp:value>static PyObject * EVP_new_ ##NAME (PyObject *self, PyObject *args) { unsigned char *cp = NULL; Py_ssize_t len = 0; if (!PyArg_ParseTuple(args, "|s#:" #NAME , &amp;cp, &amp;len)) { return NULL; } return EVPnew( CONST_ ##NAME ##_name_obj, NULL, CONST_new_ ##NAME ##_ctx_p, cp, len); }</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CONSTRUCTOR_METH_DEF</name><parameter_list>(<param><type><name>NAME</name></type></param>)</parameter_list></cpp:macro> <cpp:value>{"openssl_" #NAME, (PyCFunction)EVP_new_ ##NAME, METH_VARARGS, PyDoc_STR("Returns a " #NAME " hash object; optionally initialized with a string") }</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INIT_CONSTRUCTOR_CONSTANTS</name><parameter_list>(<param><type><name>NAME</name></type></param>)</parameter_list></cpp:macro> <cpp:value>do { CONST_ ##NAME ##_name_obj = PyString_FromString(#NAME); if (EVP_get_digestbyname(#NAME)) { CONST_new_ ##NAME ##_ctx_p = &amp;CONST_new_ ##NAME ##_ctx; EVP_DigestInit(CONST_new_ ##NAME ##_ctx_p, EVP_get_digestbyname(#NAME)); } } while (0);</cpp:value></cpp:define>
<macro><name>GEN_CONSTRUCTOR</name><argument_list>(<argument>md5</argument>)</argument_list></macro>
<macro><name>GEN_CONSTRUCTOR</name><argument_list>(<argument>sha1</argument>)</argument_list></macro>
<macro><name>GEN_CONSTRUCTOR</name><argument_list>(<argument>sha224</argument>)</argument_list></macro>
<macro><name>GEN_CONSTRUCTOR</name><argument_list>(<argument>sha256</argument>)</argument_list></macro>
<macro><name>GEN_CONSTRUCTOR</name><argument_list>(<argument>sha384</argument>)</argument_list></macro>
<macro><name>GEN_CONSTRUCTOR</name><argument_list>(<argument>sha512</argument>)</argument_list></macro>
<decl_stmt><decl><type><specifier>static</specifier> struct <name>PyMethodDef</name></type> <name><name>EVP_functions</name><index>[]</index></name> <init>= <expr><block>{
<expr><block>{<expr>"new"</expr>, <expr>(<name>PyCFunction</name>)<name>EVP_new</name></expr>, <expr><name>METH_VARARGS</name>|<name>METH_KEYWORDS</name></expr>, <expr><name>EVP_new__doc__</name></expr>}</block></expr>,
<expr><call><name>CONSTRUCTOR_METH_DEF</name><argument_list>(<argument><expr><name>md5</name></expr></argument>)</argument_list></call></expr>,
<expr><call><name>CONSTRUCTOR_METH_DEF</name><argument_list>(<argument><expr><name>sha1</name></expr></argument>)</argument_list></call></expr>,
<expr><call><name>CONSTRUCTOR_METH_DEF</name><argument_list>(<argument><expr><name>sha224</name></expr></argument>)</argument_list></call></expr>,
<expr><call><name>CONSTRUCTOR_METH_DEF</name><argument_list>(<argument><expr><name>sha256</name></expr></argument>)</argument_list></call></expr>,
<expr><call><name>CONSTRUCTOR_METH_DEF</name><argument_list>(<argument><expr><name>sha384</name></expr></argument>)</argument_list></call></expr>,
<expr><call><name>CONSTRUCTOR_METH_DEF</name><argument_list>(<argument><expr><name>sha512</name></expr></argument>)</argument_list></call></expr>,
<expr><block>{<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>}</block></expr>
}</block></expr></init></decl>;</decl_stmt>
<function><type><name>PyMODINIT_FUNC</name></type>
<name>init_hashlib</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>m</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>OpenSSL_add_all_digests</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_TYPE</name><argument_list>(<argument><expr>&amp;<name>EVPtype</name></expr></argument>)</argument_list></call> = &amp;<name>PyType_Type</name></expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>PyType_Ready</name><argument_list>(<argument><expr>&amp;<name>EVPtype</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
<return>return;</return></then></if>
<expr_stmt><expr><name>m</name> = <call><name>Py_InitModule</name><argument_list>(<argument><expr>"_hashlib"</expr></argument>, <argument><expr><name>EVP_functions</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>m</name> == <name>NULL</name></expr>)</condition><then>
<return>return;</return></then></if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>HASH_OBJ_CONSTRUCTOR</name></expr></cpp:if>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr>&amp;<name>EVPtype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyModule_AddObject</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"HASH"</expr></argument>, <argument><expr>(<name>PyObject</name> *)&amp;<name>EVPtype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><call><name>INIT_CONSTRUCTOR_CONSTANTS</name><argument_list>(<argument><expr><name>md5</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>INIT_CONSTRUCTOR_CONSTANTS</name><argument_list>(<argument><expr><name>sha1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>INIT_CONSTRUCTOR_CONSTANTS</name><argument_list>(<argument><expr><name>sha224</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>INIT_CONSTRUCTOR_CONSTANTS</name><argument_list>(<argument><expr><name>sha256</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>INIT_CONSTRUCTOR_CONSTANTS</name><argument_list>(<argument><expr><name>sha384</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>INIT_CONSTRUCTOR_CONSTANTS</name><argument_list>(<argument><expr><name>sha512</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>
</unit>
