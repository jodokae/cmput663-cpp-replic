<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C" filename="projects/cpython-2.6.1/_cppstats/Modules/mmapmodule.c"><cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PY_SSIZE_T_CLEAN</name></cpp:macro></cpp:define>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;Python.h&gt;</cpp:file></cpp:include>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>MS_WINDOWS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>UNIX</name></cpp:macro></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MS_WINDOWS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;windows.h&gt;</cpp:file></cpp:include>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>my_getpagesize</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>SYSTEM_INFO</name></type> <name>si</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>GetSystemInfo</name><argument_list>(<argument><expr>&amp;<name>si</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name><name>si</name>.<name>dwPageSize</name></name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>my_getallocationgranularity</name> <parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>SYSTEM_INFO</name></type> <name>si</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>GetSystemInfo</name><argument_list>(<argument><expr>&amp;<name>si</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name><name>si</name>.<name>dwAllocationGranularity</name></name></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>UNIX</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/mman.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/stat.h&gt;</cpp:file></cpp:include>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_SYSCONF</name></expr></argument>)</argument_list></call> &amp;&amp; <call><name>defined</name><argument_list>(<argument><expr><name>_SC_PAGESIZE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>my_getpagesize</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list> <block>{
<return>return <expr><call><name>sysconf</name><argument_list>(<argument><expr><name>_SC_PAGESIZE</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>my_getallocationgranularity</name></cpp:macro> <cpp:value>my_getpagesize</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>my_getpagesize</name></cpp:macro> <cpp:value>getpagesize</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string.h&gt;</cpp:file></cpp:include>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_SYS_TYPES_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/types.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>MAP_ANONYMOUS</name></expr></argument>)</argument_list></call> &amp;&amp; <call><name>defined</name><argument_list>(<argument><expr><name>MAP_ANON</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAP_ANONYMOUS</name></cpp:macro> <cpp:value>MAP_ANON</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<decl_stmt><decl><type><specifier>static</specifier> <name>PyObject</name> *</type><name>mmap_module_error</name></decl>;</decl_stmt>
<typedef>typedef <type><enum>enum <block>{
<decl><name>ACCESS_DEFAULT</name></decl>,
<decl><name>ACCESS_READ</name></decl>,
<decl><name>ACCESS_WRITE</name></decl>,
<decl><name>ACCESS_COPY</name></decl>
}</block></enum></type> <name>access_mode</name>;</typedef>
<typedef>typedef <type><struct>struct <block>{
<decl_stmt><decl><type><name>PyObject_HEAD</name>
<name>char</name> *</type> <name>data</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>size</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>pos</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>offset</name></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MS_WINDOWS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>HANDLE</name></type> <name>map_handle</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>HANDLE</name></type> <name>file_handle</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type> <name>tagname</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>UNIX</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>int</name></type> <name>fd</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<decl_stmt><decl><type><name>access_mode</name></type> <name>access</name></decl>;</decl_stmt>
}</block></struct></type> <name>mmap_object</name>;</typedef>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>mmap_object_dealloc</name><parameter_list>(<param><decl><type><name>mmap_object</name> *</type><name>m_obj</name></decl></param>)</parameter_list> <block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MS_WINDOWS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if>if <condition>(<expr><name><name>m_obj</name>-&gt;<name>data</name></name> != <name>NULL</name></expr>)</condition><then>
<expr_stmt><expr><call><name>UnmapViewOfFile</name> <argument_list>(<argument><expr><name><name>m_obj</name>-&gt;<name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<if>if <condition>(<expr><name><name>m_obj</name>-&gt;<name>map_handle</name></name> != <name>INVALID_HANDLE_VALUE</name></expr>)</condition><then>
<expr_stmt><expr><call><name>CloseHandle</name> <argument_list>(<argument><expr><name><name>m_obj</name>-&gt;<name>map_handle</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<if>if <condition>(<expr><name><name>m_obj</name>-&gt;<name>file_handle</name></name> != <name>INVALID_HANDLE_VALUE</name></expr>)</condition><then>
<expr_stmt><expr><call><name>CloseHandle</name> <argument_list>(<argument><expr><name><name>m_obj</name>-&gt;<name>file_handle</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<if>if <condition>(<expr><name><name>m_obj</name>-&gt;<name>tagname</name></name></expr>)</condition><then>
<expr_stmt><expr><call><name>PyMem_Free</name><argument_list>(<argument><expr><name><name>m_obj</name>-&gt;<name>tagname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>UNIX</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if>if <condition>(<expr><name><name>m_obj</name>-&gt;<name>fd</name></name> &gt;= 0</expr>)</condition><then>
<expr_stmt><expr>(<name>void</name>) <call><name>close</name><argument_list>(<argument><expr><name><name>m_obj</name>-&gt;<name>fd</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<if>if <condition>(<expr><name><name>m_obj</name>-&gt;<name>data</name></name>!=<name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>msync</name><argument_list>(<argument><expr><name><name>m_obj</name>-&gt;<name>data</name></name></expr></argument>, <argument><expr><name><name>m_obj</name>-&gt;<name>size</name></name></expr></argument>, <argument><expr><name>MS_SYNC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>munmap</name><argument_list>(<argument><expr><name><name>m_obj</name>-&gt;<name>data</name></name></expr></argument>, <argument><expr><name><name>m_obj</name>-&gt;<name>size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><call><name>Py_TYPE</name><argument_list>(<argument><expr><name>m_obj</name></expr></argument>)</argument_list></call>-&gt;<call><name>tp_free</name><argument_list>(<argument><expr>(<name>PyObject</name>*)<name>m_obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>mmap_close_method</name><parameter_list>(<param><decl><type><name>mmap_object</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>unused</name></decl></param>)</parameter_list> <block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MS_WINDOWS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if>if <condition>(<expr><name><name>self</name>-&gt;<name>data</name></name> != <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>UnmapViewOfFile</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>self</name>-&gt;<name>data</name></name> = <name>NULL</name></expr>;</expr_stmt>
}</block></then></if>
<if>if <condition>(<expr><name><name>self</name>-&gt;<name>map_handle</name></name> != <name>INVALID_HANDLE_VALUE</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>CloseHandle</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>map_handle</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>self</name>-&gt;<name>map_handle</name></name> = <name>INVALID_HANDLE_VALUE</name></expr>;</expr_stmt>
}</block></then></if>
<if>if <condition>(<expr><name><name>self</name>-&gt;<name>file_handle</name></name> != <name>INVALID_HANDLE_VALUE</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>CloseHandle</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>file_handle</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>self</name>-&gt;<name>file_handle</name></name> = <name>INVALID_HANDLE_VALUE</name></expr>;</expr_stmt>
}</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>UNIX</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr>(<name>void</name>) <call><name>close</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>fd</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>self</name>-&gt;<name>fd</name></name> = -1</expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>self</name>-&gt;<name>data</name></name> != <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>munmap</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>data</name></name></expr></argument>, <argument><expr><name><name>self</name>-&gt;<name>size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>self</name>-&gt;<name>data</name></name> = <name>NULL</name></expr>;</expr_stmt>
}</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>Py_None</name></expr>;</return>
}</block></function>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MS_WINDOWS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CHECK_VALID</name><parameter_list>(<param><type><name>err</name></type></param>)</parameter_list></cpp:macro> <cpp:value>do { if (self-&gt;map_handle == INVALID_HANDLE_VALUE) { PyErr_SetString(PyExc_ValueError, "mmap closed or invalid"); return err; } } while (0)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>UNIX</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CHECK_VALID</name><parameter_list>(<param><type><name>err</name></type></param>)</parameter_list></cpp:macro> <cpp:value>do { if (self-&gt;data == NULL) { PyErr_SetString(PyExc_ValueError, "mmap closed or invalid"); return err; } } while (0)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>mmap_read_byte_method</name><parameter_list>(<param><decl><type><name>mmap_object</name> *</type><name>self</name></decl></param>,
<param><decl><type><name>PyObject</name> *</type><name>unused</name></decl></param>)</parameter_list> <block>{
<expr_stmt><expr><call><name>CHECK_VALID</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>self</name>-&gt;<name>pos</name></name> &lt; <name><name>self</name>-&gt;<name>size</name></name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>char</name></type> <name>value</name> <init>= <expr><name><name>self</name>-&gt;<name>data</name><index>[<expr><name><name>self</name>-&gt;<name>pos</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>self</name>-&gt;<name>pos</name></name> += 1</expr>;</expr_stmt>
<return>return <expr><call><name>Py_BuildValue</name><argument_list>(<argument><expr>"c"</expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></then> <else>else <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>, <argument><expr>"read byte out of range"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></else></if>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>mmap_read_line_method</name><parameter_list>(<param><decl><type><name>mmap_object</name> *</type><name>self</name></decl></param>,
<param><decl><type><name>PyObject</name> *</type><name>unused</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>char</name> *</type><name>start</name> <init>= <expr><name><name>self</name>-&gt;<name>data</name></name>+<name><name>self</name>-&gt;<name>pos</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>eof</name> <init>= <expr><name><name>self</name>-&gt;<name>data</name></name>+<name><name>self</name>-&gt;<name>size</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>eol</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>result</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>CHECK_VALID</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>eol</name> = <call><name>memchr</name><argument_list>(<argument><expr><name>start</name></expr></argument>, <argument><expr>'\n'</expr></argument>, <argument><expr><name><name>self</name>-&gt;<name>size</name></name> - <name><name>self</name>-&gt;<name>pos</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>eol</name></expr>)</condition><then>
<expr_stmt><expr><name>eol</name> = <name>eof</name></expr>;</expr_stmt></then>
<else>else
<expr_stmt><expr>++<name>eol</name></expr>;</expr_stmt></else></if>
<expr_stmt><expr><name>result</name> = <call><name>PyString_FromStringAndSize</name><argument_list>(<argument><expr><name>start</name></expr></argument>, <argument><expr>(<name>eol</name> - <name>start</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>self</name>-&gt;<name>pos</name></name> += (<name>eol</name> - <name>start</name>)</expr>;</expr_stmt>
<return>return <expr><name>result</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>mmap_read_method</name><parameter_list>(<param><decl><type><name>mmap_object</name> *</type><name>self</name></decl></param>,
<param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>num_bytes</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>result</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>CHECK_VALID</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"n:read"</expr></argument>, <argument><expr>&amp;<name>num_bytes</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return<expr>(<name>NULL</name>)</expr>;</return></then></if>
<if>if <condition>(<expr><name>num_bytes</name> &gt; <name><name>self</name>-&gt;<name>size</name></name> - <name><name>self</name>-&gt;<name>pos</name></name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>num_bytes</name> -= (<name><name>self</name>-&gt;<name>pos</name></name>+<name>num_bytes</name>) - <name><name>self</name>-&gt;<name>size</name></name></expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><name>result</name> = <call><name>Py_BuildValue</name><argument_list>(<argument><expr>"s#"</expr></argument>, <argument><expr><name><name>self</name>-&gt;<name>data</name></name>+<name><name>self</name>-&gt;<name>pos</name></name></expr></argument>, <argument><expr><name>num_bytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>self</name>-&gt;<name>pos</name></name> += <name>num_bytes</name></expr>;</expr_stmt>
<return>return <expr><name>result</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>mmap_gfind</name><parameter_list>(<param><decl><type><name>mmap_object</name> *</type><name>self</name></decl></param>,
<param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>,
<param><decl><type><name>int</name></type> <name>reverse</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>start</name> <init>= <expr><name><name>self</name>-&gt;<name>pos</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>end</name> <init>= <expr><name><name>self</name>-&gt;<name>size</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>needle</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>len</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>CHECK_VALID</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>reverse</name> ? "s#|nn:rfind" : "s#|nn:find"</expr></argument>,
<argument><expr>&amp;<name>needle</name></expr></argument>, <argument><expr>&amp;<name>len</name></expr></argument>, <argument><expr>&amp;<name>start</name></expr></argument>, <argument><expr>&amp;<name>end</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then> <else>else <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>p</name></decl>, *<decl><type ref="prev"/><name>start_p</name></decl>, *<decl><type ref="prev"/><name>end_p</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>sign</name> <init>= <expr><name>reverse</name> ? -1 : 1</expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>start</name> &lt; 0</expr>)</condition><then>
<expr_stmt><expr><name>start</name> += <name><name>self</name>-&gt;<name>size</name></name></expr>;</expr_stmt></then></if>
<if>if <condition>(<expr><name>start</name> &lt; 0</expr>)</condition><then>
<expr_stmt><expr><name>start</name> = 0</expr>;</expr_stmt></then>
<else>else <if>if <condition>(<expr>(<name>size_t</name>)<name>start</name> &gt; <name><name>self</name>-&gt;<name>size</name></name></expr>)</condition><then>
<expr_stmt><expr><name>start</name> = <name><name>self</name>-&gt;<name>size</name></name></expr>;</expr_stmt></then></if></else></if>
<if>if <condition>(<expr><name>end</name> &lt; 0</expr>)</condition><then>
<expr_stmt><expr><name>end</name> += <name><name>self</name>-&gt;<name>size</name></name></expr>;</expr_stmt></then></if>
<if>if <condition>(<expr><name>end</name> &lt; 0</expr>)</condition><then>
<expr_stmt><expr><name>end</name> = 0</expr>;</expr_stmt></then>
<else>else <if>if <condition>(<expr>(<name>size_t</name>)<name>end</name> &gt; <name><name>self</name>-&gt;<name>size</name></name></expr>)</condition><then>
<expr_stmt><expr><name>end</name> = <name><name>self</name>-&gt;<name>size</name></name></expr>;</expr_stmt></then></if></else></if>
<expr_stmt><expr><name>start_p</name> = <name><name>self</name>-&gt;<name>data</name></name> + <name>start</name></expr>;</expr_stmt>
<expr_stmt><expr><name>end_p</name> = <name><name>self</name>-&gt;<name>data</name></name> + <name>end</name></expr>;</expr_stmt>
<for>for (<init><expr><name>p</name> = (<name>reverse</name> ? <name>end_p</name> - <name>len</name> : <name>start_p</name>)</expr>;</init>
<condition><expr>(<name>p</name> &gt;= <name>start_p</name>) &amp;&amp; (<name>p</name> + <name>len</name> &lt;= <name>end_p</name>)</expr>;</condition> <incr><expr><name>p</name> += <name>sign</name></expr></incr>) <block>{
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>i</name></decl>;</decl_stmt>
<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>len</name> &amp;&amp; <name><name>needle</name><index>[<expr><name>i</name></expr>]</index></name> == <name><name>p</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>)
<empty_stmt>;</empty_stmt></for>
<if>if <condition>(<expr><name>i</name> == <name>len</name></expr>)</condition><then> <block>{
<return>return <expr><call><name>PyInt_FromSsize_t</name><argument_list>(<argument><expr><name>p</name> - <name><name>self</name>-&gt;<name>data</name></name></expr></argument>)</argument_list></call></expr>;</return>
}</block></then></if>
}</block></for>
<return>return <expr><call><name>PyInt_FromLong</name><argument_list>(<argument><expr>-1</expr></argument>)</argument_list></call></expr>;</return>
}</block></else></if>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>mmap_find_method</name><parameter_list>(<param><decl><type><name>mmap_object</name> *</type><name>self</name></decl></param>,
<param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<return>return <expr><call><name>mmap_gfind</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>args</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>mmap_rfind_method</name><parameter_list>(<param><decl><type><name>mmap_object</name> *</type><name>self</name></decl></param>,
<param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<return>return <expr><call><name>mmap_gfind</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>args</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>is_writeable</name><parameter_list>(<param><decl><type><name>mmap_object</name> *</type><name>self</name></decl></param>)</parameter_list> <block>{
<if>if <condition>(<expr><name><name>self</name>-&gt;<name>access</name></name> != <name>ACCESS_READ</name></expr>)</condition><then>
<return>return <expr>1</expr>;</return></then></if>
<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>, <argument><expr>"mmap can't modify a readonly memory map."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>0</expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>is_resizeable</name><parameter_list>(<param><decl><type><name>mmap_object</name> *</type><name>self</name></decl></param>)</parameter_list> <block>{
<if>if <condition>(<expr>(<name><name>self</name>-&gt;<name>access</name></name> == <name>ACCESS_WRITE</name>) || (<name><name>self</name>-&gt;<name>access</name></name> == <name>ACCESS_DEFAULT</name>)</expr>)</condition><then>
<return>return <expr>1</expr>;</return></then></if>
<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
<argument><expr>"mmap can't resize a readonly or copy-on-write memory map."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>0</expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>mmap_write_method</name><parameter_list>(<param><decl><type><name>mmap_object</name> *</type><name>self</name></decl></param>,
<param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>length</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>data</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>CHECK_VALID</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"s#:write"</expr></argument>, <argument><expr>&amp;<name>data</name></expr></argument>, <argument><expr>&amp;<name>length</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return<expr>(<name>NULL</name>)</expr>;</return></then></if>
<if>if <condition>(<expr>!<call><name>is_writeable</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<if>if <condition>(<expr>(<name><name>self</name>-&gt;<name>pos</name></name> + <name>length</name>) &gt; <name><name>self</name>-&gt;<name>size</name></name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>, <argument><expr>"data out of range"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>data</name></name>+<name><name>self</name>-&gt;<name>pos</name></name></expr></argument>, <argument><expr><name>data</name></expr></argument>, <argument><expr><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>self</name>-&gt;<name>pos</name></name> = <name><name>self</name>-&gt;<name>pos</name></name>+<name>length</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>Py_None</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>mmap_write_byte_method</name><parameter_list>(<param><decl><type><name>mmap_object</name> *</type><name>self</name></decl></param>,
<param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>char</name></type> <name>value</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>CHECK_VALID</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"c:write_byte"</expr></argument>, <argument><expr>&amp;<name>value</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return<expr>(<name>NULL</name>)</expr>;</return></then></if>
<if>if <condition>(<expr>!<call><name>is_writeable</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr>*(<name><name>self</name>-&gt;<name>data</name></name>+<name><name>self</name>-&gt;<name>pos</name></name>) = <name>value</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>self</name>-&gt;<name>pos</name></name> += 1</expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>Py_None</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>mmap_size_method</name><parameter_list>(<param><decl><type><name>mmap_object</name> *</type><name>self</name></decl></param>,
<param><decl><type><name>PyObject</name> *</type><name>unused</name></decl></param>)</parameter_list> <block>{
<expr_stmt><expr><call><name>CHECK_VALID</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MS_WINDOWS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if>if <condition>(<expr><name><name>self</name>-&gt;<name>file_handle</name></name> != <name>INVALID_HANDLE_VALUE</name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>DWORD</name></type> <name>low</name></decl>,<decl><type ref="prev"/><name>high</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PY_LONG_LONG</name></type> <name>size</name></decl>;</decl_stmt>
<expr_stmt><expr><name>low</name> = <call><name>GetFileSize</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>file_handle</name></name></expr></argument>, <argument><expr>&amp;<name>high</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>low</name> == <name>INVALID_FILE_SIZE</name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>DWORD</name></type> <name>error</name> <init>= <expr><call><name>GetLastError</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>error</name> != <name>NO_ERROR</name></expr>)</condition><then>
<return>return <expr><call><name>PyErr_SetFromWindowsErr</name><argument_list>(<argument><expr><name>error</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
}</block></then></if>
<if>if <condition>(<expr>!<name>high</name> &amp;&amp; <name>low</name> &lt; <name>LONG_MAX</name></expr>)</condition><then>
<return>return <expr><call><name>PyInt_FromLong</name><argument_list>(<argument><expr>(<name>long</name>)<name>low</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
<expr_stmt><expr><name>size</name> = (((<name>PY_LONG_LONG</name>)<name>high</name>)&lt;&lt;32) + <name>low</name></expr>;</expr_stmt>
<return>return <expr><call><name>PyLong_FromLongLong</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></then> <else>else <block>{
<return>return <expr><call><name>PyInt_FromSsize_t</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>size</name></name></expr></argument>)</argument_list></call></expr>;</return>
}</block></else></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>UNIX</name></expr></argument>)</argument_list></call></expr></cpp:if>
<block>{
<decl_stmt><decl><type>struct <name>stat</name></type> <name>buf</name></decl>;</decl_stmt>
<if>if <condition>(<expr>-1 == <call><name>fstat</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>fd</name></name></expr></argument>, <argument><expr>&amp;<name>buf</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetFromErrno</name><argument_list>(<argument><expr><name>mmap_module_error</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<return>return <expr><call><name>PyInt_FromSsize_t</name><argument_list>(<argument><expr><name><name>buf</name>.<name>st_size</name></name></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>mmap_resize_method</name><parameter_list>(<param><decl><type><name>mmap_object</name> *</type><name>self</name></decl></param>,
<param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>new_size</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>CHECK_VALID</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"n:resize"</expr></argument>, <argument><expr>&amp;<name>new_size</name></expr></argument>)</argument_list></call> ||
!<call><name>is_resizeable</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<return>return <expr><name>NULL</name></expr>;</return>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MS_WINDOWS</name></expr></argument>)</argument_list></call></expr></cpp:if>
}</block></then> <else>else <block>{
<decl_stmt><decl><type><name>DWORD</name></type> <name>dwErrCode</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>DWORD</name></type> <name>off_hi</name></decl>, <decl><type ref="prev"/><name>off_lo</name></decl>, <decl><type ref="prev"/><name>newSizeLow</name></decl>, <decl><type ref="prev"/><name>newSizeHigh</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>UnmapViewOfFile</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>CloseHandle</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>map_handle</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SIZEOF_SIZE_T</name> &gt; 4</expr></cpp:if>
<expr_stmt><expr><name>newSizeHigh</name> = <call>(<name>DWORD</name>)<argument_list>(<argument><expr>(<name><name>self</name>-&gt;<name>offset</name></name> + <name>new_size</name>) &gt;&gt; 32</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>newSizeLow</name> = <call>(<name>DWORD</name>)<argument_list>(<argument><expr>(<name><name>self</name>-&gt;<name>offset</name></name> + <name>new_size</name>) &amp; 0xFFFFFFFF</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>off_hi</name> = <call>(<name>DWORD</name>)<argument_list>(<argument><expr><name><name>self</name>-&gt;<name>offset</name></name> &gt;&gt; 32</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>off_lo</name> = <call>(<name>DWORD</name>)<argument_list>(<argument><expr><name><name>self</name>-&gt;<name>offset</name></name> &amp; 0xFFFFFFFF</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<expr_stmt><expr><name>newSizeHigh</name> = 0</expr>;</expr_stmt>
<expr_stmt><expr><name>newSizeLow</name> = (<name>DWORD</name>)<name>new_size</name></expr>;</expr_stmt>
<expr_stmt><expr><name>off_hi</name> = 0</expr>;</expr_stmt>
<expr_stmt><expr><name>off_lo</name> = (<name>DWORD</name>)<name><name>self</name>-&gt;<name>offset</name></name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><call><name>SetFilePointer</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>file_handle</name></name></expr></argument>,
<argument><expr><name>newSizeLow</name></expr></argument>, <argument><expr>&amp;<name>newSizeHigh</name></expr></argument>, <argument><expr><name>FILE_BEGIN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SetEndOfFile</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>file_handle</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>self</name>-&gt;<name>map_handle</name></name> = <call><name>CreateFileMapping</name><argument_list>(
<argument><expr><name><name>self</name>-&gt;<name>file_handle</name></name></expr></argument>,
<argument><expr><name>NULL</name></expr></argument>,
<argument><expr><name>PAGE_READWRITE</name></expr></argument>,
<argument><expr>0</expr></argument>,
<argument><expr>0</expr></argument>,
<argument><expr><name><name>self</name>-&gt;<name>tagname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>self</name>-&gt;<name>map_handle</name></name> != <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>self</name>-&gt;<name>data</name></name> = (<name>char</name> *) <call><name>MapViewOfFile</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>map_handle</name></name></expr></argument>,
<argument><expr><name>FILE_MAP_WRITE</name></expr></argument>,
<argument><expr><name>off_hi</name></expr></argument>,
<argument><expr><name>off_lo</name></expr></argument>,
<argument><expr><name>new_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>self</name>-&gt;<name>data</name></name> != <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>self</name>-&gt;<name>size</name></name> = <name>new_size</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>Py_None</name></expr>;</return>
}</block></then> <else>else <block>{
<expr_stmt><expr><name>dwErrCode</name> = <call><name>GetLastError</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
}</block></else></if>
}</block></then> <else>else <block>{
<expr_stmt><expr><name>dwErrCode</name> = <call><name>GetLastError</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
}</block></else></if>
<expr_stmt><expr><call><name>PyErr_SetFromWindowsErr</name><argument_list>(<argument><expr><name>dwErrCode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>UNIX</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>HAVE_MREMAP</name></expr></argument>)</argument_list></call></expr></cpp:if>
}</block></else></if>
<else>else <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_SystemError</name></expr></argument>,
<argument><expr>"mmap: resizing not available--no mremap()"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
}</block></else>
<else>else <block>{
<decl_stmt><decl><type><name>void</name> *</type><name>newmap</name></decl>;</decl_stmt>
<if>if <condition>(<expr><call><name>ftruncate</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>fd</name></name></expr></argument>, <argument><expr><name>new_size</name></expr></argument>)</argument_list></call> == -1</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetFromErrno</name><argument_list>(<argument><expr><name>mmap_module_error</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MREMAP_MAYMOVE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><name>newmap</name> = <call><name>mremap</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>data</name></name></expr></argument>, <argument><expr><name><name>self</name>-&gt;<name>size</name></name></expr></argument>, <argument><expr><name>new_size</name></expr></argument>, <argument><expr><name>MREMAP_MAYMOVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<expr_stmt><expr><name>newmap</name> = <call><name>mremap</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>data</name></name></expr></argument>, <argument><expr><name><name>self</name>-&gt;<name>size</name></name></expr></argument>, <argument><expr><name>new_size</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<if>if <condition>(<expr><name>newmap</name> == (<name>void</name> *)-1</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetFromErrno</name><argument_list>(<argument><expr><name>mmap_module_error</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name><name>self</name>-&gt;<name>data</name></name> = <name>newmap</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>self</name>-&gt;<name>size</name></name> = <name>new_size</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>Py_None</name></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></else>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>mmap_tell_method</name><parameter_list>(<param><decl><type><name>mmap_object</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>unused</name></decl></param>)</parameter_list> <block>{
<expr_stmt><expr><call><name>CHECK_VALID</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>PyInt_FromSize_t</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>pos</name></name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>mmap_flush_method</name><parameter_list>(<param><decl><type><name>mmap_object</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>offset</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>size</name> <init>= <expr><name><name>self</name>-&gt;<name>size</name></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>CHECK_VALID</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"|nn:flush"</expr></argument>, <argument><expr>&amp;<name>offset</name></expr></argument>, <argument><expr>&amp;<name>size</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<if>if <condition>(<expr><call>(<name>size_t</name>)<argument_list>(<argument><expr><name>offset</name> + <name>size</name></expr></argument>)</argument_list></call> &gt; <name><name>self</name>-&gt;<name>size</name></name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>, <argument><expr>"flush values out of range"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MS_WINDOWS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<return>return <expr><call><name>PyInt_FromLong</name><argument_list>(<argument><expr>(<name>long</name>) <call><name>FlushViewOfFile</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>data</name></name>+<name>offset</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>UNIX</name></expr></argument>)</argument_list></call></expr></cpp:elif>
<if>if <condition>(<expr>-1 == <call><name>msync</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>data</name></name> + <name>offset</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><name>MS_SYNC</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetFromErrno</name><argument_list>(<argument><expr><name>mmap_module_error</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<return>return <expr><call><name>PyInt_FromLong</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>, <argument><expr>"flush not supported on this system"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>mmap_seek_method</name><parameter_list>(<param><decl><type><name>mmap_object</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>dist</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>how</name><init>=<expr>0</expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>CHECK_VALID</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"n|i:seek"</expr></argument>, <argument><expr>&amp;<name>dist</name></expr></argument>, <argument><expr>&amp;<name>how</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then>
<else>else <block>{
<decl_stmt><decl><type><name>size_t</name></type> <name>where</name></decl>;</decl_stmt>
<switch>switch <condition>(<expr><name>how</name></expr>)</condition> <block>{
<case>case <expr>0</expr>:
<if>if <condition>(<expr><name>dist</name> &lt; 0</expr>)</condition><then>
<goto>goto <name>onoutofrange</name>;</goto></then></if>
<expr_stmt><expr><name>where</name> = <name>dist</name></expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr>1</expr>:
<if>if <condition>(<expr>(<name>Py_ssize_t</name>)<name><name>self</name>-&gt;<name>pos</name></name> + <name>dist</name> &lt; 0</expr>)</condition><then>
<goto>goto <name>onoutofrange</name>;</goto></then></if>
<expr_stmt><expr><name>where</name> = <name><name>self</name>-&gt;<name>pos</name></name> + <name>dist</name></expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr>2</expr>:
<if>if <condition>(<expr>(<name>Py_ssize_t</name>)<name><name>self</name>-&gt;<name>size</name></name> + <name>dist</name> &lt; 0</expr>)</condition><then>
<goto>goto <name>onoutofrange</name>;</goto></then></if>
<expr_stmt><expr><name>where</name> = <name><name>self</name>-&gt;<name>size</name></name> + <name>dist</name></expr>;</expr_stmt>
<break>break;</break>
</case><default>default:
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>, <argument><expr>"unknown seek type"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
</default>}</block></switch>
<if>if <condition>(<expr><name>where</name> &gt; <name><name>self</name>-&gt;<name>size</name></name></expr>)</condition><then>
<goto>goto <name>onoutofrange</name>;</goto></then></if>
<expr_stmt><expr><name><name>self</name>-&gt;<name>pos</name></name> = <name>where</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>Py_None</name></expr>;</return>
}</block></else></if>
<label><name>onoutofrange</name>:</label>
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>, <argument><expr>"seek out of range"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>mmap_move_method</name><parameter_list>(<param><decl><type><name>mmap_object</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>dest</name></decl>, <decl><type ref="prev"/><name>src</name></decl>, <decl><type ref="prev"/><name>count</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>CHECK_VALID</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"kkk:move"</expr></argument>, <argument><expr>&amp;<name>dest</name></expr></argument>, <argument><expr>&amp;<name>src</name></expr></argument>, <argument><expr>&amp;<name>count</name></expr></argument>)</argument_list></call> ||
!<call><name>is_writeable</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then> <else>else <block>{
<if>if <condition>(
<expr>((<name>src</name>+<name>count</name>) &gt; <name><name>self</name>-&gt;<name>size</name></name>)
|| (<name>dest</name>+<name>count</name> &gt; <name><name>self</name>-&gt;<name>size</name></name>)</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>,
<argument><expr>"source or destination out of range"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then> <else>else <block>{
<expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>data</name></name>+<name>dest</name></expr></argument>, <argument><expr><name><name>self</name>-&gt;<name>data</name></name>+<name>src</name></expr></argument>, <argument><expr><name>count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>Py_None</name></expr>;</return>
}</block></else></if>
}</block></else></if>
}</block></function>
<decl_stmt><decl><type><specifier>static</specifier> struct <name>PyMethodDef</name></type> <name><name>mmap_object_methods</name><index>[]</index></name> <init>= <expr><block>{
<expr><block>{<expr>"close"</expr>, <expr>(<name>PyCFunction</name>) <name>mmap_close_method</name></expr>, <expr><name>METH_NOARGS</name></expr>}</block></expr>,
<expr><block>{<expr>"find"</expr>, <expr>(<name>PyCFunction</name>) <name>mmap_find_method</name></expr>, <expr><name>METH_VARARGS</name></expr>}</block></expr>,
<expr><block>{<expr>"rfind"</expr>, <expr>(<name>PyCFunction</name>) <name>mmap_rfind_method</name></expr>, <expr><name>METH_VARARGS</name></expr>}</block></expr>,
<expr><block>{<expr>"flush"</expr>, <expr>(<name>PyCFunction</name>) <name>mmap_flush_method</name></expr>, <expr><name>METH_VARARGS</name></expr>}</block></expr>,
<expr><block>{<expr>"move"</expr>, <expr>(<name>PyCFunction</name>) <name>mmap_move_method</name></expr>, <expr><name>METH_VARARGS</name></expr>}</block></expr>,
<expr><block>{<expr>"read"</expr>, <expr>(<name>PyCFunction</name>) <name>mmap_read_method</name></expr>, <expr><name>METH_VARARGS</name></expr>}</block></expr>,
<expr><block>{<expr>"read_byte"</expr>, <expr>(<name>PyCFunction</name>) <name>mmap_read_byte_method</name></expr>, <expr><name>METH_NOARGS</name></expr>}</block></expr>,
<expr><block>{<expr>"readline"</expr>, <expr>(<name>PyCFunction</name>) <name>mmap_read_line_method</name></expr>, <expr><name>METH_NOARGS</name></expr>}</block></expr>,
<expr><block>{<expr>"resize"</expr>, <expr>(<name>PyCFunction</name>) <name>mmap_resize_method</name></expr>, <expr><name>METH_VARARGS</name></expr>}</block></expr>,
<expr><block>{<expr>"seek"</expr>, <expr>(<name>PyCFunction</name>) <name>mmap_seek_method</name></expr>, <expr><name>METH_VARARGS</name></expr>}</block></expr>,
<expr><block>{<expr>"size"</expr>, <expr>(<name>PyCFunction</name>) <name>mmap_size_method</name></expr>, <expr><name>METH_NOARGS</name></expr>}</block></expr>,
<expr><block>{<expr>"tell"</expr>, <expr>(<name>PyCFunction</name>) <name>mmap_tell_method</name></expr>, <expr><name>METH_NOARGS</name></expr>}</block></expr>,
<expr><block>{<expr>"write"</expr>, <expr>(<name>PyCFunction</name>) <name>mmap_write_method</name></expr>, <expr><name>METH_VARARGS</name></expr>}</block></expr>,
<expr><block>{<expr>"write_byte"</expr>, <expr>(<name>PyCFunction</name>) <name>mmap_write_byte_method</name></expr>, <expr><name>METH_VARARGS</name></expr>}</block></expr>,
<expr><block>{<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>}</block></expr>
}</block></expr></init></decl>;</decl_stmt>
<function><type><specifier>static</specifier> <name>Py_ssize_t</name></type>
<name>mmap_buffer_getreadbuf</name><parameter_list>(<param><decl><type><name>mmap_object</name> *</type><name>self</name></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>index</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>void</name> **</type><name>ptr</name></decl></param>)</parameter_list> <block>{
<expr_stmt><expr><call><name>CHECK_VALID</name><argument_list>(<argument><expr>-1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>index</name> != 0</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_SystemError</name></expr></argument>,
<argument><expr>"Accessing non-existent mmap segment"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>-1</expr>;</return>
}</block></then></if>
<expr_stmt><expr>*<name>ptr</name> = <name><name>self</name>-&gt;<name>data</name></name></expr>;</expr_stmt>
<return>return <expr><name><name>self</name>-&gt;<name>size</name></name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>Py_ssize_t</name></type>
<name>mmap_buffer_getwritebuf</name><parameter_list>(<param><decl><type><name>mmap_object</name> *</type><name>self</name></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>index</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>void</name> **</type><name>ptr</name></decl></param>)</parameter_list> <block>{
<expr_stmt><expr><call><name>CHECK_VALID</name><argument_list>(<argument><expr>-1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>index</name> != 0</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_SystemError</name></expr></argument>,
<argument><expr>"Accessing non-existent mmap segment"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>-1</expr>;</return>
}</block></then></if>
<if>if <condition>(<expr>!<call><name>is_writeable</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr>-1</expr>;</return></then></if>
<expr_stmt><expr>*<name>ptr</name> = <name><name>self</name>-&gt;<name>data</name></name></expr>;</expr_stmt>
<return>return <expr><name><name>self</name>-&gt;<name>size</name></name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>Py_ssize_t</name></type>
<name>mmap_buffer_getsegcount</name><parameter_list>(<param><decl><type><name>mmap_object</name> *</type><name>self</name></decl></param>, <param><decl><type><name>Py_ssize_t</name> *</type><name>lenp</name></decl></param>)</parameter_list> <block>{
<expr_stmt><expr><call><name>CHECK_VALID</name><argument_list>(<argument><expr>-1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>lenp</name></expr>)</condition><then>
<expr_stmt><expr>*<name>lenp</name> = <name><name>self</name>-&gt;<name>size</name></name></expr>;</expr_stmt></then></if>
<return>return <expr>1</expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>Py_ssize_t</name></type>
<name>mmap_buffer_getcharbuffer</name><parameter_list>(<param><decl><type><name>mmap_object</name> *</type><name>self</name></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>index</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>void</name> **</type><name>ptr</name></decl></param>)</parameter_list> <block>{
<if>if <condition>(<expr><name>index</name> != 0</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_SystemError</name></expr></argument>,
<argument><expr>"accessing non-existent buffer segment"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>-1</expr>;</return>
}</block></then></if>
<expr_stmt><expr>*<name>ptr</name> = (const <name>char</name> *)<name><name>self</name>-&gt;<name>data</name></name></expr>;</expr_stmt>
<return>return <expr><name><name>self</name>-&gt;<name>size</name></name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>Py_ssize_t</name></type>
<name>mmap_length</name><parameter_list>(<param><decl><type><name>mmap_object</name> *</type><name>self</name></decl></param>)</parameter_list> <block>{
<expr_stmt><expr><call><name>CHECK_VALID</name><argument_list>(<argument><expr>-1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name><name>self</name>-&gt;<name>size</name></name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>mmap_item</name><parameter_list>(<param><decl><type><name>mmap_object</name> *</type><name>self</name></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>i</name></decl></param>)</parameter_list> <block>{
<expr_stmt><expr><call><name>CHECK_VALID</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>i</name> &lt; 0 || (<name>size_t</name>)<name>i</name> &gt;= <name><name>self</name>-&gt;<name>size</name></name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_IndexError</name></expr></argument>, <argument><expr>"mmap index out of range"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<return>return <expr><call><name>PyString_FromStringAndSize</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>data</name></name> + <name>i</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>mmap_slice</name><parameter_list>(<param><decl><type><name>mmap_object</name> *</type><name>self</name></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>ilow</name></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>ihigh</name></decl></param>)</parameter_list> <block>{
<expr_stmt><expr><call><name>CHECK_VALID</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>ilow</name> &lt; 0</expr>)</condition><then>
<expr_stmt><expr><name>ilow</name> = 0</expr>;</expr_stmt></then>
<else>else <if>if <condition>(<expr>(<name>size_t</name>)<name>ilow</name> &gt; <name><name>self</name>-&gt;<name>size</name></name></expr>)</condition><then>
<expr_stmt><expr><name>ilow</name> = <name><name>self</name>-&gt;<name>size</name></name></expr>;</expr_stmt></then></if></else></if>
<if>if <condition>(<expr><name>ihigh</name> &lt; 0</expr>)</condition><then>
<expr_stmt><expr><name>ihigh</name> = 0</expr>;</expr_stmt></then></if>
<if>if <condition>(<expr><name>ihigh</name> &lt; <name>ilow</name></expr>)</condition><then>
<expr_stmt><expr><name>ihigh</name> = <name>ilow</name></expr>;</expr_stmt></then>
<else>else <if>if <condition>(<expr>(<name>size_t</name>)<name>ihigh</name> &gt; <name><name>self</name>-&gt;<name>size</name></name></expr>)</condition><then>
<expr_stmt><expr><name>ihigh</name> = <name><name>self</name>-&gt;<name>size</name></name></expr>;</expr_stmt></then></if></else></if>
<return>return <expr><call><name>PyString_FromStringAndSize</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>data</name></name> + <name>ilow</name></expr></argument>, <argument><expr><name>ihigh</name>-<name>ilow</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>mmap_subscript</name><parameter_list>(<param><decl><type><name>mmap_object</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>item</name></decl></param>)</parameter_list> <block>{
<expr_stmt><expr><call><name>CHECK_VALID</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>PyIndex_Check</name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>i</name> <init>= <expr><call><name>PyNumber_AsSsize_t</name><argument_list>(<argument><expr><name>item</name></expr></argument>, <argument><expr><name>PyExc_IndexError</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>i</name> == -1 &amp;&amp; <call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<if>if <condition>(<expr><name>i</name> &lt; 0</expr>)</condition><then>
<expr_stmt><expr><name>i</name> += <name><name>self</name>-&gt;<name>size</name></name></expr>;</expr_stmt></then></if>
<if>if <condition>(<expr><name>i</name> &lt; 0 || (<name>size_t</name>)<name>i</name> &gt; <name><name>self</name>-&gt;<name>size</name></name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_IndexError</name></expr></argument>,
<argument><expr>"mmap index out of range"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<return>return <expr><call><name>PyString_FromStringAndSize</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>data</name></name> + <name>i</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</return>
}</block></then> <else>else <if>if <condition>(<expr><call><name>PySlice_Check</name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>start</name></decl>, <decl><type ref="prev"/><name>stop</name></decl>, <decl><type ref="prev"/><name>step</name></decl>, <decl><type ref="prev"/><name>slicelen</name></decl>;</decl_stmt>
<if>if <condition>(<expr><call><name>PySlice_GetIndicesEx</name><argument_list>(<argument><expr>(<name>PySliceObject</name> *)<name>item</name></expr></argument>, <argument><expr><name><name>self</name>-&gt;<name>size</name></name></expr></argument>,
<argument><expr>&amp;<name>start</name></expr></argument>, <argument><expr>&amp;<name>stop</name></expr></argument>, <argument><expr>&amp;<name>step</name></expr></argument>, <argument><expr>&amp;<name>slicelen</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then> <block>{
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<if>if <condition>(<expr><name>slicelen</name> &lt;= 0</expr>)</condition><then>
<return>return <expr><call><name>PyString_FromStringAndSize</name><argument_list>(<argument><expr>""</expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</return></then>
<else>else <if>if <condition>(<expr><name>step</name> == 1</expr>)</condition><then>
<return>return <expr><call><name>PyString_FromStringAndSize</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>data</name></name> + <name>start</name></expr></argument>,
<argument><expr><name>slicelen</name></expr></argument>)</argument_list></call></expr>;</return></then>
<else>else <block>{
<decl_stmt><decl><type><name>char</name> *</type><name>result_buf</name> <init>= <expr>(<name>char</name> *)<call><name>PyMem_Malloc</name><argument_list>(<argument><expr><name>slicelen</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>cur</name></decl>, <decl><type ref="prev"/><name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>result</name></decl>;</decl_stmt>
<if>if <condition>(<expr><name>result_buf</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><call><name>PyErr_NoMemory</name><argument_list>()</argument_list></call></expr>;</return></then></if>
<for>for (<init><expr><name>cur</name> = <name>start</name></expr>, <expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>slicelen</name></expr>;</condition>
<incr><expr><name>cur</name> += <name>step</name></expr>, <expr><name>i</name>++</expr></incr>) <block>{
<expr_stmt><expr><name><name>result_buf</name><index>[<expr><name>i</name></expr>]</index></name> = <name><name>self</name>-&gt;<name>data</name><index>[<expr><name>cur</name></expr>]</index></name></expr>;</expr_stmt>
}</block></for>
<expr_stmt><expr><name>result</name> = <call><name>PyString_FromStringAndSize</name><argument_list>(<argument><expr><name>result_buf</name></expr></argument>,
<argument><expr><name>slicelen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyMem_Free</name><argument_list>(<argument><expr><name>result_buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>result</name></expr>;</return>
}</block></else></if></else></if>
}</block></then> <else>else <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
<argument><expr>"mmap indices must be integers"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></else></if></else></if>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>mmap_concat</name><parameter_list>(<param><decl><type><name>mmap_object</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>bb</name></decl></param>)</parameter_list> <block>{
<expr_stmt><expr><call><name>CHECK_VALID</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_SystemError</name></expr></argument>,
<argument><expr>"mmaps don't support concatenation"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>mmap_repeat</name><parameter_list>(<param><decl><type><name>mmap_object</name> *</type><name>self</name></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>n</name></decl></param>)</parameter_list> <block>{
<expr_stmt><expr><call><name>CHECK_VALID</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_SystemError</name></expr></argument>,
<argument><expr>"mmaps don't support repeat operation"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>mmap_ass_slice</name><parameter_list>(<param><decl><type><name>mmap_object</name> *</type><name>self</name></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>ilow</name></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>ihigh</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>v</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>buf</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>CHECK_VALID</name><argument_list>(<argument><expr>-1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>ilow</name> &lt; 0</expr>)</condition><then>
<expr_stmt><expr><name>ilow</name> = 0</expr>;</expr_stmt></then>
<else>else <if>if <condition>(<expr>(<name>size_t</name>)<name>ilow</name> &gt; <name><name>self</name>-&gt;<name>size</name></name></expr>)</condition><then>
<expr_stmt><expr><name>ilow</name> = <name><name>self</name>-&gt;<name>size</name></name></expr>;</expr_stmt></then></if></else></if>
<if>if <condition>(<expr><name>ihigh</name> &lt; 0</expr>)</condition><then>
<expr_stmt><expr><name>ihigh</name> = 0</expr>;</expr_stmt></then></if>
<if>if <condition>(<expr><name>ihigh</name> &lt; <name>ilow</name></expr>)</condition><then>
<expr_stmt><expr><name>ihigh</name> = <name>ilow</name></expr>;</expr_stmt></then>
<else>else <if>if <condition>(<expr>(<name>size_t</name>)<name>ihigh</name> &gt; <name><name>self</name>-&gt;<name>size</name></name></expr>)</condition><then>
<expr_stmt><expr><name>ihigh</name> = <name><name>self</name>-&gt;<name>size</name></name></expr>;</expr_stmt></then></if></else></if>
<if>if <condition>(<expr><name>v</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
<argument><expr>"mmap object doesn't support slice deletion"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>-1</expr>;</return>
}</block></then></if>
<if>if <condition>(<expr>! (<call><name>PyString_Check</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call>)</expr> )</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_IndexError</name></expr></argument>,
<argument><expr>"mmap slice assignment must be a string"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>-1</expr>;</return>
}</block></then></if>
<if>if <condition>(<expr><call><name>PyString_Size</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call> != (<name>ihigh</name> - <name>ilow</name>)</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_IndexError</name></expr></argument>,
<argument><expr>"mmap slice assignment is wrong size"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>-1</expr>;</return>
}</block></then></if>
<if>if <condition>(<expr>!<call><name>is_writeable</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr>-1</expr>;</return></then></if>
<expr_stmt><expr><name>buf</name> = <call><name>PyString_AsString</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>data</name></name> + <name>ilow</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>ihigh</name>-<name>ilow</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>0</expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>mmap_ass_item</name><parameter_list>(<param><decl><type><name>mmap_object</name> *</type><name>self</name></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>i</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>v</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>buf</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>CHECK_VALID</name><argument_list>(<argument><expr>-1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>i</name> &lt; 0 || (<name>size_t</name>)<name>i</name> &gt;= <name><name>self</name>-&gt;<name>size</name></name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_IndexError</name></expr></argument>, <argument><expr>"mmap index out of range"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>-1</expr>;</return>
}</block></then></if>
<if>if <condition>(<expr><name>v</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
<argument><expr>"mmap object doesn't support item deletion"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>-1</expr>;</return>
}</block></then></if>
<if>if <condition>(<expr>! (<call><name>PyString_Check</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call> &amp;&amp; <call><name>PyString_Size</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call>==1)</expr> )</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_IndexError</name></expr></argument>,
<argument><expr>"mmap assignment must be single-character string"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>-1</expr>;</return>
}</block></then></if>
<if>if <condition>(<expr>!<call><name>is_writeable</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr>-1</expr>;</return></then></if>
<expr_stmt><expr><name>buf</name> = <call><name>PyString_AsString</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>self</name>-&gt;<name>data</name><index>[<expr><name>i</name></expr>]</index></name> = <name><name>buf</name><index>[<expr>0</expr>]</index></name></expr>;</expr_stmt>
<return>return <expr>0</expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>mmap_ass_subscript</name><parameter_list>(<param><decl><type><name>mmap_object</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>item</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>value</name></decl></param>)</parameter_list> <block>{
<expr_stmt><expr><call><name>CHECK_VALID</name><argument_list>(<argument><expr>-1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>PyIndex_Check</name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>i</name> <init>= <expr><call><name>PyNumber_AsSsize_t</name><argument_list>(<argument><expr><name>item</name></expr></argument>, <argument><expr><name>PyExc_IndexError</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>buf</name></decl>;</decl_stmt>
<if>if <condition>(<expr><name>i</name> == -1 &amp;&amp; <call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then>
<return>return <expr>-1</expr>;</return></then></if>
<if>if <condition>(<expr><name>i</name> &lt; 0</expr>)</condition><then>
<expr_stmt><expr><name>i</name> += <name><name>self</name>-&gt;<name>size</name></name></expr>;</expr_stmt></then></if>
<if>if <condition>(<expr><name>i</name> &lt; 0 || (<name>size_t</name>)<name>i</name> &gt; <name><name>self</name>-&gt;<name>size</name></name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_IndexError</name></expr></argument>,
<argument><expr>"mmap index out of range"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>-1</expr>;</return>
}</block></then></if>
<if>if <condition>(<expr><name>value</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
<argument><expr>"mmap object doesn't support item deletion"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>-1</expr>;</return>
}</block></then></if>
<if>if <condition>(<expr>!<call><name>PyString_Check</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call> || <call><name>PyString_Size</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call> != 1</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_IndexError</name></expr></argument>,
<argument><expr>"mmap assignment must be single-character string"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>-1</expr>;</return>
}</block></then></if>
<if>if <condition>(<expr>!<call><name>is_writeable</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr>-1</expr>;</return></then></if>
<expr_stmt><expr><name>buf</name> = <call><name>PyString_AsString</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>self</name>-&gt;<name>data</name><index>[<expr><name>i</name></expr>]</index></name> = <name><name>buf</name><index>[<expr>0</expr>]</index></name></expr>;</expr_stmt>
<return>return <expr>0</expr>;</return>
}</block></then> <else>else <if>if <condition>(<expr><call><name>PySlice_Check</name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>start</name></decl>, <decl><type ref="prev"/><name>stop</name></decl>, <decl><type ref="prev"/><name>step</name></decl>, <decl><type ref="prev"/><name>slicelen</name></decl>;</decl_stmt>
<if>if <condition>(<expr><call><name>PySlice_GetIndicesEx</name><argument_list>(<argument><expr>(<name>PySliceObject</name> *)<name>item</name></expr></argument>,
<argument><expr><name><name>self</name>-&gt;<name>size</name></name></expr></argument>, <argument><expr>&amp;<name>start</name></expr></argument>, <argument><expr>&amp;<name>stop</name></expr></argument>,
<argument><expr>&amp;<name>step</name></expr></argument>, <argument><expr>&amp;<name>slicelen</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then> <block>{
<return>return <expr>-1</expr>;</return>
}</block></then></if>
<if>if <condition>(<expr><name>value</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
<argument><expr>"mmap object doesn't support slice deletion"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>-1</expr>;</return>
}</block></then></if>
<if>if <condition>(<expr>!<call><name>PyString_Check</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_IndexError</name></expr></argument>,
<argument><expr>"mmap slice assignment must be a string"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>-1</expr>;</return>
}</block></then></if>
<if>if <condition>(<expr><call><name>PyString_Size</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call> != <name>slicelen</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_IndexError</name></expr></argument>,
<argument><expr>"mmap slice assignment is wrong size"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>-1</expr>;</return>
}</block></then></if>
<if>if <condition>(<expr>!<call><name>is_writeable</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr>-1</expr>;</return></then></if>
<if>if <condition>(<expr><name>slicelen</name> == 0</expr>)</condition><then>
<return>return <expr>0</expr>;</return></then>
<else>else <if>if <condition>(<expr><name>step</name> == 1</expr>)</condition><then> <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>buf</name> <init>= <expr><call><name>PyString_AsString</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>buf</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr>-1</expr>;</return></then></if>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>data</name></name> + <name>start</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>slicelen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>0</expr>;</return>
}</block></then> <else>else <block>{
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>cur</name></decl>, <decl><type ref="prev"/><name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>buf</name> <init>= <expr><call><name>PyString_AsString</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>buf</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr>-1</expr>;</return></then></if>
<for>for (<init><expr><name>cur</name> = <name>start</name></expr>, <expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>slicelen</name></expr>;</condition>
<incr><expr><name>cur</name> += <name>step</name></expr>, <expr><name>i</name>++</expr></incr>) <block>{
<expr_stmt><expr><name><name>self</name>-&gt;<name>data</name><index>[<expr><name>cur</name></expr>]</index></name> = <name><name>buf</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
}</block></for>
<return>return <expr>0</expr>;</return>
}</block></else></if></else></if>
}</block></then> <else>else <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
<argument><expr>"mmap indices must be integer"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>-1</expr>;</return>
}</block></else></if></else></if>
}</block></function>
<decl_stmt><decl><type><specifier>static</specifier> <name>PySequenceMethods</name></type> <name>mmap_as_sequence</name> <init>= <expr><block>{
<expr>(<name>lenfunc</name>)<name>mmap_length</name></expr>,
<expr>(<name>binaryfunc</name>)<name>mmap_concat</name></expr>,
<expr>(<name>ssizeargfunc</name>)<name>mmap_repeat</name></expr>,
<expr>(<name>ssizeargfunc</name>)<name>mmap_item</name></expr>,
<expr>(<name>ssizessizeargfunc</name>)<name>mmap_slice</name></expr>,
<expr>(<name>ssizeobjargproc</name>)<name>mmap_ass_item</name></expr>,
<expr>(<name>ssizessizeobjargproc</name>)<name>mmap_ass_slice</name></expr>,
}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>PyMappingMethods</name></type> <name>mmap_as_mapping</name> <init>= <expr><block>{
<expr>(<name>lenfunc</name>)<name>mmap_length</name></expr>,
<expr>(<name>binaryfunc</name>)<name>mmap_subscript</name></expr>,
<expr>(<name>objobjargproc</name>)<name>mmap_ass_subscript</name></expr>,
}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>PyBufferProcs</name></type> <name>mmap_as_buffer</name> <init>= <expr><block>{
<expr>(<name>readbufferproc</name>)<name>mmap_buffer_getreadbuf</name></expr>,
<expr>(<name>writebufferproc</name>)<name>mmap_buffer_getwritebuf</name></expr>,
<expr>(<name>segcountproc</name>)<name>mmap_buffer_getsegcount</name></expr>,
<expr>(<name>charbufferproc</name>)<name>mmap_buffer_getcharbuffer</name></expr>,
}</block></expr></init></decl>;</decl_stmt>
<function_decl><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>new_mmap_object</name><parameter_list>(<param><decl><type><name>PyTypeObject</name> *</type><name>type</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>kwdict</name></decl></param>)</parameter_list>;</function_decl>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>mmap_doc</name></expr></argument>,
<argument><expr>"Windows: mmap(fileno, length[, tagname[, access[, offset]]])\n\
\n\
Maps length bytes from the file specified by the file handle fileno,\n\
and returns a mmap object. If length is larger than the current size\n\
of the file, the file is extended to contain length bytes. If length\n\
is 0, the maximum length of the map is the current size of the file,\n\
except that if the file is empty Windows raises an exception (you cannot\n\
create an empty mapping on Windows).\n\
\n\
Unix: mmap(fileno, length[, flags[, prot[, access[, offset]]]])\n\
\n\
Maps length bytes from the file specified by the file descriptor fileno,\n\
and returns a mmap object. If length is 0, the maximum length of the map\n\
will be the current size of the file when mmap is called.\n\
flags specifies the nature of the mapping. MAP_PRIVATE creates a\n\
private copy-on-write mapping, so changes to the contents of the mmap\n\
object will be private to this process, and MAP_SHARED creates a mapping\n\
that's shared with all other processes mapping the same areas of the file.\n\
The default value is MAP_SHARED.\n\
\n\
To map anonymous memory, pass -1 as the fileno (both versions)."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>PyTypeObject</name></type> <name>mmap_object_type</name> <init>= <expr><block>{
<expr><call><name>PyVarObject_HEAD_INIT</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call>
"mmap.mmap"</expr>,
<expr><sizeof>sizeof<argument_list>(<argument><expr><name>mmap_object</name></expr></argument>)</argument_list></sizeof></expr>,
<expr>0</expr>,
<expr>(<name>destructor</name>) <name>mmap_object_dealloc</name></expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>&amp;<name>mmap_as_sequence</name></expr>,
<expr>&amp;<name>mmap_as_mapping</name></expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr><name>PyObject_GenericGetAttr</name></expr>,
<expr>0</expr>,
<expr>&amp;<name>mmap_as_buffer</name></expr>,
<expr><name>Py_TPFLAGS_DEFAULT</name> | <name>Py_TPFLAGS_BASETYPE</name> | <name>Py_TPFLAGS_HAVE_GETCHARBUFFER</name></expr>,
<expr><name>mmap_doc</name></expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr><name>mmap_object_methods</name></expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr><name>PyType_GenericAlloc</name></expr>,
<expr><name>new_mmap_object</name></expr>,
<expr><name>PyObject_Del</name></expr>,
}</block></expr></init></decl>;</decl_stmt>
<function><type><specifier>static</specifier> <name>Py_ssize_t</name></type>
<name>_GetMapSize</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>o</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name>*</type> <name>param</name></decl></param>)</parameter_list> <block>{
<if>if <condition>(<expr><name>o</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr>0</expr>;</return></then></if>
<if>if <condition>(<expr><call><name>PyIndex_Check</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>i</name> <init>= <expr><call><name>PyNumber_AsSsize_t</name><argument_list>(<argument><expr><name>o</name></expr></argument>, <argument><expr><name>PyExc_OverflowError</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>i</name>==-1 &amp;&amp; <call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then>
<return>return <expr>-1</expr>;</return></then></if>
<if>if <condition>(<expr><name>i</name> &lt; 0</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_OverflowError</name></expr></argument>,
<argument><expr>"memory mapped %s must be positive"</expr></argument>,
<argument><expr><name>param</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>-1</expr>;</return>
}</block></then></if>
<return>return <expr><name>i</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>, <argument><expr>"map size must be an integral value"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>-1</expr>;</return>
}</block></function>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>UNIX</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>new_mmap_object</name><parameter_list>(<param><decl><type><name>PyTypeObject</name> *</type><name>type</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>kwdict</name></decl></param>)</parameter_list> <block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_FSTAT</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type>struct <name>stat</name></type> <name>st</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<decl_stmt><decl><type><name>mmap_object</name> *</type><name>m_obj</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>map_size_obj</name> <init>= <expr><name>NULL</name></expr></init>, *<name>offset_obj</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>map_size</name></decl>, <decl><type ref="prev"/><name>offset</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>fd</name></decl>, <decl><type ref="prev"/><name>flags</name> <init>= <expr><name>MAP_SHARED</name></expr></init>, <name>prot</name> <init>= <expr><name>PROT_WRITE</name> | <name>PROT_READ</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>devzero</name> <init>= <expr>-1</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>access</name> <init>= <expr>(<name>int</name>)<name>ACCESS_DEFAULT</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> *</type><name><name>keywords</name><index>[]</index></name> <init>= <expr><block>{<expr>"fileno"</expr>, <expr>"length"</expr>,
<expr>"flags"</expr>, <expr>"prot"</expr>,
<expr>"access"</expr>, <expr>"offset"</expr>, <expr><name>NULL</name></expr>
}</block></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTupleAndKeywords</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>kwdict</name></expr></argument>, <argument><expr>"iO|iiiO"</expr></argument>, <argument><expr><name>keywords</name></expr></argument>,
<argument><expr>&amp;<name>fd</name></expr></argument>, <argument><expr>&amp;<name>map_size_obj</name></expr></argument>, <argument><expr>&amp;<name>flags</name></expr></argument>, <argument><expr>&amp;<name>prot</name></expr></argument>,
<argument><expr>&amp;<name>access</name></expr></argument>, <argument><expr>&amp;<name>offset_obj</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>map_size</name> = <call><name>_GetMapSize</name><argument_list>(<argument><expr><name>map_size_obj</name></expr></argument>, <argument><expr>"size"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>map_size</name> &lt; 0</expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>offset</name> = <call><name>_GetMapSize</name><argument_list>(<argument><expr><name>offset_obj</name></expr></argument>, <argument><expr>"offset"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>offset</name> &lt; 0</expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<if>if <condition>(<expr>(<name>access</name> != (<name>int</name>)<name>ACCESS_DEFAULT</name>) &amp;&amp;
((<name>flags</name> != <name>MAP_SHARED</name>) || (<name>prot</name> != (<name>PROT_WRITE</name> | <name>PROT_READ</name>)))</expr>)</condition><then>
<return>return <expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>,
<argument><expr>"mmap can't specify both access and flags, prot."</expr></argument>)</argument_list></call></expr>;</return></then></if>
<switch>switch <condition>(<expr>(<name>access_mode</name>)<name>access</name></expr>)</condition> <block>{
<case>case <expr><name>ACCESS_READ</name></expr>:
<expr_stmt><expr><name>flags</name> = <name>MAP_SHARED</name></expr>;</expr_stmt>
<expr_stmt><expr><name>prot</name> = <name>PROT_READ</name></expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr><name>ACCESS_WRITE</name></expr>:
<expr_stmt><expr><name>flags</name> = <name>MAP_SHARED</name></expr>;</expr_stmt>
<expr_stmt><expr><name>prot</name> = <name>PROT_READ</name> | <name>PROT_WRITE</name></expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr><name>ACCESS_COPY</name></expr>:
<expr_stmt><expr><name>flags</name> = <name>MAP_PRIVATE</name></expr>;</expr_stmt>
<expr_stmt><expr><name>prot</name> = <name>PROT_READ</name> | <name>PROT_WRITE</name></expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr><name>ACCESS_DEFAULT</name></expr>:
<break>break;</break>
</case><default>default:
<return>return <expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>,
<argument><expr>"mmap invalid access parameter."</expr></argument>)</argument_list></call></expr>;</return>
</default>}</block></switch>
<if>if <condition>(<expr><name>prot</name> == <name>PROT_READ</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>access</name> = <name>ACCESS_READ</name></expr>;</expr_stmt>
}</block></then></if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_FSTAT</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__VMS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if>if <condition>(<expr><name>fd</name> != -1</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>fsync</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<if>if <condition>(<expr><name>fd</name> != -1 &amp;&amp; <call><name>fstat</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr>&amp;<name>st</name></expr></argument>)</argument_list></call> == 0 &amp;&amp; <call><name>S_ISREG</name><argument_list>(<argument><expr><name><name>st</name>.<name>st_mode</name></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<if>if <condition>(<expr><name>map_size</name> == 0</expr>)</condition><then> <block>{
<expr_stmt><expr><name>map_size</name> = <name><name>st</name>.<name>st_size</name></name></expr>;</expr_stmt>
}</block></then> <else>else <if>if <condition>(<expr>(<name>size_t</name>)<name>offset</name> + (<name>size_t</name>)<name>map_size</name> &gt; <name><name>st</name>.<name>st_size</name></name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>,
<argument><expr>"mmap length is greater than file size"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if></else></if>
}</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><name>m_obj</name> = (<name>mmap_object</name> *)<call><name><name>type</name>-&gt;<name>tp_alloc</name></name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>m_obj</name> == <name>NULL</name></expr>)</condition><then> <block>{
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name><name>m_obj</name>-&gt;<name>data</name></name> = <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>m_obj</name>-&gt;<name>size</name></name> = (<name>size_t</name>) <name>map_size</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>m_obj</name>-&gt;<name>pos</name></name> = (<name>size_t</name>) 0</expr>;</expr_stmt>
<expr_stmt><expr><name><name>m_obj</name>-&gt;<name>offset</name></name> = <name>offset</name></expr>;</expr_stmt>
<if>if <condition>(<expr><name>fd</name> == -1</expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>m_obj</name>-&gt;<name>fd</name></name> = -1</expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MAP_ANONYMOUS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><name>flags</name> |= <name>MAP_ANONYMOUS</name></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<expr_stmt><expr><name>fd</name> = <name>devzero</name> = <call><name>open</name><argument_list>(<argument><expr>"/dev/zero"</expr></argument>, <argument><expr><name>O_RDWR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>devzero</name> == -1</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>m_obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyErr_SetFromErrno</name><argument_list>(<argument><expr><name>mmap_module_error</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></then> <else>else <block>{
<expr_stmt><expr><name><name>m_obj</name>-&gt;<name>fd</name></name> = <call><name>dup</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>m_obj</name>-&gt;<name>fd</name></name> == -1</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>m_obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyErr_SetFromErrno</name><argument_list>(<argument><expr><name>mmap_module_error</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
}</block></else></if>
<expr_stmt><expr><name><name>m_obj</name>-&gt;<name>data</name></name> = <call><name>mmap</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>map_size</name></expr></argument>,
<argument><expr><name>prot</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>,
<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>devzero</name> != -1</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name>devzero</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<if>if <condition>(<expr><name><name>m_obj</name>-&gt;<name>data</name></name> == (<name>char</name> *)-1</expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>m_obj</name>-&gt;<name>data</name></name> = <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>m_obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyErr_SetFromErrno</name><argument_list>(<argument><expr><name>mmap_module_error</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name><name>m_obj</name>-&gt;<name>access</name></name> = (<name>access_mode</name>)<name>access</name></expr>;</expr_stmt>
<return>return <expr>(<name>PyObject</name> *)<name>m_obj</name></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MS_WINDOWS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>new_mmap_object</name><parameter_list>(<param><decl><type><name>PyTypeObject</name> *</type><name>type</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>kwdict</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>mmap_object</name> *</type><name>m_obj</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>map_size_obj</name> <init>= <expr><name>NULL</name></expr></init>, *<name>offset_obj</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>map_size</name></decl>, <decl><type ref="prev"/><name>offset</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>DWORD</name></type> <name>off_hi</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>DWORD</name></type> <name>off_lo</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>DWORD</name></type> <name>size_hi</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>DWORD</name></type> <name>size_lo</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>tagname</name> <init>= <expr>""</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>DWORD</name></type> <name>dwErr</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>fileno</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>HANDLE</name></type> <name>fh</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>access</name> <init>= <expr>(<name>access_mode</name>)<name>ACCESS_DEFAULT</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>DWORD</name></type> <name>flProtect</name></decl>, <decl><type ref="prev"/><name>dwDesiredAccess</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> *</type><name><name>keywords</name><index>[]</index></name> <init>= <expr><block>{ <expr>"fileno"</expr>, <expr>"length"</expr>,
<expr>"tagname"</expr>,
<expr>"access"</expr>, <expr>"offset"</expr>, <expr><name>NULL</name></expr>
}</block></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTupleAndKeywords</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>kwdict</name></expr></argument>, <argument><expr>"iO|ziO"</expr></argument>, <argument><expr><name>keywords</name></expr></argument>,
<argument><expr>&amp;<name>fileno</name></expr></argument>, <argument><expr>&amp;<name>map_size_obj</name></expr></argument>,
<argument><expr>&amp;<name>tagname</name></expr></argument>, <argument><expr>&amp;<name>access</name></expr></argument>, <argument><expr>&amp;<name>offset_obj</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<switch>switch<condition>(<expr>(<name>access_mode</name>)<name>access</name></expr>)</condition> <block>{
<case>case <expr><name>ACCESS_READ</name></expr>:
<expr_stmt><expr><name>flProtect</name> = <name>PAGE_READONLY</name></expr>;</expr_stmt>
<expr_stmt><expr><name>dwDesiredAccess</name> = <name>FILE_MAP_READ</name></expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr><name>ACCESS_DEFAULT</name></expr>:
</case><case>case <expr><name>ACCESS_WRITE</name></expr>:
<expr_stmt><expr><name>flProtect</name> = <name>PAGE_READWRITE</name></expr>;</expr_stmt>
<expr_stmt><expr><name>dwDesiredAccess</name> = <name>FILE_MAP_WRITE</name></expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr><name>ACCESS_COPY</name></expr>:
<expr_stmt><expr><name>flProtect</name> = <name>PAGE_WRITECOPY</name></expr>;</expr_stmt>
<expr_stmt><expr><name>dwDesiredAccess</name> = <name>FILE_MAP_COPY</name></expr>;</expr_stmt>
<break>break;</break>
</case><default>default:
<return>return <expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>,
<argument><expr>"mmap invalid access parameter."</expr></argument>)</argument_list></call></expr>;</return>
</default>}</block></switch>
<expr_stmt><expr><name>map_size</name> = <call><name>_GetMapSize</name><argument_list>(<argument><expr><name>map_size_obj</name></expr></argument>, <argument><expr>"size"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>map_size</name> &lt; 0</expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>offset</name> = <call><name>_GetMapSize</name><argument_list>(<argument><expr><name>offset_obj</name></expr></argument>, <argument><expr>"offset"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>offset</name> &lt; 0</expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<if>if <condition>(<expr><name>fileno</name> != -1 &amp;&amp; <name>fileno</name> != 0</expr>)</condition><then> <block>{
<expr_stmt><expr><name>fh</name> = (<name>HANDLE</name>)<call><name>_get_osfhandle</name><argument_list>(<argument><expr><name>fileno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>fh</name>==(<name>HANDLE</name>)-1</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetFromErrno</name><argument_list>(<argument><expr><name>mmap_module_error</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><call><name>lseek</name><argument_list>(<argument><expr><name>fileno</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>SEEK_SET</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><name>m_obj</name> = (<name>mmap_object</name> *)<call><name><name>type</name>-&gt;<name>tp_alloc</name></name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>m_obj</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name><name>m_obj</name>-&gt;<name>data</name></name> = <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>m_obj</name>-&gt;<name>file_handle</name></name> = <name>INVALID_HANDLE_VALUE</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>m_obj</name>-&gt;<name>map_handle</name></name> = <name>INVALID_HANDLE_VALUE</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>m_obj</name>-&gt;<name>tagname</name></name> = <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>m_obj</name>-&gt;<name>offset</name></name> = <name>offset</name></expr>;</expr_stmt>
<if>if <condition>(<expr><name>fh</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr>!<call><name>DuplicateHandle</name><argument_list>(
<argument><expr><call><name>GetCurrentProcess</name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><name>fh</name></expr></argument>,
<argument><expr><call><name>GetCurrentProcess</name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr>(<name>LPHANDLE</name>)&amp;<name><name>m_obj</name>-&gt;<name>file_handle</name></name></expr></argument>,
<argument><expr>0</expr></argument>,
<argument><expr><name>FALSE</name></expr></argument>,
<argument><expr><name>DUPLICATE_SAME_ACCESS</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><name>dwErr</name> = <call><name>GetLastError</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>m_obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyErr_SetFromWindowsErr</name><argument_list>(<argument><expr><name>dwErr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<if>if <condition>(<expr>!<name>map_size</name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>DWORD</name></type> <name>low</name></decl>,<decl><type ref="prev"/><name>high</name></decl>;</decl_stmt>
<expr_stmt><expr><name>low</name> = <call><name>GetFileSize</name><argument_list>(<argument><expr><name>fh</name></expr></argument>, <argument><expr>&amp;<name>high</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>low</name> == <name>INVALID_FILE_SIZE</name> &amp;&amp;
(<name>dwErr</name> = <call><name>GetLastError</name><argument_list>()</argument_list></call>) != <name>NO_ERROR</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>m_obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>PyErr_SetFromWindowsErr</name><argument_list>(<argument><expr><name>dwErr</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></then></if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SIZEOF_SIZE_T</name> &gt; 4</expr></cpp:if>
<expr_stmt><expr><name><name>m_obj</name>-&gt;<name>size</name></name> = (((<name>size_t</name>)<name>high</name>)&lt;&lt;32) + <name>low</name></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<if>if <condition>(<expr><name>high</name></expr>)</condition><then>
<expr_stmt><expr><name><name>m_obj</name>-&gt;<name>size</name></name> = (<name>size_t</name>)-1</expr>;</expr_stmt></then>
<else>else
<expr_stmt><expr><name><name>m_obj</name>-&gt;<name>size</name></name> = <name>low</name></expr>;</expr_stmt></else></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></then> <else>else <block>{
<expr_stmt><expr><name><name>m_obj</name>-&gt;<name>size</name></name> = <name>map_size</name></expr>;</expr_stmt>
}</block></else></if>
}</block></then> <else>else <block>{
<expr_stmt><expr><name><name>m_obj</name>-&gt;<name>size</name></name> = <name>map_size</name></expr>;</expr_stmt>
}</block></else></if>
<expr_stmt><expr><name><name>m_obj</name>-&gt;<name>pos</name></name> = (<name>size_t</name>) 0</expr>;</expr_stmt>
<if>if <condition>(<expr><name>tagname</name> != <name>NULL</name> &amp;&amp; *<name>tagname</name> != '\0'</expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>m_obj</name>-&gt;<name>tagname</name></name> = <call><name>PyMem_Malloc</name><argument_list>(<argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>tagname</name></expr></argument>)</argument_list></call>+1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>m_obj</name>-&gt;<name>tagname</name></name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_NoMemory</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>m_obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name><name>m_obj</name>-&gt;<name>tagname</name></name></expr></argument>, <argument><expr><name>tagname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else
<expr_stmt><expr><name><name>m_obj</name>-&gt;<name>tagname</name></name> = <name>NULL</name></expr>;</expr_stmt></else></if>
<expr_stmt><expr><name><name>m_obj</name>-&gt;<name>access</name></name> = (<name>access_mode</name>)<name>access</name></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SIZEOF_SIZE_T</name> &gt; 4</expr></cpp:if>
<expr_stmt><expr><name>size_hi</name> = <call>(<name>DWORD</name>)<argument_list>(<argument><expr>(<name>offset</name> + <name><name>m_obj</name>-&gt;<name>size</name></name>) &gt;&gt; 32</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>size_lo</name> = <call>(<name>DWORD</name>)<argument_list>(<argument><expr>(<name>offset</name> + <name><name>m_obj</name>-&gt;<name>size</name></name>) &amp; 0xFFFFFFFF</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>off_hi</name> = <call>(<name>DWORD</name>)<argument_list>(<argument><expr><name>offset</name> &gt;&gt; 32</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>off_lo</name> = <call>(<name>DWORD</name>)<argument_list>(<argument><expr><name>offset</name> &amp; 0xFFFFFFFF</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<expr_stmt><expr><name>size_hi</name> = 0</expr>;</expr_stmt>
<expr_stmt><expr><name>size_lo</name> = <call>(<name>DWORD</name>)<argument_list>(<argument><expr><name>offset</name> + <name><name>m_obj</name>-&gt;<name>size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>off_hi</name> = 0</expr>;</expr_stmt>
<expr_stmt><expr><name>off_lo</name> = (<name>DWORD</name>)<name>offset</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><name><name>m_obj</name>-&gt;<name>map_handle</name></name> = <call><name>CreateFileMapping</name><argument_list>(<argument><expr><name><name>m_obj</name>-&gt;<name>file_handle</name></name></expr></argument>,
<argument><expr><name>NULL</name></expr></argument>,
<argument><expr><name>flProtect</name></expr></argument>,
<argument><expr><name>size_hi</name></expr></argument>,
<argument><expr><name>size_lo</name></expr></argument>,
<argument><expr><name><name>m_obj</name>-&gt;<name>tagname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>m_obj</name>-&gt;<name>map_handle</name></name> != <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>m_obj</name>-&gt;<name>data</name></name> = (<name>char</name> *) <call><name>MapViewOfFile</name><argument_list>(<argument><expr><name><name>m_obj</name>-&gt;<name>map_handle</name></name></expr></argument>,
<argument><expr><name>dwDesiredAccess</name></expr></argument>,
<argument><expr><name>off_hi</name></expr></argument>,
<argument><expr><name>off_lo</name></expr></argument>,
<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>m_obj</name>-&gt;<name>data</name></name> != <name>NULL</name></expr>)</condition><then>
<return>return <expr>(<name>PyObject</name> *)<name>m_obj</name></expr>;</return></then>
<else>else
<expr_stmt><expr><name>dwErr</name> = <call><name>GetLastError</name><argument_list>()</argument_list></call></expr>;</expr_stmt></else></if>
}</block></then> <else>else
<expr_stmt><expr><name>dwErr</name> = <call><name>GetLastError</name><argument_list>()</argument_list></call></expr>;</expr_stmt></else></if>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>m_obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyErr_SetFromWindowsErr</name><argument_list>(<argument><expr><name>dwErr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>setint</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>d</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>name</name></decl></param>, <param><decl><type><name>long</name></type> <name>value</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>o</name> <init>= <expr><call><name>PyInt_FromLong</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>o</name> &amp;&amp; <call><name>PyDict_SetItemString</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>o</name></expr></argument>)</argument_list></call> == 0</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
}</block></function>
<function><type><name>PyMODINIT_FUNC</name></type>
<name>initmmap</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>dict</name></decl>, *<decl><type ref="prev"/><name>module</name></decl>;</decl_stmt>
<if>if <condition>(<expr><call><name>PyType_Ready</name><argument_list>(<argument><expr>&amp;<name>mmap_object_type</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
<return>return;</return></then></if>
<expr_stmt><expr><name>module</name> = <call><name>Py_InitModule</name><argument_list>(<argument><expr>"mmap"</expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>module</name> == <name>NULL</name></expr>)</condition><then>
<return>return;</return></then></if>
<expr_stmt><expr><name>dict</name> = <call><name>PyModule_GetDict</name><argument_list>(<argument><expr><name>module</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>dict</name></expr>)</condition><then>
<return>return;</return></then></if>
<expr_stmt><expr><name>mmap_module_error</name> = <call><name>PyErr_NewException</name><argument_list>(<argument><expr>"mmap.error"</expr></argument>,
<argument><expr><name>PyExc_EnvironmentError</name></expr></argument> , <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>mmap_module_error</name> == <name>NULL</name></expr>)</condition><then>
<return>return;</return></then></if>
<expr_stmt><expr><call><name>PyDict_SetItemString</name><argument_list>(<argument><expr><name>dict</name></expr></argument>, <argument><expr>"error"</expr></argument>, <argument><expr><name>mmap_module_error</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyDict_SetItemString</name><argument_list>(<argument><expr><name>dict</name></expr></argument>, <argument><expr>"mmap"</expr></argument>, <argument><expr>(<name>PyObject</name>*) &amp;<name>mmap_object_type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>PROT_EXEC</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>setint</name><argument_list>(<argument><expr><name>dict</name></expr></argument>, <argument><expr>"PROT_EXEC"</expr></argument>, <argument><expr><name>PROT_EXEC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>PROT_READ</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>setint</name><argument_list>(<argument><expr><name>dict</name></expr></argument>, <argument><expr>"PROT_READ"</expr></argument>, <argument><expr><name>PROT_READ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>PROT_WRITE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>setint</name><argument_list>(<argument><expr><name>dict</name></expr></argument>, <argument><expr>"PROT_WRITE"</expr></argument>, <argument><expr><name>PROT_WRITE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MAP_SHARED</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>setint</name><argument_list>(<argument><expr><name>dict</name></expr></argument>, <argument><expr>"MAP_SHARED"</expr></argument>, <argument><expr><name>MAP_SHARED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MAP_PRIVATE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>setint</name><argument_list>(<argument><expr><name>dict</name></expr></argument>, <argument><expr>"MAP_PRIVATE"</expr></argument>, <argument><expr><name>MAP_PRIVATE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MAP_DENYWRITE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>setint</name><argument_list>(<argument><expr><name>dict</name></expr></argument>, <argument><expr>"MAP_DENYWRITE"</expr></argument>, <argument><expr><name>MAP_DENYWRITE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MAP_EXECUTABLE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>setint</name><argument_list>(<argument><expr><name>dict</name></expr></argument>, <argument><expr>"MAP_EXECUTABLE"</expr></argument>, <argument><expr><name>MAP_EXECUTABLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MAP_ANONYMOUS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>setint</name><argument_list>(<argument><expr><name>dict</name></expr></argument>, <argument><expr>"MAP_ANON"</expr></argument>, <argument><expr><name>MAP_ANONYMOUS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>setint</name><argument_list>(<argument><expr><name>dict</name></expr></argument>, <argument><expr>"MAP_ANONYMOUS"</expr></argument>, <argument><expr><name>MAP_ANONYMOUS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><call><name>setint</name><argument_list>(<argument><expr><name>dict</name></expr></argument>, <argument><expr>"PAGESIZE"</expr></argument>, <argument><expr>(<name>long</name>)<call><name>my_getpagesize</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>setint</name><argument_list>(<argument><expr><name>dict</name></expr></argument>, <argument><expr>"ALLOCATIONGRANULARITY"</expr></argument>, <argument><expr>(<name>long</name>)<call><name>my_getallocationgranularity</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>setint</name><argument_list>(<argument><expr><name>dict</name></expr></argument>, <argument><expr>"ACCESS_READ"</expr></argument>, <argument><expr><name>ACCESS_READ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>setint</name><argument_list>(<argument><expr><name>dict</name></expr></argument>, <argument><expr>"ACCESS_WRITE"</expr></argument>, <argument><expr><name>ACCESS_WRITE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>setint</name><argument_list>(<argument><expr><name>dict</name></expr></argument>, <argument><expr>"ACCESS_COPY"</expr></argument>, <argument><expr><name>ACCESS_COPY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>
</unit>
