<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C" filename="projects/cpython-2.6.1/_cppstats/Modules/_hotshot.c"><cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"Python.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"code.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"eval.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"frameobject.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"structmember.h"</cpp:file></cpp:include>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MS_WINDOWS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;windows.h&gt;</cpp:file></cpp:include>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_DIRECT_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;direct.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<typedef>typedef <type><name>__int64</name></type> <name>hs_time</name>;</typedef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GETTIMEOFDAY</name><parameter_list>(<param><type><name>P_HS_TIME</name></type></param>)</parameter_list></cpp:macro> <cpp:value>{ LARGE_INTEGER _temp; QueryPerformanceCounter(&amp;_temp); *(P_HS_TIME) = _temp.QuadPart; }</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>HAVE_GETTIMEOFDAY</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:error>#<cpp:directive>error</cpp:directive> "This module requires gettimeofday() on non-Windows platforms!"</cpp:error>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>(<call><name>defined</name><argument_list>(<argument><expr><name>PYOS_OS2</name></expr></argument>)</argument_list></call> &amp;&amp; <call><name>defined</name><argument_list>(<argument><expr><name>PYCC_GCC</name></expr></argument>)</argument_list></call>) || <call><name>defined</name><argument_list>(<argument><expr><name>__QNX__</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/time.h&gt;</cpp:file></cpp:include>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/resource.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/times.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<typedef>typedef <type>struct <name>timeval</name></type> <name>hs_time</name>;</typedef>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>__cplusplus</name></expr></argument>)</argument_list></call> &amp;&amp; !<call><name>defined</name><argument_list>(<argument><expr><name>inline</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__GNUC__</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>inline</name></cpp:macro> <cpp:value>__inline</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>inline</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>inline</name></cpp:macro></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BUFFERSIZE</name></cpp:macro> <cpp:value>10240</cpp:value></cpp:define>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>PYOS_OS2</name></expr></argument>)</argument_list></call> &amp;&amp; <call><name>defined</name><argument_list>(<argument><expr><name>PYCC_GCC</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PATH_MAX</name></cpp:macro> <cpp:value>260</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__sgi</name></expr></argument>)</argument_list></call> &amp;&amp; <name>_COMPILER_VERSION</name>&gt;700 &amp;&amp; !<call><name>defined</name><argument_list>(<argument><expr><name>PATH_MAX</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PATH_MAX</name></cpp:macro> <cpp:value>1024</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>PATH_MAX</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MAX_PATH</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PATH_MAX</name></cpp:macro> <cpp:value>MAX_PATH</cpp:value></cpp:define>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name> <argument_list>(<argument><expr><name>_POSIX_PATH_MAX</name></expr></argument>)</argument_list></call></expr></cpp:elif>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PATH_MAX</name></cpp:macro> <cpp:value>_POSIX_PATH_MAX</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:error>#<cpp:directive>error</cpp:directive> "Need a defn. for PATH_MAX in _hotshot.c"</cpp:error>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<typedef>typedef <type><struct>struct <block>{
<decl_stmt><decl><type><name>PyObject_HEAD</name>
<name>PyObject</name> *</type><name>filemap</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>logfilename</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>index</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name><name>buffer</name><index>[<expr><name>BUFFERSIZE</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>FILE</name> *</type><name>logfp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>lineevents</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>linetimings</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>frametimings</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>active</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>next_fileno</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>hs_time</name></type> <name>prev_timeofday</name></decl>;</decl_stmt>
}</block></struct></type> <name>ProfilerObject</name>;</typedef>
<typedef>typedef <type><struct>struct <block>{
<decl_stmt><decl><type><name>PyObject_HEAD</name>
<name>PyObject</name> *</type><name>info</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>FILE</name> *</type><name>logfp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>linetimings</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>frametimings</name></decl>;</decl_stmt>
}</block></struct></type> <name>LogReaderObject</name>;</typedef>
<decl_stmt><decl><type><specifier>static</specifier> <name>PyObject</name> *</type> <name>ProfilerError</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>MS_WINDOWS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>GETTIMEOFDAY_NO_TZ</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GETTIMEOFDAY</name><parameter_list>(<param><type><name>ptv</name></type></param>)</parameter_list></cpp:macro> <cpp:value>gettimeofday((ptv))</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GETTIMEOFDAY</name><parameter_list>(<param><type><name>ptv</name></type></param>)</parameter_list></cpp:macro> <cpp:value>gettimeofday((ptv), (struct timezone *)NULL)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>logreader_close__doc__</name></expr></argument>,
<argument><expr>"close()\n"
"Close the log file, preventing additional records from being read."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>logreader_close</name><parameter_list>(<param><decl><type><name>LogReaderObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<if>if <condition>(<expr><name><name>self</name>-&gt;<name>logfp</name></name> != <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>logfp</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>self</name>-&gt;<name>logfp</name></name> = <name>NULL</name></expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>Py_None</name></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>logreader_fileno__doc__</name></expr></argument>,
<argument><expr>"fileno() -&gt; file descriptor\n"
"Returns the file descriptor for the log file, if open.\n"
"Raises ValueError if the log file is closed."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>logreader_fileno</name><parameter_list>(<param><decl><type><name>LogReaderObject</name> *</type><name>self</name></decl></param>)</parameter_list> <block>{
<if>if <condition>(<expr><name><name>self</name>-&gt;<name>logfp</name></name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>,
<argument><expr>"logreader's file object already closed"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<return>return <expr><call><name>PyInt_FromLong</name><argument_list>(<argument><expr><call><name>fileno</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>logfp</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WHAT_ENTER</name></cpp:macro> <cpp:value>0x00</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WHAT_EXIT</name></cpp:macro> <cpp:value>0x01</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WHAT_LINENO</name></cpp:macro> <cpp:value>0x02</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WHAT_OTHER</name></cpp:macro> <cpp:value>0x03</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WHAT_ADD_INFO</name></cpp:macro> <cpp:value>0x13</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WHAT_DEFINE_FILE</name></cpp:macro> <cpp:value>0x23</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WHAT_LINE_TIMES</name></cpp:macro> <cpp:value>0x33</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WHAT_DEFINE_FUNC</name></cpp:macro> <cpp:value>0x43</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WHAT_FRAME_TIMES</name></cpp:macro> <cpp:value>0x53</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ERR_NONE</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ERR_EOF</name></cpp:macro> <cpp:value>-1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ERR_EXCEPTION</name></cpp:macro> <cpp:value>-2</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ERR_BAD_RECTYPE</name></cpp:macro> <cpp:value>-3</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PISIZE</name></cpp:macro> <cpp:value>(sizeof(int) + 1)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MPISIZE</name></cpp:macro> <cpp:value>(PISIZE + 1)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAXEVENTSIZE</name></cpp:macro> <cpp:value>(MPISIZE + PISIZE*2)</cpp:value></cpp:define>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>unpack_packed_int</name><parameter_list>(<param><decl><type><name>LogReaderObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>int</name> *</type><name>pvalue</name></decl></param>, <param><decl><type><name>int</name></type> <name>discard</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>c</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>accum</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>bits</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>cont</name></decl>;</decl_stmt>
<do>do <block>{
<if>if <condition>(<expr>(<name>c</name> = <call><name>fgetc</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>logfp</name></name></expr></argument>)</argument_list></call>) == <name>EOF</name></expr>)</condition><then>
<return>return <expr><name>ERR_EOF</name></expr>;</return></then></if>
<expr_stmt><expr><name>accum</name> |= ((<name>c</name> &amp; 0x7F) &gt;&gt; <name>discard</name>) &lt;&lt; <name>bits</name></expr>;</expr_stmt>
<expr_stmt><expr><name>bits</name> += (7 - <name>discard</name>)</expr>;</expr_stmt>
<expr_stmt><expr><name>cont</name> = <name>c</name> &amp; 0x80</expr>;</expr_stmt>
<expr_stmt><expr><name>discard</name> = 0</expr>;</expr_stmt>
}</block> while <condition>(<expr><name>cont</name></expr>)</condition>;</do>
<expr_stmt><expr>*<name>pvalue</name> = <name>accum</name></expr>;</expr_stmt>
<return>return <expr>0</expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>unpack_string</name><parameter_list>(<param><decl><type><name>LogReaderObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> **</type><name>pvalue</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>len</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>err</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>ch</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>buf</name></decl>;</decl_stmt>
<if>if <condition>(<expr>(<name>err</name> = <call><name>unpack_packed_int</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr>&amp;<name>len</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call>)</expr>)</condition><then>
<return>return <expr><name>err</name></expr>;</return></then></if>
<expr_stmt><expr><name>buf</name> = (<name>char</name> *)<call><name>malloc</name><argument_list>(<argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>buf</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_NoMemory</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>ERR_EXCEPTION</name></expr>;</return>
}</block></then></if>
<for>for (<init><expr><name>i</name>=0</expr>;</init> <condition><expr><name>i</name> &lt; <name>len</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
<expr_stmt><expr><name>ch</name> = <call><name>fgetc</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>logfp</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>buf</name><index>[<expr><name>i</name></expr>]</index></name> = <name>ch</name></expr>;</expr_stmt>
<if>if <condition>(<expr><name>ch</name> == <name>EOF</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>ERR_EOF</name></expr>;</return>
}</block></then></if>
}</block></for>
<expr_stmt><expr>*<name>pvalue</name> = <call><name>PyString_FromStringAndSize</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>*<name>pvalue</name> == <name>NULL</name></expr>)</condition><then> <block>{
<return>return <expr><name>ERR_EXCEPTION</name></expr>;</return>
}</block></then></if>
<return>return <expr>0</expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>unpack_add_info</name><parameter_list>(<param><decl><type><name>LogReaderObject</name> *</type><name>self</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>key</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>value</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>err</name></decl>;</decl_stmt>
<expr_stmt><expr><name>err</name> = <call><name>unpack_string</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr>&amp;<name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>err</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>err</name> = <call><name>unpack_string</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr>&amp;<name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>err</name></expr>)</condition><then>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
<else>else <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>list</name> <init>= <expr><call><name>PyDict_GetItem</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>info</name></name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>list</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>list</name> = <call><name>PyList_New</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>list</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>err</name> = <name>ERR_EXCEPTION</name></expr>;</expr_stmt>
<goto>goto <name>finally</name>;</goto>
}</block></then></if>
<if>if <condition>(<expr><call><name>PyDict_SetItem</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>info</name></name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>err</name> = <name>ERR_EXCEPTION</name></expr>;</expr_stmt>
<goto>goto <name>finally</name>;</goto>
}</block></then></if>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<if>if <condition>(<expr><call><name>PyList_Append</name><argument_list>(<argument><expr><name>list</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<expr_stmt><expr><name>err</name> = <name>ERR_EXCEPTION</name></expr>;</expr_stmt></then></if>
}</block></else></if>
}</block></then></if>
<label><name>finally</name>:</label>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>err</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>eof_error</name><parameter_list>(<param><decl><type><name>LogReaderObject</name> *</type><name>self</name></decl></param>)</parameter_list> <block>{
<expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>logfp</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>self</name>-&gt;<name>logfp</name></name> = <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_EOFError</name></expr></argument>,
<argument><expr>"end of file with incomplete profile record"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>logreader_tp_iternext</name><parameter_list>(<param><decl><type><name>LogReaderObject</name> *</type><name>self</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>c</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>what</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>err</name> <init>= <expr><name>ERR_NONE</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>lineno</name> <init>= <expr>-1</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>fileno</name> <init>= <expr>-1</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>tdelta</name> <init>= <expr>-1</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>s1</name> <init>= <expr><name>NULL</name></expr></init>, *<name>s2</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>result</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>0</expr></cpp:if>
unsigned char b0, b1;
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<if>if <condition>(<expr><name><name>self</name>-&gt;<name>logfp</name></name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>ProfilerError</name></expr></argument>,
<argument><expr>"cannot iterate over closed LogReader object"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<label><name>restart</name>:</label>
<if>if <condition>(<expr>(<name>c</name> = <call><name>fgetc</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>logfp</name></name></expr></argument>)</argument_list></call>) == <name>EOF</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>logfp</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>self</name>-&gt;<name>logfp</name></name> = <name>NULL</name></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>what</name> = <name>c</name> &amp; <name>WHAT_OTHER</name></expr>;</expr_stmt>
<if>if <condition>(<expr><name>what</name> == <name>WHAT_OTHER</name></expr>)</condition><then>
<expr_stmt><expr><name>what</name> = <name>c</name></expr>;</expr_stmt></then>
<else>else
<expr_stmt><expr><call><name>ungetc</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name><name>self</name>-&gt;<name>logfp</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
<switch>switch <condition>(<expr><name>what</name></expr>)</condition> <block>{
<case>case <expr><name>WHAT_ENTER</name></expr>:
<expr_stmt><expr><name>err</name> = <call><name>unpack_packed_int</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr>&amp;<name>fileno</name></expr></argument>, <argument><expr>2</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>err</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>err</name> = <call><name>unpack_packed_int</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr>&amp;<name>lineno</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>self</name>-&gt;<name>frametimings</name></name> &amp;&amp; !<name>err</name></expr>)</condition><then>
<expr_stmt><expr><name>err</name> = <call><name>unpack_packed_int</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr>&amp;<name>tdelta</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
}</block></then></if>
<break>break;</break>
</case><case>case <expr><name>WHAT_EXIT</name></expr>:
<expr_stmt><expr><name>err</name> = <call><name>unpack_packed_int</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr>&amp;<name>tdelta</name></expr></argument>, <argument><expr>2</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr><name>WHAT_LINENO</name></expr>:
<expr_stmt><expr><name>err</name> = <call><name>unpack_packed_int</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr>&amp;<name>lineno</name></expr></argument>, <argument><expr>2</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>self</name>-&gt;<name>linetimings</name></name> &amp;&amp; !<name>err</name></expr>)</condition><then>
<expr_stmt><expr><name>err</name> = <call><name>unpack_packed_int</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr>&amp;<name>tdelta</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<break>break;</break>
</case><case>case <expr><name>WHAT_ADD_INFO</name></expr>:
<expr_stmt><expr><name>err</name> = <call><name>unpack_add_info</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr><name>WHAT_DEFINE_FILE</name></expr>:
<expr_stmt><expr><name>err</name> = <call><name>unpack_packed_int</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr>&amp;<name>fileno</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>err</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>err</name> = <call><name>unpack_string</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr>&amp;<name>s1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>err</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>s2</name> = <name>Py_None</name></expr>;</expr_stmt>
}</block></then></if>
}</block></then></if>
<break>break;</break>
</case><case>case <expr><name>WHAT_DEFINE_FUNC</name></expr>:
<expr_stmt><expr><name>err</name> = <call><name>unpack_packed_int</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr>&amp;<name>fileno</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>err</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>err</name> = <call><name>unpack_packed_int</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr>&amp;<name>lineno</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>err</name></expr>)</condition><then>
<expr_stmt><expr><name>err</name> = <call><name>unpack_string</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr>&amp;<name>s1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
}</block></then></if>
<break>break;</break>
</case><case>case <expr><name>WHAT_LINE_TIMES</name></expr>:
<if>if <condition>(<expr>(<name>c</name> = <call><name>fgetc</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>logfp</name></name></expr></argument>)</argument_list></call>) == <name>EOF</name></expr>)</condition><then>
<expr_stmt><expr><name>err</name> = <name>ERR_EOF</name></expr>;</expr_stmt></then>
<else>else <block>{
<expr_stmt><expr><name><name>self</name>-&gt;<name>linetimings</name></name> = <name>c</name> ? 1 : 0</expr>;</expr_stmt>
<goto>goto <name>restart</name>;</goto>
}</block></else></if>
<break>break;</break>
</case><case>case <expr><name>WHAT_FRAME_TIMES</name></expr>:
<if>if <condition>(<expr>(<name>c</name> = <call><name>fgetc</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>logfp</name></name></expr></argument>)</argument_list></call>) == <name>EOF</name></expr>)</condition><then>
<expr_stmt><expr><name>err</name> = <name>ERR_EOF</name></expr>;</expr_stmt></then>
<else>else <block>{
<expr_stmt><expr><name><name>self</name>-&gt;<name>frametimings</name></name> = <name>c</name> ? 1 : 0</expr>;</expr_stmt>
<goto>goto <name>restart</name>;</goto>
}</block></else></if>
<break>break;</break>
</case><default>default:
<expr_stmt><expr><name>err</name> = <name>ERR_BAD_RECTYPE</name></expr>;</expr_stmt>
</default>}</block></switch>
<if>if <condition>(<expr><name>err</name> == <name>ERR_BAD_RECTYPE</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>,
<argument><expr>"unknown record type in log file"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else <if>if <condition>(<expr><name>err</name> == <name>ERR_EOF</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>eof_error</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else <if>if <condition>(<expr>!<name>err</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>result</name> = <call><name>PyTuple_New</name><argument_list>(<argument><expr>4</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>result</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><call><name>PyTuple_SET_ITEM</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><call><name>PyInt_FromLong</name><argument_list>(<argument><expr><name>what</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyTuple_SET_ITEM</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr>2</expr></argument>, <argument><expr><call><name>PyInt_FromLong</name><argument_list>(<argument><expr><name>fileno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>s1</name> == <name>NULL</name></expr>)</condition><then>
<expr_stmt><expr><call><name>PyTuple_SET_ITEM</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr>1</expr></argument>, <argument><expr><call><name>PyInt_FromLong</name><argument_list>(<argument><expr><name>tdelta</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
<else>else
<expr_stmt><expr><call><name>PyTuple_SET_ITEM</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr>1</expr></argument>, <argument><expr><name>s1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
<if>if <condition>(<expr><name>s2</name> == <name>NULL</name></expr>)</condition><then>
<expr_stmt><expr><call><name>PyTuple_SET_ITEM</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr>3</expr></argument>, <argument><expr><call><name>PyInt_FromLong</name><argument_list>(<argument><expr><name>lineno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
<else>else
<expr_stmt><expr><call><name>PyTuple_SET_ITEM</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr>3</expr></argument>, <argument><expr><name>s2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
}</block></then></if></else></if></else></if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>0</expr></cpp:if>
b0 = self-&gt;buffer[self-&gt;index];
b1 = self-&gt;buffer[self-&gt;index + 1];
if (b0 &amp; 1) {
what = PyTrace_LINE;
lineno = ((b0 &amp; ~1) &lt;&lt; 7) + b1;
self-&gt;index += 2;
} else {
what = (b0 &amp; 0x0E) &gt;&gt; 1;
tdelta = ((b0 &amp; 0xF0) &lt;&lt; 4) + b1;
if (what == PyTrace_CALL) {
fileno = ((self-&gt;buffer[self-&gt;index + 2] &lt;&lt; 8)
+ self-&gt;buffer[self-&gt;index + 3]);
lineno = ((self-&gt;buffer[self-&gt;index + 4] &lt;&lt; 8)
+ self-&gt;buffer[self-&gt;index + 5]);
self-&gt;index += 6;
} else
self-&gt;index += 2;
}
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<return>return <expr><name>result</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>logreader_dealloc</name><parameter_list>(<param><decl><type><name>LogReaderObject</name> *</type><name>self</name></decl></param>)</parameter_list> <block>{
<if>if <condition>(<expr><name><name>self</name>-&gt;<name>logfp</name></name> != <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>logfp</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>self</name>-&gt;<name>logfp</name></name> = <name>NULL</name></expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>info</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyObject_Del</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>logreader_sq_item</name><parameter_list>(<param><decl><type><name>LogReaderObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>index</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>result</name> <init>= <expr><call><name>logreader_tp_iternext</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>result</name> == <name>NULL</name> &amp;&amp; !<call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_IndexError</name></expr></argument>, <argument><expr>"no more events in log"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<return>return <expr><name>result</name></expr>;</return>
}</block></function>
<function_decl><type><specifier>static</specifier> <name>void</name></type>
<name>do_stop</name><parameter_list>(<param><decl><type><name>ProfilerObject</name> *</type><name>self</name></decl></param>)</parameter_list>;</function_decl>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>flush_data</name><parameter_list>(<param><decl><type><name>ProfilerObject</name> *</type><name>self</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>size_t</name></type> <name>written</name> <init>= <expr><call><name>fwrite</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>buffer</name></name></expr></argument>, <argument><expr>1</expr></argument>, <argument><expr><name><name>self</name>-&gt;<name>index</name></name></expr></argument>, <argument><expr><name><name>self</name>-&gt;<name>logfp</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>written</name> == (<name>size_t</name>)<name><name>self</name>-&gt;<name>index</name></name></expr>)</condition><then>
<expr_stmt><expr><name><name>self</name>-&gt;<name>index</name></name> = 0</expr>;</expr_stmt></then>
<else>else <block>{
<expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>buffer</name></name></expr></argument>, <argument><expr>&amp;<name><name>self</name>-&gt;<name>buffer</name><index>[<expr><name>written</name></expr>]</index></name></expr></argument>,
<argument><expr><name><name>self</name>-&gt;<name>index</name></name> - <name>written</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>self</name>-&gt;<name>index</name></name> -= <name>written</name></expr>;</expr_stmt>
<if>if <condition>(<expr><name>written</name> == 0</expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>char</name> *</type><name>s</name> <init>= <expr><call><name>PyString_AsString</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>logfilename</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>PyErr_SetFromErrnoWithFilename</name><argument_list>(<argument><expr><name>PyExc_IOError</name></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>do_stop</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>-1</expr>;</return>
}</block></then></if>
}</block></else></if>
<if>if <condition>(<expr><name>written</name> &gt; 0</expr>)</condition><then> <block>{
<if>if <condition>(<expr><call><name>fflush</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>logfp</name></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>char</name> *</type><name>s</name> <init>= <expr><call><name>PyString_AsString</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>logfilename</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>PyErr_SetFromErrnoWithFilename</name><argument_list>(<argument><expr><name>PyExc_IOError</name></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>do_stop</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>-1</expr>;</return>
}</block></then></if>
}</block></then></if>
<return>return <expr>0</expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>int</name></type>
<name>pack_packed_int</name><parameter_list>(<param><decl><type><name>ProfilerObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>int</name></type> <name>value</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name>partial</name></decl>;</decl_stmt>
<do>do <block>{
<expr_stmt><expr><name>partial</name> = <name>value</name> &amp; 0x7F</expr>;</expr_stmt>
<expr_stmt><expr><name>value</name> &gt;&gt;= 7</expr>;</expr_stmt>
<if>if <condition>(<expr><name>value</name></expr>)</condition><then>
<expr_stmt><expr><name>partial</name> |= 0x80</expr>;</expr_stmt></then></if>
<expr_stmt><expr><name><name>self</name>-&gt;<name>buffer</name><index>[<expr><name><name>self</name>-&gt;<name>index</name></name></expr>]</index></name> = <name>partial</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>self</name>-&gt;<name>index</name></name>++</expr>;</expr_stmt>
}</block> while <condition>(<expr><name>value</name></expr>)</condition>;</do>
<return>return <expr>0</expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>int</name></type>
<name>pack_modified_packed_int</name><parameter_list>(<param><decl><type><name>ProfilerObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>int</name></type> <name>value</name></decl></param>,
<param><decl><type><name>int</name></type> <name>modsize</name></decl></param>, <param><decl><type><name>int</name></type> <name>subfield</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name><name>maxvalues</name><index>[]</index></name> <init>= <expr><block>{<expr>-1</expr>, <expr>1</expr>, <expr>3</expr>, <expr>7</expr>, <expr>15</expr>, <expr>31</expr>, <expr>63</expr>, <expr>127</expr>}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>bits</name> <init>= <expr>7 - <name>modsize</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>partial</name> <init>= <expr><name>value</name> &amp; <name><name>maxvalues</name><index>[<expr><name>bits</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name>b</name> <init>= <expr><name>subfield</name> | (<name>partial</name> &lt;&lt; <name>modsize</name>)</expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>partial</name> != <name>value</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>b</name> |= 0x80</expr>;</expr_stmt>
<expr_stmt><expr><name><name>self</name>-&gt;<name>buffer</name><index>[<expr><name><name>self</name>-&gt;<name>index</name></name></expr>]</index></name> = <name>b</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>self</name>-&gt;<name>index</name></name>++</expr>;</expr_stmt>
<return>return <expr><call><name>pack_packed_int</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>value</name> &gt;&gt; <name>bits</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name><name>self</name>-&gt;<name>buffer</name><index>[<expr><name><name>self</name>-&gt;<name>index</name></name></expr>]</index></name> = <name>b</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>self</name>-&gt;<name>index</name></name>++</expr>;</expr_stmt>
<return>return <expr>0</expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>pack_string</name><parameter_list>(<param><decl><type><name>ProfilerObject</name> *</type><name>self</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>s</name></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>len</name></decl></param>)</parameter_list> <block>{
<if>if <condition>(<expr><name>len</name> + <name>PISIZE</name> + <name><name>self</name>-&gt;<name>index</name></name> &gt;= <name>BUFFERSIZE</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr><call><name>flush_data</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
<return>return <expr>-1</expr>;</return></then></if>
}</block></then></if>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>len</name> &lt; <name>INT_MAX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>pack_packed_int</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr>(<name>int</name>)<name>len</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
<return>return <expr>-1</expr>;</return></then></if>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>buffer</name></name> + <name><name>self</name>-&gt;<name>index</name></name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>self</name>-&gt;<name>index</name></name> += <name>len</name></expr>;</expr_stmt>
<return>return <expr>0</expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>pack_add_info</name><parameter_list>(<param><decl><type><name>ProfilerObject</name> *</type><name>self</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>s1</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>s2</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>len1</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name>s1</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>len2</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name>s2</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>len1</name> + <name>len2</name> + <name>PISIZE</name>*2 + 1 + <name><name>self</name>-&gt;<name>index</name></name> &gt;= <name>BUFFERSIZE</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr><call><name>flush_data</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
<return>return <expr>-1</expr>;</return></then></if>
}</block></then></if>
<expr_stmt><expr><name><name>self</name>-&gt;<name>buffer</name><index>[<expr><name><name>self</name>-&gt;<name>index</name></name></expr>]</index></name> = <name>WHAT_ADD_INFO</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>self</name>-&gt;<name>index</name></name>++</expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>pack_string</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>s1</name></expr></argument>, <argument><expr><name>len1</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
<return>return <expr>-1</expr>;</return></then></if>
<return>return <expr><call><name>pack_string</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>s2</name></expr></argument>, <argument><expr><name>len2</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>pack_define_file</name><parameter_list>(<param><decl><type><name>ProfilerObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>int</name></type> <name>fileno</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>filename</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>len</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>len</name> + <name>PISIZE</name>*2 + 1 + <name><name>self</name>-&gt;<name>index</name></name> &gt;= <name>BUFFERSIZE</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr><call><name>flush_data</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
<return>return <expr>-1</expr>;</return></then></if>
}</block></then></if>
<expr_stmt><expr><name><name>self</name>-&gt;<name>buffer</name><index>[<expr><name><name>self</name>-&gt;<name>index</name></name></expr>]</index></name> = <name>WHAT_DEFINE_FILE</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>self</name>-&gt;<name>index</name></name>++</expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>pack_packed_int</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>fileno</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
<return>return <expr>-1</expr>;</return></then></if>
<return>return <expr><call><name>pack_string</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>filename</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>pack_define_func</name><parameter_list>(<param><decl><type><name>ProfilerObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>int</name></type> <name>fileno</name></decl></param>, <param><decl><type><name>int</name></type> <name>lineno</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>funcname</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>len</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name>funcname</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>len</name> + <name>PISIZE</name>*3 + 1 + <name><name>self</name>-&gt;<name>index</name></name> &gt;= <name>BUFFERSIZE</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr><call><name>flush_data</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
<return>return <expr>-1</expr>;</return></then></if>
}</block></then></if>
<expr_stmt><expr><name><name>self</name>-&gt;<name>buffer</name><index>[<expr><name><name>self</name>-&gt;<name>index</name></name></expr>]</index></name> = <name>WHAT_DEFINE_FUNC</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>self</name>-&gt;<name>index</name></name>++</expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>pack_packed_int</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>fileno</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
<return>return <expr>-1</expr>;</return></then></if>
<if>if <condition>(<expr><call><name>pack_packed_int</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>lineno</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
<return>return <expr>-1</expr>;</return></then></if>
<return>return <expr><call><name>pack_string</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>funcname</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>pack_line_times</name><parameter_list>(<param><decl><type><name>ProfilerObject</name> *</type><name>self</name></decl></param>)</parameter_list> <block>{
<if>if <condition>(<expr>2 + <name><name>self</name>-&gt;<name>index</name></name> &gt;= <name>BUFFERSIZE</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr><call><name>flush_data</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
<return>return <expr>-1</expr>;</return></then></if>
}</block></then></if>
<expr_stmt><expr><name><name>self</name>-&gt;<name>buffer</name><index>[<expr><name><name>self</name>-&gt;<name>index</name></name></expr>]</index></name> = <name>WHAT_LINE_TIMES</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>self</name>-&gt;<name>buffer</name><index>[<expr><name><name>self</name>-&gt;<name>index</name></name> + 1</expr>]</index></name> = <name><name>self</name>-&gt;<name>linetimings</name></name> ? 1 : 0</expr>;</expr_stmt>
<expr_stmt><expr><name><name>self</name>-&gt;<name>index</name></name> += 2</expr>;</expr_stmt>
<return>return <expr>0</expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>pack_frame_times</name><parameter_list>(<param><decl><type><name>ProfilerObject</name> *</type><name>self</name></decl></param>)</parameter_list> <block>{
<if>if <condition>(<expr>2 + <name><name>self</name>-&gt;<name>index</name></name> &gt;= <name>BUFFERSIZE</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr><call><name>flush_data</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
<return>return <expr>-1</expr>;</return></then></if>
}</block></then></if>
<expr_stmt><expr><name><name>self</name>-&gt;<name>buffer</name><index>[<expr><name><name>self</name>-&gt;<name>index</name></name></expr>]</index></name> = <name>WHAT_FRAME_TIMES</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>self</name>-&gt;<name>buffer</name><index>[<expr><name><name>self</name>-&gt;<name>index</name></name> + 1</expr>]</index></name> = <name><name>self</name>-&gt;<name>frametimings</name></name> ? 1 : 0</expr>;</expr_stmt>
<expr_stmt><expr><name><name>self</name>-&gt;<name>index</name></name> += 2</expr>;</expr_stmt>
<return>return <expr>0</expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>int</name></type>
<name>pack_enter</name><parameter_list>(<param><decl><type><name>ProfilerObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>int</name></type> <name>fileno</name></decl></param>, <param><decl><type><name>int</name></type> <name>tdelta</name></decl></param>, <param><decl><type><name>int</name></type> <name>lineno</name></decl></param>)</parameter_list> <block>{
<if>if <condition>(<expr><name>MPISIZE</name> + <name>PISIZE</name>*2 + <name><name>self</name>-&gt;<name>index</name></name> &gt;= <name>BUFFERSIZE</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr><call><name>flush_data</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
<return>return <expr>-1</expr>;</return></then></if>
}</block></then></if>
<expr_stmt><expr><call><name>pack_modified_packed_int</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>fileno</name></expr></argument>, <argument><expr>2</expr></argument>, <argument><expr><name>WHAT_ENTER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>pack_packed_int</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>lineno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>self</name>-&gt;<name>frametimings</name></name></expr>)</condition><then>
<return>return <expr><call><name>pack_packed_int</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>tdelta</name></expr></argument>)</argument_list></call></expr>;</return></then>
<else>else
<return>return <expr>0</expr>;</return></else></if>
}</block></function>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>int</name></type>
<name>pack_exit</name><parameter_list>(<param><decl><type><name>ProfilerObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>int</name></type> <name>tdelta</name></decl></param>)</parameter_list> <block>{
<if>if <condition>(<expr><name>MPISIZE</name> + <name><name>self</name>-&gt;<name>index</name></name> &gt;= <name>BUFFERSIZE</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr><call><name>flush_data</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
<return>return <expr>-1</expr>;</return></then></if>
}</block></then></if>
<if>if <condition>(<expr><name><name>self</name>-&gt;<name>frametimings</name></name></expr>)</condition><then>
<return>return <expr><call><name>pack_modified_packed_int</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>tdelta</name></expr></argument>, <argument><expr>2</expr></argument>, <argument><expr><name>WHAT_EXIT</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
<expr_stmt><expr><name><name>self</name>-&gt;<name>buffer</name><index>[<expr><name><name>self</name>-&gt;<name>index</name></name></expr>]</index></name> = <name>WHAT_EXIT</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>self</name>-&gt;<name>index</name></name>++</expr>;</expr_stmt>
<return>return <expr>0</expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>int</name></type>
<name>pack_lineno</name><parameter_list>(<param><decl><type><name>ProfilerObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>int</name></type> <name>lineno</name></decl></param>)</parameter_list> <block>{
<if>if <condition>(<expr><name>MPISIZE</name> + <name><name>self</name>-&gt;<name>index</name></name> &gt;= <name>BUFFERSIZE</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr><call><name>flush_data</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
<return>return <expr>-1</expr>;</return></then></if>
}</block></then></if>
<return>return <expr><call><name>pack_modified_packed_int</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>lineno</name></expr></argument>, <argument><expr>2</expr></argument>, <argument><expr><name>WHAT_LINENO</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>int</name></type>
<name>pack_lineno_tdelta</name><parameter_list>(<param><decl><type><name>ProfilerObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>int</name></type> <name>lineno</name></decl></param>, <param><decl><type><name>int</name></type> <name>tdelta</name></decl></param>)</parameter_list> <block>{
<if>if <condition>(<expr><name>MPISIZE</name> + <name>PISIZE</name> + <name><name>self</name>-&gt;<name>index</name></name> &gt;= <name>BUFFERSIZE</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr><call><name>flush_data</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
<return>return <expr>0</expr>;</return></then></if>
}</block></then></if>
<if>if <condition>(<expr><call><name>pack_modified_packed_int</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>lineno</name></expr></argument>, <argument><expr>2</expr></argument>, <argument><expr><name>WHAT_LINENO</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
<return>return <expr>-1</expr>;</return></then></if>
<return>return <expr><call><name>pack_packed_int</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>tdelta</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>int</name></type>
<name>get_fileno</name><parameter_list>(<param><decl><type><name>ProfilerObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyCodeObject</name> *</type><name>fcode</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>obj</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>dict</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>fileno</name></decl>;</decl_stmt>
<expr_stmt><expr><name>obj</name> = <call><name>PyDict_GetItem</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>filemap</name></name></expr></argument>, <argument><expr><name><name>fcode</name>-&gt;<name>co_filename</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>obj</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>dict</name> = <call><name>PyDict_New</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>dict</name> == <name>NULL</name></expr>)</condition><then> <block>{
<return>return <expr>-1</expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>fileno</name> = <name><name>self</name>-&gt;<name>next_fileno</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>obj</name> = <call><name>Py_BuildValue</name><argument_list>(<argument><expr>"iN"</expr></argument>, <argument><expr><name>fileno</name></expr></argument>, <argument><expr><name>dict</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>obj</name> == <name>NULL</name></expr>)</condition><then> <block>{
<return>return <expr>-1</expr>;</return>
}</block></then></if>
<if>if <condition>(<expr><call><name>PyDict_SetItem</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>filemap</name></name></expr></argument>, <argument><expr><name><name>fcode</name>-&gt;<name>co_filename</name></name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>-1</expr>;</return>
}</block></then></if>
<expr_stmt><expr><name><name>self</name>-&gt;<name>next_fileno</name></name>++</expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>pack_define_file</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>fileno</name></expr></argument>,
<argument><expr><call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name><name>fcode</name>-&gt;<name>co_filename</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
<return>return <expr>-1</expr>;</return></then></if>
}</block></then> <else>else <block>{
<expr_stmt><expr><name>fileno</name> = <call><name>PyInt_AS_LONG</name><argument_list>(<argument><expr><call><name>PyTuple_GET_ITEM</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>dict</name> = <call><name>PyTuple_GET_ITEM</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></else></if>
<expr_stmt><expr><name>obj</name> = <call><name>PyInt_FromLong</name><argument_list>(<argument><expr><name><name>fcode</name>-&gt;<name>co_firstlineno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>obj</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_Clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>name</name> <init>= <expr><call><name>PyDict_GetItem</name><argument_list>(<argument><expr><name>dict</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>name</name> == <name>NULL</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr><call><name>pack_define_func</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>fileno</name></expr></argument>, <argument><expr><name><name>fcode</name>-&gt;<name>co_firstlineno</name></name></expr></argument>,
<argument><expr><call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name><name>fcode</name>-&gt;<name>co_name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>-1</expr>;</return>
}</block></then></if>
<if>if <condition>(<expr><call><name>PyDict_SetItem</name><argument_list>(<argument><expr><name>dict</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>, <argument><expr><name><name>fcode</name>-&gt;<name>co_name</name></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>-1</expr>;</return>
}</block></then></if>
}</block></then></if>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></else></if>
<return>return <expr><name>fileno</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>int</name></type>
<name>get_tdelta</name><parameter_list>(<param><decl><type><name>ProfilerObject</name> *</type><name>self</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>tdelta</name></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MS_WINDOWS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>hs_time</name></type> <name>tv</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>hs_time</name></type> <name>diff</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>GETTIMEOFDAY</name><argument_list>(<argument><expr>&amp;<name>tv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>diff</name> = <name>tv</name> - <name><name>self</name>-&gt;<name>prev_timeofday</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>tdelta</name> = (<name>int</name>)<name>diff</name></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<decl_stmt><decl><type>struct <name>timeval</name></type> <name>tv</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>GETTIMEOFDAY</name><argument_list>(<argument><expr>&amp;<name>tv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>tdelta</name> = <name><name>tv</name>.<name>tv_usec</name></name> - <name><name>self</name>-&gt;<name>prev_timeofday</name>.<name>tv_usec</name></name></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>tv</name>.<name>tv_sec</name></name> != <name><name>self</name>-&gt;<name>prev_timeofday</name>.<name>tv_sec</name></name></expr>)</condition><then>
<expr_stmt><expr><name>tdelta</name> += (<name><name>tv</name>.<name>tv_sec</name></name> - <name><name>self</name>-&gt;<name>prev_timeofday</name>.<name>tv_sec</name></name>) * 1000000</expr>;</expr_stmt></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<if>if <condition>(<expr><name>tdelta</name> &lt; 0</expr>)</condition><then>
<return>return <expr>0</expr>;</return></then></if>
<expr_stmt><expr><name><name>self</name>-&gt;<name>prev_timeofday</name></name> = <name>tv</name></expr>;</expr_stmt>
<return>return <expr><name>tdelta</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>tracer_callback</name><parameter_list>(<param><decl><type><name>ProfilerObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyFrameObject</name> *</type><name>frame</name></decl></param>, <param><decl><type><name>int</name></type> <name>what</name></decl></param>,
<param><decl><type><name>PyObject</name> *</type><name>arg</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>fileno</name></decl>;</decl_stmt>
<switch>switch <condition>(<expr><name>what</name></expr>)</condition> <block>{
<case>case <expr><name>PyTrace_CALL</name></expr>:
<expr_stmt><expr><name>fileno</name> = <call><name>get_fileno</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name><name>frame</name>-&gt;<name>f_code</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>fileno</name> &lt; 0</expr>)</condition><then>
<return>return <expr>-1</expr>;</return></then></if>
<return>return <expr><call><name>pack_enter</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>fileno</name></expr></argument>,
<argument><expr><name><name>self</name>-&gt;<name>frametimings</name></name> ? <call><name>get_tdelta</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call> : -1</expr></argument>,
<argument><expr><name><name>frame</name>-&gt;<name>f_code</name>-&gt;<name>co_firstlineno</name></name></expr></argument>)</argument_list></call></expr>;</return>
</case><case>case <expr><name>PyTrace_RETURN</name></expr>:
<return>return <expr><call><name>pack_exit</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><call><name>get_tdelta</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</case><case>case <expr><name>PyTrace_LINE</name></expr>:
<if>if <condition>(<expr><name><name>self</name>-&gt;<name>linetimings</name></name></expr>)</condition><then>
<return>return <expr><call><name>pack_lineno_tdelta</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name><name>frame</name>-&gt;<name>f_lineno</name></name></expr></argument>,
<argument><expr><call><name>get_tdelta</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></then>
<else>else
<return>return <expr><call><name>pack_lineno</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name><name>frame</name>-&gt;<name>f_lineno</name></name></expr></argument>)</argument_list></call></expr>;</return></else></if>
</case><default>default:
<break>break;</break>
</default>}</block></switch>
<return>return <expr>0</expr>;</return>
}</block></function>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MS_WINDOWS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><specifier>static</specifier> <name>LARGE_INTEGER</name></type> <name>frequency</name> <init>= <expr><block>{<expr>0</expr>, <expr>0</expr>}</block></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<decl_stmt><decl><type><specifier>static</specifier> <name>unsigned</name> <name>long</name></type> <name>timeofday_diff</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>unsigned</name> <name>long</name></type> <name>rusage_diff</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>calibrate</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>hs_time</name></type> <name>tv1</name></decl>, <decl><type ref="prev"/><name>tv2</name></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MS_WINDOWS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>hs_time</name></type> <name>diff</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>QueryPerformanceFrequency</name><argument_list>(<argument><expr>&amp;<name>frequency</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><call><name>GETTIMEOFDAY</name><argument_list>(<argument><expr>&amp;<name>tv1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<while>while <condition>(<expr>1</expr>)</condition> <block>{
<expr_stmt><expr><call><name>GETTIMEOFDAY</name><argument_list>(<argument><expr>&amp;<name>tv2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MS_WINDOWS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><name>diff</name> = <name>tv2</name> - <name>tv1</name></expr>;</expr_stmt>
<if>if <condition>(<expr><name>diff</name> != 0</expr>)</condition><then> <block>{
<expr_stmt><expr><name>timeofday_diff</name> = (<name>unsigned</name> <name>long</name>)<name>diff</name></expr>;</expr_stmt>
<break>break;</break>
}</block></then></if>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<if>if <condition>(<expr><name><name>tv1</name>.<name>tv_sec</name></name> != <name><name>tv2</name>.<name>tv_sec</name></name> || <name><name>tv1</name>.<name>tv_usec</name></name> != <name><name>tv2</name>.<name>tv_usec</name></name></expr>)</condition><then> <block>{
<if>if <condition>(<expr><name><name>tv1</name>.<name>tv_sec</name></name> == <name><name>tv2</name>.<name>tv_sec</name></name></expr>)</condition><then>
<expr_stmt><expr><name>timeofday_diff</name> = <name><name>tv2</name>.<name>tv_usec</name></name> - <name><name>tv1</name>.<name>tv_usec</name></name></expr>;</expr_stmt></then>
<else>else
<expr_stmt><expr><name>timeofday_diff</name> = (1000000 - <name><name>tv1</name>.<name>tv_usec</name></name>) + <name><name>tv2</name>.<name>tv_usec</name></name></expr>;</expr_stmt></else></if>
<break>break;</break>
}</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></while>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MS_WINDOWS</name></expr></argument>)</argument_list></call> || <call><name>defined</name><argument_list>(<argument><expr><name>PYOS_OS2</name></expr></argument>)</argument_list></call> || <call><name>defined</name><argument_list>(<argument><expr><name>__VMS</name></expr></argument>)</argument_list></call> || <call><name>defined</name> <argument_list>(<argument><expr><name>__QNX__</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><name>rusage_diff</name> = -1</expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<block>{
<decl_stmt><decl><type>struct <name>rusage</name></type> <name>ru1</name></decl>, <decl><type ref="prev"/><name>ru2</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>getrusage</name><argument_list>(<argument><expr><name>RUSAGE_SELF</name></expr></argument>, <argument><expr>&amp;<name>ru1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<while>while <condition>(<expr>1</expr>)</condition> <block>{
<expr_stmt><expr><call><name>getrusage</name><argument_list>(<argument><expr><name>RUSAGE_SELF</name></expr></argument>, <argument><expr>&amp;<name>ru2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>ru1</name>.<name>ru_utime</name>.<name>tv_sec</name></name> != <name><name>ru2</name>.<name>ru_utime</name>.<name>tv_sec</name></name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>rusage_diff</name> = ((1000000 - <name><name>ru1</name>.<name>ru_utime</name>.<name>tv_usec</name></name>)
+ <name><name>ru2</name>.<name>ru_utime</name>.<name>tv_usec</name></name>)</expr>;</expr_stmt>
<break>break;</break>
}</block></then> <else>else <if>if <condition>(<expr><name><name>ru1</name>.<name>ru_utime</name>.<name>tv_usec</name></name> != <name><name>ru2</name>.<name>ru_utime</name>.<name>tv_usec</name></name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>rusage_diff</name> = <name><name>ru2</name>.<name>ru_utime</name>.<name>tv_usec</name></name> - <name><name>ru1</name>.<name>ru_utime</name>.<name>tv_usec</name></name></expr>;</expr_stmt>
<break>break;</break>
}</block></then> <else>else <if>if <condition>(<expr><name><name>ru1</name>.<name>ru_stime</name>.<name>tv_sec</name></name> != <name><name>ru2</name>.<name>ru_stime</name>.<name>tv_sec</name></name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>rusage_diff</name> = ((1000000 - <name><name>ru1</name>.<name>ru_stime</name>.<name>tv_usec</name></name>)
+ <name><name>ru2</name>.<name>ru_stime</name>.<name>tv_usec</name></name>)</expr>;</expr_stmt>
<break>break;</break>
}</block></then> <else>else <if>if <condition>(<expr><name><name>ru1</name>.<name>ru_stime</name>.<name>tv_usec</name></name> != <name><name>ru2</name>.<name>ru_stime</name>.<name>tv_usec</name></name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>rusage_diff</name> = <name><name>ru2</name>.<name>ru_stime</name>.<name>tv_usec</name></name> - <name><name>ru1</name>.<name>ru_stime</name>.<name>tv_usec</name></name></expr>;</expr_stmt>
<break>break;</break>
}</block></then></if></else></if></else></if></else></if>
}</block></while>
}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>do_start</name><parameter_list>(<param><decl><type><name>ProfilerObject</name> *</type><name>self</name></decl></param>)</parameter_list> <block>{
<expr_stmt><expr><name><name>self</name>-&gt;<name>active</name></name> = 1</expr>;</expr_stmt>
<expr_stmt><expr><call><name>GETTIMEOFDAY</name><argument_list>(<argument><expr>&amp;<name><name>self</name>-&gt;<name>prev_timeofday</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>self</name>-&gt;<name>lineevents</name></name></expr>)</condition><then>
<expr_stmt><expr><call><name>PyEval_SetTrace</name><argument_list>(<argument><expr>(<name>Py_tracefunc</name>) <name>tracer_callback</name></expr></argument>, <argument><expr>(<name>PyObject</name> *)<name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
<else>else
<expr_stmt><expr><call><name>PyEval_SetProfile</name><argument_list>(<argument><expr>(<name>Py_tracefunc</name>) <name>tracer_callback</name></expr></argument>, <argument><expr>(<name>PyObject</name> *)<name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>do_stop</name><parameter_list>(<param><decl><type><name>ProfilerObject</name> *</type><name>self</name></decl></param>)</parameter_list> <block>{
<if>if <condition>(<expr><name><name>self</name>-&gt;<name>active</name></name></expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>self</name>-&gt;<name>active</name></name> = 0</expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>self</name>-&gt;<name>lineevents</name></name></expr>)</condition><then>
<expr_stmt><expr><call><name>PyEval_SetTrace</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
<else>else
<expr_stmt><expr><call><name>PyEval_SetProfile</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
}</block></then></if>
<if>if <condition>(<expr><name><name>self</name>-&gt;<name>index</name></name> &gt; 0</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>flush_data</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>is_available</name><parameter_list>(<param><decl><type><name>ProfilerObject</name> *</type><name>self</name></decl></param>)</parameter_list> <block>{
<if>if <condition>(<expr><name><name>self</name>-&gt;<name>active</name></name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>ProfilerError</name></expr></argument>, <argument><expr>"profiler already active"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>0</expr>;</return>
}</block></then></if>
<if>if <condition>(<expr><name><name>self</name>-&gt;<name>logfp</name></name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>ProfilerError</name></expr></argument>, <argument><expr>"profiler already closed"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>0</expr>;</return>
}</block></then></if>
<return>return <expr>1</expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>addinfo__doc__</name></expr></argument>,
<argument><expr>"addinfo(key, value)\n"
"Insert an ADD_INFO record into the log."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>profiler_addinfo</name><parameter_list>(<param><decl><type><name>ProfilerObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>result</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>key</name></decl>, *<decl><type ref="prev"/><name>value</name></decl>;</decl_stmt>
<if>if <condition>(<expr><call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"ss:addinfo"</expr></argument>, <argument><expr>&amp;<name>key</name></expr></argument>, <argument><expr>&amp;<name>value</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<if>if <condition>(<expr><name><name>self</name>-&gt;<name>logfp</name></name> == <name>NULL</name></expr>)</condition><then>
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>ProfilerError</name></expr></argument>, <argument><expr>"profiler already closed"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
<else>else <block>{
<if>if <condition>(<expr><call><name>pack_add_info</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call> == 0</expr>)</condition><then> <block>{
<expr_stmt><expr><name>result</name> = <name>Py_None</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
}</block></else></if>
}</block></then></if>
<return>return <expr><name>result</name></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>close__doc__</name></expr></argument>,
<argument><expr>"close()\n"
"Shut down this profiler and close the log files, even if its active."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>profiler_close</name><parameter_list>(<param><decl><type><name>ProfilerObject</name> *</type><name>self</name></decl></param>)</parameter_list> <block>{
<expr_stmt><expr><call><name>do_stop</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>self</name>-&gt;<name>logfp</name></name> != <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>logfp</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>self</name>-&gt;<name>logfp</name></name> = <name>NULL</name></expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>Py_None</name></expr>;</return>
}</block></function>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>fileno__doc__</name></cpp:macro> <cpp:value>logreader_fileno__doc__</cpp:value></cpp:define>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>profiler_fileno</name><parameter_list>(<param><decl><type><name>ProfilerObject</name> *</type><name>self</name></decl></param>)</parameter_list> <block>{
<if>if <condition>(<expr><name><name>self</name>-&gt;<name>logfp</name></name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>,
<argument><expr>"profiler's file object already closed"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<return>return <expr><call><name>PyInt_FromLong</name><argument_list>(<argument><expr><call><name>fileno</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>logfp</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>runcall__doc__</name></expr></argument>,
<argument><expr>"runcall(callable[, args[, kw]]) -&gt; callable()\n"
"Profile a specific function call, returning the result of that call."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>profiler_runcall</name><parameter_list>(<param><decl><type><name>ProfilerObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>result</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>callargs</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>callkw</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>callable</name></decl>;</decl_stmt>
<if>if <condition>(<expr><call><name>PyArg_UnpackTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"runcall"</expr></argument>, <argument><expr>1</expr></argument>, <argument><expr>3</expr></argument>,
<argument><expr>&amp;<name>callable</name></expr></argument>, <argument><expr>&amp;<name>callargs</name></expr></argument>, <argument><expr>&amp;<name>callkw</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<if>if <condition>(<expr><call><name>is_available</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>do_start</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>result</name> = <call><name>PyEval_CallObjectWithKeywords</name><argument_list>(<argument><expr><name>callable</name></expr></argument>, <argument><expr><name>callargs</name></expr></argument>, <argument><expr><name>callkw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>do_stop</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
}</block></then></if>
<return>return <expr><name>result</name></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>runcode__doc__</name></expr></argument>,
<argument><expr>"runcode(code, globals[, locals])\n"
"Execute a code object while collecting profile data. If locals is\n"
"omitted, globals is used for the locals as well."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>profiler_runcode</name><parameter_list>(<param><decl><type><name>ProfilerObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>result</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyCodeObject</name> *</type><name>code</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>globals</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>locals</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"O!O!|O:runcode"</expr></argument>,
<argument><expr>&amp;<name>PyCode_Type</name></expr></argument>, <argument><expr>&amp;<name>code</name></expr></argument>,
<argument><expr>&amp;<name>PyDict_Type</name></expr></argument>, <argument><expr>&amp;<name>globals</name></expr></argument>,
<argument><expr>&amp;<name>locals</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<if>if <condition>(<expr><call><name>is_available</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<if>if <condition>(<expr><name>locals</name> == <name>NULL</name> || <name>locals</name> == <name>Py_None</name></expr>)</condition><then>
<expr_stmt><expr><name>locals</name> = <name>globals</name></expr>;</expr_stmt></then>
<else>else <if>if <condition>(<expr>!<call><name>PyDict_Check</name><argument_list>(<argument><expr><name>locals</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
<argument><expr>"locals must be a dictionary or None"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if></else></if>
<expr_stmt><expr><call><name>do_start</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>result</name> = <call><name>PyEval_EvalCode</name><argument_list>(<argument><expr><name>code</name></expr></argument>, <argument><expr><name>globals</name></expr></argument>, <argument><expr><name>locals</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>do_stop</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>0</expr></cpp:if>
if (!PyErr_Occurred()) {
result = Py_None;
Py_INCREF(result);
}
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></then></if>
}</block></then></if>
<return>return <expr><name>result</name></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>start__doc__</name></expr></argument>,
<argument><expr>"start()\n"
"Install this profiler for the current thread."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>profiler_start</name><parameter_list>(<param><decl><type><name>ProfilerObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>result</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><call><name>is_available</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>do_start</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>result</name> = <name>Py_None</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<return>return <expr><name>result</name></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>stop__doc__</name></expr></argument>,
<argument><expr>"stop()\n"
"Remove this profiler from the current thread."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>profiler_stop</name><parameter_list>(<param><decl><type><name>ProfilerObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>result</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr>!<name><name>self</name>-&gt;<name>active</name></name></expr>)</condition><then>
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>ProfilerError</name></expr></argument>, <argument><expr>"profiler not active"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
<else>else <block>{
<expr_stmt><expr><call><name>do_stop</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>result</name> = <name>Py_None</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></else></if>
<return>return <expr><name>result</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>profiler_dealloc</name><parameter_list>(<param><decl><type><name>ProfilerObject</name> *</type><name>self</name></decl></param>)</parameter_list> <block>{
<expr_stmt><expr><call><name>do_stop</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>self</name>-&gt;<name>logfp</name></name> != <name>NULL</name></expr>)</condition><then>
<expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>logfp</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>filemap</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>logfilename</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyObject_Del</name><argument_list>(<argument><expr>(<name>PyObject</name> *)<name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>
<decl_stmt><decl><type><specifier>static</specifier> <name>PyMethodDef</name></type> <name><name>profiler_methods</name><index>[]</index></name> <init>= <expr><block>{
<expr><block>{<expr>"addinfo"</expr>, <expr>(<name>PyCFunction</name>)<name>profiler_addinfo</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>addinfo__doc__</name></expr>}</block></expr>,
<expr><block>{<expr>"close"</expr>, <expr>(<name>PyCFunction</name>)<name>profiler_close</name></expr>, <expr><name>METH_NOARGS</name></expr>, <expr><name>close__doc__</name></expr>}</block></expr>,
<expr><block>{<expr>"fileno"</expr>, <expr>(<name>PyCFunction</name>)<name>profiler_fileno</name></expr>, <expr><name>METH_NOARGS</name></expr>, <expr><name>fileno__doc__</name></expr>}</block></expr>,
<expr><block>{<expr>"runcall"</expr>, <expr>(<name>PyCFunction</name>)<name>profiler_runcall</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>runcall__doc__</name></expr>}</block></expr>,
<expr><block>{<expr>"runcode"</expr>, <expr>(<name>PyCFunction</name>)<name>profiler_runcode</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>runcode__doc__</name></expr>}</block></expr>,
<expr><block>{<expr>"start"</expr>, <expr>(<name>PyCFunction</name>)<name>profiler_start</name></expr>, <expr><name>METH_NOARGS</name></expr>, <expr><name>start__doc__</name></expr>}</block></expr>,
<expr><block>{<expr>"stop"</expr>, <expr>(<name>PyCFunction</name>)<name>profiler_stop</name></expr>, <expr><name>METH_NOARGS</name></expr>, <expr><name>stop__doc__</name></expr>}</block></expr>,
<expr><block>{<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>}</block></expr>
}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>PyMemberDef</name></type> <name><name>profiler_members</name><index>[]</index></name> <init>= <expr><block>{
<expr><block>{<expr>"frametimings"</expr>, <expr><name>T_LONG</name></expr>, <expr><call><name>offsetof</name><argument_list>(<argument><expr><name>ProfilerObject</name></expr></argument>, <argument><expr><name>linetimings</name></expr></argument>)</argument_list></call></expr>, <expr><name>READONLY</name></expr>}</block></expr>,
<expr><block>{<expr>"lineevents"</expr>, <expr><name>T_LONG</name></expr>, <expr><call><name>offsetof</name><argument_list>(<argument><expr><name>ProfilerObject</name></expr></argument>, <argument><expr><name>lineevents</name></expr></argument>)</argument_list></call></expr>, <expr><name>READONLY</name></expr>}</block></expr>,
<expr><block>{<expr>"linetimings"</expr>, <expr><name>T_LONG</name></expr>, <expr><call><name>offsetof</name><argument_list>(<argument><expr><name>ProfilerObject</name></expr></argument>, <argument><expr><name>linetimings</name></expr></argument>)</argument_list></call></expr>, <expr><name>READONLY</name></expr>}</block></expr>,
<expr><block>{<expr><name>NULL</name></expr>}</block></expr>
}</block></expr></init></decl>;</decl_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>profiler_get_closed</name><parameter_list>(<param><decl><type><name>ProfilerObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>void</name> *</type><name>closure</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>result</name> <init>= <expr>(<name><name>self</name>-&gt;<name>logfp</name></name> == <name>NULL</name>) ? <name>Py_True</name> : <name>Py_False</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>result</name></expr>;</return>
}</block></function>
<decl_stmt><decl><type><specifier>static</specifier> <name>PyGetSetDef</name></type> <name><name>profiler_getsets</name><index>[]</index></name> <init>= <expr><block>{
<expr><block>{
<expr>"closed"</expr>, <expr>(<name>getter</name>)<name>profiler_get_closed</name></expr>, <expr><name>NULL</name></expr>,
<macro><name>PyDoc_STR</name><argument_list>(<argument>"True if the profiler's output file has already been closed."</argument>)</argument_list></macro>
}</block></expr>,
<expr><block>{<expr><name>NULL</name></expr>}</block></expr>
}</block></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>profiler_object__doc__</name></expr></argument>,
<argument><expr>"High-performance profiler object.\n"
"\n"
"Methods:\n"
"\n"
"close(): Stop the profiler and close the log files.\n"
"fileno(): Returns the file descriptor of the log file.\n"
"runcall(): Run a single function call with profiling enabled.\n"
"runcode(): Execute a code object with profiling enabled.\n"
"start(): Install the profiler and return.\n"
"stop(): Remove the profiler.\n"
"\n"
"Attributes (read-only):\n"
"\n"
"closed: True if the profiler has already been closed.\n"
"frametimings: True if ENTER/EXIT events collect timing information.\n"
"lineevents: True if line events are reported to the profiler.\n"
"linetimings: True if line events collect timing information."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>PyTypeObject</name></type> <name>ProfilerType</name> <init>= <expr><block>{
<expr><call><name>PyVarObject_HEAD_INIT</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call>
"_hotshot.ProfilerType"</expr>,
<expr>(<name>int</name>) <sizeof>sizeof<argument_list>(<argument><expr><name>ProfilerObject</name></expr></argument>)</argument_list></sizeof></expr>,
<expr>0</expr>,
<expr>(<name>destructor</name>)<name>profiler_dealloc</name></expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr><name>PyObject_GenericGetAttr</name></expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr><name>Py_TPFLAGS_DEFAULT</name></expr>,
<expr><name>profiler_object__doc__</name></expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr><name>profiler_methods</name></expr>,
<expr><name>profiler_members</name></expr>,
<expr><name>profiler_getsets</name></expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>PyMethodDef</name></type> <name><name>logreader_methods</name><index>[]</index></name> <init>= <expr><block>{
<expr><block>{
<expr>"close"</expr>, <expr>(<name>PyCFunction</name>)<name>logreader_close</name></expr>, <expr><name>METH_NOARGS</name></expr>,
<expr><name>logreader_close__doc__</name></expr>
}</block></expr>,
<expr><block>{
<expr>"fileno"</expr>, <expr>(<name>PyCFunction</name>)<name>logreader_fileno</name></expr>, <expr><name>METH_NOARGS</name></expr>,
<expr><name>logreader_fileno__doc__</name></expr>
}</block></expr>,
<expr><block>{<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>}</block></expr>
}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>PyMemberDef</name></type> <name><name>logreader_members</name><index>[]</index></name> <init>= <expr><block>{
<expr><block>{
<expr>"info"</expr>, <expr><name>T_OBJECT</name></expr>, <expr><call><name>offsetof</name><argument_list>(<argument><expr><name>LogReaderObject</name></expr></argument>, <argument><expr><name>info</name></expr></argument>)</argument_list></call></expr>, <expr><name>RO</name></expr>,
<macro><name>PyDoc_STR</name><argument_list>(<argument>"Dictionary mapping informational keys to lists of values."</argument>)</argument_list></macro>
}</block></expr>,
<expr><block>{<expr><name>NULL</name></expr>}</block></expr>
}</block></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>logreader__doc__</name></expr></argument>,
<argument><expr>"logreader(filename) --&gt; log-iterator\n\
Create a log-reader for the timing information file."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>PySequenceMethods</name></type> <name>logreader_as_sequence</name> <init>= <expr><block>{
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>(<name>ssizeargfunc</name>)<name>logreader_sq_item</name></expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
}</block></expr></init></decl>;</decl_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>logreader_get_closed</name><parameter_list>(<param><decl><type><name>LogReaderObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>void</name> *</type><name>closure</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>result</name> <init>= <expr>(<name><name>self</name>-&gt;<name>logfp</name></name> == <name>NULL</name>) ? <name>Py_True</name> : <name>Py_False</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>result</name></expr>;</return>
}</block></function>
<decl_stmt><decl><type><specifier>static</specifier> <name>PyGetSetDef</name></type> <name><name>logreader_getsets</name><index>[]</index></name> <init>= <expr><block>{
<expr><block>{
<expr>"closed"</expr>, <expr>(<name>getter</name>)<name>logreader_get_closed</name></expr>, <expr><name>NULL</name></expr>,
<macro><name>PyDoc_STR</name><argument_list>(<argument>"True if the logreader's input file has already been closed."</argument>)</argument_list></macro>
}</block></expr>,
<expr><block>{<expr><name>NULL</name></expr>}</block></expr>
}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>PyTypeObject</name></type> <name>LogReaderType</name> <init>= <expr><block>{
<expr><call><name>PyVarObject_HEAD_INIT</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call>
"_hotshot.LogReaderType"</expr>,
<expr>(<name>int</name>) <sizeof>sizeof<argument_list>(<argument><expr><name>LogReaderObject</name></expr></argument>)</argument_list></sizeof></expr>,
<expr>0</expr>,
<expr>(<name>destructor</name>)<name>logreader_dealloc</name></expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>&amp;<name>logreader_as_sequence</name></expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr><name>PyObject_GenericGetAttr</name></expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr><name>Py_TPFLAGS_DEFAULT</name></expr>,
<expr><name>logreader__doc__</name></expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr><name>PyObject_SelfIter</name></expr>,
<expr>(<name>iternextfunc</name>)<name>logreader_tp_iternext</name></expr>,
<expr><name>logreader_methods</name></expr>,
<expr><name>logreader_members</name></expr>,
<expr><name>logreader_getsets</name></expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
}</block></expr></init></decl>;</decl_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>hotshot_logreader</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>unused</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>LogReaderObject</name> *</type><name>self</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>filename</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>c</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>err</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"s:logreader"</expr></argument>, <argument><expr>&amp;<name>filename</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><name>self</name> = <call><name>PyObject_New</name><argument_list>(<argument><expr><name>LogReaderObject</name></expr></argument>, <argument><expr>&amp;<name>LogReaderType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>self</name> != <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>self</name>-&gt;<name>frametimings</name></name> = 1</expr>;</expr_stmt>
<expr_stmt><expr><name><name>self</name>-&gt;<name>linetimings</name></name> = 0</expr>;</expr_stmt>
<expr_stmt><expr><name><name>self</name>-&gt;<name>info</name></name> = <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>self</name>-&gt;<name>logfp</name></name> = <call><name>fopen</name><argument_list>(<argument><expr><name>filename</name></expr></argument>, <argument><expr>"rb"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>self</name>-&gt;<name>logfp</name></name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetFromErrnoWithFilename</name><argument_list>(<argument><expr><name>PyExc_IOError</name></expr></argument>, <argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>self</name> = <name>NULL</name></expr>;</expr_stmt>
<goto>goto <name>finally</name>;</goto>
}</block></then></if>
<expr_stmt><expr><name><name>self</name>-&gt;<name>info</name></name> = <call><name>PyDict_New</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>self</name>-&gt;<name>info</name></name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>finally</name>;</goto>
}</block></then></if>
<for>for (<init>;</init><condition>;</condition><incr/>) <block>{
<if>if <condition>(<expr>(<name>c</name> = <call><name>fgetc</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>logfp</name></name></expr></argument>)</argument_list></call>) == <name>EOF</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>eof_error</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
}</block></then></if>
<if>if <condition>(<expr><name>c</name> != <name>WHAT_ADD_INFO</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>ungetc</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name><name>self</name>-&gt;<name>logfp</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
}</block></then></if>
<expr_stmt><expr><name>err</name> = <call><name>unpack_add_info</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>err</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr><name>err</name> == <name>ERR_EOF</name></expr>)</condition><then>
<expr_stmt><expr><call><name>eof_error</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
<else>else
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_RuntimeError</name></expr></argument>,
<argument><expr>"unexpected error"</expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
<break>break;</break>
}</block></then></if>
}</block></for>
}</block></then></if>
}</block></then></if>
<label><name>finally</name>:</label>
<return>return <expr>(<name>PyObject</name> *) <name>self</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>char</name> *</type>
<name>get_version_string</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> *</type><name>rcsid</name> <init>= <expr>"$Revision$"</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>rev</name> <init>= <expr><name>rcsid</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>buffer</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<while>while <condition>(<expr>*<name>rev</name> &amp;&amp; !<call><name>isdigit</name><argument_list>(<argument><expr><call><name>Py_CHARMASK</name><argument_list>(<argument><expr>*<name>rev</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
<expr_stmt><expr>++<name>rev</name></expr>;</expr_stmt></while>
<while>while <condition>(<expr><name><name>rev</name><index>[<expr><name>i</name></expr>]</index></name> != ' ' &amp;&amp; <name><name>rev</name><index>[<expr><name>i</name></expr>]</index></name> != '\0'</expr>)</condition>
<expr_stmt><expr>++<name>i</name></expr>;</expr_stmt></while>
<expr_stmt><expr><name>buffer</name> = (<name>char</name> *)<call><name>malloc</name><argument_list>(<argument><expr><name>i</name> + 1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>buffer</name> != <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>rev</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>buffer</name><index>[<expr><name>i</name></expr>]</index></name> = '\0'</expr>;</expr_stmt>
}</block></then></if>
<return>return <expr><name>buffer</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>write_header</name><parameter_list>(<param><decl><type><name>ProfilerObject</name> *</type><name>self</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>char</name> *</type><name>buffer</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name><name>cwdbuffer</name><index>[<expr><name>PATH_MAX</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>temp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>len</name></decl>;</decl_stmt>
<expr_stmt><expr><name>buffer</name> = <call><name>get_version_string</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>buffer</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_NoMemory</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<return>return <expr>-1</expr>;</return>
}</block></then></if>
<expr_stmt><expr><call><name>pack_add_info</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr>"hotshot-version"</expr></argument>, <argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>pack_add_info</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr>"requested-frame-timings"</expr></argument>,
<argument><expr>(<name><name>self</name>-&gt;<name>frametimings</name></name> ? "yes" : "no")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>pack_add_info</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr>"requested-line-events"</expr></argument>,
<argument><expr>(<name><name>self</name>-&gt;<name>lineevents</name></name> ? "yes" : "no")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>pack_add_info</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr>"requested-line-timings"</expr></argument>,
<argument><expr>(<name><name>self</name>-&gt;<name>linetimings</name></name> ? "yes" : "no")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>pack_add_info</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr>"platform"</expr></argument>, <argument><expr><call><name>Py_GetPlatform</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>pack_add_info</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr>"executable"</expr></argument>, <argument><expr><call><name>Py_GetProgramFullPath</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>buffer</name> = (<name>char</name> *) <call><name>Py_GetVersion</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>buffer</name> == <name>NULL</name></expr>)</condition><then>
<expr_stmt><expr><call><name>PyErr_Clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then>
<else>else
<expr_stmt><expr><call><name>pack_add_info</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr>"executable-version"</expr></argument>, <argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MS_WINDOWS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyOS_snprintf</name><argument_list>(<argument><expr><name>cwdbuffer</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>cwdbuffer</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr>"%I64d"</expr></argument>, <argument><expr><name><name>frequency</name>.<name>QuadPart</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>pack_add_info</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr>"reported-performance-frequency"</expr></argument>, <argument><expr><name>cwdbuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<expr_stmt><expr><call><name>PyOS_snprintf</name><argument_list>(<argument><expr><name>cwdbuffer</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>cwdbuffer</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr>"%lu"</expr></argument>, <argument><expr><name>rusage_diff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>pack_add_info</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr>"observed-interval-getrusage"</expr></argument>, <argument><expr><name>cwdbuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyOS_snprintf</name><argument_list>(<argument><expr><name>cwdbuffer</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>cwdbuffer</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr>"%lu"</expr></argument>, <argument><expr><name>timeofday_diff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>pack_add_info</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr>"observed-interval-gettimeofday"</expr></argument>, <argument><expr><name>cwdbuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><call><name>pack_add_info</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr>"current-directory"</expr></argument>,
<argument><expr><call><name>getcwd</name><argument_list>(<argument><expr><name>cwdbuffer</name></expr></argument>, <argument><expr>sizeof <name>cwdbuffer</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>temp</name> = <call><name>PySys_GetObject</name><argument_list>(<argument><expr>"path"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>temp</name> == <name>NULL</name> || !<call><name>PyList_Check</name><argument_list>(<argument><expr><name>temp</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_RuntimeError</name></expr></argument>, <argument><expr>"sys.path must be a list"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>-1</expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>len</name> = <call><name>PyList_GET_SIZE</name><argument_list>(<argument><expr><name>temp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>len</name></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>) <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>item</name> <init>= <expr><call><name>PyList_GET_ITEM</name><argument_list>(<argument><expr><name>temp</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>buffer</name> = <call><name>PyString_AsString</name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>buffer</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>pack_add_info</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr>"sys-path-entry"</expr></argument>, <argument><expr>"&lt;non-string-path-entry&gt;"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyErr_Clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr><call><name>pack_add_info</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr>"sys-path-entry"</expr></argument>, <argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></else></if>
}</block></for>
<expr_stmt><expr><call><name>pack_frame_times</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>pack_line_times</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>0</expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>profiler__doc__</name></expr></argument>,
<argument><expr>"profiler(logfilename[, lineevents[, linetimes]]) -&gt; profiler\n\
Create a new profiler object."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>hotshot_profiler</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>unused</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>char</name> *</type><name>logfilename</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ProfilerObject</name> *</type><name>self</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>lineevents</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>linetimings</name> <init>= <expr>1</expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"s|ii:profiler"</expr></argument>, <argument><expr>&amp;<name>logfilename</name></expr></argument>,
<argument><expr>&amp;<name>lineevents</name></expr></argument>, <argument><expr>&amp;<name>linetimings</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><name>self</name> = <call><name>PyObject_New</name><argument_list>(<argument><expr><name>ProfilerObject</name></expr></argument>, <argument><expr>&amp;<name>ProfilerType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>self</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name><name>self</name>-&gt;<name>frametimings</name></name> = 1</expr>;</expr_stmt>
<expr_stmt><expr><name><name>self</name>-&gt;<name>lineevents</name></name> = <name>lineevents</name> ? 1 : 0</expr>;</expr_stmt>
<expr_stmt><expr><name><name>self</name>-&gt;<name>linetimings</name></name> = (<name>lineevents</name> &amp;&amp; <name>linetimings</name>) ? 1 : 0</expr>;</expr_stmt>
<expr_stmt><expr><name><name>self</name>-&gt;<name>index</name></name> = 0</expr>;</expr_stmt>
<expr_stmt><expr><name><name>self</name>-&gt;<name>active</name></name> = 0</expr>;</expr_stmt>
<expr_stmt><expr><name><name>self</name>-&gt;<name>next_fileno</name></name> = 0</expr>;</expr_stmt>
<expr_stmt><expr><name><name>self</name>-&gt;<name>logfp</name></name> = <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>self</name>-&gt;<name>logfilename</name></name> = <call><name>PyTuple_GET_ITEM</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>logfilename</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>self</name>-&gt;<name>filemap</name></name> = <call><name>PyDict_New</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>self</name>-&gt;<name>filemap</name></name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name><name>self</name>-&gt;<name>logfp</name></name> = <call><name>fopen</name><argument_list>(<argument><expr><name>logfilename</name></expr></argument>, <argument><expr>"wb"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>self</name>-&gt;<name>logfp</name></name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyErr_SetFromErrnoWithFilename</name><argument_list>(<argument><expr><name>PyExc_IOError</name></expr></argument>, <argument><expr><name>logfilename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<if>if <condition>(<expr><name>timeofday_diff</name> == 0</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>calibrate</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>calibrate</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>calibrate</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<if>if <condition>(<expr><call><name>write_header</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>self</name> = <name>NULL</name></expr>;</expr_stmt>
}</block></then></if>
}</block></then></if>
<return>return <expr>(<name>PyObject</name> *) <name>self</name></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>coverage__doc__</name></expr></argument>,
<argument><expr>"coverage(logfilename) -&gt; profiler\n\
Returns a profiler that doesn't collect any timing information, which is\n\
useful in building a coverage analysis tool."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>hotshot_coverage</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>unused</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>char</name> *</type><name>logfilename</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>result</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"s:coverage"</expr></argument>, <argument><expr>&amp;<name>logfilename</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><name>result</name> = <call><name>hotshot_profiler</name><argument_list>(<argument><expr><name>unused</name></expr></argument>, <argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>result</name> != <name>NULL</name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>ProfilerObject</name> *</type><name>self</name> <init>= <expr>(<name>ProfilerObject</name> *) <name>result</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>self</name>-&gt;<name>frametimings</name></name> = 0</expr>;</expr_stmt>
<expr_stmt><expr><name><name>self</name>-&gt;<name>linetimings</name></name> = 0</expr>;</expr_stmt>
<expr_stmt><expr><name><name>self</name>-&gt;<name>lineevents</name></name> = 1</expr>;</expr_stmt>
}</block></then></if>
}</block></then></if>
<return>return <expr><name>result</name></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_VAR</name><argument_list>(<argument><expr><name>resolution__doc__</name></expr></argument>)</argument_list></call> =
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MS_WINDOWS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<call><name>PyDoc_STR</name><argument_list>(
<argument><expr>"resolution() -&gt; (performance-counter-ticks, update-frequency)\n"
"Return the resolution of the timer provided by the QueryPerformanceCounter()\n"
"function. The first value is the smallest observed change, and the second\n"
"is the result of QueryPerformanceFrequency()."</expr></argument>
)</argument_list></call>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<call><name>PyDoc_STR</name><argument_list>(
<argument><expr>"resolution() -&gt; (gettimeofday-usecs, getrusage-usecs)\n"
"Return the resolution of the timers provided by the gettimeofday() and\n"
"getrusage() system calls, or -1 if the call is not supported."</expr></argument>
)</argument_list></call></expr>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>hotshot_resolution</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>unused</name></decl></param>)</parameter_list> <block>{
<if>if <condition>(<expr><name>timeofday_diff</name> == 0</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>calibrate</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>calibrate</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>calibrate</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MS_WINDOWS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<return>return <expr><call><name>Py_BuildValue</name><argument_list>(<argument><expr>"ii"</expr></argument>, <argument><expr><name>timeofday_diff</name></expr></argument>, <argument><expr><name><name>frequency</name>.<name>LowPart</name></name></expr></argument>)</argument_list></call></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<return>return <expr><call><name>Py_BuildValue</name><argument_list>(<argument><expr>"ii"</expr></argument>, <argument><expr><name>timeofday_diff</name></expr></argument>, <argument><expr><name>rusage_diff</name></expr></argument>)</argument_list></call></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></function>
<decl_stmt><decl><type><specifier>static</specifier> <name>PyMethodDef</name></type> <name><name>functions</name><index>[]</index></name> <init>= <expr><block>{
<expr><block>{<expr>"coverage"</expr>, <expr><name>hotshot_coverage</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>coverage__doc__</name></expr>}</block></expr>,
<expr><block>{<expr>"profiler"</expr>, <expr><name>hotshot_profiler</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>profiler__doc__</name></expr>}</block></expr>,
<expr><block>{<expr>"logreader"</expr>, <expr><name>hotshot_logreader</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>logreader__doc__</name></expr>}</block></expr>,
<expr><block>{<expr>"resolution"</expr>, <expr><name>hotshot_resolution</name></expr>, <expr><name>METH_NOARGS</name></expr>, <expr><name>resolution__doc__</name></expr>}</block></expr>,
<expr><block>{<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>}</block></expr>
}</block></expr></init></decl>;</decl_stmt>
<function><type><name>void</name></type>
<name>init_hotshot</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>module</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>Py_TYPE</name><argument_list>(<argument><expr>&amp;<name>LogReaderType</name></expr></argument>)</argument_list></call> = &amp;<name>PyType_Type</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_TYPE</name><argument_list>(<argument><expr>&amp;<name>ProfilerType</name></expr></argument>)</argument_list></call> = &amp;<name>PyType_Type</name></expr>;</expr_stmt>
<expr_stmt><expr><name>module</name> = <call><name>Py_InitModule</name><argument_list>(<argument><expr>"_hotshot"</expr></argument>, <argument><expr><name>functions</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>module</name> != <name>NULL</name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>char</name> *</type><name>s</name> <init>= <expr><call><name>get_version_string</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>PyModule_AddStringConstant</name><argument_list>(<argument><expr><name>module</name></expr></argument>, <argument><expr>"__version__"</expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr>&amp;<name>LogReaderType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyModule_AddObject</name><argument_list>(<argument><expr><name>module</name></expr></argument>, <argument><expr>"LogReaderType"</expr></argument>,
<argument><expr>(<name>PyObject</name> *)&amp;<name>LogReaderType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr>&amp;<name>ProfilerType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyModule_AddObject</name><argument_list>(<argument><expr><name>module</name></expr></argument>, <argument><expr>"ProfilerType"</expr></argument>,
<argument><expr>(<name>PyObject</name> *)&amp;<name>ProfilerType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>ProfilerError</name> == <name>NULL</name></expr>)</condition><then>
<expr_stmt><expr><name>ProfilerError</name> = <call><name>PyErr_NewException</name><argument_list>(<argument><expr>"hotshot.ProfilerError"</expr></argument>,
<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<if>if <condition>(<expr><name>ProfilerError</name> != <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>ProfilerError</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyModule_AddObject</name><argument_list>(<argument><expr><name>module</name></expr></argument>, <argument><expr>"ProfilerError"</expr></argument>, <argument><expr><name>ProfilerError</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>module</name></expr></argument>, <argument><expr>"WHAT_ENTER"</expr></argument>, <argument><expr><name>WHAT_ENTER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>module</name></expr></argument>, <argument><expr>"WHAT_EXIT"</expr></argument>, <argument><expr><name>WHAT_EXIT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>module</name></expr></argument>, <argument><expr>"WHAT_LINENO"</expr></argument>, <argument><expr><name>WHAT_LINENO</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>module</name></expr></argument>, <argument><expr>"WHAT_OTHER"</expr></argument>, <argument><expr><name>WHAT_OTHER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>module</name></expr></argument>, <argument><expr>"WHAT_ADD_INFO"</expr></argument>, <argument><expr><name>WHAT_ADD_INFO</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>module</name></expr></argument>, <argument><expr>"WHAT_DEFINE_FILE"</expr></argument>, <argument><expr><name>WHAT_DEFINE_FILE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>module</name></expr></argument>, <argument><expr>"WHAT_DEFINE_FUNC"</expr></argument>, <argument><expr><name>WHAT_DEFINE_FUNC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>module</name></expr></argument>, <argument><expr>"WHAT_LINE_TIMES"</expr></argument>, <argument><expr><name>WHAT_LINE_TIMES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
}</block></function>
</unit>
