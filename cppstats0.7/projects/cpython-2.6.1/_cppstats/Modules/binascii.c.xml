<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C" filename="projects/cpython-2.6.1/_cppstats/Modules/binascii.c"><cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PY_SSIZE_T_CLEAN</name></cpp:macro></cpp:define>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"Python.h"</cpp:file></cpp:include>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>USE_ZLIB_CRC32</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"zlib.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<decl_stmt><decl><type><specifier>static</specifier> <name>PyObject</name> *</type><name>Error</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>PyObject</name> *</type><name>Incomplete</name></decl>;</decl_stmt>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RUNCHAR</name></cpp:macro> <cpp:value>0x90</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DONE</name></cpp:macro> <cpp:value>0x7F</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SKIP</name></cpp:macro> <cpp:value>0x7E</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FAIL</name></cpp:macro> <cpp:value>0x7D</cpp:value></cpp:define>
<decl_stmt><decl><type><specifier>static</specifier> <name>unsigned</name> <name>char</name></type> <name><name>table_a2b_hqx</name><index>[<expr>256</expr>]</index></name> <init>= <expr><block>{
<expr><name>FAIL</name></expr>, <expr><name>FAIL</name></expr>, <expr><name>FAIL</name></expr>, <expr><name>FAIL</name></expr>, <expr><name>FAIL</name></expr>, <expr><name>FAIL</name></expr>, <expr><name>FAIL</name></expr>, <expr><name>FAIL</name></expr>,
<expr><name>FAIL</name></expr>, <expr><name>FAIL</name></expr>, <expr><name>SKIP</name></expr>, <expr><name>FAIL</name></expr>, <expr><name>FAIL</name></expr>, <expr><name>SKIP</name></expr>, <expr><name>FAIL</name></expr>, <expr><name>FAIL</name></expr>,
<expr><name>FAIL</name></expr>, <expr><name>FAIL</name></expr>, <expr><name>FAIL</name></expr>, <expr><name>FAIL</name></expr>, <expr><name>FAIL</name></expr>, <expr><name>FAIL</name></expr>, <expr><name>FAIL</name></expr>, <expr><name>FAIL</name></expr>,
<expr><name>FAIL</name></expr>, <expr><name>FAIL</name></expr>, <expr><name>FAIL</name></expr>, <expr><name>FAIL</name></expr>, <expr><name>FAIL</name></expr>, <expr><name>FAIL</name></expr>, <expr><name>FAIL</name></expr>, <expr><name>FAIL</name></expr>,
<expr><name>FAIL</name></expr>, <expr>0x00</expr>, <expr>0x01</expr>, <expr>0x02</expr>, <expr>0x03</expr>, <expr>0x04</expr>, <expr>0x05</expr>, <expr>0x06</expr>,
<expr>0x07</expr>, <expr>0x08</expr>, <expr>0x09</expr>, <expr>0x0A</expr>, <expr>0x0B</expr>, <expr>0x0C</expr>, <expr><name>FAIL</name></expr>, <expr><name>FAIL</name></expr>,
<expr>0x0D</expr>, <expr>0x0E</expr>, <expr>0x0F</expr>, <expr>0x10</expr>, <expr>0x11</expr>, <expr>0x12</expr>, <expr>0x13</expr>, <expr><name>FAIL</name></expr>,
<expr>0x14</expr>, <expr>0x15</expr>, <expr><name>DONE</name></expr>, <expr><name>FAIL</name></expr>, <expr><name>FAIL</name></expr>, <expr><name>FAIL</name></expr>, <expr><name>FAIL</name></expr>, <expr><name>FAIL</name></expr>,
<expr>0x16</expr>, <expr>0x17</expr>, <expr>0x18</expr>, <expr>0x19</expr>, <expr>0x1A</expr>, <expr>0x1B</expr>, <expr>0x1C</expr>, <expr>0x1D</expr>,
<expr>0x1E</expr>, <expr>0x1F</expr>, <expr>0x20</expr>, <expr>0x21</expr>, <expr>0x22</expr>, <expr>0x23</expr>, <expr>0x24</expr>, <expr><name>FAIL</name></expr>,
<expr>0x25</expr>, <expr>0x26</expr>, <expr>0x27</expr>, <expr>0x28</expr>, <expr>0x29</expr>, <expr>0x2A</expr>, <expr>0x2B</expr>, <expr><name>FAIL</name></expr>,
<expr>0x2C</expr>, <expr>0x2D</expr>, <expr>0x2E</expr>, <expr>0x2F</expr>, <expr><name>FAIL</name></expr>, <expr><name>FAIL</name></expr>, <expr><name>FAIL</name></expr>, <expr><name>FAIL</name></expr>,
<expr>0x30</expr>, <expr>0x31</expr>, <expr>0x32</expr>, <expr>0x33</expr>, <expr>0x34</expr>, <expr>0x35</expr>, <expr>0x36</expr>, <expr><name>FAIL</name></expr>,
<expr>0x37</expr>, <expr>0x38</expr>, <expr>0x39</expr>, <expr>0x3A</expr>, <expr>0x3B</expr>, <expr>0x3C</expr>, <expr><name>FAIL</name></expr>, <expr><name>FAIL</name></expr>,
<expr>0x3D</expr>, <expr>0x3E</expr>, <expr>0x3F</expr>, <expr><name>FAIL</name></expr>, <expr><name>FAIL</name></expr>, <expr><name>FAIL</name></expr>, <expr><name>FAIL</name></expr>, <expr><name>FAIL</name></expr>,
<expr><name>FAIL</name></expr>, <expr><name>FAIL</name></expr>, <expr><name>FAIL</name></expr>, <expr><name>FAIL</name></expr>, <expr><name>FAIL</name></expr>, <expr><name>FAIL</name></expr>, <expr><name>FAIL</name></expr>, <expr><name>FAIL</name></expr>,
<expr><name>FAIL</name></expr>, <expr><name>FAIL</name></expr>, <expr><name>FAIL</name></expr>, <expr><name>FAIL</name></expr>, <expr><name>FAIL</name></expr>, <expr><name>FAIL</name></expr>, <expr><name>FAIL</name></expr>, <expr><name>FAIL</name></expr>,
<expr><name>FAIL</name></expr>, <expr><name>FAIL</name></expr>, <expr><name>FAIL</name></expr>, <expr><name>FAIL</name></expr>, <expr><name>FAIL</name></expr>, <expr><name>FAIL</name></expr>, <expr><name>FAIL</name></expr>, <expr><name>FAIL</name></expr>,
<expr><name>FAIL</name></expr>, <expr><name>FAIL</name></expr>, <expr><name>FAIL</name></expr>, <expr><name>FAIL</name></expr>, <expr><name>FAIL</name></expr>, <expr><name>FAIL</name></expr>, <expr><name>FAIL</name></expr>, <expr><name>FAIL</name></expr>,
<expr><name>FAIL</name></expr>, <expr><name>FAIL</name></expr>, <expr><name>FAIL</name></expr>, <expr><name>FAIL</name></expr>, <expr><name>FAIL</name></expr>, <expr><name>FAIL</name></expr>, <expr><name>FAIL</name></expr>, <expr><name>FAIL</name></expr>,
<expr><name>FAIL</name></expr>, <expr><name>FAIL</name></expr>, <expr><name>FAIL</name></expr>, <expr><name>FAIL</name></expr>, <expr><name>FAIL</name></expr>, <expr><name>FAIL</name></expr>, <expr><name>FAIL</name></expr>, <expr><name>FAIL</name></expr>,
<expr><name>FAIL</name></expr>, <expr><name>FAIL</name></expr>, <expr><name>FAIL</name></expr>, <expr><name>FAIL</name></expr>, <expr><name>FAIL</name></expr>, <expr><name>FAIL</name></expr>, <expr><name>FAIL</name></expr>, <expr><name>FAIL</name></expr>,
<expr><name>FAIL</name></expr>, <expr><name>FAIL</name></expr>, <expr><name>FAIL</name></expr>, <expr><name>FAIL</name></expr>, <expr><name>FAIL</name></expr>, <expr><name>FAIL</name></expr>, <expr><name>FAIL</name></expr>, <expr><name>FAIL</name></expr>,
<expr><name>FAIL</name></expr>, <expr><name>FAIL</name></expr>, <expr><name>FAIL</name></expr>, <expr><name>FAIL</name></expr>, <expr><name>FAIL</name></expr>, <expr><name>FAIL</name></expr>, <expr><name>FAIL</name></expr>, <expr><name>FAIL</name></expr>,
<expr><name>FAIL</name></expr>, <expr><name>FAIL</name></expr>, <expr><name>FAIL</name></expr>, <expr><name>FAIL</name></expr>, <expr><name>FAIL</name></expr>, <expr><name>FAIL</name></expr>, <expr><name>FAIL</name></expr>, <expr><name>FAIL</name></expr>,
<expr><name>FAIL</name></expr>, <expr><name>FAIL</name></expr>, <expr><name>FAIL</name></expr>, <expr><name>FAIL</name></expr>, <expr><name>FAIL</name></expr>, <expr><name>FAIL</name></expr>, <expr><name>FAIL</name></expr>, <expr><name>FAIL</name></expr>,
<expr><name>FAIL</name></expr>, <expr><name>FAIL</name></expr>, <expr><name>FAIL</name></expr>, <expr><name>FAIL</name></expr>, <expr><name>FAIL</name></expr>, <expr><name>FAIL</name></expr>, <expr><name>FAIL</name></expr>, <expr><name>FAIL</name></expr>,
<expr><name>FAIL</name></expr>, <expr><name>FAIL</name></expr>, <expr><name>FAIL</name></expr>, <expr><name>FAIL</name></expr>, <expr><name>FAIL</name></expr>, <expr><name>FAIL</name></expr>, <expr><name>FAIL</name></expr>, <expr><name>FAIL</name></expr>,
<expr><name>FAIL</name></expr>, <expr><name>FAIL</name></expr>, <expr><name>FAIL</name></expr>, <expr><name>FAIL</name></expr>, <expr><name>FAIL</name></expr>, <expr><name>FAIL</name></expr>, <expr><name>FAIL</name></expr>, <expr><name>FAIL</name></expr>,
<expr><name>FAIL</name></expr>, <expr><name>FAIL</name></expr>, <expr><name>FAIL</name></expr>, <expr><name>FAIL</name></expr>, <expr><name>FAIL</name></expr>, <expr><name>FAIL</name></expr>, <expr><name>FAIL</name></expr>, <expr><name>FAIL</name></expr>,
<expr><name>FAIL</name></expr>, <expr><name>FAIL</name></expr>, <expr><name>FAIL</name></expr>, <expr><name>FAIL</name></expr>, <expr><name>FAIL</name></expr>, <expr><name>FAIL</name></expr>, <expr><name>FAIL</name></expr>, <expr><name>FAIL</name></expr>,
<expr><name>FAIL</name></expr>, <expr><name>FAIL</name></expr>, <expr><name>FAIL</name></expr>, <expr><name>FAIL</name></expr>, <expr><name>FAIL</name></expr>, <expr><name>FAIL</name></expr>, <expr><name>FAIL</name></expr>, <expr><name>FAIL</name></expr>,
}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>unsigned</name> <name>char</name></type> <name><name>table_b2a_hqx</name><index>[]</index></name> <init>=
<expr>"!\"#$%&amp;'()*+,-012345689@ABCDEFGHIJKLMNPQRSTUVXYZ[`abcdefhijklmpqr"</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name><name>table_a2b_base64</name><index>[]</index></name> <init>= <expr><block>{
<expr>-1</expr>,<expr>-1</expr>,<expr>-1</expr>,<expr>-1</expr>, <expr>-1</expr>,<expr>-1</expr>,<expr>-1</expr>,<expr>-1</expr>, <expr>-1</expr>,<expr>-1</expr>,<expr>-1</expr>,<expr>-1</expr>, <expr>-1</expr>,<expr>-1</expr>,<expr>-1</expr>,<expr>-1</expr>,
<expr>-1</expr>,<expr>-1</expr>,<expr>-1</expr>,<expr>-1</expr>, <expr>-1</expr>,<expr>-1</expr>,<expr>-1</expr>,<expr>-1</expr>, <expr>-1</expr>,<expr>-1</expr>,<expr>-1</expr>,<expr>-1</expr>, <expr>-1</expr>,<expr>-1</expr>,<expr>-1</expr>,<expr>-1</expr>,
<expr>-1</expr>,<expr>-1</expr>,<expr>-1</expr>,<expr>-1</expr>, <expr>-1</expr>,<expr>-1</expr>,<expr>-1</expr>,<expr>-1</expr>, <expr>-1</expr>,<expr>-1</expr>,<expr>-1</expr>,<expr>62</expr>, <expr>-1</expr>,<expr>-1</expr>,<expr>-1</expr>,<expr>63</expr>,
<expr>52</expr>,<expr>53</expr>,<expr>54</expr>,<expr>55</expr>, <expr>56</expr>,<expr>57</expr>,<expr>58</expr>,<expr>59</expr>, <expr>60</expr>,<expr>61</expr>,<expr>-1</expr>,<expr>-1</expr>, <expr>-1</expr>, <expr>0</expr>,<expr>-1</expr>,<expr>-1</expr>,
<expr>-1</expr>, <expr>0</expr>, <expr>1</expr>, <expr>2</expr>, <expr>3</expr>, <expr>4</expr>, <expr>5</expr>, <expr>6</expr>, <expr>7</expr>, <expr>8</expr>, <expr>9</expr>,<expr>10</expr>, <expr>11</expr>,<expr>12</expr>,<expr>13</expr>,<expr>14</expr>,
<expr>15</expr>,<expr>16</expr>,<expr>17</expr>,<expr>18</expr>, <expr>19</expr>,<expr>20</expr>,<expr>21</expr>,<expr>22</expr>, <expr>23</expr>,<expr>24</expr>,<expr>25</expr>,<expr>-1</expr>, <expr>-1</expr>,<expr>-1</expr>,<expr>-1</expr>,<expr>-1</expr>,
<expr>-1</expr>,<expr>26</expr>,<expr>27</expr>,<expr>28</expr>, <expr>29</expr>,<expr>30</expr>,<expr>31</expr>,<expr>32</expr>, <expr>33</expr>,<expr>34</expr>,<expr>35</expr>,<expr>36</expr>, <expr>37</expr>,<expr>38</expr>,<expr>39</expr>,<expr>40</expr>,
<expr>41</expr>,<expr>42</expr>,<expr>43</expr>,<expr>44</expr>, <expr>45</expr>,<expr>46</expr>,<expr>47</expr>,<expr>48</expr>, <expr>49</expr>,<expr>50</expr>,<expr>51</expr>,<expr>-1</expr>, <expr>-1</expr>,<expr>-1</expr>,<expr>-1</expr>,<expr>-1</expr>
}</block></expr></init></decl>;</decl_stmt>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BASE64_PAD</name></cpp:macro> <cpp:value>'='</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BASE64_MAXBIN</name></cpp:macro> <cpp:value>(PY_SSIZE_T_MAX/2 - sizeof(PyStringObject) - 3)</cpp:value></cpp:define>
<decl_stmt><decl><type><specifier>static</specifier> <name>unsigned</name> <name>char</name></type> <name><name>table_b2a_base64</name><index>[]</index></name> <init>=
<expr>"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>unsigned</name> <name>short</name></type> <name><name>crctab_hqx</name><index>[<expr>256</expr>]</index></name> <init>= <expr><block>{
<expr>0x0000</expr>, <expr>0x1021</expr>, <expr>0x2042</expr>, <expr>0x3063</expr>, <expr>0x4084</expr>, <expr>0x50a5</expr>, <expr>0x60c6</expr>, <expr>0x70e7</expr>,
<expr>0x8108</expr>, <expr>0x9129</expr>, <expr>0xa14a</expr>, <expr>0xb16b</expr>, <expr>0xc18c</expr>, <expr>0xd1ad</expr>, <expr>0xe1ce</expr>, <expr>0xf1ef</expr>,
<expr>0x1231</expr>, <expr>0x0210</expr>, <expr>0x3273</expr>, <expr>0x2252</expr>, <expr>0x52b5</expr>, <expr>0x4294</expr>, <expr>0x72f7</expr>, <expr>0x62d6</expr>,
<expr>0x9339</expr>, <expr>0x8318</expr>, <expr>0xb37b</expr>, <expr>0xa35a</expr>, <expr>0xd3bd</expr>, <expr>0xc39c</expr>, <expr>0xf3ff</expr>, <expr>0xe3de</expr>,
<expr>0x2462</expr>, <expr>0x3443</expr>, <expr>0x0420</expr>, <expr>0x1401</expr>, <expr>0x64e6</expr>, <expr>0x74c7</expr>, <expr>0x44a4</expr>, <expr>0x5485</expr>,
<expr>0xa56a</expr>, <expr>0xb54b</expr>, <expr>0x8528</expr>, <expr>0x9509</expr>, <expr>0xe5ee</expr>, <expr>0xf5cf</expr>, <expr>0xc5ac</expr>, <expr>0xd58d</expr>,
<expr>0x3653</expr>, <expr>0x2672</expr>, <expr>0x1611</expr>, <expr>0x0630</expr>, <expr>0x76d7</expr>, <expr>0x66f6</expr>, <expr>0x5695</expr>, <expr>0x46b4</expr>,
<expr>0xb75b</expr>, <expr>0xa77a</expr>, <expr>0x9719</expr>, <expr>0x8738</expr>, <expr>0xf7df</expr>, <expr>0xe7fe</expr>, <expr>0xd79d</expr>, <expr>0xc7bc</expr>,
<expr>0x48c4</expr>, <expr>0x58e5</expr>, <expr>0x6886</expr>, <expr>0x78a7</expr>, <expr>0x0840</expr>, <expr>0x1861</expr>, <expr>0x2802</expr>, <expr>0x3823</expr>,
<expr>0xc9cc</expr>, <expr>0xd9ed</expr>, <expr>0xe98e</expr>, <expr>0xf9af</expr>, <expr>0x8948</expr>, <expr>0x9969</expr>, <expr>0xa90a</expr>, <expr>0xb92b</expr>,
<expr>0x5af5</expr>, <expr>0x4ad4</expr>, <expr>0x7ab7</expr>, <expr>0x6a96</expr>, <expr>0x1a71</expr>, <expr>0x0a50</expr>, <expr>0x3a33</expr>, <expr>0x2a12</expr>,
<expr>0xdbfd</expr>, <expr>0xcbdc</expr>, <expr>0xfbbf</expr>, <expr>0xeb9e</expr>, <expr>0x9b79</expr>, <expr>0x8b58</expr>, <expr>0xbb3b</expr>, <expr>0xab1a</expr>,
<expr>0x6ca6</expr>, <expr>0x7c87</expr>, <expr>0x4ce4</expr>, <expr>0x5cc5</expr>, <expr>0x2c22</expr>, <expr>0x3c03</expr>, <expr>0x0c60</expr>, <expr>0x1c41</expr>,
<expr>0xedae</expr>, <expr>0xfd8f</expr>, <expr>0xcdec</expr>, <expr>0xddcd</expr>, <expr>0xad2a</expr>, <expr>0xbd0b</expr>, <expr>0x8d68</expr>, <expr>0x9d49</expr>,
<expr>0x7e97</expr>, <expr>0x6eb6</expr>, <expr>0x5ed5</expr>, <expr>0x4ef4</expr>, <expr>0x3e13</expr>, <expr>0x2e32</expr>, <expr>0x1e51</expr>, <expr>0x0e70</expr>,
<expr>0xff9f</expr>, <expr>0xefbe</expr>, <expr>0xdfdd</expr>, <expr>0xcffc</expr>, <expr>0xbf1b</expr>, <expr>0xaf3a</expr>, <expr>0x9f59</expr>, <expr>0x8f78</expr>,
<expr>0x9188</expr>, <expr>0x81a9</expr>, <expr>0xb1ca</expr>, <expr>0xa1eb</expr>, <expr>0xd10c</expr>, <expr>0xc12d</expr>, <expr>0xf14e</expr>, <expr>0xe16f</expr>,
<expr>0x1080</expr>, <expr>0x00a1</expr>, <expr>0x30c2</expr>, <expr>0x20e3</expr>, <expr>0x5004</expr>, <expr>0x4025</expr>, <expr>0x7046</expr>, <expr>0x6067</expr>,
<expr>0x83b9</expr>, <expr>0x9398</expr>, <expr>0xa3fb</expr>, <expr>0xb3da</expr>, <expr>0xc33d</expr>, <expr>0xd31c</expr>, <expr>0xe37f</expr>, <expr>0xf35e</expr>,
<expr>0x02b1</expr>, <expr>0x1290</expr>, <expr>0x22f3</expr>, <expr>0x32d2</expr>, <expr>0x4235</expr>, <expr>0x5214</expr>, <expr>0x6277</expr>, <expr>0x7256</expr>,
<expr>0xb5ea</expr>, <expr>0xa5cb</expr>, <expr>0x95a8</expr>, <expr>0x8589</expr>, <expr>0xf56e</expr>, <expr>0xe54f</expr>, <expr>0xd52c</expr>, <expr>0xc50d</expr>,
<expr>0x34e2</expr>, <expr>0x24c3</expr>, <expr>0x14a0</expr>, <expr>0x0481</expr>, <expr>0x7466</expr>, <expr>0x6447</expr>, <expr>0x5424</expr>, <expr>0x4405</expr>,
<expr>0xa7db</expr>, <expr>0xb7fa</expr>, <expr>0x8799</expr>, <expr>0x97b8</expr>, <expr>0xe75f</expr>, <expr>0xf77e</expr>, <expr>0xc71d</expr>, <expr>0xd73c</expr>,
<expr>0x26d3</expr>, <expr>0x36f2</expr>, <expr>0x0691</expr>, <expr>0x16b0</expr>, <expr>0x6657</expr>, <expr>0x7676</expr>, <expr>0x4615</expr>, <expr>0x5634</expr>,
<expr>0xd94c</expr>, <expr>0xc96d</expr>, <expr>0xf90e</expr>, <expr>0xe92f</expr>, <expr>0x99c8</expr>, <expr>0x89e9</expr>, <expr>0xb98a</expr>, <expr>0xa9ab</expr>,
<expr>0x5844</expr>, <expr>0x4865</expr>, <expr>0x7806</expr>, <expr>0x6827</expr>, <expr>0x18c0</expr>, <expr>0x08e1</expr>, <expr>0x3882</expr>, <expr>0x28a3</expr>,
<expr>0xcb7d</expr>, <expr>0xdb5c</expr>, <expr>0xeb3f</expr>, <expr>0xfb1e</expr>, <expr>0x8bf9</expr>, <expr>0x9bd8</expr>, <expr>0xabbb</expr>, <expr>0xbb9a</expr>,
<expr>0x4a75</expr>, <expr>0x5a54</expr>, <expr>0x6a37</expr>, <expr>0x7a16</expr>, <expr>0x0af1</expr>, <expr>0x1ad0</expr>, <expr>0x2ab3</expr>, <expr>0x3a92</expr>,
<expr>0xfd2e</expr>, <expr>0xed0f</expr>, <expr>0xdd6c</expr>, <expr>0xcd4d</expr>, <expr>0xbdaa</expr>, <expr>0xad8b</expr>, <expr>0x9de8</expr>, <expr>0x8dc9</expr>,
<expr>0x7c26</expr>, <expr>0x6c07</expr>, <expr>0x5c64</expr>, <expr>0x4c45</expr>, <expr>0x3ca2</expr>, <expr>0x2c83</expr>, <expr>0x1ce0</expr>, <expr>0x0cc1</expr>,
<expr>0xef1f</expr>, <expr>0xff3e</expr>, <expr>0xcf5d</expr>, <expr>0xdf7c</expr>, <expr>0xaf9b</expr>, <expr>0xbfba</expr>, <expr>0x8fd9</expr>, <expr>0x9ff8</expr>,
<expr>0x6e17</expr>, <expr>0x7e36</expr>, <expr>0x4e55</expr>, <expr>0x5e74</expr>, <expr>0x2e93</expr>, <expr>0x3eb2</expr>, <expr>0x0ed1</expr>, <expr>0x1ef0</expr>,
}</block></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>doc_a2b_uu</name></expr></argument>, <argument><expr>"(ascii) -&gt; bin. Decode a line of uuencoded data"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>binascii_a2b_uu</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>unsigned</name> <name>char</name> *</type><name>ascii_data</name></decl>, *<decl><type ref="prev"/><name>bin_data</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>leftbits</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name>this_ch</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>leftchar</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>rv</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>ascii_len</name></decl>, <decl><type ref="prev"/><name>bin_len</name></decl>;</decl_stmt>
<if>if <condition>( <expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"t#:a2b_uu"</expr></argument>, <argument><expr>&amp;<name>ascii_data</name></expr></argument>, <argument><expr>&amp;<name>ascii_len</name></expr></argument>)</argument_list></call></expr> )</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>ascii_len</name> &gt;= 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>bin_len</name> = (*<name>ascii_data</name>++ - ' ') &amp; 077</expr>;</expr_stmt>
<expr_stmt><expr><name>ascii_len</name>--</expr>;</expr_stmt>
<if>if <condition>( <expr>(<name>rv</name>=<call><name>PyString_FromStringAndSize</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>bin_len</name></expr></argument>)</argument_list></call>) == <name>NULL</name></expr> )</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>bin_data</name> = (<name>unsigned</name> <name>char</name> *)<call><name>PyString_AsString</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for( <init>;</init> <condition><expr><name>bin_len</name> &gt; 0</expr> ;</condition> <incr><expr><name>ascii_len</name>--</expr>, <expr><name>ascii_data</name>++</expr></incr> ) <block>{
<expr_stmt><expr><name>this_ch</name> = (<name>ascii_len</name> &gt; 0) ? *<name>ascii_data</name> : 0</expr>;</expr_stmt>
<if>if <condition>( <expr><name>this_ch</name> == '\n' || <name>this_ch</name> == '\r' || <name>ascii_len</name> &lt;= 0</expr>)</condition><then> <block>{
<expr_stmt><expr><name>this_ch</name> = 0</expr>;</expr_stmt>
}</block></then> <else>else <block>{
<if>if <condition>( <expr><name>this_ch</name> &lt; ' ' || <name>this_ch</name> &gt; (' ' + 64)</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>Error</name></expr></argument>, <argument><expr>"Illegal char"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>this_ch</name> = (<name>this_ch</name> - ' ') &amp; 077</expr>;</expr_stmt>
}</block></else></if>
<expr_stmt><expr><name>leftchar</name> = (<name>leftchar</name> &lt;&lt; 6) | (<name>this_ch</name>)</expr>;</expr_stmt>
<expr_stmt><expr><name>leftbits</name> += 6</expr>;</expr_stmt>
<if>if <condition>( <expr><name>leftbits</name> &gt;= 8</expr> )</condition><then> <block>{
<expr_stmt><expr><name>leftbits</name> -= 8</expr>;</expr_stmt>
<expr_stmt><expr>*<name>bin_data</name>++ = (<name>leftchar</name> &gt;&gt; <name>leftbits</name>) &amp; 0xff</expr>;</expr_stmt>
<expr_stmt><expr><name>leftchar</name> &amp;= ((1 &lt;&lt; <name>leftbits</name>) - 1)</expr>;</expr_stmt>
<expr_stmt><expr><name>bin_len</name>--</expr>;</expr_stmt>
}</block></then></if>
}</block></for>
<while>while<condition>( <expr><name>ascii_len</name>-- &gt; 0</expr> )</condition> <block>{
<expr_stmt><expr><name>this_ch</name> = *<name>ascii_data</name>++</expr>;</expr_stmt>
<if>if <condition>( <expr><name>this_ch</name> != ' ' &amp;&amp; <name>this_ch</name> != ' '+64 &amp;&amp;
<name>this_ch</name> != '\n' &amp;&amp; <name>this_ch</name> != '\r'</expr> )</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>Error</name></expr></argument>, <argument><expr>"Trailing garbage"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
}</block></while>
<return>return <expr><name>rv</name></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>doc_b2a_uu</name></expr></argument>, <argument><expr>"(bin) -&gt; ascii. Uuencode line of data"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>binascii_b2a_uu</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>unsigned</name> <name>char</name> *</type><name>ascii_data</name></decl>, *<decl><type ref="prev"/><name>bin_data</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>leftbits</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name>this_ch</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>leftchar</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>rv</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>bin_len</name></decl>;</decl_stmt>
<if>if <condition>( <expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"s#:b2a_uu"</expr></argument>, <argument><expr>&amp;<name>bin_data</name></expr></argument>, <argument><expr>&amp;<name>bin_len</name></expr></argument>)</argument_list></call></expr> )</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<if>if <condition>( <expr><name>bin_len</name> &gt; 45</expr> )</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>Error</name></expr></argument>, <argument><expr>"At most 45 bytes at once"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<if>if <condition>( <expr>(<name>rv</name>=<call><name>PyString_FromStringAndSize</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>bin_len</name>*2+2</expr></argument>)</argument_list></call>) == <name>NULL</name></expr> )</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>ascii_data</name> = (<name>unsigned</name> <name>char</name> *)<call><name>PyString_AsString</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr>*<name>ascii_data</name>++ = ' ' + (<name>bin_len</name> &amp; 077)</expr>;</expr_stmt>
<for>for( <init>;</init> <condition><expr><name>bin_len</name> &gt; 0 || <name>leftbits</name> != 0</expr> ;</condition> <incr><expr><name>bin_len</name>--</expr>, <expr><name>bin_data</name>++</expr></incr> ) <block>{
<if>if <condition>( <expr><name>bin_len</name> &gt; 0</expr> )</condition><then>
<expr_stmt><expr><name>leftchar</name> = (<name>leftchar</name> &lt;&lt; 8) | *<name>bin_data</name></expr>;</expr_stmt></then>
<else>else
<expr_stmt><expr><name>leftchar</name> &lt;&lt;= 8</expr>;</expr_stmt></else></if>
<expr_stmt><expr><name>leftbits</name> += 8</expr>;</expr_stmt>
<while>while <condition>( <expr><name>leftbits</name> &gt;= 6</expr> )</condition> <block>{
<expr_stmt><expr><name>this_ch</name> = (<name>leftchar</name> &gt;&gt; (<name>leftbits</name>-6)) &amp; 0x3f</expr>;</expr_stmt>
<expr_stmt><expr><name>leftbits</name> -= 6</expr>;</expr_stmt>
<expr_stmt><expr>*<name>ascii_data</name>++ = <name>this_ch</name> + ' '</expr>;</expr_stmt>
}</block></while>
}</block></for>
<expr_stmt><expr>*<name>ascii_data</name>++ = '\n'</expr>;</expr_stmt>
<expr_stmt><expr><call><name>_PyString_Resize</name><argument_list>(<argument><expr>&amp;<name>rv</name></expr></argument>, <argument><expr>(<name>ascii_data</name> -
(<name>unsigned</name> <name>char</name> *)<call><name>PyString_AsString</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>rv</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>binascii_find_valid</name><parameter_list>(<param><decl><type><name>unsigned</name> <name>char</name> *</type><name>s</name></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>slen</name></decl></param>, <param><decl><type><name>int</name></type> <name>num</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>ret</name> <init>= <expr>-1</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name>c</name></decl>, <decl><type ref="prev"/><name>b64val</name></decl>;</decl_stmt>
<while>while <condition>(<expr>(<name>slen</name> &gt; 0) &amp;&amp; (<name>ret</name> == -1)</expr>)</condition> <block>{
<expr_stmt><expr><name>c</name> = *<name>s</name></expr>;</expr_stmt>
<expr_stmt><expr><name>b64val</name> = <name><name>table_a2b_base64</name><index>[<expr><name>c</name> &amp; 0x7f</expr>]</index></name></expr>;</expr_stmt>
<if>if <condition>( <expr>((<name>c</name> &lt;= 0x7f) &amp;&amp; (<name>b64val</name> != (<name>unsigned</name> <name>char</name>)-1))</expr> )</condition><then> <block>{
<if>if <condition>(<expr><name>num</name> == 0</expr>)</condition><then>
<expr_stmt><expr><name>ret</name> = *<name>s</name></expr>;</expr_stmt></then></if>
<expr_stmt><expr><name>num</name>--</expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><name>s</name>++</expr>;</expr_stmt>
<expr_stmt><expr><name>slen</name>--</expr>;</expr_stmt>
}</block></while>
<return>return <expr><name>ret</name></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>doc_a2b_base64</name></expr></argument>, <argument><expr>"(ascii) -&gt; bin. Decode a line of base64 data"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>binascii_a2b_base64</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>unsigned</name> <name>char</name> *</type><name>ascii_data</name></decl>, *<decl><type ref="prev"/><name>bin_data</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>leftbits</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name>this_ch</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>leftchar</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>rv</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>ascii_len</name></decl>, <decl><type ref="prev"/><name>bin_len</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>quad_pos</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<if>if <condition>( <expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"t#:a2b_base64"</expr></argument>, <argument><expr>&amp;<name>ascii_data</name></expr></argument>, <argument><expr>&amp;<name>ascii_len</name></expr></argument>)</argument_list></call></expr> )</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>ascii_len</name> &gt;= 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>ascii_len</name> &gt; <name>PY_SSIZE_T_MAX</name> - 3</expr>)</condition><then>
<return>return <expr><call><name>PyErr_NoMemory</name><argument_list>()</argument_list></call></expr>;</return></then></if>
<expr_stmt><expr><name>bin_len</name> = ((<name>ascii_len</name>+3)/4)*3</expr>;</expr_stmt>
<if>if <condition>( <expr>(<name>rv</name>=<call><name>PyString_FromStringAndSize</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>bin_len</name></expr></argument>)</argument_list></call>) == <name>NULL</name></expr> )</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>bin_data</name> = (<name>unsigned</name> <name>char</name> *)<call><name>PyString_AsString</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>bin_len</name> = 0</expr>;</expr_stmt>
<for>for( <init>;</init> <condition><expr><name>ascii_len</name> &gt; 0</expr>;</condition> <incr><expr><name>ascii_len</name>--</expr>, <expr><name>ascii_data</name>++</expr></incr>) <block>{
<expr_stmt><expr><name>this_ch</name> = *<name>ascii_data</name></expr>;</expr_stmt>
<if>if <condition>(<expr><name>this_ch</name> &gt; 0x7f ||
<name>this_ch</name> == '\r' || <name>this_ch</name> == '\n' || <name>this_ch</name> == ' '</expr>)</condition><then>
<continue>continue;</continue></then></if>
<if>if <condition>(<expr><name>this_ch</name> == <name>BASE64_PAD</name></expr>)</condition><then> <block>{
<if>if <condition>( <expr>(<name>quad_pos</name> &lt; 2) ||
((<name>quad_pos</name> == 2) &amp;&amp;
(<call><name>binascii_find_valid</name><argument_list>(<argument><expr><name>ascii_data</name></expr></argument>, <argument><expr><name>ascii_len</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call>
!= <name>BASE64_PAD</name>))</expr> )</condition><then> <block>{
<continue>continue;</continue>
}</block></then> <else>else <block>{
<expr_stmt><expr><name>leftbits</name> = 0</expr>;</expr_stmt>
<break>break;</break>
}</block></else></if>
}</block></then></if>
<expr_stmt><expr><name>this_ch</name> = <name><name>table_a2b_base64</name><index>[<expr>*<name>ascii_data</name></expr>]</index></name></expr>;</expr_stmt>
<if>if <condition>( <expr><name>this_ch</name> == (<name>unsigned</name> <name>char</name>) -1</expr> )</condition><then>
<continue>continue;</continue></then></if>
<expr_stmt><expr><name>quad_pos</name> = (<name>quad_pos</name> + 1) &amp; 0x03</expr>;</expr_stmt>
<expr_stmt><expr><name>leftchar</name> = (<name>leftchar</name> &lt;&lt; 6) | (<name>this_ch</name>)</expr>;</expr_stmt>
<expr_stmt><expr><name>leftbits</name> += 6</expr>;</expr_stmt>
<if>if <condition>( <expr><name>leftbits</name> &gt;= 8</expr> )</condition><then> <block>{
<expr_stmt><expr><name>leftbits</name> -= 8</expr>;</expr_stmt>
<expr_stmt><expr>*<name>bin_data</name>++ = (<name>leftchar</name> &gt;&gt; <name>leftbits</name>) &amp; 0xff</expr>;</expr_stmt>
<expr_stmt><expr><name>bin_len</name>++</expr>;</expr_stmt>
<expr_stmt><expr><name>leftchar</name> &amp;= ((1 &lt;&lt; <name>leftbits</name>) - 1)</expr>;</expr_stmt>
}</block></then></if>
}</block></for>
<if>if <condition>(<expr><name>leftbits</name> != 0</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>Error</name></expr></argument>, <argument><expr>"Incorrect padding"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<if>if <condition>(<expr><name>bin_len</name> &gt; 0</expr>)</condition><then>
<expr_stmt><expr><call><name>_PyString_Resize</name><argument_list>(<argument><expr>&amp;<name>rv</name></expr></argument>, <argument><expr><name>bin_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
<else>else <block>{
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>rv</name> = <call><name>PyString_FromString</name><argument_list>(<argument><expr>""</expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></else></if>
<return>return <expr><name>rv</name></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>doc_b2a_base64</name></expr></argument>, <argument><expr>"(bin) -&gt; ascii. Base64-code line of data"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>binascii_b2a_base64</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>unsigned</name> <name>char</name> *</type><name>ascii_data</name></decl>, *<decl><type ref="prev"/><name>bin_data</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>leftbits</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name>this_ch</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>leftchar</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>rv</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>bin_len</name></decl>;</decl_stmt>
<if>if <condition>( <expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"s#:b2a_base64"</expr></argument>, <argument><expr>&amp;<name>bin_data</name></expr></argument>, <argument><expr>&amp;<name>bin_len</name></expr></argument>)</argument_list></call></expr> )</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>bin_len</name> &gt;= 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>( <expr><name>bin_len</name> &gt; <name>BASE64_MAXBIN</name></expr> )</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>Error</name></expr></argument>, <argument><expr>"Too much data for base64 line"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<if>if <condition>( <expr>(<name>rv</name>=<call><name>PyString_FromStringAndSize</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>bin_len</name>*2 + 3</expr></argument>)</argument_list></call>) == <name>NULL</name></expr> )</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>ascii_data</name> = (<name>unsigned</name> <name>char</name> *)<call><name>PyString_AsString</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for( <init>;</init> <condition><expr><name>bin_len</name> &gt; 0</expr> ;</condition> <incr><expr><name>bin_len</name>--</expr>, <expr><name>bin_data</name>++</expr></incr> ) <block>{
<expr_stmt><expr><name>leftchar</name> = (<name>leftchar</name> &lt;&lt; 8) | *<name>bin_data</name></expr>;</expr_stmt>
<expr_stmt><expr><name>leftbits</name> += 8</expr>;</expr_stmt>
<while>while <condition>( <expr><name>leftbits</name> &gt;= 6</expr> )</condition> <block>{
<expr_stmt><expr><name>this_ch</name> = (<name>leftchar</name> &gt;&gt; (<name>leftbits</name>-6)) &amp; 0x3f</expr>;</expr_stmt>
<expr_stmt><expr><name>leftbits</name> -= 6</expr>;</expr_stmt>
<expr_stmt><expr>*<name>ascii_data</name>++ = <name><name>table_b2a_base64</name><index>[<expr><name>this_ch</name></expr>]</index></name></expr>;</expr_stmt>
}</block></while>
}</block></for>
<if>if <condition>( <expr><name>leftbits</name> == 2</expr> )</condition><then> <block>{
<expr_stmt><expr>*<name>ascii_data</name>++ = <name><name>table_b2a_base64</name><index>[<expr>(<name>leftchar</name>&amp;3) &lt;&lt; 4</expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr>*<name>ascii_data</name>++ = <name>BASE64_PAD</name></expr>;</expr_stmt>
<expr_stmt><expr>*<name>ascii_data</name>++ = <name>BASE64_PAD</name></expr>;</expr_stmt>
}</block></then> <else>else <if>if <condition>( <expr><name>leftbits</name> == 4</expr> )</condition><then> <block>{
<expr_stmt><expr>*<name>ascii_data</name>++ = <name><name>table_b2a_base64</name><index>[<expr>(<name>leftchar</name>&amp;0xf) &lt;&lt; 2</expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr>*<name>ascii_data</name>++ = <name>BASE64_PAD</name></expr>;</expr_stmt>
}</block></then></if></else></if>
<expr_stmt><expr>*<name>ascii_data</name>++ = '\n'</expr>;</expr_stmt>
<expr_stmt><expr><call><name>_PyString_Resize</name><argument_list>(<argument><expr>&amp;<name>rv</name></expr></argument>, <argument><expr>(<name>ascii_data</name> -
(<name>unsigned</name> <name>char</name> *)<call><name>PyString_AsString</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>rv</name></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>doc_a2b_hqx</name></expr></argument>, <argument><expr>"ascii -&gt; bin, done. Decode .hqx coding"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>binascii_a2b_hqx</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>unsigned</name> <name>char</name> *</type><name>ascii_data</name></decl>, *<decl><type ref="prev"/><name>bin_data</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>leftbits</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name>this_ch</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>leftchar</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>rv</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>len</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>done</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<if>if <condition>( <expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"t#:a2b_hqx"</expr></argument>, <argument><expr>&amp;<name>ascii_data</name></expr></argument>, <argument><expr>&amp;<name>len</name></expr></argument>)</argument_list></call></expr> )</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>len</name> &gt;= 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>len</name> &gt; <name>PY_SSIZE_T_MAX</name> - 2</expr>)</condition><then>
<return>return <expr><call><name>PyErr_NoMemory</name><argument_list>()</argument_list></call></expr>;</return></then></if>
<if>if <condition>( <expr>(<name>rv</name>=<call><name>PyString_FromStringAndSize</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>len</name>+2</expr></argument>)</argument_list></call>) == <name>NULL</name></expr> )</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>bin_data</name> = (<name>unsigned</name> <name>char</name> *)<call><name>PyString_AsString</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for( <init>;</init> <condition><expr><name>len</name> &gt; 0</expr> ;</condition> <incr><expr><name>len</name>--</expr>, <expr><name>ascii_data</name>++</expr></incr> ) <block>{
<expr_stmt><expr><name>this_ch</name> = <name><name>table_a2b_hqx</name><index>[<expr>*<name>ascii_data</name></expr>]</index></name></expr>;</expr_stmt>
<if>if <condition>( <expr><name>this_ch</name> == <name>SKIP</name></expr> )</condition><then>
<continue>continue;</continue></then></if>
<if>if <condition>( <expr><name>this_ch</name> == <name>FAIL</name></expr> )</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>Error</name></expr></argument>, <argument><expr>"Illegal char"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<if>if <condition>( <expr><name>this_ch</name> == <name>DONE</name></expr> )</condition><then> <block>{
<expr_stmt><expr><name>done</name> = 1</expr>;</expr_stmt>
<break>break;</break>
}</block></then></if>
<expr_stmt><expr><name>leftchar</name> = (<name>leftchar</name> &lt;&lt; 6) | (<name>this_ch</name>)</expr>;</expr_stmt>
<expr_stmt><expr><name>leftbits</name> += 6</expr>;</expr_stmt>
<if>if <condition>( <expr><name>leftbits</name> &gt;= 8</expr> )</condition><then> <block>{
<expr_stmt><expr><name>leftbits</name> -= 8</expr>;</expr_stmt>
<expr_stmt><expr>*<name>bin_data</name>++ = (<name>leftchar</name> &gt;&gt; <name>leftbits</name>) &amp; 0xff</expr>;</expr_stmt>
<expr_stmt><expr><name>leftchar</name> &amp;= ((1 &lt;&lt; <name>leftbits</name>) - 1)</expr>;</expr_stmt>
}</block></then></if>
}</block></for>
<if>if <condition>( <expr><name>leftbits</name> &amp;&amp; !<name>done</name></expr> )</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>Incomplete</name></expr></argument>,
<argument><expr>"String has incomplete number of bytes"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><call><name>_PyString_Resize</name><argument_list>(
<argument><expr>&amp;<name>rv</name></expr></argument>, <argument><expr>(<name>bin_data</name> - (<name>unsigned</name> <name>char</name> *)<call><name>PyString_AsString</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>rv</name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>rrv</name> <init>= <expr><call><name>Py_BuildValue</name><argument_list>(<argument><expr>"Oi"</expr></argument>, <argument><expr><name>rv</name></expr></argument>, <argument><expr><name>done</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>rrv</name></expr>;</return>
}</block></then></if>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>doc_rlecode_hqx</name></expr></argument>, <argument><expr>"Binhex RLE-code binary data"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>binascii_rlecode_hqx</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>unsigned</name> <name>char</name> *</type><name>in_data</name></decl>, *<decl><type ref="prev"/><name>out_data</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>rv</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name>ch</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>in</name></decl>, <decl><type ref="prev"/><name>inend</name></decl>, <decl><type ref="prev"/><name>len</name></decl>;</decl_stmt>
<if>if <condition>( <expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"s#:rlecode_hqx"</expr></argument>, <argument><expr>&amp;<name>in_data</name></expr></argument>, <argument><expr>&amp;<name>len</name></expr></argument>)</argument_list></call></expr> )</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>len</name> &gt;= 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>len</name> &gt; <name>PY_SSIZE_T_MAX</name> / 2 - 2</expr>)</condition><then>
<return>return <expr><call><name>PyErr_NoMemory</name><argument_list>()</argument_list></call></expr>;</return></then></if>
<if>if <condition>( <expr>(<name>rv</name>=<call><name>PyString_FromStringAndSize</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>len</name>*2+2</expr></argument>)</argument_list></call>) == <name>NULL</name></expr> )</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>out_data</name> = (<name>unsigned</name> <name>char</name> *)<call><name>PyString_AsString</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for( <init><expr><name>in</name>=0</expr>;</init> <condition><expr><name>in</name>&lt;<name>len</name></expr>;</condition> <incr><expr><name>in</name>++</expr></incr>) <block>{
<expr_stmt><expr><name>ch</name> = <name><name>in_data</name><index>[<expr><name>in</name></expr>]</index></name></expr>;</expr_stmt>
<if>if <condition>( <expr><name>ch</name> == <name>RUNCHAR</name></expr> )</condition><then> <block>{
<expr_stmt><expr>*<name>out_data</name>++ = <name>RUNCHAR</name></expr>;</expr_stmt>
<expr_stmt><expr>*<name>out_data</name>++ = 0</expr>;</expr_stmt>
}</block></then> <else>else <block>{
<for>for(<init><expr><name>inend</name>=<name>in</name>+1</expr>;</init>
<condition><expr><name>inend</name>&lt;<name>len</name> &amp;&amp; <name><name>in_data</name><index>[<expr><name>inend</name></expr>]</index></name> == <name>ch</name> &amp;&amp;
<name>inend</name> &lt; <name>in</name>+255</expr>;</condition>
<incr><expr><name>inend</name>++</expr></incr>) <empty_stmt>;</empty_stmt></for>
<if>if <condition>( <expr><name>inend</name> - <name>in</name> &gt; 3</expr> )</condition><then> <block>{
<expr_stmt><expr>*<name>out_data</name>++ = <name>ch</name></expr>;</expr_stmt>
<expr_stmt><expr>*<name>out_data</name>++ = <name>RUNCHAR</name></expr>;</expr_stmt>
<expr_stmt><expr>*<name>out_data</name>++ = <name>inend</name>-<name>in</name></expr>;</expr_stmt>
<expr_stmt><expr><name>in</name> = <name>inend</name>-1</expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr>*<name>out_data</name>++ = <name>ch</name></expr>;</expr_stmt>
}</block></else></if>
}</block></else></if>
}</block></for>
<expr_stmt><expr><call><name>_PyString_Resize</name><argument_list>(<argument><expr>&amp;<name>rv</name></expr></argument>, <argument><expr>(<name>out_data</name> -
(<name>unsigned</name> <name>char</name> *)<call><name>PyString_AsString</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>rv</name></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>doc_b2a_hqx</name></expr></argument>, <argument><expr>"Encode .hqx data"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>binascii_b2a_hqx</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>unsigned</name> <name>char</name> *</type><name>ascii_data</name></decl>, *<decl><type ref="prev"/><name>bin_data</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>leftbits</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name>this_ch</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>leftchar</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>rv</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>len</name></decl>;</decl_stmt>
<if>if <condition>( <expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"s#:b2a_hqx"</expr></argument>, <argument><expr>&amp;<name>bin_data</name></expr></argument>, <argument><expr>&amp;<name>len</name></expr></argument>)</argument_list></call></expr> )</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>len</name> &gt;= 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>len</name> &gt; <name>PY_SSIZE_T_MAX</name> / 2 - 2</expr>)</condition><then>
<return>return <expr><call><name>PyErr_NoMemory</name><argument_list>()</argument_list></call></expr>;</return></then></if>
<if>if <condition>( <expr>(<name>rv</name>=<call><name>PyString_FromStringAndSize</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>len</name>*2+2</expr></argument>)</argument_list></call>) == <name>NULL</name></expr> )</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>ascii_data</name> = (<name>unsigned</name> <name>char</name> *)<call><name>PyString_AsString</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for( <init>;</init> <condition><expr><name>len</name> &gt; 0</expr> ;</condition> <incr><expr><name>len</name>--</expr>, <expr><name>bin_data</name>++</expr></incr> ) <block>{
<expr_stmt><expr><name>leftchar</name> = (<name>leftchar</name> &lt;&lt; 8) | *<name>bin_data</name></expr>;</expr_stmt>
<expr_stmt><expr><name>leftbits</name> += 8</expr>;</expr_stmt>
<while>while <condition>( <expr><name>leftbits</name> &gt;= 6</expr> )</condition> <block>{
<expr_stmt><expr><name>this_ch</name> = (<name>leftchar</name> &gt;&gt; (<name>leftbits</name>-6)) &amp; 0x3f</expr>;</expr_stmt>
<expr_stmt><expr><name>leftbits</name> -= 6</expr>;</expr_stmt>
<expr_stmt><expr>*<name>ascii_data</name>++ = <name><name>table_b2a_hqx</name><index>[<expr><name>this_ch</name></expr>]</index></name></expr>;</expr_stmt>
}</block></while>
}</block></for>
<if>if <condition>( <expr><name>leftbits</name></expr> )</condition><then> <block>{
<expr_stmt><expr><name>leftchar</name> &lt;&lt;= (6-<name>leftbits</name>)</expr>;</expr_stmt>
<expr_stmt><expr>*<name>ascii_data</name>++ = <name><name>table_b2a_hqx</name><index>[<expr><name>leftchar</name> &amp; 0x3f</expr>]</index></name></expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><call><name>_PyString_Resize</name><argument_list>(<argument><expr>&amp;<name>rv</name></expr></argument>, <argument><expr>(<name>ascii_data</name> -
(<name>unsigned</name> <name>char</name> *)<call><name>PyString_AsString</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>rv</name></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>doc_rledecode_hqx</name></expr></argument>, <argument><expr>"Decode hexbin RLE-coded string"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>binascii_rledecode_hqx</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>unsigned</name> <name>char</name> *</type><name>in_data</name></decl>, *<decl><type ref="prev"/><name>out_data</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name>in_byte</name></decl>, <decl><type ref="prev"/><name>in_repeat</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>rv</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>in_len</name></decl>, <decl><type ref="prev"/><name>out_len</name></decl>, <decl><type ref="prev"/><name>out_len_left</name></decl>;</decl_stmt>
<if>if <condition>( <expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"s#:rledecode_hqx"</expr></argument>, <argument><expr>&amp;<name>in_data</name></expr></argument>, <argument><expr>&amp;<name>in_len</name></expr></argument>)</argument_list></call></expr> )</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>in_len</name> &gt;= 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>( <expr><name>in_len</name> == 0</expr> )</condition><then>
<return>return <expr><call><name>PyString_FromString</name><argument_list>(<argument><expr>""</expr></argument>)</argument_list></call></expr>;</return></then>
<else>else <if>if <condition>(<expr><name>in_len</name> &gt; <name>PY_SSIZE_T_MAX</name> / 2</expr>)</condition><then>
<return>return <expr><call><name>PyErr_NoMemory</name><argument_list>()</argument_list></call></expr>;</return></then></if></else></if>
<expr_stmt><expr><name>out_len</name> = <name>in_len</name>*2</expr>;</expr_stmt>
<if>if <condition>( <expr>(<name>rv</name>=<call><name>PyString_FromStringAndSize</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>out_len</name></expr></argument>)</argument_list></call>) == <name>NULL</name></expr> )</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>out_len_left</name> = <name>out_len</name></expr>;</expr_stmt>
<expr_stmt><expr><name>out_data</name> = (<name>unsigned</name> <name>char</name> *)<call><name>PyString_AsString</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INBYTE</name><parameter_list>(<param><type><name>b</name></type></param>)</parameter_list></cpp:macro> <cpp:value>do { if ( --in_len &lt; 0 ) { PyErr_SetString(Incomplete, ""); Py_DECREF(rv); return NULL; } b = *in_data++; } while(0)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>OUTBYTE</name><parameter_list>(<param><type><name>b</name></type></param>)</parameter_list></cpp:macro> <cpp:value>do { if ( --out_len_left &lt; 0 ) { if ( out_len &gt; PY_SSIZE_T_MAX / 2) return PyErr_NoMemory(); _PyString_Resize(&amp;rv, 2*out_len); if ( rv == NULL ) return NULL; out_data = (unsigned char *)PyString_AsString(rv) + out_len; out_len_left = out_len-1; out_len = out_len * 2; } *out_data++ = b; } while(0)</cpp:value></cpp:define>
<expr_stmt><expr><call><name>INBYTE</name><argument_list>(<argument><expr><name>in_byte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>in_byte</name> == <name>RUNCHAR</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>INBYTE</name><argument_list>(<argument><expr><name>in_repeat</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>in_repeat</name> != 0</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>Error</name></expr></argument>, <argument><expr>"Orphaned RLE code at start"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><call><name>OUTBYTE</name><argument_list>(<argument><expr><name>RUNCHAR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr><call><name>OUTBYTE</name><argument_list>(<argument><expr><name>in_byte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></else></if>
<while>while<condition>( <expr><name>in_len</name> &gt; 0</expr> )</condition> <block>{
<expr_stmt><expr><call><name>INBYTE</name><argument_list>(<argument><expr><name>in_byte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>in_byte</name> == <name>RUNCHAR</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>INBYTE</name><argument_list>(<argument><expr><name>in_repeat</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>( <expr><name>in_repeat</name> == 0</expr> )</condition><then> <block>{
<expr_stmt><expr><call><name>OUTBYTE</name><argument_list>(<argument><expr><name>RUNCHAR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr><name>in_byte</name> = <name><name>out_data</name><index>[<expr>-1</expr>]</index></name></expr>;</expr_stmt>
<while>while <condition>( <expr>--<name>in_repeat</name> &gt; 0</expr> )</condition>
<expr_stmt><expr><call><name>OUTBYTE</name><argument_list>(<argument><expr><name>in_byte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></while>
}</block></else></if>
}</block></then> <else>else <block>{
<expr_stmt><expr><call><name>OUTBYTE</name><argument_list>(<argument><expr><name>in_byte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></else></if>
}</block></while>
<expr_stmt><expr><call><name>_PyString_Resize</name><argument_list>(<argument><expr>&amp;<name>rv</name></expr></argument>, <argument><expr>(<name>out_data</name> -
(<name>unsigned</name> <name>char</name> *)<call><name>PyString_AsString</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>rv</name></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>doc_crc_hqx</name></expr></argument>,
<argument><expr>"(data, oldcrc) -&gt; newcrc. Compute hqx CRC incrementally"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>binascii_crc_hqx</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>unsigned</name> <name>char</name> *</type><name>bin_data</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>crc</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>len</name></decl>;</decl_stmt>
<if>if <condition>( <expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"s#i:crc_hqx"</expr></argument>, <argument><expr>&amp;<name>bin_data</name></expr></argument>, <argument><expr>&amp;<name>len</name></expr></argument>, <argument><expr>&amp;<name>crc</name></expr></argument>)</argument_list></call></expr> )</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<while>while<condition>(<expr><name>len</name>-- &gt; 0</expr>)</condition> <block>{
<expr_stmt><expr><name>crc</name>=((<name>crc</name>&lt;&lt;8)&amp;0xff00)^<name><name>crctab_hqx</name><index>[<expr>((<name>crc</name>&gt;&gt;8)&amp;0xff)^*<name>bin_data</name>++</expr>]</index></name></expr>;</expr_stmt>
}</block></while>
<return>return <expr><call><name>Py_BuildValue</name><argument_list>(<argument><expr>"i"</expr></argument>, <argument><expr><name>crc</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>doc_crc32</name></expr></argument>,
<argument><expr>"(data, oldcrc = 0) -&gt; newcrc. Compute CRC-32 incrementally"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>USE_ZLIB_CRC32</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>binascii_crc32</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>crc32val</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Byte</name> *</type><name>buf</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>len</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>signed_val</name></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"s#|I:crc32"</expr></argument>, <argument><expr>&amp;<name>buf</name></expr></argument>, <argument><expr>&amp;<name>len</name></expr></argument>, <argument><expr>&amp;<name>crc32val</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>signed_val</name> = <call><name>crc32</name><argument_list>(<argument><expr><name>crc32val</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>PyInt_FromLong</name><argument_list>(<argument><expr><name>signed_val</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<decl_stmt><decl><type><specifier>static</specifier> <name>unsigned</name> <name>int</name></type> <name><name>crc_32_tab</name><index>[<expr>256</expr>]</index></name> <init>= <expr><block>{
<expr>0x00000000U</expr>, <expr>0x77073096U</expr>, <expr>0xee0e612cU</expr>, <expr>0x990951baU</expr>, <expr>0x076dc419U</expr>,
<expr>0x706af48fU</expr>, <expr>0xe963a535U</expr>, <expr>0x9e6495a3U</expr>, <expr>0x0edb8832U</expr>, <expr>0x79dcb8a4U</expr>,
<expr>0xe0d5e91eU</expr>, <expr>0x97d2d988U</expr>, <expr>0x09b64c2bU</expr>, <expr>0x7eb17cbdU</expr>, <expr>0xe7b82d07U</expr>,
<expr>0x90bf1d91U</expr>, <expr>0x1db71064U</expr>, <expr>0x6ab020f2U</expr>, <expr>0xf3b97148U</expr>, <expr>0x84be41deU</expr>,
<expr>0x1adad47dU</expr>, <expr>0x6ddde4ebU</expr>, <expr>0xf4d4b551U</expr>, <expr>0x83d385c7U</expr>, <expr>0x136c9856U</expr>,
<expr>0x646ba8c0U</expr>, <expr>0xfd62f97aU</expr>, <expr>0x8a65c9ecU</expr>, <expr>0x14015c4fU</expr>, <expr>0x63066cd9U</expr>,
<expr>0xfa0f3d63U</expr>, <expr>0x8d080df5U</expr>, <expr>0x3b6e20c8U</expr>, <expr>0x4c69105eU</expr>, <expr>0xd56041e4U</expr>,
<expr>0xa2677172U</expr>, <expr>0x3c03e4d1U</expr>, <expr>0x4b04d447U</expr>, <expr>0xd20d85fdU</expr>, <expr>0xa50ab56bU</expr>,
<expr>0x35b5a8faU</expr>, <expr>0x42b2986cU</expr>, <expr>0xdbbbc9d6U</expr>, <expr>0xacbcf940U</expr>, <expr>0x32d86ce3U</expr>,
<expr>0x45df5c75U</expr>, <expr>0xdcd60dcfU</expr>, <expr>0xabd13d59U</expr>, <expr>0x26d930acU</expr>, <expr>0x51de003aU</expr>,
<expr>0xc8d75180U</expr>, <expr>0xbfd06116U</expr>, <expr>0x21b4f4b5U</expr>, <expr>0x56b3c423U</expr>, <expr>0xcfba9599U</expr>,
<expr>0xb8bda50fU</expr>, <expr>0x2802b89eU</expr>, <expr>0x5f058808U</expr>, <expr>0xc60cd9b2U</expr>, <expr>0xb10be924U</expr>,
<expr>0x2f6f7c87U</expr>, <expr>0x58684c11U</expr>, <expr>0xc1611dabU</expr>, <expr>0xb6662d3dU</expr>, <expr>0x76dc4190U</expr>,
<expr>0x01db7106U</expr>, <expr>0x98d220bcU</expr>, <expr>0xefd5102aU</expr>, <expr>0x71b18589U</expr>, <expr>0x06b6b51fU</expr>,
<expr>0x9fbfe4a5U</expr>, <expr>0xe8b8d433U</expr>, <expr>0x7807c9a2U</expr>, <expr>0x0f00f934U</expr>, <expr>0x9609a88eU</expr>,
<expr>0xe10e9818U</expr>, <expr>0x7f6a0dbbU</expr>, <expr>0x086d3d2dU</expr>, <expr>0x91646c97U</expr>, <expr>0xe6635c01U</expr>,
<expr>0x6b6b51f4U</expr>, <expr>0x1c6c6162U</expr>, <expr>0x856530d8U</expr>, <expr>0xf262004eU</expr>, <expr>0x6c0695edU</expr>,
<expr>0x1b01a57bU</expr>, <expr>0x8208f4c1U</expr>, <expr>0xf50fc457U</expr>, <expr>0x65b0d9c6U</expr>, <expr>0x12b7e950U</expr>,
<expr>0x8bbeb8eaU</expr>, <expr>0xfcb9887cU</expr>, <expr>0x62dd1ddfU</expr>, <expr>0x15da2d49U</expr>, <expr>0x8cd37cf3U</expr>,
<expr>0xfbd44c65U</expr>, <expr>0x4db26158U</expr>, <expr>0x3ab551ceU</expr>, <expr>0xa3bc0074U</expr>, <expr>0xd4bb30e2U</expr>,
<expr>0x4adfa541U</expr>, <expr>0x3dd895d7U</expr>, <expr>0xa4d1c46dU</expr>, <expr>0xd3d6f4fbU</expr>, <expr>0x4369e96aU</expr>,
<expr>0x346ed9fcU</expr>, <expr>0xad678846U</expr>, <expr>0xda60b8d0U</expr>, <expr>0x44042d73U</expr>, <expr>0x33031de5U</expr>,
<expr>0xaa0a4c5fU</expr>, <expr>0xdd0d7cc9U</expr>, <expr>0x5005713cU</expr>, <expr>0x270241aaU</expr>, <expr>0xbe0b1010U</expr>,
<expr>0xc90c2086U</expr>, <expr>0x5768b525U</expr>, <expr>0x206f85b3U</expr>, <expr>0xb966d409U</expr>, <expr>0xce61e49fU</expr>,
<expr>0x5edef90eU</expr>, <expr>0x29d9c998U</expr>, <expr>0xb0d09822U</expr>, <expr>0xc7d7a8b4U</expr>, <expr>0x59b33d17U</expr>,
<expr>0x2eb40d81U</expr>, <expr>0xb7bd5c3bU</expr>, <expr>0xc0ba6cadU</expr>, <expr>0xedb88320U</expr>, <expr>0x9abfb3b6U</expr>,
<expr>0x03b6e20cU</expr>, <expr>0x74b1d29aU</expr>, <expr>0xead54739U</expr>, <expr>0x9dd277afU</expr>, <expr>0x04db2615U</expr>,
<expr>0x73dc1683U</expr>, <expr>0xe3630b12U</expr>, <expr>0x94643b84U</expr>, <expr>0x0d6d6a3eU</expr>, <expr>0x7a6a5aa8U</expr>,
<expr>0xe40ecf0bU</expr>, <expr>0x9309ff9dU</expr>, <expr>0x0a00ae27U</expr>, <expr>0x7d079eb1U</expr>, <expr>0xf00f9344U</expr>,
<expr>0x8708a3d2U</expr>, <expr>0x1e01f268U</expr>, <expr>0x6906c2feU</expr>, <expr>0xf762575dU</expr>, <expr>0x806567cbU</expr>,
<expr>0x196c3671U</expr>, <expr>0x6e6b06e7U</expr>, <expr>0xfed41b76U</expr>, <expr>0x89d32be0U</expr>, <expr>0x10da7a5aU</expr>,
<expr>0x67dd4accU</expr>, <expr>0xf9b9df6fU</expr>, <expr>0x8ebeeff9U</expr>, <expr>0x17b7be43U</expr>, <expr>0x60b08ed5U</expr>,
<expr>0xd6d6a3e8U</expr>, <expr>0xa1d1937eU</expr>, <expr>0x38d8c2c4U</expr>, <expr>0x4fdff252U</expr>, <expr>0xd1bb67f1U</expr>,
<expr>0xa6bc5767U</expr>, <expr>0x3fb506ddU</expr>, <expr>0x48b2364bU</expr>, <expr>0xd80d2bdaU</expr>, <expr>0xaf0a1b4cU</expr>,
<expr>0x36034af6U</expr>, <expr>0x41047a60U</expr>, <expr>0xdf60efc3U</expr>, <expr>0xa867df55U</expr>, <expr>0x316e8eefU</expr>,
<expr>0x4669be79U</expr>, <expr>0xcb61b38cU</expr>, <expr>0xbc66831aU</expr>, <expr>0x256fd2a0U</expr>, <expr>0x5268e236U</expr>,
<expr>0xcc0c7795U</expr>, <expr>0xbb0b4703U</expr>, <expr>0x220216b9U</expr>, <expr>0x5505262fU</expr>, <expr>0xc5ba3bbeU</expr>,
<expr>0xb2bd0b28U</expr>, <expr>0x2bb45a92U</expr>, <expr>0x5cb36a04U</expr>, <expr>0xc2d7ffa7U</expr>, <expr>0xb5d0cf31U</expr>,
<expr>0x2cd99e8bU</expr>, <expr>0x5bdeae1dU</expr>, <expr>0x9b64c2b0U</expr>, <expr>0xec63f226U</expr>, <expr>0x756aa39cU</expr>,
<expr>0x026d930aU</expr>, <expr>0x9c0906a9U</expr>, <expr>0xeb0e363fU</expr>, <expr>0x72076785U</expr>, <expr>0x05005713U</expr>,
<expr>0x95bf4a82U</expr>, <expr>0xe2b87a14U</expr>, <expr>0x7bb12baeU</expr>, <expr>0x0cb61b38U</expr>, <expr>0x92d28e9bU</expr>,
<expr>0xe5d5be0dU</expr>, <expr>0x7cdcefb7U</expr>, <expr>0x0bdbdf21U</expr>, <expr>0x86d3d2d4U</expr>, <expr>0xf1d4e242U</expr>,
<expr>0x68ddb3f8U</expr>, <expr>0x1fda836eU</expr>, <expr>0x81be16cdU</expr>, <expr>0xf6b9265bU</expr>, <expr>0x6fb077e1U</expr>,
<expr>0x18b74777U</expr>, <expr>0x88085ae6U</expr>, <expr>0xff0f6a70U</expr>, <expr>0x66063bcaU</expr>, <expr>0x11010b5cU</expr>,
<expr>0x8f659effU</expr>, <expr>0xf862ae69U</expr>, <expr>0x616bffd3U</expr>, <expr>0x166ccf45U</expr>, <expr>0xa00ae278U</expr>,
<expr>0xd70dd2eeU</expr>, <expr>0x4e048354U</expr>, <expr>0x3903b3c2U</expr>, <expr>0xa7672661U</expr>, <expr>0xd06016f7U</expr>,
<expr>0x4969474dU</expr>, <expr>0x3e6e77dbU</expr>, <expr>0xaed16a4aU</expr>, <expr>0xd9d65adcU</expr>, <expr>0x40df0b66U</expr>,
<expr>0x37d83bf0U</expr>, <expr>0xa9bcae53U</expr>, <expr>0xdebb9ec5U</expr>, <expr>0x47b2cf7fU</expr>, <expr>0x30b5ffe9U</expr>,
<expr>0xbdbdf21cU</expr>, <expr>0xcabac28aU</expr>, <expr>0x53b39330U</expr>, <expr>0x24b4a3a6U</expr>, <expr>0xbad03605U</expr>,
<expr>0xcdd70693U</expr>, <expr>0x54de5729U</expr>, <expr>0x23d967bfU</expr>, <expr>0xb3667a2eU</expr>, <expr>0xc4614ab8U</expr>,
<expr>0x5d681b02U</expr>, <expr>0x2a6f2b94U</expr>, <expr>0xb40bbe37U</expr>, <expr>0xc30c8ea1U</expr>, <expr>0x5a05df1bU</expr>,
<expr>0x2d02ef8dU</expr>
}</block></expr></init></decl>;</decl_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>binascii_crc32</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>unsigned</name> <name>char</name> *</type><name>bin_data</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>crc</name> <init>= <expr>0U</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>len</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>result</name></decl>;</decl_stmt>
<if>if <condition>( <expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"s#|I:crc32"</expr></argument>, <argument><expr>&amp;<name>bin_data</name></expr></argument>, <argument><expr>&amp;<name>len</name></expr></argument>, <argument><expr>&amp;<name>crc</name></expr></argument>)</argument_list></call></expr> )</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>crc</name> = ~ <name>crc</name></expr>;</expr_stmt>
<while>while <condition>(<expr><name>len</name>-- &gt; 0</expr>)</condition>
<expr_stmt><expr><name>crc</name> = <name><name>crc_32_tab</name><index>[<expr>(<name>crc</name> ^ *<name>bin_data</name>++) &amp; 0xffU</expr>]</index></name> ^ (<name>crc</name> &gt;&gt; 8)</expr>;</expr_stmt></while>
<expr_stmt><expr><name>result</name> = <call>(<name>int</name>)<argument_list>(<argument><expr><name>crc</name> ^ 0xFFFFFFFFU</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>PyInt_FromLong</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>binascii_hexlify</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>char</name>*</type> <name>argbuf</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>arglen</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>retval</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name>*</type> <name>retbuf</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"s#:b2a_hex"</expr></argument>, <argument><expr>&amp;<name>argbuf</name></expr></argument>, <argument><expr>&amp;<name>arglen</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>arglen</name> &gt;= 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>arglen</name> &gt; <name>PY_SSIZE_T_MAX</name> / 2</expr>)</condition><then>
<return>return <expr><call><name>PyErr_NoMemory</name><argument_list>()</argument_list></call></expr>;</return></then></if>
<expr_stmt><expr><name>retval</name> = <call><name>PyString_FromStringAndSize</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>arglen</name>*2</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>retval</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>retbuf</name> = <call><name>PyString_AsString</name><argument_list>(<argument><expr><name>retval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>retbuf</name></expr>)</condition><then>
<goto>goto <name>finally</name>;</goto></then></if>
<for>for (<init><expr><name>i</name>=<name>j</name>=0</expr>;</init> <condition><expr><name>i</name> &lt; <name>arglen</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
<decl_stmt><decl><type><name>char</name></type> <name>c</name></decl>;</decl_stmt>
<expr_stmt><expr><name>c</name> = (<name><name>argbuf</name><index>[<expr><name>i</name></expr>]</index></name> &gt;&gt; 4) &amp; 0xf</expr>;</expr_stmt>
<expr_stmt><expr><name>c</name> = (<name>c</name>&gt;9) ? <name>c</name>+'a'-10 : <name>c</name> + '0'</expr>;</expr_stmt>
<expr_stmt><expr><name><name>retbuf</name><index>[<expr><name>j</name>++</expr>]</index></name> = <name>c</name></expr>;</expr_stmt>
<expr_stmt><expr><name>c</name> = <name><name>argbuf</name><index>[<expr><name>i</name></expr>]</index></name> &amp; 0xf</expr>;</expr_stmt>
<expr_stmt><expr><name>c</name> = (<name>c</name>&gt;9) ? <name>c</name>+'a'-10 : <name>c</name> + '0'</expr>;</expr_stmt>
<expr_stmt><expr><name><name>retbuf</name><index>[<expr><name>j</name>++</expr>]</index></name> = <name>c</name></expr>;</expr_stmt>
}</block></for>
<return>return <expr><name>retval</name></expr>;</return>
<label><name>finally</name>:</label>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>retval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>doc_hexlify</name></expr></argument>,
<argument><expr>"b2a_hex(data) -&gt; s; Hexadecimal representation of binary data.\n\
\n\
This function is also available as \"hexlify()\"."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>to_int</name><parameter_list>(<param><decl><type><name>int</name></type> <name>c</name></decl></param>)</parameter_list> <block>{
<if>if <condition>(<expr><call><name>isdigit</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>c</name> - '0'</expr>;</return></then>
<else>else <block>{
<if>if <condition>(<expr><call><name>isupper</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<expr_stmt><expr><name>c</name> = <call><name>tolower</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<if>if <condition>(<expr><name>c</name> &gt;= 'a' &amp;&amp; <name>c</name> &lt;= 'f'</expr>)</condition><then>
<return>return <expr><name>c</name> - 'a' + 10</expr>;</return></then></if>
}</block></else></if>
<return>return <expr>-1</expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>binascii_unhexlify</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>char</name>*</type> <name>argbuf</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>arglen</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>retval</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name>*</type> <name>retbuf</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"s#:a2b_hex"</expr></argument>, <argument><expr>&amp;<name>argbuf</name></expr></argument>, <argument><expr>&amp;<name>arglen</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>arglen</name> &gt;= 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>arglen</name> % 2</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>, <argument><expr>"Odd-length string"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>retval</name> = <call><name>PyString_FromStringAndSize</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr>(<name>arglen</name>/2)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>retval</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>retbuf</name> = <call><name>PyString_AsString</name><argument_list>(<argument><expr><name>retval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>retbuf</name></expr>)</condition><then>
<goto>goto <name>finally</name>;</goto></then></if>
<for>for (<init><expr><name>i</name>=<name>j</name>=0</expr>;</init> <condition><expr><name>i</name> &lt; <name>arglen</name></expr>;</condition> <incr><expr><name>i</name> += 2</expr></incr>) <block>{
<decl_stmt><decl><type><name>int</name></type> <name>top</name> <init>= <expr><call><name>to_int</name><argument_list>(<argument><expr><call><name>Py_CHARMASK</name><argument_list>(<argument><expr><name><name>argbuf</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>bot</name> <init>= <expr><call><name>to_int</name><argument_list>(<argument><expr><call><name>Py_CHARMASK</name><argument_list>(<argument><expr><name><name>argbuf</name><index>[<expr><name>i</name>+1</expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>top</name> == -1 || <name>bot</name> == -1</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
<argument><expr>"Non-hexadecimal digit found"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>finally</name>;</goto>
}</block></then></if>
<expr_stmt><expr><name><name>retbuf</name><index>[<expr><name>j</name>++</expr>]</index></name> = (<name>top</name> &lt;&lt; 4) + <name>bot</name></expr>;</expr_stmt>
}</block></for>
<return>return <expr><name>retval</name></expr>;</return>
<label><name>finally</name>:</label>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>retval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>doc_unhexlify</name></expr></argument>,
<argument><expr>"a2b_hex(hexstr) -&gt; s; Binary data of hexadecimal representation.\n\
\n\
hexstr must contain an even number of hex digits (upper or lower case).\n\
This function is also available as \"unhexlify()\""</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name><name>table_hex</name><index>[<expr>128</expr>]</index></name> <init>= <expr><block>{
<expr>-1</expr>,<expr>-1</expr>,<expr>-1</expr>,<expr>-1</expr>, <expr>-1</expr>,<expr>-1</expr>,<expr>-1</expr>,<expr>-1</expr>, <expr>-1</expr>,<expr>-1</expr>,<expr>-1</expr>,<expr>-1</expr>, <expr>-1</expr>,<expr>-1</expr>,<expr>-1</expr>,<expr>-1</expr>,
<expr>-1</expr>,<expr>-1</expr>,<expr>-1</expr>,<expr>-1</expr>, <expr>-1</expr>,<expr>-1</expr>,<expr>-1</expr>,<expr>-1</expr>, <expr>-1</expr>,<expr>-1</expr>,<expr>-1</expr>,<expr>-1</expr>, <expr>-1</expr>,<expr>-1</expr>,<expr>-1</expr>,<expr>-1</expr>,
<expr>-1</expr>,<expr>-1</expr>,<expr>-1</expr>,<expr>-1</expr>, <expr>-1</expr>,<expr>-1</expr>,<expr>-1</expr>,<expr>-1</expr>, <expr>-1</expr>,<expr>-1</expr>,<expr>-1</expr>,<expr>-1</expr>, <expr>-1</expr>,<expr>-1</expr>,<expr>-1</expr>,<expr>-1</expr>,
<expr>0</expr>, <expr>1</expr>, <expr>2</expr>, <expr>3</expr>, <expr>4</expr>, <expr>5</expr>, <expr>6</expr>, <expr>7</expr>, <expr>8</expr>, <expr>9</expr>,<expr>-1</expr>,<expr>-1</expr>, <expr>-1</expr>,<expr>-1</expr>,<expr>-1</expr>,<expr>-1</expr>,
<expr>-1</expr>,<expr>10</expr>,<expr>11</expr>,<expr>12</expr>, <expr>13</expr>,<expr>14</expr>,<expr>15</expr>,<expr>-1</expr>, <expr>-1</expr>,<expr>-1</expr>,<expr>-1</expr>,<expr>-1</expr>, <expr>-1</expr>,<expr>-1</expr>,<expr>-1</expr>,<expr>-1</expr>,
<expr>-1</expr>,<expr>-1</expr>,<expr>-1</expr>,<expr>-1</expr>, <expr>-1</expr>,<expr>-1</expr>,<expr>-1</expr>,<expr>-1</expr>, <expr>-1</expr>,<expr>-1</expr>,<expr>-1</expr>,<expr>-1</expr>, <expr>-1</expr>,<expr>-1</expr>,<expr>-1</expr>,<expr>-1</expr>,
<expr>-1</expr>,<expr>10</expr>,<expr>11</expr>,<expr>12</expr>, <expr>13</expr>,<expr>14</expr>,<expr>15</expr>,<expr>-1</expr>, <expr>-1</expr>,<expr>-1</expr>,<expr>-1</expr>,<expr>-1</expr>, <expr>-1</expr>,<expr>-1</expr>,<expr>-1</expr>,<expr>-1</expr>,
<expr>-1</expr>,<expr>-1</expr>,<expr>-1</expr>,<expr>-1</expr>, <expr>-1</expr>,<expr>-1</expr>,<expr>-1</expr>,<expr>-1</expr>, <expr>-1</expr>,<expr>-1</expr>,<expr>-1</expr>,<expr>-1</expr>, <expr>-1</expr>,<expr>-1</expr>,<expr>-1</expr>,<expr>-1</expr>
}</block></expr></init></decl>;</decl_stmt>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>hexval</name><parameter_list>(<param><type><name>c</name></type></param>)</parameter_list></cpp:macro> <cpp:value>table_hex[(unsigned int)(c)]</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAXLINESIZE</name></cpp:macro> <cpp:value>76</cpp:value></cpp:define>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>doc_a2b_qp</name></expr></argument>, <argument><expr>"Decode a string of qp-encoded data"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name>*</type>
<name>binascii_a2b_qp</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>kwargs</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>in</name></decl>, <decl><type ref="prev"/><name>out</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name>ch</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name> *</type><name>data</name></decl>, *<decl><type ref="prev"/><name>odata</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>datalen</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>rv</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> *</type><name><name>kwlist</name><index>[]</index></name> <init>= <expr><block>{<expr>"data"</expr>, <expr>"header"</expr>, <expr><name>NULL</name></expr>}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>header</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTupleAndKeywords</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>kwargs</name></expr></argument>, <argument><expr>"s#|i"</expr></argument>, <argument><expr><name>kwlist</name></expr></argument>, <argument><expr>&amp;<name>data</name></expr></argument>,
<argument><expr>&amp;<name>datalen</name></expr></argument>, <argument><expr>&amp;<name>header</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>odata</name> = (<name>unsigned</name> <name>char</name> *) <call><name>PyMem_Malloc</name><argument_list>(<argument><expr><name>datalen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>odata</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_NoMemory</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>odata</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>datalen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>in</name> = <name>out</name> = 0</expr>;</expr_stmt>
<while>while <condition>(<expr><name>in</name> &lt; <name>datalen</name></expr>)</condition> <block>{
<if>if <condition>(<expr><name><name>data</name><index>[<expr><name>in</name></expr>]</index></name> == '='</expr>)</condition><then> <block>{
<expr_stmt><expr><name>in</name>++</expr>;</expr_stmt>
<if>if <condition>(<expr><name>in</name> &gt;= <name>datalen</name></expr>)</condition><then> <break>break;</break></then></if>
<if>if <condition>(<expr>(<name><name>data</name><index>[<expr><name>in</name></expr>]</index></name> == '\n') || (<name><name>data</name><index>[<expr><name>in</name></expr>]</index></name> == '\r')</expr>)</condition><then> <block>{
<if>if <condition>(<expr><name><name>data</name><index>[<expr><name>in</name></expr>]</index></name> != '\n'</expr>)</condition><then> <block>{
<while>while <condition>(<expr><name>in</name> &lt; <name>datalen</name> &amp;&amp; <name><name>data</name><index>[<expr><name>in</name></expr>]</index></name> != '\n'</expr>)</condition> <expr_stmt><expr><name>in</name>++</expr>;</expr_stmt></while>
}</block></then></if>
<if>if <condition>(<expr><name>in</name> &lt; <name>datalen</name></expr>)</condition><then> <expr_stmt><expr><name>in</name>++</expr>;</expr_stmt></then></if>
}</block></then> <else>else <if>if <condition>(<expr><name><name>data</name><index>[<expr><name>in</name></expr>]</index></name> == '='</expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>odata</name><index>[<expr><name>out</name>++</expr>]</index></name> = '='</expr>;</expr_stmt>
<expr_stmt><expr><name>in</name>++</expr>;</expr_stmt>
}</block></then> <else>else <if>if <condition>(<expr>((<name><name>data</name><index>[<expr><name>in</name></expr>]</index></name> &gt;= 'A' &amp;&amp; <name><name>data</name><index>[<expr><name>in</name></expr>]</index></name> &lt;= 'F') ||
(<name><name>data</name><index>[<expr><name>in</name></expr>]</index></name> &gt;= 'a' &amp;&amp; <name><name>data</name><index>[<expr><name>in</name></expr>]</index></name> &lt;= 'f') ||
(<name><name>data</name><index>[<expr><name>in</name></expr>]</index></name> &gt;= '0' &amp;&amp; <name><name>data</name><index>[<expr><name>in</name></expr>]</index></name> &lt;= '9')) &amp;&amp;
((<name><name>data</name><index>[<expr><name>in</name>+1</expr>]</index></name> &gt;= 'A' &amp;&amp; <name><name>data</name><index>[<expr><name>in</name>+1</expr>]</index></name> &lt;= 'F') ||
(<name><name>data</name><index>[<expr><name>in</name>+1</expr>]</index></name> &gt;= 'a' &amp;&amp; <name><name>data</name><index>[<expr><name>in</name>+1</expr>]</index></name> &lt;= 'f') ||
(<name><name>data</name><index>[<expr><name>in</name>+1</expr>]</index></name> &gt;= '0' &amp;&amp; <name><name>data</name><index>[<expr><name>in</name>+1</expr>]</index></name> &lt;= '9'))</expr>)</condition><then> <block>{
<expr_stmt><expr><name>ch</name> = <call><name>hexval</name><argument_list>(<argument><expr><name><name>data</name><index>[<expr><name>in</name></expr>]</index></name></expr></argument>)</argument_list></call> &lt;&lt; 4</expr>;</expr_stmt>
<expr_stmt><expr><name>in</name>++</expr>;</expr_stmt>
<expr_stmt><expr><name>ch</name> |= <call><name>hexval</name><argument_list>(<argument><expr><name><name>data</name><index>[<expr><name>in</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>in</name>++</expr>;</expr_stmt>
<expr_stmt><expr><name><name>odata</name><index>[<expr><name>out</name>++</expr>]</index></name> = <name>ch</name></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr><name><name>odata</name><index>[<expr><name>out</name>++</expr>]</index></name> = '='</expr>;</expr_stmt>
}</block></else></if></else></if></else></if>
}</block></then> <else>else <if>if <condition>(<expr><name>header</name> &amp;&amp; <name><name>data</name><index>[<expr><name>in</name></expr>]</index></name> == '_'</expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>odata</name><index>[<expr><name>out</name>++</expr>]</index></name> = ' '</expr>;</expr_stmt>
<expr_stmt><expr><name>in</name>++</expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr><name><name>odata</name><index>[<expr><name>out</name></expr>]</index></name> = <name><name>data</name><index>[<expr><name>in</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name>in</name>++</expr>;</expr_stmt>
<expr_stmt><expr><name>out</name>++</expr>;</expr_stmt>
}</block></else></if></else></if>
}</block></while>
<if>if <condition>(<expr>(<name>rv</name> = <call><name>PyString_FromStringAndSize</name><argument_list>(<argument><expr>(<name>char</name> *)<name>odata</name></expr></argument>, <argument><expr><name>out</name></expr></argument>)</argument_list></call>) == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyMem_Free</name><argument_list>(<argument><expr><name>odata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><call><name>PyMem_Free</name><argument_list>(<argument><expr><name>odata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>rv</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>to_hex</name> <parameter_list>(<param><decl><type><name>unsigned</name> <name>char</name></type> <name>ch</name></decl></param>, <param><decl><type><name>unsigned</name> <name>char</name> *</type><name>s</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>uvalue</name> <init>= <expr><name>ch</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>s</name><index>[<expr>1</expr>]</index></name> = "0123456789ABCDEF"<index>[<expr><name>uvalue</name> % 16</expr>]</index></expr>;</expr_stmt>
<expr_stmt><expr><name>uvalue</name> = (<name>uvalue</name> / 16)</expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><index>[<expr>0</expr>]</index></name> = "0123456789ABCDEF"<index>[<expr><name>uvalue</name> % 16</expr>]</index></expr>;</expr_stmt>
<return>return <expr>0</expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>doc_b2a_qp</name></expr></argument>,
<argument><expr>"b2a_qp(data, quotetabs=0, istext=1, header=0) -&gt; s; \n\
Encode a string using quoted-printable encoding. \n\
\n\
On encoding, when istext is set, newlines are not encoded, and white \n\
space at end of lines is. When istext is not set, \\r and \\n (CR/LF) are \n\
both encoded. When quotetabs is set, space and tabs are encoded."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name>*</type>
<name>binascii_b2a_qp</name> <parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>kwargs</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>in</name></decl>, <decl><type ref="prev"/><name>out</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name> *</type><name>data</name></decl>, *<decl><type ref="prev"/><name>odata</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>datalen</name> <init>= <expr>0</expr></init>, <name>odatalen</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>rv</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>linelen</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> *</type><name><name>kwlist</name><index>[]</index></name> <init>= <expr><block>{<expr>"data"</expr>, <expr>"quotetabs"</expr>, <expr>"istext"</expr>,
<expr>"header"</expr>, <expr><name>NULL</name></expr>
}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>istext</name> <init>= <expr>1</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>quotetabs</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>header</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name>ch</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>crlf</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name> *</type><name>p</name></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTupleAndKeywords</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>kwargs</name></expr></argument>, <argument><expr>"s#|iii"</expr></argument>, <argument><expr><name>kwlist</name></expr></argument>, <argument><expr>&amp;<name>data</name></expr></argument>,
<argument><expr>&amp;<name>datalen</name></expr></argument>, <argument><expr>&amp;<name>quotetabs</name></expr></argument>, <argument><expr>&amp;<name>istext</name></expr></argument>, <argument><expr>&amp;<name>header</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>p</name> = (<name>unsigned</name> <name>char</name> *) <call><name>memchr</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr>'\n'</expr></argument>, <argument><expr><name>datalen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>(<name>p</name> != <name>NULL</name>) &amp;&amp; (<name>p</name> &gt; <name>data</name>) &amp;&amp; (*(<name>p</name>-1) == '\r')</expr>)</condition><then>
<expr_stmt><expr><name>crlf</name> = 1</expr>;</expr_stmt></then></if>
<expr_stmt><expr><name>in</name> = 0</expr>;</expr_stmt>
<while>while <condition>(<expr><name>in</name> &lt; <name>datalen</name></expr>)</condition> <block>{
<if>if <condition>(<expr>(<name><name>data</name><index>[<expr><name>in</name></expr>]</index></name> &gt; 126) ||
(<name><name>data</name><index>[<expr><name>in</name></expr>]</index></name> == '=') ||
(<name>header</name> &amp;&amp; <name><name>data</name><index>[<expr><name>in</name></expr>]</index></name> == '_') ||
((<name><name>data</name><index>[<expr><name>in</name></expr>]</index></name> == '.') &amp;&amp; (<name>linelen</name> == 0) &amp;&amp;
(<name><name>data</name><index>[<expr><name>in</name>+1</expr>]</index></name> == '\n' || <name><name>data</name><index>[<expr><name>in</name>+1</expr>]</index></name> == '\r' || <name><name>data</name><index>[<expr><name>in</name>+1</expr>]</index></name> == 0)) ||
(!<name>istext</name> &amp;&amp; ((<name><name>data</name><index>[<expr><name>in</name></expr>]</index></name> == '\r') || (<name><name>data</name><index>[<expr><name>in</name></expr>]</index></name> == '\n'))) ||
((<name><name>data</name><index>[<expr><name>in</name></expr>]</index></name> == '\t' || <name><name>data</name><index>[<expr><name>in</name></expr>]</index></name> == ' ') &amp;&amp; (<name>in</name> + 1 == <name>datalen</name>)) ||
((<name><name>data</name><index>[<expr><name>in</name></expr>]</index></name> &lt; 33) &amp;&amp;
(<name><name>data</name><index>[<expr><name>in</name></expr>]</index></name> != '\r') &amp;&amp; (<name><name>data</name><index>[<expr><name>in</name></expr>]</index></name> != '\n') &amp;&amp;
(<name>quotetabs</name> ||
(!<name>quotetabs</name> &amp;&amp; ((<name><name>data</name><index>[<expr><name>in</name></expr>]</index></name> != '\t') &amp;&amp; (<name><name>data</name><index>[<expr><name>in</name></expr>]</index></name> != ' ')))))</expr>)</condition><then> <block>{
<if>if <condition>(<expr>(<name>linelen</name> + 3) &gt;= <name>MAXLINESIZE</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>linelen</name> = 0</expr>;</expr_stmt>
<if>if <condition>(<expr><name>crlf</name></expr>)</condition><then>
<expr_stmt><expr><name>odatalen</name> += 3</expr>;</expr_stmt></then>
<else>else
<expr_stmt><expr><name>odatalen</name> += 2</expr>;</expr_stmt></else></if>
}</block></then></if>
<expr_stmt><expr><name>linelen</name> += 3</expr>;</expr_stmt>
<expr_stmt><expr><name>odatalen</name> += 3</expr>;</expr_stmt>
<expr_stmt><expr><name>in</name>++</expr>;</expr_stmt>
}</block></then> <else>else <block>{
<if>if <condition>(<expr><name>istext</name> &amp;&amp;
((<name><name>data</name><index>[<expr><name>in</name></expr>]</index></name> == '\n') ||
((<name>in</name>+1 &lt; <name>datalen</name>) &amp;&amp; (<name><name>data</name><index>[<expr><name>in</name></expr>]</index></name> == '\r') &amp;&amp;
(<name><name>data</name><index>[<expr><name>in</name>+1</expr>]</index></name> == '\n')))</expr>)</condition><then> <block>{
<expr_stmt><expr><name>linelen</name> = 0</expr>;</expr_stmt>
<if>if <condition>(<expr><name>in</name> &amp;&amp; ((<name><name>data</name><index>[<expr><name>in</name>-1</expr>]</index></name> == ' ') || (<name><name>data</name><index>[<expr><name>in</name>-1</expr>]</index></name> == '\t'))</expr>)</condition><then>
<expr_stmt><expr><name>odatalen</name> += 2</expr>;</expr_stmt></then></if>
<if>if <condition>(<expr><name>crlf</name></expr>)</condition><then>
<expr_stmt><expr><name>odatalen</name> += 2</expr>;</expr_stmt></then>
<else>else
<expr_stmt><expr><name>odatalen</name> += 1</expr>;</expr_stmt></else></if>
<if>if <condition>(<expr><name><name>data</name><index>[<expr><name>in</name></expr>]</index></name> == '\r'</expr>)</condition><then>
<expr_stmt><expr><name>in</name> += 2</expr>;</expr_stmt></then>
<else>else
<expr_stmt><expr><name>in</name>++</expr>;</expr_stmt></else></if>
}</block></then> <else>else <block>{
<if>if <condition>(<expr>(<name>in</name> + 1 != <name>datalen</name>) &amp;&amp;
(<name><name>data</name><index>[<expr><name>in</name>+1</expr>]</index></name> != '\n') &amp;&amp;
(<name>linelen</name> + 1) &gt;= <name>MAXLINESIZE</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>linelen</name> = 0</expr>;</expr_stmt>
<if>if <condition>(<expr><name>crlf</name></expr>)</condition><then>
<expr_stmt><expr><name>odatalen</name> += 3</expr>;</expr_stmt></then>
<else>else
<expr_stmt><expr><name>odatalen</name> += 2</expr>;</expr_stmt></else></if>
}</block></then></if>
<expr_stmt><expr><name>linelen</name>++</expr>;</expr_stmt>
<expr_stmt><expr><name>odatalen</name>++</expr>;</expr_stmt>
<expr_stmt><expr><name>in</name>++</expr>;</expr_stmt>
}</block></else></if>
}</block></else></if>
}</block></while>
<expr_stmt><expr><name>odata</name> = (<name>unsigned</name> <name>char</name> *) <call><name>PyMem_Malloc</name><argument_list>(<argument><expr><name>odatalen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>odata</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_NoMemory</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>odata</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>odatalen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>in</name> = <name>out</name> = <name>linelen</name> = 0</expr>;</expr_stmt>
<while>while <condition>(<expr><name>in</name> &lt; <name>datalen</name></expr>)</condition> <block>{
<if>if <condition>(<expr>(<name><name>data</name><index>[<expr><name>in</name></expr>]</index></name> &gt; 126) ||
(<name><name>data</name><index>[<expr><name>in</name></expr>]</index></name> == '=') ||
(<name>header</name> &amp;&amp; <name><name>data</name><index>[<expr><name>in</name></expr>]</index></name> == '_') ||
((<name><name>data</name><index>[<expr><name>in</name></expr>]</index></name> == '.') &amp;&amp; (<name>linelen</name> == 0) &amp;&amp;
(<name><name>data</name><index>[<expr><name>in</name>+1</expr>]</index></name> == '\n' || <name><name>data</name><index>[<expr><name>in</name>+1</expr>]</index></name> == '\r' || <name><name>data</name><index>[<expr><name>in</name>+1</expr>]</index></name> == 0)) ||
(!<name>istext</name> &amp;&amp; ((<name><name>data</name><index>[<expr><name>in</name></expr>]</index></name> == '\r') || (<name><name>data</name><index>[<expr><name>in</name></expr>]</index></name> == '\n'))) ||
((<name><name>data</name><index>[<expr><name>in</name></expr>]</index></name> == '\t' || <name><name>data</name><index>[<expr><name>in</name></expr>]</index></name> == ' ') &amp;&amp; (<name>in</name> + 1 == <name>datalen</name>)) ||
((<name><name>data</name><index>[<expr><name>in</name></expr>]</index></name> &lt; 33) &amp;&amp;
(<name><name>data</name><index>[<expr><name>in</name></expr>]</index></name> != '\r') &amp;&amp; (<name><name>data</name><index>[<expr><name>in</name></expr>]</index></name> != '\n') &amp;&amp;
(<name>quotetabs</name> ||
(!<name>quotetabs</name> &amp;&amp; ((<name><name>data</name><index>[<expr><name>in</name></expr>]</index></name> != '\t') &amp;&amp; (<name><name>data</name><index>[<expr><name>in</name></expr>]</index></name> != ' ')))))</expr>)</condition><then> <block>{
<if>if <condition>(<expr>(<name>linelen</name> + 3 )&gt;= <name>MAXLINESIZE</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>odata</name><index>[<expr><name>out</name>++</expr>]</index></name> = '='</expr>;</expr_stmt>
<if>if <condition>(<expr><name>crlf</name></expr>)</condition><then> <expr_stmt><expr><name><name>odata</name><index>[<expr><name>out</name>++</expr>]</index></name> = '\r'</expr>;</expr_stmt></then></if>
<expr_stmt><expr><name><name>odata</name><index>[<expr><name>out</name>++</expr>]</index></name> = '\n'</expr>;</expr_stmt>
<expr_stmt><expr><name>linelen</name> = 0</expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><name><name>odata</name><index>[<expr><name>out</name>++</expr>]</index></name> = '='</expr>;</expr_stmt>
<expr_stmt><expr><call><name>to_hex</name><argument_list>(<argument><expr><name><name>data</name><index>[<expr><name>in</name></expr>]</index></name></expr></argument>, <argument><expr>&amp;<name><name>odata</name><index>[<expr><name>out</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>out</name> += 2</expr>;</expr_stmt>
<expr_stmt><expr><name>in</name>++</expr>;</expr_stmt>
<expr_stmt><expr><name>linelen</name> += 3</expr>;</expr_stmt>
}</block></then> <else>else <block>{
<if>if <condition>(<expr><name>istext</name> &amp;&amp;
((<name><name>data</name><index>[<expr><name>in</name></expr>]</index></name> == '\n') ||
((<name>in</name>+1 &lt; <name>datalen</name>) &amp;&amp; (<name><name>data</name><index>[<expr><name>in</name></expr>]</index></name> == '\r') &amp;&amp;
(<name><name>data</name><index>[<expr><name>in</name>+1</expr>]</index></name> == '\n')))</expr>)</condition><then> <block>{
<expr_stmt><expr><name>linelen</name> = 0</expr>;</expr_stmt>
<if>if <condition>(<expr><name>out</name> &amp;&amp; ((<name><name>odata</name><index>[<expr><name>out</name>-1</expr>]</index></name> == ' ') || (<name><name>odata</name><index>[<expr><name>out</name>-1</expr>]</index></name> == '\t'))</expr>)</condition><then> <block>{
<expr_stmt><expr><name>ch</name> = <name><name>odata</name><index>[<expr><name>out</name>-1</expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>odata</name><index>[<expr><name>out</name>-1</expr>]</index></name> = '='</expr>;</expr_stmt>
<expr_stmt><expr><call><name>to_hex</name><argument_list>(<argument><expr><name>ch</name></expr></argument>, <argument><expr>&amp;<name><name>odata</name><index>[<expr><name>out</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>out</name> += 2</expr>;</expr_stmt>
}</block></then></if>
<if>if <condition>(<expr><name>crlf</name></expr>)</condition><then> <expr_stmt><expr><name><name>odata</name><index>[<expr><name>out</name>++</expr>]</index></name> = '\r'</expr>;</expr_stmt></then></if>
<expr_stmt><expr><name><name>odata</name><index>[<expr><name>out</name>++</expr>]</index></name> = '\n'</expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>data</name><index>[<expr><name>in</name></expr>]</index></name> == '\r'</expr>)</condition><then>
<expr_stmt><expr><name>in</name> += 2</expr>;</expr_stmt></then>
<else>else
<expr_stmt><expr><name>in</name>++</expr>;</expr_stmt></else></if>
}</block></then> <else>else <block>{
<if>if <condition>(<expr>(<name>in</name> + 1 != <name>datalen</name>) &amp;&amp;
(<name><name>data</name><index>[<expr><name>in</name>+1</expr>]</index></name> != '\n') &amp;&amp;
(<name>linelen</name> + 1) &gt;= <name>MAXLINESIZE</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>odata</name><index>[<expr><name>out</name>++</expr>]</index></name> = '='</expr>;</expr_stmt>
<if>if <condition>(<expr><name>crlf</name></expr>)</condition><then> <expr_stmt><expr><name><name>odata</name><index>[<expr><name>out</name>++</expr>]</index></name> = '\r'</expr>;</expr_stmt></then></if>
<expr_stmt><expr><name><name>odata</name><index>[<expr><name>out</name>++</expr>]</index></name> = '\n'</expr>;</expr_stmt>
<expr_stmt><expr><name>linelen</name> = 0</expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><name>linelen</name>++</expr>;</expr_stmt>
<if>if <condition>(<expr><name>header</name> &amp;&amp; <name><name>data</name><index>[<expr><name>in</name></expr>]</index></name> == ' '</expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>odata</name><index>[<expr><name>out</name>++</expr>]</index></name> = '_'</expr>;</expr_stmt>
<expr_stmt><expr><name>in</name>++</expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr><name><name>odata</name><index>[<expr><name>out</name>++</expr>]</index></name> = <name><name>data</name><index>[<expr><name>in</name>++</expr>]</index></name></expr>;</expr_stmt>
}</block></else></if>
}</block></else></if>
}</block></else></if>
}</block></while>
<if>if <condition>(<expr>(<name>rv</name> = <call><name>PyString_FromStringAndSize</name><argument_list>(<argument><expr>(<name>char</name> *)<name>odata</name></expr></argument>, <argument><expr><name>out</name></expr></argument>)</argument_list></call>) == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyMem_Free</name><argument_list>(<argument><expr><name>odata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><call><name>PyMem_Free</name><argument_list>(<argument><expr><name>odata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>rv</name></expr>;</return>
}</block></function>
<decl_stmt><decl><type><specifier>static</specifier> struct <name>PyMethodDef</name></type> <name><name>binascii_module_methods</name><index>[]</index></name> <init>= <expr><block>{
<expr><block>{<expr>"a2b_uu"</expr>, <expr><name>binascii_a2b_uu</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>doc_a2b_uu</name></expr>}</block></expr>,
<expr><block>{<expr>"b2a_uu"</expr>, <expr><name>binascii_b2a_uu</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>doc_b2a_uu</name></expr>}</block></expr>,
<expr><block>{<expr>"a2b_base64"</expr>, <expr><name>binascii_a2b_base64</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>doc_a2b_base64</name></expr>}</block></expr>,
<expr><block>{<expr>"b2a_base64"</expr>, <expr><name>binascii_b2a_base64</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>doc_b2a_base64</name></expr>}</block></expr>,
<expr><block>{<expr>"a2b_hqx"</expr>, <expr><name>binascii_a2b_hqx</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>doc_a2b_hqx</name></expr>}</block></expr>,
<expr><block>{<expr>"b2a_hqx"</expr>, <expr><name>binascii_b2a_hqx</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>doc_b2a_hqx</name></expr>}</block></expr>,
<expr><block>{<expr>"b2a_hex"</expr>, <expr><name>binascii_hexlify</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>doc_hexlify</name></expr>}</block></expr>,
<expr><block>{<expr>"a2b_hex"</expr>, <expr><name>binascii_unhexlify</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>doc_unhexlify</name></expr>}</block></expr>,
<expr><block>{<expr>"hexlify"</expr>, <expr><name>binascii_hexlify</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>doc_hexlify</name></expr>}</block></expr>,
<expr><block>{<expr>"unhexlify"</expr>, <expr><name>binascii_unhexlify</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>doc_unhexlify</name></expr>}</block></expr>,
<expr><block>{<expr>"rlecode_hqx"</expr>, <expr><name>binascii_rlecode_hqx</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>doc_rlecode_hqx</name></expr>}</block></expr>,
<expr><block>{
<expr>"rledecode_hqx"</expr>, <expr><name>binascii_rledecode_hqx</name></expr>, <expr><name>METH_VARARGS</name></expr>,
<expr><name>doc_rledecode_hqx</name></expr>
}</block></expr>,
<expr><block>{<expr>"crc_hqx"</expr>, <expr><name>binascii_crc_hqx</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>doc_crc_hqx</name></expr>}</block></expr>,
<expr><block>{<expr>"crc32"</expr>, <expr><name>binascii_crc32</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>doc_crc32</name></expr>}</block></expr>,
<expr><block>{
<expr>"a2b_qp"</expr>, <expr>(<name>PyCFunction</name>)<name>binascii_a2b_qp</name></expr>, <expr><name>METH_VARARGS</name> | <name>METH_KEYWORDS</name></expr>,
<expr><name>doc_a2b_qp</name></expr>
}</block></expr>,
<expr><block>{
<expr>"b2a_qp"</expr>, <expr>(<name>PyCFunction</name>)<name>binascii_b2a_qp</name></expr>, <expr><name>METH_VARARGS</name> | <name>METH_KEYWORDS</name></expr>,
<expr><name>doc_b2a_qp</name></expr>
}</block></expr>,
<expr><block>{<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>}</block></expr>
}</block></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>doc_binascii</name></expr></argument>, <argument><expr>"Conversion between binary data and ASCII"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><name>PyMODINIT_FUNC</name></type>
<name>initbinascii</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>m</name></decl>, *<decl><type ref="prev"/><name>d</name></decl>, *<decl><type ref="prev"/><name>x</name></decl>;</decl_stmt>
<expr_stmt><expr><name>m</name> = <call><name>Py_InitModule</name><argument_list>(<argument><expr>"binascii"</expr></argument>, <argument><expr><name>binascii_module_methods</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>m</name> == <name>NULL</name></expr>)</condition><then>
<return>return;</return></then></if>
<expr_stmt><expr><name>d</name> = <call><name>PyModule_GetDict</name><argument_list>(<argument><expr><name>m</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>x</name> = <call><name>PyString_FromString</name><argument_list>(<argument><expr><name>doc_binascii</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyDict_SetItemString</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr>"__doc__"</expr></argument>, <argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>Error</name> = <call><name>PyErr_NewException</name><argument_list>(<argument><expr>"binascii.Error"</expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyDict_SetItemString</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr>"Error"</expr></argument>, <argument><expr><name>Error</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>Incomplete</name> = <call><name>PyErr_NewException</name><argument_list>(<argument><expr>"binascii.Incomplete"</expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyDict_SetItemString</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr>"Incomplete"</expr></argument>, <argument><expr><name>Incomplete</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>
</unit>
