<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C" filename="Modules/posixmodule.c"><cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__APPLE__</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:pragma>#<cpp:directive>pragma</cpp:directive> weak lchown</cpp:pragma>
<cpp:pragma>#<cpp:directive>pragma</cpp:directive> weak statvfs</cpp:pragma>
<cpp:pragma>#<cpp:directive>pragma</cpp:directive> weak fstatvfs</cpp:pragma>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PY_SSIZE_T_CLEAN</name></cpp:macro></cpp:define>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"Python.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"structseq.h"</cpp:file></cpp:include>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__VMS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;unixio.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__cplusplus</name></expr></argument>)</argument_list></call></expr></cpp:if>
<extern>extern "C" <block>{
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>posix__doc__</name></expr></argument>,
<argument><expr>"This module provides access to operating system functionality that is\n\
standardized by the C Standard and the POSIX standard (a thinly\n\
disguised Unix interface). Refer to the library manual and\n\
corresponding Unix manual entries for more information on calls."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>Py_USING_UNICODE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Py_UNICODE</name></cpp:macro> <cpp:value>void</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>PYOS_OS2</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INCL_DOS</name></cpp:macro></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INCL_DOSERRORS</name></cpp:macro></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INCL_DOSPROCESS</name></cpp:macro></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INCL_NOPMAPI</name></cpp:macro></cpp:define>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;os2.h&gt;</cpp:file></cpp:include>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>PYCC_GCC</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;ctype.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;io.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdio.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;process.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"osdefs.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_SYS_TYPES_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/types.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_SYS_STAT_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/stat.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_SYS_WAIT_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/wait.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_SIGNAL_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;signal.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_FCNTL_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;fcntl.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_GRP_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;grp.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_SYSEXITS_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sysexits.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_SYS_LOADAVG_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/loadavg.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>PYCC_VACPP</name></expr></argument>)</argument_list></call> &amp;&amp; <call><name>defined</name><argument_list>(<argument><expr><name>PYOS_OS2</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;process.h&gt;</cpp:file></cpp:include>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__WATCOMC__</name></expr></argument>)</argument_list></call> &amp;&amp; !<call><name>defined</name><argument_list>(<argument><expr><name>__QNX__</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HAVE_GETCWD</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HAVE_OPENDIR</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HAVE_SYSTEM</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__OS2__</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HAVE_EXECV</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HAVE_WAIT</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;process.h&gt;</cpp:file></cpp:include>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__BORLANDC__</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HAVE_EXECV</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HAVE_GETCWD</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HAVE_OPENDIR</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HAVE_PIPE</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HAVE_POPEN</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HAVE_SYSTEM</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HAVE_WAIT</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_MSC_VER</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HAVE_GETCWD</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HAVE_SPAWNV</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HAVE_EXECV</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HAVE_PIPE</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HAVE_POPEN</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HAVE_SYSTEM</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HAVE_CWAIT</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HAVE_FSYNC</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>fsync</name></cpp:macro> <cpp:value>_commit</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>PYOS_OS2</name></expr></argument>)</argument_list></call> &amp;&amp; <call><name>defined</name><argument_list>(<argument><expr><name>PYCC_GCC</name></expr></argument>)</argument_list></call> || <call><name>defined</name><argument_list>(<argument><expr><name>__VMS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HAVE_EXECV</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HAVE_FORK</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__USLC__</name></expr></argument>)</argument_list></call> &amp;&amp; <call><name>defined</name><argument_list>(<argument><expr><name>__SCO_VERSION__</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HAVE_FORK1</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HAVE_GETCWD</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HAVE_GETEGID</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HAVE_GETEUID</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HAVE_GETGID</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HAVE_GETPPID</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HAVE_GETUID</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HAVE_KILL</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HAVE_OPENDIR</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HAVE_PIPE</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>__rtems__</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HAVE_POPEN</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HAVE_SYSTEM</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HAVE_WAIT</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HAVE_TTYNAME</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>_MSC_VER</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__sgi</name></expr></argument>)</argument_list></call>&amp;&amp;<name>_COMPILER_VERSION</name>&gt;=700</expr></cpp:if>
<function_decl><type><specifier>extern</specifier> <name>char</name> *</type><name>ctermid_r</name><parameter_list>(<param><decl><type><name>char</name> *</type></decl></param>)</parameter_list>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>HAVE_UNISTD_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>PYCC_VACPP</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function_decl><type><specifier>extern</specifier> <name>int</name></type> <name>mkdir</name><parameter_list>(<param><decl><type><name>char</name> *</type></decl></param>)</parameter_list>;</function_decl>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>( <call><name>defined</name><argument_list>(<argument><expr><name>__WATCOMC__</name></expr></argument>)</argument_list></call> || <call><name>defined</name><argument_list>(<argument><expr><name>_MSC_VER</name></expr></argument>)</argument_list></call> ) &amp;&amp; !<call><name>defined</name><argument_list>(<argument><expr><name>__QNX__</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function_decl><type><specifier>extern</specifier> <name>int</name></type> <name>mkdir</name><parameter_list>(<param><decl><type><specifier>const</specifier></type> <name>char</name> *</decl></param>)</parameter_list>;</function_decl>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<function_decl><type><specifier>extern</specifier> <name>int</name></type> <name>mkdir</name><parameter_list>(<param><decl><type><specifier>const</specifier></type> <name>char</name> *</decl></param>, <param><decl><type><name>mode_t</name></type></decl></param>)</parameter_list>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__IBMC__</name></expr></argument>)</argument_list></call> || <call><name>defined</name><argument_list>(<argument><expr><name>__IBMCPP__</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function_decl><type><specifier>extern</specifier> <name>int</name></type> <name>chdir</name><parameter_list>(<param><decl><type><name>char</name> *</type></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><specifier>extern</specifier> <name>int</name></type> <name>rmdir</name><parameter_list>(<param><decl><type><name>char</name> *</type></decl></param>)</parameter_list>;</function_decl>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<function_decl><type><specifier>extern</specifier> <name>int</name></type> <name>chdir</name><parameter_list>(<param><decl><type><specifier>const</specifier></type> <name>char</name> *</decl></param>)</parameter_list>;</function_decl>
<function_decl><type><specifier>extern</specifier> <name>int</name></type> <name>rmdir</name><parameter_list>(<param><decl><type><specifier>const</specifier></type> <name>char</name> *</decl></param>)</parameter_list>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__BORLANDC__</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function_decl><type><specifier>extern</specifier> <name>int</name></type> <name>chmod</name><parameter_list>(<param><decl><type><specifier>const</specifier></type> <name>char</name> *</decl></param>, <param><decl><type><name>int</name></type></decl></param>)</parameter_list>;</function_decl>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<function_decl><type><specifier>extern</specifier> <name>int</name></type> <name>chmod</name><parameter_list>(<param><decl><type><specifier>const</specifier></type> <name>char</name> *</decl></param>, <param><decl><type><name>mode_t</name></type></decl></param>)</parameter_list>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<function_decl><type><specifier>extern</specifier> <name>int</name></type> <name>chown</name><parameter_list>(<param><decl><type><specifier>const</specifier></type> <name>char</name> *</decl></param>, <param><decl><type><name>uid_t</name></type></decl></param>, <param><decl><type><name>gid_t</name></type></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><specifier>extern</specifier> <name>char</name> *</type><name>getcwd</name><parameter_list>(<param><decl><type><name>char</name> *</type></decl></param>, <param><decl><type><name>int</name></type></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><specifier>extern</specifier> <name>char</name> *</type><name>strerror</name><parameter_list>(<param><decl><type><name>int</name></type></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><specifier>extern</specifier> <name>int</name></type> <name>link</name><parameter_list>(<param><decl><type><specifier>const</specifier></type> <name>char</name> *</decl></param>, <param><decl><type><specifier>const</specifier></type> <name>char</name> *</decl></param>)</parameter_list>;</function_decl>
<function_decl><type><specifier>extern</specifier> <name>int</name></type> <name>rename</name><parameter_list>(<param><decl><type><specifier>const</specifier></type> <name>char</name> *</decl></param>, <param><decl><type><specifier>const</specifier></type> <name>char</name> *</decl></param>)</parameter_list>;</function_decl>
<function_decl><type><specifier>extern</specifier> <name>int</name></type> <name>stat</name><parameter_list>(<param><decl><type><specifier>const</specifier></type> <name>char</name> *</decl></param>, <param><decl><type>struct</type> <name>stat</name> *</decl></param>)</parameter_list>;</function_decl>
<function_decl><type><specifier>extern</specifier> <name>int</name></type> <name>unlink</name><parameter_list>(<param><decl><type><specifier>const</specifier></type> <name>char</name> *</decl></param>)</parameter_list>;</function_decl>
<function_decl><type><specifier>extern</specifier> <name>int</name></type> <name>pclose</name><parameter_list>(<param><decl><type><name>FILE</name> *</type></decl></param>)</parameter_list>;</function_decl>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_SYMLINK</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function_decl><type><specifier>extern</specifier> <name>int</name></type> <name>symlink</name><parameter_list>(<param><decl><type><specifier>const</specifier></type> <name>char</name> *</decl></param>, <param><decl><type><specifier>const</specifier></type> <name>char</name> *</decl></param>)</parameter_list>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_LSTAT</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function_decl><type><specifier>extern</specifier> <name>int</name></type> <name>lstat</name><parameter_list>(<param><decl><type><specifier>const</specifier></type> <name>char</name> *</decl></param>, <param><decl><type>struct</type> <name>stat</name> *</decl></param>)</parameter_list>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_UTIME_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utime.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_SYS_UTIME_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/utime.h&gt;</cpp:file></cpp:include>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HAVE_UTIME_H</name></cpp:macro></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_SYS_TIMES_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/times.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_SYS_PARAM_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/param.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_SYS_UTSNAME_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/utsname.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_DIRENT_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;dirent.h&gt;</cpp:file></cpp:include>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NAMLEN</name><parameter_list>(<param><type><name>dirent</name></type></param>)</parameter_list></cpp:macro> <cpp:value>strlen((dirent)-&gt;d_name)</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__WATCOMC__</name></expr></argument>)</argument_list></call> &amp;&amp; !<call><name>defined</name><argument_list>(<argument><expr><name>__QNX__</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;direct.h&gt;</cpp:file></cpp:include>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NAMLEN</name><parameter_list>(<param><type><name>dirent</name></type></param>)</parameter_list></cpp:macro> <cpp:value>strlen((dirent)-&gt;d_name)</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>dirent</name></cpp:macro> <cpp:value>direct</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NAMLEN</name><parameter_list>(<param><type><name>dirent</name></type></param>)</parameter_list></cpp:macro> <cpp:value>(dirent)-&gt;d_namlen</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_SYS_NDIR_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/ndir.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_SYS_DIR_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/dir.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_NDIR_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;ndir.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_MSC_VER</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_DIRECT_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;direct.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_IO_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;io.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_PROCESS_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;process.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"osdefs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;windows.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;shellapi.h&gt;</cpp:file></cpp:include>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>popen</name></cpp:macro> <cpp:value>_popen</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>pclose</name></cpp:macro> <cpp:value>_pclose</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>PYCC_VACPP</name></expr></argument>)</argument_list></call> &amp;&amp; <call><name>defined</name><argument_list>(<argument><expr><name>PYOS_OS2</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;io.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>MAXPATHLEN</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>PATH_MAX</name></expr></argument>)</argument_list></call> &amp;&amp; <name>PATH_MAX</name> &gt; 1024</expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAXPATHLEN</name></cpp:macro> <cpp:value>PATH_MAX</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAXPATHLEN</name></cpp:macro> <cpp:value>1024</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>UNION_WAIT</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>WIFEXITED</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WIFEXITED</name><parameter_list>(<param><type><name>u_wait</name></type></param>)</parameter_list></cpp:macro> <cpp:value>(!(u_wait).w_termsig &amp;&amp; !(u_wait).w_coredump)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>WEXITSTATUS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WEXITSTATUS</name><parameter_list>(<param><type><name>u_wait</name></type></param>)</parameter_list></cpp:macro> <cpp:value>(WIFEXITED(u_wait)?((u_wait).w_retcode):-1)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>WTERMSIG</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WTERMSIG</name><parameter_list>(<param><type><name>u_wait</name></type></param>)</parameter_list></cpp:macro> <cpp:value>((u_wait).w_termsig)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WAIT_TYPE</name></cpp:macro> <cpp:value>union wait</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WAIT_STATUS_INT</name><parameter_list>(<param><type><name>s</name></type></param>)</parameter_list></cpp:macro> <cpp:value>(s.w_status)</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WAIT_TYPE</name></cpp:macro> <cpp:value>int</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WAIT_STATUS_INT</name><parameter_list>(<param><type><name>s</name></type></param>)</parameter_list></cpp:macro> <cpp:value>(s)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_CTERMID_R</name></expr></argument>)</argument_list></call> &amp;&amp; <call><name>defined</name><argument_list>(<argument><expr><name>WITH_THREAD</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>USE_CTERMID_R</name></cpp:macro></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_TMPNAM_R</name></expr></argument>)</argument_list></call> &amp;&amp; <call><name>defined</name><argument_list>(<argument><expr><name>WITH_THREAD</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>USE_TMPNAM_R</name></cpp:macro></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>STAT</name></cpp:undef>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MS_WIN64</name></expr></argument>)</argument_list></call> || <call><name>defined</name><argument_list>(<argument><expr><name>MS_WINDOWS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>STAT</name></cpp:macro> <cpp:value>win32_stat</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FSTAT</name></cpp:macro> <cpp:value>win32_fstat</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>STRUCT_STAT</name></cpp:macro> <cpp:value>struct win32_stat</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>STAT</name></cpp:macro> <cpp:value>stat</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FSTAT</name></cpp:macro> <cpp:value>fstat</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>STRUCT_STAT</name></cpp:macro> <cpp:value>struct stat</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MAJOR_IN_MKDEV</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/mkdev.h&gt;</cpp:file></cpp:include>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MAJOR_IN_SYSMACROS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/sysmacros.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_MKNOD</name></expr></argument>)</argument_list></call> &amp;&amp; <call><name>defined</name><argument_list>(<argument><expr><name>HAVE_SYS_MKDEV_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/mkdev.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>WITH_NEXT_FRAMEWORK</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;crt_externs.h&gt;</cpp:file></cpp:include>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> **</type><name>environ</name></decl>;</decl_stmt>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>_MSC_VER</name></expr></argument>)</argument_list></call> &amp;&amp; ( !<call><name>defined</name><argument_list>(<argument><expr><name>__WATCOMC__</name></expr></argument>)</argument_list></call> || <call><name>defined</name><argument_list>(<argument><expr><name>__QNX__</name></expr></argument>)</argument_list></call> )</expr></cpp:elif>
<decl_stmt><decl><type><specifier>extern</specifier> <name>char</name> **</type><name>environ</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>convertenviron</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>d</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> **</type><name>e</name></decl>;</decl_stmt>
<expr_stmt><expr><name>d</name> = <call><name>PyDict_New</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>d</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>WITH_NEXT_FRAMEWORK</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if>if <condition>(<expr><name>environ</name> == <name>NULL</name></expr>)</condition><then>
<expr_stmt><expr><name>environ</name> = *<call><name>_NSGetEnviron</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<if>if <condition>(<expr><name>environ</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>d</name></expr>;</return></then></if>
<for>for (<init><expr><name>e</name> = <name>environ</name></expr>;</init> <condition><expr>*<name>e</name> != <name>NULL</name></expr>;</condition> <incr><expr><name>e</name>++</expr></incr>) <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>k</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>v</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>p</name> <init>= <expr><call><name>strchr</name><argument_list>(<argument><expr>*<name>e</name></expr></argument>, <argument><expr>'='</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>p</name> == <name>NULL</name></expr>)</condition><then>
<continue>continue;</continue></then></if>
<expr_stmt><expr><name>k</name> = <call><name>PyString_FromStringAndSize</name><argument_list>(<argument><expr>*<name>e</name></expr></argument>, <argument><expr><call>(<name>int</name>)<argument_list>(<argument><expr><name>p</name>-*<name>e</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>k</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_Clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<continue>continue;</continue>
}</block></then></if>
<expr_stmt><expr><name>v</name> = <call><name>PyString_FromString</name><argument_list>(<argument><expr><name>p</name>+1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>v</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_Clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>k</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<continue>continue;</continue>
}</block></then></if>
<if>if <condition>(<expr><call><name>PyDict_GetItem</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr><name>k</name></expr></argument>)</argument_list></call> == <name>NULL</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr><call><name>PyDict_SetItem</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr><name>k</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call> != 0</expr>)</condition><then>
<expr_stmt><expr><call><name>PyErr_Clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>
}</block></then></if>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>k</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></for>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>PYOS_OS2</name></expr></argument>)</argument_list></call></expr></cpp:if>
<block>{
<decl_stmt><decl><type><name>APIRET</name></type> <name>rc</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name><name>buffer</name><index>[<expr>1024</expr>]</index></name></decl>;</decl_stmt>
<expr_stmt><expr><name>rc</name> = <call><name>DosQueryExtLIBPATH</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>BEGIN_LIBPATH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>rc</name> == <name>NO_ERROR</name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>v</name> <init>= <expr><call><name>PyString_FromString</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>PyDict_SetItemString</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr>"BEGINLIBPATH"</expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><name>rc</name> = <call><name>DosQueryExtLIBPATH</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>END_LIBPATH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>rc</name> == <name>NO_ERROR</name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>v</name> <init>= <expr><call><name>PyString_FromString</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>PyDict_SetItemString</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr>"ENDLIBPATH"</expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<return>return <expr><name>d</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>posix_error</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list> <block>{
<return>return <expr><call><name>PyErr_SetFromErrno</name><argument_list>(<argument><expr><name>PyExc_OSError</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>posix_error_with_filename</name><parameter_list>(<param><decl><type><name>char</name>*</type> <name>name</name></decl></param>)</parameter_list> <block>{
<return>return <expr><call><name>PyErr_SetFromErrnoWithFilename</name><argument_list>(<argument><expr><name>PyExc_OSError</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>Py_WIN_WIDE_FILENAMES</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>posix_error_with_unicode_filename</name><parameter_list>(<param><decl><type><name>Py_UNICODE</name>*</type> <name>name</name></decl></param>)</parameter_list> <block>{
<return>return <expr><call><name>PyErr_SetFromErrnoWithUnicodeFilename</name><argument_list>(<argument><expr><name>PyExc_OSError</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>posix_error_with_allocated_filename</name><parameter_list>(<param><decl><type><name>char</name>*</type> <name>name</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>rc</name> <init>= <expr><call><name>PyErr_SetFromErrnoWithFilename</name><argument_list>(<argument><expr><name>PyExc_OSError</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>PyMem_Free</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>rc</name></expr>;</return>
}</block></function>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MS_WINDOWS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>win32_error</name><parameter_list>(<param><decl><type><name>char</name>*</type> <name>function</name></decl></param>, <param><decl><type><name>char</name>*</type> <name>filename</name></decl></param>)</parameter_list> <block>{
<expr_stmt><expr><name>errno</name> = <call><name>GetLastError</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>filename</name></expr>)</condition><then>
<return>return <expr><call><name>PyErr_SetFromWindowsErrWithFilename</name><argument_list>(<argument><expr><name>errno</name></expr></argument>, <argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr>;</return></then>
<else>else
<return>return <expr><call><name>PyErr_SetFromWindowsErr</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr>;</return></else></if>
}</block></function>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>Py_WIN_WIDE_FILENAMES</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>win32_error_unicode</name><parameter_list>(<param><decl><type><name>char</name>*</type> <name>function</name></decl></param>, <param><decl><type><name>Py_UNICODE</name>*</type> <name>filename</name></decl></param>)</parameter_list> <block>{
<expr_stmt><expr><name>errno</name> = <call><name>GetLastError</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>filename</name></expr>)</condition><then>
<return>return <expr><call><name>PyErr_SetFromWindowsErrWithUnicodeFilename</name><argument_list>(<argument><expr><name>errno</name></expr></argument>, <argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr>;</return></then>
<else>else
<return>return <expr><call><name>PyErr_SetFromWindowsErr</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr>;</return></else></if>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type><name>_PyUnicode_FromFileSystemEncodedObject</name><parameter_list>(<param><decl><type><name>register</name> <name>PyObject</name> *</type><name>obj</name></decl></param>)</parameter_list> <block>{
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>convert_to_unicode</name><parameter_list>(<param><decl><type><name>PyObject</name> **</type><name>param</name></decl></param>)</parameter_list> <block>{
<if>if <condition>(<expr><call><name>PyUnicode_CheckExact</name><argument_list>(<argument><expr>*<name>param</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr>*<name>param</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
<else>else <if>if <condition>(<expr><call><name>PyUnicode_Check</name><argument_list>(<argument><expr>*<name>param</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<expr_stmt><expr>*<name>param</name> = <call><name>PyUnicode_FromUnicode</name><argument_list>(<argument><expr><call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr>*<name>param</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name>PyUnicode_GET_SIZE</name><argument_list>(<argument><expr>*<name>param</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
<else>else
<expr_stmt><expr>*<name>param</name> = <call><name>PyUnicode_FromEncodedObject</name><argument_list>(<argument><expr>*<name>param</name></expr></argument>,
<argument><expr><name>Py_FileSystemDefaultEncoding</name></expr></argument>,
<argument><expr>"strict"</expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if></else></if>
<return>return <expr>(*<name>param</name>) != <name>NULL</name></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>PYOS_OS2</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>os2_formatmsg</name><parameter_list>(<param><decl><type><name>char</name> *</type><name>msgbuf</name></decl></param>, <param><decl><type><name>int</name></type> <name>msglen</name></decl></param>, <param><decl><type><name>char</name> *</type><name>reason</name></decl></param>)</parameter_list> <block>{
<expr_stmt><expr><name><name>msgbuf</name><index>[<expr><name>msglen</name></expr>]</index></name> = '\0'</expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>strlen</name><argument_list>(<argument><expr><name>msgbuf</name></expr></argument>)</argument_list></call> &gt; 0</expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>char</name> *</type><name>lastc</name> <init>= <expr>&amp;<name><name>msgbuf</name><index>[ <expr><call><name>strlen</name><argument_list>(<argument><expr><name>msgbuf</name></expr></argument>)</argument_list></call>-1</expr> ]</index></name></expr></init></decl>;</decl_stmt>
<while>while <condition>(<expr><name>lastc</name> &gt; <name>msgbuf</name> &amp;&amp; <call><name>isspace</name><argument_list>(<argument><expr><call><name>Py_CHARMASK</name><argument_list>(<argument><expr>*<name>lastc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
<expr_stmt><expr>*<name>lastc</name>-- = '\0'</expr>;</expr_stmt></while>
}</block></then></if>
<if>if <condition>(<expr><name>reason</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>strcat</name><argument_list>(<argument><expr><name>msgbuf</name></expr></argument>, <argument><expr>" : "</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>strcat</name><argument_list>(<argument><expr><name>msgbuf</name></expr></argument>, <argument><expr><name>reason</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
}</block></function>
<function><type><specifier>static</specifier> <name>char</name> *</type>
<name>os2_strerror</name><parameter_list>(<param><decl><type><name>char</name> *</type><name>msgbuf</name></decl></param>, <param><decl><type><name>int</name></type> <name>msgbuflen</name></decl></param>, <param><decl><type><name>int</name></type> <name>errorcode</name></decl></param>, <param><decl><type><name>char</name> *</type><name>reason</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>APIRET</name></type> <name>rc</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ULONG</name></type> <name>msglen</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_BEGIN_ALLOW_THREADS</name></type>
<name>rc</name> <init>= <expr><call><name>DosGetMessage</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>msgbuf</name></expr></argument>, <argument><expr><name>msgbuflen</name></expr></argument>,
<argument><expr><name>errorcode</name></expr></argument>, <argument><expr>"oso001.msg"</expr></argument>, <argument><expr>&amp;<name>msglen</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<macro><name>Py_END_ALLOW_THREADS</name></macro>
<if>if <condition>(<expr><name>rc</name> == <name>NO_ERROR</name></expr>)</condition><then>
<expr_stmt><expr><call><name>os2_formatmsg</name><argument_list>(<argument><expr><name>msgbuf</name></expr></argument>, <argument><expr><name>msglen</name></expr></argument>, <argument><expr><name>reason</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
<else>else
<expr_stmt><expr><call><name>PyOS_snprintf</name><argument_list>(<argument><expr><name>msgbuf</name></expr></argument>, <argument><expr><name>msgbuflen</name></expr></argument>,
<argument><expr>"unknown OS error #%d"</expr></argument>, <argument><expr><name>errorcode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
<return>return <expr><name>msgbuf</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type> <name>os2_error</name><parameter_list>(<param><decl><type><name>int</name></type> <name>code</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>char</name></type> <name><name>text</name><index>[<expr>1024</expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>v</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>os2_strerror</name><argument_list>(<argument><expr><name>text</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>text</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>code</name></expr></argument>, <argument><expr>""</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>v</name> = <call><name>Py_BuildValue</name><argument_list>(<argument><expr>"(is)"</expr></argument>, <argument><expr><name>code</name></expr></argument>, <argument><expr><name>text</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>v</name> != <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetObject</name><argument_list>(<argument><expr><name>PyExc_OSError</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>posix_fildes</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>fdobj</name></decl></param>, <param><function_decl><type><name>int</name></type> (*<name>func</name>)<parameter_list>(<param><decl><type><name>int</name></type></decl></param>)</parameter_list></function_decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>fd</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>res</name></decl>;</decl_stmt>
<expr_stmt><expr><name>fd</name> = <call><name>PyObject_AsFileDescriptor</name><argument_list>(<argument><expr><name>fdobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>fd</name> &lt; 0</expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<decl_stmt><decl><type><name>Py_BEGIN_ALLOW_THREADS</name></type>
<name>res</name> <init>= <expr><call>(*<name>func</name>)<argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<macro><name>Py_END_ALLOW_THREADS</name></macro>
<if>if <condition>(<expr><name>res</name> &lt; 0</expr>)</condition><then>
<return>return <expr><call><name>posix_error</name><argument_list>()</argument_list></call></expr>;</return></then></if>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>Py_None</name></expr>;</return>
}</block></function>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>Py_WIN_WIDE_FILENAMES</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>unicode_file_names</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>canusewide</name> <init>= <expr>-1</expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>canusewide</name> == -1</expr>)</condition><then> <block>{
<expr_stmt><expr><name>canusewide</name> = (<call><name>GetVersion</name><argument_list>()</argument_list></call> &lt; 0x80000000) ? 1 : 0</expr>;</expr_stmt>
}</block></then></if>
<return>return <expr><name>canusewide</name></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>posix_1str</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>, <param><decl><type><name>char</name> *</type><name>format</name></decl></param>, <param><function_decl><type><name>int</name></type> (*<name>func</name>)<parameter_list>(<param><decl><type><specifier>const</specifier></type> <name>char</name>*</decl></param>)</parameter_list></function_decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>char</name> *</type><name>path1</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>res</name></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>format</name></expr></argument>,
<argument><expr><name>Py_FileSystemDefaultEncoding</name></expr></argument>, <argument><expr>&amp;<name>path1</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<decl_stmt><decl><type><name>Py_BEGIN_ALLOW_THREADS</name></type>
<name>res</name> <init>= <expr><call>(*<name>func</name>)<argument_list>(<argument><expr><name>path1</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<macro><name>Py_END_ALLOW_THREADS</name></macro>
<if>if <condition>(<expr><name>res</name> &lt; 0</expr>)</condition><then>
<return>return <expr><call><name>posix_error_with_allocated_filename</name><argument_list>(<argument><expr><name>path1</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
<expr_stmt><expr><call><name>PyMem_Free</name><argument_list>(<argument><expr><name>path1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>Py_None</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>posix_2str</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>,
<param><decl><type><name>char</name> *</type><name>format</name></decl></param>,
<param><function_decl><type><name>int</name></type> (*<name>func</name>)<parameter_list>(<param><decl><type><specifier>const</specifier></type> <name>char</name> *</decl></param>, <param><decl><type><specifier>const</specifier></type> <name>char</name> *</decl></param>)</parameter_list></function_decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>char</name> *</type><name>path1</name> <init>= <expr><name>NULL</name></expr></init>, *<name>path2</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>res</name></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>format</name></expr></argument>,
<argument><expr><name>Py_FileSystemDefaultEncoding</name></expr></argument>, <argument><expr>&amp;<name>path1</name></expr></argument>,
<argument><expr><name>Py_FileSystemDefaultEncoding</name></expr></argument>, <argument><expr>&amp;<name>path2</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<decl_stmt><decl><type><name>Py_BEGIN_ALLOW_THREADS</name></type>
<name>res</name> <init>= <expr><call>(*<name>func</name>)<argument_list>(<argument><expr><name>path1</name></expr></argument>, <argument><expr><name>path2</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<function_decl><type><name>Py_END_ALLOW_THREADS</name></type>
<name>PyMem_Free</name><parameter_list>(<param><decl><type><name>path1</name></type></decl></param>)</parameter_list>;</function_decl>
<expr_stmt><expr><call><name>PyMem_Free</name><argument_list>(<argument><expr><name>path2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>res</name> != 0</expr>)</condition><then>
<return>return <expr><call><name>posix_error</name><argument_list>()</argument_list></call></expr>;</return></then></if>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>Py_None</name></expr>;</return>
}</block></function>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>Py_WIN_WIDE_FILENAMES</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function><type><specifier>static</specifier> <name>PyObject</name>*</type>
<name>win32_1str</name><parameter_list>(<param><decl><type><name>PyObject</name>*</type> <name>args</name></decl></param>, <param><decl><type><name>char</name>*</type> <name>func</name></decl></param>,
<param><decl><type><name>char</name>*</type> <name>format</name></decl></param>, <param><function_decl><type><name>BOOL</name></type> (<name>__stdcall</name> *<name>funcA</name>)<parameter_list>(<param><decl><type><name>LPCSTR</name></type></decl></param>)</parameter_list></function_decl></param>,
<param><decl><type><name>char</name>*</type> <name>wformat</name></decl></param>, <param><function_decl><type><name>BOOL</name></type> (<name>__stdcall</name> *<name>funcW</name>)<parameter_list>(<param><decl><type><name>LPWSTR</name></type></decl></param>)</parameter_list></function_decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>uni</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>ansi</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BOOL</name></type> <name>result</name></decl>;</decl_stmt>
<if>if <condition>(<expr><call><name>unicode_file_names</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>wformat</name></expr></argument>, <argument><expr>&amp;<name>uni</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<expr_stmt><expr><call><name>PyErr_Clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then>
<else>else <block>{
<decl_stmt><decl><type><name>Py_BEGIN_ALLOW_THREADS</name></type>
<name>result</name> <init>= <expr><call><name>funcW</name><argument_list>(<argument><expr><call><name>PyUnicode_AsUnicode</name><argument_list>(<argument><expr><name>uni</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<macro><name>Py_END_ALLOW_THREADS</name></macro>
<if>if <condition>(<expr>!<name>result</name></expr>)</condition><then>
<return>return <expr><call><name>win32_error_unicode</name><argument_list>(<argument><expr><name>func</name></expr></argument>, <argument><expr><call><name>PyUnicode_AsUnicode</name><argument_list>(<argument><expr><name>uni</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></then></if>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>Py_None</name></expr>;</return>
}</block></else></if>
}</block></then></if>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>format</name></expr></argument>, <argument><expr>&amp;<name>ansi</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<decl_stmt><decl><type><name>Py_BEGIN_ALLOW_THREADS</name></type>
<name>result</name> <init>= <expr><call><name>funcA</name><argument_list>(<argument><expr><name>ansi</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<macro><name>Py_END_ALLOW_THREADS</name></macro>
<if>if <condition>(<expr>!<name>result</name></expr>)</condition><then>
<return>return <expr><call><name>win32_error</name><argument_list>(<argument><expr><name>func</name></expr></argument>, <argument><expr><name>ansi</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>Py_None</name></expr>;</return>
}</block></function>
<function><type><name>BOOL</name> <name>__stdcall</name></type>
<name>win32_chdir</name><parameter_list>(<param><decl><type><name>LPCSTR</name></type> <name>path</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>char</name></type> <name><name>new_path</name><index>[<expr><name>MAX_PATH</name>+1</expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>result</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name><name>env</name><index>[<expr>4</expr>]</index></name> <init>= <expr>"=x:"</expr></init></decl>;</decl_stmt>
<if>if<condition>(<expr>!<call><name>SetCurrentDirectoryA</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>FALSE</name></expr>;</return></then></if>
<expr_stmt><expr><name>result</name> = <call><name>GetCurrentDirectoryA</name><argument_list>(<argument><expr><name>MAX_PATH</name>+1</expr></argument>, <argument><expr><name>new_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>result</name></expr>)</condition><then>
<return>return <expr><name>FALSE</name></expr>;</return></then></if>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>result</name> &lt;= <name>MAX_PATH</name>+1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><name>new_path</name></expr></argument>, <argument><expr>"\\\\"</expr></argument>, <argument><expr>2</expr></argument>)</argument_list></call> == 0 ||
<call><name>strncmp</name><argument_list>(<argument><expr><name>new_path</name></expr></argument>, <argument><expr>"//"</expr></argument>, <argument><expr>2</expr></argument>)</argument_list></call> == 0</expr>)</condition><then>
<return>return <expr><name>TRUE</name></expr>;</return></then></if>
<expr_stmt><expr><name><name>env</name><index>[<expr>1</expr>]</index></name> = <name><name>new_path</name><index>[<expr>0</expr>]</index></name></expr>;</expr_stmt>
<return>return <expr><call><name>SetEnvironmentVariableA</name><argument_list>(<argument><expr><name>env</name></expr></argument>, <argument><expr><name>new_path</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><name>BOOL</name> <name>__stdcall</name></type>
<name>win32_wchdir</name><parameter_list>(<param><decl><type><name>LPCWSTR</name></type> <name>path</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>wchar_t</name></type> <name><name>_new_path</name><index>[<expr><name>MAX_PATH</name>+1</expr>]</index></name></decl>, *<decl><type ref="prev"/><name>new_path</name> <init>= <expr><name>_new_path</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>result</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>wchar_t</name></type> <name><name>env</name><index>[<expr>4</expr>]</index></name> <init>= <expr>L"=x:"</expr></init></decl>;</decl_stmt>
<if>if<condition>(<expr>!<call><name>SetCurrentDirectoryW</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>FALSE</name></expr>;</return></then></if>
<expr_stmt><expr><name>result</name> = <call><name>GetCurrentDirectoryW</name><argument_list>(<argument><expr><name>MAX_PATH</name>+1</expr></argument>, <argument><expr><name>new_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>result</name></expr>)</condition><then>
<return>return <expr><name>FALSE</name></expr>;</return></then></if>
<if>if <condition>(<expr><name>result</name> &gt; <name>MAX_PATH</name>+1</expr>)</condition><then> <block>{
<expr_stmt><expr><name>new_path</name> = <call><name>malloc</name><argument_list>(<argument><expr><name>result</name> * <sizeof>sizeof<argument_list>(<argument><expr><name>wchar_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>new_path</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>SetLastError</name><argument_list>(<argument><expr><name>ERROR_OUTOFMEMORY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>FALSE</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>result</name> = <call><name>GetCurrentDirectoryW</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>new_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>result</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>new_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>FALSE</name></expr>;</return>
}</block></then></if>
}</block></then></if>
<if>if <condition>(<expr><call><name>wcsncmp</name><argument_list>(<argument><expr><name>new_path</name></expr></argument>, <argument><expr>L"\\\\"</expr></argument>, <argument><expr>2</expr></argument>)</argument_list></call> == 0 ||
<call><name>wcsncmp</name><argument_list>(<argument><expr><name>new_path</name></expr></argument>, <argument><expr>L"//"</expr></argument>, <argument><expr>2</expr></argument>)</argument_list></call> == 0</expr>)</condition><then>
<return>return <expr><name>TRUE</name></expr>;</return></then></if>
<expr_stmt><expr><name><name>env</name><index>[<expr>1</expr>]</index></name> = <name><name>new_path</name><index>[<expr>0</expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name>result</name> = <call><name>SetEnvironmentVariableW</name><argument_list>(<argument><expr><name>env</name></expr></argument>, <argument><expr><name>new_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>new_path</name> != <name>_new_path</name></expr>)</condition><then>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>new_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<return>return <expr><name>result</name></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MS_WINDOWS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HAVE_STAT_NSEC</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<struct>struct <name>win32_stat</name> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>st_dev</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>__int64</name></type> <name>st_ino</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>short</name></type> <name>st_mode</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>st_nlink</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>st_uid</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>st_gid</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>st_rdev</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>__int64</name></type> <name>st_size</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>st_atime</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>st_atime_nsec</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>st_mtime</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>st_mtime_nsec</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>st_ctime</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>st_ctime_nsec</name></decl>;</decl_stmt>
}</block>;</struct>
<decl_stmt><decl><type><specifier>static</specifier> <name>__int64</name></type> <name>secs_between_epochs</name> <init>= <expr>11644473600</expr></init></decl>;</decl_stmt>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>FILE_TIME_to_time_t_nsec</name><parameter_list>(<param><decl><type><name>FILETIME</name> *</type><name>in_ptr</name></decl></param>, <param><decl><type><name>int</name> *</type><name>time_out</name></decl></param>, <param><decl><type><name>int</name>*</type> <name>nsec_out</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>__int64</name></type> <name>in</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name>in</name></expr></argument>, <argument><expr><name>in_ptr</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>in</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr>*<name>nsec_out</name> = <call>(<name>int</name>)<argument_list>(<argument><expr><name>in</name> % 10000000</expr></argument>)</argument_list></call> * 100</expr>;</expr_stmt>
<expr_stmt><expr>*<name>time_out</name> = <call><name>Py_SAFE_DOWNCAST</name><argument_list>(<argument><expr>(<name>in</name> / 10000000) - <name>secs_between_epochs</name></expr></argument>, <argument><expr><name>__int64</name></expr></argument>, <argument><expr><name>int</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>time_t_to_FILE_TIME</name><parameter_list>(<param><decl><type><name>int</name></type> <name>time_in</name></decl></param>, <param><decl><type><name>int</name></type> <name>nsec_in</name></decl></param>, <param><decl><type><name>FILETIME</name> *</type><name>out_ptr</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>__int64</name></type> <name>out</name></decl>;</decl_stmt>
<expr_stmt><expr><name>out</name> = <name>time_in</name> + <name>secs_between_epochs</name></expr>;</expr_stmt>
<expr_stmt><expr><name>out</name> = <name>out</name> * 10000000 + <name>nsec_in</name> / 100</expr>;</expr_stmt>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>out_ptr</name></expr></argument>, <argument><expr>&amp;<name>out</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>out</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>_S_IREAD</name> != 0400</expr></cpp:if>
<cpp:error>#<cpp:directive>error</cpp:directive> Unsupported C library</cpp:error>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>attributes_to_mode</name><parameter_list>(<param><decl><type><name>DWORD</name></type> <name>attr</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>m</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>attr</name> &amp; <name>FILE_ATTRIBUTE_DIRECTORY</name></expr>)</condition><then>
<expr_stmt><expr><name>m</name> |= <name>_S_IFDIR</name> | 0111</expr>;</expr_stmt></then>
<else>else
<expr_stmt><expr><name>m</name> |= <name>_S_IFREG</name></expr>;</expr_stmt></else></if>
<if>if <condition>(<expr><name>attr</name> &amp; <name>FILE_ATTRIBUTE_READONLY</name></expr>)</condition><then>
<expr_stmt><expr><name>m</name> |= 0444</expr>;</expr_stmt></then>
<else>else
<expr_stmt><expr><name>m</name> |= 0666</expr>;</expr_stmt></else></if>
<return>return <expr><name>m</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>attribute_data_to_stat</name><parameter_list>(<param><decl><type><name>WIN32_FILE_ATTRIBUTE_DATA</name> *</type><name>info</name></decl></param>, <param><decl><type>struct <name>win32_stat</name> *</type><name>result</name></decl></param>)</parameter_list> <block>{
<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>*<name>result</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>result</name>-&gt;<name>st_mode</name></name> = <call><name>attributes_to_mode</name><argument_list>(<argument><expr><name><name>info</name>-&gt;<name>dwFileAttributes</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>result</name>-&gt;<name>st_size</name></name> = (((<name>__int64</name>)<name><name>info</name>-&gt;<name>nFileSizeHigh</name></name>)&lt;&lt;32) + <name><name>info</name>-&gt;<name>nFileSizeLow</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>FILE_TIME_to_time_t_nsec</name><argument_list>(<argument><expr>&amp;<name><name>info</name>-&gt;<name>ftCreationTime</name></name></expr></argument>, <argument><expr>&amp;<name><name>result</name>-&gt;<name>st_ctime</name></name></expr></argument>, <argument><expr>&amp;<name><name>result</name>-&gt;<name>st_ctime_nsec</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>FILE_TIME_to_time_t_nsec</name><argument_list>(<argument><expr>&amp;<name><name>info</name>-&gt;<name>ftLastWriteTime</name></name></expr></argument>, <argument><expr>&amp;<name><name>result</name>-&gt;<name>st_mtime</name></name></expr></argument>, <argument><expr>&amp;<name><name>result</name>-&gt;<name>st_mtime_nsec</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>FILE_TIME_to_time_t_nsec</name><argument_list>(<argument><expr>&amp;<name><name>info</name>-&gt;<name>ftLastAccessTime</name></name></expr></argument>, <argument><expr>&amp;<name><name>result</name>-&gt;<name>st_atime</name></name></expr></argument>, <argument><expr>&amp;<name><name>result</name>-&gt;<name>st_atime_nsec</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>0</expr>;</return>
}</block></function>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>checked</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<function_decl><type><specifier>static</specifier> <name>BOOL</name></type> (<name>CALLBACK</name> *<name>gfaxa</name>)<parameter_list>(<param><decl><type><name>LPCSTR</name></type></decl></param>, <param><decl><type><name>GET_FILEEX_INFO_LEVELS</name></type></decl></param>, <param><decl><type><name>LPVOID</name></type></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>BOOL</name></type> (<name>CALLBACK</name> *<name>gfaxw</name>)<parameter_list>(<param><decl><type><name>LPCWSTR</name></type></decl></param>, <param><decl><type><name>GET_FILEEX_INFO_LEVELS</name></type></decl></param>, <param><decl><type><name>LPVOID</name></type></decl></param>)</parameter_list>;</function_decl>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>check_gfax</name><parameter_list>()</parameter_list> <block>{
<decl_stmt><decl><type><name>HINSTANCE</name></type> <name>hKernel32</name></decl>;</decl_stmt>
<if>if <condition>(<expr><name>checked</name></expr>)</condition><then>
<return>return;</return></then></if>
<expr_stmt><expr><name>checked</name> = 1</expr>;</expr_stmt>
<expr_stmt><expr><name>hKernel32</name> = <call><name>GetModuleHandle</name><argument_list>(<argument><expr>"KERNEL32"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr>*(<name>FARPROC</name>*)&amp;<name>gfaxa</name> = <call><name>GetProcAddress</name><argument_list>(<argument><expr><name>hKernel32</name></expr></argument>, <argument><expr>"GetFileAttributesExA"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr>*(<name>FARPROC</name>*)&amp;<name>gfaxw</name> = <call><name>GetProcAddress</name><argument_list>(<argument><expr><name>hKernel32</name></expr></argument>, <argument><expr>"GetFileAttributesExW"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>
<function><type><specifier>static</specifier> <name>BOOL</name></type>
<name>attributes_from_dir</name><parameter_list>(<param><decl><type><name>LPCSTR</name></type> <name>pszFile</name></decl></param>, <param><decl><type><name>LPWIN32_FILE_ATTRIBUTE_DATA</name></type> <name>pfad</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>HANDLE</name></type> <name>hFindFile</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>WIN32_FIND_DATAA</name></type> <name>FileData</name></decl>;</decl_stmt>
<expr_stmt><expr><name>hFindFile</name> = <call><name>FindFirstFileA</name><argument_list>(<argument><expr><name>pszFile</name></expr></argument>, <argument><expr>&amp;<name>FileData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>hFindFile</name> == <name>INVALID_HANDLE_VALUE</name></expr>)</condition><then>
<return>return <expr><name>FALSE</name></expr>;</return></then></if>
<expr_stmt><expr><call><name>FindClose</name><argument_list>(<argument><expr><name>hFindFile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>pfad</name>-&gt;<name>dwFileAttributes</name></name> = <name><name>FileData</name>.<name>dwFileAttributes</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>pfad</name>-&gt;<name>ftCreationTime</name></name> = <name><name>FileData</name>.<name>ftCreationTime</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>pfad</name>-&gt;<name>ftLastAccessTime</name></name> = <name><name>FileData</name>.<name>ftLastAccessTime</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>pfad</name>-&gt;<name>ftLastWriteTime</name></name> = <name><name>FileData</name>.<name>ftLastWriteTime</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>pfad</name>-&gt;<name>nFileSizeHigh</name></name> = <name><name>FileData</name>.<name>nFileSizeHigh</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>pfad</name>-&gt;<name>nFileSizeLow</name></name> = <name><name>FileData</name>.<name>nFileSizeLow</name></name></expr>;</expr_stmt>
<return>return <expr><name>TRUE</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>BOOL</name></type>
<name>attributes_from_dir_w</name><parameter_list>(<param><decl><type><name>LPCWSTR</name></type> <name>pszFile</name></decl></param>, <param><decl><type><name>LPWIN32_FILE_ATTRIBUTE_DATA</name></type> <name>pfad</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>HANDLE</name></type> <name>hFindFile</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>WIN32_FIND_DATAW</name></type> <name>FileData</name></decl>;</decl_stmt>
<expr_stmt><expr><name>hFindFile</name> = <call><name>FindFirstFileW</name><argument_list>(<argument><expr><name>pszFile</name></expr></argument>, <argument><expr>&amp;<name>FileData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>hFindFile</name> == <name>INVALID_HANDLE_VALUE</name></expr>)</condition><then>
<return>return <expr><name>FALSE</name></expr>;</return></then></if>
<expr_stmt><expr><call><name>FindClose</name><argument_list>(<argument><expr><name>hFindFile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>pfad</name>-&gt;<name>dwFileAttributes</name></name> = <name><name>FileData</name>.<name>dwFileAttributes</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>pfad</name>-&gt;<name>ftCreationTime</name></name> = <name><name>FileData</name>.<name>ftCreationTime</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>pfad</name>-&gt;<name>ftLastAccessTime</name></name> = <name><name>FileData</name>.<name>ftLastAccessTime</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>pfad</name>-&gt;<name>ftLastWriteTime</name></name> = <name><name>FileData</name>.<name>ftLastWriteTime</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>pfad</name>-&gt;<name>nFileSizeHigh</name></name> = <name><name>FileData</name>.<name>nFileSizeHigh</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>pfad</name>-&gt;<name>nFileSizeLow</name></name> = <name><name>FileData</name>.<name>nFileSizeLow</name></name></expr>;</expr_stmt>
<return>return <expr><name>TRUE</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>BOOL</name> <name>WINAPI</name></type>
<name>Py_GetFileAttributesExA</name><parameter_list>(<param><decl><type><name>LPCSTR</name></type> <name>pszFile</name></decl></param>,
<param><decl><type><name>GET_FILEEX_INFO_LEVELS</name></type> <name>level</name></decl></param>,
<param><decl><type><name>LPVOID</name></type> <name>pv</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>BOOL</name></type> <name>result</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>LPWIN32_FILE_ATTRIBUTE_DATA</name></type> <name>pfad</name> <init>= <expr><name>pv</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>check_gfax</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>gfaxa</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>result</name> = <call><name>gfaxa</name><argument_list>(<argument><expr><name>pszFile</name></expr></argument>, <argument><expr><name>level</name></expr></argument>, <argument><expr><name>pv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>result</name> || <call><name>GetLastError</name><argument_list>()</argument_list></call> != <name>ERROR_CALL_NOT_IMPLEMENTED</name></expr>)</condition><then>
<return>return <expr><name>result</name></expr>;</return></then></if>
}</block></then></if>
<if>if <condition>(<expr><name>level</name> != <name>GetFileExInfoStandard</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>SetLastError</name><argument_list>(<argument><expr><name>ERROR_INVALID_PARAMETER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>FALSE</name></expr>;</return>
}</block></then></if>
<if>if <condition>(<expr><call><name>GetFileAttributesA</name><argument_list>(<argument><expr><name>pszFile</name></expr></argument>)</argument_list></call> == 0xFFFFFFFF</expr>)</condition><then>
<return>return <expr><name>FALSE</name></expr>;</return></then></if>
<return>return <expr><call><name>attributes_from_dir</name><argument_list>(<argument><expr><name>pszFile</name></expr></argument>, <argument><expr><name>pfad</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>BOOL</name> <name>WINAPI</name></type>
<name>Py_GetFileAttributesExW</name><parameter_list>(<param><decl><type><name>LPCWSTR</name></type> <name>pszFile</name></decl></param>,
<param><decl><type><name>GET_FILEEX_INFO_LEVELS</name></type> <name>level</name></decl></param>,
<param><decl><type><name>LPVOID</name></type> <name>pv</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>BOOL</name></type> <name>result</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>LPWIN32_FILE_ATTRIBUTE_DATA</name></type> <name>pfad</name> <init>= <expr><name>pv</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>check_gfax</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>gfaxa</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>result</name> = <call><name>gfaxw</name><argument_list>(<argument><expr><name>pszFile</name></expr></argument>, <argument><expr><name>level</name></expr></argument>, <argument><expr><name>pv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>result</name> || <call><name>GetLastError</name><argument_list>()</argument_list></call> != <name>ERROR_CALL_NOT_IMPLEMENTED</name></expr>)</condition><then>
<return>return <expr><name>result</name></expr>;</return></then></if>
}</block></then></if>
<if>if <condition>(<expr><name>level</name> != <name>GetFileExInfoStandard</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>SetLastError</name><argument_list>(<argument><expr><name>ERROR_INVALID_PARAMETER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>FALSE</name></expr>;</return>
}</block></then></if>
<if>if <condition>(<expr><call><name>GetFileAttributesW</name><argument_list>(<argument><expr><name>pszFile</name></expr></argument>)</argument_list></call> == 0xFFFFFFFF</expr>)</condition><then>
<return>return <expr><name>FALSE</name></expr>;</return></then></if>
<return>return <expr><call><name>attributes_from_dir_w</name><argument_list>(<argument><expr><name>pszFile</name></expr></argument>, <argument><expr><name>pfad</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>win32_stat</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name>*</type> <name>path</name></decl></param>, <param><decl><type>struct <name>win32_stat</name> *</type><name>result</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>WIN32_FILE_ATTRIBUTE_DATA</name></type> <name>info</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>code</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>dot</name></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>Py_GetFileAttributesExA</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>GetFileExInfoStandard</name></expr></argument>, <argument><expr>&amp;<name>info</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<if>if <condition>(<expr><call><name>GetLastError</name><argument_list>()</argument_list></call> != <name>ERROR_SHARING_VIOLATION</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>errno</name> = 0</expr>;</expr_stmt>
<return>return <expr>-1</expr>;</return>
}</block></then> <else>else <block>{
<if>if <condition>(<expr>!<call><name>attributes_from_dir</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr>&amp;<name>info</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><name>errno</name> = 0</expr>;</expr_stmt>
<return>return <expr>-1</expr>;</return>
}</block></then></if>
}</block></else></if>
}</block></then></if>
<expr_stmt><expr><name>code</name> = <call><name>attribute_data_to_stat</name><argument_list>(<argument><expr>&amp;<name>info</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>code</name> != 0</expr>)</condition><then>
<return>return <expr><name>code</name></expr>;</return></then></if>
<expr_stmt><expr><name>dot</name> = <call><name>strrchr</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr>'.'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>dot</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr><call><name>stricmp</name><argument_list>(<argument><expr><name>dot</name></expr></argument>, <argument><expr>".bat"</expr></argument>)</argument_list></call> == 0 ||
<call><name>stricmp</name><argument_list>(<argument><expr><name>dot</name></expr></argument>, <argument><expr>".cmd"</expr></argument>)</argument_list></call> == 0 ||
<call><name>stricmp</name><argument_list>(<argument><expr><name>dot</name></expr></argument>, <argument><expr>".exe"</expr></argument>)</argument_list></call> == 0 ||
<call><name>stricmp</name><argument_list>(<argument><expr><name>dot</name></expr></argument>, <argument><expr>".com"</expr></argument>)</argument_list></call> == 0</expr>)</condition><then>
<expr_stmt><expr><name><name>result</name>-&gt;<name>st_mode</name></name> |= 0111</expr>;</expr_stmt></then></if>
}</block></then></if>
<return>return <expr><name>code</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>win32_wstat</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>wchar_t</name>*</type> <name>path</name></decl></param>, <param><decl><type>struct <name>win32_stat</name> *</type><name>result</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>code</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>wchar_t</name> *</type><name>dot</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>WIN32_FILE_ATTRIBUTE_DATA</name></type> <name>info</name></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>Py_GetFileAttributesExW</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>GetFileExInfoStandard</name></expr></argument>, <argument><expr>&amp;<name>info</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<if>if <condition>(<expr><call><name>GetLastError</name><argument_list>()</argument_list></call> != <name>ERROR_SHARING_VIOLATION</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>errno</name> = 0</expr>;</expr_stmt>
<return>return <expr>-1</expr>;</return>
}</block></then> <else>else <block>{
<if>if <condition>(<expr>!<call><name>attributes_from_dir_w</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr>&amp;<name>info</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><name>errno</name> = 0</expr>;</expr_stmt>
<return>return <expr>-1</expr>;</return>
}</block></then></if>
}</block></else></if>
}</block></then></if>
<expr_stmt><expr><name>code</name> = <call><name>attribute_data_to_stat</name><argument_list>(<argument><expr>&amp;<name>info</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>code</name> &lt; 0</expr>)</condition><then>
<return>return <expr><name>code</name></expr>;</return></then></if>
<expr_stmt><expr><name>dot</name> = <call><name>wcsrchr</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr>'.'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>dot</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr><call><name>_wcsicmp</name><argument_list>(<argument><expr><name>dot</name></expr></argument>, <argument><expr>L".bat"</expr></argument>)</argument_list></call> == 0 ||
<call><name>_wcsicmp</name><argument_list>(<argument><expr><name>dot</name></expr></argument>, <argument><expr>L".cmd"</expr></argument>)</argument_list></call> == 0 ||
<call><name>_wcsicmp</name><argument_list>(<argument><expr><name>dot</name></expr></argument>, <argument><expr>L".exe"</expr></argument>)</argument_list></call> == 0 ||
<call><name>_wcsicmp</name><argument_list>(<argument><expr><name>dot</name></expr></argument>, <argument><expr>L".com"</expr></argument>)</argument_list></call> == 0</expr>)</condition><then>
<expr_stmt><expr><name><name>result</name>-&gt;<name>st_mode</name></name> |= 0111</expr>;</expr_stmt></then></if>
}</block></then></if>
<return>return <expr><name>code</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>win32_fstat</name><parameter_list>(<param><decl><type><name>int</name></type> <name>file_number</name></decl></param>, <param><decl><type>struct <name>win32_stat</name> *</type><name>result</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>BY_HANDLE_FILE_INFORMATION</name></type> <name>info</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>HANDLE</name></type> <name>h</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>type</name></decl>;</decl_stmt>
<expr_stmt><expr><name>h</name> = (<name>HANDLE</name>)<call><name>_get_osfhandle</name><argument_list>(<argument><expr><name>file_number</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>errno</name> = 0</expr>;</expr_stmt>
<if>if <condition>(<expr><name>h</name> == <name>INVALID_HANDLE_VALUE</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>SetLastError</name><argument_list>(<argument><expr><name>ERROR_INVALID_HANDLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>-1</expr>;</return>
}</block></then></if>
<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>*<name>result</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>type</name> = <call><name>GetFileType</name><argument_list>(<argument><expr><name>h</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>type</name> == <name>FILE_TYPE_UNKNOWN</name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>DWORD</name></type> <name>error</name> <init>= <expr><call><name>GetLastError</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>error</name> != 0</expr>)</condition><then> <block>{
<return>return <expr>-1</expr>;</return>
}</block></then></if>
}</block></then></if>
<if>if <condition>(<expr><name>type</name> != <name>FILE_TYPE_DISK</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr><name>type</name> == <name>FILE_TYPE_CHAR</name></expr>)</condition><then>
<expr_stmt><expr><name><name>result</name>-&gt;<name>st_mode</name></name> = <name>_S_IFCHR</name></expr>;</expr_stmt></then>
<else>else <if>if <condition>(<expr><name>type</name> == <name>FILE_TYPE_PIPE</name></expr>)</condition><then>
<expr_stmt><expr><name><name>result</name>-&gt;<name>st_mode</name></name> = <name>_S_IFIFO</name></expr>;</expr_stmt></then></if></else></if>
<return>return <expr>0</expr>;</return>
}</block></then></if>
<if>if <condition>(<expr>!<call><name>GetFileInformationByHandle</name><argument_list>(<argument><expr><name>h</name></expr></argument>, <argument><expr>&amp;<name>info</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<return>return <expr>-1</expr>;</return>
}</block></then></if>
<expr_stmt><expr><name><name>result</name>-&gt;<name>st_mode</name></name> = <call><name>attributes_to_mode</name><argument_list>(<argument><expr><name><name>info</name>.<name>dwFileAttributes</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>result</name>-&gt;<name>st_size</name></name> = (((<name>__int64</name>)<name><name>info</name>.<name>nFileSizeHigh</name></name>)&lt;&lt;32) + <name><name>info</name>.<name>nFileSizeLow</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>FILE_TIME_to_time_t_nsec</name><argument_list>(<argument><expr>&amp;<name><name>info</name>.<name>ftCreationTime</name></name></expr></argument>, <argument><expr>&amp;<name><name>result</name>-&gt;<name>st_ctime</name></name></expr></argument>, <argument><expr>&amp;<name><name>result</name>-&gt;<name>st_ctime_nsec</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>FILE_TIME_to_time_t_nsec</name><argument_list>(<argument><expr>&amp;<name><name>info</name>.<name>ftLastWriteTime</name></name></expr></argument>, <argument><expr>&amp;<name><name>result</name>-&gt;<name>st_mtime</name></name></expr></argument>, <argument><expr>&amp;<name><name>result</name>-&gt;<name>st_mtime_nsec</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>FILE_TIME_to_time_t_nsec</name><argument_list>(<argument><expr>&amp;<name><name>info</name>.<name>ftLastAccessTime</name></name></expr></argument>, <argument><expr>&amp;<name><name>result</name>-&gt;<name>st_atime</name></name></expr></argument>, <argument><expr>&amp;<name><name>result</name>-&gt;<name>st_atime_nsec</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>result</name>-&gt;<name>st_nlink</name></name> = <name><name>info</name>.<name>nNumberOfLinks</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>result</name>-&gt;<name>st_ino</name></name> = (((<name>__int64</name>)<name><name>info</name>.<name>nFileIndexHigh</name></name>)&lt;&lt;32) + <name><name>info</name>.<name>nFileIndexLow</name></name></expr>;</expr_stmt>
<return>return <expr>0</expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>stat_result__doc__</name></expr></argument>,
<argument><expr>"stat_result: Result from stat or lstat.\n\n\
This object may be accessed either as a tuple of\n\
(mode, ino, dev, nlink, uid, gid, size, atime, mtime, ctime)\n\
or via the attributes st_mode, st_ino, st_dev, st_nlink, st_uid, and so on.\n\
\n\
Posix/windows: If your platform supports st_blksize, st_blocks, st_rdev,\n\
or st_flags, they are available as attributes only.\n\
\n\
See os.stat for more information."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>PyStructSequence_Field</name></type> <name><name>stat_result_fields</name><index>[]</index></name> <init>= <expr><block>{
<expr><block>{<expr>"st_mode"</expr>, <expr>"protection bits"</expr>}</block></expr>,
<expr><block>{<expr>"st_ino"</expr>, <expr>"inode"</expr>}</block></expr>,
<expr><block>{<expr>"st_dev"</expr>, <expr>"device"</expr>}</block></expr>,
<expr><block>{<expr>"st_nlink"</expr>, <expr>"number of hard links"</expr>}</block></expr>,
<expr><block>{<expr>"st_uid"</expr>, <expr>"user ID of owner"</expr>}</block></expr>,
<expr><block>{<expr>"st_gid"</expr>, <expr>"group ID of owner"</expr>}</block></expr>,
<expr><block>{<expr>"st_size"</expr>, <expr>"total size, in bytes"</expr>}</block></expr>,
<expr><block>{<expr><name>NULL</name></expr>, <expr>"integer time of last access"</expr>}</block></expr>,
<expr><block>{<expr><name>NULL</name></expr>, <expr>"integer time of last modification"</expr>}</block></expr>,
<expr><block>{<expr><name>NULL</name></expr>, <expr>"integer time of last change"</expr>}</block></expr>,
<expr><block>{<expr>"st_atime"</expr>, <expr>"time of last access"</expr>}</block></expr>,
<expr><block>{<expr>"st_mtime"</expr>, <expr>"time of last modification"</expr>}</block></expr>,
<expr><block>{<expr>"st_ctime"</expr>, <expr>"time of last change"</expr>}</block></expr>,
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_STRUCT_STAT_ST_BLKSIZE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"st_blksize"</expr>, <expr>"blocksize for filesystem I/O"</expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_STRUCT_STAT_ST_BLOCKS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"st_blocks"</expr>, <expr>"number of blocks allocated"</expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_STRUCT_STAT_ST_RDEV</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"st_rdev"</expr>, <expr>"device type (if inode device)"</expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_STRUCT_STAT_ST_FLAGS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"st_flags"</expr>, <expr>"user defined flags for file"</expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_STRUCT_STAT_ST_GEN</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"st_gen"</expr>, <expr>"generation number"</expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_STRUCT_STAT_ST_BIRTHTIME</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"st_birthtime"</expr>, <expr>"time of creation"</expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr><block>{<expr>0</expr>}</block></expr>
}</block></expr></init></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_STRUCT_STAT_ST_BLKSIZE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ST_BLKSIZE_IDX</name></cpp:macro> <cpp:value>13</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ST_BLKSIZE_IDX</name></cpp:macro> <cpp:value>12</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_STRUCT_STAT_ST_BLOCKS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ST_BLOCKS_IDX</name></cpp:macro> <cpp:value>(ST_BLKSIZE_IDX+1)</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ST_BLOCKS_IDX</name></cpp:macro> <cpp:value>ST_BLKSIZE_IDX</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_STRUCT_STAT_ST_RDEV</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ST_RDEV_IDX</name></cpp:macro> <cpp:value>(ST_BLOCKS_IDX+1)</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ST_RDEV_IDX</name></cpp:macro> <cpp:value>ST_BLOCKS_IDX</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_STRUCT_STAT_ST_FLAGS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ST_FLAGS_IDX</name></cpp:macro> <cpp:value>(ST_RDEV_IDX+1)</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ST_FLAGS_IDX</name></cpp:macro> <cpp:value>ST_RDEV_IDX</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_STRUCT_STAT_ST_GEN</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ST_GEN_IDX</name></cpp:macro> <cpp:value>(ST_FLAGS_IDX+1)</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ST_GEN_IDX</name></cpp:macro> <cpp:value>ST_FLAGS_IDX</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_STRUCT_STAT_ST_BIRTHTIME</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ST_BIRTHTIME_IDX</name></cpp:macro> <cpp:value>(ST_GEN_IDX+1)</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ST_BIRTHTIME_IDX</name></cpp:macro> <cpp:value>ST_GEN_IDX</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<decl_stmt><decl><type><specifier>static</specifier> <name>PyStructSequence_Desc</name></type> <name>stat_result_desc</name> <init>= <expr><block>{
<expr>"stat_result"</expr>,
<expr><name>stat_result__doc__</name></expr>,
<expr><name>stat_result_fields</name></expr>,
<expr>10</expr>
}</block></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>statvfs_result__doc__</name></expr></argument>,
<argument><expr>"statvfs_result: Result from statvfs or fstatvfs.\n\n\
This object may be accessed either as a tuple of\n\
(bsize, frsize, blocks, bfree, bavail, files, ffree, favail, flag, namemax),\n\
or via the attributes f_bsize, f_frsize, f_blocks, f_bfree, and so on.\n\
\n\
See os.statvfs for more information."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>PyStructSequence_Field</name></type> <name><name>statvfs_result_fields</name><index>[]</index></name> <init>= <expr><block>{
<expr><block>{<expr>"f_bsize"</expr>, }</block></expr>,
<expr><block>{<expr>"f_frsize"</expr>, }</block></expr>,
<expr><block>{<expr>"f_blocks"</expr>, }</block></expr>,
<expr><block>{<expr>"f_bfree"</expr>, }</block></expr>,
<expr><block>{<expr>"f_bavail"</expr>, }</block></expr>,
<expr><block>{<expr>"f_files"</expr>, }</block></expr>,
<expr><block>{<expr>"f_ffree"</expr>, }</block></expr>,
<expr><block>{<expr>"f_favail"</expr>, }</block></expr>,
<expr><block>{<expr>"f_flag"</expr>, }</block></expr>,
<expr><block>{<expr>"f_namemax"</expr>,}</block></expr>,
<expr><block>{<expr>0</expr>}</block></expr>
}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>PyStructSequence_Desc</name></type> <name>statvfs_result_desc</name> <init>= <expr><block>{
<expr>"statvfs_result"</expr>,
<expr><name>statvfs_result__doc__</name></expr>,
<expr><name>statvfs_result_fields</name></expr>,
<expr>10</expr>
}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>initialized</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>PyTypeObject</name></type> <name>StatResultType</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>PyTypeObject</name></type> <name>StatVFSResultType</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>newfunc</name></type> <name>structseq_new</name></decl>;</decl_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>statresult_new</name><parameter_list>(<param><decl><type><name>PyTypeObject</name> *</type><name>type</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>kwds</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyStructSequence</name> *</type><name>result</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<expr_stmt><expr><name>result</name> = (<name>PyStructSequence</name>*)<call><name>structseq_new</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><name>args</name></expr></argument>, <argument><expr><name>kwds</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>result</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<for>for (<init><expr><name>i</name> = 7</expr>;</init> <condition><expr><name>i</name> &lt;= 9</expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
<if>if <condition>(<expr><name><name>result</name>-&gt;<name>ob_item</name><index>[<expr><name>i</name>+3</expr>]</index></name> == <name>Py_None</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name><name>result</name>-&gt;<name>ob_item</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>result</name>-&gt;<name>ob_item</name><index>[<expr><name>i</name>+3</expr>]</index></name> = <name><name>result</name>-&gt;<name>ob_item</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
}</block></then></if>
}</block></for>
<return>return <expr>(<name>PyObject</name>*)<name>result</name></expr>;</return>
}</block></function>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>_stat_float_times</name> <init>= <expr>1</expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>stat_float_times__doc__</name></expr></argument>,
<argument><expr>"stat_float_times([newval]) -&gt; oldval\n\n\
Determine whether os.[lf]stat represents time stamps as float objects.\n\
If newval is True, future calls to stat() return floats, if it is False,\n\
future calls return ints. \n\
If newval is omitted, return the current setting.\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name>*</type>
<name>stat_float_times</name><parameter_list>(<param><decl><type><name>PyObject</name>*</type> <name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>newval</name> <init>= <expr>-1</expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"|i:stat_float_times"</expr></argument>, <argument><expr>&amp;<name>newval</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<if>if <condition>(<expr><name>newval</name> == -1</expr>)</condition><then>
<return>return <expr><call><name>PyBool_FromLong</name><argument_list>(<argument><expr><name>_stat_float_times</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
<expr_stmt><expr><name>_stat_float_times</name> = <name>newval</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>Py_None</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>fill_time</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>v</name></decl></param>, <param><decl><type><name>int</name></type> <name>index</name></decl></param>, <param><decl><type><name>time_t</name></type> <name>sec</name></decl></param>, <param><decl><type><name>unsigned</name> <name>long</name></type> <name>nsec</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>fval</name></decl>,*<decl><type ref="prev"/><name>ival</name></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SIZEOF_TIME_T</name> &gt; <name>SIZEOF_LONG</name></expr></cpp:if>
<expr_stmt><expr><name>ival</name> = <call><name>PyLong_FromLongLong</name><argument_list>(<argument><expr>(<name>PY_LONG_LONG</name>)<name>sec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<expr_stmt><expr><name>ival</name> = <call><name>PyInt_FromLong</name><argument_list>(<argument><expr>(<name>long</name>)<name>sec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<if>if <condition>(<expr>!<name>ival</name></expr>)</condition><then>
<return>return;</return></then></if>
<if>if <condition>(<expr><name>_stat_float_times</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>fval</name> = <call><name>PyFloat_FromDouble</name><argument_list>(<argument><expr><name>sec</name> + 1e-9*<name>nsec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr><name>fval</name> = <name>ival</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>fval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></else></if>
<expr_stmt><expr><call><name>PyStructSequence_SET_ITEM</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>index</name></expr></argument>, <argument><expr><name>ival</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyStructSequence_SET_ITEM</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>index</name>+3</expr></argument>, <argument><expr><name>fval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name>*</type>
<name>_pystat_fromstructstat</name><parameter_list>(<param><decl><type><name>STRUCT_STAT</name> *</type><name>st</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>ansec</name></decl>, <decl><type ref="prev"/><name>mnsec</name></decl>, <decl><type ref="prev"/><name>cnsec</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>v</name> <init>= <expr><call><name>PyStructSequence_New</name><argument_list>(<argument><expr>&amp;<name>StatResultType</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>v</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><call><name>PyStructSequence_SET_ITEM</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><call><name>PyInt_FromLong</name><argument_list>(<argument><expr>(<name>long</name>)<name><name>st</name>-&gt;<name>st_mode</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_LARGEFILE_SUPPORT</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyStructSequence_SET_ITEM</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr>1</expr></argument>,
<argument><expr><call><name>PyLong_FromLongLong</name><argument_list>(<argument><expr>(<name>PY_LONG_LONG</name>)<name><name>st</name>-&gt;<name>st_ino</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<expr_stmt><expr><call><name>PyStructSequence_SET_ITEM</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr>1</expr></argument>, <argument><expr><call><name>PyInt_FromLong</name><argument_list>(<argument><expr>(<name>long</name>)<name><name>st</name>-&gt;<name>st_ino</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_LONG_LONG</name></expr></argument>)</argument_list></call> &amp;&amp; !<call><name>defined</name><argument_list>(<argument><expr><name>MS_WINDOWS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyStructSequence_SET_ITEM</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr>2</expr></argument>,
<argument><expr><call><name>PyLong_FromLongLong</name><argument_list>(<argument><expr>(<name>PY_LONG_LONG</name>)<name><name>st</name>-&gt;<name>st_dev</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<expr_stmt><expr><call><name>PyStructSequence_SET_ITEM</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr>2</expr></argument>, <argument><expr><call><name>PyInt_FromLong</name><argument_list>(<argument><expr>(<name>long</name>)<name><name>st</name>-&gt;<name>st_dev</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><call><name>PyStructSequence_SET_ITEM</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr>3</expr></argument>, <argument><expr><call><name>PyInt_FromLong</name><argument_list>(<argument><expr>(<name>long</name>)<name><name>st</name>-&gt;<name>st_nlink</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyStructSequence_SET_ITEM</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr>4</expr></argument>, <argument><expr><call><name>PyInt_FromLong</name><argument_list>(<argument><expr>(<name>long</name>)<name><name>st</name>-&gt;<name>st_uid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyStructSequence_SET_ITEM</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr>5</expr></argument>, <argument><expr><call><name>PyInt_FromLong</name><argument_list>(<argument><expr>(<name>long</name>)<name><name>st</name>-&gt;<name>st_gid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_LARGEFILE_SUPPORT</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyStructSequence_SET_ITEM</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr>6</expr></argument>,
<argument><expr><call><name>PyLong_FromLongLong</name><argument_list>(<argument><expr>(<name>PY_LONG_LONG</name>)<name><name>st</name>-&gt;<name>st_size</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<expr_stmt><expr><call><name>PyStructSequence_SET_ITEM</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr>6</expr></argument>, <argument><expr><call><name>PyInt_FromLong</name><argument_list>(<argument><expr><name><name>st</name>-&gt;<name>st_size</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_STAT_TV_NSEC</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><name>ansec</name> = <name><name>st</name>-&gt;<name>st_atim</name>.<name>tv_nsec</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>mnsec</name> = <name><name>st</name>-&gt;<name>st_mtim</name>.<name>tv_nsec</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>cnsec</name> = <name><name>st</name>-&gt;<name>st_ctim</name>.<name>tv_nsec</name></name></expr>;</expr_stmt>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_STAT_TV_NSEC2</name></expr></argument>)</argument_list></call></expr></cpp:elif>
<expr_stmt><expr><name>ansec</name> = <name><name>st</name>-&gt;<name>st_atimespec</name>.<name>tv_nsec</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>mnsec</name> = <name><name>st</name>-&gt;<name>st_mtimespec</name>.<name>tv_nsec</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>cnsec</name> = <name><name>st</name>-&gt;<name>st_ctimespec</name>.<name>tv_nsec</name></name></expr>;</expr_stmt>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_STAT_NSEC</name></expr></argument>)</argument_list></call></expr></cpp:elif>
<expr_stmt><expr><name>ansec</name> = <name><name>st</name>-&gt;<name>st_atime_nsec</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>mnsec</name> = <name><name>st</name>-&gt;<name>st_mtime_nsec</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>cnsec</name> = <name><name>st</name>-&gt;<name>st_ctime_nsec</name></name></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<expr_stmt><expr><name>ansec</name> = <name>mnsec</name> = <name>cnsec</name> = 0</expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><call><name>fill_time</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr>7</expr></argument>, <argument><expr><name><name>st</name>-&gt;<name>st_atime</name></name></expr></argument>, <argument><expr><name>ansec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>fill_time</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr>8</expr></argument>, <argument><expr><name><name>st</name>-&gt;<name>st_mtime</name></name></expr></argument>, <argument><expr><name>mnsec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>fill_time</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr>9</expr></argument>, <argument><expr><name><name>st</name>-&gt;<name>st_ctime</name></name></expr></argument>, <argument><expr><name>cnsec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_STRUCT_STAT_ST_BLKSIZE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyStructSequence_SET_ITEM</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>ST_BLKSIZE_IDX</name></expr></argument>,
<argument><expr><call><name>PyInt_FromLong</name><argument_list>(<argument><expr>(<name>long</name>)<name><name>st</name>-&gt;<name>st_blksize</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_STRUCT_STAT_ST_BLOCKS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyStructSequence_SET_ITEM</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>ST_BLOCKS_IDX</name></expr></argument>,
<argument><expr><call><name>PyInt_FromLong</name><argument_list>(<argument><expr>(<name>long</name>)<name><name>st</name>-&gt;<name>st_blocks</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_STRUCT_STAT_ST_RDEV</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyStructSequence_SET_ITEM</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>ST_RDEV_IDX</name></expr></argument>,
<argument><expr><call><name>PyInt_FromLong</name><argument_list>(<argument><expr>(<name>long</name>)<name><name>st</name>-&gt;<name>st_rdev</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_STRUCT_STAT_ST_GEN</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyStructSequence_SET_ITEM</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>ST_GEN_IDX</name></expr></argument>,
<argument><expr><call><name>PyInt_FromLong</name><argument_list>(<argument><expr>(<name>long</name>)<name><name>st</name>-&gt;<name>st_gen</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_STRUCT_STAT_ST_BIRTHTIME</name></expr></argument>)</argument_list></call></expr></cpp:if>
<block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>val</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>bsec</name></decl>,<decl><type ref="prev"/><name>bnsec</name></decl>;</decl_stmt>
<expr_stmt><expr><name>bsec</name> = (<name>long</name>)<name><name>st</name>-&gt;<name>st_birthtime</name></name></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_STAT_TV_NSEC2</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><name>bnsec</name> = <name><name>st</name>-&gt;<name>st_birthtimespec</name>.<name>tv_nsec</name></name></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<expr_stmt><expr><name>bnsec</name> = 0</expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<if>if <condition>(<expr><name>_stat_float_times</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>val</name> = <call><name>PyFloat_FromDouble</name><argument_list>(<argument><expr><name>bsec</name> + 1e-9*<name>bnsec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr><name>val</name> = <call><name>PyInt_FromLong</name><argument_list>(<argument><expr>(<name>long</name>)<name>bsec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></else></if>
<expr_stmt><expr><call><name>PyStructSequence_SET_ITEM</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>ST_BIRTHTIME_IDX</name></expr></argument>,
<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_STRUCT_STAT_ST_FLAGS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyStructSequence_SET_ITEM</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>ST_FLAGS_IDX</name></expr></argument>,
<argument><expr><call><name>PyInt_FromLong</name><argument_list>(<argument><expr>(<name>long</name>)<name><name>st</name>-&gt;<name>st_flags</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<if>if <condition>(<expr><call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<return>return <expr><name>v</name></expr>;</return>
}</block></function>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MS_WINDOWS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ISSLASHA</name><parameter_list>(<param><type><name>c</name></type></param>)</parameter_list></cpp:macro> <cpp:value>((c) == '\\' || (c) == '/')</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ISSLASHW</name><parameter_list>(<param><type><name>c</name></type></param>)</parameter_list></cpp:macro> <cpp:value>((c) == L'\\' || (c) == L'/')</cpp:value></cpp:define>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>ARRAYSIZE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ARRAYSIZE</name><parameter_list>(<param><type><name>a</name></type></param>)</parameter_list></cpp:macro> <cpp:value>(sizeof(a) / sizeof(a[0]))</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<function><type><specifier>static</specifier> <name>BOOL</name></type>
<name>IsUNCRootA</name><parameter_list>(<param><decl><type><name>char</name> *</type><name>path</name></decl></param>, <param><decl><type><name>int</name></type> <name>pathlen</name></decl></param>)</parameter_list> <block>{
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ISSLASH</name></cpp:macro> <cpp:value>ISSLASHA</cpp:value></cpp:define>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>share</name></decl>;</decl_stmt>
<if>if <condition>(<expr><name>pathlen</name> &lt; 5 || !<call><name>ISSLASH</name><argument_list>(<argument><expr><name><name>path</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></call> || !<call><name>ISSLASH</name><argument_list>(<argument><expr><name><name>path</name><index>[<expr>1</expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>FALSE</name></expr>;</return></then></if>
<for>for (<init><expr><name>i</name> = 2</expr>;</init> <condition><expr><name>i</name> &lt; <name>pathlen</name></expr> ;</condition> <incr><expr><name>i</name>++</expr></incr>)
<if>if <condition>(<expr><call><name>ISSLASH</name><argument_list>(<argument><expr><name><name>path</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><then> <break>break;</break></then></if></for>
<if>if <condition>(<expr><name>i</name> == 2 || <name>i</name> == <name>pathlen</name></expr>)</condition><then>
<return>return <expr><name>FALSE</name></expr>;</return></then></if>
<expr_stmt><expr><name>share</name> = <name>i</name>+1</expr>;</expr_stmt>
<for>for (<init><expr><name>i</name> = <name>share</name></expr>;</init> <condition><expr><name>i</name> &lt; <name>pathlen</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
<if>if <condition>(<expr><call><name>ISSLASH</name><argument_list>(<argument><expr><name><name>path</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><then> <break>break;</break></then></if></for>
<return>return <expr>(<name>i</name> != <name>share</name> &amp;&amp; (<name>i</name> == <name>pathlen</name> || <name>i</name> == <name>pathlen</name>-1))</expr>;</return>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>ISSLASH</name></cpp:undef>
}</block></function>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>Py_WIN_WIDE_FILENAMES</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function><type><specifier>static</specifier> <name>BOOL</name></type>
<name>IsUNCRootW</name><parameter_list>(<param><decl><type><name>Py_UNICODE</name> *</type><name>path</name></decl></param>, <param><decl><type><name>int</name></type> <name>pathlen</name></decl></param>)</parameter_list> <block>{
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ISSLASH</name></cpp:macro> <cpp:value>ISSLASHW</cpp:value></cpp:define>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>share</name></decl>;</decl_stmt>
<if>if <condition>(<expr><name>pathlen</name> &lt; 5 || !<call><name>ISSLASH</name><argument_list>(<argument><expr><name><name>path</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></call> || !<call><name>ISSLASH</name><argument_list>(<argument><expr><name><name>path</name><index>[<expr>1</expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>FALSE</name></expr>;</return></then></if>
<for>for (<init><expr><name>i</name> = 2</expr>;</init> <condition><expr><name>i</name> &lt; <name>pathlen</name></expr> ;</condition> <incr><expr><name>i</name>++</expr></incr>)
<if>if <condition>(<expr><call><name>ISSLASH</name><argument_list>(<argument><expr><name><name>path</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><then> <break>break;</break></then></if></for>
<if>if <condition>(<expr><name>i</name> == 2 || <name>i</name> == <name>pathlen</name></expr>)</condition><then>
<return>return <expr><name>FALSE</name></expr>;</return></then></if>
<expr_stmt><expr><name>share</name> = <name>i</name>+1</expr>;</expr_stmt>
<for>for (<init><expr><name>i</name> = <name>share</name></expr>;</init> <condition><expr><name>i</name> &lt; <name>pathlen</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
<if>if <condition>(<expr><call><name>ISSLASH</name><argument_list>(<argument><expr><name><name>path</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><then> <break>break;</break></then></if></for>
<return>return <expr>(<name>i</name> != <name>share</name> &amp;&amp; (<name>i</name> == <name>pathlen</name> || <name>i</name> == <name>pathlen</name>-1))</expr>;</return>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>ISSLASH</name></cpp:undef>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>posix_do_stat</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>,
<param><decl><type><name>char</name> *</type><name>format</name></decl></param>,
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__VMS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<param><function_decl><type><name>int</name></type> (*<name>statfunc</name>)<parameter_list>(<param><decl><type><specifier>const</specifier></type> <name>char</name> *</decl></param>, <param><decl><type><name>STRUCT_STAT</name> *</type></decl></param>, <param><decl><type>...</type></decl></param>)</parameter_list></function_decl></param>,
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<param><function_decl><type><name>int</name></type> (*<name>statfunc</name>)<parameter_list>(<param><decl><type><specifier>const</specifier></type> <name>char</name> *</decl></param>, <param><decl><type><name>STRUCT_STAT</name> *</type></decl></param>)</parameter_list></function_decl></param>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<param><decl><type><name>char</name> *</type><name>wformat</name></decl></param>,
<param><function_decl><type><name>int</name></type> (*<name>wstatfunc</name>)<parameter_list>(<param><decl><type><specifier>const</specifier></type> <name>Py_UNICODE</name> *</decl></param>, <param><decl><type><name>STRUCT_STAT</name> *</type></decl></param>)</parameter_list></function_decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>STRUCT_STAT</name></type> <name>st</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>path</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>pathfree</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>res</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>result</name></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>Py_WIN_WIDE_FILENAMES</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if>if <condition>(<expr><call><name>unicode_file_names</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>PyUnicodeObject</name> *</type><name>po</name></decl>;</decl_stmt>
<if>if <condition>(<expr><call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>wformat</name></expr></argument>, <argument><expr>&amp;<name>po</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>Py_UNICODE</name> *</type><name>wpath</name> <init>= <expr><call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr><name>po</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_BEGIN_ALLOW_THREADS</name></type>
<name>res</name> <init>= <expr><call><name>wstatfunc</name><argument_list>(<argument><expr><name>wpath</name></expr></argument>, <argument><expr>&amp;<name>st</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<macro><name>Py_END_ALLOW_THREADS</name></macro>
<if>if <condition>(<expr><name>res</name> != 0</expr>)</condition><then>
<return>return <expr><call><name>win32_error_unicode</name><argument_list>(<argument><expr>"stat"</expr></argument>, <argument><expr><name>wpath</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
<return>return <expr><call><name>_pystat_fromstructstat</name><argument_list>(<argument><expr>&amp;<name>st</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></then></if>
<expr_stmt><expr><call><name>PyErr_Clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>format</name></expr></argument>,
<argument><expr><name>Py_FileSystemDefaultEncoding</name></expr></argument>, <argument><expr>&amp;<name>path</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>pathfree</name> = <name>path</name></expr>;</expr_stmt>
<decl_stmt><decl><type><name>Py_BEGIN_ALLOW_THREADS</name></type>
<name>res</name> <init>= <expr><call>(*<name>statfunc</name>)<argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr>&amp;<name>st</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<macro><name>Py_END_ALLOW_THREADS</name></macro>
<if>if <condition>(<expr><name>res</name> != 0</expr>)</condition><then> <block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MS_WINDOWS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><name>result</name> = <call><name>win32_error</name><argument_list>(<argument><expr>"stat"</expr></argument>, <argument><expr><name>pathfree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<expr_stmt><expr><name>result</name> = <call><name>posix_error_with_filename</name><argument_list>(<argument><expr><name>pathfree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></then> <else>else
<expr_stmt><expr><name>result</name> = <call><name>_pystat_fromstructstat</name><argument_list>(<argument><expr>&amp;<name>st</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
<expr_stmt><expr><call><name>PyMem_Free</name><argument_list>(<argument><expr><name>pathfree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>result</name></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>posix_access__doc__</name></expr></argument>,
<argument><expr>"access(path, mode) -&gt; True if granted, False otherwise\n\n\
Use the real uid/gid to test for access to a path. Note that most\n\
operations will use the effective uid/gid, therefore this routine can\n\
be used in a suid/sgid environment to test if the invoking user has the\n\
specified access to the path. The mode argument can be F_OK to test\n\
existence, or the inclusive-OR of R_OK, W_OK, and X_OK."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>posix_access</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>char</name> *</type><name>path</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>mode</name></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>Py_WIN_WIDE_FILENAMES</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>DWORD</name></type> <name>attr</name></decl>;</decl_stmt>
<if>if <condition>(<expr><call><name>unicode_file_names</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>PyUnicodeObject</name> *</type><name>po</name></decl>;</decl_stmt>
<if>if <condition>(<expr><call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"Ui:access"</expr></argument>, <argument><expr>&amp;<name>po</name></expr></argument>, <argument><expr>&amp;<name>mode</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>Py_BEGIN_ALLOW_THREADS</name></type>
<name>attr</name> <init>= <expr><call><name>GetFileAttributesW</name><argument_list>(<argument><expr><call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr><name>po</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<macro><name>Py_END_ALLOW_THREADS</name></macro>
<goto>goto <name>finish</name>;</goto>
}</block></then></if>
<expr_stmt><expr><call><name>PyErr_Clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"eti:access"</expr></argument>,
<argument><expr><name>Py_FileSystemDefaultEncoding</name></expr></argument>, <argument><expr>&amp;<name>path</name></expr></argument>, <argument><expr>&amp;<name>mode</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr>0</expr>;</return></then></if>
<decl_stmt><decl><type><name>Py_BEGIN_ALLOW_THREADS</name></type>
<name>attr</name> <init>= <expr><call><name>GetFileAttributesA</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<function_decl><type><name>Py_END_ALLOW_THREADS</name></type>
<name>PyMem_Free</name><parameter_list>(<param><decl><type><name>path</name></type></decl></param>)</parameter_list>;</function_decl>
<label><name>finish</name>:</label>
<if>if <condition>(<expr><name>attr</name> == 0xFFFFFFFF</expr>)</condition><then>
<return>return <expr><call><name>PyBool_FromLong</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</return></then></if>
<return>return <expr><call><name>PyBool_FromLong</name><argument_list>(<argument><expr>!(<name>mode</name> &amp; 2)
|| !(<name>attr</name> &amp; <name>FILE_ATTRIBUTE_READONLY</name>)
|| (<name>attr</name> &amp; <name>FILE_ATTRIBUTE_DIRECTORY</name>)</expr></argument>)</argument_list></call></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<decl_stmt><decl><type><name>int</name></type> <name>res</name></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"eti:access"</expr></argument>,
<argument><expr><name>Py_FileSystemDefaultEncoding</name></expr></argument>, <argument><expr>&amp;<name>path</name></expr></argument>, <argument><expr>&amp;<name>mode</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<decl_stmt><decl><type><name>Py_BEGIN_ALLOW_THREADS</name></type>
<name>res</name> <init>= <expr><call><name>access</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>mode</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<function_decl><type><name>Py_END_ALLOW_THREADS</name></type>
<name>PyMem_Free</name><parameter_list>(<param><decl><type><name>path</name></type></decl></param>)</parameter_list>;</function_decl>
<return>return <expr><call><name>PyBool_FromLong</name><argument_list>(<argument><expr><name>res</name> == 0</expr></argument>)</argument_list></call></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></function>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>F_OK</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>F_OK</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>R_OK</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>R_OK</name></cpp:macro> <cpp:value>4</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>W_OK</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>W_OK</name></cpp:macro> <cpp:value>2</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>X_OK</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>X_OK</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_TTYNAME</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>posix_ttyname__doc__</name></expr></argument>,
<argument><expr>"ttyname(fd) -&gt; string\n\n\
Return the name of the terminal device connected to 'fd'."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>posix_ttyname</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>id</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>ret</name></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"i:ttyname"</expr></argument>, <argument><expr>&amp;<name>id</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__VMS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if>if <condition>(<expr><name>id</name> == 0</expr>)</condition><then> <block>{
<expr_stmt><expr><name>ret</name> = <call><name>ttyname</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr><name>ret</name> = <name>NULL</name></expr>;</expr_stmt>
}</block></else></if>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<expr_stmt><expr><name>ret</name> = <call><name>ttyname</name><argument_list>(<argument><expr><name>id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<if>if <condition>(<expr><name>ret</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><call><name>posix_error</name><argument_list>()</argument_list></call></expr>;</return></then></if>
<return>return <expr><call><name>PyString_FromString</name><argument_list>(<argument><expr><name>ret</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_CTERMID</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>posix_ctermid__doc__</name></expr></argument>,
<argument><expr>"ctermid() -&gt; string\n\n\
Return the name of the controlling terminal for this process."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>posix_ctermid</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>noargs</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>char</name> *</type><name>ret</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name><name>buffer</name><index>[<expr><name>L_ctermid</name></expr>]</index></name></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>USE_CTERMID_R</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><name>ret</name> = <call><name>ctermid_r</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<expr_stmt><expr><name>ret</name> = <call><name>ctermid</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<if>if <condition>(<expr><name>ret</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><call><name>posix_error</name><argument_list>()</argument_list></call></expr>;</return></then></if>
<return>return <expr><call><name>PyString_FromString</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>posix_chdir__doc__</name></expr></argument>,
<argument><expr>"chdir(path)\n\n\
Change the current working directory to the specified path."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>posix_chdir</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MS_WINDOWS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<return>return <expr><call><name>win32_1str</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"chdir"</expr></argument>, <argument><expr>"s:chdir"</expr></argument>, <argument><expr><name>win32_chdir</name></expr></argument>, <argument><expr>"U:chdir"</expr></argument>, <argument><expr><name>win32_wchdir</name></expr></argument>)</argument_list></call></expr>;</return>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>PYOS_OS2</name></expr></argument>)</argument_list></call> &amp;&amp; <call><name>defined</name><argument_list>(<argument><expr><name>PYCC_GCC</name></expr></argument>)</argument_list></call></expr></cpp:elif>
<return>return <expr><call><name>posix_1str</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"et:chdir"</expr></argument>, <argument><expr><name>_chdir2</name></expr></argument>)</argument_list></call></expr>;</return>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__VMS</name></expr></argument>)</argument_list></call></expr></cpp:elif>
<return>return <expr><call><name>posix_1str</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"et:chdir"</expr></argument>, <argument><expr>(<call><call><name>int</name> <argument_list>(<argument><expr>*</expr></argument>)</argument_list></call><argument_list>(<argument><expr>const <name>char</name> *</expr></argument>)</argument_list></call>)<name>chdir</name></expr></argument>)</argument_list></call></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<return>return <expr><call><name>posix_1str</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"et:chdir"</expr></argument>, <argument><expr><name>chdir</name></expr></argument>)</argument_list></call></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></function>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_FCHDIR</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>posix_fchdir__doc__</name></expr></argument>,
<argument><expr>"fchdir(fildes)\n\n\
Change to the directory of the given file descriptor. fildes must be\n\
opened on a directory, not a file."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>posix_fchdir</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>fdobj</name></decl></param>)</parameter_list> <block>{
<return>return <expr><call><name>posix_fildes</name><argument_list>(<argument><expr><name>fdobj</name></expr></argument>, <argument><expr><name>fchdir</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>posix_chmod__doc__</name></expr></argument>,
<argument><expr>"chmod(path, mode)\n\n\
Change the access permissions of a file."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>posix_chmod</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>char</name> *</type><name>path</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>res</name></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>Py_WIN_WIDE_FILENAMES</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>DWORD</name></type> <name>attr</name></decl>;</decl_stmt>
<if>if <condition>(<expr><call><name>unicode_file_names</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>PyUnicodeObject</name> *</type><name>po</name></decl>;</decl_stmt>
<if>if <condition>(<expr><call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"Ui|:chmod"</expr></argument>, <argument><expr>&amp;<name>po</name></expr></argument>, <argument><expr>&amp;<name>i</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>Py_BEGIN_ALLOW_THREADS</name></type>
<name>attr</name> <init>= <expr><call><name>GetFileAttributesW</name><argument_list>(<argument><expr><call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr><name>po</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>attr</name> != 0xFFFFFFFF</expr>)</condition><then> <block>{
<if>if <condition>(<expr><name>i</name> &amp; <name>_S_IWRITE</name></expr>)</condition><then>
<expr_stmt><expr><name>attr</name> &amp;= ~<name>FILE_ATTRIBUTE_READONLY</name></expr>;</expr_stmt></then>
<else>else
<expr_stmt><expr><name>attr</name> |= <name>FILE_ATTRIBUTE_READONLY</name></expr>;</expr_stmt></else></if>
<expr_stmt><expr><name>res</name> = <call><name>SetFileAttributesW</name><argument_list>(<argument><expr><call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr><name>po</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>attr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else
<expr_stmt><expr><name>res</name> = 0</expr>;</expr_stmt></else></if>
<macro><name>Py_END_ALLOW_THREADS</name></macro>
<if>if <condition>(<expr>!<name>res</name></expr>)</condition><then>
<return>return <expr><call><name>win32_error_unicode</name><argument_list>(<argument><expr>"chmod"</expr></argument>,
<argument><expr><call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr><name>po</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></then></if>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>Py_None</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><call><name>PyErr_Clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"eti:chmod"</expr></argument>, <argument><expr><name>Py_FileSystemDefaultEncoding</name></expr></argument>,
<argument><expr>&amp;<name>path</name></expr></argument>, <argument><expr>&amp;<name>i</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<decl_stmt><decl><type><name>Py_BEGIN_ALLOW_THREADS</name></type>
<name>attr</name> <init>= <expr><call><name>GetFileAttributesA</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>attr</name> != 0xFFFFFFFF</expr>)</condition><then> <block>{
<if>if <condition>(<expr><name>i</name> &amp; <name>_S_IWRITE</name></expr>)</condition><then>
<expr_stmt><expr><name>attr</name> &amp;= ~<name>FILE_ATTRIBUTE_READONLY</name></expr>;</expr_stmt></then>
<else>else
<expr_stmt><expr><name>attr</name> |= <name>FILE_ATTRIBUTE_READONLY</name></expr>;</expr_stmt></else></if>
<expr_stmt><expr><name>res</name> = <call><name>SetFileAttributesA</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>attr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else
<expr_stmt><expr><name>res</name> = 0</expr>;</expr_stmt></else></if>
<macro><name>Py_END_ALLOW_THREADS</name></macro>
<if>if <condition>(<expr>!<name>res</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>win32_error</name><argument_list>(<argument><expr>"chmod"</expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyMem_Free</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><call><name>PyMem_Free</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>Py_None</name></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"eti:chmod"</expr></argument>, <argument><expr><name>Py_FileSystemDefaultEncoding</name></expr></argument>,
<argument><expr>&amp;<name>path</name></expr></argument>, <argument><expr>&amp;<name>i</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<decl_stmt><decl><type><name>Py_BEGIN_ALLOW_THREADS</name></type>
<name>res</name> <init>= <expr><call><name>chmod</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<macro><name>Py_END_ALLOW_THREADS</name></macro>
<if>if <condition>(<expr><name>res</name> &lt; 0</expr>)</condition><then>
<return>return <expr><call><name>posix_error_with_allocated_filename</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
<expr_stmt><expr><call><name>PyMem_Free</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>Py_None</name></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></function>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_FCHMOD</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>posix_fchmod__doc__</name></expr></argument>,
<argument><expr>"fchmod(fd, mode)\n\n\
Change the access permissions of the file given by file\n\
descriptor fd."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>posix_fchmod</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>fd</name></decl>, <decl><type ref="prev"/><name>mode</name></decl>, <decl><type ref="prev"/><name>res</name></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"ii:fchmod"</expr></argument>, <argument><expr>&amp;<name>fd</name></expr></argument>, <argument><expr>&amp;<name>mode</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<decl_stmt><decl><type><name>Py_BEGIN_ALLOW_THREADS</name></type>
<name>res</name> <init>= <expr><call><name>fchmod</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>mode</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<macro><name>Py_END_ALLOW_THREADS</name></macro>
<if>if <condition>(<expr><name>res</name> &lt; 0</expr>)</condition><then>
<return>return <expr><call><name>posix_error</name><argument_list>()</argument_list></call></expr>;</return></then></if>
<expr_stmt><expr><name>Py_RETURN_NONE</name></expr>;</expr_stmt>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_LCHMOD</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>posix_lchmod__doc__</name></expr></argument>,
<argument><expr>"lchmod(path, mode)\n\n\
Change the access permissions of a file. If path is a symlink, this\n\
affects the link itself rather than the target."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>posix_lchmod</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>char</name> *</type><name>path</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>res</name></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"eti:lchmod"</expr></argument>, <argument><expr><name>Py_FileSystemDefaultEncoding</name></expr></argument>,
<argument><expr>&amp;<name>path</name></expr></argument>, <argument><expr>&amp;<name>i</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<decl_stmt><decl><type><name>Py_BEGIN_ALLOW_THREADS</name></type>
<name>res</name> <init>= <expr><call><name>lchmod</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<macro><name>Py_END_ALLOW_THREADS</name></macro>
<if>if <condition>(<expr><name>res</name> &lt; 0</expr>)</condition><then>
<return>return <expr><call><name>posix_error_with_allocated_filename</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
<expr_stmt><expr><call><name>PyMem_Free</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>Py_RETURN_NONE</name></expr>;</expr_stmt>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_CHFLAGS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>posix_chflags__doc__</name></expr></argument>,
<argument><expr>"chflags(path, flags)\n\n\
Set file flags."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>posix_chflags</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>char</name> *</type><name>path</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>flags</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>res</name></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"etk:chflags"</expr></argument>,
<argument><expr><name>Py_FileSystemDefaultEncoding</name></expr></argument>, <argument><expr>&amp;<name>path</name></expr></argument>, <argument><expr>&amp;<name>flags</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<decl_stmt><decl><type><name>Py_BEGIN_ALLOW_THREADS</name></type>
<name>res</name> <init>= <expr><call><name>chflags</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<macro><name>Py_END_ALLOW_THREADS</name></macro>
<if>if <condition>(<expr><name>res</name> &lt; 0</expr>)</condition><then>
<return>return <expr><call><name>posix_error_with_allocated_filename</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
<expr_stmt><expr><call><name>PyMem_Free</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>Py_None</name></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_LCHFLAGS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>posix_lchflags__doc__</name></expr></argument>,
<argument><expr>"lchflags(path, flags)\n\n\
Set file flags.\n\
This function will not follow symbolic links."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>posix_lchflags</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>char</name> *</type><name>path</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>flags</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>res</name></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"etk:lchflags"</expr></argument>,
<argument><expr><name>Py_FileSystemDefaultEncoding</name></expr></argument>, <argument><expr>&amp;<name>path</name></expr></argument>, <argument><expr>&amp;<name>flags</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<decl_stmt><decl><type><name>Py_BEGIN_ALLOW_THREADS</name></type>
<name>res</name> <init>= <expr><call><name>lchflags</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<macro><name>Py_END_ALLOW_THREADS</name></macro>
<if>if <condition>(<expr><name>res</name> &lt; 0</expr>)</condition><then>
<return>return <expr><call><name>posix_error_with_allocated_filename</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
<expr_stmt><expr><call><name>PyMem_Free</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>Py_None</name></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_CHROOT</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>posix_chroot__doc__</name></expr></argument>,
<argument><expr>"chroot(path)\n\n\
Change root directory to path."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>posix_chroot</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<return>return <expr><call><name>posix_1str</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"et:chroot"</expr></argument>, <argument><expr><name>chroot</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_FSYNC</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>posix_fsync__doc__</name></expr></argument>,
<argument><expr>"fsync(fildes)\n\n\
force write of file with filedescriptor to disk."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>posix_fsync</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>fdobj</name></decl></param>)</parameter_list> <block>{
<return>return <expr><call><name>posix_fildes</name><argument_list>(<argument><expr><name>fdobj</name></expr></argument>, <argument><expr><name>fsync</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_FDATASYNC</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__hpux</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function_decl><type><specifier>extern</specifier> <name>int</name></type> <name>fdatasync</name><parameter_list>(<param><decl><type><name>int</name></type></decl></param>)</parameter_list>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>posix_fdatasync__doc__</name></expr></argument>,
<argument><expr>"fdatasync(fildes)\n\n\
force write of file with filedescriptor to disk.\n\
does not force update of metadata."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>posix_fdatasync</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>fdobj</name></decl></param>)</parameter_list> <block>{
<return>return <expr><call><name>posix_fildes</name><argument_list>(<argument><expr><name>fdobj</name></expr></argument>, <argument><expr><name>fdatasync</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_CHOWN</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>posix_chown__doc__</name></expr></argument>,
<argument><expr>"chown(path, uid, gid)\n\n\
Change the owner and group id of path to the numeric uid and gid."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>posix_chown</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>char</name> *</type><name>path</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>long</name></type> <name>uid</name></decl>, <decl><type ref="prev"/><name>gid</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>res</name></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"etll:chown"</expr></argument>,
<argument><expr><name>Py_FileSystemDefaultEncoding</name></expr></argument>, <argument><expr>&amp;<name>path</name></expr></argument>,
<argument><expr>&amp;<name>uid</name></expr></argument>, <argument><expr>&amp;<name>gid</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<decl_stmt><decl><type><name>Py_BEGIN_ALLOW_THREADS</name></type>
<name>res</name> <init>= <expr><call><name>chown</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr>(<name>uid_t</name>) <name>uid</name></expr></argument>, <argument><expr>(<name>gid_t</name>) <name>gid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<macro><name>Py_END_ALLOW_THREADS</name></macro>
<if>if <condition>(<expr><name>res</name> &lt; 0</expr>)</condition><then>
<return>return <expr><call><name>posix_error_with_allocated_filename</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
<expr_stmt><expr><call><name>PyMem_Free</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>Py_None</name></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_FCHOWN</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>posix_fchown__doc__</name></expr></argument>,
<argument><expr>"fchown(fd, uid, gid)\n\n\
Change the owner and group id of the file given by file descriptor\n\
fd to the numeric uid and gid."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>posix_fchown</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>fd</name></decl>, <decl><type ref="prev"/><name>uid</name></decl>, <decl><type ref="prev"/><name>gid</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>res</name></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"iii:chown"</expr></argument>, <argument><expr>&amp;<name>fd</name></expr></argument>, <argument><expr>&amp;<name>uid</name></expr></argument>, <argument><expr>&amp;<name>gid</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<decl_stmt><decl><type><name>Py_BEGIN_ALLOW_THREADS</name></type>
<name>res</name> <init>= <expr><call><name>fchown</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr>(<name>uid_t</name>) <name>uid</name></expr></argument>, <argument><expr>(<name>gid_t</name>) <name>gid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<macro><name>Py_END_ALLOW_THREADS</name></macro>
<if>if <condition>(<expr><name>res</name> &lt; 0</expr>)</condition><then>
<return>return <expr><call><name>posix_error</name><argument_list>()</argument_list></call></expr>;</return></then></if>
<expr_stmt><expr><name>Py_RETURN_NONE</name></expr>;</expr_stmt>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_LCHOWN</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>posix_lchown__doc__</name></expr></argument>,
<argument><expr>"lchown(path, uid, gid)\n\n\
Change the owner and group id of path to the numeric uid and gid.\n\
This function will not follow symbolic links."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>posix_lchown</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>char</name> *</type><name>path</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>uid</name></decl>, <decl><type ref="prev"/><name>gid</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>res</name></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"etii:lchown"</expr></argument>,
<argument><expr><name>Py_FileSystemDefaultEncoding</name></expr></argument>, <argument><expr>&amp;<name>path</name></expr></argument>,
<argument><expr>&amp;<name>uid</name></expr></argument>, <argument><expr>&amp;<name>gid</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<decl_stmt><decl><type><name>Py_BEGIN_ALLOW_THREADS</name></type>
<name>res</name> <init>= <expr><call><name>lchown</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr>(<name>uid_t</name>) <name>uid</name></expr></argument>, <argument><expr>(<name>gid_t</name>) <name>gid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<macro><name>Py_END_ALLOW_THREADS</name></macro>
<if>if <condition>(<expr><name>res</name> &lt; 0</expr>)</condition><then>
<return>return <expr><call><name>posix_error_with_allocated_filename</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
<expr_stmt><expr><call><name>PyMem_Free</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>Py_None</name></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_GETCWD</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>posix_getcwd__doc__</name></expr></argument>,
<argument><expr>"getcwd() -&gt; path\n\n\
Return a string representing the current working directory."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>posix_getcwd</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>noargs</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>bufsize_incr</name> <init>= <expr>1024</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>bufsize</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>tmpbuf</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>res</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>dynamic_return</name></decl>;</decl_stmt>
<macro><name>Py_BEGIN_ALLOW_THREADS</name></macro>
<do>do <block>{
<expr_stmt><expr><name>bufsize</name> = <name>bufsize</name> + <name>bufsize_incr</name></expr>;</expr_stmt>
<expr_stmt><expr><name>tmpbuf</name> = <call><name>malloc</name><argument_list>(<argument><expr><name>bufsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>tmpbuf</name> == <name>NULL</name></expr>)</condition><then> <block>{
<break>break;</break>
}</block></then></if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>PYOS_OS2</name></expr></argument>)</argument_list></call> &amp;&amp; <call><name>defined</name><argument_list>(<argument><expr><name>PYCC_GCC</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><name>res</name> = <call><name>_getcwd2</name><argument_list>(<argument><expr><name>tmpbuf</name></expr></argument>, <argument><expr><name>bufsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<expr_stmt><expr><name>res</name> = <call><name>getcwd</name><argument_list>(<argument><expr><name>tmpbuf</name></expr></argument>, <argument><expr><name>bufsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<if>if <condition>(<expr><name>res</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>tmpbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
}</block> while <condition>(<expr>(<name>res</name> == <name>NULL</name>) &amp;&amp; (<name>errno</name> == <name>ERANGE</name>)</expr>)</condition>;</do>
<macro><name>Py_END_ALLOW_THREADS</name></macro>
<if>if <condition>(<expr><name>res</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><call><name>posix_error</name><argument_list>()</argument_list></call></expr>;</return></then></if>
<expr_stmt><expr><name>dynamic_return</name> = <call><name>PyString_FromString</name><argument_list>(<argument><expr><name>tmpbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>tmpbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>dynamic_return</name></expr>;</return>
}</block></function>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>Py_USING_UNICODE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>posix_getcwdu__doc__</name></expr></argument>,
<argument><expr>"getcwdu() -&gt; path\n\n\
Return a unicode string representing the current working directory."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>posix_getcwdu</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>noargs</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>char</name></type> <name><name>buf</name><index>[<expr>1026</expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>res</name></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>Py_WIN_WIDE_FILENAMES</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>DWORD</name></type> <name>len</name></decl>;</decl_stmt>
<if>if <condition>(<expr><call><name>unicode_file_names</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>wchar_t</name></type> <name><name>wbuf</name><index>[<expr>1026</expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>wchar_t</name> *</type><name>wbuf2</name> <init>= <expr><name>wbuf</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>resobj</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_BEGIN_ALLOW_THREADS</name></type>
<name>len</name> <init>= <expr><call><name>GetCurrentDirectoryW</name><argument_list>(<argument><expr>sizeof <name>wbuf</name>/ sizeof <name><name>wbuf</name><index>[<expr>0</expr>]</index></name></expr></argument>, <argument><expr><name>wbuf</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>len</name> &gt;= sizeof <name>wbuf</name>/ sizeof <name><name>wbuf</name><index>[<expr>0</expr>]</index></name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>wbuf2</name> = <call><name>malloc</name><argument_list>(<argument><expr><name>len</name> * <sizeof>sizeof<argument_list>(<argument><expr><name>wchar_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>wbuf2</name></expr>)</condition><then>
<expr_stmt><expr><name>len</name> = <call><name>GetCurrentDirectoryW</name><argument_list>(<argument><expr><name>len</name></expr></argument>, <argument><expr><name>wbuf2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
}</block></then></if>
<macro><name>Py_END_ALLOW_THREADS</name></macro>
<if>if <condition>(<expr>!<name>wbuf2</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_NoMemory</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<if>if <condition>(<expr>!<name>len</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr><name>wbuf2</name> != <name>wbuf</name></expr>)</condition><then> <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>wbuf2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<return>return <expr><call><name>win32_error</name><argument_list>(<argument><expr>"getcwdu"</expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>resobj</name> = <call><name>PyUnicode_FromWideChar</name><argument_list>(<argument><expr><name>wbuf2</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>wbuf2</name> != <name>wbuf</name></expr>)</condition><then> <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>wbuf2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<return>return <expr><name>resobj</name></expr>;</return>
}</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<decl_stmt><decl><type><name>Py_BEGIN_ALLOW_THREADS</name></type>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>PYOS_OS2</name></expr></argument>)</argument_list></call> &amp;&amp; <call><name>defined</name><argument_list>(<argument><expr><name>PYCC_GCC</name></expr></argument>)</argument_list></call></expr></cpp:if>
<name>res</name> <init>= <expr><call><name>_getcwd2</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr>sizeof <name>buf</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<expr_stmt><expr><name>res</name> = <call><name>getcwd</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr>sizeof <name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<macro><name>Py_END_ALLOW_THREADS</name></macro>
<if>if <condition>(<expr><name>res</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><call><name>posix_error</name><argument_list>()</argument_list></call></expr>;</return></then></if>
<return>return <expr><call><name>PyUnicode_Decode</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>Py_FileSystemDefaultEncoding</name></expr></argument>,<argument><expr>"strict"</expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_LINK</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>posix_link__doc__</name></expr></argument>,
<argument><expr>"link(src, dst)\n\n\
Create a hard link to a file."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>posix_link</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<return>return <expr><call><name>posix_2str</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"etet:link"</expr></argument>, <argument><expr><name>link</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>posix_listdir__doc__</name></expr></argument>,
<argument><expr>"listdir(path) -&gt; list_of_strings\n\n\
Return a list containing the names of the entries in the directory.\n\
\n\
path: path of directory to list\n\
\n\
The list is in arbitrary order. It does not include the special\n\
entries '.' and '..' even if they are present in the directory."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>posix_listdir</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MS_WINDOWS</name></expr></argument>)</argument_list></call> &amp;&amp; !<call><name>defined</name><argument_list>(<argument><expr><name>HAVE_OPENDIR</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>d</name></decl>, *<decl><type ref="prev"/><name>v</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>HANDLE</name></type> <name>hFindFile</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BOOL</name></type> <name>result</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>WIN32_FIND_DATA</name></type> <name>FileData</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name><name>namebuf</name><index>[<expr><name>MAX_PATH</name>+5</expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>bufptr</name> <init>= <expr><name>namebuf</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>len</name> <init>= <expr><sizeof>sizeof<argument_list>(<argument><expr><name>namebuf</name></expr></argument>)</argument_list></sizeof>-5</expr></init></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>Py_WIN_WIDE_FILENAMES</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if>if <condition>(<expr><call><name>unicode_file_names</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>po</name></decl>;</decl_stmt>
<if>if <condition>(<expr><call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"U:listdir"</expr></argument>, <argument><expr>&amp;<name>po</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>WIN32_FIND_DATAW</name></type> <name>wFileData</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_UNICODE</name> *</type><name>wnamebuf</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_UNICODE</name></type> <name>wch</name></decl>;</decl_stmt>
<expr_stmt><expr><name>len</name> = <call><name>PyUnicode_GET_SIZE</name><argument_list>(<argument><expr><name>po</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>wnamebuf</name> = <call><name>malloc</name><argument_list>(<argument><expr>(<name>len</name> + 5) * <sizeof>sizeof<argument_list>(<argument><expr><name>wchar_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>wnamebuf</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_NoMemory</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><call><name>wcscpy</name><argument_list>(<argument><expr><name>wnamebuf</name></expr></argument>, <argument><expr><call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr><name>po</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>wch</name> = <name>len</name> &gt; 0 ? <name><name>wnamebuf</name><index>[<expr><name>len</name>-1</expr>]</index></name> : '\0'</expr>;</expr_stmt>
<if>if <condition>(<expr><name>wch</name> != L'/' &amp;&amp; <name>wch</name> != L'\\' &amp;&amp; <name>wch</name> != L':'</expr>)</condition><then>
<expr_stmt><expr><name><name>wnamebuf</name><index>[<expr><name>len</name>++</expr>]</index></name> = L'\\'</expr>;</expr_stmt></then></if>
<expr_stmt><expr><call><name>wcscpy</name><argument_list>(<argument><expr><name>wnamebuf</name> + <name>len</name></expr></argument>, <argument><expr>L"*.*"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>(<name>d</name> = <call><name>PyList_New</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call>) == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>wnamebuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>hFindFile</name> = <call><name>FindFirstFileW</name><argument_list>(<argument><expr><name>wnamebuf</name></expr></argument>, <argument><expr>&amp;<name>wFileData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>hFindFile</name> == <name>INVALID_HANDLE_VALUE</name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>error</name> <init>= <expr><call><name>GetLastError</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>error</name> == <name>ERROR_FILE_NOT_FOUND</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>wnamebuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>d</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>win32_error_unicode</name><argument_list>(<argument><expr>"FindFirstFileW"</expr></argument>, <argument><expr><name>wnamebuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>wnamebuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<do>do <block>{
<if>if <condition>(<expr><call><name>wcscmp</name><argument_list>(<argument><expr><name><name>wFileData</name>.<name>cFileName</name></name></expr></argument>, <argument><expr>L"."</expr></argument>)</argument_list></call> != 0 &amp;&amp;
<call><name>wcscmp</name><argument_list>(<argument><expr><name><name>wFileData</name>.<name>cFileName</name></name></expr></argument>, <argument><expr>L".."</expr></argument>)</argument_list></call> != 0</expr>)</condition><then> <block>{
<expr_stmt><expr><name>v</name> = <call><name>PyUnicode_FromUnicode</name><argument_list>(<argument><expr><name><name>wFileData</name>.<name>cFileName</name></name></expr></argument>, <argument><expr><call><name>wcslen</name><argument_list>(<argument><expr><name><name>wFileData</name>.<name>cFileName</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>v</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>d</name> = <name>NULL</name></expr>;</expr_stmt>
<break>break;</break>
}</block></then></if>
<if>if <condition>(<expr><call><name>PyList_Append</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call> != 0</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>d</name> = <name>NULL</name></expr>;</expr_stmt>
<break>break;</break>
}</block></then></if>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<decl_stmt><decl><type><name>Py_BEGIN_ALLOW_THREADS</name></type>
<name>result</name> <init>= <expr><call><name>FindNextFileW</name><argument_list>(<argument><expr><name>hFindFile</name></expr></argument>, <argument><expr>&amp;<name>wFileData</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<macro><name>Py_END_ALLOW_THREADS</name></macro>
<if>if <condition>(<expr>!<name>result</name> &amp;&amp; <call><name>GetLastError</name><argument_list>()</argument_list></call> != <name>ERROR_NO_MORE_FILES</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>win32_error_unicode</name><argument_list>(<argument><expr>"FindNextFileW"</expr></argument>, <argument><expr><name>wnamebuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>FindClose</name><argument_list>(<argument><expr><name>hFindFile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>wnamebuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
}</block> while <condition>(<expr><name>result</name> == <name>TRUE</name></expr>)</condition>;</do>
<if>if <condition>(<expr><call><name>FindClose</name><argument_list>(<argument><expr><name>hFindFile</name></expr></argument>)</argument_list></call> == <name>FALSE</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>win32_error_unicode</name><argument_list>(<argument><expr>"FindClose"</expr></argument>, <argument><expr><name>wnamebuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>wnamebuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>wnamebuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>d</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><call><name>PyErr_Clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"et#:listdir"</expr></argument>,
<argument><expr><name>Py_FileSystemDefaultEncoding</name></expr></argument>, <argument><expr>&amp;<name>bufptr</name></expr></argument>, <argument><expr>&amp;<name>len</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<if>if <condition>(<expr><name>len</name> &gt; 0</expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>char</name></type> <name>ch</name> <init>= <expr><name><name>namebuf</name><index>[<expr><name>len</name>-1</expr>]</index></name></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>ch</name> != <name>SEP</name> &amp;&amp; <name>ch</name> != <name>ALTSEP</name> &amp;&amp; <name>ch</name> != ':'</expr>)</condition><then>
<expr_stmt><expr><name><name>namebuf</name><index>[<expr><name>len</name>++</expr>]</index></name> = '/'</expr>;</expr_stmt></then></if>
}</block></then></if>
<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>namebuf</name> + <name>len</name></expr></argument>, <argument><expr>"*.*"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>(<name>d</name> = <call><name>PyList_New</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call>) == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>hFindFile</name> = <call><name>FindFirstFile</name><argument_list>(<argument><expr><name>namebuf</name></expr></argument>, <argument><expr>&amp;<name>FileData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>hFindFile</name> == <name>INVALID_HANDLE_VALUE</name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>error</name> <init>= <expr><call><name>GetLastError</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>error</name> == <name>ERROR_FILE_NOT_FOUND</name></expr>)</condition><then>
<return>return <expr><name>d</name></expr>;</return></then></if>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>win32_error</name><argument_list>(<argument><expr>"FindFirstFile"</expr></argument>, <argument><expr><name>namebuf</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></then></if>
<do>do <block>{
<if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>FileData</name>.<name>cFileName</name></name></expr></argument>, <argument><expr>"."</expr></argument>)</argument_list></call> != 0 &amp;&amp;
<call><name>strcmp</name><argument_list>(<argument><expr><name><name>FileData</name>.<name>cFileName</name></name></expr></argument>, <argument><expr>".."</expr></argument>)</argument_list></call> != 0</expr>)</condition><then> <block>{
<expr_stmt><expr><name>v</name> = <call><name>PyString_FromString</name><argument_list>(<argument><expr><name><name>FileData</name>.<name>cFileName</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>v</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>d</name> = <name>NULL</name></expr>;</expr_stmt>
<break>break;</break>
}</block></then></if>
<if>if <condition>(<expr><call><name>PyList_Append</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call> != 0</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>d</name> = <name>NULL</name></expr>;</expr_stmt>
<break>break;</break>
}</block></then></if>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<decl_stmt><decl><type><name>Py_BEGIN_ALLOW_THREADS</name></type>
<name>result</name> <init>= <expr><call><name>FindNextFile</name><argument_list>(<argument><expr><name>hFindFile</name></expr></argument>, <argument><expr>&amp;<name>FileData</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<macro><name>Py_END_ALLOW_THREADS</name></macro>
<if>if <condition>(<expr>!<name>result</name> &amp;&amp; <call><name>GetLastError</name><argument_list>()</argument_list></call> != <name>ERROR_NO_MORE_FILES</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>win32_error</name><argument_list>(<argument><expr>"FindNextFile"</expr></argument>, <argument><expr><name>namebuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>FindClose</name><argument_list>(<argument><expr><name>hFindFile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
}</block> while <condition>(<expr><name>result</name> == <name>TRUE</name></expr>)</condition>;</do>
<if>if <condition>(<expr><call><name>FindClose</name><argument_list>(<argument><expr><name>hFindFile</name></expr></argument>)</argument_list></call> == <name>FALSE</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>win32_error</name><argument_list>(<argument><expr>"FindClose"</expr></argument>, <argument><expr><name>namebuf</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></then></if>
<return>return <expr><name>d</name></expr>;</return>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>PYOS_OS2</name></expr></argument>)</argument_list></call></expr></cpp:elif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>MAX_PATH</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAX_PATH</name></cpp:macro> <cpp:value>CCHMAXPATH</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<decl_stmt><decl><type><name>char</name> *</type><name>name</name></decl>, *<decl><type ref="prev"/><name>pt</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>len</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>d</name></decl>, *<decl><type ref="prev"/><name>v</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name><name>namebuf</name><index>[<expr><name>MAX_PATH</name>+5</expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>HDIR</name></type> <name>hdir</name> <init>= <expr>1</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ULONG</name></type> <name>srchcnt</name> <init>= <expr>1</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>FILEFINDBUF3</name></type> <name>ep</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>APIRET</name></type> <name>rc</name></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"t#:listdir"</expr></argument>, <argument><expr>&amp;<name>name</name></expr></argument>, <argument><expr>&amp;<name>len</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<if>if <condition>(<expr><name>len</name> &gt;= <name>MAX_PATH</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>, <argument><expr>"path too long"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>namebuf</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for (<init><expr><name>pt</name> = <name>namebuf</name></expr>;</init> <condition><expr>*<name>pt</name></expr>;</condition> <incr><expr><name>pt</name>++</expr></incr>)
<if>if <condition>(<expr>*<name>pt</name> == <name>ALTSEP</name></expr>)</condition><then>
<expr_stmt><expr>*<name>pt</name> = <name>SEP</name></expr>;</expr_stmt></then></if></for>
<if>if <condition>(<expr><name><name>namebuf</name><index>[<expr><name>len</name>-1</expr>]</index></name> != <name>SEP</name></expr>)</condition><then>
<expr_stmt><expr><name><name>namebuf</name><index>[<expr><name>len</name>++</expr>]</index></name> = <name>SEP</name></expr>;</expr_stmt></then></if>
<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>namebuf</name> + <name>len</name></expr></argument>, <argument><expr>"*.*"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>(<name>d</name> = <call><name>PyList_New</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call>) == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>rc</name> = <call><name>DosFindFirst</name><argument_list>(<argument><expr><name>namebuf</name></expr></argument>,
<argument><expr>&amp;<name>hdir</name></expr></argument>,
<argument><expr><name>FILE_READONLY</name> | <name>FILE_HIDDEN</name> | <name>FILE_SYSTEM</name> | <name>FILE_DIRECTORY</name></expr></argument>,
<argument><expr>&amp;<name>ep</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ep</name></expr></argument>)</argument_list></sizeof></expr></argument>,
<argument><expr>&amp;<name>srchcnt</name></expr></argument>,
<argument><expr><name>FIL_STANDARD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>rc</name> != <name>NO_ERROR</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>errno</name> = <name>ENOENT</name></expr>;</expr_stmt>
<return>return <expr><call><name>posix_error_with_filename</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></then></if>
<if>if <condition>(<expr><name>srchcnt</name> &gt; 0</expr>)</condition><then> <block>{
<do>do <block>{
<if>if <condition>(<expr><name><name>ep</name>.<name>achName</name><index>[<expr>0</expr>]</index></name> == '.'
&amp;&amp; (<name><name>ep</name>.<name>achName</name><index>[<expr>1</expr>]</index></name> == '\0' || (<name><name>ep</name>.<name>achName</name><index>[<expr>1</expr>]</index></name> == '.' &amp;&amp; <name><name>ep</name>.<name>achName</name><index>[<expr>2</expr>]</index></name> == '\0'))</expr>)</condition><then>
<continue>continue;</continue></then></if>
<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>namebuf</name></expr></argument>, <argument><expr><name><name>ep</name>.<name>achName</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>v</name> = <call><name>PyString_FromString</name><argument_list>(<argument><expr><name>namebuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>v</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>d</name> = <name>NULL</name></expr>;</expr_stmt>
<break>break;</break>
}</block></then></if>
<if>if <condition>(<expr><call><name>PyList_Append</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call> != 0</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>d</name> = <name>NULL</name></expr>;</expr_stmt>
<break>break;</break>
}</block></then></if>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block> while <condition>(<expr><call><name>DosFindNext</name><argument_list>(<argument><expr><name>hdir</name></expr></argument>, <argument><expr>&amp;<name>ep</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ep</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr>&amp;<name>srchcnt</name></expr></argument>)</argument_list></call> == <name>NO_ERROR</name> &amp;&amp; <name>srchcnt</name> &gt; 0</expr>)</condition>;</do>
}</block></then></if>
<return>return <expr><name>d</name></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<decl_stmt><decl><type><name>char</name> *</type><name>name</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>d</name></decl>, *<decl><type ref="prev"/><name>v</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>DIR</name> *</type><name>dirp</name></decl>;</decl_stmt>
<decl_stmt><decl><type>struct <name>dirent</name> *</type><name>ep</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>arg_is_unicode</name> <init>= <expr>1</expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>errno</name> = 0</expr>;</expr_stmt>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"U:listdir"</expr></argument>, <argument><expr>&amp;<name>v</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><name>arg_is_unicode</name> = 0</expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyErr_Clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"et:listdir"</expr></argument>, <argument><expr><name>Py_FileSystemDefaultEncoding</name></expr></argument>, <argument><expr>&amp;<name>name</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<if>if <condition>(<expr>(<name>dirp</name> = <call><name>opendir</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call>) == <name>NULL</name></expr>)</condition><then> <block>{
<return>return <expr><call><name>posix_error_with_allocated_filename</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></then></if>
<if>if <condition>(<expr>(<name>d</name> = <call><name>PyList_New</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call>) == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>closedir</name><argument_list>(<argument><expr><name>dirp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyMem_Free</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<for>for (<init>;</init><condition>;</condition><incr/>) <block>{
<expr_stmt><expr><name>errno</name> = 0</expr>;</expr_stmt>
<decl_stmt><decl><type><name>Py_BEGIN_ALLOW_THREADS</name></type>
<name>ep</name> <init>= <expr><call><name>readdir</name><argument_list>(<argument><expr><name>dirp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<macro><name>Py_END_ALLOW_THREADS</name></macro>
<if>if <condition>(<expr><name>ep</name> == <name>NULL</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr><name>errno</name> == 0</expr>)</condition><then> <block>{
<break>break;</break>
}</block></then> <else>else <block>{
<expr_stmt><expr><call><name>closedir</name><argument_list>(<argument><expr><name>dirp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>posix_error_with_allocated_filename</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></else></if>
}</block></then></if>
<if>if <condition>(<expr><name><name>ep</name>-&gt;<name>d_name</name><index>[<expr>0</expr>]</index></name> == '.' &amp;&amp;
(<call><name>NAMLEN</name><argument_list>(<argument><expr><name>ep</name></expr></argument>)</argument_list></call> == 1 ||
(<name><name>ep</name>-&gt;<name>d_name</name><index>[<expr>1</expr>]</index></name> == '.' &amp;&amp; <call><name>NAMLEN</name><argument_list>(<argument><expr><name>ep</name></expr></argument>)</argument_list></call> == 2))</expr>)</condition><then>
<continue>continue;</continue></then></if>
<expr_stmt><expr><name>v</name> = <call><name>PyString_FromStringAndSize</name><argument_list>(<argument><expr><name><name>ep</name>-&gt;<name>d_name</name></name></expr></argument>, <argument><expr><call><name>NAMLEN</name><argument_list>(<argument><expr><name>ep</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>v</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>d</name> = <name>NULL</name></expr>;</expr_stmt>
<break>break;</break>
}</block></then></if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>Py_USING_UNICODE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if>if <condition>(<expr><name>arg_is_unicode</name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>w</name></decl>;</decl_stmt>
<expr_stmt><expr><name>w</name> = <call><name>PyUnicode_FromEncodedObject</name><argument_list>(<argument><expr><name>v</name></expr></argument>,
<argument><expr><name>Py_FileSystemDefaultEncoding</name></expr></argument>,
<argument><expr>"strict"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>w</name> != <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>v</name> = <name>w</name></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr><call><name>PyErr_Clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
}</block></else></if>
}</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<if>if <condition>(<expr><call><name>PyList_Append</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call> != 0</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>d</name> = <name>NULL</name></expr>;</expr_stmt>
<break>break;</break>
}</block></then></if>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></for>
<expr_stmt><expr><call><name>closedir</name><argument_list>(<argument><expr><name>dirp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyMem_Free</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>d</name></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></function>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MS_WINDOWS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>posix__getfullpathname</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>char</name></type> <name><name>inbuf</name><index>[<expr><name>MAX_PATH</name>*2</expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>inbufp</name> <init>= <expr><name>inbuf</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>insize</name> <init>= <expr><sizeof>sizeof<argument_list>(<argument><expr><name>inbuf</name></expr></argument>)</argument_list></sizeof></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name><name>outbuf</name><index>[<expr><name>MAX_PATH</name>*2</expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>temp</name></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>Py_WIN_WIDE_FILENAMES</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if>if <condition>(<expr><call><name>unicode_file_names</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>PyUnicodeObject</name> *</type><name>po</name></decl>;</decl_stmt>
<if>if <condition>(<expr><call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"U|:_getfullpathname"</expr></argument>, <argument><expr>&amp;<name>po</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>Py_UNICODE</name></type> <name><name>woutbuf</name><index>[<expr><name>MAX_PATH</name>*2</expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_UNICODE</name> *</type><name>wtemp</name></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>GetFullPathNameW</name><argument_list>(<argument><expr><call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr><name>po</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>woutbuf</name></expr></argument>)</argument_list></sizeof>/<sizeof>sizeof<argument_list>(<argument><expr><name><name>woutbuf</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></sizeof></expr></argument>,
<argument><expr><name>woutbuf</name></expr></argument>, <argument><expr>&amp;<name>wtemp</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><call><name>win32_error</name><argument_list>(<argument><expr>"GetFullPathName"</expr></argument>, <argument><expr>""</expr></argument>)</argument_list></call></expr>;</return></then></if>
<return>return <expr><call><name>PyUnicode_FromUnicode</name><argument_list>(<argument><expr><name>woutbuf</name></expr></argument>, <argument><expr><call><name>wcslen</name><argument_list>(<argument><expr><name>woutbuf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></then></if>
<expr_stmt><expr><call><name>PyErr_Clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name> <argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"et#:_getfullpathname"</expr></argument>,
<argument><expr><name>Py_FileSystemDefaultEncoding</name></expr></argument>, <argument><expr>&amp;<name>inbufp</name></expr></argument>,
<argument><expr>&amp;<name>insize</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<if>if <condition>(<expr>!<call><name>GetFullPathName</name><argument_list>(<argument><expr><name>inbuf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>outbuf</name></expr></argument>)</argument_list></sizeof>/<sizeof>sizeof<argument_list>(<argument><expr><name><name>outbuf</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></sizeof></expr></argument>,
<argument><expr><name>outbuf</name></expr></argument>, <argument><expr>&amp;<name>temp</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><call><name>win32_error</name><argument_list>(<argument><expr>"GetFullPathName"</expr></argument>, <argument><expr><name>inbuf</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
<if>if <condition>(<expr><call><name>PyUnicode_Check</name><argument_list>(<argument><expr><call><name>PyTuple_GetItem</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<return>return <expr><call><name>PyUnicode_Decode</name><argument_list>(<argument><expr><name>outbuf</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>outbuf</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>Py_FileSystemDefaultEncoding</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></then></if>
<return>return <expr><call><name>PyString_FromString</name><argument_list>(<argument><expr><name>outbuf</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>posix_mkdir__doc__</name></expr></argument>,
<argument><expr>"mkdir(path [, mode=0777])\n\n\
Create a directory."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>posix_mkdir</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>res</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>path</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>mode</name> <init>= <expr>0777</expr></init></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>Py_WIN_WIDE_FILENAMES</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if>if <condition>(<expr><call><name>unicode_file_names</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>PyUnicodeObject</name> *</type><name>po</name></decl>;</decl_stmt>
<if>if <condition>(<expr><call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"U|i:mkdir"</expr></argument>, <argument><expr>&amp;<name>po</name></expr></argument>, <argument><expr>&amp;<name>mode</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>Py_BEGIN_ALLOW_THREADS</name></type>
<name>res</name> <init>= <expr><call><name>CreateDirectoryW</name><argument_list>(<argument><expr><call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr><name>po</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<macro><name>Py_END_ALLOW_THREADS</name></macro>
<if>if <condition>(<expr>!<name>res</name></expr>)</condition><then>
<return>return <expr><call><name>win32_error_unicode</name><argument_list>(<argument><expr>"mkdir"</expr></argument>, <argument><expr><call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr><name>po</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></then></if>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>Py_None</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><call><name>PyErr_Clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"et|i:mkdir"</expr></argument>,
<argument><expr><name>Py_FileSystemDefaultEncoding</name></expr></argument>, <argument><expr>&amp;<name>path</name></expr></argument>, <argument><expr>&amp;<name>mode</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<decl_stmt><decl><type><name>Py_BEGIN_ALLOW_THREADS</name></type>
<name>res</name> <init>= <expr><call><name>CreateDirectoryA</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<macro><name>Py_END_ALLOW_THREADS</name></macro>
<if>if <condition>(<expr>!<name>res</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>win32_error</name><argument_list>(<argument><expr>"mkdir"</expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyMem_Free</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><call><name>PyMem_Free</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>Py_None</name></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"et|i:mkdir"</expr></argument>,
<argument><expr><name>Py_FileSystemDefaultEncoding</name></expr></argument>, <argument><expr>&amp;<name>path</name></expr></argument>, <argument><expr>&amp;<name>mode</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>Py_BEGIN_ALLOW_THREADS</name>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>( <call><name>defined</name><argument_list>(<argument><expr><name>__WATCOMC__</name></expr></argument>)</argument_list></call> || <call><name>defined</name><argument_list>(<argument><expr><name>PYCC_VACPP</name></expr></argument>)</argument_list></call> ) &amp;&amp; !<call><name>defined</name><argument_list>(<argument><expr><name>__QNX__</name></expr></argument>)</argument_list></call></expr></cpp:if>
<name>res</name> = <call><name>mkdir</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<expr_stmt><expr><name>res</name> = <call><name>mkdir</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>mode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<macro><name>Py_END_ALLOW_THREADS</name></macro>
<if>if <condition>(<expr><name>res</name> &lt; 0</expr>)</condition><then>
<return>return <expr><call><name>posix_error_with_allocated_filename</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
<expr_stmt><expr><call><name>PyMem_Free</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>Py_None</name></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></function>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_SYS_RESOURCE_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/resource.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_NICE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>posix_nice__doc__</name></expr></argument>,
<argument><expr>"nice(inc) -&gt; new_priority\n\n\
Decrease the priority of process by inc and return the new priority."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>posix_nice</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>increment</name></decl>, <decl><type ref="prev"/><name>value</name></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"i:nice"</expr></argument>, <argument><expr>&amp;<name>increment</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>errno</name> = 0</expr>;</expr_stmt>
<expr_stmt><expr><name>value</name> = <call><name>nice</name><argument_list>(<argument><expr><name>increment</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_BROKEN_NICE</name></expr></argument>)</argument_list></call> &amp;&amp; <call><name>defined</name><argument_list>(<argument><expr><name>HAVE_GETPRIORITY</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if>if <condition>(<expr><name>value</name> == 0</expr>)</condition><then>
<expr_stmt><expr><name>value</name> = <call><name>getpriority</name><argument_list>(<argument><expr><name>PRIO_PROCESS</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<if>if <condition>(<expr><name>value</name> == -1 &amp;&amp; <name>errno</name> != 0</expr>)</condition><then>
<return>return <expr><call><name>posix_error</name><argument_list>()</argument_list></call></expr>;</return></then></if>
<return>return <expr><call><name>PyInt_FromLong</name><argument_list>(<argument><expr>(<name>long</name>) <name>value</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>posix_rename__doc__</name></expr></argument>,
<argument><expr>"rename(old, new)\n\n\
Rename a file or directory."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>posix_rename</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MS_WINDOWS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>o1</name></decl>, *<decl><type ref="prev"/><name>o2</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>p1</name></decl>, *<decl><type ref="prev"/><name>p2</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BOOL</name></type> <name>result</name></decl>;</decl_stmt>
<if>if <condition>(<expr><call><name>unicode_file_names</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"OO:rename"</expr></argument>, <argument><expr>&amp;<name>o1</name></expr></argument>, <argument><expr>&amp;<name>o2</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<goto>goto <name>error</name>;</goto></then></if>
<if>if <condition>(<expr>!<call><name>convert_to_unicode</name><argument_list>(<argument><expr>&amp;<name>o1</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<goto>goto <name>error</name>;</goto></then></if>
<if>if <condition>(<expr>!<call><name>convert_to_unicode</name><argument_list>(<argument><expr>&amp;<name>o2</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>o1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>error</name>;</goto>
}</block></then></if>
<decl_stmt><decl><type><name>Py_BEGIN_ALLOW_THREADS</name></type>
<name>result</name> <init>= <expr><call><name>MoveFileW</name><argument_list>(<argument><expr><call><name>PyUnicode_AsUnicode</name><argument_list>(<argument><expr><name>o1</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name>PyUnicode_AsUnicode</name><argument_list>(<argument><expr><name>o2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<function_decl><type><name>Py_END_ALLOW_THREADS</name></type>
<name>Py_DECREF</name><parameter_list>(<param><decl><type><name>o1</name></type></decl></param>)</parameter_list>;</function_decl>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>o2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>result</name></expr>)</condition><then>
<return>return <expr><call><name>win32_error</name><argument_list>(<argument><expr>"rename"</expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>Py_None</name></expr>;</return>
<label><name>error</name>:</label>
<expr_stmt><expr><call><name>PyErr_Clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"ss:rename"</expr></argument>, <argument><expr>&amp;<name>p1</name></expr></argument>, <argument><expr>&amp;<name>p2</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<decl_stmt><decl><type><name>Py_BEGIN_ALLOW_THREADS</name></type>
<name>result</name> <init>= <expr><call><name>MoveFileA</name><argument_list>(<argument><expr><name>p1</name></expr></argument>, <argument><expr><name>p2</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<macro><name>Py_END_ALLOW_THREADS</name></macro>
<if>if <condition>(<expr>!<name>result</name></expr>)</condition><then>
<return>return <expr><call><name>win32_error</name><argument_list>(<argument><expr>"rename"</expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>Py_None</name></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<return>return <expr><call><name>posix_2str</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"etet:rename"</expr></argument>, <argument><expr><name>rename</name></expr></argument>)</argument_list></call></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>posix_rmdir__doc__</name></expr></argument>,
<argument><expr>"rmdir(path)\n\n\
Remove a directory."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>posix_rmdir</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MS_WINDOWS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<return>return <expr><call><name>win32_1str</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"rmdir"</expr></argument>, <argument><expr>"s:rmdir"</expr></argument>, <argument><expr><name>RemoveDirectoryA</name></expr></argument>, <argument><expr>"U:rmdir"</expr></argument>, <argument><expr><name>RemoveDirectoryW</name></expr></argument>)</argument_list></call></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<return>return <expr><call><name>posix_1str</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"et:rmdir"</expr></argument>, <argument><expr><name>rmdir</name></expr></argument>)</argument_list></call></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>posix_stat__doc__</name></expr></argument>,
<argument><expr>"stat(path) -&gt; stat result\n\n\
Perform a stat system call on the given path."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>posix_stat</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MS_WINDOWS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<return>return <expr><call><name>posix_do_stat</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>args</name></expr></argument>, <argument><expr>"et:stat"</expr></argument>, <argument><expr><name>STAT</name></expr></argument>, <argument><expr>"U:stat"</expr></argument>, <argument><expr><name>win32_wstat</name></expr></argument>)</argument_list></call></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<return>return <expr><call><name>posix_do_stat</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>args</name></expr></argument>, <argument><expr>"et:stat"</expr></argument>, <argument><expr><name>STAT</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></function>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_SYSTEM</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>posix_system__doc__</name></expr></argument>,
<argument><expr>"system(command) -&gt; exit_status\n\n\
Execute the command (a string) in a subshell."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>posix_system</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>char</name> *</type><name>command</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>long</name></type> <name>sts</name></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"s:system"</expr></argument>, <argument><expr>&amp;<name>command</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<decl_stmt><decl><type><name>Py_BEGIN_ALLOW_THREADS</name></type>
<name>sts</name> <init>= <expr><call><name>system</name><argument_list>(<argument><expr><name>command</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<macro><name>Py_END_ALLOW_THREADS</name></macro>
<return>return <expr><call><name>PyInt_FromLong</name><argument_list>(<argument><expr><name>sts</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>posix_umask__doc__</name></expr></argument>,
<argument><expr>"umask(new_mask) -&gt; old_mask\n\n\
Set the current numeric umask and return the previous umask."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>posix_umask</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"i:umask"</expr></argument>, <argument><expr>&amp;<name>i</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>i</name> = (<name>int</name>)<call><name>umask</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>i</name> &lt; 0</expr>)</condition><then>
<return>return <expr><call><name>posix_error</name><argument_list>()</argument_list></call></expr>;</return></then></if>
<return>return <expr><call><name>PyInt_FromLong</name><argument_list>(<argument><expr>(<name>long</name>)<name>i</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>posix_unlink__doc__</name></expr></argument>,
<argument><expr>"unlink(path)\n\n\
Remove a file (same as remove(path))."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>posix_remove__doc__</name></expr></argument>,
<argument><expr>"remove(path)\n\n\
Remove a file (same as unlink(path))."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>posix_unlink</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MS_WINDOWS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<return>return <expr><call><name>win32_1str</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"remove"</expr></argument>, <argument><expr>"s:remove"</expr></argument>, <argument><expr><name>DeleteFileA</name></expr></argument>, <argument><expr>"U:remove"</expr></argument>, <argument><expr><name>DeleteFileW</name></expr></argument>)</argument_list></call></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<return>return <expr><call><name>posix_1str</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"et:remove"</expr></argument>, <argument><expr><name>unlink</name></expr></argument>)</argument_list></call></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></function>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_UNAME</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>posix_uname__doc__</name></expr></argument>,
<argument><expr>"uname() -&gt; (sysname, nodename, release, version, machine)\n\n\
Return a tuple identifying the current operating system."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>posix_uname</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>noargs</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type>struct <name>utsname</name></type> <name>u</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>res</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_BEGIN_ALLOW_THREADS</name></type>
<name>res</name> <init>= <expr><call><name>uname</name><argument_list>(<argument><expr>&amp;<name>u</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<macro><name>Py_END_ALLOW_THREADS</name></macro>
<if>if <condition>(<expr><name>res</name> &lt; 0</expr>)</condition><then>
<return>return <expr><call><name>posix_error</name><argument_list>()</argument_list></call></expr>;</return></then></if>
<return>return <expr><call><name>Py_BuildValue</name><argument_list>(<argument><expr>"(sssss)"</expr></argument>,
<argument><expr><name><name>u</name>.<name>sysname</name></name></expr></argument>,
<argument><expr><name><name>u</name>.<name>nodename</name></name></expr></argument>,
<argument><expr><name><name>u</name>.<name>release</name></name></expr></argument>,
<argument><expr><name><name>u</name>.<name>version</name></name></expr></argument>,
<argument><expr><name><name>u</name>.<name>machine</name></name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>extract_time</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>t</name></decl></param>, <param><decl><type><name>long</name>*</type> <name>sec</name></decl></param>, <param><decl><type><name>long</name>*</type> <name>usec</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>long</name></type> <name>intval</name></decl>;</decl_stmt>
<if>if <condition>(<expr><call><name>PyFloat_Check</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>double</name></type> <name>tval</name> <init>= <expr><call><name>PyFloat_AsDouble</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>intobj</name> <init>= <expr><call><name>Py_TYPE</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call>-&gt;<call><name><name>tp_as_number</name>-&gt;<name>nb_int</name></name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr>!<name>intobj</name></expr>)</condition><then>
<return>return <expr>-1</expr>;</return></then></if>
<expr_stmt><expr><name>intval</name> = <call><name>PyInt_AsLong</name><argument_list>(<argument><expr><name>intobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>intobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>intval</name> == -1 &amp;&amp; <call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then>
<return>return <expr>-1</expr>;</return></then></if>
<expr_stmt><expr>*<name>sec</name> = <name>intval</name></expr>;</expr_stmt>
<expr_stmt><expr>*<name>usec</name> = <call>(<name>long</name>)<argument_list>(<argument><expr>(<name>tval</name> - <name>intval</name>) * 1e6</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>*<name>usec</name> &lt; 0</expr>)</condition><then>
<expr_stmt><expr>*<name>usec</name> = 0</expr>;</expr_stmt></then></if>
<return>return <expr>0</expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>intval</name> = <call><name>PyInt_AsLong</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>intval</name> == -1 &amp;&amp; <call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then>
<return>return <expr>-1</expr>;</return></then></if>
<expr_stmt><expr>*<name>sec</name> = <name>intval</name></expr>;</expr_stmt>
<expr_stmt><expr>*<name>usec</name> = 0</expr>;</expr_stmt>
<return>return <expr>0</expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>posix_utime__doc__</name></expr></argument>,
<argument><expr>"utime(path, (atime, mtime))\n\
utime(path, None)\n\n\
Set the access and modified time of the file to the given values. If the\n\
second form is used, set the access and modified times to the current time."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>posix_utime</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>Py_WIN_WIDE_FILENAMES</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>arg</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyUnicodeObject</name> *</type><name>obwpath</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>wchar_t</name> *</type><name>wpath</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>apath</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>HANDLE</name></type> <name>hFile</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>long</name></type> <name>atimesec</name></decl>, <decl><type ref="prev"/><name>mtimesec</name></decl>, <decl><type ref="prev"/><name>ausec</name></decl>, <decl><type ref="prev"/><name>musec</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>FILETIME</name></type> <name>atime</name></decl>, <decl><type ref="prev"/><name>mtime</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>result</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><call><name>unicode_file_names</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
<if>if <condition>(<expr><call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"UO|:utime"</expr></argument>, <argument><expr>&amp;<name>obwpath</name></expr></argument>, <argument><expr>&amp;<name>arg</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><name>wpath</name> = <call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr><name>obwpath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>Py_BEGIN_ALLOW_THREADS</name></type>
<name>hFile</name> <init>= <expr><call><name>CreateFileW</name><argument_list>(<argument><expr><name>wpath</name></expr></argument>, <argument><expr><name>FILE_WRITE_ATTRIBUTES</name></expr></argument>, <argument><expr>0</expr></argument>,
<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>OPEN_EXISTING</name></expr></argument>,
<argument><expr><name>FILE_FLAG_BACKUP_SEMANTICS</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<macro><name>Py_END_ALLOW_THREADS</name></macro>
<if>if <condition>(<expr><name>hFile</name> == <name>INVALID_HANDLE_VALUE</name></expr>)</condition><then>
<return>return <expr><call><name>win32_error_unicode</name><argument_list>(<argument><expr>"utime"</expr></argument>, <argument><expr><name>wpath</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
}</block></then> <else>else
<expr_stmt><expr><call><name>PyErr_Clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt></else></if>
}</block></then></if>
<if>if <condition>(<expr>!<name>wpath</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"etO:utime"</expr></argument>,
<argument><expr><name>Py_FileSystemDefaultEncoding</name></expr></argument>, <argument><expr>&amp;<name>apath</name></expr></argument>, <argument><expr>&amp;<name>arg</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<decl_stmt><decl><type><name>Py_BEGIN_ALLOW_THREADS</name></type>
<name>hFile</name> <init>= <expr><call><name>CreateFileA</name><argument_list>(<argument><expr><name>apath</name></expr></argument>, <argument><expr><name>FILE_WRITE_ATTRIBUTES</name></expr></argument>, <argument><expr>0</expr></argument>,
<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>OPEN_EXISTING</name></expr></argument>,
<argument><expr><name>FILE_FLAG_BACKUP_SEMANTICS</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<macro><name>Py_END_ALLOW_THREADS</name></macro>
<if>if <condition>(<expr><name>hFile</name> == <name>INVALID_HANDLE_VALUE</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>win32_error</name><argument_list>(<argument><expr>"utime"</expr></argument>, <argument><expr><name>apath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyMem_Free</name><argument_list>(<argument><expr><name>apath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><call><name>PyMem_Free</name><argument_list>(<argument><expr><name>apath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<if>if <condition>(<expr><name>arg</name> == <name>Py_None</name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>SYSTEMTIME</name></type> <name>now</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>GetSystemTime</name><argument_list>(<argument><expr>&amp;<name>now</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<call><name>SystemTimeToFileTime</name><argument_list>(<argument><expr>&amp;<name>now</name></expr></argument>, <argument><expr>&amp;<name>mtime</name></expr></argument>)</argument_list></call> ||
!<call><name>SystemTimeToFileTime</name><argument_list>(<argument><expr>&amp;<name>now</name></expr></argument>, <argument><expr>&amp;<name>atime</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>win32_error</name><argument_list>(<argument><expr>"utime"</expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>done</name>;</goto>
}</block></then></if>
}</block></then> <else>else <if>if <condition>(<expr>!<call><name>PyTuple_Check</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call> || <call><name>PyTuple_Size</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call> != 2</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
<argument><expr>"utime() arg 2 must be a tuple (atime, mtime)"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>done</name>;</goto>
}</block></then> <else>else <block>{
<if>if <condition>(<expr><call><name>extract_time</name><argument_list>(<argument><expr><call><name>PyTuple_GET_ITEM</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></argument>,
<argument><expr>&amp;<name>atimesec</name></expr></argument>, <argument><expr>&amp;<name>ausec</name></expr></argument>)</argument_list></call> == -1</expr>)</condition><then>
<goto>goto <name>done</name>;</goto></then></if>
<expr_stmt><expr><call><name>time_t_to_FILE_TIME</name><argument_list>(<argument><expr><name>atimesec</name></expr></argument>, <argument><expr>1000*<name>ausec</name></expr></argument>, <argument><expr>&amp;<name>atime</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>extract_time</name><argument_list>(<argument><expr><call><name>PyTuple_GET_ITEM</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr></argument>,
<argument><expr>&amp;<name>mtimesec</name></expr></argument>, <argument><expr>&amp;<name>musec</name></expr></argument>)</argument_list></call> == -1</expr>)</condition><then>
<goto>goto <name>done</name>;</goto></then></if>
<expr_stmt><expr><call><name>time_t_to_FILE_TIME</name><argument_list>(<argument><expr><name>mtimesec</name></expr></argument>, <argument><expr>1000*<name>musec</name></expr></argument>, <argument><expr>&amp;<name>mtime</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></else></if></else></if>
<if>if <condition>(<expr>!<call><name>SetFileTime</name><argument_list>(<argument><expr><name>hFile</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr>&amp;<name>atime</name></expr></argument>, <argument><expr>&amp;<name>mtime</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>win32_error</name><argument_list>(<argument><expr>"utime"</expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>result</name> = <name>Py_None</name></expr>;</expr_stmt>
<label><name>done</name>:</label>
<expr_stmt><expr><call><name>CloseHandle</name><argument_list>(<argument><expr><name>hFile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>result</name></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<decl_stmt><decl><type><name>char</name> *</type><name>path</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>long</name></type> <name>atime</name></decl>, <decl><type ref="prev"/><name>mtime</name></decl>, <decl><type ref="prev"/><name>ausec</name></decl>, <decl><type ref="prev"/><name>musec</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>res</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name>*</type> <name>arg</name></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_UTIMES</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type>struct <name>timeval</name></type> <name><name>buf</name><index>[<expr>2</expr>]</index></name></decl>;</decl_stmt>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ATIME</name></cpp:macro> <cpp:value>buf[0].tv_sec</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MTIME</name></cpp:macro> <cpp:value>buf[1].tv_sec</cpp:value></cpp:define>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_UTIME_H</name></expr></argument>)</argument_list></call></expr></cpp:elif>
<decl_stmt><decl><type>struct <name>utimbuf</name></type> <name>buf</name></decl>;</decl_stmt>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ATIME</name></cpp:macro> <cpp:value>buf.actime</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MTIME</name></cpp:macro> <cpp:value>buf.modtime</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>UTIME_ARG</name></cpp:macro> <cpp:value>&amp;buf</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<decl_stmt><decl><type><name>time_t</name></type> <name><name>buf</name><index>[<expr>2</expr>]</index></name></decl>;</decl_stmt>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ATIME</name></cpp:macro> <cpp:value>buf[0]</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MTIME</name></cpp:macro> <cpp:value>buf[1]</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>UTIME_ARG</name></cpp:macro> <cpp:value>buf</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"etO:utime"</expr></argument>,
<argument><expr><name>Py_FileSystemDefaultEncoding</name></expr></argument>, <argument><expr>&amp;<name>path</name></expr></argument>, <argument><expr>&amp;<name>arg</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<if>if <condition>(<expr><name>arg</name> == <name>Py_None</name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>Py_BEGIN_ALLOW_THREADS</name></type>
<name>res</name> <init>= <expr><call><name>utime</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>Py_END_ALLOW_THREADS</name></expr></expr_stmt>
}</block></then> <else>else <if>if <condition>(<expr>!<call><name>PyTuple_Check</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call> || <call><name>PyTuple_Size</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call> != 2</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
<argument><expr>"utime() arg 2 must be a tuple (atime, mtime)"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyMem_Free</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then> <else>else <block>{
<if>if <condition>(<expr><call><name>extract_time</name><argument_list>(<argument><expr><call><name>PyTuple_GET_ITEM</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></argument>,
<argument><expr>&amp;<name>atime</name></expr></argument>, <argument><expr>&amp;<name>ausec</name></expr></argument>)</argument_list></call> == -1</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyMem_Free</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<if>if <condition>(<expr><call><name>extract_time</name><argument_list>(<argument><expr><call><name>PyTuple_GET_ITEM</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr></argument>,
<argument><expr>&amp;<name>mtime</name></expr></argument>, <argument><expr>&amp;<name>musec</name></expr></argument>)</argument_list></call> == -1</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyMem_Free</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>ATIME</name> = <name>atime</name></expr>;</expr_stmt>
<expr_stmt><expr><name>MTIME</name> = <name>mtime</name></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_UTIMES</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><name><name>buf</name><index>[<expr>0</expr>]</index></name>.<name>tv_usec</name> = <name>ausec</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>buf</name><index>[<expr>1</expr>]</index></name>.<name>tv_usec</name> = <name>musec</name></expr>;</expr_stmt>
<decl_stmt><decl><type><name>Py_BEGIN_ALLOW_THREADS</name></type>
<name>res</name> <init>= <expr><call><name>utimes</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>Py_END_ALLOW_THREADS</name>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<name>Py_BEGIN_ALLOW_THREADS</name>
<name>res</name> = <call><name>utime</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>UTIME_ARG</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>Py_END_ALLOW_THREADS</name></expr></expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></else></if></else></if>
<if>if <condition>(<expr><name>res</name> &lt; 0</expr>)</condition><then> <block>{
<return>return <expr><call><name>posix_error_with_allocated_filename</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></then></if>
<expr_stmt><expr><call><name>PyMem_Free</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>Py_None</name></expr>;</return>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>UTIME_ARG</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>ATIME</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>MTIME</name></cpp:undef>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>posix__exit__doc__</name></expr></argument>,
<argument><expr>"_exit(status)\n\n\
Exit to the system with specified status, without normal exit processing."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>posix__exit</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>sts</name></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"i:_exit"</expr></argument>, <argument><expr>&amp;<name>sts</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><call><name>_exit</name><argument_list>(<argument><expr><name>sts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></function>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_EXECV</name></expr></argument>)</argument_list></call> || <call><name>defined</name><argument_list>(<argument><expr><name>HAVE_SPAWNV</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>free_string_array</name><parameter_list>(<param><decl><type><name>char</name> **</type><name>array</name></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>count</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>i</name></decl>;</decl_stmt>
<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>count</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
<expr_stmt><expr><call><name>PyMem_Free</name><argument_list>(<argument><expr><name><name>array</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></for>
<expr_stmt><expr><call><name>PyMem_DEL</name><argument_list>(<argument><expr><name>array</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_EXECV</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>posix_execv__doc__</name></expr></argument>,
<argument><expr>"execv(path, args)\n\n\
Execute an executable path with arguments, replacing current process.\n\
\n\
path: path of executable file\n\
args: tuple or list of strings"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>posix_execv</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>char</name> *</type><name>path</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>argv</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> **</type><name>argvlist</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>argc</name></decl>;</decl_stmt>
<function_decl><type><name>PyObject</name> *</type>(*<name>getitem</name>)<parameter_list>(<param><decl><type><name>PyObject</name> *</type></decl></param>, <param><decl><type><name>Py_ssize_t</name></type></decl></param>)</parameter_list>;</function_decl>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"etO:execv"</expr></argument>,
<argument><expr><name>Py_FileSystemDefaultEncoding</name></expr></argument>,
<argument><expr>&amp;<name>path</name></expr></argument>, <argument><expr>&amp;<name>argv</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<if>if <condition>(<expr><call><name>PyList_Check</name><argument_list>(<argument><expr><name>argv</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><name>argc</name> = <call><name>PyList_Size</name><argument_list>(<argument><expr><name>argv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>getitem</name> = <name>PyList_GetItem</name></expr>;</expr_stmt>
}</block></then> <else>else <if>if <condition>(<expr><call><name>PyTuple_Check</name><argument_list>(<argument><expr><name>argv</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><name>argc</name> = <call><name>PyTuple_Size</name><argument_list>(<argument><expr><name>argv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>getitem</name> = <name>PyTuple_GetItem</name></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>, <argument><expr>"execv() arg 2 must be a tuple or list"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyMem_Free</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></else></if></else></if>
<expr_stmt><expr><name>argvlist</name> = <call><name>PyMem_NEW</name><argument_list>(<argument><expr><name>char</name> *</expr></argument>, <argument><expr><name>argc</name>+1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>argvlist</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyMem_Free</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>PyErr_NoMemory</name><argument_list>()</argument_list></call></expr>;</return>
}</block></then></if>
<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>argc</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
<if>if <condition>(<expr>!<call><name>PyArg_Parse</name><argument_list>(<argument><expr><call>(*<name>getitem</name>)<argument_list>(<argument><expr><name>argv</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>"et"</expr></argument>,
<argument><expr><name>Py_FileSystemDefaultEncoding</name></expr></argument>,
<argument><expr>&amp;<name><name>argvlist</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>free_string_array</name><argument_list>(<argument><expr><name>argvlist</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
<argument><expr>"execv() arg 2 must contain only strings"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyMem_Free</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
}</block></for>
<expr_stmt><expr><name><name>argvlist</name><index>[<expr><name>argc</name></expr>]</index></name> = <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>execv</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>argvlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free_string_array</name><argument_list>(<argument><expr><name>argvlist</name></expr></argument>, <argument><expr><name>argc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyMem_Free</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>posix_error</name><argument_list>()</argument_list></call></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>posix_execve__doc__</name></expr></argument>,
<argument><expr>"execve(path, args, env)\n\n\
Execute a path with arguments and environment, replacing current process.\n\
\n\
path: path of executable file\n\
args: tuple or list of arguments\n\
env: dictionary of strings mapping to strings"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>posix_execve</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>char</name> *</type><name>path</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>argv</name></decl>, *<decl><type ref="prev"/><name>env</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> **</type><name>argvlist</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> **</type><name>envlist</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>key</name></decl>, *<decl><type ref="prev"/><name>val</name></decl>, *<decl><type ref="prev"/><name>keys</name><init>=<expr><name>NULL</name></expr></init>, *<name>vals</name><init>=<expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>pos</name></decl>, <decl><type ref="prev"/><name>argc</name></decl>, <decl><type ref="prev"/><name>envc</name></decl>;</decl_stmt>
<function_decl><type><name>PyObject</name> *</type>(*<name>getitem</name>)<parameter_list>(<param><decl><type><name>PyObject</name> *</type></decl></param>, <param><decl><type><name>Py_ssize_t</name></type></decl></param>)</parameter_list>;</function_decl>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>lastarg</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"etOO:execve"</expr></argument>,
<argument><expr><name>Py_FileSystemDefaultEncoding</name></expr></argument>,
<argument><expr>&amp;<name>path</name></expr></argument>, <argument><expr>&amp;<name>argv</name></expr></argument>, <argument><expr>&amp;<name>env</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<if>if <condition>(<expr><call><name>PyList_Check</name><argument_list>(<argument><expr><name>argv</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><name>argc</name> = <call><name>PyList_Size</name><argument_list>(<argument><expr><name>argv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>getitem</name> = <name>PyList_GetItem</name></expr>;</expr_stmt>
}</block></then> <else>else <if>if <condition>(<expr><call><name>PyTuple_Check</name><argument_list>(<argument><expr><name>argv</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><name>argc</name> = <call><name>PyTuple_Size</name><argument_list>(<argument><expr><name>argv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>getitem</name> = <name>PyTuple_GetItem</name></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
<argument><expr>"execve() arg 2 must be a tuple or list"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>fail_0</name>;</goto>
}</block></else></if></else></if>
<if>if <condition>(<expr>!<call><name>PyMapping_Check</name><argument_list>(<argument><expr><name>env</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
<argument><expr>"execve() arg 3 must be a mapping object"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>fail_0</name>;</goto>
}</block></then></if>
<expr_stmt><expr><name>argvlist</name> = <call><name>PyMem_NEW</name><argument_list>(<argument><expr><name>char</name> *</expr></argument>, <argument><expr><name>argc</name>+1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>argvlist</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_NoMemory</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>fail_0</name>;</goto>
}</block></then></if>
<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>argc</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
<if>if <condition>(<expr>!<call><name>PyArg_Parse</name><argument_list>(<argument><expr><call>(*<name>getitem</name>)<argument_list>(<argument><expr><name>argv</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr>"et;execve() arg 2 must contain only strings"</expr></argument>,
<argument><expr><name>Py_FileSystemDefaultEncoding</name></expr></argument>,
<argument><expr>&amp;<name><name>argvlist</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><name>lastarg</name> = <name>i</name></expr>;</expr_stmt>
<goto>goto <name>fail_1</name>;</goto>
}</block></then></if>
}</block></for>
<expr_stmt><expr><name>lastarg</name> = <name>argc</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>argvlist</name><index>[<expr><name>argc</name></expr>]</index></name> = <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name>i</name> = <call><name>PyMapping_Size</name><argument_list>(<argument><expr><name>env</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>i</name> &lt; 0</expr>)</condition><then>
<goto>goto <name>fail_1</name>;</goto></then></if>
<expr_stmt><expr><name>envlist</name> = <call><name>PyMem_NEW</name><argument_list>(<argument><expr><name>char</name> *</expr></argument>, <argument><expr><name>i</name> + 1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>envlist</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_NoMemory</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>fail_1</name>;</goto>
}</block></then></if>
<expr_stmt><expr><name>envc</name> = 0</expr>;</expr_stmt>
<expr_stmt><expr><name>keys</name> = <call><name>PyMapping_Keys</name><argument_list>(<argument><expr><name>env</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>vals</name> = <call><name>PyMapping_Values</name><argument_list>(<argument><expr><name>env</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>keys</name> || !<name>vals</name></expr>)</condition><then>
<goto>goto <name>fail_2</name>;</goto></then></if>
<if>if <condition>(<expr>!<call><name>PyList_Check</name><argument_list>(<argument><expr><name>keys</name></expr></argument>)</argument_list></call> || !<call><name>PyList_Check</name><argument_list>(<argument><expr><name>vals</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
<argument><expr>"execve(): env.keys() or env.values() is not a list"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>fail_2</name>;</goto>
}</block></then></if>
<for>for (<init><expr><name>pos</name> = 0</expr>;</init> <condition><expr><name>pos</name> &lt; <name>i</name></expr>;</condition> <incr><expr><name>pos</name>++</expr></incr>) <block>{
<decl_stmt><decl><type><name>char</name> *</type><name>p</name></decl>, *<decl><type ref="prev"/><name>k</name></decl>, *<decl><type ref="prev"/><name>v</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>len</name></decl>;</decl_stmt>
<expr_stmt><expr><name>key</name> = <call><name>PyList_GetItem</name><argument_list>(<argument><expr><name>keys</name></expr></argument>, <argument><expr><name>pos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>val</name> = <call><name>PyList_GetItem</name><argument_list>(<argument><expr><name>vals</name></expr></argument>, <argument><expr><name>pos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>key</name> || !<name>val</name></expr>)</condition><then>
<goto>goto <name>fail_2</name>;</goto></then></if>
<if>if <condition>(<expr>!<call><name>PyArg_Parse</name><argument_list>(
<argument><expr><name>key</name></expr></argument>,
<argument><expr>"s;execve() arg 3 contains a non-string key"</expr></argument>,
<argument><expr>&amp;<name>k</name></expr></argument>)</argument_list></call> ||
!<call><name>PyArg_Parse</name><argument_list>(
<argument><expr><name>val</name></expr></argument>,
<argument><expr>"s;execve() arg 3 contains a non-string value"</expr></argument>,
<argument><expr>&amp;<name>v</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<goto>goto <name>fail_2</name>;</goto>
}</block></then></if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>PYOS_OS2</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if>if <condition>(<expr><call><name>stricmp</name><argument_list>(<argument><expr><name>k</name></expr></argument>, <argument><expr>"BEGINLIBPATH"</expr></argument>)</argument_list></call> != 0 &amp;&amp; <call><name>stricmp</name><argument_list>(<argument><expr><name>k</name></expr></argument>, <argument><expr>"ENDLIBPATH"</expr></argument>)</argument_list></call> != 0</expr>)</condition><then> <block>{
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><name>len</name> = <call><name>PyString_Size</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call> + <call><name>PyString_Size</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call> + 2</expr>;</expr_stmt>
<expr_stmt><expr><name>p</name> = <call><name>PyMem_NEW</name><argument_list>(<argument><expr><name>char</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>p</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_NoMemory</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>fail_2</name>;</goto>
}</block></then></if>
<expr_stmt><expr><call><name>PyOS_snprintf</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr>"%s=%s"</expr></argument>, <argument><expr><name>k</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>envlist</name><index>[<expr><name>envc</name>++</expr>]</index></name> = <name>p</name></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>PYOS_OS2</name></expr></argument>)</argument_list></call></expr></cpp:if>
}</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></for>
<expr_stmt><expr><name><name>envlist</name><index>[<expr><name>envc</name></expr>]</index></name> = 0</expr>;</expr_stmt>
<expr_stmt><expr><call><name>execve</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>argvlist</name></expr></argument>, <argument><expr><name>envlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr>(<name>void</name>) <call><name>posix_error</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<label><name>fail_2</name>:</label>
<while>while <condition>(<expr>--<name>envc</name> &gt;= 0</expr>)</condition>
<expr_stmt><expr><call><name>PyMem_DEL</name><argument_list>(<argument><expr><name><name>envlist</name><index>[<expr><name>envc</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></while>
<expr_stmt><expr><call><name>PyMem_DEL</name><argument_list>(<argument><expr><name>envlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<label><name>fail_1</name>:</label>
<expr_stmt><expr><call><name>free_string_array</name><argument_list>(<argument><expr><name>argvlist</name></expr></argument>, <argument><expr><name>lastarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>vals</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>keys</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<label><name>fail_0</name>:</label>
<expr_stmt><expr><call><name>PyMem_Free</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_SPAWNV</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>posix_spawnv__doc__</name></expr></argument>,
<argument><expr>"spawnv(mode, path, args)\n\n\
Execute the program 'path' in a new process.\n\
\n\
mode: mode of process creation\n\
path: path of executable file\n\
args: tuple or list of strings"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>posix_spawnv</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>char</name> *</type><name>path</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>argv</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> **</type><name>argvlist</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>mode</name></decl>, <decl><type ref="prev"/><name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>argc</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_intptr_t</name></type> <name>spawnval</name></decl>;</decl_stmt>
<function_decl><type><name>PyObject</name> *</type>(*<name>getitem</name>)<parameter_list>(<param><decl><type><name>PyObject</name> *</type></decl></param>, <param><decl><type><name>Py_ssize_t</name></type></decl></param>)</parameter_list>;</function_decl>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"ietO:spawnv"</expr></argument>, <argument><expr>&amp;<name>mode</name></expr></argument>,
<argument><expr><name>Py_FileSystemDefaultEncoding</name></expr></argument>,
<argument><expr>&amp;<name>path</name></expr></argument>, <argument><expr>&amp;<name>argv</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<if>if <condition>(<expr><call><name>PyList_Check</name><argument_list>(<argument><expr><name>argv</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><name>argc</name> = <call><name>PyList_Size</name><argument_list>(<argument><expr><name>argv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>getitem</name> = <name>PyList_GetItem</name></expr>;</expr_stmt>
}</block></then> <else>else <if>if <condition>(<expr><call><name>PyTuple_Check</name><argument_list>(<argument><expr><name>argv</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><name>argc</name> = <call><name>PyTuple_Size</name><argument_list>(<argument><expr><name>argv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>getitem</name> = <name>PyTuple_GetItem</name></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
<argument><expr>"spawnv() arg 2 must be a tuple or list"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyMem_Free</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></else></if></else></if>
<expr_stmt><expr><name>argvlist</name> = <call><name>PyMem_NEW</name><argument_list>(<argument><expr><name>char</name> *</expr></argument>, <argument><expr><name>argc</name>+1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>argvlist</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyMem_Free</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>PyErr_NoMemory</name><argument_list>()</argument_list></call></expr>;</return>
}</block></then></if>
<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>argc</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
<if>if <condition>(<expr>!<call><name>PyArg_Parse</name><argument_list>(<argument><expr><call>(*<name>getitem</name>)<argument_list>(<argument><expr><name>argv</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>"et"</expr></argument>,
<argument><expr><name>Py_FileSystemDefaultEncoding</name></expr></argument>,
<argument><expr>&amp;<name><name>argvlist</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>free_string_array</name><argument_list>(<argument><expr><name>argvlist</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(
<argument><expr><name>PyExc_TypeError</name></expr></argument>,
<argument><expr>"spawnv() arg 2 must contain only strings"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyMem_Free</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
}</block></for>
<expr_stmt><expr><name><name>argvlist</name><index>[<expr><name>argc</name></expr>]</index></name> = <name>NULL</name></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>PYOS_OS2</name></expr></argument>)</argument_list></call> &amp;&amp; <call><name>defined</name><argument_list>(<argument><expr><name>PYCC_GCC</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>Py_BEGIN_ALLOW_THREADS</name></type>
<name>spawnval</name> <init>= <expr><call><name>spawnv</name><argument_list>(<argument><expr><name>mode</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>argvlist</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<function_decl><type><name>Py_END_ALLOW_THREADS</name></type>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
if (<name>mode</name> == <name>_OLD_P_OVERLAY</name></function_decl>)</block>
mode = _P_OVERLAY;</function>
<decl_stmt><decl><type><name>Py_BEGIN_ALLOW_THREADS</name></type>
<name>spawnval</name> <init>= <expr><call><name>_spawnv</name><argument_list>(<argument><expr><name>mode</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>argvlist</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<function_decl><type><name>Py_END_ALLOW_THREADS</name></type>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<name>free_string_array</name><parameter_list>(<param><decl><type><name>argvlist</name></type></decl></param>, <param><decl><type><name>argc</name></type></decl></param>)</parameter_list>;</function_decl>
<expr_stmt><expr><call><name>PyMem_Free</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>spawnval</name> == -1</expr>)</condition><then>
<return>return <expr><call><name>posix_error</name><argument_list>()</argument_list></call></expr>;</return></then>
<else>else
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SIZEOF_LONG</name> == <name>SIZEOF_VOID_P</name></expr></cpp:if>
<return>return <expr><call><name>Py_BuildValue</name><argument_list>(<argument><expr>"l"</expr></argument>, <argument><expr>(<name>long</name>) <name>spawnval</name></expr></argument>)</argument_list></call></expr>;</return></else></if>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<return>return <expr><call><name>Py_BuildValue</name><argument_list>(<argument><expr>"L"</expr></argument>, <argument><expr>(<name>PY_LONG_LONG</name>) <name>spawnval</name></expr></argument>)</argument_list></call></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></extern>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>posix_spawnve__doc__</name></expr></argument>,
<argument><expr>"spawnve(mode, path, args, env)\n\n\
Execute the program 'path' in a new process.\n\
\n\
mode: mode of process creation\n\
path: path of executable file\n\
args: tuple or list of arguments\n\
env: dictionary of strings mapping to strings"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>posix_spawnve</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>char</name> *</type><name>path</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>argv</name></decl>, *<decl><type ref="prev"/><name>env</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> **</type><name>argvlist</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> **</type><name>envlist</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>key</name></decl>, *<decl><type ref="prev"/><name>val</name></decl>, *<decl><type ref="prev"/><name>keys</name><init>=<expr><name>NULL</name></expr></init>, *<name>vals</name><init>=<expr><name>NULL</name></expr></init>, *<name>res</name><init>=<expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>mode</name></decl>, <decl><type ref="prev"/><name>pos</name></decl>, <decl><type ref="prev"/><name>envc</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>argc</name></decl>, <decl><type ref="prev"/><name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_intptr_t</name></type> <name>spawnval</name></decl>;</decl_stmt>
<function_decl><type><name>PyObject</name> *</type>(*<name>getitem</name>)<parameter_list>(<param><decl><type><name>PyObject</name> *</type></decl></param>, <param><decl><type><name>Py_ssize_t</name></type></decl></param>)</parameter_list>;</function_decl>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>lastarg</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"ietOO:spawnve"</expr></argument>, <argument><expr>&amp;<name>mode</name></expr></argument>,
<argument><expr><name>Py_FileSystemDefaultEncoding</name></expr></argument>,
<argument><expr>&amp;<name>path</name></expr></argument>, <argument><expr>&amp;<name>argv</name></expr></argument>, <argument><expr>&amp;<name>env</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<if>if <condition>(<expr><call><name>PyList_Check</name><argument_list>(<argument><expr><name>argv</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><name>argc</name> = <call><name>PyList_Size</name><argument_list>(<argument><expr><name>argv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>getitem</name> = <name>PyList_GetItem</name></expr>;</expr_stmt>
}</block></then> <else>else <if>if <condition>(<expr><call><name>PyTuple_Check</name><argument_list>(<argument><expr><name>argv</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><name>argc</name> = <call><name>PyTuple_Size</name><argument_list>(<argument><expr><name>argv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>getitem</name> = <name>PyTuple_GetItem</name></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
<argument><expr>"spawnve() arg 2 must be a tuple or list"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>fail_0</name>;</goto>
}</block></else></if></else></if>
<if>if <condition>(<expr>!<call><name>PyMapping_Check</name><argument_list>(<argument><expr><name>env</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
<argument><expr>"spawnve() arg 3 must be a mapping object"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>fail_0</name>;</goto>
}</block></then></if>
<expr_stmt><expr><name>argvlist</name> = <call><name>PyMem_NEW</name><argument_list>(<argument><expr><name>char</name> *</expr></argument>, <argument><expr><name>argc</name>+1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>argvlist</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_NoMemory</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>fail_0</name>;</goto>
}</block></then></if>
<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>argc</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
<if>if <condition>(<expr>!<call><name>PyArg_Parse</name><argument_list>(<argument><expr><call>(*<name>getitem</name>)<argument_list>(<argument><expr><name>argv</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr>"et;spawnve() arg 2 must contain only strings"</expr></argument>,
<argument><expr><name>Py_FileSystemDefaultEncoding</name></expr></argument>,
<argument><expr>&amp;<name><name>argvlist</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><name>lastarg</name> = <name>i</name></expr>;</expr_stmt>
<goto>goto <name>fail_1</name>;</goto>
}</block></then></if>
}</block></for>
<expr_stmt><expr><name>lastarg</name> = <name>argc</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>argvlist</name><index>[<expr><name>argc</name></expr>]</index></name> = <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name>i</name> = <call><name>PyMapping_Size</name><argument_list>(<argument><expr><name>env</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>i</name> &lt; 0</expr>)</condition><then>
<goto>goto <name>fail_1</name>;</goto></then></if>
<expr_stmt><expr><name>envlist</name> = <call><name>PyMem_NEW</name><argument_list>(<argument><expr><name>char</name> *</expr></argument>, <argument><expr><name>i</name> + 1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>envlist</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_NoMemory</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>fail_1</name>;</goto>
}</block></then></if>
<expr_stmt><expr><name>envc</name> = 0</expr>;</expr_stmt>
<expr_stmt><expr><name>keys</name> = <call><name>PyMapping_Keys</name><argument_list>(<argument><expr><name>env</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>vals</name> = <call><name>PyMapping_Values</name><argument_list>(<argument><expr><name>env</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>keys</name> || !<name>vals</name></expr>)</condition><then>
<goto>goto <name>fail_2</name>;</goto></then></if>
<if>if <condition>(<expr>!<call><name>PyList_Check</name><argument_list>(<argument><expr><name>keys</name></expr></argument>)</argument_list></call> || !<call><name>PyList_Check</name><argument_list>(<argument><expr><name>vals</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
<argument><expr>"spawnve(): env.keys() or env.values() is not a list"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>fail_2</name>;</goto>
}</block></then></if>
<for>for (<init><expr><name>pos</name> = 0</expr>;</init> <condition><expr><name>pos</name> &lt; <name>i</name></expr>;</condition> <incr><expr><name>pos</name>++</expr></incr>) <block>{
<decl_stmt><decl><type><name>char</name> *</type><name>p</name></decl>, *<decl><type ref="prev"/><name>k</name></decl>, *<decl><type ref="prev"/><name>v</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>len</name></decl>;</decl_stmt>
<expr_stmt><expr><name>key</name> = <call><name>PyList_GetItem</name><argument_list>(<argument><expr><name>keys</name></expr></argument>, <argument><expr><name>pos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>val</name> = <call><name>PyList_GetItem</name><argument_list>(<argument><expr><name>vals</name></expr></argument>, <argument><expr><name>pos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>key</name> || !<name>val</name></expr>)</condition><then>
<goto>goto <name>fail_2</name>;</goto></then></if>
<if>if <condition>(<expr>!<call><name>PyArg_Parse</name><argument_list>(
<argument><expr><name>key</name></expr></argument>,
<argument><expr>"s;spawnve() arg 3 contains a non-string key"</expr></argument>,
<argument><expr>&amp;<name>k</name></expr></argument>)</argument_list></call> ||
!<call><name>PyArg_Parse</name><argument_list>(
<argument><expr><name>val</name></expr></argument>,
<argument><expr>"s;spawnve() arg 3 contains a non-string value"</expr></argument>,
<argument><expr>&amp;<name>v</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<goto>goto <name>fail_2</name>;</goto>
}</block></then></if>
<expr_stmt><expr><name>len</name> = <call><name>PyString_Size</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call> + <call><name>PyString_Size</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call> + 2</expr>;</expr_stmt>
<expr_stmt><expr><name>p</name> = <call><name>PyMem_NEW</name><argument_list>(<argument><expr><name>char</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>p</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_NoMemory</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>fail_2</name>;</goto>
}</block></then></if>
<expr_stmt><expr><call><name>PyOS_snprintf</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr>"%s=%s"</expr></argument>, <argument><expr><name>k</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>envlist</name><index>[<expr><name>envc</name>++</expr>]</index></name> = <name>p</name></expr>;</expr_stmt>
}</block></for>
<expr_stmt><expr><name><name>envlist</name><index>[<expr><name>envc</name></expr>]</index></name> = 0</expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>PYOS_OS2</name></expr></argument>)</argument_list></call> &amp;&amp; <call><name>defined</name><argument_list>(<argument><expr><name>PYCC_GCC</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>Py_BEGIN_ALLOW_THREADS</name></type>
<name>spawnval</name> <init>= <expr><call><name>spawnve</name><argument_list>(<argument><expr><name>mode</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>argvlist</name></expr></argument>, <argument><expr><name>envlist</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<macro><name>Py_END_ALLOW_THREADS</name></macro>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<if>if <condition>(<expr><name>mode</name> == <name>_OLD_P_OVERLAY</name></expr>)</condition><then>
<expr_stmt><expr><name>mode</name> = <name>_P_OVERLAY</name></expr>;</expr_stmt></then></if>
<decl_stmt><decl><type><name>Py_BEGIN_ALLOW_THREADS</name></type>
<name>spawnval</name> <init>= <expr><call><name>_spawnve</name><argument_list>(<argument><expr><name>mode</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>argvlist</name></expr></argument>, <argument><expr><name>envlist</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<macro><name>Py_END_ALLOW_THREADS</name></macro>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<if>if <condition>(<expr><name>spawnval</name> == -1</expr>)</condition><then>
<expr_stmt><expr>(<name>void</name>) <call><name>posix_error</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then>
<else>else
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SIZEOF_LONG</name> == <name>SIZEOF_VOID_P</name></expr></cpp:if>
<expr_stmt><expr><name>res</name> = <call><name>Py_BuildValue</name><argument_list>(<argument><expr>"l"</expr></argument>, <argument><expr>(<name>long</name>) <name>spawnval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<expr_stmt><expr><name>res</name> = <call><name>Py_BuildValue</name><argument_list>(<argument><expr>"L"</expr></argument>, <argument><expr>(<name>PY_LONG_LONG</name>) <name>spawnval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<label><name>fail_2</name>:</label>
<while>while <condition>(<expr>--<name>envc</name> &gt;= 0</expr>)</condition>
<expr_stmt><expr><call><name>PyMem_DEL</name><argument_list>(<argument><expr><name><name>envlist</name><index>[<expr><name>envc</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></while>
<expr_stmt><expr><call><name>PyMem_DEL</name><argument_list>(<argument><expr><name>envlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<label><name>fail_1</name>:</label>
<expr_stmt><expr><call><name>free_string_array</name><argument_list>(<argument><expr><name>argvlist</name></expr></argument>, <argument><expr><name>lastarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>vals</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>keys</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<label><name>fail_0</name>:</label>
<expr_stmt><expr><call><name>PyMem_Free</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>res</name></expr>;</return>
}</block></function>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>PYOS_OS2</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>posix_spawnvp__doc__</name></expr></argument>,
<argument><expr>"spawnvp(mode, file, args)\n\n\
Execute the program 'file' in a new process, using the environment\n\
search path to find the file.\n\
\n\
mode: mode of process creation\n\
file: executable file name\n\
args: tuple or list of strings"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>posix_spawnvp</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>char</name> *</type><name>path</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>argv</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> **</type><name>argvlist</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>mode</name></decl>, <decl><type ref="prev"/><name>i</name></decl>, <decl><type ref="prev"/><name>argc</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_intptr_t</name></type> <name>spawnval</name></decl>;</decl_stmt>
<function_decl><type><name>PyObject</name> *</type>(*<name>getitem</name>)<parameter_list>(<param><decl><type><name>PyObject</name> *</type></decl></param>, <param><decl><type><name>Py_ssize_t</name></type></decl></param>)</parameter_list>;</function_decl>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"ietO:spawnvp"</expr></argument>, <argument><expr>&amp;<name>mode</name></expr></argument>,
<argument><expr><name>Py_FileSystemDefaultEncoding</name></expr></argument>,
<argument><expr>&amp;<name>path</name></expr></argument>, <argument><expr>&amp;<name>argv</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<if>if <condition>(<expr><call><name>PyList_Check</name><argument_list>(<argument><expr><name>argv</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><name>argc</name> = <call><name>PyList_Size</name><argument_list>(<argument><expr><name>argv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>getitem</name> = <name>PyList_GetItem</name></expr>;</expr_stmt>
}</block></then> <else>else <if>if <condition>(<expr><call><name>PyTuple_Check</name><argument_list>(<argument><expr><name>argv</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><name>argc</name> = <call><name>PyTuple_Size</name><argument_list>(<argument><expr><name>argv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>getitem</name> = <name>PyTuple_GetItem</name></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
<argument><expr>"spawnvp() arg 2 must be a tuple or list"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyMem_Free</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></else></if></else></if>
<expr_stmt><expr><name>argvlist</name> = <call><name>PyMem_NEW</name><argument_list>(<argument><expr><name>char</name> *</expr></argument>, <argument><expr><name>argc</name>+1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>argvlist</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyMem_Free</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>PyErr_NoMemory</name><argument_list>()</argument_list></call></expr>;</return>
}</block></then></if>
<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>argc</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
<if>if <condition>(<expr>!<call><name>PyArg_Parse</name><argument_list>(<argument><expr><call>(*<name>getitem</name>)<argument_list>(<argument><expr><name>argv</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>"et"</expr></argument>,
<argument><expr><name>Py_FileSystemDefaultEncoding</name></expr></argument>,
<argument><expr>&amp;<name><name>argvlist</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>free_string_array</name><argument_list>(<argument><expr><name>argvlist</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(
<argument><expr><name>PyExc_TypeError</name></expr></argument>,
<argument><expr>"spawnvp() arg 2 must contain only strings"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyMem_Free</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
}</block></for>
<expr_stmt><expr><name><name>argvlist</name><index>[<expr><name>argc</name></expr>]</index></name> = <name>NULL</name></expr>;</expr_stmt>
<decl_stmt><decl><type><name>Py_BEGIN_ALLOW_THREADS</name></type>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>PYCC_GCC</name></expr></argument>)</argument_list></call></expr></cpp:if>
<name>spawnval</name> <init>= <expr><call><name>spawnvp</name><argument_list>(<argument><expr><name>mode</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>argvlist</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<expr_stmt><expr><name>spawnval</name> = <call><name>_spawnvp</name><argument_list>(<argument><expr><name>mode</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>argvlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<function_decl><type><name>Py_END_ALLOW_THREADS</name></type>
<name>free_string_array</name><parameter_list>(<param><decl><type><name>argvlist</name></type></decl></param>, <param><decl><type><name>argc</name></type></decl></param>)</parameter_list>;</function_decl>
<expr_stmt><expr><call><name>PyMem_Free</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>spawnval</name> == -1</expr>)</condition><then>
<return>return <expr><call><name>posix_error</name><argument_list>()</argument_list></call></expr>;</return></then>
<else>else
<return>return <expr><call><name>Py_BuildValue</name><argument_list>(<argument><expr>"l"</expr></argument>, <argument><expr>(<name>long</name>) <name>spawnval</name></expr></argument>)</argument_list></call></expr>;</return></else></if>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>posix_spawnvpe__doc__</name></expr></argument>,
<argument><expr>"spawnvpe(mode, file, args, env)\n\n\
Execute the program 'file' in a new process, using the environment\n\
search path to find the file.\n\
\n\
mode: mode of process creation\n\
file: executable file name\n\
args: tuple or list of arguments\n\
env: dictionary of strings mapping to strings"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>posix_spawnvpe</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>char</name> *</type><name>path</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>argv</name></decl>, *<decl><type ref="prev"/><name>env</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> **</type><name>argvlist</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> **</type><name>envlist</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>key</name></decl>, *<decl><type ref="prev"/><name>val</name></decl>, *<decl><type ref="prev"/><name>keys</name><init>=<expr><name>NULL</name></expr></init>, *<name>vals</name><init>=<expr><name>NULL</name></expr></init>, *<name>res</name><init>=<expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>mode</name></decl>, <decl><type ref="prev"/><name>i</name></decl>, <decl><type ref="prev"/><name>pos</name></decl>, <decl><type ref="prev"/><name>argc</name></decl>, <decl><type ref="prev"/><name>envc</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_intptr_t</name></type> <name>spawnval</name></decl>;</decl_stmt>
<function_decl><type><name>PyObject</name> *</type>(*<name>getitem</name>)<parameter_list>(<param><decl><type><name>PyObject</name> *</type></decl></param>, <param><decl><type><name>Py_ssize_t</name></type></decl></param>)</parameter_list>;</function_decl>
<decl_stmt><decl><type><name>int</name></type> <name>lastarg</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"ietOO:spawnvpe"</expr></argument>, <argument><expr>&amp;<name>mode</name></expr></argument>,
<argument><expr><name>Py_FileSystemDefaultEncoding</name></expr></argument>,
<argument><expr>&amp;<name>path</name></expr></argument>, <argument><expr>&amp;<name>argv</name></expr></argument>, <argument><expr>&amp;<name>env</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<if>if <condition>(<expr><call><name>PyList_Check</name><argument_list>(<argument><expr><name>argv</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><name>argc</name> = <call><name>PyList_Size</name><argument_list>(<argument><expr><name>argv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>getitem</name> = <name>PyList_GetItem</name></expr>;</expr_stmt>
}</block></then> <else>else <if>if <condition>(<expr><call><name>PyTuple_Check</name><argument_list>(<argument><expr><name>argv</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><name>argc</name> = <call><name>PyTuple_Size</name><argument_list>(<argument><expr><name>argv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>getitem</name> = <name>PyTuple_GetItem</name></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
<argument><expr>"spawnvpe() arg 2 must be a tuple or list"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>fail_0</name>;</goto>
}</block></else></if></else></if>
<if>if <condition>(<expr>!<call><name>PyMapping_Check</name><argument_list>(<argument><expr><name>env</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
<argument><expr>"spawnvpe() arg 3 must be a mapping object"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>fail_0</name>;</goto>
}</block></then></if>
<expr_stmt><expr><name>argvlist</name> = <call><name>PyMem_NEW</name><argument_list>(<argument><expr><name>char</name> *</expr></argument>, <argument><expr><name>argc</name>+1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>argvlist</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_NoMemory</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>fail_0</name>;</goto>
}</block></then></if>
<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>argc</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
<if>if <condition>(<expr>!<call><name>PyArg_Parse</name><argument_list>(<argument><expr><call>(*<name>getitem</name>)<argument_list>(<argument><expr><name>argv</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr>"et;spawnvpe() arg 2 must contain only strings"</expr></argument>,
<argument><expr><name>Py_FileSystemDefaultEncoding</name></expr></argument>,
<argument><expr>&amp;<name><name>argvlist</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><name>lastarg</name> = <name>i</name></expr>;</expr_stmt>
<goto>goto <name>fail_1</name>;</goto>
}</block></then></if>
}</block></for>
<expr_stmt><expr><name>lastarg</name> = <name>argc</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>argvlist</name><index>[<expr><name>argc</name></expr>]</index></name> = <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name>i</name> = <call><name>PyMapping_Size</name><argument_list>(<argument><expr><name>env</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>i</name> &lt; 0</expr>)</condition><then>
<goto>goto <name>fail_1</name>;</goto></then></if>
<expr_stmt><expr><name>envlist</name> = <call><name>PyMem_NEW</name><argument_list>(<argument><expr><name>char</name> *</expr></argument>, <argument><expr><name>i</name> + 1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>envlist</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_NoMemory</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>fail_1</name>;</goto>
}</block></then></if>
<expr_stmt><expr><name>envc</name> = 0</expr>;</expr_stmt>
<expr_stmt><expr><name>keys</name> = <call><name>PyMapping_Keys</name><argument_list>(<argument><expr><name>env</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>vals</name> = <call><name>PyMapping_Values</name><argument_list>(<argument><expr><name>env</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>keys</name> || !<name>vals</name></expr>)</condition><then>
<goto>goto <name>fail_2</name>;</goto></then></if>
<if>if <condition>(<expr>!<call><name>PyList_Check</name><argument_list>(<argument><expr><name>keys</name></expr></argument>)</argument_list></call> || !<call><name>PyList_Check</name><argument_list>(<argument><expr><name>vals</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
<argument><expr>"spawnvpe(): env.keys() or env.values() is not a list"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>fail_2</name>;</goto>
}</block></then></if>
<for>for (<init><expr><name>pos</name> = 0</expr>;</init> <condition><expr><name>pos</name> &lt; <name>i</name></expr>;</condition> <incr><expr><name>pos</name>++</expr></incr>) <block>{
<decl_stmt><decl><type><name>char</name> *</type><name>p</name></decl>, *<decl><type ref="prev"/><name>k</name></decl>, *<decl><type ref="prev"/><name>v</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>len</name></decl>;</decl_stmt>
<expr_stmt><expr><name>key</name> = <call><name>PyList_GetItem</name><argument_list>(<argument><expr><name>keys</name></expr></argument>, <argument><expr><name>pos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>val</name> = <call><name>PyList_GetItem</name><argument_list>(<argument><expr><name>vals</name></expr></argument>, <argument><expr><name>pos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>key</name> || !<name>val</name></expr>)</condition><then>
<goto>goto <name>fail_2</name>;</goto></then></if>
<if>if <condition>(<expr>!<call><name>PyArg_Parse</name><argument_list>(
<argument><expr><name>key</name></expr></argument>,
<argument><expr>"s;spawnvpe() arg 3 contains a non-string key"</expr></argument>,
<argument><expr>&amp;<name>k</name></expr></argument>)</argument_list></call> ||
!<call><name>PyArg_Parse</name><argument_list>(
<argument><expr><name>val</name></expr></argument>,
<argument><expr>"s;spawnvpe() arg 3 contains a non-string value"</expr></argument>,
<argument><expr>&amp;<name>v</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<goto>goto <name>fail_2</name>;</goto>
}</block></then></if>
<expr_stmt><expr><name>len</name> = <call><name>PyString_Size</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call> + <call><name>PyString_Size</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call> + 2</expr>;</expr_stmt>
<expr_stmt><expr><name>p</name> = <call><name>PyMem_NEW</name><argument_list>(<argument><expr><name>char</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>p</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_NoMemory</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>fail_2</name>;</goto>
}</block></then></if>
<expr_stmt><expr><call><name>PyOS_snprintf</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr>"%s=%s"</expr></argument>, <argument><expr><name>k</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>envlist</name><index>[<expr><name>envc</name>++</expr>]</index></name> = <name>p</name></expr>;</expr_stmt>
}</block></for>
<expr_stmt><expr><name><name>envlist</name><index>[<expr><name>envc</name></expr>]</index></name> = 0</expr>;</expr_stmt>
<decl_stmt><decl><type><name>Py_BEGIN_ALLOW_THREADS</name></type>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>PYCC_GCC</name></expr></argument>)</argument_list></call></expr></cpp:if>
<name>spawnval</name> <init>= <expr><call><name>spawnvpe</name><argument_list>(<argument><expr><name>mode</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>argvlist</name></expr></argument>, <argument><expr><name>envlist</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<expr_stmt><expr><name>spawnval</name> = <call><name>_spawnvpe</name><argument_list>(<argument><expr><name>mode</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>argvlist</name></expr></argument>, <argument><expr><name>envlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<macro><name>Py_END_ALLOW_THREADS</name></macro>
<if>if <condition>(<expr><name>spawnval</name> == -1</expr>)</condition><then>
<expr_stmt><expr>(<name>void</name>) <call><name>posix_error</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then>
<else>else
<expr_stmt><expr><name>res</name> = <call><name>Py_BuildValue</name><argument_list>(<argument><expr>"l"</expr></argument>, <argument><expr>(<name>long</name>) <name>spawnval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
<label><name>fail_2</name>:</label>
<while>while <condition>(<expr>--<name>envc</name> &gt;= 0</expr>)</condition>
<expr_stmt><expr><call><name>PyMem_DEL</name><argument_list>(<argument><expr><name><name>envlist</name><index>[<expr><name>envc</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></while>
<expr_stmt><expr><call><name>PyMem_DEL</name><argument_list>(<argument><expr><name>envlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<label><name>fail_1</name>:</label>
<expr_stmt><expr><call><name>free_string_array</name><argument_list>(<argument><expr><name>argvlist</name></expr></argument>, <argument><expr><name>lastarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>vals</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>keys</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<label><name>fail_0</name>:</label>
<expr_stmt><expr><call><name>PyMem_Free</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>res</name></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_FORK1</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>posix_fork1__doc__</name></expr></argument>,
<argument><expr>"fork1() -&gt; pid\n\n\
Fork a child process with a single multiplexed (i.e., not bound) thread.\n\
\n\
Return 0 to child process and PID of child to parent process."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>posix_fork1</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>noargs</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>pid_t</name></type> <name>pid</name> <init>= <expr><call><name>fork1</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>pid</name> == -1</expr>)</condition><then>
<return>return <expr><call><name>posix_error</name><argument_list>()</argument_list></call></expr>;</return></then></if>
<if>if <condition>(<expr><name>pid</name> == 0</expr>)</condition><then>
<expr_stmt><expr><call><name>PyOS_AfterFork</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>
<return>return <expr><call><name>PyInt_FromLong</name><argument_list>(<argument><expr><name>pid</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_FORK</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>posix_fork__doc__</name></expr></argument>,
<argument><expr>"fork() -&gt; pid\n\n\
Fork a child process.\n\
Return 0 to child process and PID of child to parent process."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>posix_fork</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>noargs</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>pid_t</name></type> <name>pid</name> <init>= <expr><call><name>fork</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>pid</name> == -1</expr>)</condition><then>
<return>return <expr><call><name>posix_error</name><argument_list>()</argument_list></call></expr>;</return></then></if>
<if>if <condition>(<expr><name>pid</name> == 0</expr>)</condition><then>
<expr_stmt><expr><call><name>PyOS_AfterFork</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>
<return>return <expr><call><name>PyInt_FromLong</name><argument_list>(<argument><expr><name>pid</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_DEV_PTC</name></expr></argument>)</argument_list></call> &amp;&amp; !<call><name>defined</name><argument_list>(<argument><expr><name>HAVE_DEV_PTMX</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DEV_PTY_FILE</name></cpp:macro> <cpp:value>"/dev/ptc"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HAVE_DEV_PTMX</name></cpp:macro></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DEV_PTY_FILE</name></cpp:macro> <cpp:value>"/dev/ptmx"</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_OPENPTY</name></expr></argument>)</argument_list></call> || <call><name>defined</name><argument_list>(<argument><expr><name>HAVE_FORKPTY</name></expr></argument>)</argument_list></call> || <call><name>defined</name><argument_list>(<argument><expr><name>HAVE_DEV_PTMX</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_PTY_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;pty.h&gt;</cpp:file></cpp:include>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_LIBUTIL_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;libutil.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_STROPTS_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stropts.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_OPENPTY</name></expr></argument>)</argument_list></call> || <call><name>defined</name><argument_list>(<argument><expr><name>HAVE__GETPTY</name></expr></argument>)</argument_list></call> || <call><name>defined</name><argument_list>(<argument><expr><name>HAVE_DEV_PTMX</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>posix_openpty__doc__</name></expr></argument>,
<argument><expr>"openpty() -&gt; (master_fd, slave_fd)\n\n\
Open a pseudo-terminal, returning open fd's for both master and slave end.\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>posix_openpty</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>noargs</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>master_fd</name></decl>, <decl><type ref="prev"/><name>slave_fd</name></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>HAVE_OPENPTY</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>char</name> *</type> <name>slave_name</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_DEV_PTMX</name></expr></argument>)</argument_list></call> &amp;&amp; !<call><name>defined</name><argument_list>(<argument><expr><name>HAVE_OPENPTY</name></expr></argument>)</argument_list></call> &amp;&amp; !<call><name>defined</name><argument_list>(<argument><expr><name>HAVE__GETPTY</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>PyOS_sighandler_t</name></type> <name>sig_saved</name></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>sun</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function_decl><type><specifier>extern</specifier> <name>char</name> *</type><name>ptsname</name><parameter_list>(<param><decl><type><name>int</name></type> <name>fildes</name></decl></param>)</parameter_list>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_OPENPTY</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if>if <condition>(<expr><call><name>openpty</name><argument_list>(<argument><expr>&amp;<name>master_fd</name></expr></argument>, <argument><expr>&amp;<name>slave_fd</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call> != 0</expr>)</condition><then>
<return>return <expr><call><name>posix_error</name><argument_list>()</argument_list></call></expr>;</return></then></if>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE__GETPTY</name></expr></argument>)</argument_list></call></expr></cpp:elif>
<expr_stmt><expr><name>slave_name</name> = <call><name>_getpty</name><argument_list>(<argument><expr>&amp;<name>master_fd</name></expr></argument>, <argument><expr><name>O_RDWR</name></expr></argument>, <argument><expr>0666</expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>slave_name</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><call><name>posix_error</name><argument_list>()</argument_list></call></expr>;</return></then></if>
<expr_stmt><expr><name>slave_fd</name> = <call><name>open</name><argument_list>(<argument><expr><name>slave_name</name></expr></argument>, <argument><expr><name>O_RDWR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>slave_fd</name> &lt; 0</expr>)</condition><then>
<return>return <expr><call><name>posix_error</name><argument_list>()</argument_list></call></expr>;</return></then></if>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<expr_stmt><expr><name>master_fd</name> = <call><name>open</name><argument_list>(<argument><expr><name>DEV_PTY_FILE</name></expr></argument>, <argument><expr><name>O_RDWR</name> | <name>O_NOCTTY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>master_fd</name> &lt; 0</expr>)</condition><then>
<return>return <expr><call><name>posix_error</name><argument_list>()</argument_list></call></expr>;</return></then></if>
<expr_stmt><expr><name>sig_saved</name> = <call><name>PyOS_setsig</name><argument_list>(<argument><expr><name>SIGCHLD</name></expr></argument>, <argument><expr><name>SIG_DFL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>grantpt</name><argument_list>(<argument><expr><name>master_fd</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyOS_setsig</name><argument_list>(<argument><expr><name>SIGCHLD</name></expr></argument>, <argument><expr><name>sig_saved</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>posix_error</name><argument_list>()</argument_list></call></expr>;</return>
}</block></then></if>
<if>if <condition>(<expr><call><name>unlockpt</name><argument_list>(<argument><expr><name>master_fd</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyOS_setsig</name><argument_list>(<argument><expr><name>SIGCHLD</name></expr></argument>, <argument><expr><name>sig_saved</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>posix_error</name><argument_list>()</argument_list></call></expr>;</return>
}</block></then></if>
<expr_stmt><expr><call><name>PyOS_setsig</name><argument_list>(<argument><expr><name>SIGCHLD</name></expr></argument>, <argument><expr><name>sig_saved</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>slave_name</name> = <call><name>ptsname</name><argument_list>(<argument><expr><name>master_fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>slave_name</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><call><name>posix_error</name><argument_list>()</argument_list></call></expr>;</return></then></if>
<expr_stmt><expr><name>slave_fd</name> = <call><name>open</name><argument_list>(<argument><expr><name>slave_name</name></expr></argument>, <argument><expr><name>O_RDWR</name> | <name>O_NOCTTY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>slave_fd</name> &lt; 0</expr>)</condition><then>
<return>return <expr><call><name>posix_error</name><argument_list>()</argument_list></call></expr>;</return></then></if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>__CYGWIN__</name></expr></argument>)</argument_list></call> &amp;&amp; !<call><name>defined</name><argument_list>(<argument><expr><name>HAVE_DEV_PTC</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>ioctl</name><argument_list>(<argument><expr><name>slave_fd</name></expr></argument>, <argument><expr><name>I_PUSH</name></expr></argument>, <argument><expr>"ptem"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ioctl</name><argument_list>(<argument><expr><name>slave_fd</name></expr></argument>, <argument><expr><name>I_PUSH</name></expr></argument>, <argument><expr>"ldterm"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>__hpux</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>ioctl</name><argument_list>(<argument><expr><name>slave_fd</name></expr></argument>, <argument><expr><name>I_PUSH</name></expr></argument>, <argument><expr>"ttcompat"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<return>return <expr><call><name>Py_BuildValue</name><argument_list>(<argument><expr>"(ii)"</expr></argument>, <argument><expr><name>master_fd</name></expr></argument>, <argument><expr><name>slave_fd</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_FORKPTY</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>posix_forkpty__doc__</name></expr></argument>,
<argument><expr>"forkpty() -&gt; (pid, master_fd)\n\n\
Fork a new process with a new pseudo-terminal as controlling tty.\n\n\
Like fork(), return 0 as pid to child process, and PID of child to parent.\n\
To both, return fd of newly opened pseudo-terminal.\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>posix_forkpty</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>noargs</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>master_fd</name> <init>= <expr>-1</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>pid_t</name></type> <name>pid</name></decl>;</decl_stmt>
<expr_stmt><expr><name>pid</name> = <call><name>forkpty</name><argument_list>(<argument><expr>&amp;<name>master_fd</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>pid</name> == -1</expr>)</condition><then>
<return>return <expr><call><name>posix_error</name><argument_list>()</argument_list></call></expr>;</return></then></if>
<if>if <condition>(<expr><name>pid</name> == 0</expr>)</condition><then>
<expr_stmt><expr><call><name>PyOS_AfterFork</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>
<return>return <expr><call><name>Py_BuildValue</name><argument_list>(<argument><expr>"(li)"</expr></argument>, <argument><expr><name>pid</name></expr></argument>, <argument><expr><name>master_fd</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_GETEGID</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>posix_getegid__doc__</name></expr></argument>,
<argument><expr>"getegid() -&gt; egid\n\n\
Return the current process's effective group id."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>posix_getegid</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>noargs</name></decl></param>)</parameter_list> <block>{
<return>return <expr><call><name>PyInt_FromLong</name><argument_list>(<argument><expr>(<name>long</name>)<call><name>getegid</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_GETEUID</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>posix_geteuid__doc__</name></expr></argument>,
<argument><expr>"geteuid() -&gt; euid\n\n\
Return the current process's effective user id."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>posix_geteuid</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>noargs</name></decl></param>)</parameter_list> <block>{
<return>return <expr><call><name>PyInt_FromLong</name><argument_list>(<argument><expr>(<name>long</name>)<call><name>geteuid</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_GETGID</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>posix_getgid__doc__</name></expr></argument>,
<argument><expr>"getgid() -&gt; gid\n\n\
Return the current process's group id."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>posix_getgid</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>noargs</name></decl></param>)</parameter_list> <block>{
<return>return <expr><call><name>PyInt_FromLong</name><argument_list>(<argument><expr>(<name>long</name>)<call><name>getgid</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>posix_getpid__doc__</name></expr></argument>,
<argument><expr>"getpid() -&gt; pid\n\n\
Return the current process id"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>posix_getpid</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>noargs</name></decl></param>)</parameter_list> <block>{
<return>return <expr><call><name>PyInt_FromLong</name><argument_list>(<argument><expr>(<name>long</name>)<call><name>getpid</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_GETGROUPS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>posix_getgroups__doc__</name></expr></argument>,
<argument><expr>"getgroups() -&gt; list of group IDs\n\n\
Return list of supplemental group IDs for the process."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>posix_getgroups</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>noargs</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>result</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>NGROUPS_MAX</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAX_GROUPS</name></cpp:macro> <cpp:value>NGROUPS_MAX</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAX_GROUPS</name></cpp:macro> <cpp:value>64</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<decl_stmt><decl><type><name>gid_t</name></type> <name><name>grouplist</name><index>[<expr><name>MAX_GROUPS</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>;</decl_stmt>
<expr_stmt><expr><name>n</name> = <call><name>getgroups</name><argument_list>(<argument><expr><name>MAX_GROUPS</name></expr></argument>, <argument><expr><name>grouplist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>n</name> &lt; 0</expr>)</condition><then>
<expr_stmt><expr><call><name>posix_error</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then>
<else>else <block>{
<expr_stmt><expr><name>result</name> = <call><name>PyList_New</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>result</name> != <name>NULL</name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>n</name></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>) <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>o</name> <init>= <expr><call><name>PyInt_FromLong</name><argument_list>(<argument><expr>(<name>long</name>)<name><name>grouplist</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>o</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>result</name> = <name>NULL</name></expr>;</expr_stmt>
<break>break;</break>
}</block></then></if>
<expr_stmt><expr><call><name>PyList_SET_ITEM</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></for>
}</block></then></if>
}</block></else></if>
<return>return <expr><name>result</name></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_GETPGID</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>posix_getpgid__doc__</name></expr></argument>,
<argument><expr>"getpgid(pid) -&gt; pgid\n\n\
Call the system call getpgid()."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>posix_getpgid</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>pid</name></decl>, <decl><type ref="prev"/><name>pgid</name></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"i:getpgid"</expr></argument>, <argument><expr>&amp;<name>pid</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>pgid</name> = <call><name>getpgid</name><argument_list>(<argument><expr><name>pid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>pgid</name> &lt; 0</expr>)</condition><then>
<return>return <expr><call><name>posix_error</name><argument_list>()</argument_list></call></expr>;</return></then></if>
<return>return <expr><call><name>PyInt_FromLong</name><argument_list>(<argument><expr>(<name>long</name>)<name>pgid</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_GETPGRP</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>posix_getpgrp__doc__</name></expr></argument>,
<argument><expr>"getpgrp() -&gt; pgrp\n\n\
Return the current process group id."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>posix_getpgrp</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>noargs</name></decl></param>)</parameter_list> <block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>GETPGRP_HAVE_ARG</name></expr></argument>)</argument_list></call></expr></cpp:if>
<return>return <expr><call><name>PyInt_FromLong</name><argument_list>(<argument><expr>(<name>long</name>)<call><name>getpgrp</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<return>return <expr><call><name>PyInt_FromLong</name><argument_list>(<argument><expr>(<name>long</name>)<call><name>getpgrp</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_SETPGRP</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>posix_setpgrp__doc__</name></expr></argument>,
<argument><expr>"setpgrp()\n\n\
Make this process a session leader."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>posix_setpgrp</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>noargs</name></decl></param>)</parameter_list> <block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SETPGRP_HAVE_ARG</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if>if <condition>(<expr><call><name>setpgrp</name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<if>if <condition>(<expr><call><name>setpgrp</name><argument_list>()</argument_list></call> &lt; 0</expr>)</condition><then>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<return>return <expr><call><name>posix_error</name><argument_list>()</argument_list></call></expr>;</return></then></if></then></if>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>Py_None</name></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_GETPPID</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>posix_getppid__doc__</name></expr></argument>,
<argument><expr>"getppid() -&gt; ppid\n\n\
Return the parent's process id."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>posix_getppid</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>noargs</name></decl></param>)</parameter_list> <block>{
<return>return <expr><call><name>PyInt_FromLong</name><argument_list>(<argument><expr><call><name>getppid</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_GETLOGIN</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>posix_getlogin__doc__</name></expr></argument>,
<argument><expr>"getlogin() -&gt; string\n\n\
Return the actual login name."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>posix_getlogin</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>noargs</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>result</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>name</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>old_errno</name> <init>= <expr><name>errno</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>errno</name> = 0</expr>;</expr_stmt>
<expr_stmt><expr><name>name</name> = <call><name>getlogin</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>name</name> == <name>NULL</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr><name>errno</name></expr>)</condition><then>
<expr_stmt><expr><call><name>posix_error</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then>
<else>else
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_OSError</name></expr></argument>,
<argument><expr>"unable to determine login name"</expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
}</block></then> <else>else
<expr_stmt><expr><name>result</name> = <call><name>PyString_FromString</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
<expr_stmt><expr><name>errno</name> = <name>old_errno</name></expr>;</expr_stmt>
<return>return <expr><name>result</name></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_GETUID</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>posix_getuid__doc__</name></expr></argument>,
<argument><expr>"getuid() -&gt; uid\n\n\
Return the current process's user id."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>posix_getuid</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>noargs</name></decl></param>)</parameter_list> <block>{
<return>return <expr><call><name>PyInt_FromLong</name><argument_list>(<argument><expr>(<name>long</name>)<call><name>getuid</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_KILL</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>posix_kill__doc__</name></expr></argument>,
<argument><expr>"kill(pid, sig)\n\n\
Kill a process with a signal."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>posix_kill</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>pid_t</name></type> <name>pid</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>sig</name></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"ii:kill"</expr></argument>, <argument><expr>&amp;<name>pid</name></expr></argument>, <argument><expr>&amp;<name>sig</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>PYOS_OS2</name></expr></argument>)</argument_list></call> &amp;&amp; !<call><name>defined</name><argument_list>(<argument><expr><name>PYCC_GCC</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if>if <condition>(<expr><name>sig</name> == <name>XCPT_SIGNAL_INTR</name> || <name>sig</name> == <name>XCPT_SIGNAL_BREAK</name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>APIRET</name></type> <name>rc</name></decl>;</decl_stmt>
<if>if <condition>(<expr>(<name>rc</name> = <call><name>DosSendSignalException</name><argument_list>(<argument><expr><name>pid</name></expr></argument>, <argument><expr><name>sig</name></expr></argument>)</argument_list></call>) != <name>NO_ERROR</name></expr>)</condition><then>
<return>return <expr><call><name>os2_error</name><argument_list>(<argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
}</block></then> <else>else <if>if <condition>(<expr><name>sig</name> == <name>XCPT_SIGNAL_KILLPROC</name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>APIRET</name></type> <name>rc</name></decl>;</decl_stmt>
<if>if <condition>(<expr>(<name>rc</name> = <call><name>DosKillProcess</name><argument_list>(<argument><expr><name>DKP_PROCESS</name></expr></argument>, <argument><expr><name>pid</name></expr></argument>)</argument_list></call>) != <name>NO_ERROR</name></expr>)</condition><then>
<return>return <expr><call><name>os2_error</name><argument_list>(<argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
}</block></then> <else>else
<return>return <expr><name>NULL</name></expr>;</return></else></if></else></if>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<if>if <condition>(<expr><call><name>kill</name><argument_list>(<argument><expr><name>pid</name></expr></argument>, <argument><expr><name>sig</name></expr></argument>)</argument_list></call> == -1</expr>)</condition><then>
<return>return <expr><call><name>posix_error</name><argument_list>()</argument_list></call></expr>;</return></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>Py_None</name></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_KILLPG</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>posix_killpg__doc__</name></expr></argument>,
<argument><expr>"killpg(pgid, sig)\n\n\
Kill a process group with a signal."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>posix_killpg</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>pgid</name></decl>, <decl><type ref="prev"/><name>sig</name></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"ii:killpg"</expr></argument>, <argument><expr>&amp;<name>pgid</name></expr></argument>, <argument><expr>&amp;<name>sig</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<if>if <condition>(<expr><call><name>killpg</name><argument_list>(<argument><expr><name>pgid</name></expr></argument>, <argument><expr><name>sig</name></expr></argument>)</argument_list></call> == -1</expr>)</condition><then>
<return>return <expr><call><name>posix_error</name><argument_list>()</argument_list></call></expr>;</return></then></if>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>Py_None</name></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_PLOCK</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_SYS_LOCK_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/lock.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>posix_plock__doc__</name></expr></argument>,
<argument><expr>"plock(op)\n\n\
Lock program segments into memory."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>posix_plock</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>op</name></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"i:plock"</expr></argument>, <argument><expr>&amp;<name>op</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<if>if <condition>(<expr><call><name>plock</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call> == -1</expr>)</condition><then>
<return>return <expr><call><name>posix_error</name><argument_list>()</argument_list></call></expr>;</return></then></if>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>Py_None</name></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_POPEN</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>posix_popen__doc__</name></expr></argument>,
<argument><expr>"popen(command [, mode='r' [, bufsize]]) -&gt; pipe\n\n\
Open a pipe to/from a command returning a file object."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>PYOS_OS2</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>PYCC_VACPP</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>async_system</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>command</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>char</name></type> <name><name>errormsg</name><index>[<expr>256</expr>]</index></name></decl>, <decl><type ref="prev"/><name><name>args</name><index>[<expr>1024</expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RESULTCODES</name></type> <name>rcodes</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>APIRET</name></type> <name>rc</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>shell</name> <init>= <expr><call><name>getenv</name><argument_list>(<argument><expr>"COMSPEC"</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr>!<name>shell</name></expr>)</condition><then>
<expr_stmt><expr><name>shell</name> = "cmd"</expr>;</expr_stmt></then></if>
<if>if <condition>(<expr><call><name>strlen</name><argument_list>(<argument><expr><name>shell</name></expr></argument>)</argument_list></call> + 3 + <call><name>strlen</name><argument_list>(<argument><expr><name>command</name></expr></argument>)</argument_list></call> &gt;= 1024</expr>)</condition><then>
<return>return <expr><name>ERROR_NOT_ENOUGH_MEMORY</name>
<name><name>args</name><index>[<expr>0</expr>]</index></name> = '\0'</expr>;</return></then></if>
<expr_stmt><expr><call><name>strcat</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>shell</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>strcat</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"/c "</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>strcat</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>command</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>rc</name> = <call><name>DosExecPgm</name><argument_list>(<argument><expr><name>errormsg</name></expr></argument>,
<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>errormsg</name></expr></argument>)</argument_list></sizeof></expr></argument>,
<argument><expr><name>EXEC_ASYNC</name></expr></argument>,
<argument><expr><name>args</name></expr></argument>,
<argument><expr><name>NULL</name></expr></argument>,
<argument><expr>&amp;<name>rcodes</name></expr></argument>,
<argument><expr><name>shell</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>rc</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>FILE</name> *</type>
<name>popen</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>command</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>mode</name></decl></param>, <param><decl><type><name>int</name></type> <name>pipesize</name></decl></param>, <param><decl><type><name>int</name> *</type><name>err</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>oldfd</name></decl>, <decl><type ref="prev"/><name>tgtfd</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>HFILE</name></type> <name><name>pipeh</name><index>[<expr>2</expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>APIRET</name></type> <name>rc</name></decl>;</decl_stmt>
<if>if <condition>(<expr><call><name>strchr</name><argument_list>(<argument><expr><name>mode</name></expr></argument>, <argument><expr>'r'</expr></argument>)</argument_list></call> != <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>tgt_fd</name> = 1</expr>;</expr_stmt>
}</block></then> <else>else <if>if <condition>(<expr><call><name>strchr</name><argument_list>(<argument><expr><name>mode</name></expr></argument>, <argument><expr>'w'</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><name>tgt_fd</name> = 0</expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr>*<name>err</name> = <name>ERROR_INVALID_ACCESS</name></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></else></if></else></if>
<if>if <condition>(<expr>(<name>rc</name> = <call><name>DosCreatePipe</name><argument_list>(<argument><expr>&amp;<name><name>pipeh</name><index>[<expr>0</expr>]</index></name></expr></argument>, <argument><expr>&amp;<name><name>pipeh</name><index>[<expr>1</expr>]</index></name></expr></argument>, <argument><expr><name>pipesize</name></expr></argument>)</argument_list></call>) != <name>NO_ERROR</name></expr>)</condition><then> <block>{
<expr_stmt><expr>*<name>err</name> = <name>rc</name></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><call><name>DosEnterCritSec</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>oldfd</name> = <call><name>dup</name><argument_list>(<argument><expr><name>tgtfd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name>tgtfd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>dup2</name><argument_list>(<argument><expr><name><name>pipeh</name><index>[<expr><name>tgtfd</name></expr>]</index></name></expr></argument>, <argument><expr><name>tgtfd</name></expr></argument>)</argument_list></call> == 0</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>DosClose</name><argument_list>(<argument><expr><name><name>pipeh</name><index>[<expr><name>tgtfd</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>rc</name> = <call><name>async_system</name><argument_list>(<argument><expr><name>command</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><call><name>dup2</name><argument_list>(<argument><expr><name>oldfd</name></expr></argument>, <argument><expr><name>tgtfd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name>oldfd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>DosExitCritSec</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>rc</name> == <name>NO_ERROR</name></expr>)</condition><then>
<return>return <expr><call><name>fdopen</name><argument_list>(<argument><expr><name><name>pipeh</name><index>[<expr>1 - <name>tgtfd</name></expr>]</index></name></expr></argument>, <argument><expr><name>mode</name></expr></argument>)</argument_list></call></expr>;</return></then>
<else>else <block>{
<expr_stmt><expr><call><name>DosClose</name><argument_list>(<argument><expr><name><name>pipeh</name><index>[<expr>1 - <name>tgtfd</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr>*<name>err</name> = <name>rc</name></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></else></if>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>posix_popen</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>char</name> *</type><name>name</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>mode</name> <init>= <expr>"r"</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>err</name></decl>, <decl><type ref="prev"/><name>bufsize</name> <init>= <expr>-1</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>FILE</name> *</type><name>fp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>f</name></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"s|si:popen"</expr></argument>, <argument><expr>&amp;<name>name</name></expr></argument>, <argument><expr>&amp;<name>mode</name></expr></argument>, <argument><expr>&amp;<name>bufsize</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<decl_stmt><decl><type><name>Py_BEGIN_ALLOW_THREADS</name></type>
<name>fp</name> <init>= <expr><call><name>popen</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>mode</name></expr></argument>, <argument><expr>(<name>bufsize</name> &gt; 0) ? <name>bufsize</name> : 4096</expr></argument>, <argument><expr>&amp;<name>err</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<macro><name>Py_END_ALLOW_THREADS</name></macro>
<if>if <condition>(<expr><name>fp</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><call><name>os2_error</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
<expr_stmt><expr><name>f</name> = <call><name>PyFile_FromFile</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>mode</name></expr></argument>, <argument><expr><name>fclose</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>f</name> != <name>NULL</name></expr>)</condition><then>
<expr_stmt><expr><call><name>PyFile_SetBufSize</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><name>bufsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<return>return <expr><name>f</name></expr>;</return>
}</block></function>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>PYCC_GCC</name></expr></argument>)</argument_list></call></expr></cpp:elif>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>posix_popen</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>char</name> *</type><name>name</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>mode</name> <init>= <expr>"r"</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>bufsize</name> <init>= <expr>-1</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>FILE</name> *</type><name>fp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>f</name></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"s|si:popen"</expr></argument>, <argument><expr>&amp;<name>name</name></expr></argument>, <argument><expr>&amp;<name>mode</name></expr></argument>, <argument><expr>&amp;<name>bufsize</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<decl_stmt><decl><type><name>Py_BEGIN_ALLOW_THREADS</name></type>
<name>fp</name> <init>= <expr><call><name>popen</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>mode</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<macro><name>Py_END_ALLOW_THREADS</name></macro>
<if>if <condition>(<expr><name>fp</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><call><name>posix_error</name><argument_list>()</argument_list></call></expr>;</return></then></if>
<expr_stmt><expr><name>f</name> = <call><name>PyFile_FromFile</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>mode</name></expr></argument>, <argument><expr><name>pclose</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>f</name> != <name>NULL</name></expr>)</condition><then>
<expr_stmt><expr><call><name>PyFile_SetBufSize</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><name>bufsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<return>return <expr><name>f</name></expr>;</return>
}</block></function>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>POPEN_1</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>POPEN_2</name></cpp:macro> <cpp:value>2</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>POPEN_3</name></cpp:macro> <cpp:value>3</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>POPEN_4</name></cpp:macro> <cpp:value>4</cpp:value></cpp:define>
<function_decl><type><specifier>static</specifier> <name>PyObject</name> *</type><name>_PyPopen</name><parameter_list>(<param><decl><type><name>char</name> *</type></decl></param>, <param><decl><type><name>int</name></type></decl></param>, <param><decl><type><name>int</name></type></decl></param>, <param><decl><type><name>int</name></type></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>_PyPclose</name><parameter_list>(<param><decl><type><name>FILE</name> *</type><name>file</name></decl></param>)</parameter_list>;</function_decl>
<decl_stmt><decl><type><specifier>static</specifier> <name>PyObject</name> *</type><name>_PyPopenProcs</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>os2emx_popen2</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>f</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>tm</name><init>=<expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>cmdstring</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>mode</name> <init>= <expr>"t"</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>bufsize</name> <init>= <expr>-1</expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"s|si:popen2"</expr></argument>, <argument><expr>&amp;<name>cmdstring</name></expr></argument>, <argument><expr>&amp;<name>mode</name></expr></argument>, <argument><expr>&amp;<name>bufsize</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<if>if <condition>(<expr>*<name>mode</name> == 't'</expr>)</condition><then>
<expr_stmt><expr><name>tm</name> = <name>O_TEXT</name></expr>;</expr_stmt></then>
<else>else <if>if <condition>(<expr>*<name>mode</name> != 'b'</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>, <argument><expr>"mode must be 't' or 'b'"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then> <else>else
<expr_stmt><expr><name>tm</name> = <name>O_BINARY</name></expr>;</expr_stmt></else></if></else></if>
<expr_stmt><expr><name>f</name> = <call><name>_PyPopen</name><argument_list>(<argument><expr><name>cmdstring</name></expr></argument>, <argument><expr><name>tm</name></expr></argument>, <argument><expr><name>POPEN_2</name></expr></argument>, <argument><expr><name>bufsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>f</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>os2emx_popen3</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>f</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>tm</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>cmdstring</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>mode</name> <init>= <expr>"t"</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>bufsize</name> <init>= <expr>-1</expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"s|si:popen3"</expr></argument>, <argument><expr>&amp;<name>cmdstring</name></expr></argument>, <argument><expr>&amp;<name>mode</name></expr></argument>, <argument><expr>&amp;<name>bufsize</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<if>if <condition>(<expr>*<name>mode</name> == 't'</expr>)</condition><then>
<expr_stmt><expr><name>tm</name> = <name>O_TEXT</name></expr>;</expr_stmt></then>
<else>else <if>if <condition>(<expr>*<name>mode</name> != 'b'</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>, <argument><expr>"mode must be 't' or 'b'"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then> <else>else
<expr_stmt><expr><name>tm</name> = <name>O_BINARY</name></expr>;</expr_stmt></else></if></else></if>
<expr_stmt><expr><name>f</name> = <call><name>_PyPopen</name><argument_list>(<argument><expr><name>cmdstring</name></expr></argument>, <argument><expr><name>tm</name></expr></argument>, <argument><expr><name>POPEN_3</name></expr></argument>, <argument><expr><name>bufsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>f</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>os2emx_popen4</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>f</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>tm</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>cmdstring</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>mode</name> <init>= <expr>"t"</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>bufsize</name> <init>= <expr>-1</expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"s|si:popen4"</expr></argument>, <argument><expr>&amp;<name>cmdstring</name></expr></argument>, <argument><expr>&amp;<name>mode</name></expr></argument>, <argument><expr>&amp;<name>bufsize</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<if>if <condition>(<expr>*<name>mode</name> == 't'</expr>)</condition><then>
<expr_stmt><expr><name>tm</name> = <name>O_TEXT</name></expr>;</expr_stmt></then>
<else>else <if>if <condition>(<expr>*<name>mode</name> != 'b'</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>, <argument><expr>"mode must be 't' or 'b'"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then> <else>else
<expr_stmt><expr><name>tm</name> = <name>O_BINARY</name></expr>;</expr_stmt></else></if></else></if>
<expr_stmt><expr><name>f</name> = <call><name>_PyPopen</name><argument_list>(<argument><expr><name>cmdstring</name></expr></argument>, <argument><expr><name>tm</name></expr></argument>, <argument><expr><name>POPEN_4</name></expr></argument>, <argument><expr><name>bufsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>f</name></expr>;</return>
}</block></function>
<struct>struct <name>file_ref</name> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>handle</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>flags</name></decl>;</decl_stmt>
}</block>;</struct>
<struct>struct <name>pipe_ref</name> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>rd</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>wr</name></decl>;</decl_stmt>
}</block>;</struct>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>_PyPopen</name><parameter_list>(<param><decl><type><name>char</name> *</type><name>cmdstring</name></decl></param>, <param><decl><type><name>int</name></type> <name>mode</name></decl></param>, <param><decl><type><name>int</name></type> <name>n</name></decl></param>, <param><decl><type><name>int</name></type> <name>bufsize</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type>struct <name>file_ref</name></type> <name><name>stdio</name><index>[<expr>3</expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type>struct <name>pipe_ref</name></type> <name><name>p_fd</name><index>[<expr>3</expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>FILE</name> *</type><name><name>p_s</name><index>[<expr>3</expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>file_count</name></decl>, <decl><type ref="prev"/><name>i</name></decl>, <decl><type ref="prev"/><name>pipe_err</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>pid_t</name></type> <name>pipe_pid</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>shell</name></decl>, *<decl><type ref="prev"/><name>sh_name</name></decl>, *<decl><type ref="prev"/><name>opt</name></decl>, *<decl><type ref="prev"/><name>rd_mode</name></decl>, *<decl><type ref="prev"/><name>wr_mode</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>f</name></decl>, *<decl><type ref="prev"/><name><name>p_f</name><index>[<expr>3</expr>]</index></name></decl>;</decl_stmt>
<if>if <condition>(<expr><name>mode</name> == <name>O_TEXT</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>rd_mode</name> = "rt"</expr>;</expr_stmt>
<expr_stmt><expr><name>wr_mode</name> = "wt"</expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr><name>rd_mode</name> = "rb"</expr>;</expr_stmt>
<expr_stmt><expr><name>wr_mode</name> = "wb"</expr>;</expr_stmt>
}</block></else></if>
<if>if <condition>(<expr>(<name>shell</name> = <call><name>getenv</name><argument_list>(<argument><expr>"EMXSHELL"</expr></argument>)</argument_list></call>) == <name>NULL</name></expr>)</condition><then>
<if>if <condition>(<expr>(<name>shell</name> = <call><name>getenv</name><argument_list>(<argument><expr>"COMSPEC"</expr></argument>)</argument_list></call>) == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>errno</name> = <name>ENOENT</name></expr>;</expr_stmt>
<return>return <expr><call><name>posix_error</name><argument_list>()</argument_list></call></expr>;</return>
}</block></then></if></then></if>
<expr_stmt><expr><name>sh_name</name> = <call><name>_getname</name><argument_list>(<argument><expr><name>shell</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>stricmp</name><argument_list>(<argument><expr><name>sh_name</name></expr></argument>, <argument><expr>"cmd.exe"</expr></argument>)</argument_list></call> == 0 || <call><name>stricmp</name><argument_list>(<argument><expr><name>sh_name</name></expr></argument>, <argument><expr>"4os2.exe"</expr></argument>)</argument_list></call> == 0</expr>)</condition><then>
<expr_stmt><expr><name>opt</name> = "/c"</expr>;</expr_stmt></then>
<else>else
<expr_stmt><expr><name>opt</name> = "-c"</expr>;</expr_stmt></else></if>
<expr_stmt><expr><name>i</name> = <name>pipe_err</name> = 0</expr>;</expr_stmt>
<while>while <condition>(<expr><name>pipe_err</name> &gt;= 0 &amp;&amp; <name>i</name> &lt; 3</expr>)</condition> <block>{
<expr_stmt><expr><name>pipe_err</name> = <name><name>stdio</name><index>[<expr><name>i</name></expr>]</index></name>.<name>handle</name> = <call><name>dup</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>stdio</name><index>[<expr><name>i</name></expr>]</index></name>.<name>flags</name> = <call><name>fcntl</name><argument_list>(<argument><expr><name>i</name></expr></argument>, <argument><expr><name>F_GETFD</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>fcntl</name><argument_list>(<argument><expr><name><name>stdio</name><index>[<expr><name>i</name></expr>]</index></name>.<name>handle</name></expr></argument>, <argument><expr><name>F_SETFD</name></expr></argument>, <argument><expr><name><name>stdio</name><index>[<expr><name>i</name></expr>]</index></name>.<name>flags</name> | <name>FD_CLOEXEC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>i</name>++</expr>;</expr_stmt>
}</block></while>
<if>if <condition>(<expr><name>pipe_err</name> &lt; 0</expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>saved_err</name> <init>= <expr><name>errno</name></expr></init></decl>;</decl_stmt>
<while>while <condition>(<expr><name>i</name>-- &gt; 0</expr>)</condition> <block>{
<expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name><name>stdio</name><index>[<expr><name>i</name></expr>]</index></name>.<name>handle</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></while>
<expr_stmt><expr><name>errno</name> = <name>saved_err</name></expr>;</expr_stmt>
<return>return <expr><call><name>posix_error</name><argument_list>()</argument_list></call></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>file_count</name> = 2</expr>;</expr_stmt>
<if>if <condition>(<expr><name>n</name> == <name>POPEN_3</name></expr>)</condition><then>
<expr_stmt><expr><name>file_count</name> = 3</expr>;</expr_stmt></then></if>
<expr_stmt><expr><name>i</name> = <name>pipe_err</name> = 0</expr>;</expr_stmt>
<while>while <condition>(<expr>(<name>pipe_err</name> == 0) &amp;&amp; (<name>i</name> &lt; <name>file_count</name>)</expr>)</condition>
<expr_stmt><expr><name>pipe_err</name> = <call><name>pipe</name><argument_list>(<argument><expr>(<name>int</name> *)&amp;<name><name>p_fd</name><index>[<expr><name>i</name>++</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></while>
<if>if <condition>(<expr><name>pipe_err</name> &lt; 0</expr>)</condition><then> <block>{
<while>while <condition>(<expr><name>i</name>-- &gt; 0</expr>)</condition> <block>{
<expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name><name>p_fd</name><index>[<expr><name>i</name></expr>]</index></name>.<name>wr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name><name>p_fd</name><index>[<expr><name>i</name></expr>]</index></name>.<name>rd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></while>
<expr_stmt><expr><name>errno</name> = <name>EPIPE</name></expr>;</expr_stmt>
<return>return <expr><call><name>posix_error</name><argument_list>()</argument_list></call></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>pipe_err</name> = 0</expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>dup2</name><argument_list>(<argument><expr><name><name>p_fd</name><index>[<expr>0</expr>]</index></name>.<name>rd</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call> == 0</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name><name>p_fd</name><index>[<expr>0</expr>]</index></name>.<name>rd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>i</name> = <call><name>fcntl</name><argument_list>(<argument><expr><name><name>p_fd</name><index>[<expr>0</expr>]</index></name>.<name>wr</name></expr></argument>, <argument><expr><name>F_GETFD</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>fcntl</name><argument_list>(<argument><expr><name><name>p_fd</name><index>[<expr>0</expr>]</index></name>.<name>wr</name></expr></argument>, <argument><expr><name>F_SETFD</name></expr></argument>, <argument><expr><name>i</name> | <name>FD_CLOEXEC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>(<name><name>p_s</name><index>[<expr>0</expr>]</index></name> = <call><name>fdopen</name><argument_list>(<argument><expr><name><name>p_fd</name><index>[<expr>0</expr>]</index></name>.<name>wr</name></expr></argument>, <argument><expr><name>wr_mode</name></expr></argument>)</argument_list></call>) == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name><name>p_fd</name><index>[<expr>0</expr>]</index></name>.<name>wr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>pipe_err</name> = -1</expr>;</expr_stmt>
}</block></then></if>
}</block></then> <else>else <block>{
<expr_stmt><expr><name>pipe_err</name> = -1</expr>;</expr_stmt>
}</block></else></if>
<if>if <condition>(<expr><name>pipe_err</name> == 0</expr>)</condition><then> <block>{
<if>if <condition>(<expr><call><name>dup2</name><argument_list>(<argument><expr><name><name>p_fd</name><index>[<expr>1</expr>]</index></name>.<name>wr</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call> == 1</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name><name>p_fd</name><index>[<expr>1</expr>]</index></name>.<name>wr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>i</name> = <call><name>fcntl</name><argument_list>(<argument><expr><name><name>p_fd</name><index>[<expr>1</expr>]</index></name>.<name>rd</name></expr></argument>, <argument><expr><name>F_GETFD</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>fcntl</name><argument_list>(<argument><expr><name><name>p_fd</name><index>[<expr>1</expr>]</index></name>.<name>rd</name></expr></argument>, <argument><expr><name>F_SETFD</name></expr></argument>, <argument><expr><name>i</name> | <name>FD_CLOEXEC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>(<name><name>p_s</name><index>[<expr>1</expr>]</index></name> = <call><name>fdopen</name><argument_list>(<argument><expr><name><name>p_fd</name><index>[<expr>1</expr>]</index></name>.<name>rd</name></expr></argument>, <argument><expr><name>rd_mode</name></expr></argument>)</argument_list></call>) == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name><name>p_fd</name><index>[<expr>1</expr>]</index></name>.<name>rd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>pipe_err</name> = -1</expr>;</expr_stmt>
}</block></then></if>
}</block></then> <else>else <block>{
<expr_stmt><expr><name>pipe_err</name> = -1</expr>;</expr_stmt>
}</block></else></if>
}</block></then></if>
<if>if <condition>(<expr><name>pipe_err</name> == 0</expr>)</condition><then>
<switch>switch <condition>(<expr><name>n</name></expr>)</condition> <block>{
<case>case <expr><name>POPEN_3</name></expr>: <block>{
<if>if <condition>(<expr><call><name>dup2</name><argument_list>(<argument><expr><name><name>p_fd</name><index>[<expr>2</expr>]</index></name>.<name>wr</name></expr></argument>, <argument><expr>2</expr></argument>)</argument_list></call> == 2</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name><name>p_fd</name><index>[<expr>2</expr>]</index></name>.<name>wr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>i</name> = <call><name>fcntl</name><argument_list>(<argument><expr><name><name>p_fd</name><index>[<expr>2</expr>]</index></name>.<name>rd</name></expr></argument>, <argument><expr><name>F_GETFD</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>fcntl</name><argument_list>(<argument><expr><name><name>p_fd</name><index>[<expr>2</expr>]</index></name>.<name>rd</name></expr></argument>, <argument><expr><name>F_SETFD</name></expr></argument>, <argument><expr><name>i</name> | <name>FD_CLOEXEC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>(<name><name>p_s</name><index>[<expr>2</expr>]</index></name> = <call><name>fdopen</name><argument_list>(<argument><expr><name><name>p_fd</name><index>[<expr>2</expr>]</index></name>.<name>rd</name></expr></argument>, <argument><expr><name>rd_mode</name></expr></argument>)</argument_list></call>) == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name><name>p_fd</name><index>[<expr>2</expr>]</index></name>.<name>rd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>pipe_err</name> = -1</expr>;</expr_stmt>
}</block></then></if>
}</block></then> <else>else <block>{
<expr_stmt><expr><name>pipe_err</name> = -1</expr>;</expr_stmt>
}</block></else></if>
<break>break;</break>
}</block>
</case><case>case <expr><name>POPEN_4</name></expr>: <block>{
<if>if <condition>(<expr><call><name>dup2</name><argument_list>(<argument><expr>1</expr></argument>, <argument><expr>2</expr></argument>)</argument_list></call> != 2</expr>)</condition><then> <block>{
<expr_stmt><expr><name>pipe_err</name> = -1</expr>;</expr_stmt>
}</block></then></if>
<break>break;</break>
}</block>
</case>}</block></switch></then></if>
<if>if <condition>(<expr><name>pipe_err</name> == 0</expr>)</condition><then> <block>{
<expr_stmt><expr><name>pipe_pid</name> = <call><name>spawnlp</name><argument_list>(<argument><expr><name>P_NOWAIT</name></expr></argument>, <argument><expr><name>shell</name></expr></argument>, <argument><expr><name>shell</name></expr></argument>, <argument><expr><name>opt</name></expr></argument>, <argument><expr><name>cmdstring</name></expr></argument>, <argument><expr>(<name>char</name> *)0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>pipe_pid</name> == -1</expr>)</condition><then> <block>{
<expr_stmt><expr><name>pipe_err</name> = -1</expr>;</expr_stmt>
}</block></then> <else>else <block>{
<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>file_count</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
<expr_stmt><expr><name><name>p_s</name><index>[<expr><name>i</name></expr>]</index></name>-&gt;<name>_pid</name> = <name>pipe_pid</name></expr>;</expr_stmt></for>
}</block></else></if>
}</block></then></if>
<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; 3</expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
<expr_stmt><expr><call><name>dup2</name><argument_list>(<argument><expr><name><name>stdio</name><index>[<expr><name>i</name></expr>]</index></name>.<name>handle</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>fcntl</name><argument_list>(<argument><expr><name>i</name></expr></argument>, <argument><expr><name>F_SETFD</name></expr></argument>, <argument><expr><name><name>stdio</name><index>[<expr><name>i</name></expr>]</index></name>.<name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name><name>stdio</name><index>[<expr><name>i</name></expr>]</index></name>.<name>handle</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></for>
<if>if <condition>(<expr><name>pipe_err</name> &lt; 0</expr>)</condition><then> <block>{
<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; 3</expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
<expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name><name>p_fd</name><index>[<expr><name>i</name></expr>]</index></name>.<name>rd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name><name>p_fd</name><index>[<expr><name>i</name></expr>]</index></name>.<name>wr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></for>
<expr_stmt><expr><name>errno</name> = <name>EPIPE</name></expr>;</expr_stmt>
<return>return <expr><call><name>posix_error_with_filename</name><argument_list>(<argument><expr><name>cmdstring</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></then></if>
<if>if <condition>(<expr>(<name><name>p_f</name><index>[<expr>0</expr>]</index></name> = <call><name>PyFile_FromFile</name><argument_list>(<argument><expr><name><name>p_s</name><index>[<expr>0</expr>]</index></name></expr></argument>, <argument><expr><name>cmdstring</name></expr></argument>, <argument><expr><name>wr_mode</name></expr></argument>, <argument><expr><name>_PyPclose</name></expr></argument>)</argument_list></call>) != <name>NULL</name></expr>)</condition><then>
<expr_stmt><expr><call><name>PyFile_SetBufSize</name><argument_list>(<argument><expr><name><name>p_f</name><index>[<expr>0</expr>]</index></name></expr></argument>, <argument><expr><name>bufsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<if>if <condition>(<expr>(<name><name>p_f</name><index>[<expr>1</expr>]</index></name> = <call><name>PyFile_FromFile</name><argument_list>(<argument><expr><name><name>p_s</name><index>[<expr>1</expr>]</index></name></expr></argument>, <argument><expr><name>cmdstring</name></expr></argument>, <argument><expr><name>rd_mode</name></expr></argument>, <argument><expr><name>_PyPclose</name></expr></argument>)</argument_list></call>) != <name>NULL</name></expr>)</condition><then>
<expr_stmt><expr><call><name>PyFile_SetBufSize</name><argument_list>(<argument><expr><name><name>p_f</name><index>[<expr>1</expr>]</index></name></expr></argument>, <argument><expr><name>bufsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<if>if <condition>(<expr><name>n</name> == <name>POPEN_3</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr>(<name><name>p_f</name><index>[<expr>2</expr>]</index></name> = <call><name>PyFile_FromFile</name><argument_list>(<argument><expr><name><name>p_s</name><index>[<expr>2</expr>]</index></name></expr></argument>, <argument><expr><name>cmdstring</name></expr></argument>, <argument><expr><name>rd_mode</name></expr></argument>, <argument><expr><name>_PyPclose</name></expr></argument>)</argument_list></call>) != <name>NULL</name></expr>)</condition><then>
<expr_stmt><expr><call><name>PyFile_SetBufSize</name><argument_list>(<argument><expr><name><name>p_f</name><index>[<expr>0</expr>]</index></name></expr></argument>, <argument><expr><name>bufsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<expr_stmt><expr><name>f</name> = <call><name>PyTuple_Pack</name><argument_list>(<argument><expr>3</expr></argument>, <argument><expr><name><name>p_f</name><index>[<expr>0</expr>]</index></name></expr></argument>, <argument><expr><name><name>p_f</name><index>[<expr>1</expr>]</index></name></expr></argument>, <argument><expr><name><name>p_f</name><index>[<expr>2</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else
<expr_stmt><expr><name>f</name> = <call><name>PyTuple_Pack</name><argument_list>(<argument><expr>2</expr></argument>, <argument><expr><name><name>p_f</name><index>[<expr>0</expr>]</index></name></expr></argument>, <argument><expr><name><name>p_f</name><index>[<expr>1</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
<if>if <condition>(<expr>!<name>_PyPopenProcs</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>_PyPopenProcs</name> = <call><name>PyDict_New</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<if>if <condition>(<expr><name>_PyPopenProcs</name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>procObj</name></decl>, *<decl><type ref="prev"/><name>pidObj</name></decl>, *<decl><type ref="prev"/><name>intObj</name></decl>, *<decl><type ref="prev"/><name><name>fileObj</name><index>[<expr>3</expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name><name>ins_rc</name><index>[<expr>3</expr>]</index></name></decl>;</decl_stmt>
<expr_stmt><expr><name><name>fileObj</name><index>[<expr>0</expr>]</index></name> = <name><name>fileObj</name><index>[<expr>1</expr>]</index></name> = <name><name>fileObj</name><index>[<expr>2</expr>]</index></name> = <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ins_rc</name><index>[<expr>0</expr>]</index></name> = <name><name>ins_rc</name><index>[<expr>1</expr>]</index></name> = <name><name>ins_rc</name><index>[<expr>2</expr>]</index></name> = 0</expr>;</expr_stmt>
<expr_stmt><expr><name>procObj</name> = <call><name>PyList_New</name><argument_list>(<argument><expr>2</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>pidObj</name> = <call><name>PyInt_FromLong</name><argument_list>(<argument><expr>(<name>long</name>) <name>pipe_pid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>intObj</name> = <call><name>PyInt_FromLong</name><argument_list>(<argument><expr>(<name>long</name>) <name>file_count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>procObj</name> &amp;&amp; <name>pidObj</name> &amp;&amp; <name>intObj</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyList_SetItem</name><argument_list>(<argument><expr><name>procObj</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>pidObj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyList_SetItem</name><argument_list>(<argument><expr><name>procObj</name></expr></argument>, <argument><expr>1</expr></argument>, <argument><expr><name>intObj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>fileObj</name><index>[<expr>0</expr>]</index></name> = <call><name>PyLong_FromVoidPtr</name><argument_list>(<argument><expr><name><name>p_s</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>fileObj</name><index>[<expr>0</expr>]</index></name></expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>ins_rc</name><index>[<expr>0</expr>]</index></name> = <call><name>PyDict_SetItem</name><argument_list>(<argument><expr><name>_PyPopenProcs</name></expr></argument>,
<argument><expr><name><name>fileObj</name><index>[<expr>0</expr>]</index></name></expr></argument>,
<argument><expr><name>procObj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><name><name>fileObj</name><index>[<expr>1</expr>]</index></name> = <call><name>PyLong_FromVoidPtr</name><argument_list>(<argument><expr><name><name>p_s</name><index>[<expr>1</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>fileObj</name><index>[<expr>1</expr>]</index></name></expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>ins_rc</name><index>[<expr>1</expr>]</index></name> = <call><name>PyDict_SetItem</name><argument_list>(<argument><expr><name>_PyPopenProcs</name></expr></argument>,
<argument><expr><name><name>fileObj</name><index>[<expr>1</expr>]</index></name></expr></argument>,
<argument><expr><name>procObj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<if>if <condition>(<expr><name>file_count</name> &gt;= 3</expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>fileObj</name><index>[<expr>2</expr>]</index></name> = <call><name>PyLong_FromVoidPtr</name><argument_list>(<argument><expr><name><name>p_s</name><index>[<expr>2</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>fileObj</name><index>[<expr>2</expr>]</index></name></expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>ins_rc</name><index>[<expr>2</expr>]</index></name> = <call><name>PyDict_SetItem</name><argument_list>(<argument><expr><name>_PyPopenProcs</name></expr></argument>,
<argument><expr><name><name>fileObj</name><index>[<expr>2</expr>]</index></name></expr></argument>,
<argument><expr><name>procObj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
}</block></then></if>
<if>if <condition>(<expr><name><name>ins_rc</name><index>[<expr>0</expr>]</index></name> &lt; 0 || !<name><name>fileObj</name><index>[<expr>0</expr>]</index></name> ||
<name><name>ins_rc</name><index>[<expr>1</expr>]</index></name> &lt; 0 || (<name>file_count</name> &gt; 1 &amp;&amp; !<name><name>fileObj</name><index>[<expr>1</expr>]</index></name>) ||
<name><name>ins_rc</name><index>[<expr>2</expr>]</index></name> &lt; 0 || (<name>file_count</name> &gt; 2 &amp;&amp; !<name><name>fileObj</name><index>[<expr>2</expr>]</index></name>)</expr>)</condition><then> <block>{
<if>if <condition>(<expr>!<name><name>ins_rc</name><index>[<expr>0</expr>]</index></name> &amp;&amp; <name><name>fileObj</name><index>[<expr>0</expr>]</index></name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyDict_DelItem</name><argument_list>(<argument><expr><name>_PyPopenProcs</name></expr></argument>,
<argument><expr><name><name>fileObj</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<if>if <condition>(<expr>!<name><name>ins_rc</name><index>[<expr>1</expr>]</index></name> &amp;&amp; <name><name>fileObj</name><index>[<expr>1</expr>]</index></name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyDict_DelItem</name><argument_list>(<argument><expr><name>_PyPopenProcs</name></expr></argument>,
<argument><expr><name><name>fileObj</name><index>[<expr>1</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<if>if <condition>(<expr>!<name><name>ins_rc</name><index>[<expr>2</expr>]</index></name> &amp;&amp; <name><name>fileObj</name><index>[<expr>2</expr>]</index></name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyDict_DelItem</name><argument_list>(<argument><expr><name>_PyPopenProcs</name></expr></argument>,
<argument><expr><name><name>fileObj</name><index>[<expr>2</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
}</block></then></if>
}</block></then></if>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>procObj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name><name>fileObj</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name><name>fileObj</name><index>[<expr>1</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name><name>fileObj</name><index>[<expr>2</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<return>return <expr><name>f</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>_PyPclose</name><parameter_list>(<param><decl><type><name>FILE</name> *</type><name>file</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>result</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>exit_code</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>pid_t</name></type> <name>pipe_pid</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>procObj</name></decl>, *<decl><type ref="prev"/><name>pidObj</name></decl>, *<decl><type ref="prev"/><name>intObj</name></decl>, *<decl><type ref="prev"/><name>fileObj</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>file_count</name></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>WITH_THREAD</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>PyGILState_STATE</name></type> <name>state</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><name>result</name> = <call><name>fclose</name><argument_list>(<argument><expr><name>file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>WITH_THREAD</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><name>state</name> = <call><name>PyGILState_Ensure</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<if>if <condition>(<expr><name>_PyPopenProcs</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr>(<name>fileObj</name> = <call><name>PyLong_FromVoidPtr</name><argument_list>(<argument><expr><name>file</name></expr></argument>)</argument_list></call>) != <name>NULL</name> &amp;&amp;
(<name>procObj</name> = <call><name>PyDict_GetItem</name><argument_list>(<argument><expr><name>_PyPopenProcs</name></expr></argument>,
<argument><expr><name>fileObj</name></expr></argument>)</argument_list></call>) != <name>NULL</name> &amp;&amp;
(<name>pidObj</name> = <call><name>PyList_GetItem</name><argument_list>(<argument><expr><name>procObj</name></expr></argument>,<argument><expr>0</expr></argument>)</argument_list></call>) != <name>NULL</name> &amp;&amp;
(<name>intObj</name> = <call><name>PyList_GetItem</name><argument_list>(<argument><expr><name>procObj</name></expr></argument>,<argument><expr>1</expr></argument>)</argument_list></call>) != <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>pipe_pid</name> = (<name>int</name>) <call><name>PyInt_AsLong</name><argument_list>(<argument><expr><name>pidObj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>file_count</name> = (<name>int</name>) <call><name>PyInt_AsLong</name><argument_list>(<argument><expr><name>intObj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>file_count</name> &gt; 1</expr>)</condition><then> <block>{
<expr_stmt><expr><name>file_count</name>--</expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyList_SetItem</name><argument_list>(<argument><expr><name>procObj</name></expr></argument>,<argument><expr>1</expr></argument>,
<argument><expr><call><name>PyInt_FromLong</name><argument_list>(<argument><expr>(<name>long</name>) <name>file_count</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<if>if <condition>(<expr><name>result</name> != <name>EOF</name> &amp;&amp;
<call><name>waitpid</name><argument_list>(<argument><expr><name>pipe_pid</name></expr></argument>, <argument><expr>&amp;<name>exit_code</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call> == <name>pipe_pid</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr><call><name>WIFEXITED</name><argument_list>(<argument><expr><name>exit_code</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><name>result</name> = <call><name>WEXITSTATUS</name><argument_list>(<argument><expr><name>exit_code</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr><name>errno</name> = <name>EPIPE</name></expr>;</expr_stmt>
<expr_stmt><expr><name>result</name> = -1</expr>;</expr_stmt>
}</block></else></if>
}</block></then> <else>else <block>{
<expr_stmt><expr><name>result</name> = -1</expr>;</expr_stmt>
}</block></else></if>
}</block></else></if>
<expr_stmt><expr><call><name>PyDict_DelItem</name><argument_list>(<argument><expr><name>_PyPopenProcs</name></expr></argument>, <argument><expr><name>fileObj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>PyDict_Size</name><argument_list>(<argument><expr><name>_PyPopenProcs</name></expr></argument>)</argument_list></call> == 0</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>_PyPopenProcs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>_PyPopenProcs</name> = <name>NULL</name></expr>;</expr_stmt>
}</block></then></if>
}</block></then></if>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>fileObj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>WITH_THREAD</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyGILState_Release</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<return>return <expr><name>result</name></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MS_WINDOWS</name></expr></argument>)</argument_list></call></expr></cpp:elif>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;malloc.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;io.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;fcntl.h&gt;</cpp:file></cpp:include>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>POPEN_1</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>POPEN_2</name></cpp:macro> <cpp:value>2</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>POPEN_3</name></cpp:macro> <cpp:value>3</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>POPEN_4</name></cpp:macro> <cpp:value>4</cpp:value></cpp:define>
<function_decl><type><specifier>static</specifier> <name>PyObject</name> *</type><name>_PyPopen</name><parameter_list>(<param><decl><type><name>char</name> *</type></decl></param>, <param><decl><type><name>int</name></type></decl></param>, <param><decl><type><name>int</name></type></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>_PyPclose</name><parameter_list>(<param><decl><type><name>FILE</name> *</type><name>file</name></decl></param>)</parameter_list>;</function_decl>
<decl_stmt><decl><type><specifier>static</specifier> <name>PyObject</name> *</type><name>_PyPopenProcs</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>posix_popen</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>f</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>tm</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>cmdstring</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>mode</name> <init>= <expr>"r"</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>bufsize</name> <init>= <expr>-1</expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"s|si:popen"</expr></argument>, <argument><expr>&amp;<name>cmdstring</name></expr></argument>, <argument><expr>&amp;<name>mode</name></expr></argument>, <argument><expr>&amp;<name>bufsize</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<if>if <condition>(<expr>*<name>mode</name> == 'r'</expr>)</condition><then>
<expr_stmt><expr><name>tm</name> = <name>_O_RDONLY</name></expr>;</expr_stmt></then>
<else>else <if>if <condition>(<expr>*<name>mode</name> != 'w'</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>, <argument><expr>"popen() arg 2 must be 'r' or 'w'"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then> <else>else
<expr_stmt><expr><name>tm</name> = <name>_O_WRONLY</name></expr>;</expr_stmt></else></if></else></if>
<if>if <condition>(<expr><name>bufsize</name> != -1</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>, <argument><expr>"popen() arg 3 must be -1"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<if>if <condition>(<expr>*(<name>mode</name>+1) == 't'</expr>)</condition><then>
<expr_stmt><expr><name>f</name> = <call><name>_PyPopen</name><argument_list>(<argument><expr><name>cmdstring</name></expr></argument>, <argument><expr><name>tm</name> | <name>_O_TEXT</name></expr></argument>, <argument><expr><name>POPEN_1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
<else>else <if>if <condition>(<expr>*(<name>mode</name>+1) == 'b'</expr>)</condition><then>
<expr_stmt><expr><name>f</name> = <call><name>_PyPopen</name><argument_list>(<argument><expr><name>cmdstring</name></expr></argument>, <argument><expr><name>tm</name> | <name>_O_BINARY</name></expr></argument>, <argument><expr><name>POPEN_1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
<else>else
<expr_stmt><expr><name>f</name> = <call><name>_PyPopen</name><argument_list>(<argument><expr><name>cmdstring</name></expr></argument>, <argument><expr><name>tm</name> | <name>_O_TEXT</name></expr></argument>, <argument><expr><name>POPEN_1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if></else></if>
<return>return <expr><name>f</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>win32_popen2</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>f</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>tm</name><init>=<expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>cmdstring</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>mode</name> <init>= <expr>"t"</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>bufsize</name> <init>= <expr>-1</expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"s|si:popen2"</expr></argument>, <argument><expr>&amp;<name>cmdstring</name></expr></argument>, <argument><expr>&amp;<name>mode</name></expr></argument>, <argument><expr>&amp;<name>bufsize</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<if>if <condition>(<expr>*<name>mode</name> == 't'</expr>)</condition><then>
<expr_stmt><expr><name>tm</name> = <name>_O_TEXT</name></expr>;</expr_stmt></then>
<else>else <if>if <condition>(<expr>*<name>mode</name> != 'b'</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>, <argument><expr>"popen2() arg 2 must be 't' or 'b'"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then> <else>else
<expr_stmt><expr><name>tm</name> = <name>_O_BINARY</name></expr>;</expr_stmt></else></if></else></if>
<if>if <condition>(<expr><name>bufsize</name> != -1</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>, <argument><expr>"popen2() arg 3 must be -1"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>f</name> = <call><name>_PyPopen</name><argument_list>(<argument><expr><name>cmdstring</name></expr></argument>, <argument><expr><name>tm</name></expr></argument>, <argument><expr><name>POPEN_2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>f</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>win32_popen3</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>f</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>tm</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>cmdstring</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>mode</name> <init>= <expr>"t"</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>bufsize</name> <init>= <expr>-1</expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"s|si:popen3"</expr></argument>, <argument><expr>&amp;<name>cmdstring</name></expr></argument>, <argument><expr>&amp;<name>mode</name></expr></argument>, <argument><expr>&amp;<name>bufsize</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<if>if <condition>(<expr>*<name>mode</name> == 't'</expr>)</condition><then>
<expr_stmt><expr><name>tm</name> = <name>_O_TEXT</name></expr>;</expr_stmt></then>
<else>else <if>if <condition>(<expr>*<name>mode</name> != 'b'</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>, <argument><expr>"popen3() arg 2 must be 't' or 'b'"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then> <else>else
<expr_stmt><expr><name>tm</name> = <name>_O_BINARY</name></expr>;</expr_stmt></else></if></else></if>
<if>if <condition>(<expr><name>bufsize</name> != -1</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>, <argument><expr>"popen3() arg 3 must be -1"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>f</name> = <call><name>_PyPopen</name><argument_list>(<argument><expr><name>cmdstring</name></expr></argument>, <argument><expr><name>tm</name></expr></argument>, <argument><expr><name>POPEN_3</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>f</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>win32_popen4</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>f</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>tm</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>cmdstring</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>mode</name> <init>= <expr>"t"</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>bufsize</name> <init>= <expr>-1</expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"s|si:popen4"</expr></argument>, <argument><expr>&amp;<name>cmdstring</name></expr></argument>, <argument><expr>&amp;<name>mode</name></expr></argument>, <argument><expr>&amp;<name>bufsize</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<if>if <condition>(<expr>*<name>mode</name> == 't'</expr>)</condition><then>
<expr_stmt><expr><name>tm</name> = <name>_O_TEXT</name></expr>;</expr_stmt></then>
<else>else <if>if <condition>(<expr>*<name>mode</name> != 'b'</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>, <argument><expr>"popen4() arg 2 must be 't' or 'b'"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then> <else>else
<expr_stmt><expr><name>tm</name> = <name>_O_BINARY</name></expr>;</expr_stmt></else></if></else></if>
<if>if <condition>(<expr><name>bufsize</name> != -1</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>, <argument><expr>"popen4() arg 3 must be -1"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>f</name> = <call><name>_PyPopen</name><argument_list>(<argument><expr><name>cmdstring</name></expr></argument>, <argument><expr><name>tm</name></expr></argument>, <argument><expr><name>POPEN_4</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>f</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>BOOL</name></type>
<name>_PyPopenCreateProcess</name><parameter_list>(<param><decl><type><name>char</name> *</type><name>cmdstring</name></decl></param>,
<param><decl><type><name>HANDLE</name></type> <name>hStdin</name></decl></param>,
<param><decl><type><name>HANDLE</name></type> <name>hStdout</name></decl></param>,
<param><decl><type><name>HANDLE</name></type> <name>hStderr</name></decl></param>,
<param><decl><type><name>HANDLE</name> *</type><name>hProcess</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PROCESS_INFORMATION</name></type> <name>piProcInfo</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>STARTUPINFO</name></type> <name>siStartInfo</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>DWORD</name></type> <name>dwProcessFlags</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>s1</name></decl>,*<decl><type ref="prev"/><name>s2</name></decl>, *<decl><type ref="prev"/><name>s3</name> <init>= <expr>" /c "</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>szConsoleSpawn</name> <init>= <expr>"w9xpopen.exe"</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>x</name></decl>;</decl_stmt>
<if>if <condition>(<expr><name>i</name> = <call><name>GetEnvironmentVariable</name><argument_list>(<argument><expr>"COMSPEC"</expr></argument>,<argument><expr><name>NULL</name></expr></argument>,<argument><expr>0</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>char</name> *</type><name>comshell</name></decl>;</decl_stmt>
<expr_stmt><expr><name>s1</name> = (<name>char</name> *)<call><name>alloca</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!(<name>x</name> = <call><name>GetEnvironmentVariable</name><argument_list>(<argument><expr>"COMSPEC"</expr></argument>, <argument><expr><name>s1</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call>)</expr>)</condition><then>
<return>return <expr>(<name>int</name>)<name>x</name></expr>;</return></then></if>
<expr_stmt><expr><name>comshell</name> = <name>s1</name> + <name>x</name></expr>;</expr_stmt>
<while>while <condition>(<expr><name>comshell</name> &gt;= <name>s1</name> &amp;&amp; *<name>comshell</name> != '\\'</expr>)</condition>
<expr_stmt><expr>--<name>comshell</name></expr>;</expr_stmt></while>
<expr_stmt><expr>++<name>comshell</name></expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>GetVersion</name><argument_list>()</argument_list></call> &lt; 0x80000000 &amp;&amp;
<call><name>_stricmp</name><argument_list>(<argument><expr><name>comshell</name></expr></argument>, <argument><expr>"command.com"</expr></argument>)</argument_list></call> != 0</expr>)</condition><then> <block>{
<expr_stmt><expr><name>x</name> = <name>i</name> + <call><name>strlen</name><argument_list>(<argument><expr><name>s3</name></expr></argument>)</argument_list></call> + <call><name>strlen</name><argument_list>(<argument><expr><name>cmdstring</name></expr></argument>)</argument_list></call> + 1</expr>;</expr_stmt>
<expr_stmt><expr><name>s2</name> = (<name>char</name> *)<call><name>alloca</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ZeroMemory</name><argument_list>(<argument><expr><name>s2</name></expr></argument>, <argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyOS_snprintf</name><argument_list>(<argument><expr><name>s2</name></expr></argument>, <argument><expr><name>x</name></expr></argument>, <argument><expr>"%s%s%s"</expr></argument>, <argument><expr><name>s1</name></expr></argument>, <argument><expr><name>s3</name></expr></argument>, <argument><expr><name>cmdstring</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<decl_stmt><decl><type><name>char</name></type> <name><name>modulepath</name><index>[<expr><name>_MAX_PATH</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type>struct <name>stat</name></type> <name>statinfo</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>GetModuleFileName</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>modulepath</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>modulepath</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for (<init><expr><name>x</name> = <name>i</name> = 0</expr>;</init> <condition><expr><name><name>modulepath</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
<if>if <condition>(<expr><name><name>modulepath</name><index>[<expr><name>i</name></expr>]</index></name> == <name>SEP</name></expr>)</condition><then>
<expr_stmt><expr><name>x</name> = <name>i</name>+1</expr>;</expr_stmt></then></if></for>
<expr_stmt><expr><name><name>modulepath</name><index>[<expr><name>x</name></expr>]</index></name> = '\0'</expr>;</expr_stmt>
<expr_stmt><expr><call><name>strncat</name><argument_list>(<argument><expr><name>modulepath</name></expr></argument>,
<argument><expr><name>szConsoleSpawn</name></expr></argument>,
<argument><expr>(<sizeof>sizeof<argument_list>(<argument><expr><name>modulepath</name></expr></argument>)</argument_list></sizeof>/<sizeof>sizeof<argument_list>(<argument><expr><name><name>modulepath</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></sizeof>)
-<call><name>strlen</name><argument_list>(<argument><expr><name>modulepath</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>stat</name><argument_list>(<argument><expr><name>modulepath</name></expr></argument>, <argument><expr>&amp;<name>statinfo</name></expr></argument>)</argument_list></call> != 0</expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>size_t</name></type> <name>mplen</name> <init>= <expr><sizeof>sizeof<argument_list>(<argument><expr><name>modulepath</name></expr></argument>)</argument_list></sizeof>/<sizeof>sizeof<argument_list>(<argument><expr><name><name>modulepath</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></sizeof></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>strncpy</name><argument_list>(<argument><expr><name>modulepath</name></expr></argument>,
<argument><expr><call><name>Py_GetExecPrefix</name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><name>mplen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>modulepath</name><index>[<expr><name>mplen</name>-1</expr>]</index></name> = '\0'</expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>modulepath</name><index>[<expr><call><name>strlen</name><argument_list>(<argument><expr><name>modulepath</name></expr></argument>)</argument_list></call>-1</expr>]</index></name> != '\\'</expr>)</condition><then>
<expr_stmt><expr><call><name>strcat</name><argument_list>(<argument><expr><name>modulepath</name></expr></argument>, <argument><expr>"\\"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<expr_stmt><expr><call><name>strncat</name><argument_list>(<argument><expr><name>modulepath</name></expr></argument>,
<argument><expr><name>szConsoleSpawn</name></expr></argument>,
<argument><expr><name>mplen</name>-<call><name>strlen</name><argument_list>(<argument><expr><name>modulepath</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>stat</name><argument_list>(<argument><expr><name>modulepath</name></expr></argument>, <argument><expr>&amp;<name>statinfo</name></expr></argument>)</argument_list></call> != 0</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_RuntimeError</name></expr></argument>,
<argument><expr>"Can not locate '%s' which is needed "
"for popen to work with your shell "
"or platform."</expr></argument>,
<argument><expr><name>szConsoleSpawn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>FALSE</name></expr>;</return>
}</block></then></if>
}</block></then></if>
<expr_stmt><expr><name>x</name> = <name>i</name> + <call><name>strlen</name><argument_list>(<argument><expr><name>s3</name></expr></argument>)</argument_list></call> + <call><name>strlen</name><argument_list>(<argument><expr><name>cmdstring</name></expr></argument>)</argument_list></call> + 1 +
<call><name>strlen</name><argument_list>(<argument><expr><name>modulepath</name></expr></argument>)</argument_list></call> +
<call><name>strlen</name><argument_list>(<argument><expr><name>szConsoleSpawn</name></expr></argument>)</argument_list></call> + 1</expr>;</expr_stmt>
<expr_stmt><expr><name>s2</name> = (<name>char</name> *)<call><name>alloca</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ZeroMemory</name><argument_list>(<argument><expr><name>s2</name></expr></argument>, <argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyOS_snprintf</name><argument_list>(
<argument><expr><name>s2</name></expr></argument>, <argument><expr><name>x</name></expr></argument>,
<argument><expr>"\"%s\" %s%s%s"</expr></argument>,
<argument><expr><name>modulepath</name></expr></argument>,
<argument><expr><name>s1</name></expr></argument>,
<argument><expr><name>s3</name></expr></argument>,
<argument><expr><name>cmdstring</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>dwProcessFlags</name> |= <name>CREATE_NEW_CONSOLE</name></expr>;</expr_stmt>
}</block></else></if>
}</block></then>
<else>else <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_RuntimeError</name></expr></argument>,
<argument><expr>"Cannot locate a COMSPEC environment variable to "
"use as the shell"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>FALSE</name></expr>;</return>
}</block></else></if>
<expr_stmt><expr><call><name>ZeroMemory</name><argument_list>(<argument><expr>&amp;<name>siStartInfo</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>STARTUPINFO</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>siStartInfo</name>.<name>cb</name></name> = <sizeof>sizeof<argument_list>(<argument><expr><name>STARTUPINFO</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
<expr_stmt><expr><name><name>siStartInfo</name>.<name>dwFlags</name></name> = <name>STARTF_USESTDHANDLES</name> | <name>STARTF_USESHOWWINDOW</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>siStartInfo</name>.<name>hStdInput</name></name> = <name>hStdin</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>siStartInfo</name>.<name>hStdOutput</name></name> = <name>hStdout</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>siStartInfo</name>.<name>hStdError</name></name> = <name>hStderr</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>siStartInfo</name>.<name>wShowWindow</name></name> = <name>SW_HIDE</name></expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>CreateProcess</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>,
<argument><expr><name>s2</name></expr></argument>,
<argument><expr><name>NULL</name></expr></argument>,
<argument><expr><name>NULL</name></expr></argument>,
<argument><expr><name>TRUE</name></expr></argument>,
<argument><expr><name>dwProcessFlags</name></expr></argument>,
<argument><expr><name>NULL</name></expr></argument>,
<argument><expr><name>NULL</name></expr></argument>,
<argument><expr>&amp;<name>siStartInfo</name></expr></argument>,
<argument><expr>&amp;<name>piProcInfo</name></expr></argument>)</argument_list></call></expr> )</condition><then> <block>{
<expr_stmt><expr><call><name>CloseHandle</name><argument_list>(<argument><expr><name><name>piProcInfo</name>.<name>hThread</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr>*<name>hProcess</name> = <name><name>piProcInfo</name>.<name>hProcess</name></name></expr>;</expr_stmt>
<return>return <expr><name>TRUE</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><call><name>win32_error</name><argument_list>(<argument><expr>"CreateProcess"</expr></argument>, <argument><expr><name>s2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>FALSE</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>_PyPopen</name><parameter_list>(<param><decl><type><name>char</name> *</type><name>cmdstring</name></decl></param>, <param><decl><type><name>int</name></type> <name>mode</name></decl></param>, <param><decl><type><name>int</name></type> <name>n</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>HANDLE</name></type> <name>hChildStdinRd</name></decl>, <decl><type ref="prev"/><name>hChildStdinWr</name></decl>, <decl><type ref="prev"/><name>hChildStdoutRd</name></decl>, <decl><type ref="prev"/><name>hChildStdoutWr</name></decl>,
<decl><type ref="prev"/><name>hChildStderrRd</name></decl>, <decl><type ref="prev"/><name>hChildStderrWr</name></decl>, <decl><type ref="prev"/><name>hChildStdinWrDup</name></decl>, <decl><type ref="prev"/><name>hChildStdoutRdDup</name></decl>,
<decl><type ref="prev"/><name>hChildStderrRdDup</name></decl>, <decl><type ref="prev"/><name>hProcess</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>SECURITY_ATTRIBUTES</name></type> <name>saAttr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BOOL</name></type> <name>fSuccess</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>fd1</name></decl>, <decl><type ref="prev"/><name>fd2</name></decl>, <decl><type ref="prev"/><name>fd3</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>FILE</name> *</type><name>f1</name></decl>, *<decl><type ref="prev"/><name>f2</name></decl>, *<decl><type ref="prev"/><name>f3</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>long</name></type> <name>file_count</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>f</name></decl>;</decl_stmt>
<expr_stmt><expr><name><name>saAttr</name>.<name>nLength</name></name> = <sizeof>sizeof<argument_list>(<argument><expr><name>SECURITY_ATTRIBUTES</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
<expr_stmt><expr><name><name>saAttr</name>.<name>bInheritHandle</name></name> = <name>TRUE</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>saAttr</name>.<name>lpSecurityDescriptor</name></name> = <name>NULL</name></expr>;</expr_stmt>
<if>if <condition>(<expr>!<call><name>CreatePipe</name><argument_list>(<argument><expr>&amp;<name>hChildStdinRd</name></expr></argument>, <argument><expr>&amp;<name>hChildStdinWr</name></expr></argument>, <argument><expr>&amp;<name>saAttr</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><call><name>win32_error</name><argument_list>(<argument><expr>"CreatePipe"</expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
<expr_stmt><expr><name>fSuccess</name> = <call><name>DuplicateHandle</name><argument_list>(<argument><expr><call><name>GetCurrentProcess</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>hChildStdinWr</name></expr></argument>,
<argument><expr><call><name>GetCurrentProcess</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr>&amp;<name>hChildStdinWrDup</name></expr></argument>, <argument><expr>0</expr></argument>,
<argument><expr><name>FALSE</name></expr></argument>,
<argument><expr><name>DUPLICATE_SAME_ACCESS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>fSuccess</name></expr>)</condition><then>
<return>return <expr><call><name>win32_error</name><argument_list>(<argument><expr>"DuplicateHandle"</expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
<expr_stmt><expr><call><name>CloseHandle</name><argument_list>(<argument><expr><name>hChildStdinWr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<call><name>CreatePipe</name><argument_list>(<argument><expr>&amp;<name>hChildStdoutRd</name></expr></argument>, <argument><expr>&amp;<name>hChildStdoutWr</name></expr></argument>, <argument><expr>&amp;<name>saAttr</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><call><name>win32_error</name><argument_list>(<argument><expr>"CreatePipe"</expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
<expr_stmt><expr><name>fSuccess</name> = <call><name>DuplicateHandle</name><argument_list>(<argument><expr><call><name>GetCurrentProcess</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>hChildStdoutRd</name></expr></argument>,
<argument><expr><call><name>GetCurrentProcess</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr>&amp;<name>hChildStdoutRdDup</name></expr></argument>, <argument><expr>0</expr></argument>,
<argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>DUPLICATE_SAME_ACCESS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>fSuccess</name></expr>)</condition><then>
<return>return <expr><call><name>win32_error</name><argument_list>(<argument><expr>"DuplicateHandle"</expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
<expr_stmt><expr><call><name>CloseHandle</name><argument_list>(<argument><expr><name>hChildStdoutRd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>n</name> != <name>POPEN_4</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr>!<call><name>CreatePipe</name><argument_list>(<argument><expr>&amp;<name>hChildStderrRd</name></expr></argument>, <argument><expr>&amp;<name>hChildStderrWr</name></expr></argument>, <argument><expr>&amp;<name>saAttr</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><call><name>win32_error</name><argument_list>(<argument><expr>"CreatePipe"</expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
<expr_stmt><expr><name>fSuccess</name> = <call><name>DuplicateHandle</name><argument_list>(<argument><expr><call><name>GetCurrentProcess</name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><name>hChildStderrRd</name></expr></argument>,
<argument><expr><call><name>GetCurrentProcess</name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr>&amp;<name>hChildStderrRdDup</name></expr></argument>, <argument><expr>0</expr></argument>,
<argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>DUPLICATE_SAME_ACCESS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>fSuccess</name></expr>)</condition><then>
<return>return <expr><call><name>win32_error</name><argument_list>(<argument><expr>"DuplicateHandle"</expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
<expr_stmt><expr><call><name>CloseHandle</name><argument_list>(<argument><expr><name>hChildStderrRd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<switch>switch <condition>(<expr><name>n</name></expr>)</condition> <block>{
<case>case <expr><name>POPEN_1</name></expr>:
<switch>switch <condition>(<expr><name>mode</name> &amp; (<name>_O_RDONLY</name> | <name>_O_TEXT</name> | <name>_O_BINARY</name> | <name>_O_WRONLY</name>)</expr>)</condition> <block>{
<case>case <expr><name>_O_WRONLY</name> | <name>_O_TEXT</name></expr>:
<expr_stmt><expr><name>fd1</name> = <call><name>_open_osfhandle</name><argument_list>(<argument><expr>(<name>Py_intptr_t</name>)<name>hChildStdinWrDup</name></expr></argument>, <argument><expr><name>mode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>f1</name> = <call><name>_fdopen</name><argument_list>(<argument><expr><name>fd1</name></expr></argument>, <argument><expr>"w"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>f</name> = <call><name>PyFile_FromFile</name><argument_list>(<argument><expr><name>f1</name></expr></argument>, <argument><expr><name>cmdstring</name></expr></argument>, <argument><expr>"w"</expr></argument>, <argument><expr><name>_PyPclose</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyFile_SetBufSize</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>CloseHandle</name><argument_list>(<argument><expr><name>hChildStdoutRdDup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>CloseHandle</name><argument_list>(<argument><expr><name>hChildStderrRdDup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr><name>_O_RDONLY</name> | <name>_O_TEXT</name></expr>:
<expr_stmt><expr><name>fd1</name> = <call><name>_open_osfhandle</name><argument_list>(<argument><expr>(<name>Py_intptr_t</name>)<name>hChildStdoutRdDup</name></expr></argument>, <argument><expr><name>mode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>f1</name> = <call><name>_fdopen</name><argument_list>(<argument><expr><name>fd1</name></expr></argument>, <argument><expr>"r"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>f</name> = <call><name>PyFile_FromFile</name><argument_list>(<argument><expr><name>f1</name></expr></argument>, <argument><expr><name>cmdstring</name></expr></argument>, <argument><expr>"r"</expr></argument>, <argument><expr><name>_PyPclose</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyFile_SetBufSize</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>CloseHandle</name><argument_list>(<argument><expr><name>hChildStdinWrDup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>CloseHandle</name><argument_list>(<argument><expr><name>hChildStderrRdDup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr><name>_O_RDONLY</name> | <name>_O_BINARY</name></expr>:
<expr_stmt><expr><name>fd1</name> = <call><name>_open_osfhandle</name><argument_list>(<argument><expr>(<name>Py_intptr_t</name>)<name>hChildStdoutRdDup</name></expr></argument>, <argument><expr><name>mode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>f1</name> = <call><name>_fdopen</name><argument_list>(<argument><expr><name>fd1</name></expr></argument>, <argument><expr>"rb"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>f</name> = <call><name>PyFile_FromFile</name><argument_list>(<argument><expr><name>f1</name></expr></argument>, <argument><expr><name>cmdstring</name></expr></argument>, <argument><expr>"rb"</expr></argument>, <argument><expr><name>_PyPclose</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyFile_SetBufSize</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>CloseHandle</name><argument_list>(<argument><expr><name>hChildStdinWrDup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>CloseHandle</name><argument_list>(<argument><expr><name>hChildStderrRdDup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr><name>_O_WRONLY</name> | <name>_O_BINARY</name></expr>:
<expr_stmt><expr><name>fd1</name> = <call><name>_open_osfhandle</name><argument_list>(<argument><expr>(<name>Py_intptr_t</name>)<name>hChildStdinWrDup</name></expr></argument>, <argument><expr><name>mode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>f1</name> = <call><name>_fdopen</name><argument_list>(<argument><expr><name>fd1</name></expr></argument>, <argument><expr>"wb"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>f</name> = <call><name>PyFile_FromFile</name><argument_list>(<argument><expr><name>f1</name></expr></argument>, <argument><expr><name>cmdstring</name></expr></argument>, <argument><expr>"wb"</expr></argument>, <argument><expr><name>_PyPclose</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyFile_SetBufSize</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>CloseHandle</name><argument_list>(<argument><expr><name>hChildStdoutRdDup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>CloseHandle</name><argument_list>(<argument><expr><name>hChildStderrRdDup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</case>}</block></switch>
<expr_stmt><expr><name>file_count</name> = 1</expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr><name>POPEN_2</name></expr>:
</case><case>case <expr><name>POPEN_4</name></expr>: <block>{
<decl_stmt><decl><type><name>char</name> *</type><name>m1</name></decl>, *<decl><type ref="prev"/><name>m2</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>p1</name></decl>, *<decl><type ref="prev"/><name>p2</name></decl>;</decl_stmt>
<if>if <condition>(<expr><name>mode</name> &amp; <name>_O_TEXT</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>m1</name> = "r"</expr>;</expr_stmt>
<expr_stmt><expr><name>m2</name> = "w"</expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr><name>m1</name> = "rb"</expr>;</expr_stmt>
<expr_stmt><expr><name>m2</name> = "wb"</expr>;</expr_stmt>
}</block></else></if>
<expr_stmt><expr><name>fd1</name> = <call><name>_open_osfhandle</name><argument_list>(<argument><expr>(<name>Py_intptr_t</name>)<name>hChildStdinWrDup</name></expr></argument>, <argument><expr><name>mode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>f1</name> = <call><name>_fdopen</name><argument_list>(<argument><expr><name>fd1</name></expr></argument>, <argument><expr><name>m2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>fd2</name> = <call><name>_open_osfhandle</name><argument_list>(<argument><expr>(<name>Py_intptr_t</name>)<name>hChildStdoutRdDup</name></expr></argument>, <argument><expr><name>mode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>f2</name> = <call><name>_fdopen</name><argument_list>(<argument><expr><name>fd2</name></expr></argument>, <argument><expr><name>m1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>p1</name> = <call><name>PyFile_FromFile</name><argument_list>(<argument><expr><name>f1</name></expr></argument>, <argument><expr><name>cmdstring</name></expr></argument>, <argument><expr><name>m2</name></expr></argument>, <argument><expr><name>_PyPclose</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyFile_SetBufSize</name><argument_list>(<argument><expr><name>p1</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>p2</name> = <call><name>PyFile_FromFile</name><argument_list>(<argument><expr><name>f2</name></expr></argument>, <argument><expr><name>cmdstring</name></expr></argument>, <argument><expr><name>m1</name></expr></argument>, <argument><expr><name>_PyPclose</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyFile_SetBufSize</name><argument_list>(<argument><expr><name>p2</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>n</name> != 4</expr>)</condition><then>
<expr_stmt><expr><call><name>CloseHandle</name><argument_list>(<argument><expr><name>hChildStderrRdDup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<expr_stmt><expr><name>f</name> = <call><name>PyTuple_Pack</name><argument_list>(<argument><expr>2</expr></argument>,<argument><expr><name>p1</name></expr></argument>,<argument><expr><name>p2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>p1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>p2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>file_count</name> = 2</expr>;</expr_stmt>
<break>break;</break>
}</block>
</case><case>case <expr><name>POPEN_3</name></expr>: <block>{
<decl_stmt><decl><type><name>char</name> *</type><name>m1</name></decl>, *<decl><type ref="prev"/><name>m2</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>p1</name></decl>, *<decl><type ref="prev"/><name>p2</name></decl>, *<decl><type ref="prev"/><name>p3</name></decl>;</decl_stmt>
<if>if <condition>(<expr><name>mode</name> &amp; <name>_O_TEXT</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>m1</name> = "r"</expr>;</expr_stmt>
<expr_stmt><expr><name>m2</name> = "w"</expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr><name>m1</name> = "rb"</expr>;</expr_stmt>
<expr_stmt><expr><name>m2</name> = "wb"</expr>;</expr_stmt>
}</block></else></if>
<expr_stmt><expr><name>fd1</name> = <call><name>_open_osfhandle</name><argument_list>(<argument><expr>(<name>Py_intptr_t</name>)<name>hChildStdinWrDup</name></expr></argument>, <argument><expr><name>mode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>f1</name> = <call><name>_fdopen</name><argument_list>(<argument><expr><name>fd1</name></expr></argument>, <argument><expr><name>m2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>fd2</name> = <call><name>_open_osfhandle</name><argument_list>(<argument><expr>(<name>Py_intptr_t</name>)<name>hChildStdoutRdDup</name></expr></argument>, <argument><expr><name>mode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>f2</name> = <call><name>_fdopen</name><argument_list>(<argument><expr><name>fd2</name></expr></argument>, <argument><expr><name>m1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>fd3</name> = <call><name>_open_osfhandle</name><argument_list>(<argument><expr>(<name>Py_intptr_t</name>)<name>hChildStderrRdDup</name></expr></argument>, <argument><expr><name>mode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>f3</name> = <call><name>_fdopen</name><argument_list>(<argument><expr><name>fd3</name></expr></argument>, <argument><expr><name>m1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>p1</name> = <call><name>PyFile_FromFile</name><argument_list>(<argument><expr><name>f1</name></expr></argument>, <argument><expr><name>cmdstring</name></expr></argument>, <argument><expr><name>m2</name></expr></argument>, <argument><expr><name>_PyPclose</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>p2</name> = <call><name>PyFile_FromFile</name><argument_list>(<argument><expr><name>f2</name></expr></argument>, <argument><expr><name>cmdstring</name></expr></argument>, <argument><expr><name>m1</name></expr></argument>, <argument><expr><name>_PyPclose</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>p3</name> = <call><name>PyFile_FromFile</name><argument_list>(<argument><expr><name>f3</name></expr></argument>, <argument><expr><name>cmdstring</name></expr></argument>, <argument><expr><name>m1</name></expr></argument>, <argument><expr><name>_PyPclose</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyFile_SetBufSize</name><argument_list>(<argument><expr><name>p1</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyFile_SetBufSize</name><argument_list>(<argument><expr><name>p2</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyFile_SetBufSize</name><argument_list>(<argument><expr><name>p3</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>f</name> = <call><name>PyTuple_Pack</name><argument_list>(<argument><expr>3</expr></argument>,<argument><expr><name>p1</name></expr></argument>,<argument><expr><name>p2</name></expr></argument>,<argument><expr><name>p3</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>p1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>p2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>p3</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>file_count</name> = 3</expr>;</expr_stmt>
<break>break;</break>
}</block>
</case>}</block></switch>
<if>if <condition>(<expr><name>n</name> == <name>POPEN_4</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr>!<call><name>_PyPopenCreateProcess</name><argument_list>(<argument><expr><name>cmdstring</name></expr></argument>,
<argument><expr><name>hChildStdinRd</name></expr></argument>,
<argument><expr><name>hChildStdoutWr</name></expr></argument>,
<argument><expr><name>hChildStdoutWr</name></expr></argument>,
<argument><expr>&amp;<name>hProcess</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
}</block></then> <else>else <block>{
<if>if <condition>(<expr>!<call><name>_PyPopenCreateProcess</name><argument_list>(<argument><expr><name>cmdstring</name></expr></argument>,
<argument><expr><name>hChildStdinRd</name></expr></argument>,
<argument><expr><name>hChildStdoutWr</name></expr></argument>,
<argument><expr><name>hChildStderrWr</name></expr></argument>,
<argument><expr>&amp;<name>hProcess</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
}</block></else></if>
<if>if <condition>(<expr>!<name>_PyPopenProcs</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>_PyPopenProcs</name> = <call><name>PyDict_New</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<if>if <condition>(<expr><name>_PyPopenProcs</name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>procObj</name></decl>, *<decl><type ref="prev"/><name>hProcessObj</name></decl>, *<decl><type ref="prev"/><name>intObj</name></decl>, *<decl><type ref="prev"/><name><name>fileObj</name><index>[<expr>3</expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name><name>ins_rc</name><index>[<expr>3</expr>]</index></name></decl>;</decl_stmt>
<expr_stmt><expr><name><name>fileObj</name><index>[<expr>0</expr>]</index></name> = <name><name>fileObj</name><index>[<expr>1</expr>]</index></name> = <name><name>fileObj</name><index>[<expr>2</expr>]</index></name> = <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ins_rc</name><index>[<expr>0</expr>]</index></name> = <name><name>ins_rc</name><index>[<expr>1</expr>]</index></name> = <name><name>ins_rc</name><index>[<expr>2</expr>]</index></name> = 0</expr>;</expr_stmt>
<expr_stmt><expr><name>procObj</name> = <call><name>PyList_New</name><argument_list>(<argument><expr>2</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>hProcessObj</name> = <call><name>PyLong_FromVoidPtr</name><argument_list>(<argument><expr><name>hProcess</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>intObj</name> = <call><name>PyInt_FromLong</name><argument_list>(<argument><expr><name>file_count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>procObj</name> &amp;&amp; <name>hProcessObj</name> &amp;&amp; <name>intObj</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyList_SetItem</name><argument_list>(<argument><expr><name>procObj</name></expr></argument>,<argument><expr>0</expr></argument>,<argument><expr><name>hProcessObj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyList_SetItem</name><argument_list>(<argument><expr><name>procObj</name></expr></argument>,<argument><expr>1</expr></argument>,<argument><expr><name>intObj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>fileObj</name><index>[<expr>0</expr>]</index></name> = <call><name>PyLong_FromVoidPtr</name><argument_list>(<argument><expr><name>f1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>fileObj</name><index>[<expr>0</expr>]</index></name></expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>ins_rc</name><index>[<expr>0</expr>]</index></name> = <call><name>PyDict_SetItem</name><argument_list>(<argument><expr><name>_PyPopenProcs</name></expr></argument>,
<argument><expr><name><name>fileObj</name><index>[<expr>0</expr>]</index></name></expr></argument>,
<argument><expr><name>procObj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<if>if <condition>(<expr><name>file_count</name> &gt;= 2</expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>fileObj</name><index>[<expr>1</expr>]</index></name> = <call><name>PyLong_FromVoidPtr</name><argument_list>(<argument><expr><name>f2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>fileObj</name><index>[<expr>1</expr>]</index></name></expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>ins_rc</name><index>[<expr>1</expr>]</index></name> = <call><name>PyDict_SetItem</name><argument_list>(<argument><expr><name>_PyPopenProcs</name></expr></argument>,
<argument><expr><name><name>fileObj</name><index>[<expr>1</expr>]</index></name></expr></argument>,
<argument><expr><name>procObj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
}</block></then></if>
<if>if <condition>(<expr><name>file_count</name> &gt;= 3</expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>fileObj</name><index>[<expr>2</expr>]</index></name> = <call><name>PyLong_FromVoidPtr</name><argument_list>(<argument><expr><name>f3</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>fileObj</name><index>[<expr>2</expr>]</index></name></expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>ins_rc</name><index>[<expr>2</expr>]</index></name> = <call><name>PyDict_SetItem</name><argument_list>(<argument><expr><name>_PyPopenProcs</name></expr></argument>,
<argument><expr><name><name>fileObj</name><index>[<expr>2</expr>]</index></name></expr></argument>,
<argument><expr><name>procObj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
}</block></then></if>
<if>if <condition>(<expr><name><name>ins_rc</name><index>[<expr>0</expr>]</index></name> &lt; 0 || !<name><name>fileObj</name><index>[<expr>0</expr>]</index></name> ||
<name><name>ins_rc</name><index>[<expr>1</expr>]</index></name> &lt; 0 || (<name>file_count</name> &gt; 1 &amp;&amp; !<name><name>fileObj</name><index>[<expr>1</expr>]</index></name>) ||
<name><name>ins_rc</name><index>[<expr>2</expr>]</index></name> &lt; 0 || (<name>file_count</name> &gt; 2 &amp;&amp; !<name><name>fileObj</name><index>[<expr>2</expr>]</index></name>)</expr>)</condition><then> <block>{
<if>if <condition>(<expr>!<name><name>ins_rc</name><index>[<expr>0</expr>]</index></name> &amp;&amp; <name><name>fileObj</name><index>[<expr>0</expr>]</index></name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyDict_DelItem</name><argument_list>(<argument><expr><name>_PyPopenProcs</name></expr></argument>,
<argument><expr><name><name>fileObj</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<if>if <condition>(<expr>!<name><name>ins_rc</name><index>[<expr>1</expr>]</index></name> &amp;&amp; <name><name>fileObj</name><index>[<expr>1</expr>]</index></name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyDict_DelItem</name><argument_list>(<argument><expr><name>_PyPopenProcs</name></expr></argument>,
<argument><expr><name><name>fileObj</name><index>[<expr>1</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<if>if <condition>(<expr>!<name><name>ins_rc</name><index>[<expr>2</expr>]</index></name> &amp;&amp; <name><name>fileObj</name><index>[<expr>2</expr>]</index></name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyDict_DelItem</name><argument_list>(<argument><expr><name>_PyPopenProcs</name></expr></argument>,
<argument><expr><name><name>fileObj</name><index>[<expr>2</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
}</block></then></if>
}</block></then></if>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>procObj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name><name>fileObj</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name><name>fileObj</name><index>[<expr>1</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name><name>fileObj</name><index>[<expr>2</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<if>if <condition>(<expr>!<call><name>CloseHandle</name><argument_list>(<argument><expr><name>hChildStdinRd</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><call><name>win32_error</name><argument_list>(<argument><expr>"CloseHandle"</expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
<if>if <condition>(<expr>!<call><name>CloseHandle</name><argument_list>(<argument><expr><name>hChildStdoutWr</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><call><name>win32_error</name><argument_list>(<argument><expr>"CloseHandle"</expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
<if>if <condition>(<expr>(<name>n</name> != 4) &amp;&amp; (!<call><name>CloseHandle</name><argument_list>(<argument><expr><name>hChildStderrWr</name></expr></argument>)</argument_list></call>)</expr>)</condition><then>
<return>return <expr><call><name>win32_error</name><argument_list>(<argument><expr>"CloseHandle"</expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
<return>return <expr><name>f</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>_PyPclose</name><parameter_list>(<param><decl><type><name>FILE</name> *</type><name>file</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>result</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>DWORD</name></type> <name>exit_code</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>HANDLE</name></type> <name>hProcess</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>procObj</name></decl>, *<decl><type ref="prev"/><name>hProcessObj</name></decl>, *<decl><type ref="prev"/><name>intObj</name></decl>, *<decl><type ref="prev"/><name>fileObj</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>long</name></type> <name>file_count</name></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>WITH_THREAD</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>PyGILState_STATE</name></type> <name>state</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><name>result</name> = <call><name>fclose</name><argument_list>(<argument><expr><name>file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>WITH_THREAD</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><name>state</name> = <call><name>PyGILState_Ensure</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<if>if <condition>(<expr><name>_PyPopenProcs</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr>(<name>fileObj</name> = <call><name>PyLong_FromVoidPtr</name><argument_list>(<argument><expr><name>file</name></expr></argument>)</argument_list></call>) != <name>NULL</name> &amp;&amp;
(<name>procObj</name> = <call><name>PyDict_GetItem</name><argument_list>(<argument><expr><name>_PyPopenProcs</name></expr></argument>,
<argument><expr><name>fileObj</name></expr></argument>)</argument_list></call>) != <name>NULL</name> &amp;&amp;
(<name>hProcessObj</name> = <call><name>PyList_GetItem</name><argument_list>(<argument><expr><name>procObj</name></expr></argument>,<argument><expr>0</expr></argument>)</argument_list></call>) != <name>NULL</name> &amp;&amp;
(<name>intObj</name> = <call><name>PyList_GetItem</name><argument_list>(<argument><expr><name>procObj</name></expr></argument>,<argument><expr>1</expr></argument>)</argument_list></call>) != <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>hProcess</name> = <call><name>PyLong_AsVoidPtr</name><argument_list>(<argument><expr><name>hProcessObj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>file_count</name> = <call><name>PyInt_AsLong</name><argument_list>(<argument><expr><name>intObj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>file_count</name> &gt; 1</expr>)</condition><then> <block>{
<expr_stmt><expr><name>file_count</name>--</expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyList_SetItem</name><argument_list>(<argument><expr><name>procObj</name></expr></argument>,<argument><expr>1</expr></argument>,
<argument><expr><call><name>PyInt_FromLong</name><argument_list>(<argument><expr><name>file_count</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<if>if <condition>(<expr><name>result</name> != <name>EOF</name> &amp;&amp;
<call><name>WaitForSingleObject</name><argument_list>(<argument><expr><name>hProcess</name></expr></argument>, <argument><expr><name>INFINITE</name></expr></argument>)</argument_list></call> != <name>WAIT_FAILED</name> &amp;&amp;
<call><name>GetExitCodeProcess</name><argument_list>(<argument><expr><name>hProcess</name></expr></argument>, <argument><expr>&amp;<name>exit_code</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><name>result</name> = <name>exit_code</name></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<if>if <condition>(<expr><name>result</name> != <name>EOF</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>errno</name> = <call><name>GetLastError</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><name>result</name> = -1</expr>;</expr_stmt>
}</block></else></if>
<expr_stmt><expr><call><name>CloseHandle</name><argument_list>(<argument><expr><name>hProcess</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></else></if>
<expr_stmt><expr><call><name>PyDict_DelItem</name><argument_list>(<argument><expr><name>_PyPopenProcs</name></expr></argument>, <argument><expr><name>fileObj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>PyDict_Size</name><argument_list>(<argument><expr><name>_PyPopenProcs</name></expr></argument>)</argument_list></call> == 0</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>_PyPopenProcs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>_PyPopenProcs</name> = <name>NULL</name></expr>;</expr_stmt>
}</block></then></if>
}</block></then></if>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>fileObj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>WITH_THREAD</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyGILState_Release</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<return>return <expr><name>result</name></expr>;</return>
}</block></function>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>posix_popen</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>char</name> *</type><name>name</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>mode</name> <init>= <expr>"r"</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>bufsize</name> <init>= <expr>-1</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>FILE</name> *</type><name>fp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>f</name></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"s|si:popen"</expr></argument>, <argument><expr>&amp;<name>name</name></expr></argument>, <argument><expr>&amp;<name>mode</name></expr></argument>, <argument><expr>&amp;<name>bufsize</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>mode</name></expr></argument>, <argument><expr>"rb"</expr></argument>)</argument_list></call> == 0 || <call><name>strcmp</name><argument_list>(<argument><expr><name>mode</name></expr></argument>, <argument><expr>"rt"</expr></argument>)</argument_list></call> == 0</expr>)</condition><then>
<expr_stmt><expr><name>mode</name> = "r"</expr>;</expr_stmt></then>
<else>else <if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>mode</name></expr></argument>, <argument><expr>"wb"</expr></argument>)</argument_list></call> == 0 || <call><name>strcmp</name><argument_list>(<argument><expr><name>mode</name></expr></argument>, <argument><expr>"wt"</expr></argument>)</argument_list></call> == 0</expr>)</condition><then>
<expr_stmt><expr><name>mode</name> = "w"</expr>;</expr_stmt></then></if></else></if>
<decl_stmt><decl><type><name>Py_BEGIN_ALLOW_THREADS</name></type>
<name>fp</name> <init>= <expr><call><name>popen</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>mode</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<macro><name>Py_END_ALLOW_THREADS</name></macro>
<if>if <condition>(<expr><name>fp</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><call><name>posix_error</name><argument_list>()</argument_list></call></expr>;</return></then></if>
<expr_stmt><expr><name>f</name> = <call><name>PyFile_FromFile</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>mode</name></expr></argument>, <argument><expr><name>pclose</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>f</name> != <name>NULL</name></expr>)</condition><then>
<expr_stmt><expr><call><name>PyFile_SetBufSize</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><name>bufsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<return>return <expr><name>f</name></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_SETUID</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>posix_setuid__doc__</name></expr></argument>,
<argument><expr>"setuid(uid)\n\n\
Set the current process's user id."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>posix_setuid</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>uid</name></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"i:setuid"</expr></argument>, <argument><expr>&amp;<name>uid</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<if>if <condition>(<expr><call><name>setuid</name><argument_list>(<argument><expr><name>uid</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
<return>return <expr><call><name>posix_error</name><argument_list>()</argument_list></call></expr>;</return></then></if>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>Py_None</name></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_SETEUID</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>posix_seteuid__doc__</name></expr></argument>,
<argument><expr>"seteuid(uid)\n\n\
Set the current process's effective user id."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>posix_seteuid</name> <parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>euid</name></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"i"</expr></argument>, <argument><expr>&amp;<name>euid</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then> <else>else <if>if <condition>(<expr><call><name>seteuid</name><argument_list>(<argument><expr><name>euid</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then> <block>{
<return>return <expr><call><name>posix_error</name><argument_list>()</argument_list></call></expr>;</return>
}</block></then> <else>else <block>{
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>Py_None</name></expr>;</return>
}</block></else></if></else></if>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_SETEGID</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>posix_setegid__doc__</name></expr></argument>,
<argument><expr>"setegid(gid)\n\n\
Set the current process's effective group id."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>posix_setegid</name> <parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>egid</name></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"i"</expr></argument>, <argument><expr>&amp;<name>egid</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then> <else>else <if>if <condition>(<expr><call><name>setegid</name><argument_list>(<argument><expr><name>egid</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then> <block>{
<return>return <expr><call><name>posix_error</name><argument_list>()</argument_list></call></expr>;</return>
}</block></then> <else>else <block>{
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>Py_None</name></expr>;</return>
}</block></else></if></else></if>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_SETREUID</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>posix_setreuid__doc__</name></expr></argument>,
<argument><expr>"setreuid(ruid, euid)\n\n\
Set the current process's real and effective user ids."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>posix_setreuid</name> <parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>ruid</name></decl>, <decl><type ref="prev"/><name>euid</name></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"ii"</expr></argument>, <argument><expr>&amp;<name>ruid</name></expr></argument>, <argument><expr>&amp;<name>euid</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then> <else>else <if>if <condition>(<expr><call><name>setreuid</name><argument_list>(<argument><expr><name>ruid</name></expr></argument>, <argument><expr><name>euid</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then> <block>{
<return>return <expr><call><name>posix_error</name><argument_list>()</argument_list></call></expr>;</return>
}</block></then> <else>else <block>{
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>Py_None</name></expr>;</return>
}</block></else></if></else></if>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_SETREGID</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>posix_setregid__doc__</name></expr></argument>,
<argument><expr>"setregid(rgid, egid)\n\n\
Set the current process's real and effective group ids."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>posix_setregid</name> <parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>rgid</name></decl>, <decl><type ref="prev"/><name>egid</name></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"ii"</expr></argument>, <argument><expr>&amp;<name>rgid</name></expr></argument>, <argument><expr>&amp;<name>egid</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then> <else>else <if>if <condition>(<expr><call><name>setregid</name><argument_list>(<argument><expr><name>rgid</name></expr></argument>, <argument><expr><name>egid</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then> <block>{
<return>return <expr><call><name>posix_error</name><argument_list>()</argument_list></call></expr>;</return>
}</block></then> <else>else <block>{
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>Py_None</name></expr>;</return>
}</block></else></if></else></if>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_SETGID</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>posix_setgid__doc__</name></expr></argument>,
<argument><expr>"setgid(gid)\n\n\
Set the current process's group id."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>posix_setgid</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>gid</name></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"i:setgid"</expr></argument>, <argument><expr>&amp;<name>gid</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<if>if <condition>(<expr><call><name>setgid</name><argument_list>(<argument><expr><name>gid</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
<return>return <expr><call><name>posix_error</name><argument_list>()</argument_list></call></expr>;</return></then></if>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>Py_None</name></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_SETGROUPS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>posix_setgroups__doc__</name></expr></argument>,
<argument><expr>"setgroups(list)\n\n\
Set the groups of the current process to list."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>posix_setgroups</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>groups</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>len</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>gid_t</name></type> <name><name>grouplist</name><index>[<expr><name>MAX_GROUPS</name></expr>]</index></name></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>PySequence_Check</name><argument_list>(<argument><expr><name>groups</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>, <argument><expr>"setgroups argument must be a sequence"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>len</name> = <call><name>PySequence_Size</name><argument_list>(<argument><expr><name>groups</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>len</name> &gt; <name>MAX_GROUPS</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>, <argument><expr>"too many groups"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<for>for(<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>len</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>elem</name></decl>;</decl_stmt>
<expr_stmt><expr><name>elem</name> = <call><name>PySequence_GetItem</name><argument_list>(<argument><expr><name>groups</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>elem</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<if>if <condition>(<expr>!<call><name>PyInt_Check</name><argument_list>(<argument><expr><name>elem</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<if>if <condition>(<expr>!<call><name>PyLong_Check</name><argument_list>(<argument><expr><name>elem</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
<argument><expr>"groups must be integers"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>elem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then> <else>else <block>{
<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>x</name> <init>= <expr><call><name>PyLong_AsUnsignedLong</name><argument_list>(<argument><expr><name>elem</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
<argument><expr>"group id too big"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>elem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name><name>grouplist</name><index>[<expr><name>i</name></expr>]</index></name> = <name>x</name></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>grouplist</name><index>[<expr><name>i</name></expr>]</index></name> != <name>x</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
<argument><expr>"group id too big"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>elem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
}</block></else></if>
}</block></then> <else>else <block>{
<decl_stmt><decl><type><name>long</name></type> <name>x</name> <init>= <expr><call><name>PyInt_AsLong</name><argument_list>(<argument><expr><name>elem</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>grouplist</name><index>[<expr><name>i</name></expr>]</index></name> = <name>x</name></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>grouplist</name><index>[<expr><name>i</name></expr>]</index></name> != <name>x</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
<argument><expr>"group id too big"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>elem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
}</block></else></if>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>elem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></for>
<if>if <condition>(<expr><call><name>setgroups</name><argument_list>(<argument><expr><name>len</name></expr></argument>, <argument><expr><name>grouplist</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
<return>return <expr><call><name>posix_error</name><argument_list>()</argument_list></call></expr>;</return></then></if>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>Py_None</name></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_WAIT3</name></expr></argument>)</argument_list></call> || <call><name>defined</name><argument_list>(<argument><expr><name>HAVE_WAIT4</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>wait_helper</name><parameter_list>(<param><decl><type><name>pid_t</name></type> <name>pid</name></decl></param>, <param><decl><type><name>int</name></type> <name>status</name></decl></param>, <param><decl><type>struct <name>rusage</name> *</type><name>ru</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>result</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>PyObject</name> *</type><name>struct_rusage</name></decl>;</decl_stmt>
<if>if <condition>(<expr><name>pid</name> == -1</expr>)</condition><then>
<return>return <expr><call><name>posix_error</name><argument_list>()</argument_list></call></expr>;</return></then></if>
<if>if <condition>(<expr><name>struct_rusage</name> == <name>NULL</name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>m</name> <init>= <expr><call><name>PyImport_ImportModuleNoBlock</name><argument_list>(<argument><expr>"resource"</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>m</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>struct_rusage</name> = <call><name>PyObject_GetAttrString</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"struct_rusage"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>m</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>struct_rusage</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
}</block></then></if>
<expr_stmt><expr><name>result</name> = <call><name>PyStructSequence_New</name><argument_list>(<argument><expr>(<name>PyTypeObject</name>*) <name>struct_rusage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>result</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>doubletime</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>doubletime</name><parameter_list>(<param><type><name>TV</name></type></param>)</parameter_list></cpp:macro> <cpp:value>((double)(TV).tv_sec + (TV).tv_usec * 0.000001)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><call><name>PyStructSequence_SET_ITEM</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr>0</expr></argument>,
<argument><expr><call><name>PyFloat_FromDouble</name><argument_list>(<argument><expr><call><name>doubletime</name><argument_list>(<argument><expr><name><name>ru</name>-&gt;<name>ru_utime</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyStructSequence_SET_ITEM</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr>1</expr></argument>,
<argument><expr><call><name>PyFloat_FromDouble</name><argument_list>(<argument><expr><call><name>doubletime</name><argument_list>(<argument><expr><name><name>ru</name>-&gt;<name>ru_stime</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SET_INT</name><parameter_list>(<param><type><name>result</name></type></param>, <param><type><name>index</name></type></param>, <param><type><name>value</name></type></param>)</parameter_list></cpp:macro><cpp:value>PyStructSequence_SET_ITEM(result, index, PyInt_FromLong(value))</cpp:value></cpp:define>
<expr_stmt><expr><call><name>SET_INT</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr>2</expr></argument>, <argument><expr><name><name>ru</name>-&gt;<name>ru_maxrss</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SET_INT</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr>3</expr></argument>, <argument><expr><name><name>ru</name>-&gt;<name>ru_ixrss</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SET_INT</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr>4</expr></argument>, <argument><expr><name><name>ru</name>-&gt;<name>ru_idrss</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SET_INT</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr>5</expr></argument>, <argument><expr><name><name>ru</name>-&gt;<name>ru_isrss</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SET_INT</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr>6</expr></argument>, <argument><expr><name><name>ru</name>-&gt;<name>ru_minflt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SET_INT</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr>7</expr></argument>, <argument><expr><name><name>ru</name>-&gt;<name>ru_majflt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SET_INT</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr>8</expr></argument>, <argument><expr><name><name>ru</name>-&gt;<name>ru_nswap</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SET_INT</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr>9</expr></argument>, <argument><expr><name><name>ru</name>-&gt;<name>ru_inblock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SET_INT</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr>10</expr></argument>, <argument><expr><name><name>ru</name>-&gt;<name>ru_oublock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SET_INT</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr>11</expr></argument>, <argument><expr><name><name>ru</name>-&gt;<name>ru_msgsnd</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SET_INT</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr>12</expr></argument>, <argument><expr><name><name>ru</name>-&gt;<name>ru_msgrcv</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SET_INT</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr>13</expr></argument>, <argument><expr><name><name>ru</name>-&gt;<name>ru_nsignals</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SET_INT</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr>14</expr></argument>, <argument><expr><name><name>ru</name>-&gt;<name>ru_nvcsw</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SET_INT</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr>15</expr></argument>, <argument><expr><name><name>ru</name>-&gt;<name>ru_nivcsw</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>SET_INT</name></cpp:undef>
<if>if <condition>(<expr><call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<return>return <expr><call><name>Py_BuildValue</name><argument_list>(<argument><expr>"iiN"</expr></argument>, <argument><expr><name>pid</name></expr></argument>, <argument><expr><name>status</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_WAIT3</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>posix_wait3__doc__</name></expr></argument>,
<argument><expr>"wait3(options) -&gt; (pid, status, rusage)\n\n\
Wait for completion of a child process."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>posix_wait3</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>pid_t</name></type> <name>pid</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>options</name></decl>;</decl_stmt>
<decl_stmt><decl><type>struct <name>rusage</name></type> <name>ru</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>WAIT_TYPE</name></type> <name>status</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>WAIT_STATUS_INT</name><argument_list>(<argument><expr><name>status</name></expr></argument>)</argument_list></call> = 0</expr>;</expr_stmt>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"i:wait3"</expr></argument>, <argument><expr>&amp;<name>options</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<decl_stmt><decl><type><name>Py_BEGIN_ALLOW_THREADS</name></type>
<name>pid</name> <init>= <expr><call><name>wait3</name><argument_list>(<argument><expr>&amp;<name>status</name></expr></argument>, <argument><expr><name>options</name></expr></argument>, <argument><expr>&amp;<name>ru</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<macro><name>Py_END_ALLOW_THREADS</name></macro>
<return>return <expr><call><name>wait_helper</name><argument_list>(<argument><expr><name>pid</name></expr></argument>, <argument><expr><call><name>WAIT_STATUS_INT</name><argument_list>(<argument><expr><name>status</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>&amp;<name>ru</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_WAIT4</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>posix_wait4__doc__</name></expr></argument>,
<argument><expr>"wait4(pid, options) -&gt; (pid, status, rusage)\n\n\
Wait for completion of a given child process."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>posix_wait4</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>pid_t</name></type> <name>pid</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>options</name></decl>;</decl_stmt>
<decl_stmt><decl><type>struct <name>rusage</name></type> <name>ru</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>WAIT_TYPE</name></type> <name>status</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>WAIT_STATUS_INT</name><argument_list>(<argument><expr><name>status</name></expr></argument>)</argument_list></call> = 0</expr>;</expr_stmt>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"ii:wait4"</expr></argument>, <argument><expr>&amp;<name>pid</name></expr></argument>, <argument><expr>&amp;<name>options</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<decl_stmt><decl><type><name>Py_BEGIN_ALLOW_THREADS</name></type>
<name>pid</name> <init>= <expr><call><name>wait4</name><argument_list>(<argument><expr><name>pid</name></expr></argument>, <argument><expr>&amp;<name>status</name></expr></argument>, <argument><expr><name>options</name></expr></argument>, <argument><expr>&amp;<name>ru</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<macro><name>Py_END_ALLOW_THREADS</name></macro>
<return>return <expr><call><name>wait_helper</name><argument_list>(<argument><expr><name>pid</name></expr></argument>, <argument><expr><call><name>WAIT_STATUS_INT</name><argument_list>(<argument><expr><name>status</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>&amp;<name>ru</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_WAITPID</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>posix_waitpid__doc__</name></expr></argument>,
<argument><expr>"waitpid(pid, options) -&gt; (pid, status)\n\n\
Wait for completion of a given child process."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>posix_waitpid</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>pid_t</name></type> <name>pid</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>options</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>WAIT_TYPE</name></type> <name>status</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>WAIT_STATUS_INT</name><argument_list>(<argument><expr><name>status</name></expr></argument>)</argument_list></call> = 0</expr>;</expr_stmt>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"ii:waitpid"</expr></argument>, <argument><expr>&amp;<name>pid</name></expr></argument>, <argument><expr>&amp;<name>options</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<decl_stmt><decl><type><name>Py_BEGIN_ALLOW_THREADS</name></type>
<name>pid</name> <init>= <expr><call><name>waitpid</name><argument_list>(<argument><expr><name>pid</name></expr></argument>, <argument><expr>&amp;<name>status</name></expr></argument>, <argument><expr><name>options</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<macro><name>Py_END_ALLOW_THREADS</name></macro>
<if>if <condition>(<expr><name>pid</name> == -1</expr>)</condition><then>
<return>return <expr><call><name>posix_error</name><argument_list>()</argument_list></call></expr>;</return></then></if>
<return>return <expr><call><name>Py_BuildValue</name><argument_list>(<argument><expr>"ii"</expr></argument>, <argument><expr><name>pid</name></expr></argument>, <argument><expr><call><name>WAIT_STATUS_INT</name><argument_list>(<argument><expr><name>status</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_CWAIT</name></expr></argument>)</argument_list></call></expr></cpp:elif>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>posix_waitpid__doc__</name></expr></argument>,
<argument><expr>"waitpid(pid, options) -&gt; (pid, status &lt;&lt; 8)\n\n"
"Wait for completion of a given process. options is ignored on Windows."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>posix_waitpid</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>Py_intptr_t</name></type> <name>pid</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>status</name></decl>, <decl><type ref="prev"/><name>options</name></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"ii:waitpid"</expr></argument>, <argument><expr>&amp;<name>pid</name></expr></argument>, <argument><expr>&amp;<name>options</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<decl_stmt><decl><type><name>Py_BEGIN_ALLOW_THREADS</name></type>
<name>pid</name> <init>= <expr><call><name>_cwait</name><argument_list>(<argument><expr>&amp;<name>status</name></expr></argument>, <argument><expr><name>pid</name></expr></argument>, <argument><expr><name>options</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<macro><name>Py_END_ALLOW_THREADS</name></macro>
<if>if <condition>(<expr><name>pid</name> == -1</expr>)</condition><then>
<return>return <expr><call><name>posix_error</name><argument_list>()</argument_list></call></expr>;</return></then></if>
<return>return <expr><call><name>Py_BuildValue</name><argument_list>(<argument><expr>"ii"</expr></argument>, <argument><expr><name>pid</name></expr></argument>, <argument><expr><name>status</name> &lt;&lt; 8</expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_WAIT</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>posix_wait__doc__</name></expr></argument>,
<argument><expr>"wait() -&gt; (pid, status)\n\n\
Wait for completion of a child process."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>posix_wait</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>noargs</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>pid_t</name></type> <name>pid</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>WAIT_TYPE</name></type> <name>status</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>WAIT_STATUS_INT</name><argument_list>(<argument><expr><name>status</name></expr></argument>)</argument_list></call> = 0</expr>;</expr_stmt>
<decl_stmt><decl><type><name>Py_BEGIN_ALLOW_THREADS</name></type>
<name>pid</name> <init>= <expr><call><name>wait</name><argument_list>(<argument><expr>&amp;<name>status</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<macro><name>Py_END_ALLOW_THREADS</name></macro>
<if>if <condition>(<expr><name>pid</name> == -1</expr>)</condition><then>
<return>return <expr><call><name>posix_error</name><argument_list>()</argument_list></call></expr>;</return></then></if>
<return>return <expr><call><name>Py_BuildValue</name><argument_list>(<argument><expr>"ii"</expr></argument>, <argument><expr><name>pid</name></expr></argument>, <argument><expr><call><name>WAIT_STATUS_INT</name><argument_list>(<argument><expr><name>status</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>posix_lstat__doc__</name></expr></argument>,
<argument><expr>"lstat(path) -&gt; stat result\n\n\
Like stat(path), but do not follow symbolic links."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>posix_lstat</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_LSTAT</name></expr></argument>)</argument_list></call></expr></cpp:if>
<return>return <expr><call><name>posix_do_stat</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>args</name></expr></argument>, <argument><expr>"et:lstat"</expr></argument>, <argument><expr><name>lstat</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MS_WINDOWS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<return>return <expr><call><name>posix_do_stat</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>args</name></expr></argument>, <argument><expr>"et:lstat"</expr></argument>, <argument><expr><name>STAT</name></expr></argument>, <argument><expr>"U:lstat"</expr></argument>, <argument><expr><name>win32_wstat</name></expr></argument>)</argument_list></call></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<return>return <expr><call><name>posix_do_stat</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>args</name></expr></argument>, <argument><expr>"et:lstat"</expr></argument>, <argument><expr><name>STAT</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></function>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_READLINK</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>posix_readlink__doc__</name></expr></argument>,
<argument><expr>"readlink(path) -&gt; path\n\n\
Return a string representing the path to which the symbolic link points."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>posix_readlink</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyObject</name>*</type> <name>v</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name><name>buf</name><index>[<expr><name>MAXPATHLEN</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>path</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>Py_USING_UNICODE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>int</name></type> <name>arg_is_unicode</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"et:readlink"</expr></argument>,
<argument><expr><name>Py_FileSystemDefaultEncoding</name></expr></argument>, <argument><expr>&amp;<name>path</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>Py_USING_UNICODE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><name>v</name> = <call><name>PySequence_GetItem</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>v</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyMem_Free</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<if>if <condition>(<expr><call><name>PyUnicode_Check</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><name>arg_is_unicode</name> = 1</expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<decl_stmt><decl><type><name>Py_BEGIN_ALLOW_THREADS</name></type>
<name>n</name> <init>= <expr><call><name>readlink</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr>(<name>int</name>) sizeof <name>buf</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<macro><name>Py_END_ALLOW_THREADS</name></macro>
<if>if <condition>(<expr><name>n</name> &lt; 0</expr>)</condition><then>
<return>return <expr><call><name>posix_error_with_allocated_filename</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
<expr_stmt><expr><call><name>PyMem_Free</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>v</name> = <call><name>PyString_FromStringAndSize</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>Py_USING_UNICODE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if>if <condition>(<expr><name>arg_is_unicode</name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>w</name></decl>;</decl_stmt>
<expr_stmt><expr><name>w</name> = <call><name>PyUnicode_FromEncodedObject</name><argument_list>(<argument><expr><name>v</name></expr></argument>,
<argument><expr><name>Py_FileSystemDefaultEncoding</name></expr></argument>,
<argument><expr>"strict"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>w</name> != <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>v</name> = <name>w</name></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr><call><name>PyErr_Clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
}</block></else></if>
}</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<return>return <expr><name>v</name></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_SYMLINK</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>posix_symlink__doc__</name></expr></argument>,
<argument><expr>"symlink(src, dst)\n\n\
Create a symbolic link pointing to src named dst."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>posix_symlink</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<return>return <expr><call><name>posix_2str</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"etet:symlink"</expr></argument>, <argument><expr><name>symlink</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_TIMES</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>HZ</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HZ</name></cpp:macro> <cpp:value>60</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>PYCC_VACPP</name></expr></argument>)</argument_list></call> &amp;&amp; <call><name>defined</name><argument_list>(<argument><expr><name>PYOS_OS2</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function><type><specifier>static</specifier> <name>long</name></type>
<name>system_uptime</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>ULONG</name></type> <name>value</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_BEGIN_ALLOW_THREADS</name></type>
<name>DosQuerySysInfo</name><argument_list>(<argument><expr><name>QSV_MS_COUNT</name></expr></argument>, <argument><expr><name>QSV_MS_COUNT</name></expr></argument>, <argument><expr>&amp;<name>value</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></decl>;</decl_stmt>
<macro><name>Py_END_ALLOW_THREADS</name></macro>
<return>return <expr><name>value</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>posix_times</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>noargs</name></decl></param>)</parameter_list> <block>{
<return>return <expr><call><name>Py_BuildValue</name><argument_list>(<argument><expr>"ddddd"</expr></argument>,
<argument><expr>(<name>double</name>)0</expr></argument> ,
<argument><expr>(<name>double</name>)0</expr></argument> ,
<argument><expr>(<name>double</name>)0</expr></argument> ,
<argument><expr>(<name>double</name>)0</expr></argument> ,
<argument><expr>(<name>double</name>)<call><name>system_uptime</name><argument_list>()</argument_list></call> / 1000</expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>posix_times</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>noargs</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type>struct <name>tms</name></type> <name>t</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>clock_t</name></type> <name>c</name></decl>;</decl_stmt>
<expr_stmt><expr><name>errno</name> = 0</expr>;</expr_stmt>
<expr_stmt><expr><name>c</name> = <call><name>times</name><argument_list>(<argument><expr>&amp;<name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>c</name> == (<name>clock_t</name>) -1</expr>)</condition><then>
<return>return <expr><call><name>posix_error</name><argument_list>()</argument_list></call></expr>;</return></then></if>
<return>return <expr><call><name>Py_BuildValue</name><argument_list>(<argument><expr>"ddddd"</expr></argument>,
<argument><expr>(<name>double</name>)<name><name>t</name>.<name>tms_utime</name></name> / <name>HZ</name></expr></argument>,
<argument><expr>(<name>double</name>)<name><name>t</name>.<name>tms_stime</name></name> / <name>HZ</name></expr></argument>,
<argument><expr>(<name>double</name>)<name><name>t</name>.<name>tms_cutime</name></name> / <name>HZ</name></expr></argument>,
<argument><expr>(<name>double</name>)<name><name>t</name>.<name>tms_cstime</name></name> / <name>HZ</name></expr></argument>,
<argument><expr>(<name>double</name>)<name>c</name> / <name>HZ</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MS_WINDOWS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HAVE_TIMES</name></cpp:macro></cpp:define>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>posix_times</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>noargs</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>FILETIME</name></type> <name>create</name></decl>, <decl><type ref="prev"/><name>exit</name></decl>, <decl><type ref="prev"/><name>kernel</name></decl>, <decl><type ref="prev"/><name>user</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>HANDLE</name></type> <name>hProc</name></decl>;</decl_stmt>
<expr_stmt><expr><name>hProc</name> = <call><name>GetCurrentProcess</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>GetProcessTimes</name><argument_list>(<argument><expr><name>hProc</name></expr></argument>, <argument><expr>&amp;<name>create</name></expr></argument>, <argument><expr>&amp;<name>exit</name></expr></argument>, <argument><expr>&amp;<name>kernel</name></expr></argument>, <argument><expr>&amp;<name>user</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>Py_BuildValue</name><argument_list>(
<argument><expr>"ddddd"</expr></argument>,
<argument><expr><call>(<name>double</name>)<argument_list>(<argument><expr><name><name>user</name>.<name>dwHighDateTime</name></name>*429.4967296 +
<name><name>user</name>.<name>dwLowDateTime</name></name>*1e-7</expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call>(<name>double</name>)<argument_list>(<argument><expr><name><name>kernel</name>.<name>dwHighDateTime</name></name>*429.4967296 +
<name><name>kernel</name>.<name>dwLowDateTime</name></name>*1e-7</expr></argument>)</argument_list></call></expr></argument>,
<argument><expr>(<name>double</name>)0</expr></argument>,
<argument><expr>(<name>double</name>)0</expr></argument>,
<argument><expr>(<name>double</name>)0</expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_TIMES</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>posix_times__doc__</name></expr></argument>,
<argument><expr>"times() -&gt; (utime, stime, cutime, cstime, elapsed_time)\n\n\
Return a tuple of floating point numbers indicating process times."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_GETSID</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>posix_getsid__doc__</name></expr></argument>,
<argument><expr>"getsid(pid) -&gt; sid\n\n\
Call the system call getsid()."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>posix_getsid</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>pid_t</name></type> <name>pid</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>sid</name></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"i:getsid"</expr></argument>, <argument><expr>&amp;<name>pid</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>sid</name> = <call><name>getsid</name><argument_list>(<argument><expr><name>pid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>sid</name> &lt; 0</expr>)</condition><then>
<return>return <expr><call><name>posix_error</name><argument_list>()</argument_list></call></expr>;</return></then></if>
<return>return <expr><call><name>PyInt_FromLong</name><argument_list>(<argument><expr>(<name>long</name>)<name>sid</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_SETSID</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>posix_setsid__doc__</name></expr></argument>,
<argument><expr>"setsid()\n\n\
Call the system call setsid()."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>posix_setsid</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>noargs</name></decl></param>)</parameter_list> <block>{
<if>if <condition>(<expr><call><name>setsid</name><argument_list>()</argument_list></call> &lt; 0</expr>)</condition><then>
<return>return <expr><call><name>posix_error</name><argument_list>()</argument_list></call></expr>;</return></then></if>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>Py_None</name></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_SETPGID</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>posix_setpgid__doc__</name></expr></argument>,
<argument><expr>"setpgid(pid, pgrp)\n\n\
Call the system call setpgid()."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>posix_setpgid</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>pid_t</name></type> <name>pid</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>pgrp</name></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"ii:setpgid"</expr></argument>, <argument><expr>&amp;<name>pid</name></expr></argument>, <argument><expr>&amp;<name>pgrp</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<if>if <condition>(<expr><call><name>setpgid</name><argument_list>(<argument><expr><name>pid</name></expr></argument>, <argument><expr><name>pgrp</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
<return>return <expr><call><name>posix_error</name><argument_list>()</argument_list></call></expr>;</return></then></if>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>Py_None</name></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_TCGETPGRP</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>posix_tcgetpgrp__doc__</name></expr></argument>,
<argument><expr>"tcgetpgrp(fd) -&gt; pgid\n\n\
Return the process group associated with the terminal given by a fd."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>posix_tcgetpgrp</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>fd</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>pid_t</name></type> <name>pgid</name></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"i:tcgetpgrp"</expr></argument>, <argument><expr>&amp;<name>fd</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>pgid</name> = <call><name>tcgetpgrp</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>pgid</name> &lt; 0</expr>)</condition><then>
<return>return <expr><call><name>posix_error</name><argument_list>()</argument_list></call></expr>;</return></then></if>
<return>return <expr><call><name>PyInt_FromLong</name><argument_list>(<argument><expr>(<name>long</name>)<name>pgid</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_TCSETPGRP</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>posix_tcsetpgrp__doc__</name></expr></argument>,
<argument><expr>"tcsetpgrp(fd, pgid)\n\n\
Set the process group associated with the terminal given by a fd."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>posix_tcsetpgrp</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>fd</name></decl>, <decl><type ref="prev"/><name>pgid</name></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"ii:tcsetpgrp"</expr></argument>, <argument><expr>&amp;<name>fd</name></expr></argument>, <argument><expr>&amp;<name>pgid</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<if>if <condition>(<expr><call><name>tcsetpgrp</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>pgid</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
<return>return <expr><call><name>posix_error</name><argument_list>()</argument_list></call></expr>;</return></then></if>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>Py_None</name></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>posix_open__doc__</name></expr></argument>,
<argument><expr>"open(filename, flag [, mode=0777]) -&gt; fd\n\n\
Open a file (for low level IO)."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>posix_open</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>char</name> *</type><name>file</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>flag</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>mode</name> <init>= <expr>0777</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>fd</name></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MS_WINDOWS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if>if <condition>(<expr><call><name>unicode_file_names</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>PyUnicodeObject</name> *</type><name>po</name></decl>;</decl_stmt>
<if>if <condition>(<expr><call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"Ui|i:mkdir"</expr></argument>, <argument><expr>&amp;<name>po</name></expr></argument>, <argument><expr>&amp;<name>flag</name></expr></argument>, <argument><expr>&amp;<name>mode</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>Py_BEGIN_ALLOW_THREADS</name></type>
<name>fd</name> <init>= <expr><call><name>_wopen</name><argument_list>(<argument><expr><call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr><name>po</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>flag</name></expr></argument>, <argument><expr><name>mode</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<macro><name>Py_END_ALLOW_THREADS</name></macro>
<if>if <condition>(<expr><name>fd</name> &lt; 0</expr>)</condition><then>
<return>return <expr><call><name>posix_error</name><argument_list>()</argument_list></call></expr>;</return></then></if>
<return>return <expr><call><name>PyInt_FromLong</name><argument_list>(<argument><expr>(<name>long</name>)<name>fd</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></then></if>
<expr_stmt><expr><call><name>PyErr_Clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"eti|i"</expr></argument>,
<argument><expr><name>Py_FileSystemDefaultEncoding</name></expr></argument>, <argument><expr>&amp;<name>file</name></expr></argument>,
<argument><expr>&amp;<name>flag</name></expr></argument>, <argument><expr>&amp;<name>mode</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<decl_stmt><decl><type><name>Py_BEGIN_ALLOW_THREADS</name></type>
<name>fd</name> <init>= <expr><call><name>open</name><argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><name>flag</name></expr></argument>, <argument><expr><name>mode</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<macro><name>Py_END_ALLOW_THREADS</name></macro>
<if>if <condition>(<expr><name>fd</name> &lt; 0</expr>)</condition><then>
<return>return <expr><call><name>posix_error_with_allocated_filename</name><argument_list>(<argument><expr><name>file</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
<expr_stmt><expr><call><name>PyMem_Free</name><argument_list>(<argument><expr><name>file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>PyInt_FromLong</name><argument_list>(<argument><expr>(<name>long</name>)<name>fd</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>posix_close__doc__</name></expr></argument>,
<argument><expr>"close(fd)\n\n\
Close a file descriptor (for low level IO)."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>posix_close</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>fd</name></decl>, <decl><type ref="prev"/><name>res</name></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"i:close"</expr></argument>, <argument><expr>&amp;<name>fd</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<decl_stmt><decl><type><name>Py_BEGIN_ALLOW_THREADS</name></type>
<name>res</name> <init>= <expr><call><name>close</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<macro><name>Py_END_ALLOW_THREADS</name></macro>
<if>if <condition>(<expr><name>res</name> &lt; 0</expr>)</condition><then>
<return>return <expr><call><name>posix_error</name><argument_list>()</argument_list></call></expr>;</return></then></if>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>Py_None</name></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>posix_closerange__doc__</name></expr></argument>,
<argument><expr>"closerange(fd_low, fd_high)\n\n\
Closes all file descriptors in [fd_low, fd_high), ignoring errors."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>posix_closerange</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>fd_from</name></decl>, <decl><type ref="prev"/><name>fd_to</name></decl>, <decl><type ref="prev"/><name>i</name></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"ii:closerange"</expr></argument>, <argument><expr>&amp;<name>fd_from</name></expr></argument>, <argument><expr>&amp;<name>fd_to</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<macro><name>Py_BEGIN_ALLOW_THREADS</name></macro>
<for>for (<init><expr><name>i</name> = <name>fd_from</name></expr>;</init> <condition><expr><name>i</name> &lt; <name>fd_to</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
<expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></for>
<decl_stmt><decl><type><name>Py_END_ALLOW_THREADS</name></type>
<name>Py_RETURN_NONE</name></decl>;</decl_stmt>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>posix_dup__doc__</name></expr></argument>,
<argument><expr>"dup(fd) -&gt; fd2\n\n\
Return a duplicate of a file descriptor."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>posix_dup</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>fd</name></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"i:dup"</expr></argument>, <argument><expr>&amp;<name>fd</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<decl_stmt><decl><type><name>Py_BEGIN_ALLOW_THREADS</name></type>
<name>fd</name> <init>= <expr><call><name>dup</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<macro><name>Py_END_ALLOW_THREADS</name></macro>
<if>if <condition>(<expr><name>fd</name> &lt; 0</expr>)</condition><then>
<return>return <expr><call><name>posix_error</name><argument_list>()</argument_list></call></expr>;</return></then></if>
<return>return <expr><call><name>PyInt_FromLong</name><argument_list>(<argument><expr>(<name>long</name>)<name>fd</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>posix_dup2__doc__</name></expr></argument>,
<argument><expr>"dup2(old_fd, new_fd)\n\n\
Duplicate file descriptor."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>posix_dup2</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>fd</name></decl>, <decl><type ref="prev"/><name>fd2</name></decl>, <decl><type ref="prev"/><name>res</name></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"ii:dup2"</expr></argument>, <argument><expr>&amp;<name>fd</name></expr></argument>, <argument><expr>&amp;<name>fd2</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<decl_stmt><decl><type><name>Py_BEGIN_ALLOW_THREADS</name></type>
<name>res</name> <init>= <expr><call><name>dup2</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>fd2</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<macro><name>Py_END_ALLOW_THREADS</name></macro>
<if>if <condition>(<expr><name>res</name> &lt; 0</expr>)</condition><then>
<return>return <expr><call><name>posix_error</name><argument_list>()</argument_list></call></expr>;</return></then></if>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>Py_None</name></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>posix_lseek__doc__</name></expr></argument>,
<argument><expr>"lseek(fd, pos, how) -&gt; newpos\n\n\
Set the current position of a file descriptor."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>posix_lseek</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>fd</name></decl>, <decl><type ref="prev"/><name>how</name></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MS_WIN64</name></expr></argument>)</argument_list></call> || <call><name>defined</name><argument_list>(<argument><expr><name>MS_WINDOWS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>PY_LONG_LONG</name></type> <name>pos</name></decl>, <decl><type ref="prev"/><name>res</name></decl>;</decl_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<decl_stmt><decl><type><name>off_t</name></type> <name>pos</name></decl>, <decl><type ref="prev"/><name>res</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>posobj</name></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"iOi:lseek"</expr></argument>, <argument><expr>&amp;<name>fd</name></expr></argument>, <argument><expr>&amp;<name>posobj</name></expr></argument>, <argument><expr>&amp;<name>how</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SEEK_SET</name></expr></argument>)</argument_list></call></expr></cpp:if>
<switch>switch <condition>(<expr><name>how</name></expr>)</condition> <block>{
<case>case <expr>0</expr>:
<expr_stmt><expr><name>how</name> = <name>SEEK_SET</name></expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr>1</expr>:
<expr_stmt><expr><name>how</name> = <name>SEEK_CUR</name></expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr>2</expr>:
<expr_stmt><expr><name>how</name> = <name>SEEK_END</name></expr>;</expr_stmt>
<break>break;</break>
</case>}</block></switch>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>HAVE_LARGEFILE_SUPPORT</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><name>pos</name> = <call><name>PyInt_AsLong</name><argument_list>(<argument><expr><name>posobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<expr_stmt><expr><name>pos</name> = <call><name>PyLong_Check</name><argument_list>(<argument><expr><name>posobj</name></expr></argument>)</argument_list></call> ?
<call><name>PyLong_AsLongLong</name><argument_list>(<argument><expr><name>posobj</name></expr></argument>)</argument_list></call> : <call><name>PyInt_AsLong</name><argument_list>(<argument><expr><name>posobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<if>if <condition>(<expr><call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<decl_stmt><decl><type><name>Py_BEGIN_ALLOW_THREADS</name></type>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MS_WIN64</name></expr></argument>)</argument_list></call> || <call><name>defined</name><argument_list>(<argument><expr><name>MS_WINDOWS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<name>res</name> <init>= <expr><call><name>_lseeki64</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>pos</name></expr></argument>, <argument><expr><name>how</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<expr_stmt><expr><name>res</name> = <call><name>lseek</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>pos</name></expr></argument>, <argument><expr><name>how</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<macro><name>Py_END_ALLOW_THREADS</name></macro>
<if>if <condition>(<expr><name>res</name> &lt; 0</expr>)</condition><then>
<return>return <expr><call><name>posix_error</name><argument_list>()</argument_list></call></expr>;</return></then></if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>HAVE_LARGEFILE_SUPPORT</name></expr></argument>)</argument_list></call></expr></cpp:if>
<return>return <expr><call><name>PyInt_FromLong</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<return>return <expr><call><name>PyLong_FromLongLong</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>posix_read__doc__</name></expr></argument>,
<argument><expr>"read(fd, buffersize) -&gt; string\n\n\
Read a file descriptor."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>posix_read</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>fd</name></decl>, <decl><type ref="prev"/><name>size</name></decl>, <decl><type ref="prev"/><name>n</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>buffer</name></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"ii:read"</expr></argument>, <argument><expr>&amp;<name>fd</name></expr></argument>, <argument><expr>&amp;<name>size</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<if>if <condition>(<expr><name>size</name> &lt; 0</expr>)</condition><then> <block>{
<expr_stmt><expr><name>errno</name> = <name>EINVAL</name></expr>;</expr_stmt>
<return>return <expr><call><name>posix_error</name><argument_list>()</argument_list></call></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>buffer</name> = <call><name>PyString_FromStringAndSize</name><argument_list>(<argument><expr>(<name>char</name> *)<name>NULL</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>buffer</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<decl_stmt><decl><type><name>Py_BEGIN_ALLOW_THREADS</name></type>
<name>n</name> <init>= <expr><call><name>read</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><call><name>PyString_AsString</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<macro><name>Py_END_ALLOW_THREADS</name></macro>
<if>if <condition>(<expr><name>n</name> &lt; 0</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>posix_error</name><argument_list>()</argument_list></call></expr>;</return>
}</block></then></if>
<if>if <condition>(<expr><name>n</name> != <name>size</name></expr>)</condition><then>
<expr_stmt><expr><call><name>_PyString_Resize</name><argument_list>(<argument><expr>&amp;<name>buffer</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<return>return <expr><name>buffer</name></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>posix_write__doc__</name></expr></argument>,
<argument><expr>"write(fd, string) -&gt; byteswritten\n\n\
Write a string to a file descriptor."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>posix_write</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>Py_buffer</name></type> <name>pbuf</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>fd</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>size</name></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"is*:write"</expr></argument>, <argument><expr>&amp;<name>fd</name></expr></argument>, <argument><expr>&amp;<name>pbuf</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<decl_stmt><decl><type><name>Py_BEGIN_ALLOW_THREADS</name></type>
<name>size</name> <init>= <expr><call><name>write</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name><name>pbuf</name>.<name>buf</name></name></expr></argument>, <argument><expr>(<name>size_t</name>)<name><name>pbuf</name>.<name>len</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_END_ALLOW_THREADS</name></type>
<name>PyBuffer_Release</name><argument_list>(<argument><expr>&amp;<name>pbuf</name></expr></argument>)</argument_list></decl>;</decl_stmt>
<if>if <condition>(<expr><name>size</name> &lt; 0</expr>)</condition><then>
<return>return <expr><call><name>posix_error</name><argument_list>()</argument_list></call></expr>;</return></then></if>
<return>return <expr><call><name>PyInt_FromSsize_t</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>posix_fstat__doc__</name></expr></argument>,
<argument><expr>"fstat(fd) -&gt; stat result\n\n\
Like stat(), but for an open file descriptor."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>posix_fstat</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>fd</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>STRUCT_STAT</name></type> <name>st</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>res</name></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"i:fstat"</expr></argument>, <argument><expr>&amp;<name>fd</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__VMS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>fsync</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<decl_stmt><decl><type><name>Py_BEGIN_ALLOW_THREADS</name></type>
<name>res</name> <init>= <expr><call><name>FSTAT</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr>&amp;<name>st</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<macro><name>Py_END_ALLOW_THREADS</name></macro>
<if>if <condition>(<expr><name>res</name> != 0</expr>)</condition><then> <block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MS_WINDOWS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<return>return <expr><call><name>win32_error</name><argument_list>(<argument><expr>"fstat"</expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<return>return <expr><call><name>posix_error</name><argument_list>()</argument_list></call></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></then></if>
<return>return <expr><call><name>_pystat_fromstructstat</name><argument_list>(<argument><expr>&amp;<name>st</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>posix_fdopen__doc__</name></expr></argument>,
<argument><expr>"fdopen(fd [, mode='r' [, bufsize]]) -&gt; file_object\n\n\
Return an open file object connected to a file descriptor."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>posix_fdopen</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>fd</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>orgmode</name> <init>= <expr>"r"</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>bufsize</name> <init>= <expr>-1</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>FILE</name> *</type><name>fp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>f</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>mode</name></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"i|si"</expr></argument>, <argument><expr>&amp;<name>fd</name></expr></argument>, <argument><expr>&amp;<name>orgmode</name></expr></argument>, <argument><expr>&amp;<name>bufsize</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>mode</name> = <call><name>PyMem_MALLOC</name><argument_list>(<argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>orgmode</name></expr></argument>)</argument_list></call>+3</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>mode</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_NoMemory</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>mode</name></expr></argument>, <argument><expr><name>orgmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>_PyFile_SanitizeMode</name><argument_list>(<argument><expr><name>mode</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyMem_FREE</name><argument_list>(<argument><expr><name>mode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<macro><name>Py_BEGIN_ALLOW_THREADS</name></macro>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>MS_WINDOWS</name></expr></argument>)</argument_list></call> &amp;&amp; <call><name>defined</name><argument_list>(<argument><expr><name>HAVE_FCNTL_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if>if <condition>(<expr><name><name>mode</name><index>[<expr>0</expr>]</index></name> == 'a'</expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>flags</name></decl>;</decl_stmt>
<expr_stmt><expr><name>flags</name> = <call><name>fcntl</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>F_GETFL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>flags</name> != -1</expr>)</condition><then>
<expr_stmt><expr><call><name>fcntl</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>F_SETFL</name></expr></argument>, <argument><expr><name>flags</name> | <name>O_APPEND</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<expr_stmt><expr><name>fp</name> = <call><name>fdopen</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>mode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>fp</name> == <name>NULL</name> &amp;&amp; <name>flags</name> != -1</expr>)</condition><then>
<expr_stmt><expr><call><name>fcntl</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>F_SETFL</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
}</block></then> <else>else <block>{
<expr_stmt><expr><name>fp</name> = <call><name>fdopen</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>mode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></else></if>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<expr_stmt><expr><name>fp</name> = <call><name>fdopen</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>mode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<function_decl><type><name>Py_END_ALLOW_THREADS</name></type>
<name>PyMem_FREE</name><parameter_list>(<param><decl><type><name>mode</name></type></decl></param>)</parameter_list>;</function_decl>
<if>if <condition>(<expr><name>fp</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><call><name>posix_error</name><argument_list>()</argument_list></call></expr>;</return></then></if>
<expr_stmt><expr><name>f</name> = <call><name>PyFile_FromFile</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr>"&lt;fdopen&gt;"</expr></argument>, <argument><expr><name>orgmode</name></expr></argument>, <argument><expr><name>fclose</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>f</name> != <name>NULL</name></expr>)</condition><then>
<expr_stmt><expr><call><name>PyFile_SetBufSize</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><name>bufsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<return>return <expr><name>f</name></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>posix_isatty__doc__</name></expr></argument>,
<argument><expr>"isatty(fd) -&gt; bool\n\n\
Return True if the file descriptor 'fd' is an open file descriptor\n\
connected to the slave end of a terminal."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>posix_isatty</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>fd</name></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"i:isatty"</expr></argument>, <argument><expr>&amp;<name>fd</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<return>return <expr><call><name>PyBool_FromLong</name><argument_list>(<argument><expr><call><name>isatty</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_PIPE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>posix_pipe__doc__</name></expr></argument>,
<argument><expr>"pipe() -&gt; (read_end, write_end)\n\n\
Create a pipe."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>posix_pipe</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>noargs</name></decl></param>)</parameter_list> <block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>PYOS_OS2</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>HFILE</name></type> <name>read</name></decl>, <decl><type ref="prev"/><name>write</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>APIRET</name></type> <name>rc</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_BEGIN_ALLOW_THREADS</name></type>
<name>rc</name> <init>= <expr><call><name>DosCreatePipe</name><argument_list>( <argument><expr>&amp;<name>read</name></expr></argument>, <argument><expr>&amp;<name>write</name></expr></argument>, <argument><expr>4096</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<macro><name>Py_END_ALLOW_THREADS</name></macro>
<if>if <condition>(<expr><name>rc</name> != <name>NO_ERROR</name></expr>)</condition><then>
<return>return <expr><call><name>os2_error</name><argument_list>(<argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
<return>return <expr><call><name>Py_BuildValue</name><argument_list>(<argument><expr>"(ii)"</expr></argument>, <argument><expr><name>read</name></expr></argument>, <argument><expr><name>write</name></expr></argument>)</argument_list></call></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>MS_WINDOWS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>int</name></type> <name><name>fds</name><index>[<expr>2</expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>res</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_BEGIN_ALLOW_THREADS</name></type>
<name>res</name> <init>= <expr><call><name>pipe</name><argument_list>(<argument><expr><name>fds</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<macro><name>Py_END_ALLOW_THREADS</name></macro>
<if>if <condition>(<expr><name>res</name> != 0</expr>)</condition><then>
<return>return <expr><call><name>posix_error</name><argument_list>()</argument_list></call></expr>;</return></then></if>
<return>return <expr><call><name>Py_BuildValue</name><argument_list>(<argument><expr>"(ii)"</expr></argument>, <argument><expr><name><name>fds</name><index>[<expr>0</expr>]</index></name></expr></argument>, <argument><expr><name><name>fds</name><index>[<expr>1</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<decl_stmt><decl><type><name>HANDLE</name></type> <name>read</name></decl>, <decl><type ref="prev"/><name>write</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>read_fd</name></decl>, <decl><type ref="prev"/><name>write_fd</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BOOL</name></type> <name>ok</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_BEGIN_ALLOW_THREADS</name></type>
<name>ok</name> <init>= <expr><call><name>CreatePipe</name><argument_list>(<argument><expr>&amp;<name>read</name></expr></argument>, <argument><expr>&amp;<name>write</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<macro><name>Py_END_ALLOW_THREADS</name></macro>
<if>if <condition>(<expr>!<name>ok</name></expr>)</condition><then>
<return>return <expr><call><name>win32_error</name><argument_list>(<argument><expr>"CreatePipe"</expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
<expr_stmt><expr><name>read_fd</name> = <call><name>_open_osfhandle</name><argument_list>(<argument><expr>(<name>Py_intptr_t</name>)<name>read</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>write_fd</name> = <call><name>_open_osfhandle</name><argument_list>(<argument><expr>(<name>Py_intptr_t</name>)<name>write</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>Py_BuildValue</name><argument_list>(<argument><expr>"(ii)"</expr></argument>, <argument><expr><name>read_fd</name></expr></argument>, <argument><expr><name>write_fd</name></expr></argument>)</argument_list></call></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_MKFIFO</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>posix_mkfifo__doc__</name></expr></argument>,
<argument><expr>"mkfifo(filename [, mode=0666])\n\n\
Create a FIFO (a POSIX named pipe)."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>posix_mkfifo</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>char</name> *</type><name>filename</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>mode</name> <init>= <expr>0666</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>res</name></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"s|i:mkfifo"</expr></argument>, <argument><expr>&amp;<name>filename</name></expr></argument>, <argument><expr>&amp;<name>mode</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<decl_stmt><decl><type><name>Py_BEGIN_ALLOW_THREADS</name></type>
<name>res</name> <init>= <expr><call><name>mkfifo</name><argument_list>(<argument><expr><name>filename</name></expr></argument>, <argument><expr><name>mode</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<macro><name>Py_END_ALLOW_THREADS</name></macro>
<if>if <condition>(<expr><name>res</name> &lt; 0</expr>)</condition><then>
<return>return <expr><call><name>posix_error</name><argument_list>()</argument_list></call></expr>;</return></then></if>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>Py_None</name></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_MKNOD</name></expr></argument>)</argument_list></call> &amp;&amp; <call><name>defined</name><argument_list>(<argument><expr><name>HAVE_MAKEDEV</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>posix_mknod__doc__</name></expr></argument>,
<argument><expr>"mknod(filename [, mode=0600, device])\n\n\
Create a filesystem node (file, device special file or named pipe)\n\
named filename. mode specifies both the permissions to use and the\n\
type of node to be created, being combined (bitwise OR) with one of\n\
S_IFREG, S_IFCHR, S_IFBLK, and S_IFIFO. For S_IFCHR and S_IFBLK,\n\
device defines the newly created device special file (probably using\n\
os.makedev()), otherwise it is ignored."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>posix_mknod</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>char</name> *</type><name>filename</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>mode</name> <init>= <expr>0600</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>device</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>res</name></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"s|ii:mknod"</expr></argument>, <argument><expr>&amp;<name>filename</name></expr></argument>, <argument><expr>&amp;<name>mode</name></expr></argument>, <argument><expr>&amp;<name>device</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<decl_stmt><decl><type><name>Py_BEGIN_ALLOW_THREADS</name></type>
<name>res</name> <init>= <expr><call><name>mknod</name><argument_list>(<argument><expr><name>filename</name></expr></argument>, <argument><expr><name>mode</name></expr></argument>, <argument><expr><name>device</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<macro><name>Py_END_ALLOW_THREADS</name></macro>
<if>if <condition>(<expr><name>res</name> &lt; 0</expr>)</condition><then>
<return>return <expr><call><name>posix_error</name><argument_list>()</argument_list></call></expr>;</return></then></if>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>Py_None</name></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_DEVICE_MACROS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>posix_major__doc__</name></expr></argument>,
<argument><expr>"major(device) -&gt; major number\n\
Extracts a device major number from a raw device number."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>posix_major</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>device</name></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"i:major"</expr></argument>, <argument><expr>&amp;<name>device</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<return>return <expr><call><name>PyInt_FromLong</name><argument_list>(<argument><expr>(<name>long</name>)<call><name>major</name><argument_list>(<argument><expr><name>device</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>posix_minor__doc__</name></expr></argument>,
<argument><expr>"minor(device) -&gt; minor number\n\
Extracts a device minor number from a raw device number."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>posix_minor</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>device</name></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"i:minor"</expr></argument>, <argument><expr>&amp;<name>device</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<return>return <expr><call><name>PyInt_FromLong</name><argument_list>(<argument><expr>(<name>long</name>)<call><name>minor</name><argument_list>(<argument><expr><name>device</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>posix_makedev__doc__</name></expr></argument>,
<argument><expr>"makedev(major, minor) -&gt; device number\n\
Composes a raw device number from the major and minor device numbers."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>posix_makedev</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>major</name></decl>, <decl><type ref="prev"/><name>minor</name></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"ii:makedev"</expr></argument>, <argument><expr>&amp;<name>major</name></expr></argument>, <argument><expr>&amp;<name>minor</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<return>return <expr><call><name>PyInt_FromLong</name><argument_list>(<argument><expr>(<name>long</name>)<call><name>makedev</name><argument_list>(<argument><expr><name>major</name></expr></argument>, <argument><expr><name>minor</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_FTRUNCATE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>posix_ftruncate__doc__</name></expr></argument>,
<argument><expr>"ftruncate(fd, length)\n\n\
Truncate a file to a specified length."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>posix_ftruncate</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>fd</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>off_t</name></type> <name>length</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>res</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>lenobj</name></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"iO:ftruncate"</expr></argument>, <argument><expr>&amp;<name>fd</name></expr></argument>, <argument><expr>&amp;<name>lenobj</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>HAVE_LARGEFILE_SUPPORT</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><name>length</name> = <call><name>PyInt_AsLong</name><argument_list>(<argument><expr><name>lenobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<expr_stmt><expr><name>length</name> = <call><name>PyLong_Check</name><argument_list>(<argument><expr><name>lenobj</name></expr></argument>)</argument_list></call> ?
<call><name>PyLong_AsLongLong</name><argument_list>(<argument><expr><name>lenobj</name></expr></argument>)</argument_list></call> : <call><name>PyInt_AsLong</name><argument_list>(<argument><expr><name>lenobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<if>if <condition>(<expr><call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<decl_stmt><decl><type><name>Py_BEGIN_ALLOW_THREADS</name></type>
<name>res</name> <init>= <expr><call><name>ftruncate</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>length</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<macro><name>Py_END_ALLOW_THREADS</name></macro>
<if>if <condition>(<expr><name>res</name> &lt; 0</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetFromErrno</name><argument_list>(<argument><expr><name>PyExc_IOError</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>Py_None</name></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_PUTENV</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>posix_putenv__doc__</name></expr></argument>,
<argument><expr>"putenv(key, value)\n\n\
Change or add an environment variable."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>PyObject</name> *</type><name>posix_putenv_garbage</name></decl>;</decl_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>posix_putenv</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>char</name> *</type><name>s1</name></decl>, *<decl><type ref="prev"/><name>s2</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>newenv</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>newstr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>len</name></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"ss:putenv"</expr></argument>, <argument><expr>&amp;<name>s1</name></expr></argument>, <argument><expr>&amp;<name>s2</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>PYOS_OS2</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if>if <condition>(<expr><call><name>stricmp</name><argument_list>(<argument><expr><name>s1</name></expr></argument>, <argument><expr>"BEGINLIBPATH"</expr></argument>)</argument_list></call> == 0</expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>APIRET</name></type> <name>rc</name></decl>;</decl_stmt>
<expr_stmt><expr><name>rc</name> = <call><name>DosSetExtLIBPATH</name><argument_list>(<argument><expr><name>s2</name></expr></argument>, <argument><expr><name>BEGIN_LIBPATH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>rc</name> != <name>NO_ERROR</name></expr>)</condition><then>
<return>return <expr><call><name>os2_error</name><argument_list>(<argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
}</block></then> <else>else <if>if <condition>(<expr><call><name>stricmp</name><argument_list>(<argument><expr><name>s1</name></expr></argument>, <argument><expr>"ENDLIBPATH"</expr></argument>)</argument_list></call> == 0</expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>APIRET</name></type> <name>rc</name></decl>;</decl_stmt>
<expr_stmt><expr><name>rc</name> = <call><name>DosSetExtLIBPATH</name><argument_list>(<argument><expr><name>s2</name></expr></argument>, <argument><expr><name>END_LIBPATH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>rc</name> != <name>NO_ERROR</name></expr>)</condition><then>
<return>return <expr><call><name>os2_error</name><argument_list>(<argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
}</block></then> <else>else <block>{
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><name>len</name> = <call><name>strlen</name><argument_list>(<argument><expr><name>s1</name></expr></argument>)</argument_list></call> + <call><name>strlen</name><argument_list>(<argument><expr><name>s2</name></expr></argument>)</argument_list></call> + 2</expr>;</expr_stmt>
<expr_stmt><expr><name>newstr</name> = <call><name>PyString_FromStringAndSize</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr>(<name>int</name>)<name>len</name> - 1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>newstr</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><call><name>PyErr_NoMemory</name><argument_list>()</argument_list></call></expr>;</return></then></if>
<expr_stmt><expr><name>newenv</name> = <call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>newstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyOS_snprintf</name><argument_list>(<argument><expr><name>newenv</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr>"%s=%s"</expr></argument>, <argument><expr><name>s1</name></expr></argument>, <argument><expr><name>s2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>putenv</name><argument_list>(<argument><expr><name>newenv</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>newstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>posix_error</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<if>if <condition>(<expr><call><name>PyDict_SetItem</name><argument_list>(<argument><expr><name>posix_putenv_garbage</name></expr></argument>,
<argument><expr><call><name>PyTuple_GET_ITEM</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>newstr</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_Clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>newstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></else></if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>PYOS_OS2</name></expr></argument>)</argument_list></call></expr></cpp:if>
}</block></else></if></else></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>Py_None</name></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_UNSETENV</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>posix_unsetenv__doc__</name></expr></argument>,
<argument><expr>"unsetenv(key)\n\n\
Delete an environment variable."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>posix_unsetenv</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>char</name> *</type><name>s1</name></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"s:unsetenv"</expr></argument>, <argument><expr>&amp;<name>s1</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><call><name>unsetenv</name><argument_list>(<argument><expr><name>s1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>PyDict_DelItem</name><argument_list>(<argument><expr><name>posix_putenv_garbage</name></expr></argument>,
<argument><expr><call><name>PyTuple_GET_ITEM</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_Clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>Py_None</name></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>posix_strerror__doc__</name></expr></argument>,
<argument><expr>"strerror(code) -&gt; string\n\n\
Translate an error code to a message string."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>posix_strerror</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>code</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>message</name></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"i:strerror"</expr></argument>, <argument><expr>&amp;<name>code</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>message</name> = <call><name>strerror</name><argument_list>(<argument><expr><name>code</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>message</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>,
<argument><expr>"strerror() argument out of range"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<return>return <expr><call><name>PyString_FromString</name><argument_list>(<argument><expr><name>message</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_SYS_WAIT_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>WCOREDUMP</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>posix_WCOREDUMP__doc__</name></expr></argument>,
<argument><expr>"WCOREDUMP(status) -&gt; bool\n\n\
Return True if the process returning 'status' was dumped to a core file."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>posix_WCOREDUMP</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>WAIT_TYPE</name></type> <name>status</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>WAIT_STATUS_INT</name><argument_list>(<argument><expr><name>status</name></expr></argument>)</argument_list></call> = 0</expr>;</expr_stmt>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"i:WCOREDUMP"</expr></argument>, <argument><expr>&amp;<call><name>WAIT_STATUS_INT</name><argument_list>(<argument><expr><name>status</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<return>return <expr><call><name>PyBool_FromLong</name><argument_list>(<argument><expr><call><name>WCOREDUMP</name><argument_list>(<argument><expr><name>status</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>WIFCONTINUED</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>posix_WIFCONTINUED__doc__</name></expr></argument>,
<argument><expr>"WIFCONTINUED(status) -&gt; bool\n\n\
Return True if the process returning 'status' was continued from a\n\
job control stop."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>posix_WIFCONTINUED</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>WAIT_TYPE</name></type> <name>status</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>WAIT_STATUS_INT</name><argument_list>(<argument><expr><name>status</name></expr></argument>)</argument_list></call> = 0</expr>;</expr_stmt>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"i:WCONTINUED"</expr></argument>, <argument><expr>&amp;<call><name>WAIT_STATUS_INT</name><argument_list>(<argument><expr><name>status</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<return>return <expr><call><name>PyBool_FromLong</name><argument_list>(<argument><expr><call><name>WIFCONTINUED</name><argument_list>(<argument><expr><name>status</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>WIFSTOPPED</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>posix_WIFSTOPPED__doc__</name></expr></argument>,
<argument><expr>"WIFSTOPPED(status) -&gt; bool\n\n\
Return True if the process returning 'status' was stopped."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>posix_WIFSTOPPED</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>WAIT_TYPE</name></type> <name>status</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>WAIT_STATUS_INT</name><argument_list>(<argument><expr><name>status</name></expr></argument>)</argument_list></call> = 0</expr>;</expr_stmt>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"i:WIFSTOPPED"</expr></argument>, <argument><expr>&amp;<call><name>WAIT_STATUS_INT</name><argument_list>(<argument><expr><name>status</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<return>return <expr><call><name>PyBool_FromLong</name><argument_list>(<argument><expr><call><name>WIFSTOPPED</name><argument_list>(<argument><expr><name>status</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>WIFSIGNALED</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>posix_WIFSIGNALED__doc__</name></expr></argument>,
<argument><expr>"WIFSIGNALED(status) -&gt; bool\n\n\
Return True if the process returning 'status' was terminated by a signal."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>posix_WIFSIGNALED</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>WAIT_TYPE</name></type> <name>status</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>WAIT_STATUS_INT</name><argument_list>(<argument><expr><name>status</name></expr></argument>)</argument_list></call> = 0</expr>;</expr_stmt>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"i:WIFSIGNALED"</expr></argument>, <argument><expr>&amp;<call><name>WAIT_STATUS_INT</name><argument_list>(<argument><expr><name>status</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<return>return <expr><call><name>PyBool_FromLong</name><argument_list>(<argument><expr><call><name>WIFSIGNALED</name><argument_list>(<argument><expr><name>status</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>WIFEXITED</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>posix_WIFEXITED__doc__</name></expr></argument>,
<argument><expr>"WIFEXITED(status) -&gt; bool\n\n\
Return true if the process returning 'status' exited using the exit()\n\
system call."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>posix_WIFEXITED</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>WAIT_TYPE</name></type> <name>status</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>WAIT_STATUS_INT</name><argument_list>(<argument><expr><name>status</name></expr></argument>)</argument_list></call> = 0</expr>;</expr_stmt>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"i:WIFEXITED"</expr></argument>, <argument><expr>&amp;<call><name>WAIT_STATUS_INT</name><argument_list>(<argument><expr><name>status</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<return>return <expr><call><name>PyBool_FromLong</name><argument_list>(<argument><expr><call><name>WIFEXITED</name><argument_list>(<argument><expr><name>status</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>WEXITSTATUS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>posix_WEXITSTATUS__doc__</name></expr></argument>,
<argument><expr>"WEXITSTATUS(status) -&gt; integer\n\n\
Return the process return code from 'status'."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>posix_WEXITSTATUS</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>WAIT_TYPE</name></type> <name>status</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>WAIT_STATUS_INT</name><argument_list>(<argument><expr><name>status</name></expr></argument>)</argument_list></call> = 0</expr>;</expr_stmt>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"i:WEXITSTATUS"</expr></argument>, <argument><expr>&amp;<call><name>WAIT_STATUS_INT</name><argument_list>(<argument><expr><name>status</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<return>return <expr><call><name>Py_BuildValue</name><argument_list>(<argument><expr>"i"</expr></argument>, <argument><expr><call><name>WEXITSTATUS</name><argument_list>(<argument><expr><name>status</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>WTERMSIG</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>posix_WTERMSIG__doc__</name></expr></argument>,
<argument><expr>"WTERMSIG(status) -&gt; integer\n\n\
Return the signal that terminated the process that provided the 'status'\n\
value."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>posix_WTERMSIG</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>WAIT_TYPE</name></type> <name>status</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>WAIT_STATUS_INT</name><argument_list>(<argument><expr><name>status</name></expr></argument>)</argument_list></call> = 0</expr>;</expr_stmt>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"i:WTERMSIG"</expr></argument>, <argument><expr>&amp;<call><name>WAIT_STATUS_INT</name><argument_list>(<argument><expr><name>status</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<return>return <expr><call><name>Py_BuildValue</name><argument_list>(<argument><expr>"i"</expr></argument>, <argument><expr><call><name>WTERMSIG</name><argument_list>(<argument><expr><name>status</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>WSTOPSIG</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>posix_WSTOPSIG__doc__</name></expr></argument>,
<argument><expr>"WSTOPSIG(status) -&gt; integer\n\n\
Return the signal that stopped the process that provided\n\
the 'status' value."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>posix_WSTOPSIG</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>WAIT_TYPE</name></type> <name>status</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>WAIT_STATUS_INT</name><argument_list>(<argument><expr><name>status</name></expr></argument>)</argument_list></call> = 0</expr>;</expr_stmt>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"i:WSTOPSIG"</expr></argument>, <argument><expr>&amp;<call><name>WAIT_STATUS_INT</name><argument_list>(<argument><expr><name>status</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<return>return <expr><call><name>Py_BuildValue</name><argument_list>(<argument><expr>"i"</expr></argument>, <argument><expr><call><name>WSTOPSIG</name><argument_list>(<argument><expr><name>status</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_FSTATVFS</name></expr></argument>)</argument_list></call> &amp;&amp; <call><name>defined</name><argument_list>(<argument><expr><name>HAVE_SYS_STATVFS_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_SCO_DS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>_SVID3</name></cpp:macro></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/statvfs.h&gt;</cpp:file></cpp:include>
<function><type><specifier>static</specifier> <name>PyObject</name>*</type>
<name>_pystatvfs_fromstructstatvfs</name><parameter_list>(<param><decl><type>struct <name>statvfs</name></type> <name>st</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>v</name> <init>= <expr><call><name>PyStructSequence_New</name><argument_list>(<argument><expr>&amp;<name>StatVFSResultType</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>v</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>HAVE_LARGEFILE_SUPPORT</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyStructSequence_SET_ITEM</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><call><name>PyInt_FromLong</name><argument_list>(<argument><expr>(<name>long</name>) <name><name>st</name>.<name>f_bsize</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyStructSequence_SET_ITEM</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr>1</expr></argument>, <argument><expr><call><name>PyInt_FromLong</name><argument_list>(<argument><expr>(<name>long</name>) <name><name>st</name>.<name>f_frsize</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyStructSequence_SET_ITEM</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr>2</expr></argument>, <argument><expr><call><name>PyInt_FromLong</name><argument_list>(<argument><expr>(<name>long</name>) <name><name>st</name>.<name>f_blocks</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyStructSequence_SET_ITEM</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr>3</expr></argument>, <argument><expr><call><name>PyInt_FromLong</name><argument_list>(<argument><expr>(<name>long</name>) <name><name>st</name>.<name>f_bfree</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyStructSequence_SET_ITEM</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr>4</expr></argument>, <argument><expr><call><name>PyInt_FromLong</name><argument_list>(<argument><expr>(<name>long</name>) <name><name>st</name>.<name>f_bavail</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyStructSequence_SET_ITEM</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr>5</expr></argument>, <argument><expr><call><name>PyInt_FromLong</name><argument_list>(<argument><expr>(<name>long</name>) <name><name>st</name>.<name>f_files</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyStructSequence_SET_ITEM</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr>6</expr></argument>, <argument><expr><call><name>PyInt_FromLong</name><argument_list>(<argument><expr>(<name>long</name>) <name><name>st</name>.<name>f_ffree</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyStructSequence_SET_ITEM</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr>7</expr></argument>, <argument><expr><call><name>PyInt_FromLong</name><argument_list>(<argument><expr>(<name>long</name>) <name><name>st</name>.<name>f_favail</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyStructSequence_SET_ITEM</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr>8</expr></argument>, <argument><expr><call><name>PyInt_FromLong</name><argument_list>(<argument><expr>(<name>long</name>) <name><name>st</name>.<name>f_flag</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyStructSequence_SET_ITEM</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr>9</expr></argument>, <argument><expr><call><name>PyInt_FromLong</name><argument_list>(<argument><expr>(<name>long</name>) <name><name>st</name>.<name>f_namemax</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<expr_stmt><expr><call><name>PyStructSequence_SET_ITEM</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><call><name>PyInt_FromLong</name><argument_list>(<argument><expr>(<name>long</name>) <name><name>st</name>.<name>f_bsize</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyStructSequence_SET_ITEM</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr>1</expr></argument>, <argument><expr><call><name>PyInt_FromLong</name><argument_list>(<argument><expr>(<name>long</name>) <name><name>st</name>.<name>f_frsize</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyStructSequence_SET_ITEM</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr>2</expr></argument>,
<argument><expr><call><name>PyLong_FromLongLong</name><argument_list>(<argument><expr>(<name>PY_LONG_LONG</name>) <name><name>st</name>.<name>f_blocks</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyStructSequence_SET_ITEM</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr>3</expr></argument>,
<argument><expr><call><name>PyLong_FromLongLong</name><argument_list>(<argument><expr>(<name>PY_LONG_LONG</name>) <name><name>st</name>.<name>f_bfree</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyStructSequence_SET_ITEM</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr>4</expr></argument>,
<argument><expr><call><name>PyLong_FromLongLong</name><argument_list>(<argument><expr>(<name>PY_LONG_LONG</name>) <name><name>st</name>.<name>f_bavail</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyStructSequence_SET_ITEM</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr>5</expr></argument>,
<argument><expr><call><name>PyLong_FromLongLong</name><argument_list>(<argument><expr>(<name>PY_LONG_LONG</name>) <name><name>st</name>.<name>f_files</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyStructSequence_SET_ITEM</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr>6</expr></argument>,
<argument><expr><call><name>PyLong_FromLongLong</name><argument_list>(<argument><expr>(<name>PY_LONG_LONG</name>) <name><name>st</name>.<name>f_ffree</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyStructSequence_SET_ITEM</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr>7</expr></argument>,
<argument><expr><call><name>PyLong_FromLongLong</name><argument_list>(<argument><expr>(<name>PY_LONG_LONG</name>) <name><name>st</name>.<name>f_favail</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyStructSequence_SET_ITEM</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr>8</expr></argument>, <argument><expr><call><name>PyInt_FromLong</name><argument_list>(<argument><expr>(<name>long</name>) <name><name>st</name>.<name>f_flag</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyStructSequence_SET_ITEM</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr>9</expr></argument>, <argument><expr><call><name>PyInt_FromLong</name><argument_list>(<argument><expr>(<name>long</name>) <name><name>st</name>.<name>f_namemax</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<return>return <expr><name>v</name></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>posix_fstatvfs__doc__</name></expr></argument>,
<argument><expr>"fstatvfs(fd) -&gt; statvfs result\n\n\
Perform an fstatvfs system call on the given fd."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>posix_fstatvfs</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>fd</name></decl>, <decl><type ref="prev"/><name>res</name></decl>;</decl_stmt>
<decl_stmt><decl><type>struct <name>statvfs</name></type> <name>st</name></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"i:fstatvfs"</expr></argument>, <argument><expr>&amp;<name>fd</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<decl_stmt><decl><type><name>Py_BEGIN_ALLOW_THREADS</name></type>
<name>res</name> <init>= <expr><call><name>fstatvfs</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr>&amp;<name>st</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<macro><name>Py_END_ALLOW_THREADS</name></macro>
<if>if <condition>(<expr><name>res</name> != 0</expr>)</condition><then>
<return>return <expr><call><name>posix_error</name><argument_list>()</argument_list></call></expr>;</return></then></if>
<return>return <expr><call><name>_pystatvfs_fromstructstatvfs</name><argument_list>(<argument><expr><name>st</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_STATVFS</name></expr></argument>)</argument_list></call> &amp;&amp; <call><name>defined</name><argument_list>(<argument><expr><name>HAVE_SYS_STATVFS_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/statvfs.h&gt;</cpp:file></cpp:include>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>posix_statvfs__doc__</name></expr></argument>,
<argument><expr>"statvfs(path) -&gt; statvfs result\n\n\
Perform a statvfs system call on the given path."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>posix_statvfs</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>char</name> *</type><name>path</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>res</name></decl>;</decl_stmt>
<decl_stmt><decl><type>struct <name>statvfs</name></type> <name>st</name></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"s:statvfs"</expr></argument>, <argument><expr>&amp;<name>path</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<decl_stmt><decl><type><name>Py_BEGIN_ALLOW_THREADS</name></type>
<name>res</name> <init>= <expr><call><name>statvfs</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr>&amp;<name>st</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<macro><name>Py_END_ALLOW_THREADS</name></macro>
<if>if <condition>(<expr><name>res</name> != 0</expr>)</condition><then>
<return>return <expr><call><name>posix_error_with_filename</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
<return>return <expr><call><name>_pystatvfs_fromstructstatvfs</name><argument_list>(<argument><expr><name>st</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_TEMPNAM</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>posix_tempnam__doc__</name></expr></argument>,
<argument><expr>"tempnam([dir[, prefix]]) -&gt; string\n\n\
Return a unique name for a temporary file.\n\
The directory and a prefix may be specified as strings; they may be omitted\n\
or None if not needed."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>posix_tempnam</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>result</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>dir</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>pfx</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>name</name></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"|zz:tempnam"</expr></argument>, <argument><expr>&amp;<name>dir</name></expr></argument>, <argument><expr>&amp;<name>pfx</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<if>if <condition>(<expr><call><name>PyErr_Warn</name><argument_list>(<argument><expr><name>PyExc_RuntimeWarning</name></expr></argument>,
<argument><expr>"tempnam is a potential security risk to your program"</expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MS_WINDOWS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><name>name</name> = <call><name>_tempnam</name><argument_list>(<argument><expr><name>dir</name></expr></argument>, <argument><expr><name>pfx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<expr_stmt><expr><name>name</name> = <call><name>tempnam</name><argument_list>(<argument><expr><name>dir</name></expr></argument>, <argument><expr><name>pfx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<if>if <condition>(<expr><name>name</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><call><name>PyErr_NoMemory</name><argument_list>()</argument_list></call></expr>;</return></then></if>
<expr_stmt><expr><name>result</name> = <call><name>PyString_FromString</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>result</name></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_TMPFILE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>posix_tmpfile__doc__</name></expr></argument>,
<argument><expr>"tmpfile() -&gt; file object\n\n\
Create a temporary file with no directory entries."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>posix_tmpfile</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>noargs</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>FILE</name> *</type><name>fp</name></decl>;</decl_stmt>
<expr_stmt><expr><name>fp</name> = <call><name>tmpfile</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>fp</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><call><name>posix_error</name><argument_list>()</argument_list></call></expr>;</return></then></if>
<return>return <expr><call><name>PyFile_FromFile</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr>"&lt;tmpfile&gt;"</expr></argument>, <argument><expr>"w+b"</expr></argument>, <argument><expr><name>fclose</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_TMPNAM</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>posix_tmpnam__doc__</name></expr></argument>,
<argument><expr>"tmpnam() -&gt; string\n\n\
Return a unique name for a temporary file."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>posix_tmpnam</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>noargs</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>char</name></type> <name><name>buffer</name><index>[<expr><name>L_tmpnam</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>name</name></decl>;</decl_stmt>
<if>if <condition>(<expr><call><name>PyErr_Warn</name><argument_list>(<argument><expr><name>PyExc_RuntimeWarning</name></expr></argument>,
<argument><expr>"tmpnam is a potential security risk to your program"</expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>USE_TMPNAM_R</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><name>name</name> = <call><name>tmpnam_r</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<expr_stmt><expr><name>name</name> = <call><name>tmpnam</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<if>if <condition>(<expr><name>name</name> == <name>NULL</name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>err</name> <init>= <expr><call><name>Py_BuildValue</name><argument_list>(<argument><expr>"is"</expr></argument>, <argument><expr>0</expr></argument>,
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>USE_TMPNAM_R</name></expr></argument>)</argument_list></call></expr></cpp:if>
<argument><expr>"unexpected NULL from tmpnam_r"
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
"unexpected NULL from tmpnam"</expr></argument>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>PyErr_SetObject</name><argument_list>(<argument><expr><name>PyExc_OSError</name></expr></argument>, <argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<return>return <expr><call><name>PyString_FromString</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<struct>struct <name>constdef</name> <block>{
<decl_stmt><decl><type><name>char</name> *</type><name>name</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>long</name></type> <name>value</name></decl>;</decl_stmt>
}</block>;</struct>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>conv_confname</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>arg</name></decl></param>, <param><decl><type><name>int</name> *</type><name>valuep</name></decl></param>, <param><decl><type>struct <name>constdef</name> *</type><name>table</name></decl></param>,
<param><decl><type><name>size_t</name></type> <name>tablesize</name></decl></param>)</parameter_list> <block>{
<if>if <condition>(<expr><call><name>PyInt_Check</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr>*<name>valuep</name> = <call><name>PyInt_AS_LONG</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>1</expr>;</return>
}</block></then></if>
<if>if <condition>(<expr><call><name>PyString_Check</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>size_t</name></type> <name>lo</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>mid</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>hi</name> <init>= <expr><name>tablesize</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>cmp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>confname</name> <init>= <expr><call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<while>while <condition>(<expr><name>lo</name> &lt; <name>hi</name></expr>)</condition> <block>{
<expr_stmt><expr><name>mid</name> = (<name>lo</name> + <name>hi</name>) / 2</expr>;</expr_stmt>
<expr_stmt><expr><name>cmp</name> = <call><name>strcmp</name><argument_list>(<argument><expr><name>confname</name></expr></argument>, <argument><expr><name><name>table</name><index>[<expr><name>mid</name></expr>]</index></name>.<name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>cmp</name> &lt; 0</expr>)</condition><then>
<expr_stmt><expr><name>hi</name> = <name>mid</name></expr>;</expr_stmt></then>
<else>else <if>if <condition>(<expr><name>cmp</name> &gt; 0</expr>)</condition><then>
<expr_stmt><expr><name>lo</name> = <name>mid</name> + 1</expr>;</expr_stmt></then>
<else>else <block>{
<expr_stmt><expr>*<name>valuep</name> = <name><name>table</name><index>[<expr><name>mid</name></expr>]</index></name>.<name>value</name></expr>;</expr_stmt>
<return>return <expr>1</expr>;</return>
}</block></else></if></else></if>
}</block></while>
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>, <argument><expr>"unrecognized configuration name"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
<argument><expr>"configuration names must be strings or integers"</expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
<return>return <expr>0</expr>;</return>
}</block></function>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_FPATHCONF</name></expr></argument>)</argument_list></call> || <call><name>defined</name><argument_list>(<argument><expr><name>HAVE_PATHCONF</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><specifier>static</specifier> struct <name>constdef</name></type> <name><name>posix_constants_pathconf</name><index>[]</index></name> <init>= <expr><block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_PC_ABI_AIO_XFER_MAX</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"PC_ABI_AIO_XFER_MAX"</expr>, <expr><name>_PC_ABI_AIO_XFER_MAX</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_PC_ABI_ASYNC_IO</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"PC_ABI_ASYNC_IO"</expr>, <expr><name>_PC_ABI_ASYNC_IO</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_PC_ASYNC_IO</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"PC_ASYNC_IO"</expr>, <expr><name>_PC_ASYNC_IO</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_PC_CHOWN_RESTRICTED</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"PC_CHOWN_RESTRICTED"</expr>, <expr><name>_PC_CHOWN_RESTRICTED</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_PC_FILESIZEBITS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"PC_FILESIZEBITS"</expr>, <expr><name>_PC_FILESIZEBITS</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_PC_LAST</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"PC_LAST"</expr>, <expr><name>_PC_LAST</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_PC_LINK_MAX</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"PC_LINK_MAX"</expr>, <expr><name>_PC_LINK_MAX</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_PC_MAX_CANON</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"PC_MAX_CANON"</expr>, <expr><name>_PC_MAX_CANON</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_PC_MAX_INPUT</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"PC_MAX_INPUT"</expr>, <expr><name>_PC_MAX_INPUT</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_PC_NAME_MAX</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"PC_NAME_MAX"</expr>, <expr><name>_PC_NAME_MAX</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_PC_NO_TRUNC</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"PC_NO_TRUNC"</expr>, <expr><name>_PC_NO_TRUNC</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_PC_PATH_MAX</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"PC_PATH_MAX"</expr>, <expr><name>_PC_PATH_MAX</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_PC_PIPE_BUF</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"PC_PIPE_BUF"</expr>, <expr><name>_PC_PIPE_BUF</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_PC_PRIO_IO</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"PC_PRIO_IO"</expr>, <expr><name>_PC_PRIO_IO</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_PC_SOCK_MAXBUF</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"PC_SOCK_MAXBUF"</expr>, <expr><name>_PC_SOCK_MAXBUF</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_PC_SYNC_IO</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"PC_SYNC_IO"</expr>, <expr><name>_PC_SYNC_IO</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_PC_VDISABLE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"PC_VDISABLE"</expr>, <expr><name>_PC_VDISABLE</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></expr></init></decl>;</decl_stmt>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>conv_path_confname</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>arg</name></decl></param>, <param><decl><type><name>int</name> *</type><name>valuep</name></decl></param>)</parameter_list> <block>{
<return>return <expr><call><name>conv_confname</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><name>valuep</name></expr></argument>, <argument><expr><name>posix_constants_pathconf</name></expr></argument>,
<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>posix_constants_pathconf</name></expr></argument>)</argument_list></sizeof>
/ <sizeof>sizeof<argument_list>(<argument>struct <expr><name>constdef</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_FPATHCONF</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>posix_fpathconf__doc__</name></expr></argument>,
<argument><expr>"fpathconf(fd, name) -&gt; integer\n\n\
Return the configuration limit name for the file descriptor fd.\n\
If there is no limit, return -1."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>posix_fpathconf</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>result</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>name</name></decl>, <decl><type ref="prev"/><name>fd</name></decl>;</decl_stmt>
<if>if <condition>(<expr><call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"iO&amp;:fpathconf"</expr></argument>, <argument><expr>&amp;<name>fd</name></expr></argument>,
<argument><expr><name>conv_path_confname</name></expr></argument>, <argument><expr>&amp;<name>name</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>long</name></type> <name>limit</name></decl>;</decl_stmt>
<expr_stmt><expr><name>errno</name> = 0</expr>;</expr_stmt>
<expr_stmt><expr><name>limit</name> = <call><name>fpathconf</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>limit</name> == -1 &amp;&amp; <name>errno</name> != 0</expr>)</condition><then>
<expr_stmt><expr><call><name>posix_error</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then>
<else>else
<expr_stmt><expr><name>result</name> = <call><name>PyInt_FromLong</name><argument_list>(<argument><expr><name>limit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
}</block></then></if>
<return>return <expr><name>result</name></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_PATHCONF</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>posix_pathconf__doc__</name></expr></argument>,
<argument><expr>"pathconf(path, name) -&gt; integer\n\n\
Return the configuration limit name for the file or directory path.\n\
If there is no limit, return -1."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>posix_pathconf</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>result</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>name</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>path</name></decl>;</decl_stmt>
<if>if <condition>(<expr><call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"sO&amp;:pathconf"</expr></argument>, <argument><expr>&amp;<name>path</name></expr></argument>,
<argument><expr><name>conv_path_confname</name></expr></argument>, <argument><expr>&amp;<name>name</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>long</name></type> <name>limit</name></decl>;</decl_stmt>
<expr_stmt><expr><name>errno</name> = 0</expr>;</expr_stmt>
<expr_stmt><expr><name>limit</name> = <call><name>pathconf</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>limit</name> == -1 &amp;&amp; <name>errno</name> != 0</expr>)</condition><then> <block>{
<if>if <condition>(<expr><name>errno</name> == <name>EINVAL</name></expr>)</condition><then>
<expr_stmt><expr><call><name>posix_error</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then>
<else>else
<expr_stmt><expr><call><name>posix_error_with_filename</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
}</block></then> <else>else
<expr_stmt><expr><name>result</name> = <call><name>PyInt_FromLong</name><argument_list>(<argument><expr><name>limit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
}</block></then></if>
<return>return <expr><name>result</name></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_CONFSTR</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><specifier>static</specifier> struct <name>constdef</name></type> <name><name>posix_constants_confstr</name><index>[]</index></name> <init>= <expr><block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_CS_ARCHITECTURE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"CS_ARCHITECTURE"</expr>, <expr><name>_CS_ARCHITECTURE</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_CS_HOSTNAME</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"CS_HOSTNAME"</expr>, <expr><name>_CS_HOSTNAME</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_CS_HW_PROVIDER</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"CS_HW_PROVIDER"</expr>, <expr><name>_CS_HW_PROVIDER</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_CS_HW_SERIAL</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"CS_HW_SERIAL"</expr>, <expr><name>_CS_HW_SERIAL</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_CS_INITTAB_NAME</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"CS_INITTAB_NAME"</expr>, <expr><name>_CS_INITTAB_NAME</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_CS_LFS64_CFLAGS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"CS_LFS64_CFLAGS"</expr>, <expr><name>_CS_LFS64_CFLAGS</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_CS_LFS64_LDFLAGS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"CS_LFS64_LDFLAGS"</expr>, <expr><name>_CS_LFS64_LDFLAGS</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_CS_LFS64_LIBS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"CS_LFS64_LIBS"</expr>, <expr><name>_CS_LFS64_LIBS</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_CS_LFS64_LINTFLAGS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"CS_LFS64_LINTFLAGS"</expr>, <expr><name>_CS_LFS64_LINTFLAGS</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_CS_LFS_CFLAGS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"CS_LFS_CFLAGS"</expr>, <expr><name>_CS_LFS_CFLAGS</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_CS_LFS_LDFLAGS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"CS_LFS_LDFLAGS"</expr>, <expr><name>_CS_LFS_LDFLAGS</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_CS_LFS_LIBS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"CS_LFS_LIBS"</expr>, <expr><name>_CS_LFS_LIBS</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_CS_LFS_LINTFLAGS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"CS_LFS_LINTFLAGS"</expr>, <expr><name>_CS_LFS_LINTFLAGS</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_CS_MACHINE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"CS_MACHINE"</expr>, <expr><name>_CS_MACHINE</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_CS_PATH</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"CS_PATH"</expr>, <expr><name>_CS_PATH</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_CS_RELEASE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"CS_RELEASE"</expr>, <expr><name>_CS_RELEASE</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_CS_SRPC_DOMAIN</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"CS_SRPC_DOMAIN"</expr>, <expr><name>_CS_SRPC_DOMAIN</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_CS_SYSNAME</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"CS_SYSNAME"</expr>, <expr><name>_CS_SYSNAME</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_CS_VERSION</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"CS_VERSION"</expr>, <expr><name>_CS_VERSION</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_CS_XBS5_ILP32_OFF32_CFLAGS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"CS_XBS5_ILP32_OFF32_CFLAGS"</expr>, <expr><name>_CS_XBS5_ILP32_OFF32_CFLAGS</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_CS_XBS5_ILP32_OFF32_LDFLAGS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"CS_XBS5_ILP32_OFF32_LDFLAGS"</expr>, <expr><name>_CS_XBS5_ILP32_OFF32_LDFLAGS</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_CS_XBS5_ILP32_OFF32_LIBS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"CS_XBS5_ILP32_OFF32_LIBS"</expr>, <expr><name>_CS_XBS5_ILP32_OFF32_LIBS</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_CS_XBS5_ILP32_OFF32_LINTFLAGS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"CS_XBS5_ILP32_OFF32_LINTFLAGS"</expr>, <expr><name>_CS_XBS5_ILP32_OFF32_LINTFLAGS</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_CS_XBS5_ILP32_OFFBIG_CFLAGS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"CS_XBS5_ILP32_OFFBIG_CFLAGS"</expr>, <expr><name>_CS_XBS5_ILP32_OFFBIG_CFLAGS</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_CS_XBS5_ILP32_OFFBIG_LDFLAGS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"CS_XBS5_ILP32_OFFBIG_LDFLAGS"</expr>, <expr><name>_CS_XBS5_ILP32_OFFBIG_LDFLAGS</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_CS_XBS5_ILP32_OFFBIG_LIBS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"CS_XBS5_ILP32_OFFBIG_LIBS"</expr>, <expr><name>_CS_XBS5_ILP32_OFFBIG_LIBS</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_CS_XBS5_ILP32_OFFBIG_LINTFLAGS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"CS_XBS5_ILP32_OFFBIG_LINTFLAGS"</expr>, <expr><name>_CS_XBS5_ILP32_OFFBIG_LINTFLAGS</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_CS_XBS5_LP64_OFF64_CFLAGS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"CS_XBS5_LP64_OFF64_CFLAGS"</expr>, <expr><name>_CS_XBS5_LP64_OFF64_CFLAGS</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_CS_XBS5_LP64_OFF64_LDFLAGS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"CS_XBS5_LP64_OFF64_LDFLAGS"</expr>, <expr><name>_CS_XBS5_LP64_OFF64_LDFLAGS</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_CS_XBS5_LP64_OFF64_LIBS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"CS_XBS5_LP64_OFF64_LIBS"</expr>, <expr><name>_CS_XBS5_LP64_OFF64_LIBS</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_CS_XBS5_LP64_OFF64_LINTFLAGS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"CS_XBS5_LP64_OFF64_LINTFLAGS"</expr>, <expr><name>_CS_XBS5_LP64_OFF64_LINTFLAGS</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_CS_XBS5_LPBIG_OFFBIG_CFLAGS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"CS_XBS5_LPBIG_OFFBIG_CFLAGS"</expr>, <expr><name>_CS_XBS5_LPBIG_OFFBIG_CFLAGS</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_CS_XBS5_LPBIG_OFFBIG_LDFLAGS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"CS_XBS5_LPBIG_OFFBIG_LDFLAGS"</expr>, <expr><name>_CS_XBS5_LPBIG_OFFBIG_LDFLAGS</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_CS_XBS5_LPBIG_OFFBIG_LIBS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"CS_XBS5_LPBIG_OFFBIG_LIBS"</expr>, <expr><name>_CS_XBS5_LPBIG_OFFBIG_LIBS</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_CS_XBS5_LPBIG_OFFBIG_LINTFLAGS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"CS_XBS5_LPBIG_OFFBIG_LINTFLAGS"</expr>, <expr><name>_CS_XBS5_LPBIG_OFFBIG_LINTFLAGS</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_MIPS_CS_AVAIL_PROCESSORS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"MIPS_CS_AVAIL_PROCESSORS"</expr>, <expr><name>_MIPS_CS_AVAIL_PROCESSORS</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_MIPS_CS_BASE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"MIPS_CS_BASE"</expr>, <expr><name>_MIPS_CS_BASE</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_MIPS_CS_HOSTID</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"MIPS_CS_HOSTID"</expr>, <expr><name>_MIPS_CS_HOSTID</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_MIPS_CS_HW_NAME</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"MIPS_CS_HW_NAME"</expr>, <expr><name>_MIPS_CS_HW_NAME</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_MIPS_CS_NUM_PROCESSORS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"MIPS_CS_NUM_PROCESSORS"</expr>, <expr><name>_MIPS_CS_NUM_PROCESSORS</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_MIPS_CS_OSREL_MAJ</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"MIPS_CS_OSREL_MAJ"</expr>, <expr><name>_MIPS_CS_OSREL_MAJ</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_MIPS_CS_OSREL_MIN</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"MIPS_CS_OSREL_MIN"</expr>, <expr><name>_MIPS_CS_OSREL_MIN</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_MIPS_CS_OSREL_PATCH</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"MIPS_CS_OSREL_PATCH"</expr>, <expr><name>_MIPS_CS_OSREL_PATCH</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_MIPS_CS_OS_NAME</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"MIPS_CS_OS_NAME"</expr>, <expr><name>_MIPS_CS_OS_NAME</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_MIPS_CS_OS_PROVIDER</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"MIPS_CS_OS_PROVIDER"</expr>, <expr><name>_MIPS_CS_OS_PROVIDER</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_MIPS_CS_PROCESSORS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"MIPS_CS_PROCESSORS"</expr>, <expr><name>_MIPS_CS_PROCESSORS</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_MIPS_CS_SERIAL</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"MIPS_CS_SERIAL"</expr>, <expr><name>_MIPS_CS_SERIAL</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_MIPS_CS_VENDOR</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"MIPS_CS_VENDOR"</expr>, <expr><name>_MIPS_CS_VENDOR</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></expr></init></decl>;</decl_stmt>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>conv_confstr_confname</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>arg</name></decl></param>, <param><decl><type><name>int</name> *</type><name>valuep</name></decl></param>)</parameter_list> <block>{
<return>return <expr><call><name>conv_confname</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><name>valuep</name></expr></argument>, <argument><expr><name>posix_constants_confstr</name></expr></argument>,
<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>posix_constants_confstr</name></expr></argument>)</argument_list></sizeof>
/ <sizeof>sizeof<argument_list>(<argument>struct <expr><name>constdef</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>posix_confstr__doc__</name></expr></argument>,
<argument><expr>"confstr(name) -&gt; string\n\n\
Return a string-valued system configuration variable."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>posix_confstr</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>result</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>name</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name><name>buffer</name><index>[<expr>256</expr>]</index></name></decl>;</decl_stmt>
<if>if <condition>(<expr><call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"O&amp;:confstr"</expr></argument>, <argument><expr><name>conv_confstr_confname</name></expr></argument>, <argument><expr>&amp;<name>name</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>len</name></decl>;</decl_stmt>
<expr_stmt><expr><name>errno</name> = 0</expr>;</expr_stmt>
<expr_stmt><expr><name>len</name> = <call><name>confstr</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>len</name> == 0</expr>)</condition><then> <block>{
<if>if <condition>(<expr><name>errno</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>posix_error</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr><name>result</name> = <name>Py_None</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></else></if>
}</block></then> <else>else <block>{
<if>if <condition>(<expr>(<name>unsigned</name> <name>int</name>)<name>len</name> &gt;= <sizeof>sizeof<argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></sizeof></expr>)</condition><then> <block>{
<expr_stmt><expr><name>result</name> = <call><name>PyString_FromStringAndSize</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>len</name>-1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>result</name> != <name>NULL</name></expr>)</condition><then>
<expr_stmt><expr><call><name>confstr</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
}</block></then> <else>else
<expr_stmt><expr><name>result</name> = <call><name>PyString_FromStringAndSize</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>len</name>-1</expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
}</block></else></if>
}</block></then></if>
<return>return <expr><name>result</name></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_SYSCONF</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><specifier>static</specifier> struct <name>constdef</name></type> <name><name>posix_constants_sysconf</name><index>[]</index></name> <init>= <expr><block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_SC_2_CHAR_TERM</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"SC_2_CHAR_TERM"</expr>, <expr><name>_SC_2_CHAR_TERM</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_SC_2_C_BIND</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"SC_2_C_BIND"</expr>, <expr><name>_SC_2_C_BIND</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_SC_2_C_DEV</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"SC_2_C_DEV"</expr>, <expr><name>_SC_2_C_DEV</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_SC_2_C_VERSION</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"SC_2_C_VERSION"</expr>, <expr><name>_SC_2_C_VERSION</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_SC_2_FORT_DEV</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"SC_2_FORT_DEV"</expr>, <expr><name>_SC_2_FORT_DEV</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_SC_2_FORT_RUN</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"SC_2_FORT_RUN"</expr>, <expr><name>_SC_2_FORT_RUN</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_SC_2_LOCALEDEF</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"SC_2_LOCALEDEF"</expr>, <expr><name>_SC_2_LOCALEDEF</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_SC_2_SW_DEV</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"SC_2_SW_DEV"</expr>, <expr><name>_SC_2_SW_DEV</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_SC_2_UPE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"SC_2_UPE"</expr>, <expr><name>_SC_2_UPE</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_SC_2_VERSION</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"SC_2_VERSION"</expr>, <expr><name>_SC_2_VERSION</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_SC_ABI_ASYNCHRONOUS_IO</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"SC_ABI_ASYNCHRONOUS_IO"</expr>, <expr><name>_SC_ABI_ASYNCHRONOUS_IO</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_SC_ACL</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"SC_ACL"</expr>, <expr><name>_SC_ACL</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_SC_AIO_LISTIO_MAX</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"SC_AIO_LISTIO_MAX"</expr>, <expr><name>_SC_AIO_LISTIO_MAX</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_SC_AIO_MAX</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"SC_AIO_MAX"</expr>, <expr><name>_SC_AIO_MAX</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_SC_AIO_PRIO_DELTA_MAX</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"SC_AIO_PRIO_DELTA_MAX"</expr>, <expr><name>_SC_AIO_PRIO_DELTA_MAX</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_SC_ARG_MAX</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"SC_ARG_MAX"</expr>, <expr><name>_SC_ARG_MAX</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_SC_ASYNCHRONOUS_IO</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"SC_ASYNCHRONOUS_IO"</expr>, <expr><name>_SC_ASYNCHRONOUS_IO</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_SC_ATEXIT_MAX</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"SC_ATEXIT_MAX"</expr>, <expr><name>_SC_ATEXIT_MAX</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_SC_AUDIT</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"SC_AUDIT"</expr>, <expr><name>_SC_AUDIT</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_SC_AVPHYS_PAGES</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"SC_AVPHYS_PAGES"</expr>, <expr><name>_SC_AVPHYS_PAGES</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_SC_BC_BASE_MAX</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"SC_BC_BASE_MAX"</expr>, <expr><name>_SC_BC_BASE_MAX</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_SC_BC_DIM_MAX</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"SC_BC_DIM_MAX"</expr>, <expr><name>_SC_BC_DIM_MAX</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_SC_BC_SCALE_MAX</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"SC_BC_SCALE_MAX"</expr>, <expr><name>_SC_BC_SCALE_MAX</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_SC_BC_STRING_MAX</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"SC_BC_STRING_MAX"</expr>, <expr><name>_SC_BC_STRING_MAX</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_SC_CAP</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"SC_CAP"</expr>, <expr><name>_SC_CAP</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_SC_CHARCLASS_NAME_MAX</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"SC_CHARCLASS_NAME_MAX"</expr>, <expr><name>_SC_CHARCLASS_NAME_MAX</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_SC_CHAR_BIT</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"SC_CHAR_BIT"</expr>, <expr><name>_SC_CHAR_BIT</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_SC_CHAR_MAX</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"SC_CHAR_MAX"</expr>, <expr><name>_SC_CHAR_MAX</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_SC_CHAR_MIN</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"SC_CHAR_MIN"</expr>, <expr><name>_SC_CHAR_MIN</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_SC_CHILD_MAX</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"SC_CHILD_MAX"</expr>, <expr><name>_SC_CHILD_MAX</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_SC_CLK_TCK</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"SC_CLK_TCK"</expr>, <expr><name>_SC_CLK_TCK</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_SC_COHER_BLKSZ</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"SC_COHER_BLKSZ"</expr>, <expr><name>_SC_COHER_BLKSZ</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_SC_COLL_WEIGHTS_MAX</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"SC_COLL_WEIGHTS_MAX"</expr>, <expr><name>_SC_COLL_WEIGHTS_MAX</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_SC_DCACHE_ASSOC</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"SC_DCACHE_ASSOC"</expr>, <expr><name>_SC_DCACHE_ASSOC</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_SC_DCACHE_BLKSZ</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"SC_DCACHE_BLKSZ"</expr>, <expr><name>_SC_DCACHE_BLKSZ</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_SC_DCACHE_LINESZ</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"SC_DCACHE_LINESZ"</expr>, <expr><name>_SC_DCACHE_LINESZ</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_SC_DCACHE_SZ</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"SC_DCACHE_SZ"</expr>, <expr><name>_SC_DCACHE_SZ</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_SC_DCACHE_TBLKSZ</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"SC_DCACHE_TBLKSZ"</expr>, <expr><name>_SC_DCACHE_TBLKSZ</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_SC_DELAYTIMER_MAX</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"SC_DELAYTIMER_MAX"</expr>, <expr><name>_SC_DELAYTIMER_MAX</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_SC_EQUIV_CLASS_MAX</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"SC_EQUIV_CLASS_MAX"</expr>, <expr><name>_SC_EQUIV_CLASS_MAX</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_SC_EXPR_NEST_MAX</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"SC_EXPR_NEST_MAX"</expr>, <expr><name>_SC_EXPR_NEST_MAX</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_SC_FSYNC</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"SC_FSYNC"</expr>, <expr><name>_SC_FSYNC</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_SC_GETGR_R_SIZE_MAX</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"SC_GETGR_R_SIZE_MAX"</expr>, <expr><name>_SC_GETGR_R_SIZE_MAX</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_SC_GETPW_R_SIZE_MAX</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"SC_GETPW_R_SIZE_MAX"</expr>, <expr><name>_SC_GETPW_R_SIZE_MAX</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_SC_ICACHE_ASSOC</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"SC_ICACHE_ASSOC"</expr>, <expr><name>_SC_ICACHE_ASSOC</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_SC_ICACHE_BLKSZ</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"SC_ICACHE_BLKSZ"</expr>, <expr><name>_SC_ICACHE_BLKSZ</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_SC_ICACHE_LINESZ</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"SC_ICACHE_LINESZ"</expr>, <expr><name>_SC_ICACHE_LINESZ</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_SC_ICACHE_SZ</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"SC_ICACHE_SZ"</expr>, <expr><name>_SC_ICACHE_SZ</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_SC_INF</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"SC_INF"</expr>, <expr><name>_SC_INF</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_SC_INT_MAX</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"SC_INT_MAX"</expr>, <expr><name>_SC_INT_MAX</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_SC_INT_MIN</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"SC_INT_MIN"</expr>, <expr><name>_SC_INT_MIN</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_SC_IOV_MAX</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"SC_IOV_MAX"</expr>, <expr><name>_SC_IOV_MAX</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_SC_IP_SECOPTS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"SC_IP_SECOPTS"</expr>, <expr><name>_SC_IP_SECOPTS</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_SC_JOB_CONTROL</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"SC_JOB_CONTROL"</expr>, <expr><name>_SC_JOB_CONTROL</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_SC_KERN_POINTERS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"SC_KERN_POINTERS"</expr>, <expr><name>_SC_KERN_POINTERS</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_SC_KERN_SIM</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"SC_KERN_SIM"</expr>, <expr><name>_SC_KERN_SIM</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_SC_LINE_MAX</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"SC_LINE_MAX"</expr>, <expr><name>_SC_LINE_MAX</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_SC_LOGIN_NAME_MAX</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"SC_LOGIN_NAME_MAX"</expr>, <expr><name>_SC_LOGIN_NAME_MAX</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_SC_LOGNAME_MAX</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"SC_LOGNAME_MAX"</expr>, <expr><name>_SC_LOGNAME_MAX</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_SC_LONG_BIT</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"SC_LONG_BIT"</expr>, <expr><name>_SC_LONG_BIT</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_SC_MAC</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"SC_MAC"</expr>, <expr><name>_SC_MAC</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_SC_MAPPED_FILES</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"SC_MAPPED_FILES"</expr>, <expr><name>_SC_MAPPED_FILES</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_SC_MAXPID</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"SC_MAXPID"</expr>, <expr><name>_SC_MAXPID</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_SC_MB_LEN_MAX</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"SC_MB_LEN_MAX"</expr>, <expr><name>_SC_MB_LEN_MAX</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_SC_MEMLOCK</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"SC_MEMLOCK"</expr>, <expr><name>_SC_MEMLOCK</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_SC_MEMLOCK_RANGE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"SC_MEMLOCK_RANGE"</expr>, <expr><name>_SC_MEMLOCK_RANGE</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_SC_MEMORY_PROTECTION</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"SC_MEMORY_PROTECTION"</expr>, <expr><name>_SC_MEMORY_PROTECTION</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_SC_MESSAGE_PASSING</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"SC_MESSAGE_PASSING"</expr>, <expr><name>_SC_MESSAGE_PASSING</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_SC_MMAP_FIXED_ALIGNMENT</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"SC_MMAP_FIXED_ALIGNMENT"</expr>, <expr><name>_SC_MMAP_FIXED_ALIGNMENT</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_SC_MQ_OPEN_MAX</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"SC_MQ_OPEN_MAX"</expr>, <expr><name>_SC_MQ_OPEN_MAX</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_SC_MQ_PRIO_MAX</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"SC_MQ_PRIO_MAX"</expr>, <expr><name>_SC_MQ_PRIO_MAX</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_SC_NACLS_MAX</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"SC_NACLS_MAX"</expr>, <expr><name>_SC_NACLS_MAX</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_SC_NGROUPS_MAX</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"SC_NGROUPS_MAX"</expr>, <expr><name>_SC_NGROUPS_MAX</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_SC_NL_ARGMAX</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"SC_NL_ARGMAX"</expr>, <expr><name>_SC_NL_ARGMAX</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_SC_NL_LANGMAX</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"SC_NL_LANGMAX"</expr>, <expr><name>_SC_NL_LANGMAX</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_SC_NL_MSGMAX</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"SC_NL_MSGMAX"</expr>, <expr><name>_SC_NL_MSGMAX</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_SC_NL_NMAX</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"SC_NL_NMAX"</expr>, <expr><name>_SC_NL_NMAX</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_SC_NL_SETMAX</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"SC_NL_SETMAX"</expr>, <expr><name>_SC_NL_SETMAX</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_SC_NL_TEXTMAX</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"SC_NL_TEXTMAX"</expr>, <expr><name>_SC_NL_TEXTMAX</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_SC_NPROCESSORS_CONF</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"SC_NPROCESSORS_CONF"</expr>, <expr><name>_SC_NPROCESSORS_CONF</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_SC_NPROCESSORS_ONLN</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"SC_NPROCESSORS_ONLN"</expr>, <expr><name>_SC_NPROCESSORS_ONLN</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_SC_NPROC_CONF</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"SC_NPROC_CONF"</expr>, <expr><name>_SC_NPROC_CONF</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_SC_NPROC_ONLN</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"SC_NPROC_ONLN"</expr>, <expr><name>_SC_NPROC_ONLN</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_SC_NZERO</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"SC_NZERO"</expr>, <expr><name>_SC_NZERO</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_SC_OPEN_MAX</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"SC_OPEN_MAX"</expr>, <expr><name>_SC_OPEN_MAX</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_SC_PAGESIZE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"SC_PAGESIZE"</expr>, <expr><name>_SC_PAGESIZE</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_SC_PAGE_SIZE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"SC_PAGE_SIZE"</expr>, <expr><name>_SC_PAGE_SIZE</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_SC_PASS_MAX</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"SC_PASS_MAX"</expr>, <expr><name>_SC_PASS_MAX</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_SC_PHYS_PAGES</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"SC_PHYS_PAGES"</expr>, <expr><name>_SC_PHYS_PAGES</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_SC_PII</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"SC_PII"</expr>, <expr><name>_SC_PII</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_SC_PII_INTERNET</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"SC_PII_INTERNET"</expr>, <expr><name>_SC_PII_INTERNET</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_SC_PII_INTERNET_DGRAM</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"SC_PII_INTERNET_DGRAM"</expr>, <expr><name>_SC_PII_INTERNET_DGRAM</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_SC_PII_INTERNET_STREAM</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"SC_PII_INTERNET_STREAM"</expr>, <expr><name>_SC_PII_INTERNET_STREAM</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_SC_PII_OSI</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"SC_PII_OSI"</expr>, <expr><name>_SC_PII_OSI</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_SC_PII_OSI_CLTS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"SC_PII_OSI_CLTS"</expr>, <expr><name>_SC_PII_OSI_CLTS</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_SC_PII_OSI_COTS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"SC_PII_OSI_COTS"</expr>, <expr><name>_SC_PII_OSI_COTS</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_SC_PII_OSI_M</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"SC_PII_OSI_M"</expr>, <expr><name>_SC_PII_OSI_M</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_SC_PII_SOCKET</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"SC_PII_SOCKET"</expr>, <expr><name>_SC_PII_SOCKET</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_SC_PII_XTI</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"SC_PII_XTI"</expr>, <expr><name>_SC_PII_XTI</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_SC_POLL</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"SC_POLL"</expr>, <expr><name>_SC_POLL</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_SC_PRIORITIZED_IO</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"SC_PRIORITIZED_IO"</expr>, <expr><name>_SC_PRIORITIZED_IO</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_SC_PRIORITY_SCHEDULING</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"SC_PRIORITY_SCHEDULING"</expr>, <expr><name>_SC_PRIORITY_SCHEDULING</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_SC_REALTIME_SIGNALS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"SC_REALTIME_SIGNALS"</expr>, <expr><name>_SC_REALTIME_SIGNALS</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_SC_RE_DUP_MAX</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"SC_RE_DUP_MAX"</expr>, <expr><name>_SC_RE_DUP_MAX</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_SC_RTSIG_MAX</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"SC_RTSIG_MAX"</expr>, <expr><name>_SC_RTSIG_MAX</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_SC_SAVED_IDS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"SC_SAVED_IDS"</expr>, <expr><name>_SC_SAVED_IDS</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_SC_SCHAR_MAX</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"SC_SCHAR_MAX"</expr>, <expr><name>_SC_SCHAR_MAX</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_SC_SCHAR_MIN</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"SC_SCHAR_MIN"</expr>, <expr><name>_SC_SCHAR_MIN</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_SC_SELECT</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"SC_SELECT"</expr>, <expr><name>_SC_SELECT</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_SC_SEMAPHORES</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"SC_SEMAPHORES"</expr>, <expr><name>_SC_SEMAPHORES</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_SC_SEM_NSEMS_MAX</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"SC_SEM_NSEMS_MAX"</expr>, <expr><name>_SC_SEM_NSEMS_MAX</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_SC_SEM_VALUE_MAX</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"SC_SEM_VALUE_MAX"</expr>, <expr><name>_SC_SEM_VALUE_MAX</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_SC_SHARED_MEMORY_OBJECTS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"SC_SHARED_MEMORY_OBJECTS"</expr>, <expr><name>_SC_SHARED_MEMORY_OBJECTS</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_SC_SHRT_MAX</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"SC_SHRT_MAX"</expr>, <expr><name>_SC_SHRT_MAX</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_SC_SHRT_MIN</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"SC_SHRT_MIN"</expr>, <expr><name>_SC_SHRT_MIN</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_SC_SIGQUEUE_MAX</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"SC_SIGQUEUE_MAX"</expr>, <expr><name>_SC_SIGQUEUE_MAX</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_SC_SIGRT_MAX</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"SC_SIGRT_MAX"</expr>, <expr><name>_SC_SIGRT_MAX</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_SC_SIGRT_MIN</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"SC_SIGRT_MIN"</expr>, <expr><name>_SC_SIGRT_MIN</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_SC_SOFTPOWER</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"SC_SOFTPOWER"</expr>, <expr><name>_SC_SOFTPOWER</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_SC_SPLIT_CACHE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"SC_SPLIT_CACHE"</expr>, <expr><name>_SC_SPLIT_CACHE</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_SC_SSIZE_MAX</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"SC_SSIZE_MAX"</expr>, <expr><name>_SC_SSIZE_MAX</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_SC_STACK_PROT</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"SC_STACK_PROT"</expr>, <expr><name>_SC_STACK_PROT</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_SC_STREAM_MAX</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"SC_STREAM_MAX"</expr>, <expr><name>_SC_STREAM_MAX</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_SC_SYNCHRONIZED_IO</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"SC_SYNCHRONIZED_IO"</expr>, <expr><name>_SC_SYNCHRONIZED_IO</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_SC_THREADS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"SC_THREADS"</expr>, <expr><name>_SC_THREADS</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_SC_THREAD_ATTR_STACKADDR</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"SC_THREAD_ATTR_STACKADDR"</expr>, <expr><name>_SC_THREAD_ATTR_STACKADDR</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_SC_THREAD_ATTR_STACKSIZE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"SC_THREAD_ATTR_STACKSIZE"</expr>, <expr><name>_SC_THREAD_ATTR_STACKSIZE</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_SC_THREAD_DESTRUCTOR_ITERATIONS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"SC_THREAD_DESTRUCTOR_ITERATIONS"</expr>, <expr><name>_SC_THREAD_DESTRUCTOR_ITERATIONS</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_SC_THREAD_KEYS_MAX</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"SC_THREAD_KEYS_MAX"</expr>, <expr><name>_SC_THREAD_KEYS_MAX</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_SC_THREAD_PRIORITY_SCHEDULING</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"SC_THREAD_PRIORITY_SCHEDULING"</expr>, <expr><name>_SC_THREAD_PRIORITY_SCHEDULING</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_SC_THREAD_PRIO_INHERIT</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"SC_THREAD_PRIO_INHERIT"</expr>, <expr><name>_SC_THREAD_PRIO_INHERIT</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_SC_THREAD_PRIO_PROTECT</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"SC_THREAD_PRIO_PROTECT"</expr>, <expr><name>_SC_THREAD_PRIO_PROTECT</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_SC_THREAD_PROCESS_SHARED</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"SC_THREAD_PROCESS_SHARED"</expr>, <expr><name>_SC_THREAD_PROCESS_SHARED</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_SC_THREAD_SAFE_FUNCTIONS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"SC_THREAD_SAFE_FUNCTIONS"</expr>, <expr><name>_SC_THREAD_SAFE_FUNCTIONS</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_SC_THREAD_STACK_MIN</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"SC_THREAD_STACK_MIN"</expr>, <expr><name>_SC_THREAD_STACK_MIN</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_SC_THREAD_THREADS_MAX</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"SC_THREAD_THREADS_MAX"</expr>, <expr><name>_SC_THREAD_THREADS_MAX</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_SC_TIMERS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"SC_TIMERS"</expr>, <expr><name>_SC_TIMERS</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_SC_TIMER_MAX</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"SC_TIMER_MAX"</expr>, <expr><name>_SC_TIMER_MAX</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_SC_TTY_NAME_MAX</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"SC_TTY_NAME_MAX"</expr>, <expr><name>_SC_TTY_NAME_MAX</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_SC_TZNAME_MAX</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"SC_TZNAME_MAX"</expr>, <expr><name>_SC_TZNAME_MAX</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_SC_T_IOV_MAX</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"SC_T_IOV_MAX"</expr>, <expr><name>_SC_T_IOV_MAX</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_SC_UCHAR_MAX</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"SC_UCHAR_MAX"</expr>, <expr><name>_SC_UCHAR_MAX</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_SC_UINT_MAX</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"SC_UINT_MAX"</expr>, <expr><name>_SC_UINT_MAX</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_SC_UIO_MAXIOV</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"SC_UIO_MAXIOV"</expr>, <expr><name>_SC_UIO_MAXIOV</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_SC_ULONG_MAX</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"SC_ULONG_MAX"</expr>, <expr><name>_SC_ULONG_MAX</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_SC_USHRT_MAX</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"SC_USHRT_MAX"</expr>, <expr><name>_SC_USHRT_MAX</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_SC_VERSION</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"SC_VERSION"</expr>, <expr><name>_SC_VERSION</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_SC_WORD_BIT</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"SC_WORD_BIT"</expr>, <expr><name>_SC_WORD_BIT</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_SC_XBS5_ILP32_OFF32</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"SC_XBS5_ILP32_OFF32"</expr>, <expr><name>_SC_XBS5_ILP32_OFF32</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_SC_XBS5_ILP32_OFFBIG</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"SC_XBS5_ILP32_OFFBIG"</expr>, <expr><name>_SC_XBS5_ILP32_OFFBIG</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_SC_XBS5_LP64_OFF64</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"SC_XBS5_LP64_OFF64"</expr>, <expr><name>_SC_XBS5_LP64_OFF64</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_SC_XBS5_LPBIG_OFFBIG</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"SC_XBS5_LPBIG_OFFBIG"</expr>, <expr><name>_SC_XBS5_LPBIG_OFFBIG</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_SC_XOPEN_CRYPT</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"SC_XOPEN_CRYPT"</expr>, <expr><name>_SC_XOPEN_CRYPT</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_SC_XOPEN_ENH_I18N</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"SC_XOPEN_ENH_I18N"</expr>, <expr><name>_SC_XOPEN_ENH_I18N</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_SC_XOPEN_LEGACY</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"SC_XOPEN_LEGACY"</expr>, <expr><name>_SC_XOPEN_LEGACY</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_SC_XOPEN_REALTIME</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"SC_XOPEN_REALTIME"</expr>, <expr><name>_SC_XOPEN_REALTIME</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_SC_XOPEN_REALTIME_THREADS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"SC_XOPEN_REALTIME_THREADS"</expr>, <expr><name>_SC_XOPEN_REALTIME_THREADS</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_SC_XOPEN_SHM</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"SC_XOPEN_SHM"</expr>, <expr><name>_SC_XOPEN_SHM</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_SC_XOPEN_UNIX</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"SC_XOPEN_UNIX"</expr>, <expr><name>_SC_XOPEN_UNIX</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_SC_XOPEN_VERSION</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"SC_XOPEN_VERSION"</expr>, <expr><name>_SC_XOPEN_VERSION</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_SC_XOPEN_XCU_VERSION</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"SC_XOPEN_XCU_VERSION"</expr>, <expr><name>_SC_XOPEN_XCU_VERSION</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_SC_XOPEN_XPG2</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"SC_XOPEN_XPG2"</expr>, <expr><name>_SC_XOPEN_XPG2</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_SC_XOPEN_XPG3</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"SC_XOPEN_XPG3"</expr>, <expr><name>_SC_XOPEN_XPG3</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_SC_XOPEN_XPG4</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"SC_XOPEN_XPG4"</expr>, <expr><name>_SC_XOPEN_XPG4</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></expr></init></decl>;</decl_stmt>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>conv_sysconf_confname</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>arg</name></decl></param>, <param><decl><type><name>int</name> *</type><name>valuep</name></decl></param>)</parameter_list> <block>{
<return>return <expr><call><name>conv_confname</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><name>valuep</name></expr></argument>, <argument><expr><name>posix_constants_sysconf</name></expr></argument>,
<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>posix_constants_sysconf</name></expr></argument>)</argument_list></sizeof>
/ <sizeof>sizeof<argument_list>(<argument>struct <expr><name>constdef</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>posix_sysconf__doc__</name></expr></argument>,
<argument><expr>"sysconf(name) -&gt; integer\n\n\
Return an integer-valued system configuration variable."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>posix_sysconf</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>result</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>name</name></decl>;</decl_stmt>
<if>if <condition>(<expr><call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"O&amp;:sysconf"</expr></argument>, <argument><expr><name>conv_sysconf_confname</name></expr></argument>, <argument><expr>&amp;<name>name</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>value</name></decl>;</decl_stmt>
<expr_stmt><expr><name>errno</name> = 0</expr>;</expr_stmt>
<expr_stmt><expr><name>value</name> = <call><name>sysconf</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>value</name> == -1 &amp;&amp; <name>errno</name> != 0</expr>)</condition><then>
<expr_stmt><expr><call><name>posix_error</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then>
<else>else
<expr_stmt><expr><name>result</name> = <call><name>PyInt_FromLong</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
}</block></then></if>
<return>return <expr><name>result</name></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>cmp_constdefs</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>void</name> *</type><name>v1</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>void</name> *</type><name>v2</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><specifier>const</specifier> struct <name>constdef</name> *</type><name>c1</name> <init>=
<expr>(const struct <name>constdef</name> *) <name>v1</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> struct <name>constdef</name> *</type><name>c2</name> <init>=
<expr>(const struct <name>constdef</name> *) <name>v2</name></expr></init></decl>;</decl_stmt>
<return>return <expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>c1</name>-&gt;<name>name</name></name></expr></argument>, <argument><expr><name><name>c2</name>-&gt;<name>name</name></name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>setup_confname_table</name><parameter_list>(<param><decl><type>struct <name>constdef</name> *</type><name>table</name></decl></param>, <param><decl><type><name>size_t</name></type> <name>tablesize</name></decl></param>,
<param><decl><type><name>char</name> *</type><name>tablename</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>module</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>d</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>i</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>qsort</name><argument_list>(<argument><expr><name>table</name></expr></argument>, <argument><expr><name>tablesize</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument>struct <expr><name>constdef</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>cmp_constdefs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>d</name> = <call><name>PyDict_New</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>d</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr>-1</expr>;</return></then></if>
<for>for (<init><expr><name>i</name>=0</expr>;</init> <condition><expr><name>i</name> &lt; <name>tablesize</name></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>) <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>o</name> <init>= <expr><call><name>PyInt_FromLong</name><argument_list>(<argument><expr><name><name>table</name><index>[<expr><name>i</name></expr>]</index></name>.<name>value</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>o</name> == <name>NULL</name> || <call><name>PyDict_SetItemString</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr><name><name>table</name><index>[<expr><name>i</name></expr>]</index></name>.<name>name</name></expr></argument>, <argument><expr><name>o</name></expr></argument>)</argument_list></call> == -1</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>-1</expr>;</return>
}</block></then></if>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></for>
<return>return <expr><call><name>PyModule_AddObject</name><argument_list>(<argument><expr><name>module</name></expr></argument>, <argument><expr><name>tablename</name></expr></argument>, <argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>setup_confname_tables</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>module</name></decl></param>)</parameter_list> <block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_FPATHCONF</name></expr></argument>)</argument_list></call> || <call><name>defined</name><argument_list>(<argument><expr><name>HAVE_PATHCONF</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if>if <condition>(<expr><call><name>setup_confname_table</name><argument_list>(<argument><expr><name>posix_constants_pathconf</name></expr></argument>,
<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>posix_constants_pathconf</name></expr></argument>)</argument_list></sizeof>
/ <sizeof>sizeof<argument_list>(<argument>struct <expr><name>constdef</name></expr></argument>)</argument_list></sizeof></expr></argument>,
<argument><expr>"pathconf_names"</expr></argument>, <argument><expr><name>module</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr>-1</expr>;</return></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_CONFSTR</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if>if <condition>(<expr><call><name>setup_confname_table</name><argument_list>(<argument><expr><name>posix_constants_confstr</name></expr></argument>,
<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>posix_constants_confstr</name></expr></argument>)</argument_list></sizeof>
/ <sizeof>sizeof<argument_list>(<argument>struct <expr><name>constdef</name></expr></argument>)</argument_list></sizeof></expr></argument>,
<argument><expr>"confstr_names"</expr></argument>, <argument><expr><name>module</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr>-1</expr>;</return></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_SYSCONF</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if>if <condition>(<expr><call><name>setup_confname_table</name><argument_list>(<argument><expr><name>posix_constants_sysconf</name></expr></argument>,
<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>posix_constants_sysconf</name></expr></argument>)</argument_list></sizeof>
/ <sizeof>sizeof<argument_list>(<argument>struct <expr><name>constdef</name></expr></argument>)</argument_list></sizeof></expr></argument>,
<argument><expr>"sysconf_names"</expr></argument>, <argument><expr><name>module</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr>-1</expr>;</return></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<return>return <expr>0</expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>posix_abort__doc__</name></expr></argument>,
<argument><expr>"abort() -&gt; does not return!\n\n\
Abort the interpreter immediately. This 'dumps core' or otherwise fails\n\
in the hardest way possible on the hosting operating system."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>posix_abort</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>noargs</name></decl></param>)</parameter_list> <block>{
<expr_stmt><expr><call><name>abort</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_FatalError</name><argument_list>(<argument><expr>"abort() called from Python code didn't abort!"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></function>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MS_WINDOWS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>win32_startfile__doc__</name></expr></argument>,
<argument><expr>"startfile(filepath [, operation]) - Start a file with its associated\n\
application.\n\
\n\
When \"operation\" is not specified or \"open\", this acts like\n\
double-clicking the file in Explorer, or giving the file name as an\n\
argument to the DOS \"start\" command: the file is opened with whatever\n\
application (if any) its extension is associated.\n\
When another \"operation\" is given, it specifies what should be done with\n\
the file. A typical operation is \"print\".\n\
\n\
startfile returns as soon as the associated application is launched.\n\
There is no option to wait for the application to close, and no way\n\
to retrieve the application's exit status.\n\
\n\
The filepath is relative to the current directory. If you want to use\n\
an absolute path, make sure the first character is not a slash (\"/\");\n\
the underlying Win32 ShellExecute function doesn't work if it is."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>win32_startfile</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>char</name> *</type><name>filepath</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>operation</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>HINSTANCE</name></type> <name>rc</name></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>Py_WIN_WIDE_FILENAMES</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if>if <condition>(<expr><call><name>unicode_file_names</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>unipath</name></decl>, *<decl><type ref="prev"/><name>woperation</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"U|s:startfile"</expr></argument>,
<argument><expr>&amp;<name>unipath</name></expr></argument>, <argument><expr>&amp;<name>operation</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_Clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>normal</name>;</goto>
}</block></then></if>
<if>if <condition>(<expr><name>operation</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>woperation</name> = <call><name>PyUnicode_DecodeASCII</name><argument_list>(<argument><expr><name>operation</name></expr></argument>,
<argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>operation</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>woperation</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_Clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>operation</name> = <name>NULL</name></expr>;</expr_stmt>
<goto>goto <name>normal</name>;</goto>
}</block></then></if>
}</block></then></if>
<decl_stmt><decl><type><name>Py_BEGIN_ALLOW_THREADS</name></type>
<name>rc</name> <init>= <expr><call><name>ShellExecuteW</name><argument_list>(<argument><expr>(<name>HWND</name>)0</expr></argument>, <argument><expr><name>woperation</name> ? <call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr><name>woperation</name></expr></argument>)</argument_list></call> : 0</expr></argument>,
<argument><expr><call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr><name>unipath</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>SW_SHOWNORMAL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<function_decl><type><name>Py_END_ALLOW_THREADS</name></type>
<name>Py_XDECREF</name><parameter_list>(<param><decl><type><name>woperation</name></type></decl></param>)</parameter_list>;</function_decl>
<if>if <condition>(<expr><name>rc</name> &lt;= (<name>HINSTANCE</name>)32</expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>errval</name> <init>= <expr><call><name>win32_error_unicode</name><argument_list>(<argument><expr>"startfile"</expr></argument>,
<argument><expr><call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr><name>unipath</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<return>return <expr><name>errval</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>Py_None</name></expr>;</return>
}</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<label><name>normal</name>:</label>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"et|s:startfile"</expr></argument>,
<argument><expr><name>Py_FileSystemDefaultEncoding</name></expr></argument>, <argument><expr>&amp;<name>filepath</name></expr></argument>,
<argument><expr>&amp;<name>operation</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<decl_stmt><decl><type><name>Py_BEGIN_ALLOW_THREADS</name></type>
<name>rc</name> <init>= <expr><call><name>ShellExecute</name><argument_list>(<argument><expr>(<name>HWND</name>)0</expr></argument>, <argument><expr><name>operation</name></expr></argument>, <argument><expr><name>filepath</name></expr></argument>,
<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>SW_SHOWNORMAL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<macro><name>Py_END_ALLOW_THREADS</name></macro>
<if>if <condition>(<expr><name>rc</name> &lt;= (<name>HINSTANCE</name>)32</expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>errval</name> <init>= <expr><call><name>win32_error</name><argument_list>(<argument><expr>"startfile"</expr></argument>, <argument><expr><name>filepath</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>PyMem_Free</name><argument_list>(<argument><expr><name>filepath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>errval</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><call><name>PyMem_Free</name><argument_list>(<argument><expr><name>filepath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>Py_None</name></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_GETLOADAVG</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>posix_getloadavg__doc__</name></expr></argument>,
<argument><expr>"getloadavg() -&gt; (float, float, float)\n\n\
Return the number of processes in the system run queue averaged over\n\
the last 1, 5, and 15 minutes or raises OSError if the load average\n\
was unobtainable"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>posix_getloadavg</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>noargs</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>double</name></type> <name><name>loadavg</name><index>[<expr>3</expr>]</index></name></decl>;</decl_stmt>
<if>if <condition>(<expr><call><name>getloadavg</name><argument_list>(<argument><expr><name>loadavg</name></expr></argument>, <argument><expr>3</expr></argument>)</argument_list></call>!=3</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_OSError</name></expr></argument>, <argument><expr>"Load averages are unobtainable"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then> <else>else
<return>return <expr><call><name>Py_BuildValue</name><argument_list>(<argument><expr>"ddd"</expr></argument>, <argument><expr><name><name>loadavg</name><index>[<expr>0</expr>]</index></name></expr></argument>, <argument><expr><name><name>loadavg</name><index>[<expr>1</expr>]</index></name></expr></argument>, <argument><expr><name><name>loadavg</name><index>[<expr>2</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</return></else></if>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MS_WINDOWS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>win32_urandom__doc__</name></expr></argument>,
<argument><expr>"urandom(n) -&gt; str\n\n\
Return a string of n random bytes suitable for cryptographic use."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<typedef>typedef <function_decl><type><name>BOOL</name></type> (<name>WINAPI</name> *<name>CRYPTACQUIRECONTEXTA</name>)<parameter_list>(<param><decl><type><name>HCRYPTPROV</name> *</type><name>phProv</name></decl></param>,\
<param><decl><type><name>LPCSTR</name></type> <name>pszContainer</name></decl></param>, <param><decl><type><name>LPCSTR</name></type> <name>pszProvider</name></decl></param>, <param><decl><type><name>DWORD</name></type> <name>dwProvType</name></decl></param>,\
<param><decl><type><name>DWORD</name></type> <name>dwFlags</name></decl></param> )</parameter_list>;</function_decl></typedef>
<typedef>typedef <function_decl><type><name>BOOL</name></type> (<name>WINAPI</name> *<name>CRYPTGENRANDOM</name>)<parameter_list>(<param><decl><type><name>HCRYPTPROV</name></type> <name>hProv</name></decl></param>, <param><decl><type><name>DWORD</name></type> <name>dwLen</name></decl></param>,\
<param><decl><type><name>BYTE</name> *</type><name>pbBuffer</name></decl></param> )</parameter_list>;</function_decl></typedef>
<decl_stmt><decl><type><specifier>static</specifier> <name>CRYPTGENRANDOM</name></type> <name>pCryptGenRandom</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>HCRYPTPROV</name></type> <name>hCryptProv</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name>*</type>
<name>win32_urandom</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>howMany</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name>*</type> <name>result</name></decl>;</decl_stmt>
<if>if <condition>(<expr>! <call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"i:urandom"</expr></argument>, <argument><expr>&amp;<name>howMany</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<if>if <condition>(<expr><name>howMany</name> &lt; 0</expr>)</condition><then>
<return>return <expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>,
<argument><expr>"negative argument not allowed"</expr></argument>)</argument_list></call></expr>;</return></then></if>
<if>if <condition>(<expr><name>hCryptProv</name> == 0</expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>HINSTANCE</name></type> <name>hAdvAPI32</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>CRYPTACQUIRECONTEXTA</name></type> <name>pCryptAcquireContext</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>hAdvAPI32</name> = <call><name>GetModuleHandle</name><argument_list>(<argument><expr>"advapi32.dll"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if<condition>(<expr><name>hAdvAPI32</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><call><name>win32_error</name><argument_list>(<argument><expr>"GetModuleHandle"</expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
<expr_stmt><expr><name>pCryptAcquireContext</name> = (<name>CRYPTACQUIRECONTEXTA</name>)<call><name>GetProcAddress</name><argument_list>(
<argument><expr><name>hAdvAPI32</name></expr></argument>,
<argument><expr>"CryptAcquireContextA"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>pCryptAcquireContext</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_NotImplementedError</name></expr></argument>,
<argument><expr>"CryptAcquireContextA not found"</expr></argument>)</argument_list></call></expr>;</return></then></if>
<expr_stmt><expr><name>pCryptGenRandom</name> = (<name>CRYPTGENRANDOM</name>)<call><name>GetProcAddress</name><argument_list>(
<argument><expr><name>hAdvAPI32</name></expr></argument>, <argument><expr>"CryptGenRandom"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>pCryptGenRandom</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_NotImplementedError</name></expr></argument>,
<argument><expr>"CryptGenRandom not found"</expr></argument>)</argument_list></call></expr>;</return></then></if>
<if>if <condition>(<expr>! <call><name>pCryptAcquireContext</name><argument_list>(<argument><expr>&amp;<name>hCryptProv</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
<argument><expr><name>PROV_RSA_FULL</name></expr></argument>, <argument><expr><name>CRYPT_VERIFYCONTEXT</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><call><name>win32_error</name><argument_list>(<argument><expr>"CryptAcquireContext"</expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
}</block></then></if>
<expr_stmt><expr><name>result</name> = <call><name>PyString_FromStringAndSize</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>howMany</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>result</name> != <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>howMany</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>! <call><name>pCryptGenRandom</name><argument_list>(<argument><expr><name>hCryptProv</name></expr></argument>, <argument><expr><name>howMany</name></expr></argument>, <argument><expr>(<name>unsigned</name> <name>char</name>*)
<call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>win32_error</name><argument_list>(<argument><expr>"CryptGenRandom"</expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></then></if>
}</block></then></if>
<return>return <expr><name>result</name></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__VMS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;openssl/rand.h&gt;</cpp:file></cpp:include>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>vms_urandom__doc__</name></expr></argument>,
<argument><expr>"urandom(n) -&gt; str\n\n\
Return a string of n random bytes suitable for cryptographic use."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name>*</type>
<name>vms_urandom</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>howMany</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name>*</type> <name>result</name></decl>;</decl_stmt>
<if>if <condition>(<expr>! <call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"i:urandom"</expr></argument>, <argument><expr>&amp;<name>howMany</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<if>if <condition>(<expr><name>howMany</name> &lt; 0</expr>)</condition><then>
<return>return <expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>,
<argument><expr>"negative argument not allowed"</expr></argument>)</argument_list></call></expr>;</return></then></if>
<expr_stmt><expr><name>result</name> = <call><name>PyString_FromStringAndSize</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>howMany</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>result</name> != <name>NULL</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr><call><name>RAND_pseudo_bytes</name><argument_list>(<argument><expr>(<name>unsigned</name> <name>char</name>*)
<call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>howMany</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>,
<argument><expr>"RAND_pseudo_bytes"</expr></argument>)</argument_list></call></expr>;</return>
}</block></then></if>
}</block></then></if>
<return>return <expr><name>result</name></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<decl_stmt><decl><type><specifier>static</specifier> <name>PyMethodDef</name></type> <name><name>posix_methods</name><index>[]</index></name> <init>= <expr><block>{
<expr><block>{<expr>"access"</expr>, <expr><name>posix_access</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>posix_access__doc__</name></expr>}</block></expr>,
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_TTYNAME</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"ttyname"</expr>, <expr><name>posix_ttyname</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>posix_ttyname__doc__</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr><block>{<expr>"chdir"</expr>, <expr><name>posix_chdir</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>posix_chdir__doc__</name></expr>}</block></expr>,
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_CHFLAGS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"chflags"</expr>, <expr><name>posix_chflags</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>posix_chflags__doc__</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr><block>{<expr>"chmod"</expr>, <expr><name>posix_chmod</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>posix_chmod__doc__</name></expr>}</block></expr>,
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_FCHMOD</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"fchmod"</expr>, <expr><name>posix_fchmod</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>posix_fchmod__doc__</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_CHOWN</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"chown"</expr>, <expr><name>posix_chown</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>posix_chown__doc__</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_LCHMOD</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"lchmod"</expr>, <expr><name>posix_lchmod</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>posix_lchmod__doc__</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_FCHOWN</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"fchown"</expr>, <expr><name>posix_fchown</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>posix_fchown__doc__</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_LCHFLAGS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"lchflags"</expr>, <expr><name>posix_lchflags</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>posix_lchflags__doc__</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_LCHOWN</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"lchown"</expr>, <expr><name>posix_lchown</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>posix_lchown__doc__</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_CHROOT</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"chroot"</expr>, <expr><name>posix_chroot</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>posix_chroot__doc__</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_CTERMID</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"ctermid"</expr>, <expr><name>posix_ctermid</name></expr>, <expr><name>METH_NOARGS</name></expr>, <expr><name>posix_ctermid__doc__</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_GETCWD</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"getcwd"</expr>, <expr><name>posix_getcwd</name></expr>, <expr><name>METH_NOARGS</name></expr>, <expr><name>posix_getcwd__doc__</name></expr>}</block></expr>,
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>Py_USING_UNICODE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"getcwdu"</expr>, <expr><name>posix_getcwdu</name></expr>, <expr><name>METH_NOARGS</name></expr>, <expr><name>posix_getcwdu__doc__</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_LINK</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"link"</expr>, <expr><name>posix_link</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>posix_link__doc__</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr><block>{<expr>"listdir"</expr>, <expr><name>posix_listdir</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>posix_listdir__doc__</name></expr>}</block></expr>,
<expr><block>{<expr>"lstat"</expr>, <expr><name>posix_lstat</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>posix_lstat__doc__</name></expr>}</block></expr>,
<expr><block>{<expr>"mkdir"</expr>, <expr><name>posix_mkdir</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>posix_mkdir__doc__</name></expr>}</block></expr>,
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_NICE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"nice"</expr>, <expr><name>posix_nice</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>posix_nice__doc__</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_READLINK</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"readlink"</expr>, <expr><name>posix_readlink</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>posix_readlink__doc__</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr><block>{<expr>"rename"</expr>, <expr><name>posix_rename</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>posix_rename__doc__</name></expr>}</block></expr>,
<expr><block>{<expr>"rmdir"</expr>, <expr><name>posix_rmdir</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>posix_rmdir__doc__</name></expr>}</block></expr>,
<expr><block>{<expr>"stat"</expr>, <expr><name>posix_stat</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>posix_stat__doc__</name></expr>}</block></expr>,
<expr><block>{<expr>"stat_float_times"</expr>, <expr><name>stat_float_times</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>stat_float_times__doc__</name></expr>}</block></expr>,
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_SYMLINK</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"symlink"</expr>, <expr><name>posix_symlink</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>posix_symlink__doc__</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_SYSTEM</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"system"</expr>, <expr><name>posix_system</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>posix_system__doc__</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr><block>{<expr>"umask"</expr>, <expr><name>posix_umask</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>posix_umask__doc__</name></expr>}</block></expr>,
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_UNAME</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"uname"</expr>, <expr><name>posix_uname</name></expr>, <expr><name>METH_NOARGS</name></expr>, <expr><name>posix_uname__doc__</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr><block>{<expr>"unlink"</expr>, <expr><name>posix_unlink</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>posix_unlink__doc__</name></expr>}</block></expr>,
<expr><block>{<expr>"remove"</expr>, <expr><name>posix_unlink</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>posix_remove__doc__</name></expr>}</block></expr>,
<expr><block>{<expr>"utime"</expr>, <expr><name>posix_utime</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>posix_utime__doc__</name></expr>}</block></expr>,
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_TIMES</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"times"</expr>, <expr><name>posix_times</name></expr>, <expr><name>METH_NOARGS</name></expr>, <expr><name>posix_times__doc__</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr><block>{<expr>"_exit"</expr>, <expr><name>posix__exit</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>posix__exit__doc__</name></expr>}</block></expr>,
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_EXECV</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"execv"</expr>, <expr><name>posix_execv</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>posix_execv__doc__</name></expr>}</block></expr>,
<expr><block>{<expr>"execve"</expr>, <expr><name>posix_execve</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>posix_execve__doc__</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_SPAWNV</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"spawnv"</expr>, <expr><name>posix_spawnv</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>posix_spawnv__doc__</name></expr>}</block></expr>,
<expr><block>{<expr>"spawnve"</expr>, <expr><name>posix_spawnve</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>posix_spawnve__doc__</name></expr>}</block></expr>,
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>PYOS_OS2</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"spawnvp"</expr>, <expr><name>posix_spawnvp</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>posix_spawnvp__doc__</name></expr>}</block></expr>,
<expr><block>{<expr>"spawnvpe"</expr>, <expr><name>posix_spawnvpe</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>posix_spawnvpe__doc__</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_FORK1</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"fork1"</expr>, <expr><name>posix_fork1</name></expr>, <expr><name>METH_NOARGS</name></expr>, <expr><name>posix_fork1__doc__</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_FORK</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"fork"</expr>, <expr><name>posix_fork</name></expr>, <expr><name>METH_NOARGS</name></expr>, <expr><name>posix_fork__doc__</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_OPENPTY</name></expr></argument>)</argument_list></call> || <call><name>defined</name><argument_list>(<argument><expr><name>HAVE__GETPTY</name></expr></argument>)</argument_list></call> || <call><name>defined</name><argument_list>(<argument><expr><name>HAVE_DEV_PTMX</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"openpty"</expr>, <expr><name>posix_openpty</name></expr>, <expr><name>METH_NOARGS</name></expr>, <expr><name>posix_openpty__doc__</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_FORKPTY</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"forkpty"</expr>, <expr><name>posix_forkpty</name></expr>, <expr><name>METH_NOARGS</name></expr>, <expr><name>posix_forkpty__doc__</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_GETEGID</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"getegid"</expr>, <expr><name>posix_getegid</name></expr>, <expr><name>METH_NOARGS</name></expr>, <expr><name>posix_getegid__doc__</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_GETEUID</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"geteuid"</expr>, <expr><name>posix_geteuid</name></expr>, <expr><name>METH_NOARGS</name></expr>, <expr><name>posix_geteuid__doc__</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_GETGID</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"getgid"</expr>, <expr><name>posix_getgid</name></expr>, <expr><name>METH_NOARGS</name></expr>, <expr><name>posix_getgid__doc__</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_GETGROUPS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"getgroups"</expr>, <expr><name>posix_getgroups</name></expr>, <expr><name>METH_NOARGS</name></expr>, <expr><name>posix_getgroups__doc__</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr><block>{<expr>"getpid"</expr>, <expr><name>posix_getpid</name></expr>, <expr><name>METH_NOARGS</name></expr>, <expr><name>posix_getpid__doc__</name></expr>}</block></expr>,
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_GETPGRP</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"getpgrp"</expr>, <expr><name>posix_getpgrp</name></expr>, <expr><name>METH_NOARGS</name></expr>, <expr><name>posix_getpgrp__doc__</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_GETPPID</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"getppid"</expr>, <expr><name>posix_getppid</name></expr>, <expr><name>METH_NOARGS</name></expr>, <expr><name>posix_getppid__doc__</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_GETUID</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"getuid"</expr>, <expr><name>posix_getuid</name></expr>, <expr><name>METH_NOARGS</name></expr>, <expr><name>posix_getuid__doc__</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_GETLOGIN</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"getlogin"</expr>, <expr><name>posix_getlogin</name></expr>, <expr><name>METH_NOARGS</name></expr>, <expr><name>posix_getlogin__doc__</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_KILL</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"kill"</expr>, <expr><name>posix_kill</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>posix_kill__doc__</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_KILLPG</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"killpg"</expr>, <expr><name>posix_killpg</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>posix_killpg__doc__</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_PLOCK</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"plock"</expr>, <expr><name>posix_plock</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>posix_plock__doc__</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_POPEN</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"popen"</expr>, <expr><name>posix_popen</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>posix_popen__doc__</name></expr>}</block></expr>,
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MS_WINDOWS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"popen2"</expr>, <expr><name>win32_popen2</name></expr>, <expr><name>METH_VARARGS</name></expr>}</block></expr>,
<expr><block>{<expr>"popen3"</expr>, <expr><name>win32_popen3</name></expr>, <expr><name>METH_VARARGS</name></expr>}</block></expr>,
<expr><block>{<expr>"popen4"</expr>, <expr><name>win32_popen4</name></expr>, <expr><name>METH_VARARGS</name></expr>}</block></expr>,
<expr><block>{<expr>"startfile"</expr>, <expr><name>win32_startfile</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>win32_startfile__doc__</name></expr>}</block></expr>,
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>PYOS_OS2</name></expr></argument>)</argument_list></call> &amp;&amp; <call><name>defined</name><argument_list>(<argument><expr><name>PYCC_GCC</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"popen2"</expr>, <expr><name>os2emx_popen2</name></expr>, <expr><name>METH_VARARGS</name></expr>}</block></expr>,
<expr><block>{<expr>"popen3"</expr>, <expr><name>os2emx_popen3</name></expr>, <expr><name>METH_VARARGS</name></expr>}</block></expr>,
<expr><block>{<expr>"popen4"</expr>, <expr><name>os2emx_popen4</name></expr>, <expr><name>METH_VARARGS</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_SETUID</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"setuid"</expr>, <expr><name>posix_setuid</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>posix_setuid__doc__</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_SETEUID</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"seteuid"</expr>, <expr><name>posix_seteuid</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>posix_seteuid__doc__</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_SETEGID</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"setegid"</expr>, <expr><name>posix_setegid</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>posix_setegid__doc__</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_SETREUID</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"setreuid"</expr>, <expr><name>posix_setreuid</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>posix_setreuid__doc__</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_SETREGID</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"setregid"</expr>, <expr><name>posix_setregid</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>posix_setregid__doc__</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_SETGID</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"setgid"</expr>, <expr><name>posix_setgid</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>posix_setgid__doc__</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_SETGROUPS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"setgroups"</expr>, <expr><name>posix_setgroups</name></expr>, <expr><name>METH_O</name></expr>, <expr><name>posix_setgroups__doc__</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_GETPGID</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"getpgid"</expr>, <expr><name>posix_getpgid</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>posix_getpgid__doc__</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_SETPGRP</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"setpgrp"</expr>, <expr><name>posix_setpgrp</name></expr>, <expr><name>METH_NOARGS</name></expr>, <expr><name>posix_setpgrp__doc__</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_WAIT</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"wait"</expr>, <expr><name>posix_wait</name></expr>, <expr><name>METH_NOARGS</name></expr>, <expr><name>posix_wait__doc__</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_WAIT3</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"wait3"</expr>, <expr><name>posix_wait3</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>posix_wait3__doc__</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_WAIT4</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"wait4"</expr>, <expr><name>posix_wait4</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>posix_wait4__doc__</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_WAITPID</name></expr></argument>)</argument_list></call> || <call><name>defined</name><argument_list>(<argument><expr><name>HAVE_CWAIT</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"waitpid"</expr>, <expr><name>posix_waitpid</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>posix_waitpid__doc__</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_GETSID</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"getsid"</expr>, <expr><name>posix_getsid</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>posix_getsid__doc__</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_SETSID</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"setsid"</expr>, <expr><name>posix_setsid</name></expr>, <expr><name>METH_NOARGS</name></expr>, <expr><name>posix_setsid__doc__</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_SETPGID</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"setpgid"</expr>, <expr><name>posix_setpgid</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>posix_setpgid__doc__</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_TCGETPGRP</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"tcgetpgrp"</expr>, <expr><name>posix_tcgetpgrp</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>posix_tcgetpgrp__doc__</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_TCSETPGRP</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"tcsetpgrp"</expr>, <expr><name>posix_tcsetpgrp</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>posix_tcsetpgrp__doc__</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr><block>{<expr>"open"</expr>, <expr><name>posix_open</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>posix_open__doc__</name></expr>}</block></expr>,
<expr><block>{<expr>"close"</expr>, <expr><name>posix_close</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>posix_close__doc__</name></expr>}</block></expr>,
<expr><block>{<expr>"closerange"</expr>, <expr><name>posix_closerange</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>posix_closerange__doc__</name></expr>}</block></expr>,
<expr><block>{<expr>"dup"</expr>, <expr><name>posix_dup</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>posix_dup__doc__</name></expr>}</block></expr>,
<expr><block>{<expr>"dup2"</expr>, <expr><name>posix_dup2</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>posix_dup2__doc__</name></expr>}</block></expr>,
<expr><block>{<expr>"lseek"</expr>, <expr><name>posix_lseek</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>posix_lseek__doc__</name></expr>}</block></expr>,
<expr><block>{<expr>"read"</expr>, <expr><name>posix_read</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>posix_read__doc__</name></expr>}</block></expr>,
<expr><block>{<expr>"write"</expr>, <expr><name>posix_write</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>posix_write__doc__</name></expr>}</block></expr>,
<expr><block>{<expr>"fstat"</expr>, <expr><name>posix_fstat</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>posix_fstat__doc__</name></expr>}</block></expr>,
<expr><block>{<expr>"fdopen"</expr>, <expr><name>posix_fdopen</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>posix_fdopen__doc__</name></expr>}</block></expr>,
<expr><block>{<expr>"isatty"</expr>, <expr><name>posix_isatty</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>posix_isatty__doc__</name></expr>}</block></expr>,
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_PIPE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"pipe"</expr>, <expr><name>posix_pipe</name></expr>, <expr><name>METH_NOARGS</name></expr>, <expr><name>posix_pipe__doc__</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_MKFIFO</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"mkfifo"</expr>, <expr><name>posix_mkfifo</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>posix_mkfifo__doc__</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_MKNOD</name></expr></argument>)</argument_list></call> &amp;&amp; <call><name>defined</name><argument_list>(<argument><expr><name>HAVE_MAKEDEV</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"mknod"</expr>, <expr><name>posix_mknod</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>posix_mknod__doc__</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_DEVICE_MACROS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"major"</expr>, <expr><name>posix_major</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>posix_major__doc__</name></expr>}</block></expr>,
<expr><block>{<expr>"minor"</expr>, <expr><name>posix_minor</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>posix_minor__doc__</name></expr>}</block></expr>,
<expr><block>{<expr>"makedev"</expr>, <expr><name>posix_makedev</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>posix_makedev__doc__</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_FTRUNCATE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"ftruncate"</expr>, <expr><name>posix_ftruncate</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>posix_ftruncate__doc__</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_PUTENV</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"putenv"</expr>, <expr><name>posix_putenv</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>posix_putenv__doc__</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_UNSETENV</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"unsetenv"</expr>, <expr><name>posix_unsetenv</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>posix_unsetenv__doc__</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr><block>{<expr>"strerror"</expr>, <expr><name>posix_strerror</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>posix_strerror__doc__</name></expr>}</block></expr>,
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_FCHDIR</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"fchdir"</expr>, <expr><name>posix_fchdir</name></expr>, <expr><name>METH_O</name></expr>, <expr><name>posix_fchdir__doc__</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_FSYNC</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"fsync"</expr>, <expr><name>posix_fsync</name></expr>, <expr><name>METH_O</name></expr>, <expr><name>posix_fsync__doc__</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_FDATASYNC</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"fdatasync"</expr>, <expr><name>posix_fdatasync</name></expr>, <expr><name>METH_O</name></expr>, <expr><name>posix_fdatasync__doc__</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_SYS_WAIT_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>WCOREDUMP</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"WCOREDUMP"</expr>, <expr><name>posix_WCOREDUMP</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>posix_WCOREDUMP__doc__</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>WIFCONTINUED</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"WIFCONTINUED"</expr>,<expr><name>posix_WIFCONTINUED</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>posix_WIFCONTINUED__doc__</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>WIFSTOPPED</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"WIFSTOPPED"</expr>, <expr><name>posix_WIFSTOPPED</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>posix_WIFSTOPPED__doc__</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>WIFSIGNALED</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"WIFSIGNALED"</expr>, <expr><name>posix_WIFSIGNALED</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>posix_WIFSIGNALED__doc__</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>WIFEXITED</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"WIFEXITED"</expr>, <expr><name>posix_WIFEXITED</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>posix_WIFEXITED__doc__</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>WEXITSTATUS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"WEXITSTATUS"</expr>, <expr><name>posix_WEXITSTATUS</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>posix_WEXITSTATUS__doc__</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>WTERMSIG</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"WTERMSIG"</expr>, <expr><name>posix_WTERMSIG</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>posix_WTERMSIG__doc__</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>WSTOPSIG</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"WSTOPSIG"</expr>, <expr><name>posix_WSTOPSIG</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>posix_WSTOPSIG__doc__</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_FSTATVFS</name></expr></argument>)</argument_list></call> &amp;&amp; <call><name>defined</name><argument_list>(<argument><expr><name>HAVE_SYS_STATVFS_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"fstatvfs"</expr>, <expr><name>posix_fstatvfs</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>posix_fstatvfs__doc__</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_STATVFS</name></expr></argument>)</argument_list></call> &amp;&amp; <call><name>defined</name><argument_list>(<argument><expr><name>HAVE_SYS_STATVFS_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"statvfs"</expr>, <expr><name>posix_statvfs</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>posix_statvfs__doc__</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_TMPFILE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"tmpfile"</expr>, <expr><name>posix_tmpfile</name></expr>, <expr><name>METH_NOARGS</name></expr>, <expr><name>posix_tmpfile__doc__</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_TEMPNAM</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"tempnam"</expr>, <expr><name>posix_tempnam</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>posix_tempnam__doc__</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_TMPNAM</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"tmpnam"</expr>, <expr><name>posix_tmpnam</name></expr>, <expr><name>METH_NOARGS</name></expr>, <expr><name>posix_tmpnam__doc__</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_CONFSTR</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"confstr"</expr>, <expr><name>posix_confstr</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>posix_confstr__doc__</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_SYSCONF</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"sysconf"</expr>, <expr><name>posix_sysconf</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>posix_sysconf__doc__</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_FPATHCONF</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"fpathconf"</expr>, <expr><name>posix_fpathconf</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>posix_fpathconf__doc__</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_PATHCONF</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"pathconf"</expr>, <expr><name>posix_pathconf</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>posix_pathconf__doc__</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr><block>{<expr>"abort"</expr>, <expr><name>posix_abort</name></expr>, <expr><name>METH_NOARGS</name></expr>, <expr><name>posix_abort__doc__</name></expr>}</block></expr>,
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MS_WINDOWS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"_getfullpathname"</expr>, <expr><name>posix__getfullpathname</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>NULL</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_GETLOADAVG</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"getloadavg"</expr>, <expr><name>posix_getloadavg</name></expr>, <expr><name>METH_NOARGS</name></expr>, <expr><name>posix_getloadavg__doc__</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MS_WINDOWS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"urandom"</expr>, <expr><name>win32_urandom</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>win32_urandom__doc__</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__VMS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"urandom"</expr>, <expr><name>vms_urandom</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>vms_urandom__doc__</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr><block>{<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>}</block></expr>
}</block></expr></init></decl>;</decl_stmt>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>ins</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>module</name></decl></param>, <param><decl><type><name>char</name> *</type><name>symbol</name></decl></param>, <param><decl><type><name>long</name></type> <name>value</name></decl></param>)</parameter_list> <block>{
<return>return <expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>module</name></expr></argument>, <argument><expr><name>symbol</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>PYOS_OS2</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function><type><specifier>static</specifier> <name>int</name></type> <name>insertvalues</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>module</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>APIRET</name></type> <name>rc</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ULONG</name></type> <name><name>values</name><index>[<expr><name>QSV_MAX</name>+1</expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>v</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>ver</name></decl>, <decl><type ref="prev"/><name><name>tmp</name><index>[<expr>50</expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_BEGIN_ALLOW_THREADS</name></type>
<name>rc</name> <init>= <expr><call><name>DosQuerySysInfo</name><argument_list>(<argument><expr>1L</expr></argument>, <argument><expr><name>QSV_MAX</name></expr></argument>, <argument><expr>&amp;<name><name>values</name><index>[<expr>1</expr>]</index></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ULONG</name></expr></argument>)</argument_list></sizeof> * <name>QSV_MAX</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<macro><name>Py_END_ALLOW_THREADS</name></macro>
<if>if <condition>(<expr><name>rc</name> != <name>NO_ERROR</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>os2_error</name><argument_list>(<argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>-1</expr>;</return>
}</block></then></if>
<if>if <condition>(<expr><call><name>ins</name><argument_list>(<argument><expr><name>module</name></expr></argument>, <argument><expr>"meminstalled"</expr></argument>, <argument><expr><name><name>values</name><index>[<expr><name>QSV_TOTPHYSMEM</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr>-1</expr>;</return></then></if>
<if>if <condition>(<expr><call><name>ins</name><argument_list>(<argument><expr><name>module</name></expr></argument>, <argument><expr>"memkernel"</expr></argument>, <argument><expr><name><name>values</name><index>[<expr><name>QSV_TOTRESMEM</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr>-1</expr>;</return></then></if>
<if>if <condition>(<expr><call><name>ins</name><argument_list>(<argument><expr><name>module</name></expr></argument>, <argument><expr>"memvirtual"</expr></argument>, <argument><expr><name><name>values</name><index>[<expr><name>QSV_TOTAVAILMEM</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr>-1</expr>;</return></then></if>
<if>if <condition>(<expr><call><name>ins</name><argument_list>(<argument><expr><name>module</name></expr></argument>, <argument><expr>"maxpathlen"</expr></argument>, <argument><expr><name><name>values</name><index>[<expr><name>QSV_MAX_PATH_LENGTH</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr>-1</expr>;</return></then></if>
<if>if <condition>(<expr><call><name>ins</name><argument_list>(<argument><expr><name>module</name></expr></argument>, <argument><expr>"maxnamelen"</expr></argument>, <argument><expr><name><name>values</name><index>[<expr><name>QSV_MAX_COMP_LENGTH</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr>-1</expr>;</return></then></if>
<if>if <condition>(<expr><call><name>ins</name><argument_list>(<argument><expr><name>module</name></expr></argument>, <argument><expr>"revision"</expr></argument>, <argument><expr><name><name>values</name><index>[<expr><name>QSV_VERSION_REVISION</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr>-1</expr>;</return></then></if>
<if>if <condition>(<expr><call><name>ins</name><argument_list>(<argument><expr><name>module</name></expr></argument>, <argument><expr>"timeslice"</expr></argument>, <argument><expr><name><name>values</name><index>[<expr><name>QSV_MIN_SLICE</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr>-1</expr>;</return></then></if>
<switch>switch <condition>(<expr><name><name>values</name><index>[<expr><name>QSV_VERSION_MINOR</name></expr>]</index></name></expr>)</condition> <block>{
<case>case <expr>0</expr>:
<expr_stmt><expr><name>ver</name> = "2.00"</expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr>10</expr>:
<expr_stmt><expr><name>ver</name> = "2.10"</expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr>11</expr>:
<expr_stmt><expr><name>ver</name> = "2.11"</expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr>30</expr>:
<expr_stmt><expr><name>ver</name> = "3.00"</expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr>40</expr>:
<expr_stmt><expr><name>ver</name> = "4.00"</expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr>50</expr>:
<expr_stmt><expr><name>ver</name> = "5.00"</expr>;</expr_stmt>
<break>break;</break>
</case><default>default:
<expr_stmt><expr><call><name>PyOS_snprintf</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></sizeof></expr></argument>,
<argument><expr>"%d-%d"</expr></argument>, <argument><expr><name><name>values</name><index>[<expr><name>QSV_VERSION_MAJOR</name></expr>]</index></name></expr></argument>,
<argument><expr><name><name>values</name><index>[<expr><name>QSV_VERSION_MINOR</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ver</name> = &amp;<name><name>tmp</name><index>[<expr>0</expr>]</index></name></expr>;</expr_stmt>
</default>}</block></switch>
<if>if <condition>(<expr><call><name>PyModule_AddStringConstant</name><argument_list>(<argument><expr><name>module</name></expr></argument>, <argument><expr>"version"</expr></argument>, <argument><expr><name>tmp</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
<return>return <expr>-1</expr>;</return></then></if>
<expr_stmt><expr><name><name>tmp</name><index>[<expr>0</expr>]</index></name> = 'A' + <name><name>values</name><index>[<expr><name>QSV_BOOT_DRIVE</name></expr>]</index></name> - 1</expr>;</expr_stmt>
<expr_stmt><expr><name><name>tmp</name><index>[<expr>1</expr>]</index></name> = ':'</expr>;</expr_stmt>
<expr_stmt><expr><name><name>tmp</name><index>[<expr>2</expr>]</index></name> = '\0'</expr>;</expr_stmt>
<return>return <expr><call><name>PyModule_AddStringConstant</name><argument_list>(<argument><expr><name>module</name></expr></argument>, <argument><expr>"bootdrive"</expr></argument>, <argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>all_ins</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>d</name></decl></param>)</parameter_list> <block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>F_OK</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if>if <condition>(<expr><call><name>ins</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr>"F_OK"</expr></argument>, <argument><expr>(<name>long</name>)<name>F_OK</name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr>-1</expr>;</return></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>R_OK</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if>if <condition>(<expr><call><name>ins</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr>"R_OK"</expr></argument>, <argument><expr>(<name>long</name>)<name>R_OK</name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr>-1</expr>;</return></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>W_OK</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if>if <condition>(<expr><call><name>ins</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr>"W_OK"</expr></argument>, <argument><expr>(<name>long</name>)<name>W_OK</name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr>-1</expr>;</return></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>X_OK</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if>if <condition>(<expr><call><name>ins</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr>"X_OK"</expr></argument>, <argument><expr>(<name>long</name>)<name>X_OK</name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr>-1</expr>;</return></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>NGROUPS_MAX</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if>if <condition>(<expr><call><name>ins</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr>"NGROUPS_MAX"</expr></argument>, <argument><expr>(<name>long</name>)<name>NGROUPS_MAX</name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr>-1</expr>;</return></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>TMP_MAX</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if>if <condition>(<expr><call><name>ins</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr>"TMP_MAX"</expr></argument>, <argument><expr>(<name>long</name>)<name>TMP_MAX</name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr>-1</expr>;</return></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>WCONTINUED</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if>if <condition>(<expr><call><name>ins</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr>"WCONTINUED"</expr></argument>, <argument><expr>(<name>long</name>)<name>WCONTINUED</name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr>-1</expr>;</return></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>WNOHANG</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if>if <condition>(<expr><call><name>ins</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr>"WNOHANG"</expr></argument>, <argument><expr>(<name>long</name>)<name>WNOHANG</name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr>-1</expr>;</return></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>WUNTRACED</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if>if <condition>(<expr><call><name>ins</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr>"WUNTRACED"</expr></argument>, <argument><expr>(<name>long</name>)<name>WUNTRACED</name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr>-1</expr>;</return></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>O_RDONLY</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if>if <condition>(<expr><call><name>ins</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr>"O_RDONLY"</expr></argument>, <argument><expr>(<name>long</name>)<name>O_RDONLY</name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr>-1</expr>;</return></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>O_WRONLY</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if>if <condition>(<expr><call><name>ins</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr>"O_WRONLY"</expr></argument>, <argument><expr>(<name>long</name>)<name>O_WRONLY</name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr>-1</expr>;</return></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>O_RDWR</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if>if <condition>(<expr><call><name>ins</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr>"O_RDWR"</expr></argument>, <argument><expr>(<name>long</name>)<name>O_RDWR</name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr>-1</expr>;</return></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>O_NDELAY</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if>if <condition>(<expr><call><name>ins</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr>"O_NDELAY"</expr></argument>, <argument><expr>(<name>long</name>)<name>O_NDELAY</name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr>-1</expr>;</return></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>O_NONBLOCK</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if>if <condition>(<expr><call><name>ins</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr>"O_NONBLOCK"</expr></argument>, <argument><expr>(<name>long</name>)<name>O_NONBLOCK</name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr>-1</expr>;</return></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>O_APPEND</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if>if <condition>(<expr><call><name>ins</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr>"O_APPEND"</expr></argument>, <argument><expr>(<name>long</name>)<name>O_APPEND</name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr>-1</expr>;</return></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>O_DSYNC</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if>if <condition>(<expr><call><name>ins</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr>"O_DSYNC"</expr></argument>, <argument><expr>(<name>long</name>)<name>O_DSYNC</name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr>-1</expr>;</return></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>O_RSYNC</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if>if <condition>(<expr><call><name>ins</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr>"O_RSYNC"</expr></argument>, <argument><expr>(<name>long</name>)<name>O_RSYNC</name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr>-1</expr>;</return></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>O_SYNC</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if>if <condition>(<expr><call><name>ins</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr>"O_SYNC"</expr></argument>, <argument><expr>(<name>long</name>)<name>O_SYNC</name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr>-1</expr>;</return></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>O_NOCTTY</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if>if <condition>(<expr><call><name>ins</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr>"O_NOCTTY"</expr></argument>, <argument><expr>(<name>long</name>)<name>O_NOCTTY</name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr>-1</expr>;</return></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>O_CREAT</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if>if <condition>(<expr><call><name>ins</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr>"O_CREAT"</expr></argument>, <argument><expr>(<name>long</name>)<name>O_CREAT</name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr>-1</expr>;</return></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>O_EXCL</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if>if <condition>(<expr><call><name>ins</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr>"O_EXCL"</expr></argument>, <argument><expr>(<name>long</name>)<name>O_EXCL</name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr>-1</expr>;</return></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>O_TRUNC</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if>if <condition>(<expr><call><name>ins</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr>"O_TRUNC"</expr></argument>, <argument><expr>(<name>long</name>)<name>O_TRUNC</name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr>-1</expr>;</return></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>O_BINARY</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if>if <condition>(<expr><call><name>ins</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr>"O_BINARY"</expr></argument>, <argument><expr>(<name>long</name>)<name>O_BINARY</name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr>-1</expr>;</return></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>O_TEXT</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if>if <condition>(<expr><call><name>ins</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr>"O_TEXT"</expr></argument>, <argument><expr>(<name>long</name>)<name>O_TEXT</name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr>-1</expr>;</return></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>O_LARGEFILE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if>if <condition>(<expr><call><name>ins</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr>"O_LARGEFILE"</expr></argument>, <argument><expr>(<name>long</name>)<name>O_LARGEFILE</name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr>-1</expr>;</return></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>O_SHLOCK</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if>if <condition>(<expr><call><name>ins</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr>"O_SHLOCK"</expr></argument>, <argument><expr>(<name>long</name>)<name>O_SHLOCK</name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr>-1</expr>;</return></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>O_EXLOCK</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if>if <condition>(<expr><call><name>ins</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr>"O_EXLOCK"</expr></argument>, <argument><expr>(<name>long</name>)<name>O_EXLOCK</name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr>-1</expr>;</return></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>O_NOINHERIT</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if>if <condition>(<expr><call><name>ins</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr>"O_NOINHERIT"</expr></argument>, <argument><expr>(<name>long</name>)<name>O_NOINHERIT</name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr>-1</expr>;</return></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_O_SHORT_LIVED</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if>if <condition>(<expr><call><name>ins</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr>"O_SHORT_LIVED"</expr></argument>, <argument><expr>(<name>long</name>)<name>_O_SHORT_LIVED</name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr>-1</expr>;</return></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>O_TEMPORARY</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if>if <condition>(<expr><call><name>ins</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr>"O_TEMPORARY"</expr></argument>, <argument><expr>(<name>long</name>)<name>O_TEMPORARY</name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr>-1</expr>;</return></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>O_RANDOM</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if>if <condition>(<expr><call><name>ins</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr>"O_RANDOM"</expr></argument>, <argument><expr>(<name>long</name>)<name>O_RANDOM</name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr>-1</expr>;</return></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>O_SEQUENTIAL</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if>if <condition>(<expr><call><name>ins</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr>"O_SEQUENTIAL"</expr></argument>, <argument><expr>(<name>long</name>)<name>O_SEQUENTIAL</name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr>-1</expr>;</return></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>O_ASYNC</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if>if <condition>(<expr><call><name>ins</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr>"O_ASYNC"</expr></argument>, <argument><expr>(<name>long</name>)<name>O_ASYNC</name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr>-1</expr>;</return></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>O_DIRECT</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if>if <condition>(<expr><call><name>ins</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr>"O_DIRECT"</expr></argument>, <argument><expr>(<name>long</name>)<name>O_DIRECT</name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr>-1</expr>;</return></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>O_DIRECTORY</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if>if <condition>(<expr><call><name>ins</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr>"O_DIRECTORY"</expr></argument>, <argument><expr>(<name>long</name>)<name>O_DIRECTORY</name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr>-1</expr>;</return></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>O_NOFOLLOW</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if>if <condition>(<expr><call><name>ins</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr>"O_NOFOLLOW"</expr></argument>, <argument><expr>(<name>long</name>)<name>O_NOFOLLOW</name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr>-1</expr>;</return></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>O_NOATIME</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if>if <condition>(<expr><call><name>ins</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr>"O_NOATIME"</expr></argument>, <argument><expr>(<name>long</name>)<name>O_NOATIME</name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr>-1</expr>;</return></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>EX_OK</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if>if <condition>(<expr><call><name>ins</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr>"EX_OK"</expr></argument>, <argument><expr>(<name>long</name>)<name>EX_OK</name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr>-1</expr>;</return></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>EX_USAGE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if>if <condition>(<expr><call><name>ins</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr>"EX_USAGE"</expr></argument>, <argument><expr>(<name>long</name>)<name>EX_USAGE</name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr>-1</expr>;</return></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>EX_DATAERR</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if>if <condition>(<expr><call><name>ins</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr>"EX_DATAERR"</expr></argument>, <argument><expr>(<name>long</name>)<name>EX_DATAERR</name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr>-1</expr>;</return></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>EX_NOINPUT</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if>if <condition>(<expr><call><name>ins</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr>"EX_NOINPUT"</expr></argument>, <argument><expr>(<name>long</name>)<name>EX_NOINPUT</name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr>-1</expr>;</return></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>EX_NOUSER</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if>if <condition>(<expr><call><name>ins</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr>"EX_NOUSER"</expr></argument>, <argument><expr>(<name>long</name>)<name>EX_NOUSER</name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr>-1</expr>;</return></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>EX_NOHOST</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if>if <condition>(<expr><call><name>ins</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr>"EX_NOHOST"</expr></argument>, <argument><expr>(<name>long</name>)<name>EX_NOHOST</name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr>-1</expr>;</return></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>EX_UNAVAILABLE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if>if <condition>(<expr><call><name>ins</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr>"EX_UNAVAILABLE"</expr></argument>, <argument><expr>(<name>long</name>)<name>EX_UNAVAILABLE</name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr>-1</expr>;</return></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>EX_SOFTWARE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if>if <condition>(<expr><call><name>ins</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr>"EX_SOFTWARE"</expr></argument>, <argument><expr>(<name>long</name>)<name>EX_SOFTWARE</name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr>-1</expr>;</return></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>EX_OSERR</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if>if <condition>(<expr><call><name>ins</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr>"EX_OSERR"</expr></argument>, <argument><expr>(<name>long</name>)<name>EX_OSERR</name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr>-1</expr>;</return></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>EX_OSFILE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if>if <condition>(<expr><call><name>ins</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr>"EX_OSFILE"</expr></argument>, <argument><expr>(<name>long</name>)<name>EX_OSFILE</name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr>-1</expr>;</return></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>EX_CANTCREAT</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if>if <condition>(<expr><call><name>ins</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr>"EX_CANTCREAT"</expr></argument>, <argument><expr>(<name>long</name>)<name>EX_CANTCREAT</name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr>-1</expr>;</return></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>EX_IOERR</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if>if <condition>(<expr><call><name>ins</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr>"EX_IOERR"</expr></argument>, <argument><expr>(<name>long</name>)<name>EX_IOERR</name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr>-1</expr>;</return></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>EX_TEMPFAIL</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if>if <condition>(<expr><call><name>ins</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr>"EX_TEMPFAIL"</expr></argument>, <argument><expr>(<name>long</name>)<name>EX_TEMPFAIL</name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr>-1</expr>;</return></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>EX_PROTOCOL</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if>if <condition>(<expr><call><name>ins</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr>"EX_PROTOCOL"</expr></argument>, <argument><expr>(<name>long</name>)<name>EX_PROTOCOL</name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr>-1</expr>;</return></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>EX_NOPERM</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if>if <condition>(<expr><call><name>ins</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr>"EX_NOPERM"</expr></argument>, <argument><expr>(<name>long</name>)<name>EX_NOPERM</name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr>-1</expr>;</return></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>EX_CONFIG</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if>if <condition>(<expr><call><name>ins</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr>"EX_CONFIG"</expr></argument>, <argument><expr>(<name>long</name>)<name>EX_CONFIG</name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr>-1</expr>;</return></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>EX_NOTFOUND</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if>if <condition>(<expr><call><name>ins</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr>"EX_NOTFOUND"</expr></argument>, <argument><expr>(<name>long</name>)<name>EX_NOTFOUND</name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr>-1</expr>;</return></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_SPAWNV</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>PYOS_OS2</name></expr></argument>)</argument_list></call> &amp;&amp; <call><name>defined</name><argument_list>(<argument><expr><name>PYCC_GCC</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if>if <condition>(<expr><call><name>ins</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr>"P_WAIT"</expr></argument>, <argument><expr>(<name>long</name>)<name>P_WAIT</name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr>-1</expr>;</return></then></if>
<if>if <condition>(<expr><call><name>ins</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr>"P_NOWAIT"</expr></argument>, <argument><expr>(<name>long</name>)<name>P_NOWAIT</name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr>-1</expr>;</return></then></if>
<if>if <condition>(<expr><call><name>ins</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr>"P_OVERLAY"</expr></argument>, <argument><expr>(<name>long</name>)<name>P_OVERLAY</name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr>-1</expr>;</return></then></if>
<if>if <condition>(<expr><call><name>ins</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr>"P_DEBUG"</expr></argument>, <argument><expr>(<name>long</name>)<name>P_DEBUG</name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr>-1</expr>;</return></then></if>
<if>if <condition>(<expr><call><name>ins</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr>"P_SESSION"</expr></argument>, <argument><expr>(<name>long</name>)<name>P_SESSION</name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr>-1</expr>;</return></then></if>
<if>if <condition>(<expr><call><name>ins</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr>"P_DETACH"</expr></argument>, <argument><expr>(<name>long</name>)<name>P_DETACH</name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr>-1</expr>;</return></then></if>
<if>if <condition>(<expr><call><name>ins</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr>"P_PM"</expr></argument>, <argument><expr>(<name>long</name>)<name>P_PM</name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr>-1</expr>;</return></then></if>
<if>if <condition>(<expr><call><name>ins</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr>"P_DEFAULT"</expr></argument>, <argument><expr>(<name>long</name>)<name>P_DEFAULT</name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr>-1</expr>;</return></then></if>
<if>if <condition>(<expr><call><name>ins</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr>"P_MINIMIZE"</expr></argument>, <argument><expr>(<name>long</name>)<name>P_MINIMIZE</name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr>-1</expr>;</return></then></if>
<if>if <condition>(<expr><call><name>ins</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr>"P_MAXIMIZE"</expr></argument>, <argument><expr>(<name>long</name>)<name>P_MAXIMIZE</name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr>-1</expr>;</return></then></if>
<if>if <condition>(<expr><call><name>ins</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr>"P_FULLSCREEN"</expr></argument>, <argument><expr>(<name>long</name>)<name>P_FULLSCREEN</name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr>-1</expr>;</return></then></if>
<if>if <condition>(<expr><call><name>ins</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr>"P_WINDOWED"</expr></argument>, <argument><expr>(<name>long</name>)<name>P_WINDOWED</name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr>-1</expr>;</return></then></if>
<if>if <condition>(<expr><call><name>ins</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr>"P_FOREGROUND"</expr></argument>, <argument><expr>(<name>long</name>)<name>P_FOREGROUND</name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr>-1</expr>;</return></then></if>
<if>if <condition>(<expr><call><name>ins</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr>"P_BACKGROUND"</expr></argument>, <argument><expr>(<name>long</name>)<name>P_BACKGROUND</name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr>-1</expr>;</return></then></if>
<if>if <condition>(<expr><call><name>ins</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr>"P_NOCLOSE"</expr></argument>, <argument><expr>(<name>long</name>)<name>P_NOCLOSE</name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr>-1</expr>;</return></then></if>
<if>if <condition>(<expr><call><name>ins</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr>"P_NOSESSION"</expr></argument>, <argument><expr>(<name>long</name>)<name>P_NOSESSION</name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr>-1</expr>;</return></then></if>
<if>if <condition>(<expr><call><name>ins</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr>"P_QUOTE"</expr></argument>, <argument><expr>(<name>long</name>)<name>P_QUOTE</name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr>-1</expr>;</return></then></if>
<if>if <condition>(<expr><call><name>ins</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr>"P_TILDE"</expr></argument>, <argument><expr>(<name>long</name>)<name>P_TILDE</name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr>-1</expr>;</return></then></if>
<if>if <condition>(<expr><call><name>ins</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr>"P_UNRELATED"</expr></argument>, <argument><expr>(<name>long</name>)<name>P_UNRELATED</name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr>-1</expr>;</return></then></if>
<if>if <condition>(<expr><call><name>ins</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr>"P_DEBUGDESC"</expr></argument>, <argument><expr>(<name>long</name>)<name>P_DEBUGDESC</name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr>-1</expr>;</return></then></if>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<if>if <condition>(<expr><call><name>ins</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr>"P_WAIT"</expr></argument>, <argument><expr>(<name>long</name>)<name>_P_WAIT</name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr>-1</expr>;</return></then></if>
<if>if <condition>(<expr><call><name>ins</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr>"P_NOWAIT"</expr></argument>, <argument><expr>(<name>long</name>)<name>_P_NOWAIT</name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr>-1</expr>;</return></then></if>
<if>if <condition>(<expr><call><name>ins</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr>"P_OVERLAY"</expr></argument>, <argument><expr>(<name>long</name>)<name>_OLD_P_OVERLAY</name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr>-1</expr>;</return></then></if>
<if>if <condition>(<expr><call><name>ins</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr>"P_NOWAITO"</expr></argument>, <argument><expr>(<name>long</name>)<name>_P_NOWAITO</name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr>-1</expr>;</return></then></if>
<if>if <condition>(<expr><call><name>ins</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr>"P_DETACH"</expr></argument>, <argument><expr>(<name>long</name>)<name>_P_DETACH</name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr>-1</expr>;</return></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>PYOS_OS2</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if>if <condition>(<expr><call><name>insertvalues</name><argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr>-1</expr>;</return></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<return>return <expr>0</expr>;</return>
}</block></function>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>(<call><name>defined</name><argument_list>(<argument><expr><name>_MSC_VER</name></expr></argument>)</argument_list></call> || <call><name>defined</name><argument_list>(<argument><expr><name>__WATCOMC__</name></expr></argument>)</argument_list></call> || <call><name>defined</name><argument_list>(<argument><expr><name>__BORLANDC__</name></expr></argument>)</argument_list></call>) &amp;&amp; !<call><name>defined</name><argument_list>(<argument><expr><name>__QNX__</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INITFUNC</name></cpp:macro> <cpp:value>initnt</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MODNAME</name></cpp:macro> <cpp:value>"nt"</cpp:value></cpp:define>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>PYOS_OS2</name></expr></argument>)</argument_list></call></expr></cpp:elif>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INITFUNC</name></cpp:macro> <cpp:value>initos2</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MODNAME</name></cpp:macro> <cpp:value>"os2"</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INITFUNC</name></cpp:macro> <cpp:value>initposix</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MODNAME</name></cpp:macro> <cpp:value>"posix"</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<function><type><name>PyMODINIT_FUNC</name></type>
<name>INITFUNC</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>m</name></decl>, *<decl><type ref="prev"/><name>v</name></decl>;</decl_stmt>
<expr_stmt><expr><name>m</name> = <call><name>Py_InitModule3</name><argument_list>(<argument><expr><name>MODNAME</name></expr></argument>,
<argument><expr><name>posix_methods</name></expr></argument>,
<argument><expr><name>posix__doc__</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>m</name> == <name>NULL</name></expr>)</condition><then>
<return>return;</return></then></if>
<expr_stmt><expr><name>v</name> = <call><name>convertenviron</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_XINCREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>v</name> == <name>NULL</name> || <call><name>PyModule_AddObject</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"environ"</expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call> != 0</expr>)</condition><then>
<return>return;</return></then></if>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>all_ins</name><argument_list>(<argument><expr><name>m</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return;</return></then></if>
<if>if <condition>(<expr><call><name>setup_confname_tables</name><argument_list>(<argument><expr><name>m</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return;</return></then></if>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>PyExc_OSError</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyModule_AddObject</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"error"</expr></argument>, <argument><expr><name>PyExc_OSError</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_PUTENV</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if>if <condition>(<expr><name>posix_putenv_garbage</name> == <name>NULL</name></expr>)</condition><then>
<expr_stmt><expr><name>posix_putenv_garbage</name> = <call><name>PyDict_New</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<if>if <condition>(<expr>!<name>initialized</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>stat_result_desc</name>.<name>name</name></name> = <name>MODNAME</name> ".stat_result"</expr>;</expr_stmt>
<expr_stmt><expr><name><name>stat_result_desc</name>.<name>fields</name><index>[<expr>7</expr>]</index></name>.<name>name</name> = <name>PyStructSequence_UnnamedField</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>stat_result_desc</name>.<name>fields</name><index>[<expr>8</expr>]</index></name>.<name>name</name> = <name>PyStructSequence_UnnamedField</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>stat_result_desc</name>.<name>fields</name><index>[<expr>9</expr>]</index></name>.<name>name</name> = <name>PyStructSequence_UnnamedField</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyStructSequence_InitType</name><argument_list>(<argument><expr>&amp;<name>StatResultType</name></expr></argument>, <argument><expr>&amp;<name>stat_result_desc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>structseq_new</name> = <name><name>StatResultType</name>.<name>tp_new</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>StatResultType</name>.<name>tp_new</name></name> = <name>statresult_new</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>statvfs_result_desc</name>.<name>name</name></name> = <name>MODNAME</name> ".statvfs_result"</expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyStructSequence_InitType</name><argument_list>(<argument><expr>&amp;<name>StatVFSResultType</name></expr></argument>, <argument><expr>&amp;<name>statvfs_result_desc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr>(<name>PyObject</name>*) &amp;<name>StatResultType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyModule_AddObject</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"stat_result"</expr></argument>, <argument><expr>(<name>PyObject</name>*) &amp;<name>StatResultType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr>(<name>PyObject</name>*) &amp;<name>StatVFSResultType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyModule_AddObject</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"statvfs_result"</expr></argument>,
<argument><expr>(<name>PyObject</name>*) &amp;<name>StatVFSResultType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>initialized</name> = 1</expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__APPLE__</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_FSTATVFS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if>if <condition>(<expr><name>fstatvfs</name> == <name>NULL</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr><call><name>PyObject_DelAttrString</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"fstatvfs"</expr></argument>)</argument_list></call> == -1</expr>)</condition><then> <block>{
<return>return;</return>
}</block></then></if>
}</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_STATVFS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if>if <condition>(<expr><name>statvfs</name> == <name>NULL</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr><call><name>PyObject_DelAttrString</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"statvfs"</expr></argument>)</argument_list></call> == -1</expr>)</condition><then> <block>{
<return>return;</return>
}</block></then></if>
}</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_LCHOWN</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if>if <condition>(<expr><name>lchown</name> == <name>NULL</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr><call><name>PyObject_DelAttrString</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"lchown"</expr></argument>)</argument_list></call> == -1</expr>)</condition><then> <block>{
<return>return;</return>
}</block></then></if>
}</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></function>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__cplusplus</name></expr></argument>)</argument_list></call></expr></cpp:if>
}
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</unit>
