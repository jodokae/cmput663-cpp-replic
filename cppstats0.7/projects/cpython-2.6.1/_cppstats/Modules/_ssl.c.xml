<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C" filename="projects/cpython-2.6.1/_cppstats/Modules/_ssl.c"><cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"Python.h"</cpp:file></cpp:include>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>WITH_THREAD</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pythread.h"</cpp:file></cpp:include>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PySSL_BEGIN_ALLOW_THREADS</name></cpp:macro> <cpp:value>{ PyThreadState *_save = NULL; if (_ssl_locks_count&gt;0) {_save = PyEval_SaveThread();}</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PySSL_BLOCK_THREADS</name></cpp:macro> <cpp:value>if (_ssl_locks_count&gt;0){PyEval_RestoreThread(_save)};</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PySSL_UNBLOCK_THREADS</name></cpp:macro> <cpp:value>if (_ssl_locks_count&gt;0){_save = PyEval_SaveThread()};</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PySSL_END_ALLOW_THREADS</name></cpp:macro> <cpp:value>if (_ssl_locks_count&gt;0){PyEval_RestoreThread(_save);} }</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PySSL_BEGIN_ALLOW_THREADS</name></cpp:macro></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PySSL_BLOCK_THREADS</name></cpp:macro></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PySSL_UNBLOCK_THREADS</name></cpp:macro></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PySSL_END_ALLOW_THREADS</name></cpp:macro></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<enum>enum <name>py_ssl_error</name> <block>{
<decl><name>PY_SSL_ERROR_NONE</name></decl>,
<decl><name>PY_SSL_ERROR_SSL</name></decl>,
<decl><name>PY_SSL_ERROR_WANT_READ</name></decl>,
<decl><name>PY_SSL_ERROR_WANT_WRITE</name></decl>,
<decl><name>PY_SSL_ERROR_WANT_X509_LOOKUP</name></decl>,
<decl><name>PY_SSL_ERROR_SYSCALL</name></decl>,
<decl><name>PY_SSL_ERROR_ZERO_RETURN</name></decl>,
<decl><name>PY_SSL_ERROR_WANT_CONNECT</name></decl>,
<decl><name>PY_SSL_ERROR_EOF</name></decl>,
<decl><name>PY_SSL_ERROR_INVALID_ERROR_CODE</name></decl>
}</block>;</enum>
<enum>enum <name>py_ssl_server_or_client</name> <block>{
<decl><name>PY_SSL_CLIENT</name></decl>,
<decl><name>PY_SSL_SERVER</name></decl>
}</block>;</enum>
<enum>enum <name>py_ssl_cert_requirements</name> <block>{
<decl><name>PY_SSL_CERT_NONE</name></decl>,
<decl><name>PY_SSL_CERT_OPTIONAL</name></decl>,
<decl><name>PY_SSL_CERT_REQUIRED</name></decl>
}</block>;</enum>
<enum>enum <name>py_ssl_version</name> <block>{
<decl><name>PY_SSL_VERSION_SSL2</name></decl>,
<decl><name>PY_SSL_VERSION_SSL3</name></decl>,
<decl><name>PY_SSL_VERSION_SSL23</name></decl>,
<decl><name>PY_SSL_VERSION_TLS1</name></decl>,
}</block>;</enum>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"socketmodule.h"</cpp:file></cpp:include>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_POLL_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;poll.h&gt;</cpp:file></cpp:include>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_SYS_POLL_H</name></expr></argument>)</argument_list></call></expr></cpp:elif>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/poll.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"openssl/rsa.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"openssl/crypto.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"openssl/x509.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"openssl/x509v3.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"openssl/pem.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"openssl/ssl.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"openssl/err.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"openssl/rand.h"</cpp:file></cpp:include>
<decl_stmt><decl><type><specifier>static</specifier> <name>PyObject</name> *</type><name>PySSLErrorObject</name></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>WITH_THREAD</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><specifier>static</specifier> <name>unsigned</name> <name>int</name></type> <name>_ssl_locks_count</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>X509_NAME_MAXLEN</name></cpp:macro> <cpp:value>256</cpp:value></cpp:define>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPENSSL_VERSION_NUMBER</name> &gt;= 0x0090500fL</expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HAVE_OPENSSL_RAND</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>HAVE_OPENSSL_RAND</name></cpp:undef>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<typedef>typedef <type><struct>struct <block>{
<decl_stmt><decl><type><name>PyObject_HEAD</name>
<name>PySocketSockObject</name> *</type><name>Socket</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>SSL_CTX</name>*</type> <name>ctx</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>SSL</name>*</type> <name>ssl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>X509</name>*</type> <name>peer_cert</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name><name>server</name><index>[<expr><name>X509_NAME_MAXLEN</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name><name>issuer</name><index>[<expr><name>X509_NAME_MAXLEN</name></expr>]</index></name></decl>;</decl_stmt>
}</block></struct></type> <name>PySSLObject</name>;</typedef>
<decl_stmt><decl><type><specifier>static</specifier> <name>PyTypeObject</name></type> <name>PySSL_Type</name></decl>;</decl_stmt>
<function_decl><type><specifier>static</specifier> <name>PyObject</name> *</type><name>PySSL_SSLwrite</name><parameter_list>(<param><decl><type><name>PySSLObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>PyObject</name> *</type><name>PySSL_SSLread</name><parameter_list>(<param><decl><type><name>PySSLObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>check_socket_and_wait_for_timeout</name><parameter_list>(<param><decl><type><name>PySocketSockObject</name> *</type><name>s</name></decl></param>,
<param><decl><type><name>int</name></type> <name>writing</name></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>PyObject</name> *</type><name>PySSL_peercert</name><parameter_list>(<param><decl><type><name>PySSLObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>PyObject</name> *</type><name>PySSL_cipher</name><parameter_list>(<param><decl><type><name>PySSLObject</name> *</type><name>self</name></decl></param>)</parameter_list>;</function_decl>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PySSLObject_Check</name><parameter_list>(<param><type><name>v</name></type></param>)</parameter_list></cpp:macro> <cpp:value>(Py_TYPE(v) == &amp;PySSL_Type)</cpp:value></cpp:define>
<typedef>typedef <type><enum>enum <block>{
<decl><name>SOCKET_IS_NONBLOCKING</name></decl>,
<decl><name>SOCKET_IS_BLOCKING</name></decl>,
<decl><name>SOCKET_HAS_TIMED_OUT</name></decl>,
<decl><name>SOCKET_HAS_BEEN_CLOSED</name></decl>,
<decl><name>SOCKET_TOO_LARGE_FOR_SELECT</name></decl>,
<decl><name>SOCKET_OPERATION_OK</name></decl>
}</block></enum></type> <name>timeout_state</name>;</typedef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>STRINGIFY1</name><parameter_list>(<param><type><name>x</name></type></param>)</parameter_list></cpp:macro> <cpp:value>#x</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>STRINGIFY2</name><parameter_list>(<param><type><name>x</name></type></param>)</parameter_list></cpp:macro> <cpp:value>STRINGIFY1(x)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ERRSTR1</name><parameter_list>(<param><type><name>x</name></type></param>,<param><type><name>y</name></type></param>,<param><type><name>z</name></type></param>)</parameter_list></cpp:macro> <cpp:value>(x ":" y ": " z)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ERRSTR</name><parameter_list>(<param><type><name>x</name></type></param>)</parameter_list></cpp:macro> <cpp:value>ERRSTR1("_ssl.c", STRINGIFY2(__LINE__), x)</cpp:value></cpp:define>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>PySSL_SetError</name><parameter_list>(<param><decl><type><name>PySSLObject</name> *</type><name>obj</name></decl></param>, <param><decl><type><name>int</name></type> <name>ret</name></decl></param>, <param><decl><type><name>char</name> *</type><name>filename</name></decl></param>, <param><decl><type><name>int</name></type> <name>lineno</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>v</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name><name>buf</name><index>[<expr>2048</expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>errstr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>err</name></decl>;</decl_stmt>
<enum>enum <name>py_ssl_error</name> <name>p</name> <expr_stmt><expr>= <name>PY_SSL_ERROR_NONE</name></expr>;</expr_stmt></enum>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>ret</name> &lt;= 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>obj</name>-&gt;<name>ssl</name></name> != <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>err</name> = <call><name>SSL_get_error</name><argument_list>(<argument><expr><name><name>obj</name>-&gt;<name>ssl</name></name></expr></argument>, <argument><expr><name>ret</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<switch>switch <condition>(<expr><name>err</name></expr>)</condition> <block>{
<case>case <expr><name>SSL_ERROR_ZERO_RETURN</name></expr>:
<expr_stmt><expr><name>errstr</name> = "TLS/SSL connection has been closed"</expr>;</expr_stmt>
<expr_stmt><expr><name>p</name> = <name>PY_SSL_ERROR_ZERO_RETURN</name></expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr><name>SSL_ERROR_WANT_READ</name></expr>:
<expr_stmt><expr><name>errstr</name> = "The operation did not complete (read)"</expr>;</expr_stmt>
<expr_stmt><expr><name>p</name> = <name>PY_SSL_ERROR_WANT_READ</name></expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr><name>SSL_ERROR_WANT_WRITE</name></expr>:
<expr_stmt><expr><name>p</name> = <name>PY_SSL_ERROR_WANT_WRITE</name></expr>;</expr_stmt>
<expr_stmt><expr><name>errstr</name> = "The operation did not complete (write)"</expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr><name>SSL_ERROR_WANT_X509_LOOKUP</name></expr>:
<expr_stmt><expr><name>p</name> = <name>PY_SSL_ERROR_WANT_X509_LOOKUP</name></expr>;</expr_stmt>
<expr_stmt><expr><name>errstr</name> =
"The operation did not complete (X509 lookup)"</expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr><name>SSL_ERROR_WANT_CONNECT</name></expr>:
<expr_stmt><expr><name>p</name> = <name>PY_SSL_ERROR_WANT_CONNECT</name></expr>;</expr_stmt>
<expr_stmt><expr><name>errstr</name> = "The operation did not complete (connect)"</expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr><name>SSL_ERROR_SYSCALL</name></expr>: <block>{
<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>e</name> <init>= <expr><call><name>ERR_get_error</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>e</name> == 0</expr>)</condition><then> <block>{
<if>if <condition>(<expr><name>ret</name> == 0 || !<name><name>obj</name>-&gt;<name>Socket</name></name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>p</name> = <name>PY_SSL_ERROR_EOF</name></expr>;</expr_stmt>
<expr_stmt><expr><name>errstr</name> =
"EOF occurred in violation of protocol"</expr>;</expr_stmt>
}</block></then> <else>else <if>if <condition>(<expr><name>ret</name> == -1</expr>)</condition><then> <block>{
<return>return <expr><call><name><name>obj</name>-&gt;<name>Socket</name>-&gt;<name>errorhandler</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block></then> <else>else <block>{
<expr_stmt><expr><name>p</name> = <name>PY_SSL_ERROR_SYSCALL</name></expr>;</expr_stmt>
<expr_stmt><expr><name>errstr</name> = "Some I/O error occurred"</expr>;</expr_stmt>
}</block></else></if></else></if>
}</block></then> <else>else <block>{
<expr_stmt><expr><name>p</name> = <name>PY_SSL_ERROR_SYSCALL</name></expr>;</expr_stmt>
<expr_stmt><expr><name>errstr</name> = <call><name>ERR_error_string</name><argument_list>(<argument><expr><name>e</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></else></if>
<break>break;</break>
}</block>
</case><case>case <expr><name>SSL_ERROR_SSL</name></expr>: <block>{
<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>e</name> <init>= <expr><call><name>ERR_get_error</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>p</name> = <name>PY_SSL_ERROR_SSL</name></expr>;</expr_stmt>
<if>if <condition>(<expr><name>e</name> != 0</expr>)</condition><then>
<expr_stmt><expr><name>errstr</name> = <call><name>ERR_error_string</name><argument_list>(<argument><expr><name>e</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
<else>else <block>{
<expr_stmt><expr><name>errstr</name> =
"A failure in the SSL library occurred"</expr>;</expr_stmt>
}</block></else></if>
<break>break;</break>
}</block>
</case><default>default:
<expr_stmt><expr><name>p</name> = <name>PY_SSL_ERROR_INVALID_ERROR_CODE</name></expr>;</expr_stmt>
<expr_stmt><expr><name>errstr</name> = "Invalid error code"</expr>;</expr_stmt>
</default>}</block></switch>
}</block></then> <else>else <block>{
<expr_stmt><expr><name>errstr</name> = <call><name>ERR_error_string</name><argument_list>(<argument><expr><call><name>ERR_peek_last_error</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></else></if>
<expr_stmt><expr><call><name>PyOS_snprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr>"_ssl.c:%d: %s"</expr></argument>, <argument><expr><name>lineno</name></expr></argument>, <argument><expr><name>errstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>v</name> = <call><name>Py_BuildValue</name><argument_list>(<argument><expr>"(is)"</expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>v</name> != <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetObject</name><argument_list>(<argument><expr><name>PySSLErrorObject</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>_setSSLError</name> <parameter_list>(<param><decl><type><name>char</name> *</type><name>errstr</name></decl></param>, <param><decl><type><name>int</name></type> <name>errcode</name></decl></param>, <param><decl><type><name>char</name> *</type><name>filename</name></decl></param>, <param><decl><type><name>int</name></type> <name>lineno</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>char</name></type> <name><name>buf</name><index>[<expr>2048</expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>v</name></decl>;</decl_stmt>
<if>if <condition>(<expr><name>errstr</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>errcode</name> = <call><name>ERR_peek_last_error</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>errstr</name> = <call><name>ERR_error_string</name><argument_list>(<argument><expr><name>errcode</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><call><name>PyOS_snprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr>"_ssl.c:%d: %s"</expr></argument>, <argument><expr><name>lineno</name></expr></argument>, <argument><expr><name>errstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>v</name> = <call><name>Py_BuildValue</name><argument_list>(<argument><expr>"(is)"</expr></argument>, <argument><expr><name>errcode</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>v</name> != <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetObject</name><argument_list>(<argument><expr><name>PySSLErrorObject</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></function>
<decl_stmt><decl><type><specifier>static</specifier> <name>PySSLObject</name> *</type>
<name>newPySSLObject</name><argument_list>(<argument><expr><name>PySocketSockObject</name> *<name>Sock</name></expr></argument>, <argument><expr><name>char</name> *<name>key_file</name></expr></argument>, <argument><expr><name>char</name> *<name>cert_file</name></expr></argument>,
<argument>enum <expr><name>py_ssl_server_or_client</name> <name>socket_type</name></expr></argument>,
<argument>enum <expr><name>py_ssl_cert_requirements</name> <name>certreq</name></expr></argument>,
<argument>enum <expr><name>py_ssl_version</name> <name>proto_version</name></expr></argument>,
<argument><expr><name>char</name> *<name>cacerts_file</name></expr></argument>)</argument_list> <block>{
<decl_stmt><decl><type><name>PySSLObject</name> *</type><name>self</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>errstr</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>verification_mode</name></decl>;</decl_stmt>
<expr_stmt><expr><name>self</name> = <call><name>PyObject_New</name><argument_list>(<argument><expr><name>PySSLObject</name></expr></argument>, <argument><expr>&amp;<name>PySSL_Type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>self</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>server</name></name></expr></argument>, <argument><expr>'\0'</expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>char</name></expr></argument>)</argument_list></sizeof> * <name>X509_NAME_MAXLEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>issuer</name></name></expr></argument>, <argument><expr>'\0'</expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>char</name></expr></argument>)</argument_list></sizeof> * <name>X509_NAME_MAXLEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>self</name>-&gt;<name>peer_cert</name></name> = <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>self</name>-&gt;<name>ssl</name></name> = <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>self</name>-&gt;<name>ctx</name></name> = <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>self</name>-&gt;<name>Socket</name></name> = <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr>(<name>void</name>) <call><name>ERR_get_state</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ERR_clear_error</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>(<name>key_file</name> &amp;&amp; !<name>cert_file</name>) || (!<name>key_file</name> &amp;&amp; <name>cert_file</name>)</expr>)</condition><then> <block>{
<expr_stmt><expr><name>errstr</name> = <call><name>ERRSTR</name><argument_list>(<argument><expr>"Both the key &amp; certificate files "
"must be specified"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>fail</name>;</goto>
}</block></then></if>
<if>if <condition>(<expr>(<name>socket_type</name> == <name>PY_SSL_SERVER</name>) &amp;&amp;
((<name>key_file</name> == <name>NULL</name>) || (<name>cert_file</name> == <name>NULL</name>))</expr>)</condition><then> <block>{
<expr_stmt><expr><name>errstr</name> = <call><name>ERRSTR</name><argument_list>(<argument><expr>"Both the key &amp; certificate files "
"must be specified for server-side operation"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>fail</name>;</goto>
}</block></then></if>
<macro><name>PySSL_BEGIN_ALLOW_THREADS</name></macro>
<if>if <condition>(<expr><name>proto_version</name> == <name>PY_SSL_VERSION_TLS1</name></expr>)</condition><then>
<expr_stmt><expr><name><name>self</name>-&gt;<name>ctx</name></name> = <call><name>SSL_CTX_new</name><argument_list>(<argument><expr><call><name>TLSv1_method</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
<else>else <if>if <condition>(<expr><name>proto_version</name> == <name>PY_SSL_VERSION_SSL3</name></expr>)</condition><then>
<expr_stmt><expr><name><name>self</name>-&gt;<name>ctx</name></name> = <call><name>SSL_CTX_new</name><argument_list>(<argument><expr><call><name>SSLv3_method</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
<else>else <if>if <condition>(<expr><name>proto_version</name> == <name>PY_SSL_VERSION_SSL2</name></expr>)</condition><then>
<expr_stmt><expr><name><name>self</name>-&gt;<name>ctx</name></name> = <call><name>SSL_CTX_new</name><argument_list>(<argument><expr><call><name>SSLv2_method</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
<else>else <if>if <condition>(<expr><name>proto_version</name> == <name>PY_SSL_VERSION_SSL23</name></expr>)</condition><then>
<expr_stmt><expr><name><name>self</name>-&gt;<name>ctx</name></name> = <call><name>SSL_CTX_new</name><argument_list>(<argument><expr><call><name>SSLv23_method</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if></else></if></else></if></else></if>
<macro><name>PySSL_END_ALLOW_THREADS</name></macro>
<if>if <condition>(<expr><name><name>self</name>-&gt;<name>ctx</name></name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>errstr</name> = <call><name>ERRSTR</name><argument_list>(<argument><expr>"Invalid SSL protocol variant specified."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>fail</name>;</goto>
}</block></then></if>
<if>if <condition>(<expr><name>certreq</name> != <name>PY_SSL_CERT_NONE</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr><name>cacerts_file</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>errstr</name> = <call><name>ERRSTR</name><argument_list>(<argument><expr>"No root certificates specified for "
"verification of other-side certificates."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>fail</name>;</goto>
}</block></then> <else>else <block>{
<decl_stmt><decl><type><name>PySSL_BEGIN_ALLOW_THREADS</name></type>
<name>ret</name> <init>= <expr><call><name>SSL_CTX_load_verify_locations</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>ctx</name></name></expr></argument>,
<argument><expr><name>cacerts_file</name></expr></argument>,
<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<macro><name>PySSL_END_ALLOW_THREADS</name></macro>
<if>if <condition>(<expr><name>ret</name> != 1</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>_setSSLError</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>__FILE__</name></expr></argument>, <argument><expr><name>__LINE__</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>fail</name>;</goto>
}</block></then></if>
}</block></else></if>
}</block></then></if>
<if>if <condition>(<expr><name>key_file</name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>PySSL_BEGIN_ALLOW_THREADS</name></type>
<name>ret</name> <init>= <expr><call><name>SSL_CTX_use_PrivateKey_file</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>ctx</name></name></expr></argument>, <argument><expr><name>key_file</name></expr></argument>,
<argument><expr><name>SSL_FILETYPE_PEM</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<macro><name>PySSL_END_ALLOW_THREADS</name></macro>
<if>if <condition>(<expr><name>ret</name> != 1</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>_setSSLError</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>ret</name></expr></argument>, <argument><expr><name>__FILE__</name></expr></argument>, <argument><expr><name>__LINE__</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>fail</name>;</goto>
}</block></then></if>
<decl_stmt><decl><type><name>PySSL_BEGIN_ALLOW_THREADS</name></type>
<name>ret</name> <init>= <expr><call><name>SSL_CTX_use_certificate_chain_file</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>ctx</name></name></expr></argument>,
<argument><expr><name>cert_file</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<macro><name>PySSL_END_ALLOW_THREADS</name></macro>
<if>if <condition>(<expr><name>ret</name> != 1</expr>)</condition><then> <block>{
<if>if <condition>(<expr><call><name>ERR_peek_last_error</name><argument_list>()</argument_list></call> != 0</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>_setSSLError</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>ret</name></expr></argument>, <argument><expr><name>__FILE__</name></expr></argument>, <argument><expr><name>__LINE__</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>fail</name>;</goto>
}</block></then></if>
}</block></then></if>
}</block></then></if>
<expr_stmt><expr><call><name>SSL_CTX_set_options</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>ctx</name></name></expr></argument>, <argument><expr><name>SSL_OP_ALL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>verification_mode</name> = <name>SSL_VERIFY_NONE</name></expr>;</expr_stmt>
<if>if <condition>(<expr><name>certreq</name> == <name>PY_SSL_CERT_OPTIONAL</name></expr>)</condition><then>
<expr_stmt><expr><name>verification_mode</name> = <name>SSL_VERIFY_PEER</name></expr>;</expr_stmt></then>
<else>else <if>if <condition>(<expr><name>certreq</name> == <name>PY_SSL_CERT_REQUIRED</name></expr>)</condition><then>
<expr_stmt><expr><name>verification_mode</name> = (<name>SSL_VERIFY_PEER</name> |
<name>SSL_VERIFY_FAIL_IF_NO_PEER_CERT</name>)</expr>;</expr_stmt></then></if></else></if>
<expr_stmt><expr><call><name>SSL_CTX_set_verify</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>ctx</name></name></expr></argument>, <argument><expr><name>verification_mode</name></expr></argument>,
<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>PySSL_BEGIN_ALLOW_THREADS</name></type>
<name><name>self</name>-&gt;<name>ssl</name></name> <init>= <expr><call><name>SSL_new</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>ctx</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<function_decl><type><name>PySSL_END_ALLOW_THREADS</name></type>
<name>SSL_set_fd</name><parameter_list>(<param><decl><type><name><name>self</name>-&gt;<name>ssl</name></name></type></decl></param>, <param><decl><type><name><name>Sock</name>-&gt;<name>sock_fd</name></name></type></decl></param>)</parameter_list>;</function_decl>
<if>if <condition>(<expr><name><name>Sock</name>-&gt;<name>sock_timeout</name></name> &gt;= 0.0</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>BIO_set_nbio</name><argument_list>(<argument><expr><call><name>SSL_get_rbio</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>ssl</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>BIO_set_nbio</name><argument_list>(<argument><expr><call><name>SSL_get_wbio</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>ssl</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<macro><name>PySSL_BEGIN_ALLOW_THREADS</name></macro>
<if>if <condition>(<expr><name>socket_type</name> == <name>PY_SSL_CLIENT</name></expr>)</condition><then>
<expr_stmt><expr><call><name>SSL_set_connect_state</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>ssl</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
<else>else
<expr_stmt><expr><call><name>SSL_set_accept_state</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>ssl</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
<decl_stmt><decl><type><name>PySSL_END_ALLOW_THREADS</name></type>
<name><name>self</name>-&gt;<name>Socket</name></name> <init>= <expr><name>Sock</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>Socket</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>self</name></expr>;</return>
<label><name>fail</name>:</label>
<if>if <condition>(<expr><name>errstr</name></expr>)</condition><then>
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PySSLErrorObject</name></expr></argument>, <argument><expr><name>errstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></decl></decl_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>PySSL_sslwrap</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PySocketSockObject</name> *</type><name>Sock</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>server_side</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>verification_mode</name> <init>= <expr><name>PY_SSL_CERT_NONE</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>protocol</name> <init>= <expr><name>PY_SSL_VERSION_SSL23</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>key_file</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>cert_file</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>cacerts_file</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"O!i|zziiz:sslwrap"</expr></argument>,
<argument><expr><name><name>PySocketModule</name>.<name>Sock_Type</name></name></expr></argument>,
<argument><expr>&amp;<name>Sock</name></expr></argument>,
<argument><expr>&amp;<name>server_side</name></expr></argument>,
<argument><expr>&amp;<name>key_file</name></expr></argument>, <argument><expr>&amp;<name>cert_file</name></expr></argument>,
<argument><expr>&amp;<name>verification_mode</name></expr></argument>, <argument><expr>&amp;<name>protocol</name></expr></argument>,
<argument><expr>&amp;<name>cacerts_file</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<return>return <expr>(<name>PyObject</name> *) <call><name>newPySSLObject</name><argument_list>(<argument><expr><name>Sock</name></expr></argument>, <argument><expr><name>key_file</name></expr></argument>, <argument><expr><name>cert_file</name></expr></argument>,
<argument><expr><name>server_side</name></expr></argument>, <argument><expr><name>verification_mode</name></expr></argument>,
<argument><expr><name>protocol</name></expr></argument>, <argument><expr><name>cacerts_file</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>ssl_doc</name></expr></argument>,
<argument><expr>"sslwrap(socket, server_side, [keyfile, certfile, certs_mode, protocol,\n"
" cacertsfile]) -&gt; sslobject"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type><name>PySSL_SSLdo_handshake</name><parameter_list>(<param><decl><type><name>PySSLObject</name> *</type><name>self</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>err</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>sockstate</name></decl>;</decl_stmt>
<expr_stmt><expr><name>sockstate</name> = 0</expr>;</expr_stmt>
<do>do <block>{
<decl_stmt><decl><type><name>PySSL_BEGIN_ALLOW_THREADS</name></type>
<name>ret</name> <init>= <expr><call><name>SSL_do_handshake</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>ssl</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>err</name> = <call><name>SSL_get_error</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>ssl</name></name></expr></argument>, <argument><expr><name>ret</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<macro><name>PySSL_END_ALLOW_THREADS</name></macro>
<if>if<condition>(<expr><call><name>PyErr_CheckSignals</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<if>if <condition>(<expr><name>err</name> == <name>SSL_ERROR_WANT_READ</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>sockstate</name> = <call><name>check_socket_and_wait_for_timeout</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>Socket</name></name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else <if>if <condition>(<expr><name>err</name> == <name>SSL_ERROR_WANT_WRITE</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>sockstate</name> = <call><name>check_socket_and_wait_for_timeout</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>Socket</name></name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr><name>sockstate</name> = <name>SOCKET_OPERATION_OK</name></expr>;</expr_stmt>
}</block></else></if></else></if>
<if>if <condition>(<expr><name>sockstate</name> == <name>SOCKET_HAS_TIMED_OUT</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PySSLErrorObject</name></expr></argument>,
<argument><expr><call><name>ERRSTR</name><argument_list>(<argument><expr>"The handshake operation timed out"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then> <else>else <if>if <condition>(<expr><name>sockstate</name> == <name>SOCKET_HAS_BEEN_CLOSED</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PySSLErrorObject</name></expr></argument>,
<argument><expr><call><name>ERRSTR</name><argument_list>(<argument><expr>"Underlying socket has been closed."</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then> <else>else <if>if <condition>(<expr><name>sockstate</name> == <name>SOCKET_TOO_LARGE_FOR_SELECT</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PySSLErrorObject</name></expr></argument>,
<argument><expr><call><name>ERRSTR</name><argument_list>(<argument><expr>"Underlying socket too large for select()."</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then> <else>else <if>if <condition>(<expr><name>sockstate</name> == <name>SOCKET_IS_NONBLOCKING</name></expr>)</condition><then> <block>{
<break>break;</break>
}</block></then></if></else></if></else></if></else></if>
}</block> while <condition>(<expr><name>err</name> == <name>SSL_ERROR_WANT_READ</name> || <name>err</name> == <name>SSL_ERROR_WANT_WRITE</name></expr>)</condition>;</do>
<if>if <condition>(<expr><name>ret</name> &lt; 1</expr>)</condition><then>
<return>return <expr><call><name>PySSL_SetError</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>ret</name></expr></argument>, <argument><expr><name>__FILE__</name></expr></argument>, <argument><expr><name>__LINE__</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
<expr_stmt><expr><name><name>self</name>-&gt;<name>ssl</name>-&gt;<name>debug</name></name> = 1</expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>self</name>-&gt;<name>peer_cert</name></name></expr>)</condition><then>
<expr_stmt><expr><call><name>X509_free</name> <argument_list>(<argument><expr><name><name>self</name>-&gt;<name>peer_cert</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<macro><name>PySSL_BEGIN_ALLOW_THREADS</name></macro>
<if>if <condition>(<expr>(<name><name>self</name>-&gt;<name>peer_cert</name></name> = <call><name>SSL_get_peer_certificate</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>ssl</name></name></expr></argument>)</argument_list></call>)</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>X509_NAME_oneline</name><argument_list>(<argument><expr><call><name>X509_get_subject_name</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>peer_cert</name></name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name><name>self</name>-&gt;<name>server</name></name></expr></argument>, <argument><expr><name>X509_NAME_MAXLEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>X509_NAME_oneline</name><argument_list>(<argument><expr><call><name>X509_get_issuer_name</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>peer_cert</name></name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name><name>self</name>-&gt;<name>issuer</name></name></expr></argument>, <argument><expr><name>X509_NAME_MAXLEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<function_decl><type><name>PySSL_END_ALLOW_THREADS</name></type>
<name>Py_INCREF</name><parameter_list>(<param><decl><type><name>Py_None</name></type></decl></param>)</parameter_list>;</function_decl>
<return>return <expr><name>Py_None</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>PySSL_server</name><parameter_list>(<param><decl><type><name>PySSLObject</name> *</type><name>self</name></decl></param>)</parameter_list> <block>{
<return>return <expr><call><name>PyString_FromString</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>server</name></name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>PySSL_issuer</name><parameter_list>(<param><decl><type><name>PySSLObject</name> *</type><name>self</name></decl></param>)</parameter_list> <block>{
<return>return <expr><call><name>PyString_FromString</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>issuer</name></name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>_create_tuple_for_attribute</name> <parameter_list>(<param><decl><type><name>ASN1_OBJECT</name> *</type><name>name</name></decl></param>, <param><decl><type><name>ASN1_STRING</name> *</type><name>value</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>char</name></type> <name><name>namebuf</name><index>[<expr><name>X509_NAME_MAXLEN</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>buflen</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>name_obj</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>value_obj</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>attr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name> *</type><name>valuebuf</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>buflen</name> = <call><name>OBJ_obj2txt</name><argument_list>(<argument><expr><name>namebuf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>namebuf</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>buflen</name> &lt; 0</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>_setSSLError</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>__FILE__</name></expr></argument>, <argument><expr><name>__LINE__</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>fail</name>;</goto>
}</block></then></if>
<expr_stmt><expr><name>name_obj</name> = <call><name>PyString_FromStringAndSize</name><argument_list>(<argument><expr><name>namebuf</name></expr></argument>, <argument><expr><name>buflen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>name_obj</name> == <name>NULL</name></expr>)</condition><then>
<goto>goto <name>fail</name>;</goto></then></if>
<expr_stmt><expr><name>buflen</name> = <call><name>ASN1_STRING_to_UTF8</name><argument_list>(<argument><expr>&amp;<name>valuebuf</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>buflen</name> &lt; 0</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>_setSSLError</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>__FILE__</name></expr></argument>, <argument><expr><name>__LINE__</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>name_obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>fail</name>;</goto>
}</block></then></if>
<expr_stmt><expr><name>value_obj</name> = <call><name>PyUnicode_DecodeUTF8</name><argument_list>(<argument><expr>(<name>char</name> *) <name>valuebuf</name></expr></argument>,
<argument><expr><name>buflen</name></expr></argument>, <argument><expr>"strict"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OPENSSL_free</name><argument_list>(<argument><expr><name>valuebuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>value_obj</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>name_obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>fail</name>;</goto>
}</block></then></if>
<expr_stmt><expr><name>attr</name> = <call><name>PyTuple_New</name><argument_list>(<argument><expr>2</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>attr</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>name_obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>value_obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>fail</name>;</goto>
}</block></then></if>
<expr_stmt><expr><call><name>PyTuple_SET_ITEM</name><argument_list>(<argument><expr><name>attr</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>name_obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyTuple_SET_ITEM</name><argument_list>(<argument><expr><name>attr</name></expr></argument>, <argument><expr>1</expr></argument>, <argument><expr><name>value_obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>attr</name></expr>;</return>
<label><name>fail</name>:</label>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>_create_tuple_for_X509_NAME</name> <parameter_list>(<param><decl><type><name>X509_NAME</name> *</type><name>xname</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>dn</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>rdn</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>rdnt</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>attr</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>entry_count</name> <init>= <expr><call><name>X509_NAME_entry_count</name><argument_list>(<argument><expr><name>xname</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>X509_NAME_ENTRY</name> *</type><name>entry</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ASN1_OBJECT</name> *</type><name>name</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ASN1_STRING</name> *</type><name>value</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>index_counter</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>rdn_level</name> <init>= <expr>-1</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>retcode</name></decl>;</decl_stmt>
<expr_stmt><expr><name>dn</name> = <call><name>PyList_New</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>dn</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>rdn</name> = <call><name>PyList_New</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>rdn</name> == <name>NULL</name></expr>)</condition><then>
<goto>goto <name>fail0</name>;</goto></then></if>
<for>for (<init><expr><name>index_counter</name> = 0</expr>;</init>
<condition><expr><name>index_counter</name> &lt; <name>entry_count</name></expr>;</condition>
<incr><expr><name>index_counter</name>++</expr></incr>) <block>{
<expr_stmt><expr><name>entry</name> = <call><name>X509_NAME_get_entry</name><argument_list>(<argument><expr><name>xname</name></expr></argument>, <argument><expr><name>index_counter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>rdn_level</name> &gt;= 0</expr>)</condition><then> <block>{
<if>if <condition>(<expr><name>rdn_level</name> != <name><name>entry</name>-&gt;<name>set</name></name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>rdnt</name> = <call><name>PyList_AsTuple</name><argument_list>(<argument><expr><name>rdn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>rdn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>rdnt</name> == <name>NULL</name></expr>)</condition><then>
<goto>goto <name>fail0</name>;</goto></then></if>
<expr_stmt><expr><name>retcode</name> = <call><name>PyList_Append</name><argument_list>(<argument><expr><name>dn</name></expr></argument>, <argument><expr><name>rdnt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>rdnt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>retcode</name> &lt; 0</expr>)</condition><then>
<goto>goto <name>fail0</name>;</goto></then></if>
<expr_stmt><expr><name>rdn</name> = <call><name>PyList_New</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>rdn</name> == <name>NULL</name></expr>)</condition><then>
<goto>goto <name>fail0</name>;</goto></then></if>
}</block></then></if>
}</block></then></if>
<expr_stmt><expr><name>rdn_level</name> = <name><name>entry</name>-&gt;<name>set</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>name</name> = <call><name>X509_NAME_ENTRY_get_object</name><argument_list>(<argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>value</name> = <call><name>X509_NAME_ENTRY_get_data</name><argument_list>(<argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>attr</name> = <call><name>_create_tuple_for_attribute</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>attr</name> == <name>NULL</name></expr>)</condition><then>
<goto>goto <name>fail1</name>;</goto></then></if>
<expr_stmt><expr><name>retcode</name> = <call><name>PyList_Append</name><argument_list>(<argument><expr><name>rdn</name></expr></argument>, <argument><expr><name>attr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>attr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>retcode</name> &lt; 0</expr>)</condition><then>
<goto>goto <name>fail1</name>;</goto></then></if>
}</block></for>
<if>if <condition>(<expr>(<name>rdn</name> != <name>NULL</name>) &amp;&amp; (<call><name>PyList_Size</name><argument_list>(<argument><expr><name>rdn</name></expr></argument>)</argument_list></call> &gt; 0)</expr>)</condition><then> <block>{
<expr_stmt><expr><name>rdnt</name> = <call><name>PyList_AsTuple</name><argument_list>(<argument><expr><name>rdn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>rdn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>rdnt</name> == <name>NULL</name></expr>)</condition><then>
<goto>goto <name>fail0</name>;</goto></then></if>
<expr_stmt><expr><name>retcode</name> = <call><name>PyList_Append</name><argument_list>(<argument><expr><name>dn</name></expr></argument>, <argument><expr><name>rdnt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>rdnt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>retcode</name> &lt; 0</expr>)</condition><then>
<goto>goto <name>fail0</name>;</goto></then></if>
}</block></then></if>
<expr_stmt><expr><name>rdnt</name> = <call><name>PyList_AsTuple</name><argument_list>(<argument><expr><name>dn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>dn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>rdnt</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<return>return <expr><name>rdnt</name></expr>;</return>
<label><name>fail1</name>:</label>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>rdn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<label><name>fail0</name>:</label>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>dn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>_get_peer_alt_names</name> <parameter_list>(<param><decl><type><name>X509</name> *</type><name>certificate</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>peer_alt_names</name> <init>= <expr><name>Py_None</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>v</name></decl>, *<decl><type ref="prev"/><name>t</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>X509_EXTENSION</name> *</type><name>ext</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>GENERAL_NAMES</name> *</type><name>names</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>GENERAL_NAME</name> *</type><name>name</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>X509V3_EXT_METHOD</name> *</type><name>method</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BIO</name> *</type><name>biobuf</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name><name>buf</name><index>[<expr>2048</expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>vptr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>len</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> *</type><name>p</name></decl>;</decl_stmt>
<if>if <condition>(<expr><name>certificate</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>peer_alt_names</name></expr>;</return></then></if>
<expr_stmt><expr><name>biobuf</name> = <call><name>BIO_new</name><argument_list>(<argument><expr><call><name>BIO_s_mem</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>i</name> = 0</expr>;</expr_stmt>
<while>while <condition>(<expr>(<name>i</name> = <call><name>X509_get_ext_by_NID</name><argument_list>(
<argument><expr><name>certificate</name></expr></argument>, <argument><expr><name>NID_subject_alt_name</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call>) &gt;= 0</expr>)</condition> <block>{
<if>if <condition>(<expr><name>peer_alt_names</name> == <name>Py_None</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>peer_alt_names</name> = <call><name>PyList_New</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>peer_alt_names</name> == <name>NULL</name></expr>)</condition><then>
<goto>goto <name>fail</name>;</goto></then></if>
}</block></then></if>
<expr_stmt><expr><name>ext</name> = <call><name>X509_get_ext</name><argument_list>(<argument><expr><name>certificate</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if<condition>(<expr>!(<name>method</name> = <call><name>X509V3_EXT_get</name><argument_list>(<argument><expr><name>ext</name></expr></argument>)</argument_list></call>)</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PySSLErrorObject</name></expr></argument>,
<argument><expr><call><name>ERRSTR</name><argument_list>(<argument><expr>"No method for internalizing subjectAltName!"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>fail</name>;</goto>
}</block></then></if>
<expr_stmt><expr><name>p</name> = <name><name>ext</name>-&gt;<name>value</name>-&gt;<name>data</name></name></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>method</name>-&gt;<name>it</name></name></expr>)</condition><then>
<expr_stmt><expr><name>names</name> = <call>(<name>GENERAL_NAMES</name>*) <argument_list>(<argument><expr><call><name>ASN1_item_d2i</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>,
<argument><expr>&amp;<name>p</name></expr></argument>,
<argument><expr><name><name>ext</name>-&gt;<name>value</name>-&gt;<name>length</name></name></expr></argument>,
<argument><expr><call><name>ASN1_ITEM_ptr</name><argument_list>(<argument><expr><name><name>method</name>-&gt;<name>it</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
<else>else
<expr_stmt><expr><name>names</name> = <call>(<name>GENERAL_NAMES</name>*) <argument_list>(<argument><expr><call><name><name>method</name>-&gt;<name>d2i</name></name><argument_list>(<argument><expr><name>NULL</name></expr></argument>,
<argument><expr>&amp;<name>p</name></expr></argument>,
<argument><expr><name><name>ext</name>-&gt;<name>value</name>-&gt;<name>length</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
<for>for(<init><expr><name>j</name> = 0</expr>;</init> <condition><expr><name>j</name> &lt; <call><name>sk_GENERAL_NAME_num</name><argument_list>(<argument><expr><name>names</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>j</name>++</expr></incr>) <block>{
<expr_stmt><expr><name>name</name> = <call><name>sk_GENERAL_NAME_value</name><argument_list>(<argument><expr><name>names</name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>name</name>-&gt;<name>type</name></name> == <name>GEN_DIRNAME</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>t</name> = <call><name>PyTuple_New</name><argument_list>(<argument><expr>2</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>t</name> == <name>NULL</name></expr>)</condition><then> <block>{
<goto>goto <name>fail</name>;</goto>
}</block></then></if>
<expr_stmt><expr><name>v</name> = <call><name>PyString_FromString</name><argument_list>(<argument><expr>"DirName"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>v</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>fail</name>;</goto>
}</block></then></if>
<expr_stmt><expr><call><name>PyTuple_SET_ITEM</name><argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>v</name> = <call><name>_create_tuple_for_X509_NAME</name> <argument_list>(<argument><expr><name><name>name</name>-&gt;<name>d</name>.<name>dirn</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>v</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>fail</name>;</goto>
}</block></then></if>
<expr_stmt><expr><call><name>PyTuple_SET_ITEM</name><argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr>1</expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr>(<name>void</name>) <call><name>BIO_reset</name><argument_list>(<argument><expr><name>biobuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>GENERAL_NAME_print</name><argument_list>(<argument><expr><name>biobuf</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>len</name> = <call><name>BIO_gets</name><argument_list>(<argument><expr><name>biobuf</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof>-1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>len</name> &lt; 0</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>_setSSLError</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>__FILE__</name></expr></argument>, <argument><expr><name>__LINE__</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>fail</name>;</goto>
}</block></then></if>
<expr_stmt><expr><name>vptr</name> = <call><name>strchr</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr>':'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>vptr</name> == <name>NULL</name></expr>)</condition><then>
<goto>goto <name>fail</name>;</goto></then></if>
<expr_stmt><expr><name>t</name> = <call><name>PyTuple_New</name><argument_list>(<argument><expr>2</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>t</name> == <name>NULL</name></expr>)</condition><then>
<goto>goto <name>fail</name>;</goto></then></if>
<expr_stmt><expr><name>v</name> = <call><name>PyString_FromStringAndSize</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr>(<name>vptr</name> - <name>buf</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>v</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>fail</name>;</goto>
}</block></then></if>
<expr_stmt><expr><call><name>PyTuple_SET_ITEM</name><argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>v</name> = <call><name>PyString_FromStringAndSize</name><argument_list>(<argument><expr>(<name>vptr</name> + 1)</expr></argument>, <argument><expr>(<name>len</name> - (<name>vptr</name> - <name>buf</name> + 1))</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>v</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>fail</name>;</goto>
}</block></then></if>
<expr_stmt><expr><call><name>PyTuple_SET_ITEM</name><argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr>1</expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></else></if>
<if>if <condition>(<expr><call><name>PyList_Append</name><argument_list>(<argument><expr><name>peer_alt_names</name></expr></argument>, <argument><expr><name>t</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>fail</name>;</goto>
}</block></then></if>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></for>
}</block></while>
<expr_stmt><expr><call><name>BIO_free</name><argument_list>(<argument><expr><name>biobuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>peer_alt_names</name> != <name>Py_None</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>v</name> = <call><name>PyList_AsTuple</name><argument_list>(<argument><expr><name>peer_alt_names</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>peer_alt_names</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>v</name></expr>;</return>
}</block></then> <else>else <block>{
<return>return <expr><name>peer_alt_names</name></expr>;</return>
}</block></else></if>
<label><name>fail</name>:</label>
<if>if <condition>(<expr><name>biobuf</name> != <name>NULL</name></expr>)</condition><then>
<expr_stmt><expr><call><name>BIO_free</name><argument_list>(<argument><expr><name>biobuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<if>if <condition>(<expr><name>peer_alt_names</name> != <name>Py_None</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>peer_alt_names</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>_decode_certificate</name> <parameter_list>(<param><decl><type><name>X509</name> *</type><name>certificate</name></decl></param>, <param><decl><type><name>int</name></type> <name>verbose</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>retval</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BIO</name> *</type><name>biobuf</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>peer</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>peer_alt_names</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>issuer</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>version</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>sn_obj</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ASN1_INTEGER</name> *</type><name>serialNumber</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name><name>buf</name><index>[<expr>2048</expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>len</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ASN1_TIME</name> *</type><name>notBefore</name></decl>, *<decl><type ref="prev"/><name>notAfter</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>pnotBefore</name></decl>, *<decl><type ref="prev"/><name>pnotAfter</name></decl>;</decl_stmt>
<expr_stmt><expr><name>retval</name> = <call><name>PyDict_New</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>retval</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>peer</name> = <call><name>_create_tuple_for_X509_NAME</name><argument_list>(
<argument><expr><call><name>X509_get_subject_name</name><argument_list>(<argument><expr><name>certificate</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>peer</name> == <name>NULL</name></expr>)</condition><then>
<goto>goto <name>fail0</name>;</goto></then></if>
<if>if <condition>(<expr><call><name>PyDict_SetItemString</name><argument_list>(<argument><expr><name>retval</name></expr></argument>, <argument><expr>(const <name>char</name> *) "subject"</expr></argument>, <argument><expr><name>peer</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>peer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>fail0</name>;</goto>
}</block></then></if>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>peer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>verbose</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>issuer</name> = <call><name>_create_tuple_for_X509_NAME</name><argument_list>(
<argument><expr><call><name>X509_get_issuer_name</name><argument_list>(<argument><expr><name>certificate</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>issuer</name> == <name>NULL</name></expr>)</condition><then>
<goto>goto <name>fail0</name>;</goto></then></if>
<if>if <condition>(<expr><call><name>PyDict_SetItemString</name><argument_list>(<argument><expr><name>retval</name></expr></argument>, <argument><expr>(const <name>char</name> *)"issuer"</expr></argument>, <argument><expr><name>issuer</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>issuer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>fail0</name>;</goto>
}</block></then></if>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>issuer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>version</name> = <call><name>PyInt_FromLong</name><argument_list>(<argument><expr><call><name>X509_get_version</name><argument_list>(<argument><expr><name>certificate</name></expr></argument>)</argument_list></call> + 1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>PyDict_SetItemString</name><argument_list>(<argument><expr><name>retval</name></expr></argument>, <argument><expr>"version"</expr></argument>, <argument><expr><name>version</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>version</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>fail0</name>;</goto>
}</block></then></if>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>version</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><name>biobuf</name> = <call><name>BIO_new</name><argument_list>(<argument><expr><call><name>BIO_s_mem</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>verbose</name></expr>)</condition><then> <block>{
<expr_stmt><expr>(<name>void</name>) <call><name>BIO_reset</name><argument_list>(<argument><expr><name>biobuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>serialNumber</name> = <call><name>X509_get_serialNumber</name><argument_list>(<argument><expr><name>certificate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>i2a_ASN1_INTEGER</name><argument_list>(<argument><expr><name>biobuf</name></expr></argument>, <argument><expr><name>serialNumber</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>len</name> = <call><name>BIO_gets</name><argument_list>(<argument><expr><name>biobuf</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof>-1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>len</name> &lt; 0</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>_setSSLError</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>__FILE__</name></expr></argument>, <argument><expr><name>__LINE__</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>fail1</name>;</goto>
}</block></then></if>
<expr_stmt><expr><name>sn_obj</name> = <call><name>PyString_FromStringAndSize</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>sn_obj</name> == <name>NULL</name></expr>)</condition><then>
<goto>goto <name>fail1</name>;</goto></then></if>
<if>if <condition>(<expr><call><name>PyDict_SetItemString</name><argument_list>(<argument><expr><name>retval</name></expr></argument>, <argument><expr>"serialNumber"</expr></argument>, <argument><expr><name>sn_obj</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>sn_obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>fail1</name>;</goto>
}</block></then></if>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>sn_obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr>(<name>void</name>) <call><name>BIO_reset</name><argument_list>(<argument><expr><name>biobuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>notBefore</name> = <call><name>X509_get_notBefore</name><argument_list>(<argument><expr><name>certificate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ASN1_TIME_print</name><argument_list>(<argument><expr><name>biobuf</name></expr></argument>, <argument><expr><name>notBefore</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>len</name> = <call><name>BIO_gets</name><argument_list>(<argument><expr><name>biobuf</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof>-1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>len</name> &lt; 0</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>_setSSLError</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>__FILE__</name></expr></argument>, <argument><expr><name>__LINE__</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>fail1</name>;</goto>
}</block></then></if>
<expr_stmt><expr><name>pnotBefore</name> = <call><name>PyString_FromStringAndSize</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>pnotBefore</name> == <name>NULL</name></expr>)</condition><then>
<goto>goto <name>fail1</name>;</goto></then></if>
<if>if <condition>(<expr><call><name>PyDict_SetItemString</name><argument_list>(<argument><expr><name>retval</name></expr></argument>, <argument><expr>"notBefore"</expr></argument>, <argument><expr><name>pnotBefore</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>pnotBefore</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>fail1</name>;</goto>
}</block></then></if>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>pnotBefore</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr>(<name>void</name>) <call><name>BIO_reset</name><argument_list>(<argument><expr><name>biobuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>notAfter</name> = <call><name>X509_get_notAfter</name><argument_list>(<argument><expr><name>certificate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ASN1_TIME_print</name><argument_list>(<argument><expr><name>biobuf</name></expr></argument>, <argument><expr><name>notAfter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>len</name> = <call><name>BIO_gets</name><argument_list>(<argument><expr><name>biobuf</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof>-1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>len</name> &lt; 0</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>_setSSLError</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>__FILE__</name></expr></argument>, <argument><expr><name>__LINE__</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>fail1</name>;</goto>
}</block></then></if>
<expr_stmt><expr><name>pnotAfter</name> = <call><name>PyString_FromStringAndSize</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>pnotAfter</name> == <name>NULL</name></expr>)</condition><then>
<goto>goto <name>fail1</name>;</goto></then></if>
<if>if <condition>(<expr><call><name>PyDict_SetItemString</name><argument_list>(<argument><expr><name>retval</name></expr></argument>, <argument><expr>"notAfter"</expr></argument>, <argument><expr><name>pnotAfter</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>pnotAfter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>fail1</name>;</goto>
}</block></then></if>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>pnotAfter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>peer_alt_names</name> = <call><name>_get_peer_alt_names</name><argument_list>(<argument><expr><name>certificate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>peer_alt_names</name> == <name>NULL</name></expr>)</condition><then>
<goto>goto <name>fail1</name>;</goto></then>
<else>else <if>if <condition>(<expr><name>peer_alt_names</name> != <name>Py_None</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr><call><name>PyDict_SetItemString</name><argument_list>(<argument><expr><name>retval</name></expr></argument>, <argument><expr>"subjectAltName"</expr></argument>,
<argument><expr><name>peer_alt_names</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>peer_alt_names</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>fail1</name>;</goto>
}</block></then></if>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>peer_alt_names</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if></else></if>
<expr_stmt><expr><call><name>BIO_free</name><argument_list>(<argument><expr><name>biobuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>retval</name></expr>;</return>
<label><name>fail1</name>:</label>
<if>if <condition>(<expr><name>biobuf</name> != <name>NULL</name></expr>)</condition><then>
<expr_stmt><expr><call><name>BIO_free</name><argument_list>(<argument><expr><name>biobuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<label><name>fail0</name>:</label>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>retval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>PySSL_test_decode_certificate</name> <parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>mod</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>retval</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>filename</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>X509</name> *</type><name>x</name><init>=<expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BIO</name> *</type><name>cert</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>verbose</name> <init>= <expr>1</expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"s|i:test_decode_certificate"</expr></argument>, <argument><expr>&amp;<name>filename</name></expr></argument>, <argument><expr>&amp;<name>verbose</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<if>if <condition>(<expr>(<name>cert</name>=<call><name>BIO_new</name><argument_list>(<argument><expr><call><name>BIO_s_file</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call>) == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PySSLErrorObject</name></expr></argument>, <argument><expr>"Can't malloc memory to read file"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>fail0</name>;</goto>
}</block></then></if>
<if>if <condition>(<expr><call><name>BIO_read_filename</name><argument_list>(<argument><expr><name>cert</name></expr></argument>,<argument><expr><name>filename</name></expr></argument>)</argument_list></call> &lt;= 0</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PySSLErrorObject</name></expr></argument>, <argument><expr>"Can't open file"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>fail0</name>;</goto>
}</block></then></if>
<expr_stmt><expr><name>x</name> = <call><name>PEM_read_bio_X509_AUX</name><argument_list>(<argument><expr><name>cert</name></expr></argument>,<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>x</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PySSLErrorObject</name></expr></argument>, <argument><expr>"Error decoding PEM-encoded file"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>fail0</name>;</goto>
}</block></then></if>
<expr_stmt><expr><name>retval</name> = <call><name>_decode_certificate</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><name>verbose</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<label><name>fail0</name>:</label>
<if>if <condition>(<expr><name>cert</name> != <name>NULL</name></expr>)</condition><then> <expr_stmt><expr><call><name>BIO_free</name><argument_list>(<argument><expr><name>cert</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<return>return <expr><name>retval</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>PySSL_peercert</name><parameter_list>(<param><decl><type><name>PySSLObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>retval</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>len</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>verification</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>binary_mode</name> <init>= <expr><name>Py_None</name></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"|O:peer_certificate"</expr></argument>, <argument><expr>&amp;<name>binary_mode</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<if>if <condition>(<expr>!<name><name>self</name>-&gt;<name>peer_cert</name></name></expr>)</condition><then>
<expr_stmt><expr><name>Py_RETURN_NONE</name></expr>;</expr_stmt></then></if>
<if>if <condition>(<expr><call><name>PyObject_IsTrue</name><argument_list>(<argument><expr><name>binary_mode</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>unsigned</name> <name>char</name> *</type><name>bytes_buf</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>bytes_buf</name> = <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name>len</name> = <call><name>i2d_X509</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>peer_cert</name></name></expr></argument>, <argument><expr>&amp;<name>bytes_buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>len</name> &lt; 0</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PySSL_SetError</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>__FILE__</name></expr></argument>, <argument><expr><name>__LINE__</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>retval</name> = <call><name>PyString_FromStringAndSize</name><argument_list>(<argument><expr>(const <name>char</name> *) <name>bytes_buf</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OPENSSL_free</name><argument_list>(<argument><expr><name>bytes_buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>retval</name></expr>;</return>
}</block></then> <else>else <block>{
<expr_stmt><expr><name>verification</name> = <call><name>SSL_CTX_get_verify_mode</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>ctx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>(<name>verification</name> &amp; <name>SSL_VERIFY_PEER</name>) == 0</expr>)</condition><then>
<return>return <expr><call><name>PyDict_New</name><argument_list>()</argument_list></call></expr>;</return></then>
<else>else
<return>return <expr><call><name>_decode_certificate</name> <argument_list>(<argument><expr><name><name>self</name>-&gt;<name>peer_cert</name></name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</return></else></if>
}</block></else></if>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>PySSL_peercert_doc</name></expr></argument>,
<argument><expr>"peer_certificate([der=False]) -&gt; certificate\n\
\n\
Returns the certificate for the peer. If no certificate was provided,\n\
returns None. If a certificate was provided, but not validated, returns\n\
an empty dictionary. Otherwise returns a dict containing information\n\
about the peer certificate.\n\
\n\
If the optional argument is True, returns a DER-encoded copy of the\n\
peer certificate, or None if no certificate was provided. This will\n\
return the certificate even if it wasn't validated."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type><name>PySSL_cipher</name> <parameter_list>(<param><decl><type><name>PySSLObject</name> *</type><name>self</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>retval</name></decl>, *<decl><type ref="prev"/><name>v</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>SSL_CIPHER</name> *</type><name>current</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>cipher_name</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>cipher_protocol</name></decl>;</decl_stmt>
<if>if <condition>(<expr><name><name>self</name>-&gt;<name>ssl</name></name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>Py_None</name></expr>;</return></then></if>
<expr_stmt><expr><name>current</name> = <call><name>SSL_get_current_cipher</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>ssl</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>current</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>Py_None</name></expr>;</return></then></if>
<expr_stmt><expr><name>retval</name> = <call><name>PyTuple_New</name><argument_list>(<argument><expr>3</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>retval</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>cipher_name</name> = (<name>char</name> *) <call><name>SSL_CIPHER_get_name</name><argument_list>(<argument><expr><name>current</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>cipher_name</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyTuple_SET_ITEM</name><argument_list>(<argument><expr><name>retval</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr><name>v</name> = <call><name>PyString_FromString</name><argument_list>(<argument><expr><name>cipher_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>v</name> == <name>NULL</name></expr>)</condition><then>
<goto>goto <name>fail0</name>;</goto></then></if>
<expr_stmt><expr><call><name>PyTuple_SET_ITEM</name><argument_list>(<argument><expr><name>retval</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></else></if>
<expr_stmt><expr><name>cipher_protocol</name> = <call><name>SSL_CIPHER_get_version</name><argument_list>(<argument><expr><name>current</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>cipher_protocol</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyTuple_SET_ITEM</name><argument_list>(<argument><expr><name>retval</name></expr></argument>, <argument><expr>1</expr></argument>, <argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr><name>v</name> = <call><name>PyString_FromString</name><argument_list>(<argument><expr><name>cipher_protocol</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>v</name> == <name>NULL</name></expr>)</condition><then>
<goto>goto <name>fail0</name>;</goto></then></if>
<expr_stmt><expr><call><name>PyTuple_SET_ITEM</name><argument_list>(<argument><expr><name>retval</name></expr></argument>, <argument><expr>1</expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></else></if>
<expr_stmt><expr><name>v</name> = <call><name>PyInt_FromLong</name><argument_list>(<argument><expr><call><name>SSL_CIPHER_get_bits</name><argument_list>(<argument><expr><name>current</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>v</name> == <name>NULL</name></expr>)</condition><then>
<goto>goto <name>fail0</name>;</goto></then></if>
<expr_stmt><expr><call><name>PyTuple_SET_ITEM</name><argument_list>(<argument><expr><name>retval</name></expr></argument>, <argument><expr>2</expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>retval</name></expr>;</return>
<label><name>fail0</name>:</label>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>retval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>PySSL_dealloc</name><parameter_list>(<param><decl><type><name>PySSLObject</name> *</type><name>self</name></decl></param>)</parameter_list> <block>{
<if>if <condition>(<expr><name><name>self</name>-&gt;<name>peer_cert</name></name></expr>)</condition><then>
<expr_stmt><expr><call><name>X509_free</name> <argument_list>(<argument><expr><name><name>self</name>-&gt;<name>peer_cert</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<if>if <condition>(<expr><name><name>self</name>-&gt;<name>ssl</name></name></expr>)</condition><then>
<expr_stmt><expr><call><name>SSL_free</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>ssl</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<if>if <condition>(<expr><name><name>self</name>-&gt;<name>ctx</name></name></expr>)</condition><then>
<expr_stmt><expr><call><name>SSL_CTX_free</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>ctx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>Socket</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyObject_Del</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>check_socket_and_wait_for_timeout</name><parameter_list>(<param><decl><type><name>PySocketSockObject</name> *</type><name>s</name></decl></param>, <param><decl><type><name>int</name></type> <name>writing</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>fd_set</name></type> <name>fds</name></decl>;</decl_stmt>
<decl_stmt><decl><type>struct <name>timeval</name></type> <name>tv</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
<if>if <condition>(<expr><name><name>s</name>-&gt;<name>sock_timeout</name></name> &lt; 0.0</expr>)</condition><then>
<return>return <expr><name>SOCKET_IS_BLOCKING</name></expr>;</return></then>
<else>else <if>if <condition>(<expr><name><name>s</name>-&gt;<name>sock_timeout</name></name> == 0.0</expr>)</condition><then>
<return>return <expr><name>SOCKET_IS_NONBLOCKING</name></expr>;</return></then></if></else></if>
<if>if <condition>(<expr><name><name>s</name>-&gt;<name>sock_fd</name></name> &lt; 0</expr>)</condition><then>
<return>return <expr><name>SOCKET_HAS_BEEN_CLOSED</name></expr>;</return></then></if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_POLL</name></expr></argument>)</argument_list></call></expr></cpp:if>
<block>{
<decl_stmt><decl><type>struct <name>pollfd</name></type> <name>pollfd</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>timeout</name></decl>;</decl_stmt>
<expr_stmt><expr><name><name>pollfd</name>.<name>fd</name></name> = <name><name>s</name>-&gt;<name>sock_fd</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>pollfd</name>.<name>events</name></name> = <name>writing</name> ? <name>POLLOUT</name> : <name>POLLIN</name></expr>;</expr_stmt>
<expr_stmt><expr><name>timeout</name> = <call>(<name>int</name>)<argument_list>(<argument><expr><name><name>s</name>-&gt;<name>sock_timeout</name></name> * 1000 + 0.5</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>PySSL_BEGIN_ALLOW_THREADS</name></type>
<name>rc</name> <init>= <expr><call><name>poll</name><argument_list>(<argument><expr>&amp;<name>pollfd</name></expr></argument>, <argument><expr>1</expr></argument>, <argument><expr><name>timeout</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<macro><name>PySSL_END_ALLOW_THREADS</name></macro>
<goto>goto <name>normal_return</name>;</goto>
}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>Py_SOCKET_FD_CAN_BE_GE_FD_SETSIZE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if>if <condition>(<expr><name><name>s</name>-&gt;<name>sock_fd</name></name> &gt;= <name>FD_SETSIZE</name></expr>)</condition><then>
<return>return <expr><name>SOCKET_TOO_LARGE_FOR_SELECT</name></expr>;</return></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><name><name>tv</name>.<name>tv_sec</name></name> = (<name>int</name>)<name><name>s</name>-&gt;<name>sock_timeout</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tv</name>.<name>tv_usec</name></name> = <call>(<name>int</name>)<argument_list>(<argument><expr>(<name><name>s</name>-&gt;<name>sock_timeout</name></name> - <name><name>tv</name>.<name>tv_sec</name></name>) * 1e6</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>FD_ZERO</name><argument_list>(<argument><expr>&amp;<name>fds</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>FD_SET</name><argument_list>(<argument><expr><name><name>s</name>-&gt;<name>sock_fd</name></name></expr></argument>, <argument><expr>&amp;<name>fds</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<macro><name>PySSL_BEGIN_ALLOW_THREADS</name></macro>
<if>if <condition>(<expr><name>writing</name></expr>)</condition><then>
<expr_stmt><expr><name>rc</name> = <call><name>select</name><argument_list>(<argument><expr><name><name>s</name>-&gt;<name>sock_fd</name></name>+1</expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr>&amp;<name>fds</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr>&amp;<name>tv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
<else>else
<expr_stmt><expr><name>rc</name> = <call><name>select</name><argument_list>(<argument><expr><name><name>s</name>-&gt;<name>sock_fd</name></name>+1</expr></argument>, <argument><expr>&amp;<name>fds</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr>&amp;<name>tv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
<expr_stmt><expr><name>PySSL_END_ALLOW_THREADS</name>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_POLL</name></expr></argument>)</argument_list></call></expr></cpp:if>
<name>normal_return</name>:</expr></expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<return>return <expr><name>rc</name> == 0 ? <name>SOCKET_HAS_TIMED_OUT</name> : <name>SOCKET_OPERATION_OK</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type><name>PySSL_SSLwrite</name><parameter_list>(<param><decl><type><name>PySSLObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>char</name> *</type><name>data</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>len</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>count</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>sockstate</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>err</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>nonblocking</name></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"s#:write"</expr></argument>, <argument><expr>&amp;<name>data</name></expr></argument>, <argument><expr>&amp;<name>count</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>nonblocking</name> = (<name><name>self</name>-&gt;<name>Socket</name>-&gt;<name>sock_timeout</name></name> &gt;= 0.0)</expr>;</expr_stmt>
<expr_stmt><expr><call><name>BIO_set_nbio</name><argument_list>(<argument><expr><call><name>SSL_get_rbio</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>ssl</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>nonblocking</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>BIO_set_nbio</name><argument_list>(<argument><expr><call><name>SSL_get_wbio</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>ssl</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>nonblocking</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>sockstate</name> = <call><name>check_socket_and_wait_for_timeout</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>Socket</name></name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>sockstate</name> == <name>SOCKET_HAS_TIMED_OUT</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PySSLErrorObject</name></expr></argument>,
<argument><expr>"The write operation timed out"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then> <else>else <if>if <condition>(<expr><name>sockstate</name> == <name>SOCKET_HAS_BEEN_CLOSED</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PySSLErrorObject</name></expr></argument>,
<argument><expr>"Underlying socket has been closed."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then> <else>else <if>if <condition>(<expr><name>sockstate</name> == <name>SOCKET_TOO_LARGE_FOR_SELECT</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PySSLErrorObject</name></expr></argument>,
<argument><expr>"Underlying socket too large for select()."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if></else></if></else></if>
<do>do <block>{
<expr_stmt><expr><name>err</name> = 0</expr>;</expr_stmt>
<decl_stmt><decl><type><name>PySSL_BEGIN_ALLOW_THREADS</name></type>
<name>len</name> <init>= <expr><call><name>SSL_write</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>ssl</name></name></expr></argument>, <argument><expr><name>data</name></expr></argument>, <argument><expr><name>count</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>err</name> = <call><name>SSL_get_error</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>ssl</name></name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<macro><name>PySSL_END_ALLOW_THREADS</name></macro>
<if>if<condition>(<expr><call><name>PyErr_CheckSignals</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<if>if <condition>(<expr><name>err</name> == <name>SSL_ERROR_WANT_READ</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>sockstate</name> =
<call><name>check_socket_and_wait_for_timeout</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>Socket</name></name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else <if>if <condition>(<expr><name>err</name> == <name>SSL_ERROR_WANT_WRITE</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>sockstate</name> =
<call><name>check_socket_and_wait_for_timeout</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>Socket</name></name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr><name>sockstate</name> = <name>SOCKET_OPERATION_OK</name></expr>;</expr_stmt>
}</block></else></if></else></if>
<if>if <condition>(<expr><name>sockstate</name> == <name>SOCKET_HAS_TIMED_OUT</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PySSLErrorObject</name></expr></argument>,
<argument><expr>"The write operation timed out"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then> <else>else <if>if <condition>(<expr><name>sockstate</name> == <name>SOCKET_HAS_BEEN_CLOSED</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PySSLErrorObject</name></expr></argument>,
<argument><expr>"Underlying socket has been closed."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then> <else>else <if>if <condition>(<expr><name>sockstate</name> == <name>SOCKET_IS_NONBLOCKING</name></expr>)</condition><then> <block>{
<break>break;</break>
}</block></then></if></else></if></else></if>
}</block> while <condition>(<expr><name>err</name> == <name>SSL_ERROR_WANT_READ</name> || <name>err</name> == <name>SSL_ERROR_WANT_WRITE</name></expr>)</condition>;</do>
<if>if <condition>(<expr><name>len</name> &gt; 0</expr>)</condition><then>
<return>return <expr><call><name>PyInt_FromLong</name><argument_list>(<argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</return></then>
<else>else
<return>return <expr><call><name>PySSL_SetError</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>__FILE__</name></expr></argument>, <argument><expr><name>__LINE__</name></expr></argument>)</argument_list></call></expr>;</return></else></if>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>PySSL_SSLwrite_doc</name></expr></argument>,
<argument><expr>"write(s) -&gt; len\n\
\n\
Writes the string s into the SSL object. Returns the number\n\
of bytes written."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type><name>PySSL_SSLpending</name><parameter_list>(<param><decl><type><name>PySSLObject</name> *</type><name>self</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>count</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PySSL_BEGIN_ALLOW_THREADS</name></type>
<name>count</name> <init>= <expr><call><name>SSL_pending</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>ssl</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<macro><name>PySSL_END_ALLOW_THREADS</name></macro>
<if>if <condition>(<expr><name>count</name> &lt; 0</expr>)</condition><then>
<return>return <expr><call><name>PySSL_SetError</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>count</name></expr></argument>, <argument><expr><name>__FILE__</name></expr></argument>, <argument><expr><name>__LINE__</name></expr></argument>)</argument_list></call></expr>;</return></then>
<else>else
<return>return <expr><call><name>PyInt_FromLong</name><argument_list>(<argument><expr><name>count</name></expr></argument>)</argument_list></call></expr>;</return></else></if>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>PySSL_SSLpending_doc</name></expr></argument>,
<argument><expr>"pending() -&gt; count\n\
\n\
Returns the number of already decrypted bytes available for read,\n\
pending on the connection.\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type><name>PySSL_SSLread</name><parameter_list>(<param><decl><type><name>PySSLObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>buf</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>count</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>len</name> <init>= <expr>1024</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>sockstate</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>err</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>nonblocking</name></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"|i:read"</expr></argument>, <argument><expr>&amp;<name>len</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<if>if <condition>(<expr>!(<name>buf</name> = <call><name>PyString_FromStringAndSize</name><argument_list>(<argument><expr>(<name>char</name> *) 0</expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call>)</expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>nonblocking</name> = (<name><name>self</name>-&gt;<name>Socket</name>-&gt;<name>sock_timeout</name></name> &gt;= 0.0)</expr>;</expr_stmt>
<expr_stmt><expr><call><name>BIO_set_nbio</name><argument_list>(<argument><expr><call><name>SSL_get_rbio</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>ssl</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>nonblocking</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>BIO_set_nbio</name><argument_list>(<argument><expr><call><name>SSL_get_wbio</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>ssl</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>nonblocking</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>PySSL_BEGIN_ALLOW_THREADS</name></type>
<name>count</name> <init>= <expr><call><name>SSL_pending</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>ssl</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<macro><name>PySSL_END_ALLOW_THREADS</name></macro>
<if>if <condition>(<expr>!<name>count</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>sockstate</name> = <call><name>check_socket_and_wait_for_timeout</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>Socket</name></name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>sockstate</name> == <name>SOCKET_HAS_TIMED_OUT</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PySSLErrorObject</name></expr></argument>,
<argument><expr>"The read operation timed out"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then> <else>else <if>if <condition>(<expr><name>sockstate</name> == <name>SOCKET_TOO_LARGE_FOR_SELECT</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PySSLErrorObject</name></expr></argument>,
<argument><expr>"Underlying socket too large for select()."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then> <else>else <if>if <condition>(<expr><name>sockstate</name> == <name>SOCKET_HAS_BEEN_CLOSED</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr><call><name>SSL_get_shutdown</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>ssl</name></name></expr></argument>)</argument_list></call> !=
<name>SSL_RECEIVED_SHUTDOWN</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PySSLErrorObject</name></expr></argument>,
<argument><expr>"Socket closed without SSL shutdown handshake"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then> <else>else <block>{
<expr_stmt><expr><call><name>_PyString_Resize</name><argument_list>(<argument><expr>&amp;<name>buf</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>buf</name></expr>;</return>
}</block></else></if>
}</block></then></if></else></if></else></if>
}</block></then></if>
<do>do <block>{
<expr_stmt><expr><name>err</name> = 0</expr>;</expr_stmt>
<decl_stmt><decl><type><name>PySSL_BEGIN_ALLOW_THREADS</name></type>
<name>count</name> <init>= <expr><call><name>SSL_read</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>ssl</name></name></expr></argument>, <argument><expr><call><name>PyString_AsString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>err</name> = <call><name>SSL_get_error</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>ssl</name></name></expr></argument>, <argument><expr><name>count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<macro><name>PySSL_END_ALLOW_THREADS</name></macro>
<if>if<condition>(<expr><call><name>PyErr_CheckSignals</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<if>if <condition>(<expr><name>err</name> == <name>SSL_ERROR_WANT_READ</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>sockstate</name> =
<call><name>check_socket_and_wait_for_timeout</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>Socket</name></name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else <if>if <condition>(<expr><name>err</name> == <name>SSL_ERROR_WANT_WRITE</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>sockstate</name> =
<call><name>check_socket_and_wait_for_timeout</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>Socket</name></name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else <if>if <condition>(<expr>(<name>err</name> == <name>SSL_ERROR_ZERO_RETURN</name>) &amp;&amp;
(<call><name>SSL_get_shutdown</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>ssl</name></name></expr></argument>)</argument_list></call> ==
<name>SSL_RECEIVED_SHUTDOWN</name>)</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>_PyString_Resize</name><argument_list>(<argument><expr>&amp;<name>buf</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>buf</name></expr>;</return>
}</block></then> <else>else <block>{
<expr_stmt><expr><name>sockstate</name> = <name>SOCKET_OPERATION_OK</name></expr>;</expr_stmt>
}</block></else></if></else></if></else></if>
<if>if <condition>(<expr><name>sockstate</name> == <name>SOCKET_HAS_TIMED_OUT</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PySSLErrorObject</name></expr></argument>,
<argument><expr>"The read operation timed out"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then> <else>else <if>if <condition>(<expr><name>sockstate</name> == <name>SOCKET_IS_NONBLOCKING</name></expr>)</condition><then> <block>{
<break>break;</break>
}</block></then></if></else></if>
}</block> while <condition>(<expr><name>err</name> == <name>SSL_ERROR_WANT_READ</name> || <name>err</name> == <name>SSL_ERROR_WANT_WRITE</name></expr>)</condition>;</do>
<if>if <condition>(<expr><name>count</name> &lt;= 0</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>PySSL_SetError</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>count</name></expr></argument>, <argument><expr><name>__FILE__</name></expr></argument>, <argument><expr><name>__LINE__</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></then></if>
<if>if <condition>(<expr><name>count</name> != <name>len</name></expr>)</condition><then>
<expr_stmt><expr><call><name>_PyString_Resize</name><argument_list>(<argument><expr>&amp;<name>buf</name></expr></argument>, <argument><expr><name>count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<return>return <expr><name>buf</name></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>PySSL_SSLread_doc</name></expr></argument>,
<argument><expr>"read([len]) -&gt; string\n\
\n\
Read up to len bytes from the SSL socket."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type><name>PySSL_SSLshutdown</name><parameter_list>(<param><decl><type><name>PySSLObject</name> *</type><name>self</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>err</name></decl>;</decl_stmt>
<if>if <condition>(<expr><name><name>self</name>-&gt;<name>Socket</name>-&gt;<name>sock_fd</name></name> &lt; 0</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PySSLErrorObject</name></expr></argument>,
<argument><expr>"Underlying socket has been closed."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<decl_stmt><decl><type><name>PySSL_BEGIN_ALLOW_THREADS</name></type>
<name>err</name> <init>= <expr><call><name>SSL_shutdown</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>ssl</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>err</name> == 0</expr>)</condition><then> <block>{
<expr_stmt><expr><name>err</name> = <call><name>SSL_shutdown</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>ssl</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<macro><name>PySSL_END_ALLOW_THREADS</name></macro>
<if>if <condition>(<expr><name>err</name> &lt; 0</expr>)</condition><then>
<return>return <expr><call><name>PySSL_SetError</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>err</name></expr></argument>, <argument><expr><name>__FILE__</name></expr></argument>, <argument><expr><name>__LINE__</name></expr></argument>)</argument_list></call></expr>;</return></then>
<else>else <block>{
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>Socket</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call>(<name>PyObject</name> *) <argument_list>(<argument><expr><name><name>self</name>-&gt;<name>Socket</name></name></expr></argument>)</argument_list></call></expr>;</return>
}</block></else></if>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>PySSL_SSLshutdown_doc</name></expr></argument>,
<argument><expr>"shutdown(s) -&gt; socket\n\
\n\
Does the SSL shutdown handshake with the remote end, and returns\n\
the underlying socket object."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>PyMethodDef</name></type> <name><name>PySSLMethods</name><index>[]</index></name> <init>= <expr><block>{
<expr><block>{<expr>"do_handshake"</expr>, <expr>(<name>PyCFunction</name>)<name>PySSL_SSLdo_handshake</name></expr>, <expr><name>METH_NOARGS</name></expr>}</block></expr>,
<expr><block>{
<expr>"write"</expr>, <expr>(<name>PyCFunction</name>)<name>PySSL_SSLwrite</name></expr>, <expr><name>METH_VARARGS</name></expr>,
<expr><name>PySSL_SSLwrite_doc</name></expr>
}</block></expr>,
<expr><block>{
<expr>"read"</expr>, <expr>(<name>PyCFunction</name>)<name>PySSL_SSLread</name></expr>, <expr><name>METH_VARARGS</name></expr>,
<expr><name>PySSL_SSLread_doc</name></expr>
}</block></expr>,
<expr><block>{
<expr>"pending"</expr>, <expr>(<name>PyCFunction</name>)<name>PySSL_SSLpending</name></expr>, <expr><name>METH_NOARGS</name></expr>,
<expr><name>PySSL_SSLpending_doc</name></expr>
}</block></expr>,
<expr><block>{<expr>"server"</expr>, <expr>(<name>PyCFunction</name>)<name>PySSL_server</name></expr>, <expr><name>METH_NOARGS</name></expr>}</block></expr>,
<expr><block>{<expr>"issuer"</expr>, <expr>(<name>PyCFunction</name>)<name>PySSL_issuer</name></expr>, <expr><name>METH_NOARGS</name></expr>}</block></expr>,
<expr><block>{
<expr>"peer_certificate"</expr>, <expr>(<name>PyCFunction</name>)<name>PySSL_peercert</name></expr>, <expr><name>METH_VARARGS</name></expr>,
<expr><name>PySSL_peercert_doc</name></expr>
}</block></expr>,
<expr><block>{<expr>"cipher"</expr>, <expr>(<name>PyCFunction</name>)<name>PySSL_cipher</name></expr>, <expr><name>METH_NOARGS</name></expr>}</block></expr>,
<expr><block>{
<expr>"shutdown"</expr>, <expr>(<name>PyCFunction</name>)<name>PySSL_SSLshutdown</name></expr>, <expr><name>METH_NOARGS</name></expr>,
<expr><name>PySSL_SSLshutdown_doc</name></expr>
}</block></expr>,
<expr><block>{<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>}</block></expr>
}</block></expr></init></decl>;</decl_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type><name>PySSL_getattr</name><parameter_list>(<param><decl><type><name>PySSLObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>char</name> *</type><name>name</name></decl></param>)</parameter_list> <block>{
<return>return <expr><call><name>Py_FindMethod</name><argument_list>(<argument><expr><name>PySSLMethods</name></expr></argument>, <argument><expr>(<name>PyObject</name> *)<name>self</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<decl_stmt><decl><type><specifier>static</specifier> <name>PyTypeObject</name></type> <name>PySSL_Type</name> <init>= <expr><block>{
<expr><call><name>PyVarObject_HEAD_INIT</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call>
"ssl.SSLContext"</expr>,
<expr><sizeof>sizeof<argument_list>(<argument><expr><name>PySSLObject</name></expr></argument>)</argument_list></sizeof></expr>,
<expr>0</expr>,
<expr>(<name>destructor</name>)<name>PySSL_dealloc</name></expr>,
<expr>0</expr>,
<expr>(<name>getattrfunc</name>)<name>PySSL_getattr</name></expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
}</block></expr></init></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_OPENSSL_RAND</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>PySSL_RAND_add</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>char</name> *</type><name>buf</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>len</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>double</name></type> <name>entropy</name></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"s#d:RAND_add"</expr></argument>, <argument><expr>&amp;<name>buf</name></expr></argument>, <argument><expr>&amp;<name>len</name></expr></argument>, <argument><expr>&amp;<name>entropy</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><call><name>RAND_add</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>entropy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>Py_None</name></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>PySSL_RAND_add_doc</name></expr></argument>,
<argument><expr>"RAND_add(string, entropy)\n\
\n\
Mix string into the OpenSSL PRNG state. entropy (a float) is a lower\n\
bound on the entropy contained in string. See RFC 1750."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>PySSL_RAND_status</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>)</parameter_list> <block>{
<return>return <expr><call><name>PyInt_FromLong</name><argument_list>(<argument><expr><call><name>RAND_status</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>PySSL_RAND_status_doc</name></expr></argument>,
<argument><expr>"RAND_status() -&gt; 0 or 1\n\
\n\
Returns 1 if the OpenSSL PRNG has been seeded with enough data and 0 if not.\n\
It is necessary to seed the PRNG with RAND_add() on some platforms before\n\
using the ssl() function."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>PySSL_RAND_egd</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>arg</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>bytes</name></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>PyString_Check</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
<argument><expr>"RAND_egd() expected string, found %s"</expr></argument>,
<argument><expr><call><name>Py_TYPE</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call>-&gt;<name>tp_name</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
<expr_stmt><expr><name>bytes</name> = <call><name>RAND_egd</name><argument_list>(<argument><expr><call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>bytes</name> == -1</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PySSLErrorObject</name></expr></argument>,
<argument><expr>"EGD connection failed or EGD did not return "
"enough data to seed the PRNG"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<return>return <expr><call><name>PyInt_FromLong</name><argument_list>(<argument><expr><name>bytes</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>PySSL_RAND_egd_doc</name></expr></argument>,
<argument><expr>"RAND_egd(path) -&gt; bytes\n\
\n\
Queries the entropy gather daemon (EGD) on the socket named by 'path'.\n\
Returns number of bytes read. Raises SSLError if connection to EGD\n\
fails or if it does provide enough data to seed PRNG."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<decl_stmt><decl><type><specifier>static</specifier> <name>PyMethodDef</name></type> <name><name>PySSL_methods</name><index>[]</index></name> <init>= <expr><block>{
<expr><block>{
<expr>"sslwrap"</expr>, <expr><name>PySSL_sslwrap</name></expr>,
<expr><name>METH_VARARGS</name></expr>, <expr><name>ssl_doc</name></expr>
}</block></expr>,
<expr><block>{
<expr>"_test_decode_cert"</expr>, <expr><name>PySSL_test_decode_certificate</name></expr>,
<expr><name>METH_VARARGS</name></expr>
}</block></expr>,
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_OPENSSL_RAND</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{
<expr>"RAND_add"</expr>, <expr><name>PySSL_RAND_add</name></expr>, <expr><name>METH_VARARGS</name></expr>,
<expr><name>PySSL_RAND_add_doc</name></expr>
}</block></expr>,
<expr><block>{
<expr>"RAND_egd"</expr>, <expr><name>PySSL_RAND_egd</name></expr>, <expr><name>METH_O</name></expr>,
<expr><name>PySSL_RAND_egd_doc</name></expr>
}</block></expr>,
<expr><block>{
<expr>"RAND_status"</expr>, <expr>(<name>PyCFunction</name>)<name>PySSL_RAND_status</name></expr>, <expr><name>METH_NOARGS</name></expr>,
<expr><name>PySSL_RAND_status_doc</name></expr>
}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr><block>{<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>}</block></expr>
}</block></expr></init></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>WITH_THREAD</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><specifier>static</specifier> <name>PyThread_type_lock</name> *</type><name>_ssl_locks</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<function><type><specifier>static</specifier> <name>unsigned</name> <name>long</name></type> <name>_ssl_thread_id_function</name> <parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list> <block>{
<return>return <expr><call><name>PyThread_get_thread_ident</name><argument_list>()</argument_list></call></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>_ssl_thread_locking_function</name> <parameter_list>(<param><decl><type><name>int</name></type> <name>mode</name></decl></param>, <param><decl><type><name>int</name></type> <name>n</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>file</name></decl></param>, <param><decl><type><name>int</name></type> <name>line</name></decl></param>)</parameter_list> <block>{
<if>if <condition>(<expr>(<name>_ssl_locks</name> == <name>NULL</name>) ||
(<name>n</name> &lt; 0) || ((<name>unsigned</name>)<name>n</name> &gt;= <name>_ssl_locks_count</name>)</expr>)</condition><then>
<return>return;</return></then></if>
<if>if <condition>(<expr><name>mode</name> &amp; <name>CRYPTO_LOCK</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyThread_acquire_lock</name><argument_list>(<argument><expr><name><name>_ssl_locks</name><index>[<expr><name>n</name></expr>]</index></name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr><call><name>PyThread_release_lock</name><argument_list>(<argument><expr><name><name>_ssl_locks</name><index>[<expr><name>n</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></else></if>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>_setup_ssl_threads</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>i</name></decl>;</decl_stmt>
<if>if <condition>(<expr><name>_ssl_locks</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>_ssl_locks_count</name> = <call><name>CRYPTO_num_locks</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>_ssl_locks</name> = (<name>PyThread_type_lock</name> *)
<call><name>malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PyThread_type_lock</name></expr></argument>)</argument_list></sizeof> * <name>_ssl_locks_count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>_ssl_locks</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr>0</expr>;</return></then></if>
<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>_ssl_locks</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PyThread_type_lock</name></expr></argument>)</argument_list></sizeof> * <name>_ssl_locks_count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>_ssl_locks_count</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
<expr_stmt><expr><name><name>_ssl_locks</name><index>[<expr><name>i</name></expr>]</index></name> = <call><name>PyThread_allocate_lock</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>_ssl_locks</name><index>[<expr><name>i</name></expr>]</index></name> == <name>NULL</name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>;</decl_stmt>
<for>for (<init><expr><name>j</name> = 0</expr>;</init> <condition><expr><name>j</name> &lt; <name>i</name></expr>;</condition> <incr><expr><name>j</name>++</expr></incr>) <block>{
<expr_stmt><expr><call><name>PyThread_free_lock</name><argument_list>(<argument><expr><name><name>_ssl_locks</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></for>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>_ssl_locks</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>0</expr>;</return>
}</block></then></if>
}</block></for>
<expr_stmt><expr><call><name>CRYPTO_set_locking_callback</name><argument_list>(<argument><expr><name>_ssl_thread_locking_function</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>CRYPTO_set_id_callback</name><argument_list>(<argument><expr><name>_ssl_thread_id_function</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<return>return <expr>1</expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>module_doc</name></expr></argument>,
<argument><expr>"Implementation module for SSL socket operations. See the socket module\n\
for documentation."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><name>PyMODINIT_FUNC</name></type>
<name>init_ssl</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>m</name></decl>, *<decl><type ref="prev"/><name>d</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>Py_TYPE</name><argument_list>(<argument><expr>&amp;<name>PySSL_Type</name></expr></argument>)</argument_list></call> = &amp;<name>PyType_Type</name></expr>;</expr_stmt>
<expr_stmt><expr><name>m</name> = <call><name>Py_InitModule3</name><argument_list>(<argument><expr>"_ssl"</expr></argument>, <argument><expr><name>PySSL_methods</name></expr></argument>, <argument><expr><name>module_doc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>m</name> == <name>NULL</name></expr>)</condition><then>
<return>return;</return></then></if>
<expr_stmt><expr><name>d</name> = <call><name>PyModule_GetDict</name><argument_list>(<argument><expr><name>m</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>PySocketModule_ImportModuleAndAPI</name><argument_list>()</argument_list></call></expr>)</condition><then>
<return>return;</return></then></if>
<expr_stmt><expr><call><name>SSL_load_error_strings</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>WITH_THREAD</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if>if <condition>(<expr>!<call><name>_setup_ssl_threads</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
<return>return;</return>
}</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><call><name>SSLeay_add_ssl_algorithms</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>PySSLErrorObject</name> = <call><name>PyErr_NewException</name><argument_list>(<argument><expr>"ssl.SSLError"</expr></argument>,
<argument><expr><name><name>PySocketModule</name>.<name>error</name></name></expr></argument>,
<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>PySSLErrorObject</name> == <name>NULL</name></expr>)</condition><then>
<return>return;</return></then></if>
<if>if <condition>(<expr><call><name>PyDict_SetItemString</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr>"SSLError"</expr></argument>, <argument><expr><name>PySSLErrorObject</name></expr></argument>)</argument_list></call> != 0</expr>)</condition><then>
<return>return;</return></then></if>
<if>if <condition>(<expr><call><name>PyDict_SetItemString</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr>"SSLType"</expr></argument>,
<argument><expr>(<name>PyObject</name> *)&amp;<name>PySSL_Type</name></expr></argument>)</argument_list></call> != 0</expr>)</condition><then>
<return>return;</return></then></if>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"SSL_ERROR_ZERO_RETURN"</expr></argument>,
<argument><expr><name>PY_SSL_ERROR_ZERO_RETURN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"SSL_ERROR_WANT_READ"</expr></argument>,
<argument><expr><name>PY_SSL_ERROR_WANT_READ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"SSL_ERROR_WANT_WRITE"</expr></argument>,
<argument><expr><name>PY_SSL_ERROR_WANT_WRITE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"SSL_ERROR_WANT_X509_LOOKUP"</expr></argument>,
<argument><expr><name>PY_SSL_ERROR_WANT_X509_LOOKUP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"SSL_ERROR_SYSCALL"</expr></argument>,
<argument><expr><name>PY_SSL_ERROR_SYSCALL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"SSL_ERROR_SSL"</expr></argument>,
<argument><expr><name>PY_SSL_ERROR_SSL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"SSL_ERROR_WANT_CONNECT"</expr></argument>,
<argument><expr><name>PY_SSL_ERROR_WANT_CONNECT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"SSL_ERROR_EOF"</expr></argument>,
<argument><expr><name>PY_SSL_ERROR_EOF</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"SSL_ERROR_INVALID_ERROR_CODE"</expr></argument>,
<argument><expr><name>PY_SSL_ERROR_INVALID_ERROR_CODE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"CERT_NONE"</expr></argument>,
<argument><expr><name>PY_SSL_CERT_NONE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"CERT_OPTIONAL"</expr></argument>,
<argument><expr><name>PY_SSL_CERT_OPTIONAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"CERT_REQUIRED"</expr></argument>,
<argument><expr><name>PY_SSL_CERT_REQUIRED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"PROTOCOL_SSLv2"</expr></argument>,
<argument><expr><name>PY_SSL_VERSION_SSL2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"PROTOCOL_SSLv3"</expr></argument>,
<argument><expr><name>PY_SSL_VERSION_SSL3</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"PROTOCOL_SSLv23"</expr></argument>,
<argument><expr><name>PY_SSL_VERSION_SSL23</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"PROTOCOL_TLSv1"</expr></argument>,
<argument><expr><name>PY_SSL_VERSION_TLS1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>
</unit>
