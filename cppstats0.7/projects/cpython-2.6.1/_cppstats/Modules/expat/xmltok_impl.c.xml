<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C" filename="projects/cpython-2.6.1/_cppstats/Modules/expat/xmltok_impl.c"><cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>IS_INVALID_CHAR</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IS_INVALID_CHAR</name><parameter_list>(<param><type><name>enc</name></type></param>, <param><type><name>ptr</name></type></param>, <param><type><name>n</name></type></param>)</parameter_list></cpp:macro> <cpp:value>(0)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INVALID_LEAD_CASE</name><parameter_list>(<param><type><name>n</name></type></param>, <param><type><name>ptr</name></type></param>, <param><type><name>nextTokPtr</name></type></param>)</parameter_list></cpp:macro> <cpp:value>case BT_LEAD ##n: if (end - ptr &lt; n) return XML_TOK_PARTIAL_CHAR; if (IS_INVALID_CHAR(enc, ptr, n)) { *(nextTokPtr) = (ptr); return XML_TOK_INVALID; } ptr += n; break;</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INVALID_CASES</name><parameter_list>(<param><type><name>ptr</name></type></param>, <param><type><name>nextTokPtr</name></type></param>)</parameter_list></cpp:macro> <cpp:value>INVALID_LEAD_CASE(2, ptr, nextTokPtr) INVALID_LEAD_CASE(3, ptr, nextTokPtr) INVALID_LEAD_CASE(4, ptr, nextTokPtr) case BT_NONXML: case BT_MALFORM: case BT_TRAIL: *(nextTokPtr) = (ptr); return XML_TOK_INVALID;</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CHECK_NAME_CASE</name><parameter_list>(<param><type><name>n</name></type></param>, <param><type><name>enc</name></type></param>, <param><type><name>ptr</name></type></param>, <param><type><name>end</name></type></param>, <param><type><name>nextTokPtr</name></type></param>)</parameter_list></cpp:macro> <cpp:value>case BT_LEAD ##n: if (end - ptr &lt; n) return XML_TOK_PARTIAL_CHAR; if (!IS_NAME_CHAR(enc, ptr, n)) { *nextTokPtr = ptr; return XML_TOK_INVALID; } ptr += n; break;</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CHECK_NAME_CASES</name><parameter_list>(<param><type><name>enc</name></type></param>, <param><type><name>ptr</name></type></param>, <param><type><name>end</name></type></param>, <param><type><name>nextTokPtr</name></type></param>)</parameter_list></cpp:macro> <cpp:value>case BT_NONASCII: if (!IS_NAME_CHAR_MINBPC(enc, ptr)) { *nextTokPtr = ptr; return XML_TOK_INVALID; } case BT_NMSTRT: case BT_HEX: case BT_DIGIT: case BT_NAME: case BT_MINUS: ptr += MINBPC(enc); break; CHECK_NAME_CASE(2, enc, ptr, end, nextTokPtr) CHECK_NAME_CASE(3, enc, ptr, end, nextTokPtr) CHECK_NAME_CASE(4, enc, ptr, end, nextTokPtr)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CHECK_NMSTRT_CASE</name><parameter_list>(<param><type><name>n</name></type></param>, <param><type><name>enc</name></type></param>, <param><type><name>ptr</name></type></param>, <param><type><name>end</name></type></param>, <param><type><name>nextTokPtr</name></type></param>)</parameter_list></cpp:macro> <cpp:value>case BT_LEAD ##n: if (end - ptr &lt; n) return XML_TOK_PARTIAL_CHAR; if (!IS_NMSTRT_CHAR(enc, ptr, n)) { *nextTokPtr = ptr; return XML_TOK_INVALID; } ptr += n; break;</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CHECK_NMSTRT_CASES</name><parameter_list>(<param><type><name>enc</name></type></param>, <param><type><name>ptr</name></type></param>, <param><type><name>end</name></type></param>, <param><type><name>nextTokPtr</name></type></param>)</parameter_list></cpp:macro> <cpp:value>case BT_NONASCII: if (!IS_NMSTRT_CHAR_MINBPC(enc, ptr)) { *nextTokPtr = ptr; return XML_TOK_INVALID; } case BT_NMSTRT: case BT_HEX: ptr += MINBPC(enc); break; CHECK_NMSTRT_CASE(2, enc, ptr, end, nextTokPtr) CHECK_NMSTRT_CASE(3, enc, ptr, end, nextTokPtr) CHECK_NMSTRT_CASE(4, enc, ptr, end, nextTokPtr)</cpp:value></cpp:define>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>PREFIX</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PREFIX</name><parameter_list>(<param><type><name>ident</name></type></param>)</parameter_list></cpp:macro> <cpp:value>ident</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<function><type><specifier>static</specifier> <name>int</name> <name>PTRCALL</name>
<name>PREFIX</name></type>(<name>scanComment</name>)<parameter_list>(<param><decl><type><specifier>const</specifier> <name>ENCODING</name> *</type><name>enc</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>ptr</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>end</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> **</type><name>nextTokPtr</name></decl></param>)</parameter_list> <block>{
<if>if <condition>(<expr><name>ptr</name> != <name>end</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr>!<call><name>CHAR_MATCHES</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>ASCII_MINUS</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr>*<name>nextTokPtr</name> = <name>ptr</name></expr>;</expr_stmt>
<return>return <expr><name>XML_TOK_INVALID</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>ptr</name> += <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<while>while <condition>(<expr><name>ptr</name> != <name>end</name></expr>)</condition> <block>{
<switch>switch <condition>(<expr><call><name>BYTE_TYPE</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{
<macro><name>INVALID_CASES</name><argument_list>(<argument>ptr</argument>, <argument>nextTokPtr</argument>)</argument_list></macro>
<case>case <expr><name>BT_MINUS</name></expr>:
<if>if <condition>(<expr>(<name>ptr</name> += <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call>) == <name>end</name></expr>)</condition><then>
<return>return <expr><name>XML_TOK_PARTIAL</name></expr>;</return></then></if>
<if>if <condition>(<expr><call><name>CHAR_MATCHES</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>ASCII_MINUS</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<if>if <condition>(<expr>(<name>ptr</name> += <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call>) == <name>end</name></expr>)</condition><then>
<return>return <expr><name>XML_TOK_PARTIAL</name></expr>;</return></then></if>
<if>if <condition>(<expr>!<call><name>CHAR_MATCHES</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>ASCII_GT</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr>*<name>nextTokPtr</name> = <name>ptr</name></expr>;</expr_stmt>
<return>return <expr><name>XML_TOK_INVALID</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr>*<name>nextTokPtr</name> = <name>ptr</name> + <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>XML_TOK_COMMENT</name></expr>;</return>
}</block></then></if>
<break>break;</break>
</case><default>default:
<expr_stmt><expr><name>ptr</name> += <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</default>}</block></switch>
}</block></while>
}</block></then></if>
<return>return <expr><name>XML_TOK_PARTIAL</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name> <name>PTRCALL</name>
<name>PREFIX</name></type>(<name>scanDecl</name>)<parameter_list>(<param><decl><type><specifier>const</specifier> <name>ENCODING</name> *</type><name>enc</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>ptr</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>end</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> **</type><name>nextTokPtr</name></decl></param>)</parameter_list> <block>{
<if>if <condition>(<expr><name>ptr</name> == <name>end</name></expr>)</condition><then>
<return>return <expr><name>XML_TOK_PARTIAL</name></expr>;</return></then></if>
<switch>switch <condition>(<expr><call><name>BYTE_TYPE</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{
<case>case <expr><name>BT_MINUS</name></expr>:
<return>return <expr><call><call><name>PREFIX</name><argument_list>(<argument><expr><name>scanComment</name></expr></argument>)</argument_list></call><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name> + <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><name>nextTokPtr</name></expr></argument>)</argument_list></call></expr>;</return>
</case><case>case <expr><name>BT_LSQB</name></expr>:
<expr_stmt><expr>*<name>nextTokPtr</name> = <name>ptr</name> + <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>XML_TOK_COND_SECT_OPEN</name></expr>;</return>
</case><case>case <expr><name>BT_NMSTRT</name></expr>:
</case><case>case <expr><name>BT_HEX</name></expr>:
<expr_stmt><expr><name>ptr</name> += <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</case><default>default:
<expr_stmt><expr>*<name>nextTokPtr</name> = <name>ptr</name></expr>;</expr_stmt>
<return>return <expr><name>XML_TOK_INVALID</name></expr>;</return>
</default>}</block></switch>
<while>while <condition>(<expr><name>ptr</name> != <name>end</name></expr>)</condition> <block>{
<switch>switch <condition>(<expr><call><name>BYTE_TYPE</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{
<case>case <expr><name>BT_PERCNT</name></expr>:
<if>if <condition>(<expr><name>ptr</name> + <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call> == <name>end</name></expr>)</condition><then>
<return>return <expr><name>XML_TOK_PARTIAL</name></expr>;</return></then></if>
<switch>switch <condition>(<expr><call><name>BYTE_TYPE</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name> + <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{
<case>case <expr><name>BT_S</name></expr>:
</case><case>case <expr><name>BT_CR</name></expr>:
</case><case>case <expr><name>BT_LF</name></expr>:
</case><case>case <expr><name>BT_PERCNT</name></expr>:
<expr_stmt><expr>*<name>nextTokPtr</name> = <name>ptr</name></expr>;</expr_stmt>
<return>return <expr><name>XML_TOK_INVALID</name></expr>;</return>
</case>}</block></switch>
</case><case>case <expr><name>BT_S</name></expr>:
</case><case>case <expr><name>BT_CR</name></expr>:
</case><case>case <expr><name>BT_LF</name></expr>:
<expr_stmt><expr>*<name>nextTokPtr</name> = <name>ptr</name></expr>;</expr_stmt>
<return>return <expr><name>XML_TOK_DECL_OPEN</name></expr>;</return>
</case><case>case <expr><name>BT_NMSTRT</name></expr>:
</case><case>case <expr><name>BT_HEX</name></expr>:
<expr_stmt><expr><name>ptr</name> += <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</case><default>default:
<expr_stmt><expr>*<name>nextTokPtr</name> = <name>ptr</name></expr>;</expr_stmt>
<return>return <expr><name>XML_TOK_INVALID</name></expr>;</return>
</default>}</block></switch>
}</block></while>
<return>return <expr><name>XML_TOK_PARTIAL</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name> <name>PTRCALL</name>
<name>PREFIX</name></type>(<name>checkPiTarget</name>)<parameter_list>(<param><decl><type><specifier>const</specifier> <name>ENCODING</name> *</type><name>enc</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>ptr</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>end</name></decl></param>, <param><decl><type><name>int</name> *</type><name>tokPtr</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>upper</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<expr_stmt><expr>*<name>tokPtr</name> = <name>XML_TOK_PI</name></expr>;</expr_stmt>
<if>if <condition>(<expr><name>end</name> - <name>ptr</name> != <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call>*3</expr>)</condition><then>
<return>return <expr>1</expr>;</return></then></if>
<switch>switch <condition>(<expr><call><name>BYTE_TO_ASCII</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{
<case>case <expr><name>ASCII_x</name></expr>:
<break>break;</break>
</case><case>case <expr><name>ASCII_X</name></expr>:
<expr_stmt><expr><name>upper</name> = 1</expr>;</expr_stmt>
<break>break;</break>
</case><default>default:
<return>return <expr>1</expr>;</return>
</default>}</block></switch>
<expr_stmt><expr><name>ptr</name> += <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<switch>switch <condition>(<expr><call><name>BYTE_TO_ASCII</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{
<case>case <expr><name>ASCII_m</name></expr>:
<break>break;</break>
</case><case>case <expr><name>ASCII_M</name></expr>:
<expr_stmt><expr><name>upper</name> = 1</expr>;</expr_stmt>
<break>break;</break>
</case><default>default:
<return>return <expr>1</expr>;</return>
</default>}</block></switch>
<expr_stmt><expr><name>ptr</name> += <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<switch>switch <condition>(<expr><call><name>BYTE_TO_ASCII</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{
<case>case <expr><name>ASCII_l</name></expr>:
<break>break;</break>
</case><case>case <expr><name>ASCII_L</name></expr>:
<expr_stmt><expr><name>upper</name> = 1</expr>;</expr_stmt>
<break>break;</break>
</case><default>default:
<return>return <expr>1</expr>;</return>
</default>}</block></switch>
<if>if <condition>(<expr><name>upper</name></expr>)</condition><then>
<return>return <expr>0</expr>;</return></then></if>
<expr_stmt><expr>*<name>tokPtr</name> = <name>XML_TOK_XML_DECL</name></expr>;</expr_stmt>
<return>return <expr>1</expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name> <name>PTRCALL</name>
<name>PREFIX</name></type>(<name>scanPi</name>)<parameter_list>(<param><decl><type><specifier>const</specifier> <name>ENCODING</name> *</type><name>enc</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>ptr</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>end</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> **</type><name>nextTokPtr</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>tok</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>target</name> <init>= <expr><name>ptr</name></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>ptr</name> == <name>end</name></expr>)</condition><then>
<return>return <expr><name>XML_TOK_PARTIAL</name></expr>;</return></then></if>
<switch>switch <condition>(<expr><call><name>BYTE_TYPE</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{
<macro><name>CHECK_NMSTRT_CASES</name><argument_list>(<argument>enc</argument>, <argument>ptr</argument>, <argument>end</argument>, <argument>nextTokPtr</argument>)</argument_list></macro>
<default>default:
<expr_stmt><expr>*<name>nextTokPtr</name> = <name>ptr</name></expr>;</expr_stmt>
<return>return <expr><name>XML_TOK_INVALID</name></expr>;</return>
</default>}</block></switch>
<while>while <condition>(<expr><name>ptr</name> != <name>end</name></expr>)</condition> <block>{
<switch>switch <condition>(<expr><call><name>BYTE_TYPE</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{
<macro><name>CHECK_NAME_CASES</name><argument_list>(<argument>enc</argument>, <argument>ptr</argument>, <argument>end</argument>, <argument>nextTokPtr</argument>)</argument_list></macro>
<case>case <expr><name>BT_S</name></expr>:
</case><case>case <expr><name>BT_CR</name></expr>:
</case><case>case <expr><name>BT_LF</name></expr>:
<if>if <condition>(<expr>!<call><call><name>PREFIX</name><argument_list>(<argument><expr><name>checkPiTarget</name></expr></argument>)</argument_list></call><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>target</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr>&amp;<name>tok</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr>*<name>nextTokPtr</name> = <name>ptr</name></expr>;</expr_stmt>
<return>return <expr><name>XML_TOK_INVALID</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>ptr</name> += <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<while>while <condition>(<expr><name>ptr</name> != <name>end</name></expr>)</condition> <block>{
<switch>switch <condition>(<expr><call><name>BYTE_TYPE</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{
<macro><name>INVALID_CASES</name><argument_list>(<argument>ptr</argument>, <argument>nextTokPtr</argument>)</argument_list></macro>
<case>case <expr><name>BT_QUEST</name></expr>:
<expr_stmt><expr><name>ptr</name> += <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>ptr</name> == <name>end</name></expr>)</condition><then>
<return>return <expr><name>XML_TOK_PARTIAL</name></expr>;</return></then></if>
<if>if <condition>(<expr><call><name>CHAR_MATCHES</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>ASCII_GT</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr>*<name>nextTokPtr</name> = <name>ptr</name> + <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>tok</name></expr>;</return>
}</block></then></if>
<break>break;</break>
</case><default>default:
<expr_stmt><expr><name>ptr</name> += <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</default>}</block></switch>
}</block></while>
<return>return <expr><name>XML_TOK_PARTIAL</name></expr>;</return>
</case><case>case <expr><name>BT_QUEST</name></expr>:
<if>if <condition>(<expr>!<call><call><name>PREFIX</name><argument_list>(<argument><expr><name>checkPiTarget</name></expr></argument>)</argument_list></call><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>target</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr>&amp;<name>tok</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr>*<name>nextTokPtr</name> = <name>ptr</name></expr>;</expr_stmt>
<return>return <expr><name>XML_TOK_INVALID</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>ptr</name> += <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>ptr</name> == <name>end</name></expr>)</condition><then>
<return>return <expr><name>XML_TOK_PARTIAL</name></expr>;</return></then></if>
<if>if <condition>(<expr><call><name>CHAR_MATCHES</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>ASCII_GT</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr>*<name>nextTokPtr</name> = <name>ptr</name> + <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>tok</name></expr>;</return>
}</block></then></if>
</case><default>default:
<expr_stmt><expr>*<name>nextTokPtr</name> = <name>ptr</name></expr>;</expr_stmt>
<return>return <expr><name>XML_TOK_INVALID</name></expr>;</return>
</default>}</block></switch>
}</block></while>
<return>return <expr><name>XML_TOK_PARTIAL</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name> <name>PTRCALL</name>
<name>PREFIX</name></type>(<name>scanCdataSection</name>)<parameter_list>(<param><decl><type><specifier>const</specifier> <name>ENCODING</name> *</type><name>enc</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>ptr</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>end</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> **</type><name>nextTokPtr</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name></type> <name><name>CDATA_LSQB</name><index>[]</index></name> <init>= <expr><block>{ <expr><name>ASCII_C</name></expr>, <expr><name>ASCII_D</name></expr>, <expr><name>ASCII_A</name></expr>,
<expr><name>ASCII_T</name></expr>, <expr><name>ASCII_A</name></expr>, <expr><name>ASCII_LSQB</name></expr>
}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<if>if <condition>(<expr><name>end</name> - <name>ptr</name> &lt; 6 * <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>XML_TOK_PARTIAL</name></expr>;</return></then></if>
<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; 6</expr>;</condition> <incr><expr><name>i</name>++</expr>, <expr><name>ptr</name> += <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr></incr>) <block>{
<if>if <condition>(<expr>!<call><name>CHAR_MATCHES</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name><name>CDATA_LSQB</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr>*<name>nextTokPtr</name> = <name>ptr</name></expr>;</expr_stmt>
<return>return <expr><name>XML_TOK_INVALID</name></expr>;</return>
}</block></then></if>
}</block></for>
<expr_stmt><expr>*<name>nextTokPtr</name> = <name>ptr</name></expr>;</expr_stmt>
<return>return <expr><name>XML_TOK_CDATA_SECT_OPEN</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name> <name>PTRCALL</name>
<name>PREFIX</name></type>(<name>cdataSectionTok</name>)<parameter_list>(<param><decl><type><specifier>const</specifier> <name>ENCODING</name> *</type><name>enc</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>ptr</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>end</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> **</type><name>nextTokPtr</name></decl></param>)</parameter_list> <block>{
<if>if <condition>(<expr><name>ptr</name> == <name>end</name></expr>)</condition><then>
<return>return <expr><name>XML_TOK_NONE</name></expr>;</return></then></if>
<if>if <condition>(<expr><call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call> &gt; 1</expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>size_t</name></type> <name>n</name> <init>= <expr><name>end</name> - <name>ptr</name></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>n</name> &amp; (<call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call> - 1)</expr>)</condition><then> <block>{
<expr_stmt><expr><name>n</name> &amp;= ~(<call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call> - 1)</expr>;</expr_stmt>
<if>if <condition>(<expr><name>n</name> == 0</expr>)</condition><then>
<return>return <expr><name>XML_TOK_PARTIAL</name></expr>;</return></then></if>
<expr_stmt><expr><name>end</name> = <name>ptr</name> + <name>n</name></expr>;</expr_stmt>
}</block></then></if>
}</block></then></if>
<switch>switch <condition>(<expr><call><name>BYTE_TYPE</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{
<case>case <expr><name>BT_RSQB</name></expr>:
<expr_stmt><expr><name>ptr</name> += <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>ptr</name> == <name>end</name></expr>)</condition><then>
<return>return <expr><name>XML_TOK_PARTIAL</name></expr>;</return></then></if>
<if>if <condition>(<expr>!<call><name>CHAR_MATCHES</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>ASCII_RSQB</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<break>break;</break></then></if>
<expr_stmt><expr><name>ptr</name> += <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>ptr</name> == <name>end</name></expr>)</condition><then>
<return>return <expr><name>XML_TOK_PARTIAL</name></expr>;</return></then></if>
<if>if <condition>(<expr>!<call><name>CHAR_MATCHES</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>ASCII_GT</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><name>ptr</name> -= <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
}</block></then></if>
<expr_stmt><expr>*<name>nextTokPtr</name> = <name>ptr</name> + <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>XML_TOK_CDATA_SECT_CLOSE</name></expr>;</return>
</case><case>case <expr><name>BT_CR</name></expr>:
<expr_stmt><expr><name>ptr</name> += <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>ptr</name> == <name>end</name></expr>)</condition><then>
<return>return <expr><name>XML_TOK_PARTIAL</name></expr>;</return></then></if>
<if>if <condition>(<expr><call><name>BYTE_TYPE</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>)</argument_list></call> == <name>BT_LF</name></expr>)</condition><then>
<expr_stmt><expr><name>ptr</name> += <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<expr_stmt><expr>*<name>nextTokPtr</name> = <name>ptr</name></expr>;</expr_stmt>
<return>return <expr><name>XML_TOK_DATA_NEWLINE</name></expr>;</return>
</case><case>case <expr><name>BT_LF</name></expr>:
<expr_stmt><expr>*<name>nextTokPtr</name> = <name>ptr</name> + <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>XML_TOK_DATA_NEWLINE</name></expr>;</return>
<macro><name>INVALID_CASES</name><argument_list>(<argument>ptr</argument>, <argument>nextTokPtr</argument>)</argument_list></macro>
</case><default>default:
<expr_stmt><expr><name>ptr</name> += <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</default>}</block></switch>
<while>while <condition>(<expr><name>ptr</name> != <name>end</name></expr>)</condition> <block>{
<switch>switch <condition>(<expr><call><name>BYTE_TYPE</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LEAD_CASE</name><parameter_list>(<param><type><name>n</name></type></param>)</parameter_list></cpp:macro> <cpp:value>case BT_LEAD ##n: if (end - ptr &lt; n || IS_INVALID_CHAR(enc, ptr, n)) { *nextTokPtr = ptr; return XML_TOK_DATA_CHARS; } ptr += n; break;</cpp:value></cpp:define>
<macro><name>LEAD_CASE</name><argument_list>(<argument>2</argument>)</argument_list></macro> <macro><name>LEAD_CASE</name><argument_list>(<argument>3</argument>)</argument_list></macro> <macro><name>LEAD_CASE</name><argument_list>(<argument>4</argument>)</argument_list></macro>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>LEAD_CASE</name></cpp:undef>
<case>case <expr><name>BT_NONXML</name></expr>:
</case><case>case <expr><name>BT_MALFORM</name></expr>:
</case><case>case <expr><name>BT_TRAIL</name></expr>:
</case><case>case <expr><name>BT_CR</name></expr>:
</case><case>case <expr><name>BT_LF</name></expr>:
</case><case>case <expr><name>BT_RSQB</name></expr>:
<expr_stmt><expr>*<name>nextTokPtr</name> = <name>ptr</name></expr>;</expr_stmt>
<return>return <expr><name>XML_TOK_DATA_CHARS</name></expr>;</return>
</case><default>default:
<expr_stmt><expr><name>ptr</name> += <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</default>}</block></switch>
}</block></while>
<expr_stmt><expr>*<name>nextTokPtr</name> = <name>ptr</name></expr>;</expr_stmt>
<return>return <expr><name>XML_TOK_DATA_CHARS</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name> <name>PTRCALL</name>
<name>PREFIX</name></type>(<name>scanEndTag</name>)<parameter_list>(<param><decl><type><specifier>const</specifier> <name>ENCODING</name> *</type><name>enc</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>ptr</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>end</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> **</type><name>nextTokPtr</name></decl></param>)</parameter_list> <block>{
<if>if <condition>(<expr><name>ptr</name> == <name>end</name></expr>)</condition><then>
<return>return <expr><name>XML_TOK_PARTIAL</name></expr>;</return></then></if>
<switch>switch <condition>(<expr><call><name>BYTE_TYPE</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{
<macro><name>CHECK_NMSTRT_CASES</name><argument_list>(<argument>enc</argument>, <argument>ptr</argument>, <argument>end</argument>, <argument>nextTokPtr</argument>)</argument_list></macro>
<default>default:
<expr_stmt><expr>*<name>nextTokPtr</name> = <name>ptr</name></expr>;</expr_stmt>
<return>return <expr><name>XML_TOK_INVALID</name></expr>;</return>
</default>}</block></switch>
<while>while <condition>(<expr><name>ptr</name> != <name>end</name></expr>)</condition> <block>{
<switch>switch <condition>(<expr><call><name>BYTE_TYPE</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{
<macro><name>CHECK_NAME_CASES</name><argument_list>(<argument>enc</argument>, <argument>ptr</argument>, <argument>end</argument>, <argument>nextTokPtr</argument>)</argument_list></macro>
<case>case <expr><name>BT_S</name></expr>:
</case><case>case <expr><name>BT_CR</name></expr>:
</case><case>case <expr><name>BT_LF</name></expr>:
<for>for (<init><expr><name>ptr</name> += <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</init> <condition><expr><name>ptr</name> != <name>end</name></expr>;</condition> <incr><expr><name>ptr</name> += <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr></incr>) <block>{
<switch>switch <condition>(<expr><call><name>BYTE_TYPE</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{
<case>case <expr><name>BT_S</name></expr>:
</case><case>case <expr><name>BT_CR</name></expr>:
</case><case>case <expr><name>BT_LF</name></expr>:
<break>break;</break>
</case><case>case <expr><name>BT_GT</name></expr>:
<expr_stmt><expr>*<name>nextTokPtr</name> = <name>ptr</name> + <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>XML_TOK_END_TAG</name></expr>;</return>
</case><default>default:
<expr_stmt><expr>*<name>nextTokPtr</name> = <name>ptr</name></expr>;</expr_stmt>
<return>return <expr><name>XML_TOK_INVALID</name></expr>;</return>
</default>}</block></switch>
}</block></for>
<return>return <expr><name>XML_TOK_PARTIAL</name></expr>;</return>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>XML_NS</name></expr></argument>)</argument_list></call></expr></cpp:if>
</case><case>case <expr><name>BT_COLON</name></expr>:
<expr_stmt><expr><name>ptr</name> += <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</case><case>case <expr><name>BT_GT</name></expr>:
<expr_stmt><expr>*<name>nextTokPtr</name> = <name>ptr</name> + <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>XML_TOK_END_TAG</name></expr>;</return>
</case><default>default:
<expr_stmt><expr>*<name>nextTokPtr</name> = <name>ptr</name></expr>;</expr_stmt>
<return>return <expr><name>XML_TOK_INVALID</name></expr>;</return>
</default>}</block></switch>
}</block></while>
<return>return <expr><name>XML_TOK_PARTIAL</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name> <name>PTRCALL</name>
<name>PREFIX</name></type>(<name>scanHexCharRef</name>)<parameter_list>(<param><decl><type><specifier>const</specifier> <name>ENCODING</name> *</type><name>enc</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>ptr</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>end</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> **</type><name>nextTokPtr</name></decl></param>)</parameter_list> <block>{
<if>if <condition>(<expr><name>ptr</name> != <name>end</name></expr>)</condition><then> <block>{
<switch>switch <condition>(<expr><call><name>BYTE_TYPE</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{
<case>case <expr><name>BT_DIGIT</name></expr>:
</case><case>case <expr><name>BT_HEX</name></expr>:
<break>break;</break>
</case><default>default:
<expr_stmt><expr>*<name>nextTokPtr</name> = <name>ptr</name></expr>;</expr_stmt>
<return>return <expr><name>XML_TOK_INVALID</name></expr>;</return>
</default>}</block></switch>
<for>for (<init><expr><name>ptr</name> += <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</init> <condition><expr><name>ptr</name> != <name>end</name></expr>;</condition> <incr><expr><name>ptr</name> += <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr></incr>) <block>{
<switch>switch <condition>(<expr><call><name>BYTE_TYPE</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{
<case>case <expr><name>BT_DIGIT</name></expr>:
</case><case>case <expr><name>BT_HEX</name></expr>:
<break>break;</break>
</case><case>case <expr><name>BT_SEMI</name></expr>:
<expr_stmt><expr>*<name>nextTokPtr</name> = <name>ptr</name> + <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>XML_TOK_CHAR_REF</name></expr>;</return>
</case><default>default:
<expr_stmt><expr>*<name>nextTokPtr</name> = <name>ptr</name></expr>;</expr_stmt>
<return>return <expr><name>XML_TOK_INVALID</name></expr>;</return>
</default>}</block></switch>
}</block></for>
}</block></then></if>
<return>return <expr><name>XML_TOK_PARTIAL</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name> <name>PTRCALL</name>
<name>PREFIX</name></type>(<name>scanCharRef</name>)<parameter_list>(<param><decl><type><specifier>const</specifier> <name>ENCODING</name> *</type><name>enc</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>ptr</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>end</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> **</type><name>nextTokPtr</name></decl></param>)</parameter_list> <block>{
<if>if <condition>(<expr><name>ptr</name> != <name>end</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr><call><name>CHAR_MATCHES</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>ASCII_x</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><call><call><name>PREFIX</name><argument_list>(<argument><expr><name>scanHexCharRef</name></expr></argument>)</argument_list></call><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name> + <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><name>nextTokPtr</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
<switch>switch <condition>(<expr><call><name>BYTE_TYPE</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{
<case>case <expr><name>BT_DIGIT</name></expr>:
<break>break;</break>
</case><default>default:
<expr_stmt><expr>*<name>nextTokPtr</name> = <name>ptr</name></expr>;</expr_stmt>
<return>return <expr><name>XML_TOK_INVALID</name></expr>;</return>
</default>}</block></switch>
<for>for (<init><expr><name>ptr</name> += <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</init> <condition><expr><name>ptr</name> != <name>end</name></expr>;</condition> <incr><expr><name>ptr</name> += <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr></incr>) <block>{
<switch>switch <condition>(<expr><call><name>BYTE_TYPE</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{
<case>case <expr><name>BT_DIGIT</name></expr>:
<break>break;</break>
</case><case>case <expr><name>BT_SEMI</name></expr>:
<expr_stmt><expr>*<name>nextTokPtr</name> = <name>ptr</name> + <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>XML_TOK_CHAR_REF</name></expr>;</return>
</case><default>default:
<expr_stmt><expr>*<name>nextTokPtr</name> = <name>ptr</name></expr>;</expr_stmt>
<return>return <expr><name>XML_TOK_INVALID</name></expr>;</return>
</default>}</block></switch>
}</block></for>
}</block></then></if>
<return>return <expr><name>XML_TOK_PARTIAL</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name> <name>PTRCALL</name>
<name>PREFIX</name></type>(<name>scanRef</name>)<parameter_list>(<param><decl><type><specifier>const</specifier> <name>ENCODING</name> *</type><name>enc</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>ptr</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>end</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> **</type><name>nextTokPtr</name></decl></param>)</parameter_list> <block>{
<if>if <condition>(<expr><name>ptr</name> == <name>end</name></expr>)</condition><then>
<return>return <expr><name>XML_TOK_PARTIAL</name></expr>;</return></then></if>
<switch>switch <condition>(<expr><call><name>BYTE_TYPE</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{
<macro><name>CHECK_NMSTRT_CASES</name><argument_list>(<argument>enc</argument>, <argument>ptr</argument>, <argument>end</argument>, <argument>nextTokPtr</argument>)</argument_list></macro>
<case>case <expr><name>BT_NUM</name></expr>:
<return>return <expr><call><call><name>PREFIX</name><argument_list>(<argument><expr><name>scanCharRef</name></expr></argument>)</argument_list></call><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name> + <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><name>nextTokPtr</name></expr></argument>)</argument_list></call></expr>;</return>
</case><default>default:
<expr_stmt><expr>*<name>nextTokPtr</name> = <name>ptr</name></expr>;</expr_stmt>
<return>return <expr><name>XML_TOK_INVALID</name></expr>;</return>
</default>}</block></switch>
<while>while <condition>(<expr><name>ptr</name> != <name>end</name></expr>)</condition> <block>{
<switch>switch <condition>(<expr><call><name>BYTE_TYPE</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{
<macro><name>CHECK_NAME_CASES</name><argument_list>(<argument>enc</argument>, <argument>ptr</argument>, <argument>end</argument>, <argument>nextTokPtr</argument>)</argument_list></macro>
<case>case <expr><name>BT_SEMI</name></expr>:
<expr_stmt><expr>*<name>nextTokPtr</name> = <name>ptr</name> + <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>XML_TOK_ENTITY_REF</name></expr>;</return>
</case><default>default:
<expr_stmt><expr>*<name>nextTokPtr</name> = <name>ptr</name></expr>;</expr_stmt>
<return>return <expr><name>XML_TOK_INVALID</name></expr>;</return>
</default>}</block></switch>
}</block></while>
<return>return <expr><name>XML_TOK_PARTIAL</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name> <name>PTRCALL</name>
<name>PREFIX</name></type>(<name>scanAtts</name>)<parameter_list>(<param><decl><type><specifier>const</specifier> <name>ENCODING</name> *</type><name>enc</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>ptr</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>end</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> **</type><name>nextTokPtr</name></decl></param>)</parameter_list> <block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>XML_NS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>int</name></type> <name>hadColon</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<while>while <condition>(<expr><name>ptr</name> != <name>end</name></expr>)</condition> <block>{
<switch>switch <condition>(<expr><call><name>BYTE_TYPE</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{
<macro><name>CHECK_NAME_CASES</name><argument_list>(<argument>enc</argument>, <argument>ptr</argument>, <argument>end</argument>, <argument>nextTokPtr</argument>)</argument_list></macro>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>XML_NS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<case>case <expr><name>BT_COLON</name></expr>:
<if>if <condition>(<expr><name>hadColon</name></expr>)</condition><then> <block>{
<expr_stmt><expr>*<name>nextTokPtr</name> = <name>ptr</name></expr>;</expr_stmt>
<return>return <expr><name>XML_TOK_INVALID</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>hadColon</name> = 1</expr>;</expr_stmt>
<expr_stmt><expr><name>ptr</name> += <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>ptr</name> == <name>end</name></expr>)</condition><then>
<return>return <expr><name>XML_TOK_PARTIAL</name></expr>;</return></then></if>
<switch>switch <condition>(<expr><call><name>BYTE_TYPE</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{
<macro><name>CHECK_NMSTRT_CASES</name><argument_list>(<argument>enc</argument>, <argument>ptr</argument>, <argument>end</argument>, <argument>nextTokPtr</argument>)</argument_list></macro>
<default>default:
<expr_stmt><expr>*<name>nextTokPtr</name> = <name>ptr</name></expr>;</expr_stmt>
<return>return <expr><name>XML_TOK_INVALID</name></expr>;</return>
</default>}</block></switch>
<break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</case><case>case <expr><name>BT_S</name></expr>:
</case><case>case <expr><name>BT_CR</name></expr>:
</case><case>case <expr><name>BT_LF</name></expr>:
<for>for (<init>;</init><condition>;</condition><incr/>) <block>{
<decl_stmt><decl><type><name>int</name></type> <name>t</name></decl>;</decl_stmt>
<expr_stmt><expr><name>ptr</name> += <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>ptr</name> == <name>end</name></expr>)</condition><then>
<return>return <expr><name>XML_TOK_PARTIAL</name></expr>;</return></then></if>
<expr_stmt><expr><name>t</name> = <call><name>BYTE_TYPE</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>t</name> == <name>BT_EQUALS</name></expr>)</condition><then>
<break>break;</break></then></if>
<switch>switch <condition>(<expr><name>t</name></expr>)</condition> <block>{
<case>case <expr><name>BT_S</name></expr>:
</case><case>case <expr><name>BT_LF</name></expr>:
</case><case>case <expr><name>BT_CR</name></expr>:
<break>break;</break>
</case><default>default:
<expr_stmt><expr>*<name>nextTokPtr</name> = <name>ptr</name></expr>;</expr_stmt>
<return>return <expr><name>XML_TOK_INVALID</name></expr>;</return>
</default>}</block></switch>
}</block></for>
</case><case>case <expr><name>BT_EQUALS</name></expr>: <block>{
<decl_stmt><decl><type><name>int</name></type> <name>open</name></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>XML_NS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><name>hadColon</name> = 0</expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<for>for (<init>;</init><condition>;</condition><incr/>) <block>{
<expr_stmt><expr><name>ptr</name> += <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>ptr</name> == <name>end</name></expr>)</condition><then>
<return>return <expr><name>XML_TOK_PARTIAL</name></expr>;</return></then></if>
<expr_stmt><expr><name>open</name> = <call><name>BYTE_TYPE</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>open</name> == <name>BT_QUOT</name> || <name>open</name> == <name>BT_APOS</name></expr>)</condition><then>
<break>break;</break></then></if>
<switch>switch <condition>(<expr><name>open</name></expr>)</condition> <block>{
<case>case <expr><name>BT_S</name></expr>:
</case><case>case <expr><name>BT_LF</name></expr>:
</case><case>case <expr><name>BT_CR</name></expr>:
<break>break;</break>
</case><default>default:
<expr_stmt><expr>*<name>nextTokPtr</name> = <name>ptr</name></expr>;</expr_stmt>
<return>return <expr><name>XML_TOK_INVALID</name></expr>;</return>
</default>}</block></switch>
}</block></for>
<expr_stmt><expr><name>ptr</name> += <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for (<init>;</init><condition>;</condition><incr/>) <block>{
<decl_stmt><decl><type><name>int</name></type> <name>t</name></decl>;</decl_stmt>
<if>if <condition>(<expr><name>ptr</name> == <name>end</name></expr>)</condition><then>
<return>return <expr><name>XML_TOK_PARTIAL</name></expr>;</return></then></if>
<expr_stmt><expr><name>t</name> = <call><name>BYTE_TYPE</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>t</name> == <name>open</name></expr>)</condition><then>
<break>break;</break></then></if>
<switch>switch <condition>(<expr><name>t</name></expr>)</condition> <block>{
<macro><name>INVALID_CASES</name><argument_list>(<argument>ptr</argument>, <argument>nextTokPtr</argument>)</argument_list></macro>
<case>case <expr><name>BT_AMP</name></expr>: <block>{
<decl_stmt><decl><type><name>int</name></type> <name>tok</name> <init>= <expr><call><call><name>PREFIX</name><argument_list>(<argument><expr><name>scanRef</name></expr></argument>)</argument_list></call><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name> + <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr>&amp;<name>ptr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>tok</name> &lt;= 0</expr>)</condition><then> <block>{
<if>if <condition>(<expr><name>tok</name> == <name>XML_TOK_INVALID</name></expr>)</condition><then>
<expr_stmt><expr>*<name>nextTokPtr</name> = <name>ptr</name></expr>;</expr_stmt></then></if>
<return>return <expr><name>tok</name></expr>;</return>
}</block></then></if>
<break>break;</break>
}</block>
</case><case>case <expr><name>BT_LT</name></expr>:
<expr_stmt><expr>*<name>nextTokPtr</name> = <name>ptr</name></expr>;</expr_stmt>
<return>return <expr><name>XML_TOK_INVALID</name></expr>;</return>
</case><default>default:
<expr_stmt><expr><name>ptr</name> += <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</default>}</block></switch>
}</block></for>
<expr_stmt><expr><name>ptr</name> += <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>ptr</name> == <name>end</name></expr>)</condition><then>
<return>return <expr><name>XML_TOK_PARTIAL</name></expr>;</return></then></if>
<switch>switch <condition>(<expr><call><name>BYTE_TYPE</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{
<case>case <expr><name>BT_S</name></expr>:
</case><case>case <expr><name>BT_CR</name></expr>:
</case><case>case <expr><name>BT_LF</name></expr>:
<break>break;</break>
</case><case>case <expr><name>BT_SOL</name></expr>:
<goto>goto <name>sol</name>;</goto>
</case><case>case <expr><name>BT_GT</name></expr>:
<goto>goto <name>gt</name>;</goto>
</case><default>default:
<expr_stmt><expr>*<name>nextTokPtr</name> = <name>ptr</name></expr>;</expr_stmt>
<return>return <expr><name>XML_TOK_INVALID</name></expr>;</return>
</default>}</block></switch>
<for>for (<init>;</init><condition>;</condition><incr/>) <block>{
<expr_stmt><expr><name>ptr</name> += <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>ptr</name> == <name>end</name></expr>)</condition><then>
<return>return <expr><name>XML_TOK_PARTIAL</name></expr>;</return></then></if>
<switch>switch <condition>(<expr><call><name>BYTE_TYPE</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{
<macro><name>CHECK_NMSTRT_CASES</name><argument_list>(<argument>enc</argument>, <argument>ptr</argument>, <argument>end</argument>, <argument>nextTokPtr</argument>)</argument_list></macro>
<case>case <expr><name>BT_S</name></expr>:
</case><case>case <expr><name>BT_CR</name></expr>:
</case><case>case <expr><name>BT_LF</name></expr>:
<continue>continue;</continue>
</case><case>case <expr><name>BT_GT</name></expr>:
<label><name>gt</name>:</label>
<expr_stmt><expr>*<name>nextTokPtr</name> = <name>ptr</name> + <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>XML_TOK_START_TAG_WITH_ATTS</name></expr>;</return>
</case><case>case <expr><name>BT_SOL</name></expr>:
<label><name>sol</name>:</label>
<expr_stmt><expr><name>ptr</name> += <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>ptr</name> == <name>end</name></expr>)</condition><then>
<return>return <expr><name>XML_TOK_PARTIAL</name></expr>;</return></then></if>
<if>if <condition>(<expr>!<call><name>CHAR_MATCHES</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>ASCII_GT</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr>*<name>nextTokPtr</name> = <name>ptr</name></expr>;</expr_stmt>
<return>return <expr><name>XML_TOK_INVALID</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr>*<name>nextTokPtr</name> = <name>ptr</name> + <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>XML_TOK_EMPTY_ELEMENT_WITH_ATTS</name></expr>;</return>
</case><default>default:
<expr_stmt><expr>*<name>nextTokPtr</name> = <name>ptr</name></expr>;</expr_stmt>
<return>return <expr><name>XML_TOK_INVALID</name></expr>;</return>
</default>}</block></switch>
<break>break;</break>
}</block></for>
<break>break;</break>
}</block>
</case><default>default:
<expr_stmt><expr>*<name>nextTokPtr</name> = <name>ptr</name></expr>;</expr_stmt>
<return>return <expr><name>XML_TOK_INVALID</name></expr>;</return>
</default>}</block></switch>
}</block></while>
<return>return <expr><name>XML_TOK_PARTIAL</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name> <name>PTRCALL</name>
<name>PREFIX</name></type>(<name>scanLt</name>)<parameter_list>(<param><decl><type><specifier>const</specifier> <name>ENCODING</name> *</type><name>enc</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>ptr</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>end</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> **</type><name>nextTokPtr</name></decl></param>)</parameter_list> <block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>XML_NS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>int</name></type> <name>hadColon</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<if>if <condition>(<expr><name>ptr</name> == <name>end</name></expr>)</condition><then>
<return>return <expr><name>XML_TOK_PARTIAL</name></expr>;</return></then></if>
<switch>switch <condition>(<expr><call><name>BYTE_TYPE</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{
<macro><name>CHECK_NMSTRT_CASES</name><argument_list>(<argument>enc</argument>, <argument>ptr</argument>, <argument>end</argument>, <argument>nextTokPtr</argument>)</argument_list></macro>
<case>case <expr><name>BT_EXCL</name></expr>:
<if>if <condition>(<expr>(<name>ptr</name> += <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call>) == <name>end</name></expr>)</condition><then>
<return>return <expr><name>XML_TOK_PARTIAL</name></expr>;</return></then></if>
<switch>switch <condition>(<expr><call><name>BYTE_TYPE</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{
<case>case <expr><name>BT_MINUS</name></expr>:
<return>return <expr><call><call><name>PREFIX</name><argument_list>(<argument><expr><name>scanComment</name></expr></argument>)</argument_list></call><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name> + <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><name>nextTokPtr</name></expr></argument>)</argument_list></call></expr>;</return>
</case><case>case <expr><name>BT_LSQB</name></expr>:
<return>return <expr><call><call><name>PREFIX</name><argument_list>(<argument><expr><name>scanCdataSection</name></expr></argument>)</argument_list></call><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name> + <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>end</name></expr></argument>, <argument><expr><name>nextTokPtr</name></expr></argument>)</argument_list></call></expr>;</return>
</case>}</block></switch>
<expr_stmt><expr>*<name>nextTokPtr</name> = <name>ptr</name></expr>;</expr_stmt>
<return>return <expr><name>XML_TOK_INVALID</name></expr>;</return>
</case><case>case <expr><name>BT_QUEST</name></expr>:
<return>return <expr><call><call><name>PREFIX</name><argument_list>(<argument><expr><name>scanPi</name></expr></argument>)</argument_list></call><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name> + <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><name>nextTokPtr</name></expr></argument>)</argument_list></call></expr>;</return>
</case><case>case <expr><name>BT_SOL</name></expr>:
<return>return <expr><call><call><name>PREFIX</name><argument_list>(<argument><expr><name>scanEndTag</name></expr></argument>)</argument_list></call><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name> + <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><name>nextTokPtr</name></expr></argument>)</argument_list></call></expr>;</return>
</case><default>default:
<expr_stmt><expr>*<name>nextTokPtr</name> = <name>ptr</name></expr>;</expr_stmt>
<return>return <expr><name>XML_TOK_INVALID</name></expr>;</return>
</default>}</block></switch>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>XML_NS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><name>hadColon</name> = 0</expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<while>while <condition>(<expr><name>ptr</name> != <name>end</name></expr>)</condition> <block>{
<switch>switch <condition>(<expr><call><name>BYTE_TYPE</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{
<macro><name>CHECK_NAME_CASES</name><argument_list>(<argument>enc</argument>, <argument>ptr</argument>, <argument>end</argument>, <argument>nextTokPtr</argument>)</argument_list></macro>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>XML_NS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<case>case <expr><name>BT_COLON</name></expr>:
<if>if <condition>(<expr><name>hadColon</name></expr>)</condition><then> <block>{
<expr_stmt><expr>*<name>nextTokPtr</name> = <name>ptr</name></expr>;</expr_stmt>
<return>return <expr><name>XML_TOK_INVALID</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>hadColon</name> = 1</expr>;</expr_stmt>
<expr_stmt><expr><name>ptr</name> += <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>ptr</name> == <name>end</name></expr>)</condition><then>
<return>return <expr><name>XML_TOK_PARTIAL</name></expr>;</return></then></if>
<switch>switch <condition>(<expr><call><name>BYTE_TYPE</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{
<macro><name>CHECK_NMSTRT_CASES</name><argument_list>(<argument>enc</argument>, <argument>ptr</argument>, <argument>end</argument>, <argument>nextTokPtr</argument>)</argument_list></macro>
<default>default:
<expr_stmt><expr>*<name>nextTokPtr</name> = <name>ptr</name></expr>;</expr_stmt>
<return>return <expr><name>XML_TOK_INVALID</name></expr>;</return>
</default>}</block></switch>
<break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</case><case>case <expr><name>BT_S</name></expr>:
</case><case>case <expr><name>BT_CR</name></expr>:
</case><case>case <expr><name>BT_LF</name></expr>: <block>{
<expr_stmt><expr><name>ptr</name> += <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<while>while <condition>(<expr><name>ptr</name> != <name>end</name></expr>)</condition> <block>{
<switch>switch <condition>(<expr><call><name>BYTE_TYPE</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{
<macro><name>CHECK_NMSTRT_CASES</name><argument_list>(<argument>enc</argument>, <argument>ptr</argument>, <argument>end</argument>, <argument>nextTokPtr</argument>)</argument_list></macro>
<case>case <expr><name>BT_GT</name></expr>:
<goto>goto <name>gt</name>;</goto>
</case><case>case <expr><name>BT_SOL</name></expr>:
<goto>goto <name>sol</name>;</goto>
</case><case>case <expr><name>BT_S</name></expr>:
</case><case>case <expr><name>BT_CR</name></expr>:
</case><case>case <expr><name>BT_LF</name></expr>:
<expr_stmt><expr><name>ptr</name> += <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<continue>continue;</continue>
</case><default>default:
<expr_stmt><expr>*<name>nextTokPtr</name> = <name>ptr</name></expr>;</expr_stmt>
<return>return <expr><name>XML_TOK_INVALID</name></expr>;</return>
</default>}</block></switch>
<return>return <expr><call><call><name>PREFIX</name><argument_list>(<argument><expr><name>scanAtts</name></expr></argument>)</argument_list></call><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><name>nextTokPtr</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></while>
<return>return <expr><name>XML_TOK_PARTIAL</name></expr>;</return>
}</block>
</case><case>case <expr><name>BT_GT</name></expr>:
<label><name>gt</name>:</label>
<expr_stmt><expr>*<name>nextTokPtr</name> = <name>ptr</name> + <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>XML_TOK_START_TAG_NO_ATTS</name></expr>;</return>
</case><case>case <expr><name>BT_SOL</name></expr>:
<label><name>sol</name>:</label>
<expr_stmt><expr><name>ptr</name> += <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>ptr</name> == <name>end</name></expr>)</condition><then>
<return>return <expr><name>XML_TOK_PARTIAL</name></expr>;</return></then></if>
<if>if <condition>(<expr>!<call><name>CHAR_MATCHES</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>ASCII_GT</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr>*<name>nextTokPtr</name> = <name>ptr</name></expr>;</expr_stmt>
<return>return <expr><name>XML_TOK_INVALID</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr>*<name>nextTokPtr</name> = <name>ptr</name> + <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>XML_TOK_EMPTY_ELEMENT_NO_ATTS</name></expr>;</return>
</case><default>default:
<expr_stmt><expr>*<name>nextTokPtr</name> = <name>ptr</name></expr>;</expr_stmt>
<return>return <expr><name>XML_TOK_INVALID</name></expr>;</return>
</default>}</block></switch>
}</block></while>
<return>return <expr><name>XML_TOK_PARTIAL</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name> <name>PTRCALL</name>
<name>PREFIX</name></type>(<name>contentTok</name>)<parameter_list>(<param><decl><type><specifier>const</specifier> <name>ENCODING</name> *</type><name>enc</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>ptr</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>end</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> **</type><name>nextTokPtr</name></decl></param>)</parameter_list> <block>{
<if>if <condition>(<expr><name>ptr</name> == <name>end</name></expr>)</condition><then>
<return>return <expr><name>XML_TOK_NONE</name></expr>;</return></then></if>
<if>if <condition>(<expr><call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call> &gt; 1</expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>size_t</name></type> <name>n</name> <init>= <expr><name>end</name> - <name>ptr</name></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>n</name> &amp; (<call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call> - 1)</expr>)</condition><then> <block>{
<expr_stmt><expr><name>n</name> &amp;= ~(<call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call> - 1)</expr>;</expr_stmt>
<if>if <condition>(<expr><name>n</name> == 0</expr>)</condition><then>
<return>return <expr><name>XML_TOK_PARTIAL</name></expr>;</return></then></if>
<expr_stmt><expr><name>end</name> = <name>ptr</name> + <name>n</name></expr>;</expr_stmt>
}</block></then></if>
}</block></then></if>
<switch>switch <condition>(<expr><call><name>BYTE_TYPE</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{
<case>case <expr><name>BT_LT</name></expr>:
<return>return <expr><call><call><name>PREFIX</name><argument_list>(<argument><expr><name>scanLt</name></expr></argument>)</argument_list></call><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name> + <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><name>nextTokPtr</name></expr></argument>)</argument_list></call></expr>;</return>
</case><case>case <expr><name>BT_AMP</name></expr>:
<return>return <expr><call><call><name>PREFIX</name><argument_list>(<argument><expr><name>scanRef</name></expr></argument>)</argument_list></call><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name> + <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><name>nextTokPtr</name></expr></argument>)</argument_list></call></expr>;</return>
</case><case>case <expr><name>BT_CR</name></expr>:
<expr_stmt><expr><name>ptr</name> += <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>ptr</name> == <name>end</name></expr>)</condition><then>
<return>return <expr><name>XML_TOK_TRAILING_CR</name></expr>;</return></then></if>
<if>if <condition>(<expr><call><name>BYTE_TYPE</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>)</argument_list></call> == <name>BT_LF</name></expr>)</condition><then>
<expr_stmt><expr><name>ptr</name> += <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<expr_stmt><expr>*<name>nextTokPtr</name> = <name>ptr</name></expr>;</expr_stmt>
<return>return <expr><name>XML_TOK_DATA_NEWLINE</name></expr>;</return>
</case><case>case <expr><name>BT_LF</name></expr>:
<expr_stmt><expr>*<name>nextTokPtr</name> = <name>ptr</name> + <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>XML_TOK_DATA_NEWLINE</name></expr>;</return>
</case><case>case <expr><name>BT_RSQB</name></expr>:
<expr_stmt><expr><name>ptr</name> += <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>ptr</name> == <name>end</name></expr>)</condition><then>
<return>return <expr><name>XML_TOK_TRAILING_RSQB</name></expr>;</return></then></if>
<if>if <condition>(<expr>!<call><name>CHAR_MATCHES</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>ASCII_RSQB</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<break>break;</break></then></if>
<expr_stmt><expr><name>ptr</name> += <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>ptr</name> == <name>end</name></expr>)</condition><then>
<return>return <expr><name>XML_TOK_TRAILING_RSQB</name></expr>;</return></then></if>
<if>if <condition>(<expr>!<call><name>CHAR_MATCHES</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>ASCII_GT</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><name>ptr</name> -= <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
}</block></then></if>
<expr_stmt><expr>*<name>nextTokPtr</name> = <name>ptr</name></expr>;</expr_stmt>
<return>return <expr><name>XML_TOK_INVALID</name></expr>;</return>
<macro><name>INVALID_CASES</name><argument_list>(<argument>ptr</argument>, <argument>nextTokPtr</argument>)</argument_list></macro>
</case><default>default:
<expr_stmt><expr><name>ptr</name> += <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</default>}</block></switch>
<while>while <condition>(<expr><name>ptr</name> != <name>end</name></expr>)</condition> <block>{
<switch>switch <condition>(<expr><call><name>BYTE_TYPE</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LEAD_CASE</name><parameter_list>(<param><type><name>n</name></type></param>)</parameter_list></cpp:macro> <cpp:value>case BT_LEAD ##n: if (end - ptr &lt; n || IS_INVALID_CHAR(enc, ptr, n)) { *nextTokPtr = ptr; return XML_TOK_DATA_CHARS; } ptr += n; break;</cpp:value></cpp:define>
<macro><name>LEAD_CASE</name><argument_list>(<argument>2</argument>)</argument_list></macro> <macro><name>LEAD_CASE</name><argument_list>(<argument>3</argument>)</argument_list></macro> <macro><name>LEAD_CASE</name><argument_list>(<argument>4</argument>)</argument_list></macro>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>LEAD_CASE</name></cpp:undef>
<case>case <expr><name>BT_RSQB</name></expr>:
<if>if <condition>(<expr><name>ptr</name> + <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call> != <name>end</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr>!<call><name>CHAR_MATCHES</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name> + <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>ASCII_RSQB</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><name>ptr</name> += <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
}</block></then></if>
<if>if <condition>(<expr><name>ptr</name> + 2*<call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call> != <name>end</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr>!<call><name>CHAR_MATCHES</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name> + 2*<call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>ASCII_GT</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><name>ptr</name> += <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
}</block></then></if>
<expr_stmt><expr>*<name>nextTokPtr</name> = <name>ptr</name> + 2*<call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>XML_TOK_INVALID</name></expr>;</return>
}</block></then></if>
}</block></then></if>
</case><case>case <expr><name>BT_AMP</name></expr>:
</case><case>case <expr><name>BT_LT</name></expr>:
</case><case>case <expr><name>BT_NONXML</name></expr>:
</case><case>case <expr><name>BT_MALFORM</name></expr>:
</case><case>case <expr><name>BT_TRAIL</name></expr>:
</case><case>case <expr><name>BT_CR</name></expr>:
</case><case>case <expr><name>BT_LF</name></expr>:
<expr_stmt><expr>*<name>nextTokPtr</name> = <name>ptr</name></expr>;</expr_stmt>
<return>return <expr><name>XML_TOK_DATA_CHARS</name></expr>;</return>
</case><default>default:
<expr_stmt><expr><name>ptr</name> += <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</default>}</block></switch>
}</block></while>
<expr_stmt><expr>*<name>nextTokPtr</name> = <name>ptr</name></expr>;</expr_stmt>
<return>return <expr><name>XML_TOK_DATA_CHARS</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name> <name>PTRCALL</name>
<name>PREFIX</name></type>(<name>scanPercent</name>)<parameter_list>(<param><decl><type><specifier>const</specifier> <name>ENCODING</name> *</type><name>enc</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>ptr</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>end</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> **</type><name>nextTokPtr</name></decl></param>)</parameter_list> <block>{
<if>if <condition>(<expr><name>ptr</name> == <name>end</name></expr>)</condition><then>
<return>return <expr>-<name>XML_TOK_PERCENT</name></expr>;</return></then></if>
<switch>switch <condition>(<expr><call><name>BYTE_TYPE</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{
<macro><name>CHECK_NMSTRT_CASES</name><argument_list>(<argument>enc</argument>, <argument>ptr</argument>, <argument>end</argument>, <argument>nextTokPtr</argument>)</argument_list></macro>
<case>case <expr><name>BT_S</name></expr>:
</case><case>case <expr><name>BT_LF</name></expr>:
</case><case>case <expr><name>BT_CR</name></expr>:
</case><case>case <expr><name>BT_PERCNT</name></expr>:
<expr_stmt><expr>*<name>nextTokPtr</name> = <name>ptr</name></expr>;</expr_stmt>
<return>return <expr><name>XML_TOK_PERCENT</name></expr>;</return>
</case><default>default:
<expr_stmt><expr>*<name>nextTokPtr</name> = <name>ptr</name></expr>;</expr_stmt>
<return>return <expr><name>XML_TOK_INVALID</name></expr>;</return>
</default>}</block></switch>
<while>while <condition>(<expr><name>ptr</name> != <name>end</name></expr>)</condition> <block>{
<switch>switch <condition>(<expr><call><name>BYTE_TYPE</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{
<macro><name>CHECK_NAME_CASES</name><argument_list>(<argument>enc</argument>, <argument>ptr</argument>, <argument>end</argument>, <argument>nextTokPtr</argument>)</argument_list></macro>
<case>case <expr><name>BT_SEMI</name></expr>:
<expr_stmt><expr>*<name>nextTokPtr</name> = <name>ptr</name> + <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>XML_TOK_PARAM_ENTITY_REF</name></expr>;</return>
</case><default>default:
<expr_stmt><expr>*<name>nextTokPtr</name> = <name>ptr</name></expr>;</expr_stmt>
<return>return <expr><name>XML_TOK_INVALID</name></expr>;</return>
</default>}</block></switch>
}</block></while>
<return>return <expr><name>XML_TOK_PARTIAL</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name> <name>PTRCALL</name>
<name>PREFIX</name></type>(<name>scanPoundName</name>)<parameter_list>(<param><decl><type><specifier>const</specifier> <name>ENCODING</name> *</type><name>enc</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>ptr</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>end</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> **</type><name>nextTokPtr</name></decl></param>)</parameter_list> <block>{
<if>if <condition>(<expr><name>ptr</name> == <name>end</name></expr>)</condition><then>
<return>return <expr><name>XML_TOK_PARTIAL</name></expr>;</return></then></if>
<switch>switch <condition>(<expr><call><name>BYTE_TYPE</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{
<macro><name>CHECK_NMSTRT_CASES</name><argument_list>(<argument>enc</argument>, <argument>ptr</argument>, <argument>end</argument>, <argument>nextTokPtr</argument>)</argument_list></macro>
<default>default:
<expr_stmt><expr>*<name>nextTokPtr</name> = <name>ptr</name></expr>;</expr_stmt>
<return>return <expr><name>XML_TOK_INVALID</name></expr>;</return>
</default>}</block></switch>
<while>while <condition>(<expr><name>ptr</name> != <name>end</name></expr>)</condition> <block>{
<switch>switch <condition>(<expr><call><name>BYTE_TYPE</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{
<macro><name>CHECK_NAME_CASES</name><argument_list>(<argument>enc</argument>, <argument>ptr</argument>, <argument>end</argument>, <argument>nextTokPtr</argument>)</argument_list></macro>
<case>case <expr><name>BT_CR</name></expr>:
</case><case>case <expr><name>BT_LF</name></expr>:
</case><case>case <expr><name>BT_S</name></expr>:
</case><case>case <expr><name>BT_RPAR</name></expr>:
</case><case>case <expr><name>BT_GT</name></expr>:
</case><case>case <expr><name>BT_PERCNT</name></expr>:
</case><case>case <expr><name>BT_VERBAR</name></expr>:
<expr_stmt><expr>*<name>nextTokPtr</name> = <name>ptr</name></expr>;</expr_stmt>
<return>return <expr><name>XML_TOK_POUND_NAME</name></expr>;</return>
</case><default>default:
<expr_stmt><expr>*<name>nextTokPtr</name> = <name>ptr</name></expr>;</expr_stmt>
<return>return <expr><name>XML_TOK_INVALID</name></expr>;</return>
</default>}</block></switch>
}</block></while>
<return>return <expr>-<name>XML_TOK_POUND_NAME</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name> <name>PTRCALL</name>
<name>PREFIX</name></type>(<name>scanLit</name>)<parameter_list>(<param><decl><type><name>int</name></type> <name>open</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>ENCODING</name> *</type><name>enc</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>ptr</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>end</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> **</type><name>nextTokPtr</name></decl></param>)</parameter_list> <block>{
<while>while <condition>(<expr><name>ptr</name> != <name>end</name></expr>)</condition> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>t</name> <init>= <expr><call><name>BYTE_TYPE</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<switch>switch <condition>(<expr><name>t</name></expr>)</condition> <block>{
<macro><name>INVALID_CASES</name><argument_list>(<argument>ptr</argument>, <argument>nextTokPtr</argument>)</argument_list></macro>
<case>case <expr><name>BT_QUOT</name></expr>:
</case><case>case <expr><name>BT_APOS</name></expr>:
<expr_stmt><expr><name>ptr</name> += <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>t</name> != <name>open</name></expr>)</condition><then>
<break>break;</break></then></if>
<if>if <condition>(<expr><name>ptr</name> == <name>end</name></expr>)</condition><then>
<return>return <expr>-<name>XML_TOK_LITERAL</name></expr>;</return></then></if>
<expr_stmt><expr>*<name>nextTokPtr</name> = <name>ptr</name></expr>;</expr_stmt>
<switch>switch <condition>(<expr><call><name>BYTE_TYPE</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{
<case>case <expr><name>BT_S</name></expr>:
</case><case>case <expr><name>BT_CR</name></expr>:
</case><case>case <expr><name>BT_LF</name></expr>:
</case><case>case <expr><name>BT_GT</name></expr>:
</case><case>case <expr><name>BT_PERCNT</name></expr>:
</case><case>case <expr><name>BT_LSQB</name></expr>:
<return>return <expr><name>XML_TOK_LITERAL</name></expr>;</return>
</case><default>default:
<return>return <expr><name>XML_TOK_INVALID</name></expr>;</return>
</default>}</block></switch>
</case><default>default:
<expr_stmt><expr><name>ptr</name> += <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</default>}</block></switch>
}</block></while>
<return>return <expr><name>XML_TOK_PARTIAL</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name> <name>PTRCALL</name>
<name>PREFIX</name></type>(<name>prologTok</name>)<parameter_list>(<param><decl><type><specifier>const</specifier> <name>ENCODING</name> *</type><name>enc</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>ptr</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>end</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> **</type><name>nextTokPtr</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>tok</name></decl>;</decl_stmt>
<if>if <condition>(<expr><name>ptr</name> == <name>end</name></expr>)</condition><then>
<return>return <expr><name>XML_TOK_NONE</name></expr>;</return></then></if>
<if>if <condition>(<expr><call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call> &gt; 1</expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>size_t</name></type> <name>n</name> <init>= <expr><name>end</name> - <name>ptr</name></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>n</name> &amp; (<call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call> - 1)</expr>)</condition><then> <block>{
<expr_stmt><expr><name>n</name> &amp;= ~(<call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call> - 1)</expr>;</expr_stmt>
<if>if <condition>(<expr><name>n</name> == 0</expr>)</condition><then>
<return>return <expr><name>XML_TOK_PARTIAL</name></expr>;</return></then></if>
<expr_stmt><expr><name>end</name> = <name>ptr</name> + <name>n</name></expr>;</expr_stmt>
}</block></then></if>
}</block></then></if>
<switch>switch <condition>(<expr><call><name>BYTE_TYPE</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{
<case>case <expr><name>BT_QUOT</name></expr>:
<return>return <expr><call><call><name>PREFIX</name><argument_list>(<argument><expr><name>scanLit</name></expr></argument>)</argument_list></call><argument_list>(<argument><expr><name>BT_QUOT</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name> + <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><name>nextTokPtr</name></expr></argument>)</argument_list></call></expr>;</return>
</case><case>case <expr><name>BT_APOS</name></expr>:
<return>return <expr><call><call><name>PREFIX</name><argument_list>(<argument><expr><name>scanLit</name></expr></argument>)</argument_list></call><argument_list>(<argument><expr><name>BT_APOS</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name> + <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><name>nextTokPtr</name></expr></argument>)</argument_list></call></expr>;</return>
</case><case>case <expr><name>BT_LT</name></expr>: <block>{
<expr_stmt><expr><name>ptr</name> += <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>ptr</name> == <name>end</name></expr>)</condition><then>
<return>return <expr><name>XML_TOK_PARTIAL</name></expr>;</return></then></if>
<switch>switch <condition>(<expr><call><name>BYTE_TYPE</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{
<case>case <expr><name>BT_EXCL</name></expr>:
<return>return <expr><call><call><name>PREFIX</name><argument_list>(<argument><expr><name>scanDecl</name></expr></argument>)</argument_list></call><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name> + <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><name>nextTokPtr</name></expr></argument>)</argument_list></call></expr>;</return>
</case><case>case <expr><name>BT_QUEST</name></expr>:
<return>return <expr><call><call><name>PREFIX</name><argument_list>(<argument><expr><name>scanPi</name></expr></argument>)</argument_list></call><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name> + <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><name>nextTokPtr</name></expr></argument>)</argument_list></call></expr>;</return>
</case><case>case <expr><name>BT_NMSTRT</name></expr>:
</case><case>case <expr><name>BT_HEX</name></expr>:
</case><case>case <expr><name>BT_NONASCII</name></expr>:
</case><case>case <expr><name>BT_LEAD2</name></expr>:
</case><case>case <expr><name>BT_LEAD3</name></expr>:
</case><case>case <expr><name>BT_LEAD4</name></expr>:
<expr_stmt><expr>*<name>nextTokPtr</name> = <name>ptr</name> - <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>XML_TOK_INSTANCE_START</name></expr>;</return>
</case>}</block></switch>
<expr_stmt><expr>*<name>nextTokPtr</name> = <name>ptr</name></expr>;</expr_stmt>
<return>return <expr><name>XML_TOK_INVALID</name></expr>;</return>
}</block>
</case><case>case <expr><name>BT_CR</name></expr>:
<if>if <condition>(<expr><name>ptr</name> + <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call> == <name>end</name></expr>)</condition><then> <block>{
<expr_stmt><expr>*<name>nextTokPtr</name> = <name>end</name></expr>;</expr_stmt>
<return>return <expr>-<name>XML_TOK_PROLOG_S</name></expr>;</return>
}</block></then></if>
</case><case>case <expr><name>BT_S</name></expr>:
</case><case>case <expr><name>BT_LF</name></expr>:
<for>for (<init>;</init><condition>;</condition><incr/>) <block>{
<expr_stmt><expr><name>ptr</name> += <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>ptr</name> == <name>end</name></expr>)</condition><then>
<break>break;</break></then></if>
<switch>switch <condition>(<expr><call><name>BYTE_TYPE</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{
<case>case <expr><name>BT_S</name></expr>:
</case><case>case <expr><name>BT_LF</name></expr>:
<break>break;</break>
</case><case>case <expr><name>BT_CR</name></expr>:
<if>if <condition>(<expr><name>ptr</name> + <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call> != <name>end</name></expr>)</condition><then>
<break>break;</break></then></if>
</case><default>default:
<expr_stmt><expr>*<name>nextTokPtr</name> = <name>ptr</name></expr>;</expr_stmt>
<return>return <expr><name>XML_TOK_PROLOG_S</name></expr>;</return>
</default>}</block></switch>
}</block></for>
<expr_stmt><expr>*<name>nextTokPtr</name> = <name>ptr</name></expr>;</expr_stmt>
<return>return <expr><name>XML_TOK_PROLOG_S</name></expr>;</return>
</case><case>case <expr><name>BT_PERCNT</name></expr>:
<return>return <expr><call><call><name>PREFIX</name><argument_list>(<argument><expr><name>scanPercent</name></expr></argument>)</argument_list></call><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name> + <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><name>nextTokPtr</name></expr></argument>)</argument_list></call></expr>;</return>
</case><case>case <expr><name>BT_COMMA</name></expr>:
<expr_stmt><expr>*<name>nextTokPtr</name> = <name>ptr</name> + <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>XML_TOK_COMMA</name></expr>;</return>
</case><case>case <expr><name>BT_LSQB</name></expr>:
<expr_stmt><expr>*<name>nextTokPtr</name> = <name>ptr</name> + <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>XML_TOK_OPEN_BRACKET</name></expr>;</return>
</case><case>case <expr><name>BT_RSQB</name></expr>:
<expr_stmt><expr><name>ptr</name> += <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>ptr</name> == <name>end</name></expr>)</condition><then>
<return>return <expr>-<name>XML_TOK_CLOSE_BRACKET</name></expr>;</return></then></if>
<if>if <condition>(<expr><call><name>CHAR_MATCHES</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>ASCII_RSQB</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<if>if <condition>(<expr><name>ptr</name> + <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call> == <name>end</name></expr>)</condition><then>
<return>return <expr><name>XML_TOK_PARTIAL</name></expr>;</return></then></if>
<if>if <condition>(<expr><call><name>CHAR_MATCHES</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name> + <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>ASCII_GT</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr>*<name>nextTokPtr</name> = <name>ptr</name> + 2*<call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>XML_TOK_COND_SECT_CLOSE</name></expr>;</return>
}</block></then></if>
}</block></then></if>
<expr_stmt><expr>*<name>nextTokPtr</name> = <name>ptr</name></expr>;</expr_stmt>
<return>return <expr><name>XML_TOK_CLOSE_BRACKET</name></expr>;</return>
</case><case>case <expr><name>BT_LPAR</name></expr>:
<expr_stmt><expr>*<name>nextTokPtr</name> = <name>ptr</name> + <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>XML_TOK_OPEN_PAREN</name></expr>;</return>
</case><case>case <expr><name>BT_RPAR</name></expr>:
<expr_stmt><expr><name>ptr</name> += <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>ptr</name> == <name>end</name></expr>)</condition><then>
<return>return <expr>-<name>XML_TOK_CLOSE_PAREN</name></expr>;</return></then></if>
<switch>switch <condition>(<expr><call><name>BYTE_TYPE</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{
<case>case <expr><name>BT_AST</name></expr>:
<expr_stmt><expr>*<name>nextTokPtr</name> = <name>ptr</name> + <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>XML_TOK_CLOSE_PAREN_ASTERISK</name></expr>;</return>
</case><case>case <expr><name>BT_QUEST</name></expr>:
<expr_stmt><expr>*<name>nextTokPtr</name> = <name>ptr</name> + <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>XML_TOK_CLOSE_PAREN_QUESTION</name></expr>;</return>
</case><case>case <expr><name>BT_PLUS</name></expr>:
<expr_stmt><expr>*<name>nextTokPtr</name> = <name>ptr</name> + <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>XML_TOK_CLOSE_PAREN_PLUS</name></expr>;</return>
</case><case>case <expr><name>BT_CR</name></expr>:
</case><case>case <expr><name>BT_LF</name></expr>:
</case><case>case <expr><name>BT_S</name></expr>:
</case><case>case <expr><name>BT_GT</name></expr>:
</case><case>case <expr><name>BT_COMMA</name></expr>:
</case><case>case <expr><name>BT_VERBAR</name></expr>:
</case><case>case <expr><name>BT_RPAR</name></expr>:
<expr_stmt><expr>*<name>nextTokPtr</name> = <name>ptr</name></expr>;</expr_stmt>
<return>return <expr><name>XML_TOK_CLOSE_PAREN</name></expr>;</return>
</case>}</block></switch>
<expr_stmt><expr>*<name>nextTokPtr</name> = <name>ptr</name></expr>;</expr_stmt>
<return>return <expr><name>XML_TOK_INVALID</name></expr>;</return>
</case><case>case <expr><name>BT_VERBAR</name></expr>:
<expr_stmt><expr>*<name>nextTokPtr</name> = <name>ptr</name> + <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>XML_TOK_OR</name></expr>;</return>
</case><case>case <expr><name>BT_GT</name></expr>:
<expr_stmt><expr>*<name>nextTokPtr</name> = <name>ptr</name> + <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>XML_TOK_DECL_CLOSE</name></expr>;</return>
</case><case>case <expr><name>BT_NUM</name></expr>:
<return>return <expr><call><call><name>PREFIX</name><argument_list>(<argument><expr><name>scanPoundName</name></expr></argument>)</argument_list></call><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name> + <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><name>nextTokPtr</name></expr></argument>)</argument_list></call></expr>;</return>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LEAD_CASE</name><parameter_list>(<param><type><name>n</name></type></param>)</parameter_list></cpp:macro> <cpp:value>case BT_LEAD ##n: if (end - ptr &lt; n) return XML_TOK_PARTIAL_CHAR; if (IS_NMSTRT_CHAR(enc, ptr, n)) { ptr += n; tok = XML_TOK_NAME; break; } if (IS_NAME_CHAR(enc, ptr, n)) { ptr += n; tok = XML_TOK_NMTOKEN; break; } *nextTokPtr = ptr; return XML_TOK_INVALID;</cpp:value></cpp:define>
<macro><name>LEAD_CASE</name><argument_list>(<argument>2</argument>)</argument_list></macro> <macro><name>LEAD_CASE</name><argument_list>(<argument>3</argument>)</argument_list></macro> <macro><name>LEAD_CASE</name><argument_list>(<argument>4</argument>)</argument_list></macro>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>LEAD_CASE</name></cpp:undef>
</case><case>case <expr><name>BT_NMSTRT</name></expr>:
</case><case>case <expr><name>BT_HEX</name></expr>:
<expr_stmt><expr><name>tok</name> = <name>XML_TOK_NAME</name></expr>;</expr_stmt>
<expr_stmt><expr><name>ptr</name> += <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr><name>BT_DIGIT</name></expr>:
</case><case>case <expr><name>BT_NAME</name></expr>:
</case><case>case <expr><name>BT_MINUS</name></expr>:
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>XML_NS</name></expr></argument>)</argument_list></call></expr></cpp:if>
</case><case>case <expr><name>BT_COLON</name></expr>:
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><name>tok</name> = <name>XML_TOK_NMTOKEN</name></expr>;</expr_stmt>
<expr_stmt><expr><name>ptr</name> += <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr><name>BT_NONASCII</name></expr>:
<if>if <condition>(<expr><call><name>IS_NMSTRT_CHAR_MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><name>ptr</name> += <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>tok</name> = <name>XML_TOK_NAME</name></expr>;</expr_stmt>
<break>break;</break>
}</block></then></if>
<if>if <condition>(<expr><call><name>IS_NAME_CHAR_MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><name>ptr</name> += <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>tok</name> = <name>XML_TOK_NMTOKEN</name></expr>;</expr_stmt>
<break>break;</break>
}</block></then></if>
</case><default>default:
<expr_stmt><expr>*<name>nextTokPtr</name> = <name>ptr</name></expr>;</expr_stmt>
<return>return <expr><name>XML_TOK_INVALID</name></expr>;</return>
</default>}</block></switch>
<while>while <condition>(<expr><name>ptr</name> != <name>end</name></expr>)</condition> <block>{
<switch>switch <condition>(<expr><call><name>BYTE_TYPE</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{
<macro><name>CHECK_NAME_CASES</name><argument_list>(<argument>enc</argument>, <argument>ptr</argument>, <argument>end</argument>, <argument>nextTokPtr</argument>)</argument_list></macro>
<case>case <expr><name>BT_GT</name></expr>:
</case><case>case <expr><name>BT_RPAR</name></expr>:
</case><case>case <expr><name>BT_COMMA</name></expr>:
</case><case>case <expr><name>BT_VERBAR</name></expr>:
</case><case>case <expr><name>BT_LSQB</name></expr>:
</case><case>case <expr><name>BT_PERCNT</name></expr>:
</case><case>case <expr><name>BT_S</name></expr>:
</case><case>case <expr><name>BT_CR</name></expr>:
</case><case>case <expr><name>BT_LF</name></expr>:
<expr_stmt><expr>*<name>nextTokPtr</name> = <name>ptr</name></expr>;</expr_stmt>
<return>return <expr><name>tok</name></expr>;</return>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>XML_NS</name></expr></argument>)</argument_list></call></expr></cpp:if>
</case><case>case <expr><name>BT_COLON</name></expr>:
<expr_stmt><expr><name>ptr</name> += <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<switch>switch <condition>(<expr><name>tok</name></expr>)</condition> <block>{
<case>case <expr><name>XML_TOK_NAME</name></expr>:
<if>if <condition>(<expr><name>ptr</name> == <name>end</name></expr>)</condition><then>
<return>return <expr><name>XML_TOK_PARTIAL</name></expr>;</return></then></if>
<expr_stmt><expr><name>tok</name> = <name>XML_TOK_PREFIXED_NAME</name></expr>;</expr_stmt>
<switch>switch <condition>(<expr><call><name>BYTE_TYPE</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{
<macro><name>CHECK_NAME_CASES</name><argument_list>(<argument>enc</argument>, <argument>ptr</argument>, <argument>end</argument>, <argument>nextTokPtr</argument>)</argument_list></macro>
<default>default:
<expr_stmt><expr><name>tok</name> = <name>XML_TOK_NMTOKEN</name></expr>;</expr_stmt>
<break>break;</break>
</default>}</block></switch>
<break>break;</break>
</case><case>case <expr><name>XML_TOK_PREFIXED_NAME</name></expr>:
<expr_stmt><expr><name>tok</name> = <name>XML_TOK_NMTOKEN</name></expr>;</expr_stmt>
<break>break;</break>
</case>}</block></switch>
<break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</case><case>case <expr><name>BT_PLUS</name></expr>:
<if>if <condition>(<expr><name>tok</name> == <name>XML_TOK_NMTOKEN</name></expr>)</condition><then> <block>{
<expr_stmt><expr>*<name>nextTokPtr</name> = <name>ptr</name></expr>;</expr_stmt>
<return>return <expr><name>XML_TOK_INVALID</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr>*<name>nextTokPtr</name> = <name>ptr</name> + <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>XML_TOK_NAME_PLUS</name></expr>;</return>
</case><case>case <expr><name>BT_AST</name></expr>:
<if>if <condition>(<expr><name>tok</name> == <name>XML_TOK_NMTOKEN</name></expr>)</condition><then> <block>{
<expr_stmt><expr>*<name>nextTokPtr</name> = <name>ptr</name></expr>;</expr_stmt>
<return>return <expr><name>XML_TOK_INVALID</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr>*<name>nextTokPtr</name> = <name>ptr</name> + <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>XML_TOK_NAME_ASTERISK</name></expr>;</return>
</case><case>case <expr><name>BT_QUEST</name></expr>:
<if>if <condition>(<expr><name>tok</name> == <name>XML_TOK_NMTOKEN</name></expr>)</condition><then> <block>{
<expr_stmt><expr>*<name>nextTokPtr</name> = <name>ptr</name></expr>;</expr_stmt>
<return>return <expr><name>XML_TOK_INVALID</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr>*<name>nextTokPtr</name> = <name>ptr</name> + <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>XML_TOK_NAME_QUESTION</name></expr>;</return>
</case><default>default:
<expr_stmt><expr>*<name>nextTokPtr</name> = <name>ptr</name></expr>;</expr_stmt>
<return>return <expr><name>XML_TOK_INVALID</name></expr>;</return>
</default>}</block></switch>
}</block></while>
<return>return <expr>-<name>tok</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name> <name>PTRCALL</name>
<name>PREFIX</name></type>(<name>attributeValueTok</name>)<parameter_list>(<param><decl><type><specifier>const</specifier> <name>ENCODING</name> *</type><name>enc</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>ptr</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>end</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> **</type><name>nextTokPtr</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>start</name></decl>;</decl_stmt>
<if>if <condition>(<expr><name>ptr</name> == <name>end</name></expr>)</condition><then>
<return>return <expr><name>XML_TOK_NONE</name></expr>;</return></then></if>
<expr_stmt><expr><name>start</name> = <name>ptr</name></expr>;</expr_stmt>
<while>while <condition>(<expr><name>ptr</name> != <name>end</name></expr>)</condition> <block>{
<switch>switch <condition>(<expr><call><name>BYTE_TYPE</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LEAD_CASE</name><parameter_list>(<param><type><name>n</name></type></param>)</parameter_list></cpp:macro> <cpp:value>case BT_LEAD ##n: ptr += n; break;</cpp:value></cpp:define>
<macro><name>LEAD_CASE</name><argument_list>(<argument>2</argument>)</argument_list></macro> <macro><name>LEAD_CASE</name><argument_list>(<argument>3</argument>)</argument_list></macro> <macro><name>LEAD_CASE</name><argument_list>(<argument>4</argument>)</argument_list></macro>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>LEAD_CASE</name></cpp:undef>
<case>case <expr><name>BT_AMP</name></expr>:
<if>if <condition>(<expr><name>ptr</name> == <name>start</name></expr>)</condition><then>
<return>return <expr><call><call><name>PREFIX</name><argument_list>(<argument><expr><name>scanRef</name></expr></argument>)</argument_list></call><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name> + <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><name>nextTokPtr</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
<expr_stmt><expr>*<name>nextTokPtr</name> = <name>ptr</name></expr>;</expr_stmt>
<return>return <expr><name>XML_TOK_DATA_CHARS</name></expr>;</return>
</case><case>case <expr><name>BT_LT</name></expr>:
<expr_stmt><expr>*<name>nextTokPtr</name> = <name>ptr</name></expr>;</expr_stmt>
<return>return <expr><name>XML_TOK_INVALID</name></expr>;</return>
</case><case>case <expr><name>BT_LF</name></expr>:
<if>if <condition>(<expr><name>ptr</name> == <name>start</name></expr>)</condition><then> <block>{
<expr_stmt><expr>*<name>nextTokPtr</name> = <name>ptr</name> + <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>XML_TOK_DATA_NEWLINE</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr>*<name>nextTokPtr</name> = <name>ptr</name></expr>;</expr_stmt>
<return>return <expr><name>XML_TOK_DATA_CHARS</name></expr>;</return>
</case><case>case <expr><name>BT_CR</name></expr>:
<if>if <condition>(<expr><name>ptr</name> == <name>start</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>ptr</name> += <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>ptr</name> == <name>end</name></expr>)</condition><then>
<return>return <expr><name>XML_TOK_TRAILING_CR</name></expr>;</return></then></if>
<if>if <condition>(<expr><call><name>BYTE_TYPE</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>)</argument_list></call> == <name>BT_LF</name></expr>)</condition><then>
<expr_stmt><expr><name>ptr</name> += <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<expr_stmt><expr>*<name>nextTokPtr</name> = <name>ptr</name></expr>;</expr_stmt>
<return>return <expr><name>XML_TOK_DATA_NEWLINE</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr>*<name>nextTokPtr</name> = <name>ptr</name></expr>;</expr_stmt>
<return>return <expr><name>XML_TOK_DATA_CHARS</name></expr>;</return>
</case><case>case <expr><name>BT_S</name></expr>:
<if>if <condition>(<expr><name>ptr</name> == <name>start</name></expr>)</condition><then> <block>{
<expr_stmt><expr>*<name>nextTokPtr</name> = <name>ptr</name> + <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>XML_TOK_ATTRIBUTE_VALUE_S</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr>*<name>nextTokPtr</name> = <name>ptr</name></expr>;</expr_stmt>
<return>return <expr><name>XML_TOK_DATA_CHARS</name></expr>;</return>
</case><default>default:
<expr_stmt><expr><name>ptr</name> += <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</default>}</block></switch>
}</block></while>
<expr_stmt><expr>*<name>nextTokPtr</name> = <name>ptr</name></expr>;</expr_stmt>
<return>return <expr><name>XML_TOK_DATA_CHARS</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name> <name>PTRCALL</name>
<name>PREFIX</name></type>(<name>entityValueTok</name>)<parameter_list>(<param><decl><type><specifier>const</specifier> <name>ENCODING</name> *</type><name>enc</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>ptr</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>end</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> **</type><name>nextTokPtr</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>start</name></decl>;</decl_stmt>
<if>if <condition>(<expr><name>ptr</name> == <name>end</name></expr>)</condition><then>
<return>return <expr><name>XML_TOK_NONE</name></expr>;</return></then></if>
<expr_stmt><expr><name>start</name> = <name>ptr</name></expr>;</expr_stmt>
<while>while <condition>(<expr><name>ptr</name> != <name>end</name></expr>)</condition> <block>{
<switch>switch <condition>(<expr><call><name>BYTE_TYPE</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LEAD_CASE</name><parameter_list>(<param><type><name>n</name></type></param>)</parameter_list></cpp:macro> <cpp:value>case BT_LEAD ##n: ptr += n; break;</cpp:value></cpp:define>
<macro><name>LEAD_CASE</name><argument_list>(<argument>2</argument>)</argument_list></macro> <macro><name>LEAD_CASE</name><argument_list>(<argument>3</argument>)</argument_list></macro> <macro><name>LEAD_CASE</name><argument_list>(<argument>4</argument>)</argument_list></macro>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>LEAD_CASE</name></cpp:undef>
<case>case <expr><name>BT_AMP</name></expr>:
<if>if <condition>(<expr><name>ptr</name> == <name>start</name></expr>)</condition><then>
<return>return <expr><call><call><name>PREFIX</name><argument_list>(<argument><expr><name>scanRef</name></expr></argument>)</argument_list></call><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name> + <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><name>nextTokPtr</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
<expr_stmt><expr>*<name>nextTokPtr</name> = <name>ptr</name></expr>;</expr_stmt>
<return>return <expr><name>XML_TOK_DATA_CHARS</name></expr>;</return>
</case><case>case <expr><name>BT_PERCNT</name></expr>:
<if>if <condition>(<expr><name>ptr</name> == <name>start</name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>tok</name> <init>= <expr><call><call><name>PREFIX</name><argument_list>(<argument><expr><name>scanPercent</name></expr></argument>)</argument_list></call><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name> + <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>end</name></expr></argument>, <argument><expr><name>nextTokPtr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<return>return <expr>(<name>tok</name> == <name>XML_TOK_PERCENT</name>) ? <name>XML_TOK_INVALID</name> : <name>tok</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr>*<name>nextTokPtr</name> = <name>ptr</name></expr>;</expr_stmt>
<return>return <expr><name>XML_TOK_DATA_CHARS</name></expr>;</return>
</case><case>case <expr><name>BT_LF</name></expr>:
<if>if <condition>(<expr><name>ptr</name> == <name>start</name></expr>)</condition><then> <block>{
<expr_stmt><expr>*<name>nextTokPtr</name> = <name>ptr</name> + <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>XML_TOK_DATA_NEWLINE</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr>*<name>nextTokPtr</name> = <name>ptr</name></expr>;</expr_stmt>
<return>return <expr><name>XML_TOK_DATA_CHARS</name></expr>;</return>
</case><case>case <expr><name>BT_CR</name></expr>:
<if>if <condition>(<expr><name>ptr</name> == <name>start</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>ptr</name> += <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>ptr</name> == <name>end</name></expr>)</condition><then>
<return>return <expr><name>XML_TOK_TRAILING_CR</name></expr>;</return></then></if>
<if>if <condition>(<expr><call><name>BYTE_TYPE</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>)</argument_list></call> == <name>BT_LF</name></expr>)</condition><then>
<expr_stmt><expr><name>ptr</name> += <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<expr_stmt><expr>*<name>nextTokPtr</name> = <name>ptr</name></expr>;</expr_stmt>
<return>return <expr><name>XML_TOK_DATA_NEWLINE</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr>*<name>nextTokPtr</name> = <name>ptr</name></expr>;</expr_stmt>
<return>return <expr><name>XML_TOK_DATA_CHARS</name></expr>;</return>
</case><default>default:
<expr_stmt><expr><name>ptr</name> += <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</default>}</block></switch>
}</block></while>
<expr_stmt><expr>*<name>nextTokPtr</name> = <name>ptr</name></expr>;</expr_stmt>
<return>return <expr><name>XML_TOK_DATA_CHARS</name></expr>;</return>
}</block></function>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>XML_DTD</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function><type><specifier>static</specifier> <name>int</name> <name>PTRCALL</name>
<name>PREFIX</name></type>(<name>ignoreSectionTok</name>)<parameter_list>(<param><decl><type><specifier>const</specifier> <name>ENCODING</name> *</type><name>enc</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>ptr</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>end</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> **</type><name>nextTokPtr</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>level</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call> &gt; 1</expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>size_t</name></type> <name>n</name> <init>= <expr><name>end</name> - <name>ptr</name></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>n</name> &amp; (<call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call> - 1)</expr>)</condition><then> <block>{
<expr_stmt><expr><name>n</name> &amp;= ~(<call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call> - 1)</expr>;</expr_stmt>
<expr_stmt><expr><name>end</name> = <name>ptr</name> + <name>n</name></expr>;</expr_stmt>
}</block></then></if>
}</block></then></if>
<while>while <condition>(<expr><name>ptr</name> != <name>end</name></expr>)</condition> <block>{
<switch>switch <condition>(<expr><call><name>BYTE_TYPE</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{
<macro><name>INVALID_CASES</name><argument_list>(<argument>ptr</argument>, <argument>nextTokPtr</argument>)</argument_list></macro>
<case>case <expr><name>BT_LT</name></expr>:
<if>if <condition>(<expr>(<name>ptr</name> += <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call>) == <name>end</name></expr>)</condition><then>
<return>return <expr><name>XML_TOK_PARTIAL</name></expr>;</return></then></if>
<if>if <condition>(<expr><call><name>CHAR_MATCHES</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>ASCII_EXCL</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<if>if <condition>(<expr>(<name>ptr</name> += <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call>) == <name>end</name></expr>)</condition><then>
<return>return <expr><name>XML_TOK_PARTIAL</name></expr>;</return></then></if>
<if>if <condition>(<expr><call><name>CHAR_MATCHES</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>ASCII_LSQB</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr>++<name>level</name></expr>;</expr_stmt>
<expr_stmt><expr><name>ptr</name> += <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
}</block></then></if>
<break>break;</break>
</case><case>case <expr><name>BT_RSQB</name></expr>:
<if>if <condition>(<expr>(<name>ptr</name> += <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call>) == <name>end</name></expr>)</condition><then>
<return>return <expr><name>XML_TOK_PARTIAL</name></expr>;</return></then></if>
<if>if <condition>(<expr><call><name>CHAR_MATCHES</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>ASCII_RSQB</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<if>if <condition>(<expr>(<name>ptr</name> += <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call>) == <name>end</name></expr>)</condition><then>
<return>return <expr><name>XML_TOK_PARTIAL</name></expr>;</return></then></if>
<if>if <condition>(<expr><call><name>CHAR_MATCHES</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>ASCII_GT</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><name>ptr</name> += <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>level</name> == 0</expr>)</condition><then> <block>{
<expr_stmt><expr>*<name>nextTokPtr</name> = <name>ptr</name></expr>;</expr_stmt>
<return>return <expr><name>XML_TOK_IGNORE_SECT</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr>--<name>level</name></expr>;</expr_stmt>
}</block></then></if>
}</block></then></if>
<break>break;</break>
</case><default>default:
<expr_stmt><expr><name>ptr</name> += <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</default>}</block></switch>
}</block></while>
<return>return <expr><name>XML_TOK_PARTIAL</name></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<function><type><specifier>static</specifier> <name>int</name> <name>PTRCALL</name>
<name>PREFIX</name></type>(<name>isPublicId</name>)<parameter_list>(<param><decl><type><specifier>const</specifier> <name>ENCODING</name> *</type><name>enc</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>ptr</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>end</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> **</type><name>badPtr</name></decl></param>)</parameter_list> <block>{
<expr_stmt><expr><name>ptr</name> += <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>end</name> -= <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for (<init>;</init> <condition><expr><name>ptr</name> != <name>end</name></expr>;</condition> <incr><expr><name>ptr</name> += <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr></incr>) <block>{
<switch>switch <condition>(<expr><call><name>BYTE_TYPE</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{
<case>case <expr><name>BT_DIGIT</name></expr>:
</case><case>case <expr><name>BT_HEX</name></expr>:
</case><case>case <expr><name>BT_MINUS</name></expr>:
</case><case>case <expr><name>BT_APOS</name></expr>:
</case><case>case <expr><name>BT_LPAR</name></expr>:
</case><case>case <expr><name>BT_RPAR</name></expr>:
</case><case>case <expr><name>BT_PLUS</name></expr>:
</case><case>case <expr><name>BT_COMMA</name></expr>:
</case><case>case <expr><name>BT_SOL</name></expr>:
</case><case>case <expr><name>BT_EQUALS</name></expr>:
</case><case>case <expr><name>BT_QUEST</name></expr>:
</case><case>case <expr><name>BT_CR</name></expr>:
</case><case>case <expr><name>BT_LF</name></expr>:
</case><case>case <expr><name>BT_SEMI</name></expr>:
</case><case>case <expr><name>BT_EXCL</name></expr>:
</case><case>case <expr><name>BT_AST</name></expr>:
</case><case>case <expr><name>BT_PERCNT</name></expr>:
</case><case>case <expr><name>BT_NUM</name></expr>:
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>XML_NS</name></expr></argument>)</argument_list></call></expr></cpp:if>
</case><case>case <expr><name>BT_COLON</name></expr>:
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<break>break;</break>
</case><case>case <expr><name>BT_S</name></expr>:
<if>if <condition>(<expr><call><name>CHAR_MATCHES</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>ASCII_TAB</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr>*<name>badPtr</name> = <name>ptr</name></expr>;</expr_stmt>
<return>return <expr>0</expr>;</return>
}</block></then></if>
<break>break;</break>
</case><case>case <expr><name>BT_NAME</name></expr>:
</case><case>case <expr><name>BT_NMSTRT</name></expr>:
<if>if <condition>(<expr>!(<call><name>BYTE_TO_ASCII</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>)</argument_list></call> &amp; ~0x7f)</expr>)</condition><then>
<break>break;</break></then></if>
</case><default>default:
<switch>switch <condition>(<expr><call><name>BYTE_TO_ASCII</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{
<case>case <expr>0x24</expr>:
</case><case>case <expr>0x40</expr>:
<break>break;</break>
</case><default>default:
<expr_stmt><expr>*<name>badPtr</name> = <name>ptr</name></expr>;</expr_stmt>
<return>return <expr>0</expr>;</return>
</default>}</block></switch>
<break>break;</break>
</default>}</block></switch>
}</block></for>
<return>return <expr>1</expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name> <name>PTRCALL</name>
<name>PREFIX</name></type>(<name>getAtts</name>)<parameter_list>(<param><decl><type><specifier>const</specifier> <name>ENCODING</name> *</type><name>enc</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>ptr</name></decl></param>,
<param><decl><type><name>int</name></type> <name>attsMax</name></decl></param>, <param><decl><type><name>ATTRIBUTE</name> *</type><name>atts</name></decl></param>)</parameter_list> <block>{
<enum>enum <block>{ <decl><name>other</name></decl>, <decl><name>inName</name></decl>, <decl><name>inValue</name></decl> }</block> <decl><name>state</name> <init>= <expr><name>inName</name></expr></init></decl>;</enum>
<decl_stmt><decl><type><name>int</name></type> <name>nAtts</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>open</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<for>for (<init><expr><name>ptr</name> += <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</init><condition>;</condition> <incr><expr><name>ptr</name> += <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr></incr>) <block>{
<switch>switch <condition>(<expr><call><name>BYTE_TYPE</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>START_NAME</name></cpp:macro> <cpp:value>if (state == other) { if (nAtts &lt; attsMax) { atts[nAtts].name = ptr; atts[nAtts].normalized = 1; } state = inName; }</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LEAD_CASE</name><parameter_list>(<param><type><name>n</name></type></param>)</parameter_list></cpp:macro> <cpp:value>case BT_LEAD ##n: START_NAME ptr += (n - MINBPC(enc)); break;</cpp:value></cpp:define>
<macro><name>LEAD_CASE</name><argument_list>(<argument>2</argument>)</argument_list></macro> <macro><name>LEAD_CASE</name><argument_list>(<argument>3</argument>)</argument_list></macro> <macro><name>LEAD_CASE</name><argument_list>(<argument>4</argument>)</argument_list></macro>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>LEAD_CASE</name></cpp:undef>
<case>case <expr><name>BT_NONASCII</name></expr>:
</case><case>case <expr><name>BT_NMSTRT</name></expr>:
</case><case>case <expr><name>BT_HEX</name></expr>:
<macro><name>START_NAME</name></macro>
<break>break;</break>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>START_NAME</name></cpp:undef>
</case><case>case <expr><name>BT_QUOT</name></expr>:
<if>if <condition>(<expr><name>state</name> != <name>inValue</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr><name>nAtts</name> &lt; <name>attsMax</name></expr>)</condition><then>
<expr_stmt><expr><name><name>atts</name><index>[<expr><name>nAtts</name></expr>]</index></name>.<name>valuePtr</name> = <name>ptr</name> + <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<expr_stmt><expr><name>state</name> = <name>inValue</name></expr>;</expr_stmt>
<expr_stmt><expr><name>open</name> = <name>BT_QUOT</name></expr>;</expr_stmt>
}</block></then> <else>else <if>if <condition>(<expr><name>open</name> == <name>BT_QUOT</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>state</name> = <name>other</name></expr>;</expr_stmt>
<if>if <condition>(<expr><name>nAtts</name> &lt; <name>attsMax</name></expr>)</condition><then>
<expr_stmt><expr><name><name>atts</name><index>[<expr><name>nAtts</name></expr>]</index></name>.<name>valueEnd</name> = <name>ptr</name></expr>;</expr_stmt></then></if>
<expr_stmt><expr><name>nAtts</name>++</expr>;</expr_stmt>
}</block></then></if></else></if>
<break>break;</break>
</case><case>case <expr><name>BT_APOS</name></expr>:
<if>if <condition>(<expr><name>state</name> != <name>inValue</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr><name>nAtts</name> &lt; <name>attsMax</name></expr>)</condition><then>
<expr_stmt><expr><name><name>atts</name><index>[<expr><name>nAtts</name></expr>]</index></name>.<name>valuePtr</name> = <name>ptr</name> + <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<expr_stmt><expr><name>state</name> = <name>inValue</name></expr>;</expr_stmt>
<expr_stmt><expr><name>open</name> = <name>BT_APOS</name></expr>;</expr_stmt>
}</block></then> <else>else <if>if <condition>(<expr><name>open</name> == <name>BT_APOS</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>state</name> = <name>other</name></expr>;</expr_stmt>
<if>if <condition>(<expr><name>nAtts</name> &lt; <name>attsMax</name></expr>)</condition><then>
<expr_stmt><expr><name><name>atts</name><index>[<expr><name>nAtts</name></expr>]</index></name>.<name>valueEnd</name> = <name>ptr</name></expr>;</expr_stmt></then></if>
<expr_stmt><expr><name>nAtts</name>++</expr>;</expr_stmt>
}</block></then></if></else></if>
<break>break;</break>
</case><case>case <expr><name>BT_AMP</name></expr>:
<if>if <condition>(<expr><name>nAtts</name> &lt; <name>attsMax</name></expr>)</condition><then>
<expr_stmt><expr><name><name>atts</name><index>[<expr><name>nAtts</name></expr>]</index></name>.<name>normalized</name> = 0</expr>;</expr_stmt></then></if>
<break>break;</break>
</case><case>case <expr><name>BT_S</name></expr>:
<if>if <condition>(<expr><name>state</name> == <name>inName</name></expr>)</condition><then>
<expr_stmt><expr><name>state</name> = <name>other</name></expr>;</expr_stmt></then>
<else>else <if>if <condition>(<expr><name>state</name> == <name>inValue</name>
&amp;&amp; <name>nAtts</name> &lt; <name>attsMax</name>
&amp;&amp; <name><name>atts</name><index>[<expr><name>nAtts</name></expr>]</index></name>.<name>normalized</name>
&amp;&amp; (<name>ptr</name> == <name><name>atts</name><index>[<expr><name>nAtts</name></expr>]</index></name>.<name>valuePtr</name>
|| <call><name>BYTE_TO_ASCII</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>)</argument_list></call> != <name>ASCII_SPACE</name>
|| <call><name>BYTE_TO_ASCII</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name> + <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> == <name>ASCII_SPACE</name>
|| <call><name>BYTE_TYPE</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name> + <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> == <name>open</name>)</expr>)</condition><then>
<expr_stmt><expr><name><name>atts</name><index>[<expr><name>nAtts</name></expr>]</index></name>.<name>normalized</name> = 0</expr>;</expr_stmt></then></if></else></if>
<break>break;</break>
</case><case>case <expr><name>BT_CR</name></expr>:
</case><case>case <expr><name>BT_LF</name></expr>:
<if>if <condition>(<expr><name>state</name> == <name>inName</name></expr>)</condition><then>
<expr_stmt><expr><name>state</name> = <name>other</name></expr>;</expr_stmt></then>
<else>else <if>if <condition>(<expr><name>state</name> == <name>inValue</name> &amp;&amp; <name>nAtts</name> &lt; <name>attsMax</name></expr>)</condition><then>
<expr_stmt><expr><name><name>atts</name><index>[<expr><name>nAtts</name></expr>]</index></name>.<name>normalized</name> = 0</expr>;</expr_stmt></then></if></else></if>
<break>break;</break>
</case><case>case <expr><name>BT_GT</name></expr>:
</case><case>case <expr><name>BT_SOL</name></expr>:
<if>if <condition>(<expr><name>state</name> != <name>inValue</name></expr>)</condition><then>
<return>return <expr><name>nAtts</name></expr>;</return></then></if>
<break>break;</break>
</case><default>default:
<break>break;</break>
</default>}</block></switch>
}</block></for>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name> <name>PTRFASTCALL</name>
<name>PREFIX</name></type>(<name>charRefNumber</name>)<parameter_list>(<param><decl><type><specifier>const</specifier> <name>ENCODING</name> *</type><name>enc</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>ptr</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>result</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>ptr</name> += 2*<call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>CHAR_MATCHES</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>ASCII_x</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<for>for (<init><expr><name>ptr</name> += <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</init>
<condition><expr>!<call><name>CHAR_MATCHES</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>ASCII_SEMI</name></expr></argument>)</argument_list></call></expr>;</condition>
<incr><expr><name>ptr</name> += <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr></incr>) <block>{
<decl_stmt><decl><type><name>int</name></type> <name>c</name> <init>= <expr><call><name>BYTE_TO_ASCII</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<switch>switch <condition>(<expr><name>c</name></expr>)</condition> <block>{
<case>case <expr><name>ASCII_0</name></expr>:
</case><case>case <expr><name>ASCII_1</name></expr>:
</case><case>case <expr><name>ASCII_2</name></expr>:
</case><case>case <expr><name>ASCII_3</name></expr>:
</case><case>case <expr><name>ASCII_4</name></expr>:
</case><case>case <expr><name>ASCII_5</name></expr>:
</case><case>case <expr><name>ASCII_6</name></expr>:
</case><case>case <expr><name>ASCII_7</name></expr>:
</case><case>case <expr><name>ASCII_8</name></expr>:
</case><case>case <expr><name>ASCII_9</name></expr>:
<expr_stmt><expr><name>result</name> &lt;&lt;= 4</expr>;</expr_stmt>
<expr_stmt><expr><name>result</name> |= (<name>c</name> - <name>ASCII_0</name>)</expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr><name>ASCII_A</name></expr>:
</case><case>case <expr><name>ASCII_B</name></expr>:
</case><case>case <expr><name>ASCII_C</name></expr>:
</case><case>case <expr><name>ASCII_D</name></expr>:
</case><case>case <expr><name>ASCII_E</name></expr>:
</case><case>case <expr><name>ASCII_F</name></expr>:
<expr_stmt><expr><name>result</name> &lt;&lt;= 4</expr>;</expr_stmt>
<expr_stmt><expr><name>result</name> += 10 + (<name>c</name> - <name>ASCII_A</name>)</expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr><name>ASCII_a</name></expr>:
</case><case>case <expr><name>ASCII_b</name></expr>:
</case><case>case <expr><name>ASCII_c</name></expr>:
</case><case>case <expr><name>ASCII_d</name></expr>:
</case><case>case <expr><name>ASCII_e</name></expr>:
</case><case>case <expr><name>ASCII_f</name></expr>:
<expr_stmt><expr><name>result</name> &lt;&lt;= 4</expr>;</expr_stmt>
<expr_stmt><expr><name>result</name> += 10 + (<name>c</name> - <name>ASCII_a</name>)</expr>;</expr_stmt>
<break>break;</break>
</case>}</block></switch>
<if>if <condition>(<expr><name>result</name> &gt;= 0x110000</expr>)</condition><then>
<return>return <expr>-1</expr>;</return></then></if>
}</block></for>
}</block></then> <else>else <block>{
<for>for (<init>;</init> <condition><expr>!<call><name>CHAR_MATCHES</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>ASCII_SEMI</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>ptr</name> += <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr></incr>) <block>{
<decl_stmt><decl><type><name>int</name></type> <name>c</name> <init>= <expr><call><name>BYTE_TO_ASCII</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>result</name> *= 10</expr>;</expr_stmt>
<expr_stmt><expr><name>result</name> += (<name>c</name> - <name>ASCII_0</name>)</expr>;</expr_stmt>
<if>if <condition>(<expr><name>result</name> &gt;= 0x110000</expr>)</condition><then>
<return>return <expr>-1</expr>;</return></then></if>
}</block></for>
}</block></else></if>
<return>return <expr><call><name>checkCharRefNumber</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name> <name>PTRCALL</name>
<name>PREFIX</name></type>(<name>predefinedEntityName</name>)<parameter_list>(<param><decl><type><specifier>const</specifier> <name>ENCODING</name> *</type><name>enc</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>ptr</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>end</name></decl></param>)</parameter_list> <block>{
<switch>switch <condition>(<expr>(<name>end</name> - <name>ptr</name>)/<call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{
<case>case <expr>2</expr>:
<if>if <condition>(<expr><call><name>CHAR_MATCHES</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name> + <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>ASCII_t</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<switch>switch <condition>(<expr><call><name>BYTE_TO_ASCII</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{
<case>case <expr><name>ASCII_l</name></expr>:
<return>return <expr><name>ASCII_LT</name></expr>;</return>
</case><case>case <expr><name>ASCII_g</name></expr>:
<return>return <expr><name>ASCII_GT</name></expr>;</return>
</case>}</block></switch>
}</block></then></if>
<break>break;</break>
</case><case>case <expr>3</expr>:
<if>if <condition>(<expr><call><name>CHAR_MATCHES</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>ASCII_a</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><name>ptr</name> += <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>CHAR_MATCHES</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>ASCII_m</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><name>ptr</name> += <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>CHAR_MATCHES</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>ASCII_p</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>ASCII_AMP</name></expr>;</return></then></if>
}</block></then></if>
}</block></then></if>
<break>break;</break>
</case><case>case <expr>4</expr>:
<switch>switch <condition>(<expr><call><name>BYTE_TO_ASCII</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{
<case>case <expr><name>ASCII_q</name></expr>:
<expr_stmt><expr><name>ptr</name> += <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>CHAR_MATCHES</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>ASCII_u</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><name>ptr</name> += <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>CHAR_MATCHES</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>ASCII_o</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><name>ptr</name> += <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>CHAR_MATCHES</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>ASCII_t</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>ASCII_QUOT</name></expr>;</return></then></if>
}</block></then></if>
}</block></then></if>
<break>break;</break>
</case><case>case <expr><name>ASCII_a</name></expr>:
<expr_stmt><expr><name>ptr</name> += <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>CHAR_MATCHES</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>ASCII_p</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><name>ptr</name> += <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>CHAR_MATCHES</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>ASCII_o</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><name>ptr</name> += <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>CHAR_MATCHES</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>ASCII_s</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>ASCII_APOS</name></expr>;</return></then></if>
}</block></then></if>
}</block></then></if>
<break>break;</break>
</case>}</block></switch>
</case>}</block></switch>
<return>return <expr>0</expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name> <name>PTRCALL</name>
<name>PREFIX</name></type>(<name>sameName</name>)<parameter_list>(<param><decl><type><specifier>const</specifier> <name>ENCODING</name> *</type><name>enc</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>ptr1</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>ptr2</name></decl></param>)</parameter_list> <block>{
<for>for (<init>;</init><condition>;</condition><incr/>) <block>{
<switch>switch <condition>(<expr><call><name>BYTE_TYPE</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr1</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LEAD_CASE</name><parameter_list>(<param><type><name>n</name></type></param>)</parameter_list></cpp:macro> <cpp:value>case BT_LEAD ##n: if (*ptr1++ != *ptr2++) return 0;</cpp:value></cpp:define>
<macro><name>LEAD_CASE</name><argument_list>(<argument>4</argument>)</argument_list></macro> <macro><name>LEAD_CASE</name><argument_list>(<argument>3</argument>)</argument_list></macro> <macro><name>LEAD_CASE</name><argument_list>(<argument>2</argument>)</argument_list></macro>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>LEAD_CASE</name></cpp:undef>
<if>if <condition>(<expr>*<name>ptr1</name>++ != *<name>ptr2</name>++</expr>)</condition><then>
<return>return <expr>0</expr>;</return></then></if>
<break>break;</break>
<case>case <expr><name>BT_NONASCII</name></expr>:
</case><case>case <expr><name>BT_NMSTRT</name></expr>:
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>XML_NS</name></expr></argument>)</argument_list></call></expr></cpp:if>
</case><case>case <expr><name>BT_COLON</name></expr>:
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</case><case>case <expr><name>BT_HEX</name></expr>:
</case><case>case <expr><name>BT_DIGIT</name></expr>:
</case><case>case <expr><name>BT_NAME</name></expr>:
</case><case>case <expr><name>BT_MINUS</name></expr>:
<if>if <condition>(<expr>*<name>ptr2</name>++ != *<name>ptr1</name>++</expr>)</condition><then>
<return>return <expr>0</expr>;</return></then></if>
<if>if <condition>(<expr><call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call> &gt; 1</expr>)</condition><then> <block>{
<if>if <condition>(<expr>*<name>ptr2</name>++ != *<name>ptr1</name>++</expr>)</condition><then>
<return>return <expr>0</expr>;</return></then></if>
<if>if <condition>(<expr><call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call> &gt; 2</expr>)</condition><then> <block>{
<if>if <condition>(<expr>*<name>ptr2</name>++ != *<name>ptr1</name>++</expr>)</condition><then>
<return>return <expr>0</expr>;</return></then></if>
<if>if <condition>(<expr><call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call> &gt; 3</expr>)</condition><then> <block>{
<if>if <condition>(<expr>*<name>ptr2</name>++ != *<name>ptr1</name>++</expr>)</condition><then>
<return>return <expr>0</expr>;</return></then></if>
}</block></then></if>
}</block></then></if>
}</block></then></if>
<break>break;</break>
</case><default>default:
<if>if <condition>(<expr><call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call> == 1 &amp;&amp; *<name>ptr1</name> == *<name>ptr2</name></expr>)</condition><then>
<return>return <expr>1</expr>;</return></then></if>
<switch>switch <condition>(<expr><call><name>BYTE_TYPE</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr2</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{
<case>case <expr><name>BT_LEAD2</name></expr>:
</case><case>case <expr><name>BT_LEAD3</name></expr>:
</case><case>case <expr><name>BT_LEAD4</name></expr>:
</case><case>case <expr><name>BT_NONASCII</name></expr>:
</case><case>case <expr><name>BT_NMSTRT</name></expr>:
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>XML_NS</name></expr></argument>)</argument_list></call></expr></cpp:if>
</case><case>case <expr><name>BT_COLON</name></expr>:
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</case><case>case <expr><name>BT_HEX</name></expr>:
</case><case>case <expr><name>BT_DIGIT</name></expr>:
</case><case>case <expr><name>BT_NAME</name></expr>:
</case><case>case <expr><name>BT_MINUS</name></expr>:
<return>return <expr>0</expr>;</return>
</case><default>default:
<return>return <expr>1</expr>;</return>
</default>}</block></switch>
</default>}</block></switch>
}</block></for>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name> <name>PTRCALL</name>
<name>PREFIX</name></type>(<name>nameMatchesAscii</name>)<parameter_list>(<param><decl><type><specifier>const</specifier> <name>ENCODING</name> *</type><name>enc</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>ptr1</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>end1</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>ptr2</name></decl></param>)</parameter_list> <block>{
<for>for (<init>;</init> <condition><expr>*<name>ptr2</name></expr>;</condition> <incr><expr><name>ptr1</name> += <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>, <expr><name>ptr2</name>++</expr></incr>) <block>{
<if>if <condition>(<expr><name>ptr1</name> == <name>end1</name></expr>)</condition><then>
<return>return <expr>0</expr>;</return></then></if>
<if>if <condition>(<expr>!<call><name>CHAR_MATCHES</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr1</name></expr></argument>, <argument><expr>*<name>ptr2</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr>0</expr>;</return></then></if>
}</block></for>
<return>return <expr><name>ptr1</name> == <name>end1</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name> <name>PTRFASTCALL</name>
<name>PREFIX</name></type>(<name>nameLength</name>)<parameter_list>(<param><decl><type><specifier>const</specifier> <name>ENCODING</name> *</type><name>enc</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>ptr</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>start</name> <init>= <expr><name>ptr</name></expr></init></decl>;</decl_stmt>
<for>for (<init>;</init><condition>;</condition><incr/>) <block>{
<switch>switch <condition>(<expr><call><name>BYTE_TYPE</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LEAD_CASE</name><parameter_list>(<param><type><name>n</name></type></param>)</parameter_list></cpp:macro> <cpp:value>case BT_LEAD ##n: ptr += n; break;</cpp:value></cpp:define>
<macro><name>LEAD_CASE</name><argument_list>(<argument>2</argument>)</argument_list></macro> <macro><name>LEAD_CASE</name><argument_list>(<argument>3</argument>)</argument_list></macro> <macro><name>LEAD_CASE</name><argument_list>(<argument>4</argument>)</argument_list></macro>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>LEAD_CASE</name></cpp:undef>
<case>case <expr><name>BT_NONASCII</name></expr>:
</case><case>case <expr><name>BT_NMSTRT</name></expr>:
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>XML_NS</name></expr></argument>)</argument_list></call></expr></cpp:if>
</case><case>case <expr><name>BT_COLON</name></expr>:
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</case><case>case <expr><name>BT_HEX</name></expr>:
</case><case>case <expr><name>BT_DIGIT</name></expr>:
</case><case>case <expr><name>BT_NAME</name></expr>:
</case><case>case <expr><name>BT_MINUS</name></expr>:
<expr_stmt><expr><name>ptr</name> += <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</case><default>default:
<return>return <expr><call>(<name>int</name>)<argument_list>(<argument><expr><name>ptr</name> - <name>start</name></expr></argument>)</argument_list></call></expr>;</return>
</default>}</block></switch>
}</block></for>
}</block></function>
<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> * <name>PTRFASTCALL</name>
<name>PREFIX</name></type>(<name>skipS</name>)<parameter_list>(<param><decl><type><specifier>const</specifier> <name>ENCODING</name> *</type><name>enc</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>ptr</name></decl></param>)</parameter_list> <block>{
<for>for (<init>;</init><condition>;</condition><incr/>) <block>{
<switch>switch <condition>(<expr><call><name>BYTE_TYPE</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{
<case>case <expr><name>BT_LF</name></expr>:
</case><case>case <expr><name>BT_CR</name></expr>:
</case><case>case <expr><name>BT_S</name></expr>:
<expr_stmt><expr><name>ptr</name> += <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</case><default>default:
<return>return <expr><name>ptr</name></expr>;</return>
</default>}</block></switch>
}</block></for>
}</block></function>
<function><type><specifier>static</specifier> <name>void</name> <name>PTRCALL</name>
<name>PREFIX</name></type>(<name>updatePosition</name>)<parameter_list>(<param><decl><type><specifier>const</specifier> <name>ENCODING</name> *</type><name>enc</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>ptr</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>end</name></decl></param>,
<param><decl><type><name>POSITION</name> *</type><name>pos</name></decl></param>)</parameter_list> <block>{
<while>while <condition>(<expr><name>ptr</name> != <name>end</name></expr>)</condition> <block>{
<switch>switch <condition>(<expr><call><name>BYTE_TYPE</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LEAD_CASE</name><parameter_list>(<param><type><name>n</name></type></param>)</parameter_list></cpp:macro> <cpp:value>case BT_LEAD ##n: ptr += n; break;</cpp:value></cpp:define>
<macro><name>LEAD_CASE</name><argument_list>(<argument>2</argument>)</argument_list></macro> <macro><name>LEAD_CASE</name><argument_list>(<argument>3</argument>)</argument_list></macro> <macro><name>LEAD_CASE</name><argument_list>(<argument>4</argument>)</argument_list></macro>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>LEAD_CASE</name></cpp:undef>
<case>case <expr><name>BT_LF</name></expr>:
<expr_stmt><expr><name><name>pos</name>-&gt;<name>columnNumber</name></name> = (<name>XML_Size</name>)-1</expr>;</expr_stmt>
<expr_stmt><expr><name><name>pos</name>-&gt;<name>lineNumber</name></name>++</expr>;</expr_stmt>
<expr_stmt><expr><name>ptr</name> += <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr><name>BT_CR</name></expr>:
<expr_stmt><expr><name><name>pos</name>-&gt;<name>lineNumber</name></name>++</expr>;</expr_stmt>
<expr_stmt><expr><name>ptr</name> += <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>ptr</name> != <name>end</name> &amp;&amp; <call><name>BYTE_TYPE</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>)</argument_list></call> == <name>BT_LF</name></expr>)</condition><then>
<expr_stmt><expr><name>ptr</name> += <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<expr_stmt><expr><name><name>pos</name>-&gt;<name>columnNumber</name></name> = (<name>XML_Size</name>)-1</expr>;</expr_stmt>
<break>break;</break>
</case><default>default:
<expr_stmt><expr><name>ptr</name> += <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</default>}</block></switch>
<expr_stmt><expr><name><name>pos</name>-&gt;<name>columnNumber</name></name>++</expr>;</expr_stmt>
}</block></while>
}</block></function>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>DO_LEAD_CASE</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>MULTIBYTE_CASES</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>INVALID_CASES</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>CHECK_NAME_CASE</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>CHECK_NAME_CASES</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>CHECK_NMSTRT_CASE</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>CHECK_NMSTRT_CASES</name></cpp:undef>
</unit>
