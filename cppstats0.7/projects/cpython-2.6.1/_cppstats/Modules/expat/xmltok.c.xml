<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C" filename="Modules/expat/xmltok.c"><cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>COMPILED_FROM_DSP</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"winconfig.h"</cpp:file></cpp:include>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MACOS_CLASSIC</name></expr></argument>)</argument_list></call></expr></cpp:elif>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"macconfig.h"</cpp:file></cpp:include>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__amigaos4__</name></expr></argument>)</argument_list></call></expr></cpp:elif>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"amigaconfig.h"</cpp:file></cpp:include>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_EXPAT_CONFIG_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;expat_config.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stddef.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"expat_external.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"internal.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"xmltok.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nametab.h"</cpp:file></cpp:include>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>XML_DTD</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IGNORE_SECTION_TOK_VTABLE</name></cpp:macro> <cpp:value>, PREFIX(ignoreSectionTok)</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IGNORE_SECTION_TOK_VTABLE</name></cpp:macro></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>VTABLE1</name></cpp:macro> <cpp:value>{ PREFIX(prologTok), PREFIX(contentTok), PREFIX(cdataSectionTok) IGNORE_SECTION_TOK_VTABLE }, { PREFIX(attributeValueTok), PREFIX(entityValueTok) }, PREFIX(sameName), PREFIX(nameMatchesAscii), PREFIX(nameLength), PREFIX(skipS), PREFIX(getAtts), PREFIX(charRefNumber), PREFIX(predefinedEntityName), PREFIX(updatePosition), PREFIX(isPublicId)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>VTABLE</name></cpp:macro> <cpp:value>VTABLE1, PREFIX(toUtf8), PREFIX(toUtf16)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>UCS2_GET_NAMING</name><parameter_list>(<param><type><name>pages</name></type></param>, <param><type><name>hi</name></type></param>, <param><type><name>lo</name></type></param>)</parameter_list></cpp:macro> <cpp:value>(namingBitmap[(pages[hi] &lt;&lt; 3) + ((lo) &gt;&gt; 5)] &amp; (1 &lt;&lt; ((lo) &amp; 0x1F)))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>UTF8_GET_NAMING2</name><parameter_list>(<param><type><name>pages</name></type></param>, <param><type><name>byte</name></type></param>)</parameter_list></cpp:macro> <cpp:value>(namingBitmap[((pages)[(((byte)[0]) &gt;&gt; 2) &amp; 7] &lt;&lt; 3) + ((((byte)[0]) &amp; 3) &lt;&lt; 1) + ((((byte)[1]) &gt;&gt; 5) &amp; 1)] &amp; (1 &lt;&lt; (((byte)[1]) &amp; 0x1F)))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>UTF8_GET_NAMING3</name><parameter_list>(<param><type><name>pages</name></type></param>, <param><type><name>byte</name></type></param>)</parameter_list></cpp:macro> <cpp:value>(namingBitmap[((pages)[((((byte)[0]) &amp; 0xF) &lt;&lt; 4) + ((((byte)[1]) &gt;&gt; 2) &amp; 0xF)] &lt;&lt; 3) + ((((byte)[1]) &amp; 3) &lt;&lt; 1) + ((((byte)[2]) &gt;&gt; 5) &amp; 1)] &amp; (1 &lt;&lt; (((byte)[2]) &amp; 0x1F)))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>UTF8_GET_NAMING</name><parameter_list>(<param><type><name>pages</name></type></param>, <param><type><name>p</name></type></param>, <param><type><name>n</name></type></param>)</parameter_list></cpp:macro> <cpp:value>((n) == 2 ? UTF8_GET_NAMING2(pages, (const unsigned char *)(p)) : ((n) == 3 ? UTF8_GET_NAMING3(pages, (const unsigned char *)(p)) : 0))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>UTF8_INVALID2</name><parameter_list>(<param><type><name>p</name></type></param>)</parameter_list></cpp:macro> <cpp:value>((*p) &lt; 0xC2 || ((p)[1] &amp; 0x80) == 0 || ((p)[1] &amp; 0xC0) == 0xC0)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>UTF8_INVALID3</name><parameter_list>(<param><type><name>p</name></type></param>)</parameter_list></cpp:macro> <cpp:value>(((p)[2] &amp; 0x80) == 0 || ((*p) == 0xEF &amp;&amp; (p)[1] == 0xBF ? (p)[2] &gt; 0xBD : ((p)[2] &amp; 0xC0) == 0xC0) || ((*p) == 0xE0 ? (p)[1] &lt; 0xA0 || ((p)[1] &amp; 0xC0) == 0xC0 : ((p)[1] &amp; 0x80) == 0 || ((*p) == 0xED ? (p)[1] &gt; 0x9F : ((p)[1] &amp; 0xC0) == 0xC0)))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>UTF8_INVALID4</name><parameter_list>(<param><type><name>p</name></type></param>)</parameter_list></cpp:macro> <cpp:value>(((p)[3] &amp; 0x80) == 0 || ((p)[3] &amp; 0xC0) == 0xC0 || ((p)[2] &amp; 0x80) == 0 || ((p)[2] &amp; 0xC0) == 0xC0 || ((*p) == 0xF0 ? (p)[1] &lt; 0x90 || ((p)[1] &amp; 0xC0) == 0xC0 : ((p)[1] &amp; 0x80) == 0 || ((*p) == 0xF4 ? (p)[1] &gt; 0x8F : ((p)[1] &amp; 0xC0) == 0xC0)))</cpp:value></cpp:define>
<function><type><specifier>static</specifier> <name>int</name> <name>PTRFASTCALL</name></type>
<name>isNever</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>ENCODING</name> *</type><name>enc</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>p</name></decl></param>)</parameter_list> <block>{
<return>return <expr>0</expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name> <name>PTRFASTCALL</name></type>
<name>utf8_isName2</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>ENCODING</name> *</type><name>enc</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>p</name></decl></param>)</parameter_list> <block>{
<return>return <expr><call><name>UTF8_GET_NAMING2</name><argument_list>(<argument><expr><name>namePages</name></expr></argument>, <argument><expr>(const <name>unsigned</name> <name>char</name> *)<name>p</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name> <name>PTRFASTCALL</name></type>
<name>utf8_isName3</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>ENCODING</name> *</type><name>enc</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>p</name></decl></param>)</parameter_list> <block>{
<return>return <expr><call><name>UTF8_GET_NAMING3</name><argument_list>(<argument><expr><name>namePages</name></expr></argument>, <argument><expr>(const <name>unsigned</name> <name>char</name> *)<name>p</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>utf8_isName4</name></cpp:macro> <cpp:value>isNever</cpp:value></cpp:define>
<function><type><specifier>static</specifier> <name>int</name> <name>PTRFASTCALL</name></type>
<name>utf8_isNmstrt2</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>ENCODING</name> *</type><name>enc</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>p</name></decl></param>)</parameter_list> <block>{
<return>return <expr><call><name>UTF8_GET_NAMING2</name><argument_list>(<argument><expr><name>nmstrtPages</name></expr></argument>, <argument><expr>(const <name>unsigned</name> <name>char</name> *)<name>p</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name> <name>PTRFASTCALL</name></type>
<name>utf8_isNmstrt3</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>ENCODING</name> *</type><name>enc</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>p</name></decl></param>)</parameter_list> <block>{
<return>return <expr><call><name>UTF8_GET_NAMING3</name><argument_list>(<argument><expr><name>nmstrtPages</name></expr></argument>, <argument><expr>(const <name>unsigned</name> <name>char</name> *)<name>p</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>utf8_isNmstrt4</name></cpp:macro> <cpp:value>isNever</cpp:value></cpp:define>
<function><type><specifier>static</specifier> <name>int</name> <name>PTRFASTCALL</name></type>
<name>utf8_isInvalid2</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>ENCODING</name> *</type><name>enc</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>p</name></decl></param>)</parameter_list> <block>{
<return>return <expr><call><name>UTF8_INVALID2</name><argument_list>(<argument><expr>(const <name>unsigned</name> <name>char</name> *)<name>p</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name> <name>PTRFASTCALL</name></type>
<name>utf8_isInvalid3</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>ENCODING</name> *</type><name>enc</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>p</name></decl></param>)</parameter_list> <block>{
<return>return <expr><call><name>UTF8_INVALID3</name><argument_list>(<argument><expr>(const <name>unsigned</name> <name>char</name> *)<name>p</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name> <name>PTRFASTCALL</name></type>
<name>utf8_isInvalid4</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>ENCODING</name> *</type><name>enc</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>p</name></decl></param>)</parameter_list> <block>{
<return>return <expr><call><name>UTF8_INVALID4</name><argument_list>(<argument><expr>(const <name>unsigned</name> <name>char</name> *)<name>p</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<struct>struct <name>normal_encoding</name> <block>{
<decl_stmt><decl><type><name>ENCODING</name></type> <name>enc</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name><name>type</name><index>[<expr>256</expr>]</index></name></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>XML_MIN_SIZE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function_decl><type><name>int</name></type> (<name>PTRFASTCALL</name> *<name>byteType</name>)<parameter_list>(<param><decl><type><specifier>const</specifier></type> <name>ENCODING</name> *</decl></param>, <param><decl><type><specifier>const</specifier></type> <name>char</name> *</decl></param>)</parameter_list>;</function_decl>
<function_decl><type><name>int</name></type> (<name>PTRFASTCALL</name> *<name>isNameMin</name>)<parameter_list>(<param><decl><type><specifier>const</specifier></type> <name>ENCODING</name> *</decl></param>, <param><decl><type><specifier>const</specifier></type> <name>char</name> *</decl></param>)</parameter_list>;</function_decl>
<function_decl><type><name>int</name></type> (<name>PTRFASTCALL</name> *<name>isNmstrtMin</name>)<parameter_list>(<param><decl><type><specifier>const</specifier></type> <name>ENCODING</name> *</decl></param>, <param><decl><type><specifier>const</specifier></type> <name>char</name> *</decl></param>)</parameter_list>;</function_decl>
<function_decl><type><name>int</name></type> (<name>PTRFASTCALL</name> *<name>byteToAscii</name>)<parameter_list>(<param><decl><type><specifier>const</specifier></type> <name>ENCODING</name> *</decl></param>, <param><decl><type><specifier>const</specifier></type> <name>char</name> *</decl></param>)</parameter_list>;</function_decl>
<function_decl><type><name>int</name></type> (<name>PTRCALL</name> *<name>charMatches</name>)<parameter_list>(<param><decl><type><specifier>const</specifier></type> <name>ENCODING</name> *</decl></param>, <param><decl><type><specifier>const</specifier></type> <name>char</name> *</decl></param>, <param><decl><type><name>int</name></type></decl></param>)</parameter_list>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<function_decl><type><name>int</name></type> (<name>PTRFASTCALL</name> *<name>isName2</name>)<parameter_list>(<param><decl><type><specifier>const</specifier></type> <name>ENCODING</name> *</decl></param>, <param><decl><type><specifier>const</specifier></type> <name>char</name> *</decl></param>)</parameter_list>;</function_decl>
<function_decl><type><name>int</name></type> (<name>PTRFASTCALL</name> *<name>isName3</name>)<parameter_list>(<param><decl><type><specifier>const</specifier></type> <name>ENCODING</name> *</decl></param>, <param><decl><type><specifier>const</specifier></type> <name>char</name> *</decl></param>)</parameter_list>;</function_decl>
<function_decl><type><name>int</name></type> (<name>PTRFASTCALL</name> *<name>isName4</name>)<parameter_list>(<param><decl><type><specifier>const</specifier></type> <name>ENCODING</name> *</decl></param>, <param><decl><type><specifier>const</specifier></type> <name>char</name> *</decl></param>)</parameter_list>;</function_decl>
<function_decl><type><name>int</name></type> (<name>PTRFASTCALL</name> *<name>isNmstrt2</name>)<parameter_list>(<param><decl><type><specifier>const</specifier></type> <name>ENCODING</name> *</decl></param>, <param><decl><type><specifier>const</specifier></type> <name>char</name> *</decl></param>)</parameter_list>;</function_decl>
<function_decl><type><name>int</name></type> (<name>PTRFASTCALL</name> *<name>isNmstrt3</name>)<parameter_list>(<param><decl><type><specifier>const</specifier></type> <name>ENCODING</name> *</decl></param>, <param><decl><type><specifier>const</specifier></type> <name>char</name> *</decl></param>)</parameter_list>;</function_decl>
<function_decl><type><name>int</name></type> (<name>PTRFASTCALL</name> *<name>isNmstrt4</name>)<parameter_list>(<param><decl><type><specifier>const</specifier></type> <name>ENCODING</name> *</decl></param>, <param><decl><type><specifier>const</specifier></type> <name>char</name> *</decl></param>)</parameter_list>;</function_decl>
<function_decl><type><name>int</name></type> (<name>PTRFASTCALL</name> *<name>isInvalid2</name>)<parameter_list>(<param><decl><type><specifier>const</specifier></type> <name>ENCODING</name> *</decl></param>, <param><decl><type><specifier>const</specifier></type> <name>char</name> *</decl></param>)</parameter_list>;</function_decl>
<function_decl><type><name>int</name></type> (<name>PTRFASTCALL</name> *<name>isInvalid3</name>)<parameter_list>(<param><decl><type><specifier>const</specifier></type> <name>ENCODING</name> *</decl></param>, <param><decl><type><specifier>const</specifier></type> <name>char</name> *</decl></param>)</parameter_list>;</function_decl>
<function_decl><type><name>int</name></type> (<name>PTRFASTCALL</name> *<name>isInvalid4</name>)<parameter_list>(<param><decl><type><specifier>const</specifier></type> <name>ENCODING</name> *</decl></param>, <param><decl><type><specifier>const</specifier></type> <name>char</name> *</decl></param>)</parameter_list>;</function_decl>
}</block>;</struct>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AS_NORMAL_ENCODING</name><parameter_list>(<param><type><name>enc</name></type></param>)</parameter_list></cpp:macro> <cpp:value>((const struct normal_encoding *) (enc))</cpp:value></cpp:define>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>XML_MIN_SIZE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>STANDARD_VTABLE</name><parameter_list>(<param><type><name>E</name></type></param>)</parameter_list></cpp:macro> <cpp:value>E ##byteType, E ##isNameMin, E ##isNmstrtMin, E ##byteToAscii, E ##charMatches,</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>STANDARD_VTABLE</name><parameter_list>(<param><type><name>E</name></type></param>)</parameter_list></cpp:macro></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NORMAL_VTABLE</name><parameter_list>(<param><type><name>E</name></type></param>)</parameter_list></cpp:macro> <cpp:value>E ##isName2, E ##isName3, E ##isName4, E ##isNmstrt2, E ##isNmstrt3, E ##isNmstrt4, E ##isInvalid2, E ##isInvalid3, E ##isInvalid4</cpp:value></cpp:define>
<function_decl><type><specifier>static</specifier> <name>int</name> <name>FASTCALL</name></type> <name>checkCharRefNumber</name><parameter_list>(<param><decl><type><name>int</name></type></decl></param>)</parameter_list>;</function_decl>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"xmltok_impl.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ascii.h"</cpp:file></cpp:include>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>XML_MIN_SIZE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>sb_isNameMin</name></cpp:macro> <cpp:value>isNever</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>sb_isNmstrtMin</name></cpp:macro> <cpp:value>isNever</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>XML_MIN_SIZE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MINBPC</name><parameter_list>(<param><type><name>enc</name></type></param>)</parameter_list></cpp:macro> <cpp:value>((enc)-&gt;minBytesPerChar)</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MINBPC</name><parameter_list>(<param><type><name>enc</name></type></param>)</parameter_list></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SB_BYTE_TYPE</name><parameter_list>(<param><type><name>enc</name></type></param>, <param><type><name>p</name></type></param>)</parameter_list></cpp:macro> <cpp:value>(((struct normal_encoding *)(enc))-&gt;type[(unsigned char)*(p)])</cpp:value></cpp:define>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>XML_MIN_SIZE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function><type><specifier>static</specifier> <name>int</name> <name>PTRFASTCALL</name></type>
<name>sb_byteType</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>ENCODING</name> *</type><name>enc</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>p</name></decl></param>)</parameter_list> <block>{
<return>return <expr><call><name>SB_BYTE_TYPE</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BYTE_TYPE</name><parameter_list>(<param><type><name>enc</name></type></param>, <param><type><name>p</name></type></param>)</parameter_list></cpp:macro> <cpp:value>(AS_NORMAL_ENCODING(enc)-&gt;byteType(enc, p))</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BYTE_TYPE</name><parameter_list>(<param><type><name>enc</name></type></param>, <param><type><name>p</name></type></param>)</parameter_list></cpp:macro> <cpp:value>SB_BYTE_TYPE(enc, p)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>XML_MIN_SIZE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BYTE_TO_ASCII</name><parameter_list>(<param><type><name>enc</name></type></param>, <param><type><name>p</name></type></param>)</parameter_list></cpp:macro> <cpp:value>(AS_NORMAL_ENCODING(enc)-&gt;byteToAscii(enc, p))</cpp:value></cpp:define>
<function><type><specifier>static</specifier> <name>int</name> <name>PTRFASTCALL</name></type>
<name>sb_byteToAscii</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>ENCODING</name> *</type><name>enc</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>p</name></decl></param>)</parameter_list> <block>{
<return>return <expr>*<name>p</name></expr>;</return>
}</block></function>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BYTE_TO_ASCII</name><parameter_list>(<param><type><name>enc</name></type></param>, <param><type><name>p</name></type></param>)</parameter_list></cpp:macro> <cpp:value>(*(p))</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IS_NAME_CHAR</name><parameter_list>(<param><type><name>enc</name></type></param>, <param><type><name>p</name></type></param>, <param><type><name>n</name></type></param>)</parameter_list></cpp:macro> <cpp:value>(AS_NORMAL_ENCODING(enc)-&gt;isName ##n(enc, p))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IS_NMSTRT_CHAR</name><parameter_list>(<param><type><name>enc</name></type></param>, <param><type><name>p</name></type></param>, <param><type><name>n</name></type></param>)</parameter_list></cpp:macro> <cpp:value>(AS_NORMAL_ENCODING(enc)-&gt;isNmstrt ##n(enc, p))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IS_INVALID_CHAR</name><parameter_list>(<param><type><name>enc</name></type></param>, <param><type><name>p</name></type></param>, <param><type><name>n</name></type></param>)</parameter_list></cpp:macro> <cpp:value>(AS_NORMAL_ENCODING(enc)-&gt;isInvalid ##n(enc, p))</cpp:value></cpp:define>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>XML_MIN_SIZE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IS_NAME_CHAR_MINBPC</name><parameter_list>(<param><type><name>enc</name></type></param>, <param><type><name>p</name></type></param>)</parameter_list></cpp:macro> <cpp:value>(AS_NORMAL_ENCODING(enc)-&gt;isNameMin(enc, p))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IS_NMSTRT_CHAR_MINBPC</name><parameter_list>(<param><type><name>enc</name></type></param>, <param><type><name>p</name></type></param>)</parameter_list></cpp:macro> <cpp:value>(AS_NORMAL_ENCODING(enc)-&gt;isNmstrtMin(enc, p))</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IS_NAME_CHAR_MINBPC</name><parameter_list>(<param><type><name>enc</name></type></param>, <param><type><name>p</name></type></param>)</parameter_list></cpp:macro> <cpp:value>(0)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IS_NMSTRT_CHAR_MINBPC</name><parameter_list>(<param><type><name>enc</name></type></param>, <param><type><name>p</name></type></param>)</parameter_list></cpp:macro> <cpp:value>(0)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>XML_MIN_SIZE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CHAR_MATCHES</name><parameter_list>(<param><type><name>enc</name></type></param>, <param><type><name>p</name></type></param>, <param><type><name>c</name></type></param>)</parameter_list></cpp:macro> <cpp:value>(AS_NORMAL_ENCODING(enc)-&gt;charMatches(enc, p, c))</cpp:value></cpp:define>
<function><type><specifier>static</specifier> <name>int</name> <name>PTRCALL</name></type>
<name>sb_charMatches</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>ENCODING</name> *</type><name>enc</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>p</name></decl></param>, <param><decl><type><name>int</name></type> <name>c</name></decl></param>)</parameter_list> <block>{
<return>return <expr>*<name>p</name> == <name>c</name></expr>;</return>
}</block></function>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CHAR_MATCHES</name><parameter_list>(<param><type><name>enc</name></type></param>, <param><type><name>p</name></type></param>, <param><type><name>c</name></type></param>)</parameter_list></cpp:macro> <cpp:value>(*(p) == c)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PREFIX</name><parameter_list>(<param><type><name>ident</name></type></param>)</parameter_list></cpp:macro> <cpp:value>normal_ ##ident</cpp:value></cpp:define>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"xmltok_impl.c"</cpp:file></cpp:include>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>MINBPC</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>BYTE_TYPE</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>BYTE_TO_ASCII</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>CHAR_MATCHES</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>IS_NAME_CHAR</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>IS_NAME_CHAR_MINBPC</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>IS_NMSTRT_CHAR</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>IS_NMSTRT_CHAR_MINBPC</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>IS_INVALID_CHAR</name></cpp:undef>
<enum>enum <block>{
<decl><name>UTF8_cval1</name> <init>= <expr>0x00</expr></init></decl>,
<decl><name>UTF8_cval2</name> <init>= <expr>0xc0</expr></init></decl>,
<decl><name>UTF8_cval3</name> <init>= <expr>0xe0</expr></init></decl>,
<decl><name>UTF8_cval4</name> <init>= <expr>0xf0</expr></init></decl>
}</block>;</enum>
<function><type><specifier>static</specifier> <name>void</name> <name>PTRCALL</name></type>
<name>utf8_toUtf8</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>ENCODING</name> *</type><name>enc</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> **</type><name>fromP</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>fromLim</name></decl></param>,
<param><decl><type><name>char</name> **</type><name>toP</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>toLim</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>char</name> *</type><name>to</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>from</name></decl>;</decl_stmt>
<if>if <condition>(<expr><name>fromLim</name> - *<name>fromP</name> &gt; <name>toLim</name> - *<name>toP</name></expr>)</condition><then> <block>{
<for>for (<init><expr><name>fromLim</name> = *<name>fromP</name> + (<name>toLim</name> - *<name>toP</name>)</expr>;</init> <condition><expr><name>fromLim</name> &gt; *<name>fromP</name></expr>;</condition> <incr><expr><name>fromLim</name>--</expr></incr>)
<if>if <condition>(<expr>((<name>unsigned</name> <name>char</name>)<name><name>fromLim</name><index>[<expr>-1</expr>]</index></name> &amp; 0xc0) != 0x80</expr>)</condition><then>
<break>break;</break></then></if></for>
}</block></then></if>
<for>for (<init><expr><name>to</name> = *<name>toP</name></expr>, <expr><name>from</name> = *<name>fromP</name></expr>;</init> <condition><expr><name>from</name> != <name>fromLim</name></expr>;</condition> <incr><expr><name>from</name>++</expr>, <expr><name>to</name>++</expr></incr>)
<expr_stmt><expr>*<name>to</name> = *<name>from</name></expr>;</expr_stmt></for>
<expr_stmt><expr>*<name>fromP</name> = <name>from</name></expr>;</expr_stmt>
<expr_stmt><expr>*<name>toP</name> = <name>to</name></expr>;</expr_stmt>
}</block></function>
<function><type><specifier>static</specifier> <name>void</name> <name>PTRCALL</name></type>
<name>utf8_toUtf16</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>ENCODING</name> *</type><name>enc</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> **</type><name>fromP</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>fromLim</name></decl></param>,
<param><decl><type><name>unsigned</name> <name>short</name> **</type><name>toP</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>unsigned</name> <name>short</name> *</type><name>toLim</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>unsigned</name> <name>short</name> *</type><name>to</name> <init>= <expr>*<name>toP</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>from</name> <init>= <expr>*<name>fromP</name></expr></init></decl>;</decl_stmt>
<while>while <condition>(<expr><name>from</name> != <name>fromLim</name> &amp;&amp; <name>to</name> != <name>toLim</name></expr>)</condition> <block>{
<switch>switch <condition>(<expr>((struct <name>normal_encoding</name> *)<name>enc</name>)-&gt;<name><name>type</name><index>[<expr>(<name>unsigned</name> <name>char</name>)*<name>from</name></expr>]</index></name></expr>)</condition> <block>{
<case>case <expr><name>BT_LEAD2</name></expr>:
<expr_stmt><expr>*<name>to</name>++ = <call>(<name>unsigned</name> <name>short</name>)<argument_list>(<argument><expr>((<name><name>from</name><index>[<expr>0</expr>]</index></name> &amp; 0x1f) &lt;&lt; 6) | (<name><name>from</name><index>[<expr>1</expr>]</index></name> &amp; 0x3f)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>from</name> += 2</expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr><name>BT_LEAD3</name></expr>:
<expr_stmt><expr>*<name>to</name>++ = <call>(<name>unsigned</name> <name>short</name>)<argument_list>(<argument><expr>((<name><name>from</name><index>[<expr>0</expr>]</index></name> &amp; 0xf) &lt;&lt; 12)
| ((<name><name>from</name><index>[<expr>1</expr>]</index></name> &amp; 0x3f) &lt;&lt; 6) | (<name><name>from</name><index>[<expr>2</expr>]</index></name> &amp; 0x3f)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>from</name> += 3</expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr><name>BT_LEAD4</name></expr>: <block>{
<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>n</name></decl>;</decl_stmt>
<if>if <condition>(<expr><name>to</name> + 1 == <name>toLim</name></expr>)</condition><then>
<goto>goto <name>after</name>;</goto></then></if>
<expr_stmt><expr><name>n</name> = ((<name><name>from</name><index>[<expr>0</expr>]</index></name> &amp; 0x7) &lt;&lt; 18) | ((<name><name>from</name><index>[<expr>1</expr>]</index></name> &amp; 0x3f) &lt;&lt; 12)
| ((<name><name>from</name><index>[<expr>2</expr>]</index></name> &amp; 0x3f) &lt;&lt; 6) | (<name><name>from</name><index>[<expr>3</expr>]</index></name> &amp; 0x3f)</expr>;</expr_stmt>
<expr_stmt><expr><name>n</name> -= 0x10000</expr>;</expr_stmt>
<expr_stmt><expr><name><name>to</name><index>[<expr>0</expr>]</index></name> = <call>(<name>unsigned</name> <name>short</name>)<argument_list>(<argument><expr>(<name>n</name> &gt;&gt; 10) | 0xD800</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>to</name><index>[<expr>1</expr>]</index></name> = <call>(<name>unsigned</name> <name>short</name>)<argument_list>(<argument><expr>(<name>n</name> &amp; 0x3FF) | 0xDC00</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>to</name> += 2</expr>;</expr_stmt>
<expr_stmt><expr><name>from</name> += 4</expr>;</expr_stmt>
}</block>
<break>break;</break>
</case><default>default:
<expr_stmt><expr>*<name>to</name>++ = *<name>from</name>++</expr>;</expr_stmt>
<break>break;</break>
</default>}</block></switch>
}</block></while>
<label><name>after</name>:</label>
<expr_stmt><expr>*<name>fromP</name> = <name>from</name></expr>;</expr_stmt>
<expr_stmt><expr>*<name>toP</name> = <name>to</name></expr>;</expr_stmt>
}</block></function>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>XML_NS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> struct <name>normal_encoding</name></type> <name>utf8_encoding_ns</name> <init>= <expr><block>{
<expr><block>{ <expr><name>VTABLE1</name></expr>, <expr><name>utf8_toUtf8</name></expr>, <expr><name>utf8_toUtf16</name></expr>, <expr>1</expr>, <expr>1</expr>, <expr>0</expr> }</block></expr>,
<expr><block>{
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"asciitab.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utf8tab.h"</cpp:file></cpp:include>
}</block></expr>,
<macro><name>STANDARD_VTABLE</name><argument_list>(<argument>sb_</argument>)</argument_list></macro> <macro><name>NORMAL_VTABLE</name><argument_list>(<argument>utf8_</argument>)</argument_list></macro>
}</block></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> struct <name>normal_encoding</name></type> <name>utf8_encoding</name> <init>= <expr><block>{
<expr><block>{ <expr><name>VTABLE1</name></expr>, <expr><name>utf8_toUtf8</name></expr>, <expr><name>utf8_toUtf16</name></expr>, <expr>1</expr>, <expr>1</expr>, <expr>0</expr> }</block></expr>,
<expr><block>{
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BT_COLON</name></cpp:macro> <cpp:value>BT_NMSTRT</cpp:value></cpp:define>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"asciitab.h"</cpp:file></cpp:include>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>BT_COLON</name></cpp:undef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utf8tab.h"</cpp:file></cpp:include>
}</block></expr>,
<macro><name>STANDARD_VTABLE</name><argument_list>(<argument>sb_</argument>)</argument_list></macro> <macro><name>NORMAL_VTABLE</name><argument_list>(<argument>utf8_</argument>)</argument_list></macro>
}</block></expr></init></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>XML_NS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> struct <name>normal_encoding</name></type> <name>internal_utf8_encoding_ns</name> <init>= <expr><block>{
<expr><block>{ <expr><name>VTABLE1</name></expr>, <expr><name>utf8_toUtf8</name></expr>, <expr><name>utf8_toUtf16</name></expr>, <expr>1</expr>, <expr>1</expr>, <expr>0</expr> }</block></expr>,
<expr><block>{
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"iasciitab.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utf8tab.h"</cpp:file></cpp:include>
}</block></expr>,
<macro><name>STANDARD_VTABLE</name><argument_list>(<argument>sb_</argument>)</argument_list></macro> <macro><name>NORMAL_VTABLE</name><argument_list>(<argument>utf8_</argument>)</argument_list></macro>
}</block></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> struct <name>normal_encoding</name></type> <name>internal_utf8_encoding</name> <init>= <expr><block>{
<expr><block>{ <expr><name>VTABLE1</name></expr>, <expr><name>utf8_toUtf8</name></expr>, <expr><name>utf8_toUtf16</name></expr>, <expr>1</expr>, <expr>1</expr>, <expr>0</expr> }</block></expr>,
<expr><block>{
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BT_COLON</name></cpp:macro> <cpp:value>BT_NMSTRT</cpp:value></cpp:define>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"iasciitab.h"</cpp:file></cpp:include>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>BT_COLON</name></cpp:undef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utf8tab.h"</cpp:file></cpp:include>
}</block></expr>,
<macro><name>STANDARD_VTABLE</name><argument_list>(<argument>sb_</argument>)</argument_list></macro> <macro><name>NORMAL_VTABLE</name><argument_list>(<argument>utf8_</argument>)</argument_list></macro>
}</block></expr></init></decl>;</decl_stmt>
<function><type><specifier>static</specifier> <name>void</name> <name>PTRCALL</name></type>
<name>latin1_toUtf8</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>ENCODING</name> *</type><name>enc</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> **</type><name>fromP</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>fromLim</name></decl></param>,
<param><decl><type><name>char</name> **</type><name>toP</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>toLim</name></decl></param>)</parameter_list> <block>{
<for>for (<init>;</init><condition>;</condition><incr/>) <block>{
<decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name>c</name></decl>;</decl_stmt>
<if>if <condition>(<expr>*<name>fromP</name> == <name>fromLim</name></expr>)</condition><then>
<break>break;</break></then></if>
<expr_stmt><expr><name>c</name> = (<name>unsigned</name> <name>char</name>)**<name>fromP</name></expr>;</expr_stmt>
<if>if <condition>(<expr><name>c</name> &amp; 0x80</expr>)</condition><then> <block>{
<if>if <condition>(<expr><name>toLim</name> - *<name>toP</name> &lt; 2</expr>)</condition><then>
<break>break;</break></then></if>
<expr_stmt><expr>*(*<name>toP</name>)++ = <call>(<name>char</name>)<argument_list>(<argument><expr>(<name>c</name> &gt;&gt; 6) | <name>UTF8_cval2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr>*(*<name>toP</name>)++ = <call>(<name>char</name>)<argument_list>(<argument><expr>(<name>c</name> &amp; 0x3f) | 0x80</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr>(*<name>fromP</name>)++</expr>;</expr_stmt>
}</block></then> <else>else <block>{
<if>if <condition>(<expr>*<name>toP</name> == <name>toLim</name></expr>)</condition><then>
<break>break;</break></then></if>
<expr_stmt><expr>*(*<name>toP</name>)++ = *(*<name>fromP</name>)++</expr>;</expr_stmt>
}</block></else></if>
}</block></for>
}</block></function>
<function><type><specifier>static</specifier> <name>void</name> <name>PTRCALL</name></type>
<name>latin1_toUtf16</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>ENCODING</name> *</type><name>enc</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> **</type><name>fromP</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>fromLim</name></decl></param>,
<param><decl><type><name>unsigned</name> <name>short</name> **</type><name>toP</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>unsigned</name> <name>short</name> *</type><name>toLim</name></decl></param>)</parameter_list> <block>{
<while>while <condition>(<expr>*<name>fromP</name> != <name>fromLim</name> &amp;&amp; *<name>toP</name> != <name>toLim</name></expr>)</condition>
<expr_stmt><expr>*(*<name>toP</name>)++ = (<name>unsigned</name> <name>char</name>)*(*<name>fromP</name>)++</expr>;</expr_stmt></while>
}</block></function>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>XML_NS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> struct <name>normal_encoding</name></type> <name>latin1_encoding_ns</name> <init>= <expr><block>{
<expr><block>{ <expr><name>VTABLE1</name></expr>, <expr><name>latin1_toUtf8</name></expr>, <expr><name>latin1_toUtf16</name></expr>, <expr>1</expr>, <expr>0</expr>, <expr>0</expr> }</block></expr>,
<expr><block>{
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"asciitab.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"latin1tab.h"</cpp:file></cpp:include>
}</block></expr>,
<macro><name>STANDARD_VTABLE</name><argument_list>(<argument>sb_</argument>)</argument_list></macro>
}</block></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> struct <name>normal_encoding</name></type> <name>latin1_encoding</name> <init>= <expr><block>{
<expr><block>{ <expr><name>VTABLE1</name></expr>, <expr><name>latin1_toUtf8</name></expr>, <expr><name>latin1_toUtf16</name></expr>, <expr>1</expr>, <expr>0</expr>, <expr>0</expr> }</block></expr>,
<expr><block>{
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BT_COLON</name></cpp:macro> <cpp:value>BT_NMSTRT</cpp:value></cpp:define>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"asciitab.h"</cpp:file></cpp:include>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>BT_COLON</name></cpp:undef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"latin1tab.h"</cpp:file></cpp:include>
}</block></expr>,
<macro><name>STANDARD_VTABLE</name><argument_list>(<argument>sb_</argument>)</argument_list></macro>
}</block></expr></init></decl>;</decl_stmt>
<function><type><specifier>static</specifier> <name>void</name> <name>PTRCALL</name></type>
<name>ascii_toUtf8</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>ENCODING</name> *</type><name>enc</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> **</type><name>fromP</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>fromLim</name></decl></param>,
<param><decl><type><name>char</name> **</type><name>toP</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>toLim</name></decl></param>)</parameter_list> <block>{
<while>while <condition>(<expr>*<name>fromP</name> != <name>fromLim</name> &amp;&amp; *<name>toP</name> != <name>toLim</name></expr>)</condition>
<expr_stmt><expr>*(*<name>toP</name>)++ = *(*<name>fromP</name>)++</expr>;</expr_stmt></while>
}</block></function>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>XML_NS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> struct <name>normal_encoding</name></type> <name>ascii_encoding_ns</name> <init>= <expr><block>{
<expr><block>{ <expr><name>VTABLE1</name></expr>, <expr><name>ascii_toUtf8</name></expr>, <expr><name>latin1_toUtf16</name></expr>, <expr>1</expr>, <expr>1</expr>, <expr>0</expr> }</block></expr>,
<expr><block>{
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"asciitab.h"</cpp:file></cpp:include>
}</block></expr>,
<macro><name>STANDARD_VTABLE</name><argument_list>(<argument>sb_</argument>)</argument_list></macro>
}</block></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> struct <name>normal_encoding</name></type> <name>ascii_encoding</name> <init>= <expr><block>{
<expr><block>{ <expr><name>VTABLE1</name></expr>, <expr><name>ascii_toUtf8</name></expr>, <expr><name>latin1_toUtf16</name></expr>, <expr>1</expr>, <expr>1</expr>, <expr>0</expr> }</block></expr>,
<expr><block>{
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BT_COLON</name></cpp:macro> <cpp:value>BT_NMSTRT</cpp:value></cpp:define>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"asciitab.h"</cpp:file></cpp:include>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>BT_COLON</name></cpp:undef>
}</block></expr>,
<macro><name>STANDARD_VTABLE</name><argument_list>(<argument>sb_</argument>)</argument_list></macro>
}</block></expr></init></decl>;</decl_stmt>
<function><type><specifier>static</specifier> <name>int</name> <name>PTRFASTCALL</name></type>
<name>unicode_byte_type</name><parameter_list>(<param><decl><type><name>char</name></type> <name>hi</name></decl></param>, <param><decl><type><name>char</name></type> <name>lo</name></decl></param>)</parameter_list> <block>{
<switch>switch <condition>(<expr>(<name>unsigned</name> <name>char</name>)<name>hi</name></expr>)</condition> <block>{
<case>case <expr>0xD8</expr>:
</case><case>case <expr>0xD9</expr>:
</case><case>case <expr>0xDA</expr>:
</case><case>case <expr>0xDB</expr>:
<return>return <expr><name>BT_LEAD4</name></expr>;</return>
</case><case>case <expr>0xDC</expr>:
</case><case>case <expr>0xDD</expr>:
</case><case>case <expr>0xDE</expr>:
</case><case>case <expr>0xDF</expr>:
<return>return <expr><name>BT_TRAIL</name></expr>;</return>
</case><case>case <expr>0xFF</expr>:
<switch>switch <condition>(<expr>(<name>unsigned</name> <name>char</name>)<name>lo</name></expr>)</condition> <block>{
<case>case <expr>0xFF</expr>:
</case><case>case <expr>0xFE</expr>:
<return>return <expr><name>BT_NONXML</name></expr>;</return>
</case>}</block></switch>
<break>break;</break>
</case>}</block></switch>
<return>return <expr><name>BT_NONASCII</name></expr>;</return>
}</block></function>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DEFINE_UTF16_TO_UTF8</name><parameter_list>(<param><type><name>E</name></type></param>)</parameter_list></cpp:macro> <cpp:value>static void PTRCALL E ##toUtf8(const ENCODING *enc, const char **fromP, const char *fromLim, char **toP, const char *toLim) { const char *from; for (from = *fromP; from != fromLim; from += 2) { int plane; unsigned char lo2; unsigned char lo = GET_LO(from); unsigned char hi = GET_HI(from); switch (hi) { case 0: if (lo &lt; 0x80) { if (*toP == toLim) { *fromP = from; return; } *(*toP)++ = lo; break; } case 0x1: case 0x2: case 0x3: case 0x4: case 0x5: case 0x6: case 0x7: if (toLim - *toP &lt; 2) { *fromP = from; return; } *(*toP)++ = ((lo &gt;&gt; 6) | (hi &lt;&lt; 2) | UTF8_cval2); *(*toP)++ = ((lo &amp; 0x3f) | 0x80); break; default: if (toLim - *toP &lt; 3) { *fromP = from; return; } *(*toP)++ = ((hi &gt;&gt; 4) | UTF8_cval3); *(*toP)++ = (((hi &amp; 0xf) &lt;&lt; 2) | (lo &gt;&gt; 6) | 0x80); *(*toP)++ = ((lo &amp; 0x3f) | 0x80); break; case 0xD8: case 0xD9: case 0xDA: case 0xDB: if (toLim - *toP &lt; 4) { *fromP = from; return; } plane = (((hi &amp; 0x3) &lt;&lt; 2) | ((lo &gt;&gt; 6) &amp; 0x3)) + 1; *(*toP)++ = ((plane &gt;&gt; 2) | UTF8_cval4); *(*toP)++ = (((lo &gt;&gt; 2) &amp; 0xF) | ((plane &amp; 0x3) &lt;&lt; 4) | 0x80); from += 2; lo2 = GET_LO(from); *(*toP)++ = (((lo &amp; 0x3) &lt;&lt; 4) | ((GET_HI(from) &amp; 0x3) &lt;&lt; 2) | (lo2 &gt;&gt; 6) | 0x80); *(*toP)++ = ((lo2 &amp; 0x3f) | 0x80); break; } } *fromP = from; }</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DEFINE_UTF16_TO_UTF16</name><parameter_list>(<param><type><name>E</name></type></param>)</parameter_list></cpp:macro> <cpp:value>static void PTRCALL E ##toUtf16(const ENCODING *enc, const char **fromP, const char *fromLim, unsigned short **toP, const unsigned short *toLim) { if (fromLim - *fromP &gt; ((toLim - *toP) &lt;&lt; 1) &amp;&amp; (GET_HI(fromLim - 2) &amp; 0xF8) == 0xD8) fromLim -= 2; for (; *fromP != fromLim &amp;&amp; *toP != toLim; *fromP += 2) *(*toP)++ = (GET_HI(*fromP) &lt;&lt; 8) | GET_LO(*fromP); }</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SET2</name><parameter_list>(<param><type><name>ptr</name></type></param>, <param><type><name>ch</name></type></param>)</parameter_list></cpp:macro> <cpp:value>(((ptr)[0] = ((ch) &amp; 0xff)), ((ptr)[1] = ((ch) &gt;&gt; 8)))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GET_LO</name><parameter_list>(<param><type><name>ptr</name></type></param>)</parameter_list></cpp:macro> <cpp:value>((unsigned char)(ptr)[0])</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GET_HI</name><parameter_list>(<param><type><name>ptr</name></type></param>)</parameter_list></cpp:macro> <cpp:value>((unsigned char)(ptr)[1])</cpp:value></cpp:define>
<macro><name>DEFINE_UTF16_TO_UTF8</name><argument_list>(<argument>little2_</argument>)</argument_list></macro>
<macro><name>DEFINE_UTF16_TO_UTF16</name><argument_list>(<argument>little2_</argument>)</argument_list></macro>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>SET2</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>GET_LO</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>GET_HI</name></cpp:undef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SET2</name><parameter_list>(<param><type><name>ptr</name></type></param>, <param><type><name>ch</name></type></param>)</parameter_list></cpp:macro> <cpp:value>(((ptr)[0] = ((ch) &gt;&gt; 8)), ((ptr)[1] = ((ch) &amp; 0xFF)))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GET_LO</name><parameter_list>(<param><type><name>ptr</name></type></param>)</parameter_list></cpp:macro> <cpp:value>((unsigned char)(ptr)[1])</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GET_HI</name><parameter_list>(<param><type><name>ptr</name></type></param>)</parameter_list></cpp:macro> <cpp:value>((unsigned char)(ptr)[0])</cpp:value></cpp:define>
<macro><name>DEFINE_UTF16_TO_UTF8</name><argument_list>(<argument>big2_</argument>)</argument_list></macro>
<macro><name>DEFINE_UTF16_TO_UTF16</name><argument_list>(<argument>big2_</argument>)</argument_list></macro>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>SET2</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>GET_LO</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>GET_HI</name></cpp:undef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LITTLE2_BYTE_TYPE</name><parameter_list>(<param><type><name>enc</name></type></param>, <param><type><name>p</name></type></param>)</parameter_list></cpp:macro> <cpp:value>((p)[1] == 0 ? ((struct normal_encoding *)(enc))-&gt;type[(unsigned char)*(p)] : unicode_byte_type((p)[1], (p)[0]))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LITTLE2_BYTE_TO_ASCII</name><parameter_list>(<param><type><name>enc</name></type></param>, <param><type><name>p</name></type></param>)</parameter_list></cpp:macro> <cpp:value>((p)[1] == 0 ? (p)[0] : -1)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LITTLE2_CHAR_MATCHES</name><parameter_list>(<param><type><name>enc</name></type></param>, <param><type><name>p</name></type></param>, <param><type><name>c</name></type></param>)</parameter_list></cpp:macro> <cpp:value>((p)[1] == 0 &amp;&amp; (p)[0] == c)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LITTLE2_IS_NAME_CHAR_MINBPC</name><parameter_list>(<param><type><name>enc</name></type></param>, <param><type><name>p</name></type></param>)</parameter_list></cpp:macro> <cpp:value>UCS2_GET_NAMING(namePages, (unsigned char)p[1], (unsigned char)p[0])</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LITTLE2_IS_NMSTRT_CHAR_MINBPC</name><parameter_list>(<param><type><name>enc</name></type></param>, <param><type><name>p</name></type></param>)</parameter_list></cpp:macro> <cpp:value>UCS2_GET_NAMING(nmstrtPages, (unsigned char)p[1], (unsigned char)p[0])</cpp:value></cpp:define>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>XML_MIN_SIZE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function><type><specifier>static</specifier> <name>int</name> <name>PTRFASTCALL</name></type>
<name>little2_byteType</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>ENCODING</name> *</type><name>enc</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>p</name></decl></param>)</parameter_list> <block>{
<return>return <expr><call><name>LITTLE2_BYTE_TYPE</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name> <name>PTRFASTCALL</name></type>
<name>little2_byteToAscii</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>ENCODING</name> *</type><name>enc</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>p</name></decl></param>)</parameter_list> <block>{
<return>return <expr><call><name>LITTLE2_BYTE_TO_ASCII</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name> <name>PTRCALL</name></type>
<name>little2_charMatches</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>ENCODING</name> *</type><name>enc</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>p</name></decl></param>, <param><decl><type><name>int</name></type> <name>c</name></decl></param>)</parameter_list> <block>{
<return>return <expr><call><name>LITTLE2_CHAR_MATCHES</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name> <name>PTRFASTCALL</name></type>
<name>little2_isNameMin</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>ENCODING</name> *</type><name>enc</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>p</name></decl></param>)</parameter_list> <block>{
<return>return <expr><call><name>LITTLE2_IS_NAME_CHAR_MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name> <name>PTRFASTCALL</name></type>
<name>little2_isNmstrtMin</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>ENCODING</name> *</type><name>enc</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>p</name></decl></param>)</parameter_list> <block>{
<return>return <expr><call><name>LITTLE2_IS_NMSTRT_CHAR_MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>VTABLE</name></cpp:undef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>VTABLE</name></cpp:macro> <cpp:value>VTABLE1, little2_toUtf8, little2_toUtf16</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>PREFIX</name></cpp:undef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PREFIX</name><parameter_list>(<param><type><name>ident</name></type></param>)</parameter_list></cpp:macro> <cpp:value>little2_ ##ident</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MINBPC</name><parameter_list>(<param><type><name>enc</name></type></param>)</parameter_list></cpp:macro> <cpp:value>2</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BYTE_TYPE</name><parameter_list>(<param><type><name>enc</name></type></param>, <param><type><name>p</name></type></param>)</parameter_list></cpp:macro> <cpp:value>LITTLE2_BYTE_TYPE(enc, p)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BYTE_TO_ASCII</name><parameter_list>(<param><type><name>enc</name></type></param>, <param><type><name>p</name></type></param>)</parameter_list></cpp:macro> <cpp:value>LITTLE2_BYTE_TO_ASCII(enc, p)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CHAR_MATCHES</name><parameter_list>(<param><type><name>enc</name></type></param>, <param><type><name>p</name></type></param>, <param><type><name>c</name></type></param>)</parameter_list></cpp:macro> <cpp:value>LITTLE2_CHAR_MATCHES(enc, p, c)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IS_NAME_CHAR</name><parameter_list>(<param><type><name>enc</name></type></param>, <param><type><name>p</name></type></param>, <param><type><name>n</name></type></param>)</parameter_list></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IS_NAME_CHAR_MINBPC</name><parameter_list>(<param><type><name>enc</name></type></param>, <param><type><name>p</name></type></param>)</parameter_list></cpp:macro> <cpp:value>LITTLE2_IS_NAME_CHAR_MINBPC(enc, p)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IS_NMSTRT_CHAR</name><parameter_list>(<param><type><name>enc</name></type></param>, <param><type><name>p</name></type></param>, <param><type><name>n</name></type></param>)</parameter_list></cpp:macro> <cpp:value>(0)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IS_NMSTRT_CHAR_MINBPC</name><parameter_list>(<param><type><name>enc</name></type></param>, <param><type><name>p</name></type></param>)</parameter_list></cpp:macro> <cpp:value>LITTLE2_IS_NMSTRT_CHAR_MINBPC(enc, p)</cpp:value></cpp:define>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"xmltok_impl.c"</cpp:file></cpp:include>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>MINBPC</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>BYTE_TYPE</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>BYTE_TO_ASCII</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>CHAR_MATCHES</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>IS_NAME_CHAR</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>IS_NAME_CHAR_MINBPC</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>IS_NMSTRT_CHAR</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>IS_NMSTRT_CHAR_MINBPC</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>IS_INVALID_CHAR</name></cpp:undef>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>XML_NS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> struct <name>normal_encoding</name></type> <name>little2_encoding_ns</name> <init>= <expr><block>{
<expr><block>{
<expr><name>VTABLE</name></expr>, <expr>2</expr>, <expr>0</expr>,
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>BYTEORDER</name> == 1234</expr></cpp:if>
<expr>1
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
0</expr>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></expr>,
<expr><block>{
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"asciitab.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"latin1tab.h"</cpp:file></cpp:include>
}</block></expr>,
<macro><name>STANDARD_VTABLE</name><argument_list>(<argument>little2_</argument>)</argument_list></macro>
}</block></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> struct <name>normal_encoding</name></type> <name>little2_encoding</name> <init>= <expr><block>{
<expr><block>{
<expr><name>VTABLE</name></expr>, <expr>2</expr>, <expr>0</expr>,
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>BYTEORDER</name> == 1234</expr></cpp:if>
<expr>1
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
0</expr>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></expr>,
<expr><block>{
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BT_COLON</name></cpp:macro> <cpp:value>BT_NMSTRT</cpp:value></cpp:define>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"asciitab.h"</cpp:file></cpp:include>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>BT_COLON</name></cpp:undef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"latin1tab.h"</cpp:file></cpp:include>
}</block></expr>,
<macro><name>STANDARD_VTABLE</name><argument_list>(<argument>little2_</argument>)</argument_list></macro>
}</block></expr></init></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>BYTEORDER</name> != 4321</expr></cpp:if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>XML_NS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> struct <name>normal_encoding</name></type> <name>internal_little2_encoding_ns</name> <init>= <expr><block>{
<expr><block>{ <expr><name>VTABLE</name></expr>, <expr>2</expr>, <expr>0</expr>, <expr>1</expr> }</block></expr>,
<expr><block>{
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"iasciitab.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"latin1tab.h"</cpp:file></cpp:include>
}</block></expr>,
<macro><name>STANDARD_VTABLE</name><argument_list>(<argument>little2_</argument>)</argument_list></macro>
}</block></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> struct <name>normal_encoding</name></type> <name>internal_little2_encoding</name> <init>= <expr><block>{
<expr><block>{ <expr><name>VTABLE</name></expr>, <expr>2</expr>, <expr>0</expr>, <expr>1</expr> }</block></expr>,
<expr><block>{
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BT_COLON</name></cpp:macro> <cpp:value>BT_NMSTRT</cpp:value></cpp:define>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"iasciitab.h"</cpp:file></cpp:include>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>BT_COLON</name></cpp:undef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"latin1tab.h"</cpp:file></cpp:include>
}</block></expr>,
<macro><name>STANDARD_VTABLE</name><argument_list>(<argument>little2_</argument>)</argument_list></macro>
}</block></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BIG2_BYTE_TYPE</name><parameter_list>(<param><type><name>enc</name></type></param>, <param><type><name>p</name></type></param>)</parameter_list></cpp:macro> <cpp:value>((p)[0] == 0 ? ((struct normal_encoding *)(enc))-&gt;type[(unsigned char)(p)[1]] : unicode_byte_type((p)[0], (p)[1]))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BIG2_BYTE_TO_ASCII</name><parameter_list>(<param><type><name>enc</name></type></param>, <param><type><name>p</name></type></param>)</parameter_list></cpp:macro> <cpp:value>((p)[0] == 0 ? (p)[1] : -1)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BIG2_CHAR_MATCHES</name><parameter_list>(<param><type><name>enc</name></type></param>, <param><type><name>p</name></type></param>, <param><type><name>c</name></type></param>)</parameter_list></cpp:macro> <cpp:value>((p)[0] == 0 &amp;&amp; (p)[1] == c)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BIG2_IS_NAME_CHAR_MINBPC</name><parameter_list>(<param><type><name>enc</name></type></param>, <param><type><name>p</name></type></param>)</parameter_list></cpp:macro> <cpp:value>UCS2_GET_NAMING(namePages, (unsigned char)p[0], (unsigned char)p[1])</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BIG2_IS_NMSTRT_CHAR_MINBPC</name><parameter_list>(<param><type><name>enc</name></type></param>, <param><type><name>p</name></type></param>)</parameter_list></cpp:macro> <cpp:value>UCS2_GET_NAMING(nmstrtPages, (unsigned char)p[0], (unsigned char)p[1])</cpp:value></cpp:define>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>XML_MIN_SIZE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function><type><specifier>static</specifier> <name>int</name> <name>PTRFASTCALL</name></type>
<name>big2_byteType</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>ENCODING</name> *</type><name>enc</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>p</name></decl></param>)</parameter_list> <block>{
<return>return <expr><call><name>BIG2_BYTE_TYPE</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name> <name>PTRFASTCALL</name></type>
<name>big2_byteToAscii</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>ENCODING</name> *</type><name>enc</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>p</name></decl></param>)</parameter_list> <block>{
<return>return <expr><call><name>BIG2_BYTE_TO_ASCII</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name> <name>PTRCALL</name></type>
<name>big2_charMatches</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>ENCODING</name> *</type><name>enc</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>p</name></decl></param>, <param><decl><type><name>int</name></type> <name>c</name></decl></param>)</parameter_list> <block>{
<return>return <expr><call><name>BIG2_CHAR_MATCHES</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name> <name>PTRFASTCALL</name></type>
<name>big2_isNameMin</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>ENCODING</name> *</type><name>enc</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>p</name></decl></param>)</parameter_list> <block>{
<return>return <expr><call><name>BIG2_IS_NAME_CHAR_MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name> <name>PTRFASTCALL</name></type>
<name>big2_isNmstrtMin</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>ENCODING</name> *</type><name>enc</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>p</name></decl></param>)</parameter_list> <block>{
<return>return <expr><call><name>BIG2_IS_NMSTRT_CHAR_MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>VTABLE</name></cpp:undef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>VTABLE</name></cpp:macro> <cpp:value>VTABLE1, big2_toUtf8, big2_toUtf16</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>PREFIX</name></cpp:undef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PREFIX</name><parameter_list>(<param><type><name>ident</name></type></param>)</parameter_list></cpp:macro> <cpp:value>big2_ ##ident</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MINBPC</name><parameter_list>(<param><type><name>enc</name></type></param>)</parameter_list></cpp:macro> <cpp:value>2</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BYTE_TYPE</name><parameter_list>(<param><type><name>enc</name></type></param>, <param><type><name>p</name></type></param>)</parameter_list></cpp:macro> <cpp:value>BIG2_BYTE_TYPE(enc, p)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BYTE_TO_ASCII</name><parameter_list>(<param><type><name>enc</name></type></param>, <param><type><name>p</name></type></param>)</parameter_list></cpp:macro> <cpp:value>BIG2_BYTE_TO_ASCII(enc, p)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CHAR_MATCHES</name><parameter_list>(<param><type><name>enc</name></type></param>, <param><type><name>p</name></type></param>, <param><type><name>c</name></type></param>)</parameter_list></cpp:macro> <cpp:value>BIG2_CHAR_MATCHES(enc, p, c)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IS_NAME_CHAR</name><parameter_list>(<param><type><name>enc</name></type></param>, <param><type><name>p</name></type></param>, <param><type><name>n</name></type></param>)</parameter_list></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IS_NAME_CHAR_MINBPC</name><parameter_list>(<param><type><name>enc</name></type></param>, <param><type><name>p</name></type></param>)</parameter_list></cpp:macro> <cpp:value>BIG2_IS_NAME_CHAR_MINBPC(enc, p)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IS_NMSTRT_CHAR</name><parameter_list>(<param><type><name>enc</name></type></param>, <param><type><name>p</name></type></param>, <param><type><name>n</name></type></param>)</parameter_list></cpp:macro> <cpp:value>(0)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IS_NMSTRT_CHAR_MINBPC</name><parameter_list>(<param><type><name>enc</name></type></param>, <param><type><name>p</name></type></param>)</parameter_list></cpp:macro> <cpp:value>BIG2_IS_NMSTRT_CHAR_MINBPC(enc, p)</cpp:value></cpp:define>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"xmltok_impl.c"</cpp:file></cpp:include>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>MINBPC</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>BYTE_TYPE</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>BYTE_TO_ASCII</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>CHAR_MATCHES</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>IS_NAME_CHAR</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>IS_NAME_CHAR_MINBPC</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>IS_NMSTRT_CHAR</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>IS_NMSTRT_CHAR_MINBPC</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>IS_INVALID_CHAR</name></cpp:undef>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>XML_NS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> struct <name>normal_encoding</name></type> <name>big2_encoding_ns</name> <init>= <expr><block>{
<expr><block>{
<expr><name>VTABLE</name></expr>, <expr>2</expr>, <expr>0</expr>,
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>BYTEORDER</name> == 4321</expr></cpp:if>
<expr>1
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
0</expr>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></expr>,
<expr><block>{
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"asciitab.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"latin1tab.h"</cpp:file></cpp:include>
}</block></expr>,
<macro><name>STANDARD_VTABLE</name><argument_list>(<argument>big2_</argument>)</argument_list></macro>
}</block></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> struct <name>normal_encoding</name></type> <name>big2_encoding</name> <init>= <expr><block>{
<expr><block>{
<expr><name>VTABLE</name></expr>, <expr>2</expr>, <expr>0</expr>,
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>BYTEORDER</name> == 4321</expr></cpp:if>
<expr>1
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
0</expr>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></expr>,
<expr><block>{
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BT_COLON</name></cpp:macro> <cpp:value>BT_NMSTRT</cpp:value></cpp:define>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"asciitab.h"</cpp:file></cpp:include>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>BT_COLON</name></cpp:undef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"latin1tab.h"</cpp:file></cpp:include>
}</block></expr>,
<macro><name>STANDARD_VTABLE</name><argument_list>(<argument>big2_</argument>)</argument_list></macro>
}</block></expr></init></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>BYTEORDER</name> != 1234</expr></cpp:if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>XML_NS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> struct <name>normal_encoding</name></type> <name>internal_big2_encoding_ns</name> <init>= <expr><block>{
<expr><block>{ <expr><name>VTABLE</name></expr>, <expr>2</expr>, <expr>0</expr>, <expr>1</expr> }</block></expr>,
<expr><block>{
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"iasciitab.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"latin1tab.h"</cpp:file></cpp:include>
}</block></expr>,
<macro><name>STANDARD_VTABLE</name><argument_list>(<argument>big2_</argument>)</argument_list></macro>
}</block></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> struct <name>normal_encoding</name></type> <name>internal_big2_encoding</name> <init>= <expr><block>{
<expr><block>{ <expr><name>VTABLE</name></expr>, <expr>2</expr>, <expr>0</expr>, <expr>1</expr> }</block></expr>,
<expr><block>{
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BT_COLON</name></cpp:macro> <cpp:value>BT_NMSTRT</cpp:value></cpp:define>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"iasciitab.h"</cpp:file></cpp:include>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>BT_COLON</name></cpp:undef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"latin1tab.h"</cpp:file></cpp:include>
}</block></expr>,
<macro><name>STANDARD_VTABLE</name><argument_list>(<argument>big2_</argument>)</argument_list></macro>
}</block></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>PREFIX</name></cpp:undef>
<function><type><specifier>static</specifier> <name>int</name> <name>FASTCALL</name></type>
<name>streqci</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>s1</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>s2</name></decl></param>)</parameter_list> <block>{
<for>for (<init>;</init><condition>;</condition><incr/>) <block>{
<decl_stmt><decl><type><name>char</name></type> <name>c1</name> <init>= <expr>*<name>s1</name>++</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name>c2</name> <init>= <expr>*<name>s2</name>++</expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>ASCII_a</name> &lt;= <name>c1</name> &amp;&amp; <name>c1</name> &lt;= <name>ASCII_z</name></expr>)</condition><then>
<expr_stmt><expr><name>c1</name> += <name>ASCII_A</name> - <name>ASCII_a</name></expr>;</expr_stmt></then></if>
<if>if <condition>(<expr><name>ASCII_a</name> &lt;= <name>c2</name> &amp;&amp; <name>c2</name> &lt;= <name>ASCII_z</name></expr>)</condition><then>
<expr_stmt><expr><name>c2</name> += <name>ASCII_A</name> - <name>ASCII_a</name></expr>;</expr_stmt></then></if>
<if>if <condition>(<expr><name>c1</name> != <name>c2</name></expr>)</condition><then>
<return>return <expr>0</expr>;</return></then></if>
<if>if <condition>(<expr>!<name>c1</name></expr>)</condition><then>
<break>break;</break></then></if>
}</block></for>
<return>return <expr>1</expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>void</name> <name>PTRCALL</name></type>
<name>initUpdatePosition</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>ENCODING</name> *</type><name>enc</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>ptr</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>end</name></decl></param>, <param><decl><type><name>POSITION</name> *</type><name>pos</name></decl></param>)</parameter_list> <block>{
<expr_stmt><expr><call><name>normal_updatePosition</name><argument_list>(<argument><expr>&amp;<name><name>utf8_encoding</name>.<name>enc</name></name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><name>pos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>toAscii</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>ENCODING</name> *</type><name>enc</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>ptr</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>end</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>char</name></type> <name><name>buf</name><index>[<expr>1</expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>p</name> <init>= <expr><name>buf</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>XmlUtf8Convert</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr>&amp;<name>ptr</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr>&amp;<name>p</name></expr></argument>, <argument><expr><name>p</name> + 1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>p</name> == <name>buf</name></expr>)</condition><then>
<return>return <expr>-1</expr>;</return></then>
<else>else
<return>return <expr><name><name>buf</name><index>[<expr>0</expr>]</index></name></expr>;</return></else></if>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name> <name>FASTCALL</name></type>
<name>isSpace</name><parameter_list>(<param><decl><type><name>int</name></type> <name>c</name></decl></param>)</parameter_list> <block>{
<switch>switch <condition>(<expr><name>c</name></expr>)</condition> <block>{
<case>case <expr>0x20</expr>:
</case><case>case <expr>0xD</expr>:
</case><case>case <expr>0xA</expr>:
</case><case>case <expr>0x9</expr>:
<return>return <expr>1</expr>;</return>
</case>}</block></switch>
<return>return <expr>0</expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>parsePseudoAttribute</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>ENCODING</name> *</type><name>enc</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>ptr</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>end</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> **</type><name>namePtr</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> **</type><name>nameEndPtr</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> **</type><name>valPtr</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> **</type><name>nextTokPtr</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>c</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name>open</name></decl>;</decl_stmt>
<if>if <condition>(<expr><name>ptr</name> == <name>end</name></expr>)</condition><then> <block>{
<expr_stmt><expr>*<name>namePtr</name> = <name>NULL</name></expr>;</expr_stmt>
<return>return <expr>1</expr>;</return>
}</block></then></if>
<if>if <condition>(<expr>!<call><name>isSpace</name><argument_list>(<argument><expr><call><name>toAscii</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>end</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr>*<name>nextTokPtr</name> = <name>ptr</name></expr>;</expr_stmt>
<return>return <expr>0</expr>;</return>
}</block></then></if>
<do>do <block>{
<expr_stmt><expr><name>ptr</name> += <name><name>enc</name>-&gt;<name>minBytesPerChar</name></name></expr>;</expr_stmt>
}</block> while <condition>(<expr><call><name>isSpace</name><argument_list>(<argument><expr><call><name>toAscii</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>end</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>;</do>
<if>if <condition>(<expr><name>ptr</name> == <name>end</name></expr>)</condition><then> <block>{
<expr_stmt><expr>*<name>namePtr</name> = <name>NULL</name></expr>;</expr_stmt>
<return>return <expr>1</expr>;</return>
}</block></then></if>
<expr_stmt><expr>*<name>namePtr</name> = <name>ptr</name></expr>;</expr_stmt>
<for>for (<init>;</init><condition>;</condition><incr/>) <block>{
<expr_stmt><expr><name>c</name> = <call><name>toAscii</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>c</name> == -1</expr>)</condition><then> <block>{
<expr_stmt><expr>*<name>nextTokPtr</name> = <name>ptr</name></expr>;</expr_stmt>
<return>return <expr>0</expr>;</return>
}</block></then></if>
<if>if <condition>(<expr><name>c</name> == <name>ASCII_EQUALS</name></expr>)</condition><then> <block>{
<expr_stmt><expr>*<name>nameEndPtr</name> = <name>ptr</name></expr>;</expr_stmt>
<break>break;</break>
}</block></then></if>
<if>if <condition>(<expr><call><name>isSpace</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr>*<name>nameEndPtr</name> = <name>ptr</name></expr>;</expr_stmt>
<do>do <block>{
<expr_stmt><expr><name>ptr</name> += <name><name>enc</name>-&gt;<name>minBytesPerChar</name></name></expr>;</expr_stmt>
}</block> while <condition>(<expr><call><name>isSpace</name><argument_list>(<argument><expr><name>c</name> = <call><name>toAscii</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>end</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>;</do>
<if>if <condition>(<expr><name>c</name> != <name>ASCII_EQUALS</name></expr>)</condition><then> <block>{
<expr_stmt><expr>*<name>nextTokPtr</name> = <name>ptr</name></expr>;</expr_stmt>
<return>return <expr>0</expr>;</return>
}</block></then></if>
<break>break;</break>
}</block></then></if>
<expr_stmt><expr><name>ptr</name> += <name><name>enc</name>-&gt;<name>minBytesPerChar</name></name></expr>;</expr_stmt>
}</block></for>
<if>if <condition>(<expr><name>ptr</name> == *<name>namePtr</name></expr>)</condition><then> <block>{
<expr_stmt><expr>*<name>nextTokPtr</name> = <name>ptr</name></expr>;</expr_stmt>
<return>return <expr>0</expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>ptr</name> += <name><name>enc</name>-&gt;<name>minBytesPerChar</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>c</name> = <call><name>toAscii</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<while>while <condition>(<expr><call><name>isSpace</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{
<expr_stmt><expr><name>ptr</name> += <name><name>enc</name>-&gt;<name>minBytesPerChar</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>c</name> = <call><name>toAscii</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></while>
<if>if <condition>(<expr><name>c</name> != <name>ASCII_QUOT</name> &amp;&amp; <name>c</name> != <name>ASCII_APOS</name></expr>)</condition><then> <block>{
<expr_stmt><expr>*<name>nextTokPtr</name> = <name>ptr</name></expr>;</expr_stmt>
<return>return <expr>0</expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>open</name> = (<name>char</name>)<name>c</name></expr>;</expr_stmt>
<expr_stmt><expr><name>ptr</name> += <name><name>enc</name>-&gt;<name>minBytesPerChar</name></name></expr>;</expr_stmt>
<expr_stmt><expr>*<name>valPtr</name> = <name>ptr</name></expr>;</expr_stmt>
<for>for (<init>;</init><condition>;</condition> <incr><expr><name>ptr</name> += <name><name>enc</name>-&gt;<name>minBytesPerChar</name></name></expr></incr>) <block>{
<expr_stmt><expr><name>c</name> = <call><name>toAscii</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>c</name> == <name>open</name></expr>)</condition><then>
<break>break;</break></then></if>
<if>if <condition>(<expr>!(<name>ASCII_a</name> &lt;= <name>c</name> &amp;&amp; <name>c</name> &lt;= <name>ASCII_z</name>)
&amp;&amp; !(<name>ASCII_A</name> &lt;= <name>c</name> &amp;&amp; <name>c</name> &lt;= <name>ASCII_Z</name>)
&amp;&amp; !(<name>ASCII_0</name> &lt;= <name>c</name> &amp;&amp; <name>c</name> &lt;= <name>ASCII_9</name>)
&amp;&amp; <name>c</name> != <name>ASCII_PERIOD</name>
&amp;&amp; <name>c</name> != <name>ASCII_MINUS</name>
&amp;&amp; <name>c</name> != <name>ASCII_UNDERSCORE</name></expr>)</condition><then> <block>{
<expr_stmt><expr>*<name>nextTokPtr</name> = <name>ptr</name></expr>;</expr_stmt>
<return>return <expr>0</expr>;</return>
}</block></then></if>
}</block></for>
<expr_stmt><expr>*<name>nextTokPtr</name> = <name>ptr</name> + <name><name>enc</name>-&gt;<name>minBytesPerChar</name></name></expr>;</expr_stmt>
<return>return <expr>1</expr>;</return>
}</block></function>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name></type> <name><name>KW_version</name><index>[]</index></name> <init>= <expr><block>{
<expr><name>ASCII_v</name></expr>, <expr><name>ASCII_e</name></expr>, <expr><name>ASCII_r</name></expr>, <expr><name>ASCII_s</name></expr>, <expr><name>ASCII_i</name></expr>, <expr><name>ASCII_o</name></expr>, <expr><name>ASCII_n</name></expr>, <expr>'\0'</expr>
}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name></type> <name><name>KW_encoding</name><index>[]</index></name> <init>= <expr><block>{
<expr><name>ASCII_e</name></expr>, <expr><name>ASCII_n</name></expr>, <expr><name>ASCII_c</name></expr>, <expr><name>ASCII_o</name></expr>, <expr><name>ASCII_d</name></expr>, <expr><name>ASCII_i</name></expr>, <expr><name>ASCII_n</name></expr>, <expr><name>ASCII_g</name></expr>, <expr>'\0'</expr>
}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name></type> <name><name>KW_standalone</name><index>[]</index></name> <init>= <expr><block>{
<expr><name>ASCII_s</name></expr>, <expr><name>ASCII_t</name></expr>, <expr><name>ASCII_a</name></expr>, <expr><name>ASCII_n</name></expr>, <expr><name>ASCII_d</name></expr>, <expr><name>ASCII_a</name></expr>, <expr><name>ASCII_l</name></expr>, <expr><name>ASCII_o</name></expr>,
<expr><name>ASCII_n</name></expr>, <expr><name>ASCII_e</name></expr>, <expr>'\0'</expr>
}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name></type> <name><name>KW_yes</name><index>[]</index></name> <init>= <expr><block>{
<expr><name>ASCII_y</name></expr>, <expr><name>ASCII_e</name></expr>, <expr><name>ASCII_s</name></expr>, <expr>'\0'</expr>
}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name></type> <name><name>KW_no</name><index>[]</index></name> <init>= <expr><block>{
<expr><name>ASCII_n</name></expr>, <expr><name>ASCII_o</name></expr>, <expr>'\0'</expr>
}</block></expr></init></decl>;</decl_stmt>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>doParseXmlDecl</name><parameter_list>(<param><function_decl><type><specifier>const</specifier> <name>ENCODING</name> *</type>(*<name>encodingFinder</name>)<parameter_list>(<param><decl><type><specifier>const</specifier></type> <name>ENCODING</name> *</decl></param>,
<param><decl><type><specifier>const</specifier></type> <name>char</name> *</decl></param>,
<param><decl><type><specifier>const</specifier></type> <name>char</name> *</decl></param>)</parameter_list></function_decl></param>,
<param><decl><type><name>int</name></type> <name>isGeneralTextEntity</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>ENCODING</name> *</type><name>enc</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>ptr</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>end</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> **</type><name>badPtr</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> **</type><name>versionPtr</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> **</type><name>versionEndPtr</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> **</type><name>encodingName</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>ENCODING</name> **</type><name>encoding</name></decl></param>,
<param><decl><type><name>int</name> *</type><name>standalone</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>val</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>name</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>nameEnd</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>ptr</name> += 5 * <name><name>enc</name>-&gt;<name>minBytesPerChar</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>end</name> -= 2 * <name><name>enc</name>-&gt;<name>minBytesPerChar</name></name></expr>;</expr_stmt>
<if>if <condition>(<expr>!<call><name>parsePseudoAttribute</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr>&amp;<name>name</name></expr></argument>, <argument><expr>&amp;<name>nameEnd</name></expr></argument>, <argument><expr>&amp;<name>val</name></expr></argument>, <argument><expr>&amp;<name>ptr</name></expr></argument>)</argument_list></call>
|| !<name>name</name></expr>)</condition><then> <block>{
<expr_stmt><expr>*<name>badPtr</name> = <name>ptr</name></expr>;</expr_stmt>
<return>return <expr>0</expr>;</return>
}</block></then></if>
<if>if <condition>(<expr>!<call><name>XmlNameMatchesAscii</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>nameEnd</name></expr></argument>, <argument><expr><name>KW_version</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<if>if <condition>(<expr>!<name>isGeneralTextEntity</name></expr>)</condition><then> <block>{
<expr_stmt><expr>*<name>badPtr</name> = <name>name</name></expr>;</expr_stmt>
<return>return <expr>0</expr>;</return>
}</block></then></if>
}</block></then> <else>else <block>{
<if>if <condition>(<expr><name>versionPtr</name></expr>)</condition><then>
<expr_stmt><expr>*<name>versionPtr</name> = <name>val</name></expr>;</expr_stmt></then></if>
<if>if <condition>(<expr><name>versionEndPtr</name></expr>)</condition><then>
<expr_stmt><expr>*<name>versionEndPtr</name> = <name>ptr</name></expr>;</expr_stmt></then></if>
<if>if <condition>(<expr>!<call><name>parsePseudoAttribute</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr>&amp;<name>name</name></expr></argument>, <argument><expr>&amp;<name>nameEnd</name></expr></argument>, <argument><expr>&amp;<name>val</name></expr></argument>, <argument><expr>&amp;<name>ptr</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr>*<name>badPtr</name> = <name>ptr</name></expr>;</expr_stmt>
<return>return <expr>0</expr>;</return>
}</block></then></if>
<if>if <condition>(<expr>!<name>name</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr><name>isGeneralTextEntity</name></expr>)</condition><then> <block>{
<expr_stmt><expr>*<name>badPtr</name> = <name>ptr</name></expr>;</expr_stmt>
<return>return <expr>0</expr>;</return>
}</block></then></if>
<return>return <expr>1</expr>;</return>
}</block></then></if>
}</block></else></if>
<if>if <condition>(<expr><call><name>XmlNameMatchesAscii</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>nameEnd</name></expr></argument>, <argument><expr><name>KW_encoding</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>c</name> <init>= <expr><call><name>toAscii</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>val</name></expr></argument>, <argument><expr><name>end</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr>!(<name>ASCII_a</name> &lt;= <name>c</name> &amp;&amp; <name>c</name> &lt;= <name>ASCII_z</name>) &amp;&amp; !(<name>ASCII_A</name> &lt;= <name>c</name> &amp;&amp; <name>c</name> &lt;= <name>ASCII_Z</name>)</expr>)</condition><then> <block>{
<expr_stmt><expr>*<name>badPtr</name> = <name>val</name></expr>;</expr_stmt>
<return>return <expr>0</expr>;</return>
}</block></then></if>
<if>if <condition>(<expr><name>encodingName</name></expr>)</condition><then>
<expr_stmt><expr>*<name>encodingName</name> = <name>val</name></expr>;</expr_stmt></then></if>
<if>if <condition>(<expr><name>encoding</name></expr>)</condition><then>
<expr_stmt><expr>*<name>encoding</name> = <call><name>encodingFinder</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>val</name></expr></argument>, <argument><expr><name>ptr</name> - <name><name>enc</name>-&gt;<name>minBytesPerChar</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<if>if <condition>(<expr>!<call><name>parsePseudoAttribute</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr>&amp;<name>name</name></expr></argument>, <argument><expr>&amp;<name>nameEnd</name></expr></argument>, <argument><expr>&amp;<name>val</name></expr></argument>, <argument><expr>&amp;<name>ptr</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr>*<name>badPtr</name> = <name>ptr</name></expr>;</expr_stmt>
<return>return <expr>0</expr>;</return>
}</block></then></if>
<if>if <condition>(<expr>!<name>name</name></expr>)</condition><then>
<return>return <expr>1</expr>;</return></then></if>
}</block></then></if>
<if>if <condition>(<expr>!<call><name>XmlNameMatchesAscii</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>nameEnd</name></expr></argument>, <argument><expr><name>KW_standalone</name></expr></argument>)</argument_list></call>
|| <name>isGeneralTextEntity</name></expr>)</condition><then> <block>{
<expr_stmt><expr>*<name>badPtr</name> = <name>name</name></expr>;</expr_stmt>
<return>return <expr>0</expr>;</return>
}</block></then></if>
<if>if <condition>(<expr><call><name>XmlNameMatchesAscii</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>val</name></expr></argument>, <argument><expr><name>ptr</name> - <name><name>enc</name>-&gt;<name>minBytesPerChar</name></name></expr></argument>, <argument><expr><name>KW_yes</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<if>if <condition>(<expr><name>standalone</name></expr>)</condition><then>
<expr_stmt><expr>*<name>standalone</name> = 1</expr>;</expr_stmt></then></if>
}</block></then> <else>else <if>if <condition>(<expr><call><name>XmlNameMatchesAscii</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>val</name></expr></argument>, <argument><expr><name>ptr</name> - <name><name>enc</name>-&gt;<name>minBytesPerChar</name></name></expr></argument>, <argument><expr><name>KW_no</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<if>if <condition>(<expr><name>standalone</name></expr>)</condition><then>
<expr_stmt><expr>*<name>standalone</name> = 0</expr>;</expr_stmt></then></if>
}</block></then> <else>else <block>{
<expr_stmt><expr>*<name>badPtr</name> = <name>val</name></expr>;</expr_stmt>
<return>return <expr>0</expr>;</return>
}</block></else></if></else></if>
<while>while <condition>(<expr><call><name>isSpace</name><argument_list>(<argument><expr><call><name>toAscii</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>end</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
<expr_stmt><expr><name>ptr</name> += <name><name>enc</name>-&gt;<name>minBytesPerChar</name></name></expr>;</expr_stmt></while>
<if>if <condition>(<expr><name>ptr</name> != <name>end</name></expr>)</condition><then> <block>{
<expr_stmt><expr>*<name>badPtr</name> = <name>ptr</name></expr>;</expr_stmt>
<return>return <expr>0</expr>;</return>
}</block></then></if>
<return>return <expr>1</expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name> <name>FASTCALL</name></type>
<name>checkCharRefNumber</name><parameter_list>(<param><decl><type><name>int</name></type> <name>result</name></decl></param>)</parameter_list> <block>{
<switch>switch <condition>(<expr><name>result</name> &gt;&gt; 8</expr>)</condition> <block>{
<case>case <expr>0xD8</expr>:
</case><case>case <expr>0xD9</expr>:
</case><case>case <expr>0xDA</expr>:
</case><case>case <expr>0xDB</expr>:
</case><case>case <expr>0xDC</expr>:
</case><case>case <expr>0xDD</expr>:
</case><case>case <expr>0xDE</expr>:
</case><case>case <expr>0xDF</expr>:
<return>return <expr>-1</expr>;</return>
</case><case>case <expr>0</expr>:
<if>if <condition>(<expr><name><name>latin1_encoding</name>.<name>type</name><index>[<expr><name>result</name></expr>]</index></name> == <name>BT_NONXML</name></expr>)</condition><then>
<return>return <expr>-1</expr>;</return></then></if>
<break>break;</break>
</case><case>case <expr>0xFF</expr>:
<if>if <condition>(<expr><name>result</name> == 0xFFFE || <name>result</name> == 0xFFFF</expr>)</condition><then>
<return>return <expr>-1</expr>;</return></then></if>
<break>break;</break>
</case>}</block></switch>
<return>return <expr><name>result</name></expr>;</return>
}</block></function>
<function><type><name>int</name> <name>FASTCALL</name></type>
<name>XmlUtf8Encode</name><parameter_list>(<param><decl><type><name>int</name></type> <name>c</name></decl></param>, <param><decl><type><name>char</name> *</type><name>buf</name></decl></param>)</parameter_list> <block>{
<enum>enum <block>{
<decl><name>min2</name> <init>= <expr>0x80</expr></init></decl>,
<decl><name>min3</name> <init>= <expr>0x800</expr></init></decl>,
<decl><name>min4</name> <init>= <expr>0x10000</expr></init></decl>
}</block>;</enum>
<if>if <condition>(<expr><name>c</name> &lt; 0</expr>)</condition><then>
<return>return <expr>0</expr>;</return></then></if>
<if>if <condition>(<expr><name>c</name> &lt; <name>min2</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>buf</name><index>[<expr>0</expr>]</index></name> = <call>(<name>char</name>)<argument_list>(<argument><expr><name>c</name> | <name>UTF8_cval1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>1</expr>;</return>
}</block></then></if>
<if>if <condition>(<expr><name>c</name> &lt; <name>min3</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>buf</name><index>[<expr>0</expr>]</index></name> = <call>(<name>char</name>)<argument_list>(<argument><expr>(<name>c</name> &gt;&gt; 6) | <name>UTF8_cval2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>buf</name><index>[<expr>1</expr>]</index></name> = <call>(<name>char</name>)<argument_list>(<argument><expr>(<name>c</name> &amp; 0x3f) | 0x80</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>2</expr>;</return>
}</block></then></if>
<if>if <condition>(<expr><name>c</name> &lt; <name>min4</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>buf</name><index>[<expr>0</expr>]</index></name> = <call>(<name>char</name>)<argument_list>(<argument><expr>(<name>c</name> &gt;&gt; 12) | <name>UTF8_cval3</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>buf</name><index>[<expr>1</expr>]</index></name> = <call>(<name>char</name>)<argument_list>(<argument><expr>((<name>c</name> &gt;&gt; 6) &amp; 0x3f) | 0x80</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>buf</name><index>[<expr>2</expr>]</index></name> = <call>(<name>char</name>)<argument_list>(<argument><expr>(<name>c</name> &amp; 0x3f) | 0x80</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>3</expr>;</return>
}</block></then></if>
<if>if <condition>(<expr><name>c</name> &lt; 0x110000</expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>buf</name><index>[<expr>0</expr>]</index></name> = <call>(<name>char</name>)<argument_list>(<argument><expr>(<name>c</name> &gt;&gt; 18) | <name>UTF8_cval4</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>buf</name><index>[<expr>1</expr>]</index></name> = <call>(<name>char</name>)<argument_list>(<argument><expr>((<name>c</name> &gt;&gt; 12) &amp; 0x3f) | 0x80</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>buf</name><index>[<expr>2</expr>]</index></name> = <call>(<name>char</name>)<argument_list>(<argument><expr>((<name>c</name> &gt;&gt; 6) &amp; 0x3f) | 0x80</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>buf</name><index>[<expr>3</expr>]</index></name> = <call>(<name>char</name>)<argument_list>(<argument><expr>(<name>c</name> &amp; 0x3f) | 0x80</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>4</expr>;</return>
}</block></then></if>
<return>return <expr>0</expr>;</return>
}</block></function>
<function><type><name>int</name> <name>FASTCALL</name></type>
<name>XmlUtf16Encode</name><parameter_list>(<param><decl><type><name>int</name></type> <name>charNum</name></decl></param>, <param><decl><type><name>unsigned</name> <name>short</name> *</type><name>buf</name></decl></param>)</parameter_list> <block>{
<if>if <condition>(<expr><name>charNum</name> &lt; 0</expr>)</condition><then>
<return>return <expr>0</expr>;</return></then></if>
<if>if <condition>(<expr><name>charNum</name> &lt; 0x10000</expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>buf</name><index>[<expr>0</expr>]</index></name> = (<name>unsigned</name> <name>short</name>)<name>charNum</name></expr>;</expr_stmt>
<return>return <expr>1</expr>;</return>
}</block></then></if>
<if>if <condition>(<expr><name>charNum</name> &lt; 0x110000</expr>)</condition><then> <block>{
<expr_stmt><expr><name>charNum</name> -= 0x10000</expr>;</expr_stmt>
<expr_stmt><expr><name><name>buf</name><index>[<expr>0</expr>]</index></name> = <call>(<name>unsigned</name> <name>short</name>)<argument_list>(<argument><expr>(<name>charNum</name> &gt;&gt; 10) + 0xD800</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>buf</name><index>[<expr>1</expr>]</index></name> = <call>(<name>unsigned</name> <name>short</name>)<argument_list>(<argument><expr>(<name>charNum</name> &amp; 0x3FF) + 0xDC00</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>2</expr>;</return>
}</block></then></if>
<return>return <expr>0</expr>;</return>
}</block></function>
<struct>struct <name>unknown_encoding</name> <block>{
<decl_stmt><decl><type>struct <name>normal_encoding</name></type> <name>normal</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>CONVERTER</name></type> <name>convert</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>void</name> *</type><name>userData</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>short</name></type> <name><name>utf16</name><index>[<expr>256</expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name><name>utf8</name><index>[<expr>256</expr>]</index><index>[<expr>4</expr>]</index></name></decl>;</decl_stmt>
}</block>;</struct>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AS_UNKNOWN_ENCODING</name><parameter_list>(<param><type><name>enc</name></type></param>)</parameter_list></cpp:macro> <cpp:value>((const struct unknown_encoding *) (enc))</cpp:value></cpp:define>
<function><type><name>int</name></type>
<name>XmlSizeOfUnknownEncoding</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list> <block>{
<return>return <expr><sizeof>sizeof<argument_list>(<argument>struct <expr><name>unknown_encoding</name></expr></argument>)</argument_list></sizeof></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name> <name>PTRFASTCALL</name></type>
<name>unknown_isName</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>ENCODING</name> *</type><name>enc</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>p</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><specifier>const</specifier> struct <name>unknown_encoding</name> *</type><name>uenc</name> <init>= <expr><call><name>AS_UNKNOWN_ENCODING</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>c</name> <init>= <expr><call><name><name>uenc</name>-&gt;<name>convert</name></name><argument_list>(<argument><expr><name><name>uenc</name>-&gt;<name>userData</name></name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>c</name> &amp; ~0xFFFF</expr>)</condition><then>
<return>return <expr>0</expr>;</return></then></if>
<return>return <expr><call><name>UCS2_GET_NAMING</name><argument_list>(<argument><expr><name>namePages</name></expr></argument>, <argument><expr><name>c</name> &gt;&gt; 8</expr></argument>, <argument><expr><name>c</name> &amp; 0xFF</expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name> <name>PTRFASTCALL</name></type>
<name>unknown_isNmstrt</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>ENCODING</name> *</type><name>enc</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>p</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><specifier>const</specifier> struct <name>unknown_encoding</name> *</type><name>uenc</name> <init>= <expr><call><name>AS_UNKNOWN_ENCODING</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>c</name> <init>= <expr><call><name><name>uenc</name>-&gt;<name>convert</name></name><argument_list>(<argument><expr><name><name>uenc</name>-&gt;<name>userData</name></name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>c</name> &amp; ~0xFFFF</expr>)</condition><then>
<return>return <expr>0</expr>;</return></then></if>
<return>return <expr><call><name>UCS2_GET_NAMING</name><argument_list>(<argument><expr><name>nmstrtPages</name></expr></argument>, <argument><expr><name>c</name> &gt;&gt; 8</expr></argument>, <argument><expr><name>c</name> &amp; 0xFF</expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name> <name>PTRFASTCALL</name></type>
<name>unknown_isInvalid</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>ENCODING</name> *</type><name>enc</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>p</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><specifier>const</specifier> struct <name>unknown_encoding</name> *</type><name>uenc</name> <init>= <expr><call><name>AS_UNKNOWN_ENCODING</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>c</name> <init>= <expr><call><name><name>uenc</name>-&gt;<name>convert</name></name><argument_list>(<argument><expr><name><name>uenc</name>-&gt;<name>userData</name></name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<return>return <expr>(<name>c</name> &amp; ~0xFFFF) || <call><name>checkCharRefNumber</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call> &lt; 0</expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>void</name> <name>PTRCALL</name></type>
<name>unknown_toUtf8</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>ENCODING</name> *</type><name>enc</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> **</type><name>fromP</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>fromLim</name></decl></param>,
<param><decl><type><name>char</name> **</type><name>toP</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>toLim</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><specifier>const</specifier> struct <name>unknown_encoding</name> *</type><name>uenc</name> <init>= <expr><call><name>AS_UNKNOWN_ENCODING</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name><name>buf</name><index>[<expr><name>XML_UTF8_ENCODE_MAX</name></expr>]</index></name></decl>;</decl_stmt>
<for>for (<init>;</init><condition>;</condition><incr/>) <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>utf8</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>;</decl_stmt>
<if>if <condition>(<expr>*<name>fromP</name> == <name>fromLim</name></expr>)</condition><then>
<break>break;</break></then></if>
<expr_stmt><expr><name>utf8</name> = <name><name>uenc</name>-&gt;<name>utf8</name><index>[<expr>(<name>unsigned</name> <name>char</name>)**<name>fromP</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name>n</name> = *<name>utf8</name>++</expr>;</expr_stmt>
<if>if <condition>(<expr><name>n</name> == 0</expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>c</name> <init>= <expr><call><name><name>uenc</name>-&gt;<name>convert</name></name><argument_list>(<argument><expr><name><name>uenc</name>-&gt;<name>userData</name></name></expr></argument>, <argument><expr>*<name>fromP</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>n</name> = <call><name>XmlUtf8Encode</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>n</name> &gt; <name>toLim</name> - *<name>toP</name></expr>)</condition><then>
<break>break;</break></then></if>
<expr_stmt><expr><name>utf8</name> = <name>buf</name></expr>;</expr_stmt>
<expr_stmt><expr>*<name>fromP</name> += (<call><name>AS_NORMAL_ENCODING</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call>-&gt;<name><name>type</name><index>[<expr>(<name>unsigned</name> <name>char</name>)**<name>fromP</name></expr>]</index></name>
- (<name>BT_LEAD2</name> - 2))</expr>;</expr_stmt>
}</block></then> <else>else <block>{
<if>if <condition>(<expr><name>n</name> &gt; <name>toLim</name> - *<name>toP</name></expr>)</condition><then>
<break>break;</break></then></if>
<expr_stmt><expr>(*<name>fromP</name>)++</expr>;</expr_stmt>
}</block></else></if>
<do>do <block>{
<expr_stmt><expr>*(*<name>toP</name>)++ = *<name>utf8</name>++</expr>;</expr_stmt>
}</block> while <condition>(<expr>--<name>n</name> != 0</expr>)</condition>;</do>
}</block></for>
}</block></function>
<function><type><specifier>static</specifier> <name>void</name> <name>PTRCALL</name></type>
<name>unknown_toUtf16</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>ENCODING</name> *</type><name>enc</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> **</type><name>fromP</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>fromLim</name></decl></param>,
<param><decl><type><name>unsigned</name> <name>short</name> **</type><name>toP</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>unsigned</name> <name>short</name> *</type><name>toLim</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><specifier>const</specifier> struct <name>unknown_encoding</name> *</type><name>uenc</name> <init>= <expr><call><name>AS_UNKNOWN_ENCODING</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<while>while <condition>(<expr>*<name>fromP</name> != <name>fromLim</name> &amp;&amp; *<name>toP</name> != <name>toLim</name></expr>)</condition> <block>{
<decl_stmt><decl><type><name>unsigned</name> <name>short</name></type> <name>c</name> <init>= <expr><name><name>uenc</name>-&gt;<name>utf16</name><index>[<expr>(<name>unsigned</name> <name>char</name>)**<name>fromP</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>c</name> == 0</expr>)</condition><then> <block>{
<expr_stmt><expr><name>c</name> = (<name>unsigned</name> <name>short</name>)
<call><name><name>uenc</name>-&gt;<name>convert</name></name><argument_list>(<argument><expr><name><name>uenc</name>-&gt;<name>userData</name></name></expr></argument>, <argument><expr>*<name>fromP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr>*<name>fromP</name> += (<call><name>AS_NORMAL_ENCODING</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call>-&gt;<name><name>type</name><index>[<expr>(<name>unsigned</name> <name>char</name>)**<name>fromP</name></expr>]</index></name>
- (<name>BT_LEAD2</name> - 2))</expr>;</expr_stmt>
}</block></then> <else>else
<expr_stmt><expr>(*<name>fromP</name>)++</expr>;</expr_stmt></else></if>
<expr_stmt><expr>*(*<name>toP</name>)++ = <name>c</name></expr>;</expr_stmt>
}</block></while>
}</block></function>
<function><type><name>ENCODING</name> *</type>
<name>XmlInitUnknownEncoding</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>mem</name></decl></param>,
<param><decl><type><name>int</name> *</type><name>table</name></decl></param>,
<param><decl><type><name>CONVERTER</name></type> <name>convert</name></decl></param>,
<param><decl><type><name>void</name> *</type><name>userData</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type>struct <name>unknown_encoding</name> *</type><name>e</name> <init>= <expr>(struct <name>unknown_encoding</name> *)<name>mem</name></expr></init></decl>;</decl_stmt>
<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; (<name>int</name>)<sizeof>sizeof<argument_list>(<argument>struct <expr><name>normal_encoding</name></expr></argument>)</argument_list></sizeof></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
<expr_stmt><expr>((<name>char</name> *)<name>mem</name>)<index>[<expr><name>i</name></expr>]</index> = ((<name>char</name> *)&amp;<name>latin1_encoding</name>)<index>[<expr><name>i</name></expr>]</index></expr>;</expr_stmt></for>
<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; 128</expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
<if>if <condition>(<expr><name><name>latin1_encoding</name>.<name>type</name><index>[<expr><name>i</name></expr>]</index></name> != <name>BT_OTHER</name>
&amp;&amp; <name><name>latin1_encoding</name>.<name>type</name><index>[<expr><name>i</name></expr>]</index></name> != <name>BT_NONXML</name>
&amp;&amp; <name><name>table</name><index>[<expr><name>i</name></expr>]</index></name> != <name>i</name></expr>)</condition><then>
<return>return <expr>0</expr>;</return></then></if></for>
<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; 256</expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
<decl_stmt><decl><type><name>int</name></type> <name>c</name> <init>= <expr><name><name>table</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>c</name> == -1</expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>e</name>-&gt;<name>normal</name>.<name>type</name><index>[<expr><name>i</name></expr>]</index></name> = <name>BT_MALFORM</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>e</name>-&gt;<name>utf16</name><index>[<expr><name>i</name></expr>]</index></name> = 0xFFFF</expr>;</expr_stmt>
<expr_stmt><expr><name><name>e</name>-&gt;<name>utf8</name><index>[<expr><name>i</name></expr>]</index><index>[<expr>0</expr>]</index></name> = 1</expr>;</expr_stmt>
<expr_stmt><expr><name><name>e</name>-&gt;<name>utf8</name><index>[<expr><name>i</name></expr>]</index><index>[<expr>1</expr>]</index></name> = 0</expr>;</expr_stmt>
}</block></then> <else>else <if>if <condition>(<expr><name>c</name> &lt; 0</expr>)</condition><then> <block>{
<if>if <condition>(<expr><name>c</name> &lt; -4</expr>)</condition><then>
<return>return <expr>0</expr>;</return></then></if>
<expr_stmt><expr><name><name>e</name>-&gt;<name>normal</name>.<name>type</name><index>[<expr><name>i</name></expr>]</index></name> = <call>(<name>unsigned</name> <name>char</name>)<argument_list>(<argument><expr><name>BT_LEAD2</name> - (<name>c</name> + 2)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>e</name>-&gt;<name>utf8</name><index>[<expr><name>i</name></expr>]</index><index>[<expr>0</expr>]</index></name> = 0</expr>;</expr_stmt>
<expr_stmt><expr><name><name>e</name>-&gt;<name>utf16</name><index>[<expr><name>i</name></expr>]</index></name> = 0</expr>;</expr_stmt>
}</block></then> <else>else <if>if <condition>(<expr><name>c</name> &lt; 0x80</expr>)</condition><then> <block>{
<if>if <condition>(<expr><name><name>latin1_encoding</name>.<name>type</name><index>[<expr><name>c</name></expr>]</index></name> != <name>BT_OTHER</name>
&amp;&amp; <name><name>latin1_encoding</name>.<name>type</name><index>[<expr><name>c</name></expr>]</index></name> != <name>BT_NONXML</name>
&amp;&amp; <name>c</name> != <name>i</name></expr>)</condition><then>
<return>return <expr>0</expr>;</return></then></if>
<expr_stmt><expr><name><name>e</name>-&gt;<name>normal</name>.<name>type</name><index>[<expr><name>i</name></expr>]</index></name> = <name><name>latin1_encoding</name>.<name>type</name><index>[<expr><name>c</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>e</name>-&gt;<name>utf8</name><index>[<expr><name>i</name></expr>]</index><index>[<expr>0</expr>]</index></name> = 1</expr>;</expr_stmt>
<expr_stmt><expr><name><name>e</name>-&gt;<name>utf8</name><index>[<expr><name>i</name></expr>]</index><index>[<expr>1</expr>]</index></name> = (<name>char</name>)<name>c</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>e</name>-&gt;<name>utf16</name><index>[<expr><name>i</name></expr>]</index></name> = <call>(<name>unsigned</name> <name>short</name>)<argument_list>(<argument><expr><name>c</name> == 0 ? 0xFFFF : <name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else <if>if <condition>(<expr><call><name>checkCharRefNumber</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>e</name>-&gt;<name>normal</name>.<name>type</name><index>[<expr><name>i</name></expr>]</index></name> = <name>BT_NONXML</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>e</name>-&gt;<name>utf16</name><index>[<expr><name>i</name></expr>]</index></name> = 0xFFFF</expr>;</expr_stmt>
<expr_stmt><expr><name><name>e</name>-&gt;<name>utf8</name><index>[<expr><name>i</name></expr>]</index><index>[<expr>0</expr>]</index></name> = 1</expr>;</expr_stmt>
<expr_stmt><expr><name><name>e</name>-&gt;<name>utf8</name><index>[<expr><name>i</name></expr>]</index><index>[<expr>1</expr>]</index></name> = 0</expr>;</expr_stmt>
}</block></then> <else>else <block>{
<if>if <condition>(<expr><name>c</name> &gt; 0xFFFF</expr>)</condition><then>
<return>return <expr>0</expr>;</return></then></if>
<if>if <condition>(<expr><call><name>UCS2_GET_NAMING</name><argument_list>(<argument><expr><name>nmstrtPages</name></expr></argument>, <argument><expr><name>c</name> &gt;&gt; 8</expr></argument>, <argument><expr><name>c</name> &amp; 0xff</expr></argument>)</argument_list></call></expr>)</condition><then>
<expr_stmt><expr><name><name>e</name>-&gt;<name>normal</name>.<name>type</name><index>[<expr><name>i</name></expr>]</index></name> = <name>BT_NMSTRT</name></expr>;</expr_stmt></then>
<else>else <if>if <condition>(<expr><call><name>UCS2_GET_NAMING</name><argument_list>(<argument><expr><name>namePages</name></expr></argument>, <argument><expr><name>c</name> &gt;&gt; 8</expr></argument>, <argument><expr><name>c</name> &amp; 0xff</expr></argument>)</argument_list></call></expr>)</condition><then>
<expr_stmt><expr><name><name>e</name>-&gt;<name>normal</name>.<name>type</name><index>[<expr><name>i</name></expr>]</index></name> = <name>BT_NAME</name></expr>;</expr_stmt></then>
<else>else
<expr_stmt><expr><name><name>e</name>-&gt;<name>normal</name>.<name>type</name><index>[<expr><name>i</name></expr>]</index></name> = <name>BT_OTHER</name></expr>;</expr_stmt></else></if></else></if>
<expr_stmt><expr><name><name>e</name>-&gt;<name>utf8</name><index>[<expr><name>i</name></expr>]</index><index>[<expr>0</expr>]</index></name> = (<name>char</name>)<call><name>XmlUtf8Encode</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name><name>e</name>-&gt;<name>utf8</name><index>[<expr><name>i</name></expr>]</index></name> + 1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>e</name>-&gt;<name>utf16</name><index>[<expr><name>i</name></expr>]</index></name> = (<name>unsigned</name> <name>short</name>)<name>c</name></expr>;</expr_stmt>
}</block></else></if></else></if></else></if></else></if>
}</block></for>
<expr_stmt><expr><name><name>e</name>-&gt;<name>userData</name></name> = <name>userData</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>e</name>-&gt;<name>convert</name></name> = <name>convert</name></expr>;</expr_stmt>
<if>if <condition>(<expr><name>convert</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>e</name>-&gt;<name>normal</name>.<name>isName2</name></name> = <name>unknown_isName</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>e</name>-&gt;<name>normal</name>.<name>isName3</name></name> = <name>unknown_isName</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>e</name>-&gt;<name>normal</name>.<name>isName4</name></name> = <name>unknown_isName</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>e</name>-&gt;<name>normal</name>.<name>isNmstrt2</name></name> = <name>unknown_isNmstrt</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>e</name>-&gt;<name>normal</name>.<name>isNmstrt3</name></name> = <name>unknown_isNmstrt</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>e</name>-&gt;<name>normal</name>.<name>isNmstrt4</name></name> = <name>unknown_isNmstrt</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>e</name>-&gt;<name>normal</name>.<name>isInvalid2</name></name> = <name>unknown_isInvalid</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>e</name>-&gt;<name>normal</name>.<name>isInvalid3</name></name> = <name>unknown_isInvalid</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>e</name>-&gt;<name>normal</name>.<name>isInvalid4</name></name> = <name>unknown_isInvalid</name></expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><name><name>e</name>-&gt;<name>normal</name>.<name>enc</name>.<name>utf8Convert</name></name> = <name>unknown_toUtf8</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>e</name>-&gt;<name>normal</name>.<name>enc</name>.<name>utf16Convert</name></name> = <name>unknown_toUtf16</name></expr>;</expr_stmt>
<return>return <expr>&amp;(<name><name>e</name>-&gt;<name>normal</name>.<name>enc</name></name>)</expr>;</return>
}</block></function>
<enum>enum <block>{
<decl><name>UNKNOWN_ENC</name> <init>= <expr>-1</expr></init></decl>,
<decl><name>ISO_8859_1_ENC</name> <init>= <expr>0</expr></init></decl>,
<decl><name>US_ASCII_ENC</name></decl>,
<decl><name>UTF_8_ENC</name></decl>,
<decl><name>UTF_16_ENC</name></decl>,
<decl><name>UTF_16BE_ENC</name></decl>,
<decl><name>UTF_16LE_ENC</name></decl>,
<decl><name>NO_ENC</name></decl>
}</block>;</enum>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name></type> <name><name>KW_ISO_8859_1</name><index>[]</index></name> <init>= <expr><block>{
<expr><name>ASCII_I</name></expr>, <expr><name>ASCII_S</name></expr>, <expr><name>ASCII_O</name></expr>, <expr><name>ASCII_MINUS</name></expr>, <expr><name>ASCII_8</name></expr>, <expr><name>ASCII_8</name></expr>, <expr><name>ASCII_5</name></expr>, <expr><name>ASCII_9</name></expr>,
<expr><name>ASCII_MINUS</name></expr>, <expr><name>ASCII_1</name></expr>, <expr>'\0'</expr>
}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name></type> <name><name>KW_US_ASCII</name><index>[]</index></name> <init>= <expr><block>{
<expr><name>ASCII_U</name></expr>, <expr><name>ASCII_S</name></expr>, <expr><name>ASCII_MINUS</name></expr>, <expr><name>ASCII_A</name></expr>, <expr><name>ASCII_S</name></expr>, <expr><name>ASCII_C</name></expr>, <expr><name>ASCII_I</name></expr>, <expr><name>ASCII_I</name></expr>,
<expr>'\0'</expr>
}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name></type> <name><name>KW_UTF_8</name><index>[]</index></name> <init>= <expr><block>{
<expr><name>ASCII_U</name></expr>, <expr><name>ASCII_T</name></expr>, <expr><name>ASCII_F</name></expr>, <expr><name>ASCII_MINUS</name></expr>, <expr><name>ASCII_8</name></expr>, <expr>'\0'</expr>
}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name></type> <name><name>KW_UTF_16</name><index>[]</index></name> <init>= <expr><block>{
<expr><name>ASCII_U</name></expr>, <expr><name>ASCII_T</name></expr>, <expr><name>ASCII_F</name></expr>, <expr><name>ASCII_MINUS</name></expr>, <expr><name>ASCII_1</name></expr>, <expr><name>ASCII_6</name></expr>, <expr>'\0'</expr>
}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name></type> <name><name>KW_UTF_16BE</name><index>[]</index></name> <init>= <expr><block>{
<expr><name>ASCII_U</name></expr>, <expr><name>ASCII_T</name></expr>, <expr><name>ASCII_F</name></expr>, <expr><name>ASCII_MINUS</name></expr>, <expr><name>ASCII_1</name></expr>, <expr><name>ASCII_6</name></expr>, <expr><name>ASCII_B</name></expr>, <expr><name>ASCII_E</name></expr>,
<expr>'\0'</expr>
}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name></type> <name><name>KW_UTF_16LE</name><index>[]</index></name> <init>= <expr><block>{
<expr><name>ASCII_U</name></expr>, <expr><name>ASCII_T</name></expr>, <expr><name>ASCII_F</name></expr>, <expr><name>ASCII_MINUS</name></expr>, <expr><name>ASCII_1</name></expr>, <expr><name>ASCII_6</name></expr>, <expr><name>ASCII_L</name></expr>, <expr><name>ASCII_E</name></expr>,
<expr>'\0'</expr>
}</block></expr></init></decl>;</decl_stmt>
<function><type><specifier>static</specifier> <name>int</name> <name>FASTCALL</name></type>
<name>getEncodingIndex</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>name</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> * <specifier>const</specifier></type> <name><name>encodingNames</name><index>[]</index></name> <init>= <expr><block>{
<expr><name>KW_ISO_8859_1</name></expr>,
<expr><name>KW_US_ASCII</name></expr>,
<expr><name>KW_UTF_8</name></expr>,
<expr><name>KW_UTF_16</name></expr>,
<expr><name>KW_UTF_16BE</name></expr>,
<expr><name>KW_UTF_16LE</name></expr>,
}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<if>if <condition>(<expr><name>name</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>NO_ENC</name></expr>;</return></then></if>
<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <call>(<name>int</name>)<argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>encodingNames</name></expr></argument>)</argument_list></sizeof>/<sizeof>sizeof<argument_list>(<argument><expr><name><name>encodingNames</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
<if>if <condition>(<expr><call><name>streqci</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name><name>encodingNames</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>i</name></expr>;</return></then></if></for>
<return>return <expr><name>UNKNOWN_ENC</name></expr>;</return>
}</block></function>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INIT_ENC_INDEX</name><parameter_list>(<param><type><name>enc</name></type></param>)</parameter_list></cpp:macro> <cpp:value>((int)(enc)-&gt;initEnc.isUtf16)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SET_INIT_ENC_INDEX</name><parameter_list>(<param><type><name>enc</name></type></param>, <param><type><name>i</name></type></param>)</parameter_list></cpp:macro> <cpp:value>((enc)-&gt;initEnc.isUtf16 = (char)i)</cpp:value></cpp:define>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>initScan</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>ENCODING</name> * <specifier>const</specifier> *</type><name>encodingTable</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>INIT_ENCODING</name> *</type><name>enc</name></decl></param>,
<param><decl><type><name>int</name></type> <name>state</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>ptr</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>end</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> **</type><name>nextTokPtr</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>ENCODING</name> **</type><name>encPtr</name></decl>;</decl_stmt>
<if>if <condition>(<expr><name>ptr</name> == <name>end</name></expr>)</condition><then>
<return>return <expr><name>XML_TOK_NONE</name></expr>;</return></then></if>
<expr_stmt><expr><name>encPtr</name> = <name><name>enc</name>-&gt;<name>encPtr</name></name></expr>;</expr_stmt>
<if>if <condition>(<expr><name>ptr</name> + 1 == <name>end</name></expr>)</condition><then> <block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>XML_DTD</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if>if <condition>(<expr><name>state</name> != <name>XML_CONTENT_STATE</name></expr>)</condition><then>
<return>return <expr><name>XML_TOK_PARTIAL</name></expr>;</return></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<switch>switch <condition>(<expr><call><name>INIT_ENC_INDEX</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{
<case>case <expr><name>UTF_16_ENC</name></expr>:
</case><case>case <expr><name>UTF_16LE_ENC</name></expr>:
</case><case>case <expr><name>UTF_16BE_ENC</name></expr>:
<return>return <expr><name>XML_TOK_PARTIAL</name></expr>;</return>
</case>}</block></switch>
<switch>switch <condition>(<expr>(<name>unsigned</name> <name>char</name>)*<name>ptr</name></expr>)</condition> <block>{
<case>case <expr>0xFE</expr>:
</case><case>case <expr>0xFF</expr>:
</case><case>case <expr>0xEF</expr>:
<if>if <condition>(<expr><call><name>INIT_ENC_INDEX</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call> == <name>ISO_8859_1_ENC</name>
&amp;&amp; <name>state</name> == <name>XML_CONTENT_STATE</name></expr>)</condition><then>
<break>break;</break></then></if>
</case><case>case <expr>0x00</expr>:
</case><case>case <expr>0x3C</expr>:
<return>return <expr><name>XML_TOK_PARTIAL</name></expr>;</return>
</case>}</block></switch>
}</block></then> <else>else <block>{
<switch>switch <condition>(<expr>((<name>unsigned</name> <name>char</name>)<name><name>ptr</name><index>[<expr>0</expr>]</index></name> &lt;&lt; 8) | (<name>unsigned</name> <name>char</name>)<name><name>ptr</name><index>[<expr>1</expr>]</index></name></expr>)</condition> <block>{
<case>case <expr>0xFEFF</expr>:
<if>if <condition>(<expr><call><name>INIT_ENC_INDEX</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call> == <name>ISO_8859_1_ENC</name>
&amp;&amp; <name>state</name> == <name>XML_CONTENT_STATE</name></expr>)</condition><then>
<break>break;</break></then></if>
<expr_stmt><expr>*<name>nextTokPtr</name> = <name>ptr</name> + 2</expr>;</expr_stmt>
<expr_stmt><expr>*<name>encPtr</name> = <name><name>encodingTable</name><index>[<expr><name>UTF_16BE_ENC</name></expr>]</index></name></expr>;</expr_stmt>
<return>return <expr><name>XML_TOK_BOM</name></expr>;</return>
</case><case>case <expr>0x3C00</expr>:
<if>if <condition>(<expr>(<call><name>INIT_ENC_INDEX</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call> == <name>UTF_16BE_ENC</name>
|| <call><name>INIT_ENC_INDEX</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call> == <name>UTF_16_ENC</name>)
&amp;&amp; <name>state</name> == <name>XML_CONTENT_STATE</name></expr>)</condition><then>
<break>break;</break></then></if>
<expr_stmt><expr>*<name>encPtr</name> = <name><name>encodingTable</name><index>[<expr><name>UTF_16LE_ENC</name></expr>]</index></name></expr>;</expr_stmt>
<return>return <expr><call><name>XmlTok</name><argument_list>(<argument><expr>*<name>encPtr</name></expr></argument>, <argument><expr><name>state</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><name>nextTokPtr</name></expr></argument>)</argument_list></call></expr>;</return>
</case><case>case <expr>0xFFFE</expr>:
<if>if <condition>(<expr><call><name>INIT_ENC_INDEX</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call> == <name>ISO_8859_1_ENC</name>
&amp;&amp; <name>state</name> == <name>XML_CONTENT_STATE</name></expr>)</condition><then>
<break>break;</break></then></if>
<expr_stmt><expr>*<name>nextTokPtr</name> = <name>ptr</name> + 2</expr>;</expr_stmt>
<expr_stmt><expr>*<name>encPtr</name> = <name><name>encodingTable</name><index>[<expr><name>UTF_16LE_ENC</name></expr>]</index></name></expr>;</expr_stmt>
<return>return <expr><name>XML_TOK_BOM</name></expr>;</return>
</case><case>case <expr>0xEFBB</expr>:
<if>if <condition>(<expr><name>state</name> == <name>XML_CONTENT_STATE</name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>e</name> <init>= <expr><call><name>INIT_ENC_INDEX</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>e</name> == <name>ISO_8859_1_ENC</name> || <name>e</name> == <name>UTF_16BE_ENC</name>
|| <name>e</name> == <name>UTF_16LE_ENC</name> || <name>e</name> == <name>UTF_16_ENC</name></expr>)</condition><then>
<break>break;</break></then></if>
}</block></then></if>
<if>if <condition>(<expr><name>ptr</name> + 2 == <name>end</name></expr>)</condition><then>
<return>return <expr><name>XML_TOK_PARTIAL</name></expr>;</return></then></if>
<if>if <condition>(<expr>(<name>unsigned</name> <name>char</name>)<name><name>ptr</name><index>[<expr>2</expr>]</index></name> == 0xBF</expr>)</condition><then> <block>{
<expr_stmt><expr>*<name>nextTokPtr</name> = <name>ptr</name> + 3</expr>;</expr_stmt>
<expr_stmt><expr>*<name>encPtr</name> = <name><name>encodingTable</name><index>[<expr><name>UTF_8_ENC</name></expr>]</index></name></expr>;</expr_stmt>
<return>return <expr><name>XML_TOK_BOM</name></expr>;</return>
}</block></then></if>
<break>break;</break>
</case><default>default:
<if>if <condition>(<expr><name><name>ptr</name><index>[<expr>0</expr>]</index></name> == '\0'</expr>)</condition><then> <block>{
<if>if <condition>(<expr><name>state</name> == <name>XML_CONTENT_STATE</name> &amp;&amp; <call><name>INIT_ENC_INDEX</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call> == <name>UTF_16LE_ENC</name></expr>)</condition><then>
<break>break;</break></then></if>
<expr_stmt><expr>*<name>encPtr</name> = <name><name>encodingTable</name><index>[<expr><name>UTF_16BE_ENC</name></expr>]</index></name></expr>;</expr_stmt>
<return>return <expr><call><name>XmlTok</name><argument_list>(<argument><expr>*<name>encPtr</name></expr></argument>, <argument><expr><name>state</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><name>nextTokPtr</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></then> <else>else <if>if <condition>(<expr><name><name>ptr</name><index>[<expr>1</expr>]</index></name> == '\0'</expr>)</condition><then> <block>{
<if>if <condition>(<expr><name>state</name> == <name>XML_CONTENT_STATE</name></expr>)</condition><then>
<break>break;</break></then></if>
<expr_stmt><expr>*<name>encPtr</name> = <name><name>encodingTable</name><index>[<expr><name>UTF_16LE_ENC</name></expr>]</index></name></expr>;</expr_stmt>
<return>return <expr><call><name>XmlTok</name><argument_list>(<argument><expr>*<name>encPtr</name></expr></argument>, <argument><expr><name>state</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><name>nextTokPtr</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></then></if></else></if>
<break>break;</break>
</default>}</block></switch>
}</block></else></if>
<expr_stmt><expr>*<name>encPtr</name> = <name><name>encodingTable</name><index>[<expr><call><name>INIT_ENC_INDEX</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>]</index></name></expr>;</expr_stmt>
<return>return <expr><call><name>XmlTok</name><argument_list>(<argument><expr>*<name>encPtr</name></expr></argument>, <argument><expr><name>state</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><name>nextTokPtr</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NS</name><parameter_list>(<param><type><name>x</name></type></param>)</parameter_list></cpp:macro> <cpp:value>x</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ns</name><parameter_list>(<param><type><name>x</name></type></param>)</parameter_list></cpp:macro> <cpp:value>x</cpp:value></cpp:define>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"xmltok_ns.c"</cpp:file></cpp:include>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>NS</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>ns</name></cpp:undef>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>XML_NS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NS</name><parameter_list>(<param><type><name>x</name></type></param>)</parameter_list></cpp:macro> <cpp:value>x ##NS</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ns</name><parameter_list>(<param><type><name>x</name></type></param>)</parameter_list></cpp:macro> <cpp:value>x ##_ns</cpp:value></cpp:define>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"xmltok_ns.c"</cpp:file></cpp:include>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>NS</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>ns</name></cpp:undef>
<function><type><name>ENCODING</name> *</type>
<name>XmlInitUnknownEncodingNS</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>mem</name></decl></param>,
<param><decl><type><name>int</name> *</type><name>table</name></decl></param>,
<param><decl><type><name>CONVERTER</name></type> <name>convert</name></decl></param>,
<param><decl><type><name>void</name> *</type><name>userData</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>ENCODING</name> *</type><name>enc</name> <init>= <expr><call><name>XmlInitUnknownEncoding</name><argument_list>(<argument><expr><name>mem</name></expr></argument>, <argument><expr><name>table</name></expr></argument>, <argument><expr><name>convert</name></expr></argument>, <argument><expr><name>userData</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>enc</name></expr>)</condition><then>
<expr_stmt><expr>((struct <name>normal_encoding</name> *)<name>enc</name>)-&gt;<name><name>type</name><index>[<expr><name>ASCII_COLON</name></expr>]</index></name> = <name>BT_COLON</name></expr>;</expr_stmt></then></if>
<return>return <expr><name>enc</name></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</unit>
