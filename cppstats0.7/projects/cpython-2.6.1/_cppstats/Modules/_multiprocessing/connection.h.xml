<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C" filename="Modules/_multiprocessing/connection.h"><cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>CONNECTION_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CONNECTION_H</name></cpp:macro></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>READABLE</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WRITABLE</name></cpp:macro> <cpp:value>2</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CHECK_READABLE</name><parameter_list>(<param><type><name>self</name></type></param>)</parameter_list></cpp:macro> <cpp:value>if (!(self-&gt;flags &amp; READABLE)) { PyErr_SetString(PyExc_IOError, "connection is write-only"); return NULL; }</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CHECK_WRITABLE</name><parameter_list>(<param><type><name>self</name></type></param>)</parameter_list></cpp:macro> <cpp:value>if (!(self-&gt;flags &amp; WRITABLE)) { PyErr_SetString(PyExc_IOError, "connection is read-only"); return NULL; }</cpp:value></cpp:define>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>connection_new</name><parameter_list>(<param><decl><type><name>PyTypeObject</name> *</type><name>type</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>kwds</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>ConnectionObject</name> *</type><name>self</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>HANDLE</name></type> <name>handle</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BOOL</name></type> <name>readable</name> <init>= <expr><name>TRUE</name></expr></init>, <name>writable</name> <init>= <expr><name>TRUE</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> *</type><name><name>kwlist</name><index>[]</index></name> <init>= <expr><block>{<expr>"handle"</expr>, <expr>"readable"</expr>, <expr>"writable"</expr>, <expr><name>NULL</name></expr>}</block></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTupleAndKeywords</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>kwds</name></expr></argument>, <argument><expr><name>F_HANDLE</name> "|ii"</expr></argument>, <argument><expr><name>kwlist</name></expr></argument>,
<argument><expr>&amp;<name>handle</name></expr></argument>, <argument><expr>&amp;<name>readable</name></expr></argument>, <argument><expr>&amp;<name>writable</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<if>if <condition>(<expr><name>handle</name> == <name>INVALID_HANDLE_VALUE</name> || (<name>Py_ssize_t</name>)<name>handle</name> &lt; 0</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_IOError</name></expr></argument>, <argument><expr>"invalid handle %zd"</expr></argument>,
<argument><expr>(<name>Py_ssize_t</name>)<name>handle</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<if>if <condition>(<expr>!<name>readable</name> &amp;&amp; !<name>writable</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>,
<argument><expr>"either readable or writable must be true"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>self</name> = <call><name>PyObject_New</name><argument_list>(<argument><expr><name>ConnectionObject</name></expr></argument>, <argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>self</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name><name>self</name>-&gt;<name>weakreflist</name></name> = <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>self</name>-&gt;<name>handle</name></name> = <name>handle</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>self</name>-&gt;<name>flags</name></name> = 0</expr>;</expr_stmt>
<if>if <condition>(<expr><name>readable</name></expr>)</condition><then>
<expr_stmt><expr><name><name>self</name>-&gt;<name>flags</name></name> |= <name>READABLE</name></expr>;</expr_stmt></then></if>
<if>if <condition>(<expr><name>writable</name></expr>)</condition><then>
<expr_stmt><expr><name><name>self</name>-&gt;<name>flags</name></name> |= <name>WRITABLE</name></expr>;</expr_stmt></then></if>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>flags</name></name> &gt;= 1 &amp;&amp; <name><name>self</name>-&gt;<name>flags</name></name> &lt;= 3</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>(<name>PyObject</name>*)<name>self</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>connection_dealloc</name><parameter_list>(<param><decl><type><name>ConnectionObject</name>*</type> <name>self</name></decl></param>)</parameter_list> <block>{
<if>if <condition>(<expr><name><name>self</name>-&gt;<name>weakreflist</name></name> != <name>NULL</name></expr>)</condition><then>
<expr_stmt><expr><call><name>PyObject_ClearWeakRefs</name><argument_list>(<argument><expr>(<name>PyObject</name>*)<name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<if>if <condition>(<expr><name><name>self</name>-&gt;<name>handle</name></name> != <name>INVALID_HANDLE_VALUE</name></expr>)</condition><then> <block>{
<function_decl><type><name>Py_BEGIN_ALLOW_THREADS</name></type>
<name>CLOSE</name><parameter_list>(<param><decl><type><name><name>self</name>-&gt;<name>handle</name></name></type></decl></param>)</parameter_list>;</function_decl>
<expr_stmt><expr><name>Py_END_ALLOW_THREADS</name></expr></expr_stmt>
}</block></then></if>
<expr_stmt><expr><call><name>PyObject_Del</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>connection_sendbytes</name><parameter_list>(<param><decl><type><name>ConnectionObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>char</name> *</type><name>buffer</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>length</name></decl>, <decl><type ref="prev"/><name>offset</name><init>=<expr>0</expr></init>, <name>size</name><init>=<expr><name>PY_SSIZE_T_MIN</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>res</name></decl>;</decl_stmt>
<if>if <condition>(<expr>!<macro><name>PyArg_ParseTuple</name><argument_list>(<argument>args</argument>, <argument>F_RBUFFER "#|" F_PY_SSIZE_T F_PY_SSIZE_T</argument>,
<argument>&amp;buffer</argument>, <argument>&amp;length</argument>, <argument>&amp;offset</argument>, <argument>&amp;size</argument>)</argument_list></macro></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><call><name>CHECK_WRITABLE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>offset</name> &lt; 0</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>, <argument><expr>"offset is negative"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<if>if <condition>(<expr><name>length</name> &lt; <name>offset</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>, <argument><expr>"buffer length &lt; offset"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<if>if <condition>(<expr><name>size</name> == <name>PY_SSIZE_T_MIN</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>size</name> = <name>length</name> - <name>offset</name></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<if>if <condition>(<expr><name>size</name> &lt; 0</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>, <argument><expr>"size is negative"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<if>if <condition>(<expr><name>offset</name> + <name>size</name> &gt; <name>length</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>,
<argument><expr>"buffer length &lt; offset + size"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
}</block></else></if>
<expr_stmt><expr><name>res</name> = <call><name>conn_send_string</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>buffer</name> + <name>offset</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>res</name> &lt; 0</expr>)</condition><then>
<return>return <expr><call><name>mp_SetError</name><argument_list>(<argument><expr><name>PyExc_IOError</name></expr></argument>, <argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
<expr_stmt><expr><name>Py_RETURN_NONE</name></expr>;</expr_stmt>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>connection_recvbytes</name><parameter_list>(<param><decl><type><name>ConnectionObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>char</name> *</type><name>freeme</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>res</name></decl>, <decl><type ref="prev"/><name>maxlength</name> <init>= <expr><name>PY_SSIZE_T_MAX</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>result</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"|" <name>F_PY_SSIZE_T</name></expr></argument>, <argument><expr>&amp;<name>maxlength</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><call><name>CHECK_READABLE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>maxlength</name> &lt; 0</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>, <argument><expr>"maxlength &lt; 0"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>res</name> = <call><name>conn_recv_string</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name><name>self</name>-&gt;<name>buffer</name></name></expr></argument>, <argument><expr><name>CONNECTION_BUFFER_SIZE</name></expr></argument>,
<argument><expr>&amp;<name>freeme</name></expr></argument>, <argument><expr><name>maxlength</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>res</name> &lt; 0</expr>)</condition><then> <block>{
<if>if <condition>(<expr><name>res</name> == <name>MP_BAD_MESSAGE_LENGTH</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr>(<name><name>self</name>-&gt;<name>flags</name></name> &amp; <name>WRITABLE</name>) == 0</expr>)</condition><then> <block>{
<function_decl><type><name>Py_BEGIN_ALLOW_THREADS</name></type>
<name>CLOSE</name><parameter_list>(<param><decl><type><name><name>self</name>-&gt;<name>handle</name></name></type></decl></param>)</parameter_list>;</function_decl>
<decl_stmt><decl><type><name>Py_END_ALLOW_THREADS</name></type>
<name><name>self</name>-&gt;<name>handle</name></name> <init>= <expr><name>INVALID_HANDLE_VALUE</name></expr></init></decl>;</decl_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr><name><name>self</name>-&gt;<name>flags</name></name> = <name>WRITABLE</name></expr>;</expr_stmt>
}</block></else></if>
}</block></then></if>
<expr_stmt><expr><call><name>mp_SetError</name><argument_list>(<argument><expr><name>PyExc_IOError</name></expr></argument>, <argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<if>if <condition>(<expr><name>freeme</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>result</name> = <call><name>PyString_FromStringAndSize</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>buffer</name></name></expr></argument>, <argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr><name>result</name> = <call><name>PyString_FromStringAndSize</name><argument_list>(<argument><expr><name>freeme</name></expr></argument>, <argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyMem_Free</name><argument_list>(<argument><expr><name>freeme</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></else></if>
}</block></else></if>
<return>return <expr><name>result</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>connection_recvbytes_into</name><parameter_list>(<param><decl><type><name>ConnectionObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>char</name> *</type><name>freeme</name> <init>= <expr><name>NULL</name></expr></init>, *<name>buffer</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>res</name></decl>, <decl><type ref="prev"/><name>length</name></decl>, <decl><type ref="prev"/><name>offset</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>result</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_buffer</name></type> <name>pbuf</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>CHECK_READABLE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"w*|" <name>F_PY_SSIZE_T</name></expr></argument>,
<argument><expr>&amp;<name>pbuf</name></expr></argument>, <argument><expr>&amp;<name>offset</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>buffer</name> = <name><name>pbuf</name>.<name>buf</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>length</name> = <name><name>pbuf</name>.<name>len</name></name></expr>;</expr_stmt>
<if>if <condition>(<expr><name>offset</name> &lt; 0</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>, <argument><expr>"negative offset"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>_error</name>;</goto>
}</block></then></if>
<if>if <condition>(<expr><name>offset</name> &gt; <name>length</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>, <argument><expr>"offset too large"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>_error</name>;</goto>
}</block></then></if>
<expr_stmt><expr><name>res</name> = <call><name>conn_recv_string</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>buffer</name>+<name>offset</name></expr></argument>, <argument><expr><name>length</name>-<name>offset</name></expr></argument>,
<argument><expr>&amp;<name>freeme</name></expr></argument>, <argument><expr><name>PY_SSIZE_T_MAX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>res</name> &lt; 0</expr>)</condition><then> <block>{
<if>if <condition>(<expr><name>res</name> == <name>MP_BAD_MESSAGE_LENGTH</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr>(<name><name>self</name>-&gt;<name>flags</name></name> &amp; <name>WRITABLE</name>) == 0</expr>)</condition><then> <block>{
<function_decl><type><name>Py_BEGIN_ALLOW_THREADS</name></type>
<name>CLOSE</name><parameter_list>(<param><decl><type><name><name>self</name>-&gt;<name>handle</name></name></type></decl></param>)</parameter_list>;</function_decl>
<decl_stmt><decl><type><name>Py_END_ALLOW_THREADS</name></type>
<name><name>self</name>-&gt;<name>handle</name></name> <init>= <expr><name>INVALID_HANDLE_VALUE</name></expr></init></decl>;</decl_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr><name><name>self</name>-&gt;<name>flags</name></name> = <name>WRITABLE</name></expr>;</expr_stmt>
}</block></else></if>
}</block></then></if>
<expr_stmt><expr><call><name>mp_SetError</name><argument_list>(<argument><expr><name>PyExc_IOError</name></expr></argument>, <argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<if>if <condition>(<expr><name>freeme</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>result</name> = <call><name>PyInt_FromSsize_t</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr><name>result</name> = <call><name>PyObject_CallFunction</name><argument_list>(<argument><expr><name>BufferTooShort</name></expr></argument>,
<argument><expr><name>F_RBUFFER</name> "#"</expr></argument>,
<argument><expr><name>freeme</name></expr></argument>, <argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyMem_Free</name><argument_list>(<argument><expr><name>freeme</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>result</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetObject</name><argument_list>(<argument><expr><name>BufferTooShort</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<goto>goto <name>_error</name>;</goto>
}</block></else></if>
}</block></else></if>
<label><name>_cleanup</name>:</label>
<expr_stmt><expr><call><name>PyBuffer_Release</name><argument_list>(<argument><expr>&amp;<name>pbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>result</name></expr>;</return>
<label><name>_error</name>:</label>
<expr_stmt><expr><name>result</name> = <name>NULL</name></expr>;</expr_stmt>
<goto>goto <name>_cleanup</name>;</goto>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>connection_send_obj</name><parameter_list>(<param><decl><type><name>ConnectionObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>obj</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>char</name> *</type><name>buffer</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>res</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>length</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>pickled_string</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>CHECK_WRITABLE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>pickled_string</name> = <call><name>PyObject_CallFunctionObjArgs</name><argument_list>(<argument><expr><name>pickle_dumps</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>,
<argument><expr><name>pickle_protocol</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>pickled_string</name></expr>)</condition><then>
<goto>goto <name>failure</name>;</goto></then></if>
<if>if <condition>(<expr><call><name>PyString_AsStringAndSize</name><argument_list>(<argument><expr><name>pickled_string</name></expr></argument>, <argument><expr>&amp;<name>buffer</name></expr></argument>, <argument><expr>&amp;<name>length</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
<goto>goto <name>failure</name>;</goto></then></if>
<expr_stmt><expr><name>res</name> = <call><name>conn_send_string</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>, <argument><expr>(<name>int</name>)<name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>res</name> &lt; 0</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>mp_SetError</name><argument_list>(<argument><expr><name>PyExc_IOError</name></expr></argument>, <argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>failure</name>;</goto>
}</block></then></if>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>pickled_string</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>Py_RETURN_NONE</name></expr>;</expr_stmt>
<label><name>failure</name>:</label>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>pickled_string</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>connection_recv_obj</name><parameter_list>(<param><decl><type><name>ConnectionObject</name> *</type><name>self</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>char</name> *</type><name>freeme</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>res</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>temp</name> <init>= <expr><name>NULL</name></expr></init>, *<name>result</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>CHECK_READABLE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>res</name> = <call><name>conn_recv_string</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name><name>self</name>-&gt;<name>buffer</name></name></expr></argument>, <argument><expr><name>CONNECTION_BUFFER_SIZE</name></expr></argument>,
<argument><expr>&amp;<name>freeme</name></expr></argument>, <argument><expr><name>PY_SSIZE_T_MAX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>res</name> &lt; 0</expr>)</condition><then> <block>{
<if>if <condition>(<expr><name>res</name> == <name>MP_BAD_MESSAGE_LENGTH</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr>(<name><name>self</name>-&gt;<name>flags</name></name> &amp; <name>WRITABLE</name>) == 0</expr>)</condition><then> <block>{
<function_decl><type><name>Py_BEGIN_ALLOW_THREADS</name></type>
<name>CLOSE</name><parameter_list>(<param><decl><type><name><name>self</name>-&gt;<name>handle</name></name></type></decl></param>)</parameter_list>;</function_decl>
<decl_stmt><decl><type><name>Py_END_ALLOW_THREADS</name></type>
<name><name>self</name>-&gt;<name>handle</name></name> <init>= <expr><name>INVALID_HANDLE_VALUE</name></expr></init></decl>;</decl_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr><name><name>self</name>-&gt;<name>flags</name></name> = <name>WRITABLE</name></expr>;</expr_stmt>
}</block></else></if>
}</block></then></if>
<expr_stmt><expr><call><name>mp_SetError</name><argument_list>(<argument><expr><name>PyExc_IOError</name></expr></argument>, <argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<if>if <condition>(<expr><name>freeme</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>temp</name> = <call><name>PyString_FromStringAndSize</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>buffer</name></name></expr></argument>, <argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr><name>temp</name> = <call><name>PyString_FromStringAndSize</name><argument_list>(<argument><expr><name>freeme</name></expr></argument>, <argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyMem_Free</name><argument_list>(<argument><expr><name>freeme</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></else></if>
}</block></else></if>
<if>if <condition>(<expr><name>temp</name></expr>)</condition><then>
<expr_stmt><expr><name>result</name> = <call><name>PyObject_CallFunctionObjArgs</name><argument_list>(<argument><expr><name>pickle_loads</name></expr></argument>,
<argument><expr><name>temp</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>temp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>result</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>connection_poll</name><parameter_list>(<param><decl><type><name>ConnectionObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>timeout_obj</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>double</name></type> <name>timeout</name> <init>= <expr>0.0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>res</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>CHECK_READABLE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"|O"</expr></argument>, <argument><expr>&amp;<name>timeout_obj</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<if>if <condition>(<expr><name>timeout_obj</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>timeout</name> = 0.0</expr>;</expr_stmt>
}</block></then> <else>else <if>if <condition>(<expr><name>timeout_obj</name> == <name>Py_None</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>timeout</name> = -1.0</expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr><name>timeout</name> = <call><name>PyFloat_AsDouble</name><argument_list>(<argument><expr><name>timeout_obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<if>if <condition>(<expr><name>timeout</name> &lt; 0.0</expr>)</condition><then>
<expr_stmt><expr><name>timeout</name> = 0.0</expr>;</expr_stmt></then></if>
}</block></else></if></else></if>
<decl_stmt><decl><type><name>Py_BEGIN_ALLOW_THREADS</name></type>
<name>res</name> <init>= <expr><call><name>conn_poll</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>timeout</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<macro><name>Py_END_ALLOW_THREADS</name></macro>
<switch>switch <condition>(<expr><name>res</name></expr>)</condition> <block>{
<case>case <expr><name>TRUE</name></expr>:
<expr_stmt><expr><name>Py_RETURN_TRUE</name></expr>;</expr_stmt>
</case><case>case <expr><name>FALSE</name></expr>:
<expr_stmt><expr><name>Py_RETURN_FALSE</name></expr>;</expr_stmt>
</case><default>default:
<return>return <expr><call><name>mp_SetError</name><argument_list>(<argument><expr><name>PyExc_IOError</name></expr></argument>, <argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</return>
</default>}</block></switch>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>connection_fileno</name><parameter_list>(<param><decl><type><name>ConnectionObject</name>*</type> <name>self</name></decl></param>)</parameter_list> <block>{
<if>if <condition>(<expr><name><name>self</name>-&gt;<name>handle</name></name> == <name>INVALID_HANDLE_VALUE</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_IOError</name></expr></argument>, <argument><expr>"handle is invalid"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<return>return <expr><call><name>PyInt_FromLong</name><argument_list>(<argument><expr>(<name>long</name>)<name><name>self</name>-&gt;<name>handle</name></name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>connection_close</name><parameter_list>(<param><decl><type><name>ConnectionObject</name> *</type><name>self</name></decl></param>)</parameter_list> <block>{
<if>if <condition>(<expr><name><name>self</name>-&gt;<name>handle</name></name> != <name>INVALID_HANDLE_VALUE</name></expr>)</condition><then> <block>{
<function_decl><type><name>Py_BEGIN_ALLOW_THREADS</name></type>
<name>CLOSE</name><parameter_list>(<param><decl><type><name><name>self</name>-&gt;<name>handle</name></name></type></decl></param>)</parameter_list>;</function_decl>
<decl_stmt><decl><type><name>Py_END_ALLOW_THREADS</name></type>
<name><name>self</name>-&gt;<name>handle</name></name> <init>= <expr><name>INVALID_HANDLE_VALUE</name></expr></init></decl>;</decl_stmt>
}</block></then></if>
<expr_stmt><expr><name>Py_RETURN_NONE</name></expr>;</expr_stmt>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>connection_repr</name><parameter_list>(<param><decl><type><name>ConnectionObject</name> *</type><name>self</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> *</type><name><name>conn_type</name><index>[]</index></name> <init>= <expr><block>{<expr>"read-only"</expr>, <expr>"write-only"</expr>, <expr>"read-write"</expr>}</block></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>flags</name></name> &gt;= 1 &amp;&amp; <name><name>self</name>-&gt;<name>flags</name></name> &lt;= 3</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>FROM_FORMAT</name><argument_list>(<argument><expr>"&lt;%s %s, handle %zd&gt;"</expr></argument>,
<argument><expr><name><name>conn_type</name><index>[<expr><name><name>self</name>-&gt;<name>flags</name></name> - 1</expr>]</index></name></expr></argument>,
<argument><expr><name>CONNECTION_NAME</name></expr></argument>, <argument><expr>(<name>Py_ssize_t</name>)<name><name>self</name>-&gt;<name>handle</name></name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>connection_closed</name><parameter_list>(<param><decl><type><name>ConnectionObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>void</name> *</type><name>closure</name></decl></param>)</parameter_list> <block>{
<return>return <expr><call><name>PyBool_FromLong</name><argument_list>(<argument><expr><call>(<name>long</name>)<argument_list>(<argument><expr><name><name>self</name>-&gt;<name>handle</name></name> == <name>INVALID_HANDLE_VALUE</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>connection_readable</name><parameter_list>(<param><decl><type><name>ConnectionObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>void</name> *</type><name>closure</name></decl></param>)</parameter_list> <block>{
<return>return <expr><call><name>PyBool_FromLong</name><argument_list>(<argument><expr><call>(<name>long</name>)<argument_list>(<argument><expr><name><name>self</name>-&gt;<name>flags</name></name> &amp; <name>READABLE</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>connection_writable</name><parameter_list>(<param><decl><type><name>ConnectionObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>void</name> *</type><name>closure</name></decl></param>)</parameter_list> <block>{
<return>return <expr><call><name>PyBool_FromLong</name><argument_list>(<argument><expr><call>(<name>long</name>)<argument_list>(<argument><expr><name><name>self</name>-&gt;<name>flags</name></name> &amp; <name>WRITABLE</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<decl_stmt><decl><type><specifier>static</specifier> <name>PyMethodDef</name></type> <name><name>connection_methods</name><index>[]</index></name> <init>= <expr><block>{
<expr><block>{
<expr>"send_bytes"</expr>, <expr>(<name>PyCFunction</name>)<name>connection_sendbytes</name></expr>, <expr><name>METH_VARARGS</name></expr>,
<expr>"send the byte data from a readable buffer-like object"</expr>
}</block></expr>,
<expr><block>{
<expr>"recv_bytes"</expr>, <expr>(<name>PyCFunction</name>)<name>connection_recvbytes</name></expr>, <expr><name>METH_VARARGS</name></expr>,
<expr>"receive byte data as a string"</expr>
}</block></expr>,
<expr><block>{
<expr>"recv_bytes_into"</expr>,<expr>(<name>PyCFunction</name>)<name>connection_recvbytes_into</name></expr>,<expr><name>METH_VARARGS</name></expr>,
<expr>"receive byte data into a writeable buffer-like object\n"
"returns the number of bytes read"</expr>
}</block></expr>,
<expr><block>{
<expr>"send"</expr>, <expr>(<name>PyCFunction</name>)<name>connection_send_obj</name></expr>, <expr><name>METH_O</name></expr>,
<expr>"send a (picklable) object"</expr>
}</block></expr>,
<expr><block>{
<expr>"recv"</expr>, <expr>(<name>PyCFunction</name>)<name>connection_recv_obj</name></expr>, <expr><name>METH_NOARGS</name></expr>,
<expr>"receive a (picklable) object"</expr>
}</block></expr>,
<expr><block>{
<expr>"poll"</expr>, <expr>(<name>PyCFunction</name>)<name>connection_poll</name></expr>, <expr><name>METH_VARARGS</name></expr>,
<expr>"whether there is any input available to be read"</expr>
}</block></expr>,
<expr><block>{
<expr>"fileno"</expr>, <expr>(<name>PyCFunction</name>)<name>connection_fileno</name></expr>, <expr><name>METH_NOARGS</name></expr>,
<expr>"file descriptor or handle of the connection"</expr>
}</block></expr>,
<expr><block>{
<expr>"close"</expr>, <expr>(<name>PyCFunction</name>)<name>connection_close</name></expr>, <expr><name>METH_NOARGS</name></expr>,
<expr>"close the connection"</expr>
}</block></expr>,
<expr><block>{<expr><name>NULL</name></expr>}</block></expr>
}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>PyGetSetDef</name></type> <name><name>connection_getset</name><index>[]</index></name> <init>= <expr><block>{
<expr><block>{
<expr>"closed"</expr>, <expr>(<name>getter</name>)<name>connection_closed</name></expr>, <expr><name>NULL</name></expr>,
<expr>"True if the connection is closed"</expr>, <expr><name>NULL</name></expr>
}</block></expr>,
<expr><block>{
<expr>"readable"</expr>, <expr>(<name>getter</name>)<name>connection_readable</name></expr>, <expr><name>NULL</name></expr>,
<expr>"True if the connection is readable"</expr>, <expr><name>NULL</name></expr>
}</block></expr>,
<expr><block>{
<expr>"writable"</expr>, <expr>(<name>getter</name>)<name>connection_writable</name></expr>, <expr><name>NULL</name></expr>,
<expr>"True if the connection is writable"</expr>, <expr><name>NULL</name></expr>
}</block></expr>,
<expr><block>{<expr><name>NULL</name></expr>}</block></expr>
}</block></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>connection_doc</name></expr></argument>,
<argument><expr>"Connection type whose constructor signature is\n\n"
" Connection(handle, readable=True, writable=True).\n\n"
"The constructor does *not* duplicate the handle."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>PyTypeObject</name></type> <name>CONNECTION_TYPE</name> <init>= <expr><block>{
<expr><call><name>PyVarObject_HEAD_INIT</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call>
"_multiprocessing." <name>CONNECTION_NAME</name></expr>,
<expr><sizeof>sizeof<argument_list>(<argument><expr><name>ConnectionObject</name></expr></argument>)</argument_list></sizeof></expr>,
<expr>0</expr>,
<expr>(<name>destructor</name>)<name>connection_dealloc</name></expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>(<name>reprfunc</name>)<name>connection_repr</name></expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr><name>Py_TPFLAGS_DEFAULT</name> | <name>Py_TPFLAGS_BASETYPE</name> |
<name>Py_TPFLAGS_HAVE_WEAKREFS</name></expr>,
<expr><name>connection_doc</name></expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr><call><name>offsetof</name><argument_list>(<argument><expr><name>ConnectionObject</name></expr></argument>, <argument><expr><name>weakreflist</name></expr></argument>)</argument_list></call></expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr><name>connection_methods</name></expr>,
<expr>0</expr>,
<expr><name>connection_getset</name></expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr><name>connection_new</name></expr>,
}</block></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</unit>
