<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C" filename="Modules/socketmodule.c"><cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__APPLE__</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:pragma>#<cpp:directive>pragma</cpp:directive> weak inet_aton</cpp:pragma>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"Python.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"structmember.h"</cpp:file></cpp:include>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>MAX</name></cpp:undef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAX</name><parameter_list>(<param><type><name>x</name></type></param>, <param><type><name>y</name></type></param>)</parameter_list></cpp:macro> <cpp:value>((x) &lt; (y) ? (y) : (x))</cpp:value></cpp:define>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>sock_doc</name></expr></argument>,
<argument><expr>"socket([family[, type[, proto]]]) -&gt; socket object\n\
\n\
Open a socket of the given type. The family argument specifies the\n\
address family; it defaults to AF_INET. The type argument specifies\n\
whether this is a stream (SOCK_STREAM, this is the default)\n\
or datagram (SOCK_DGRAM) socket. The protocol argument defaults to 0,\n\
specifying the default protocol. Keyword arguments are accepted.\n\
\n\
A socket object represents one endpoint of a network connection.\n\
\n\
Methods of socket objects (keyword arguments not allowed):\n\
\n\
accept() -- accept a connection, returning new socket and client address\n\
bind(addr) -- bind the socket to a local address\n\
close() -- close the socket\n\
connect(addr) -- connect the socket to a remote address\n\
connect_ex(addr) -- connect, return an error code instead of an exception\n\
dup() -- return a new socket object identical to the current one [*]\n\
fileno() -- return underlying file descriptor\n\
getpeername() -- return remote address [*]\n\
getsockname() -- return local address\n\
getsockopt(level, optname[, buflen]) -- get socket options\n\
gettimeout() -- return timeout or None\n\
listen(n) -- start listening for incoming connections\n\
makefile([mode, [bufsize]]) -- return a file object for the socket [*]\n\
recv(buflen[, flags]) -- receive data\n\
recv_into(buffer[, nbytes[, flags]]) -- receive data (into a buffer)\n\
recvfrom(buflen[, flags]) -- receive data and sender\'s address\n\
recvfrom_into(buffer[, nbytes, [, flags])\n\
-- receive data and sender\'s address (into a buffer)\n\
sendall(data[, flags]) -- send all data\n\
send(data[, flags]) -- send data, may not send all of it\n\
sendto(data[, flags], addr) -- send data to a given address\n\
setblocking(0 | 1) -- set or clear the blocking I/O flag\n\
setsockopt(level, optname, value) -- set socket options\n\
settimeout(None | float) -- set or clear the timeout\n\
shutdown(how) -- shut down traffic in one or both directions\n\
\n\
[*] not available on all platforms!"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>linux</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>HAVE_GETHOSTBYNAME_R_3_ARG</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>HAVE_GETHOSTBYNAME_R_5_ARG</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>HAVE_GETHOSTBYNAME_R_6_ARG</name></cpp:undef>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>WITH_THREAD</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>HAVE_GETHOSTBYNAME_R</name></cpp:undef>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_GETHOSTBYNAME_R</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_AIX</name></expr></argument>)</argument_list></call> || <call><name>defined</name><argument_list>(<argument><expr><name>__osf__</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HAVE_GETHOSTBYNAME_R_3_ARG</name></cpp:macro></cpp:define>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__sun</name></expr></argument>)</argument_list></call> || <call><name>defined</name><argument_list>(<argument><expr><name>__sgi</name></expr></argument>)</argument_list></call></expr></cpp:elif>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HAVE_GETHOSTBYNAME_R_5_ARG</name></cpp:macro></cpp:define>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>linux</name></expr></argument>)</argument_list></call></expr></cpp:elif>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>HAVE_GETHOSTBYNAME_R</name></cpp:undef>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>HAVE_GETHOSTBYNAME_R</name></expr></argument>)</argument_list></call> &amp;&amp; <call><name>defined</name><argument_list>(<argument><expr><name>WITH_THREAD</name></expr></argument>)</argument_list></call> &amp;&amp; !<call><name>defined</name><argument_list>(<argument><expr><name>MS_WINDOWS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>USE_GETHOSTBYNAME_LOCK</name></cpp:macro></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_SYS_PARAM_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/param.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>WITH_THREAD</name></expr></argument>)</argument_list></call> &amp;&amp; (<call><name>defined</name><argument_list>(<argument><expr><name>__APPLE__</name></expr></argument>)</argument_list></call> || (<call><name>defined</name><argument_list>(<argument><expr><name>__FreeBSD__</name></expr></argument>)</argument_list></call> &amp;&amp; <name>__FreeBSD_version</name>+0 &lt; 503000) || <call><name>defined</name><argument_list>(<argument><expr><name>__OpenBSD__</name></expr></argument>)</argument_list></call> || <call><name>defined</name><argument_list>(<argument><expr><name>__NetBSD__</name></expr></argument>)</argument_list></call> || <call><name>defined</name><argument_list>(<argument><expr><name>__VMS</name></expr></argument>)</argument_list></call> || !<call><name>defined</name><argument_list>(<argument><expr><name>HAVE_GETADDRINFO</name></expr></argument>)</argument_list></call>)</expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>USE_GETADDRINFO_LOCK</name></cpp:macro></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>USE_GETADDRINFO_LOCK</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ACQUIRE_GETADDRINFO_LOCK</name></cpp:macro> <cpp:value>PyThread_acquire_lock(netdb_lock, 1);</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RELEASE_GETADDRINFO_LOCK</name></cpp:macro> <cpp:value>PyThread_release_lock(netdb_lock);</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ACQUIRE_GETADDRINFO_LOCK</name></cpp:macro></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RELEASE_GETADDRINFO_LOCK</name></cpp:macro></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>USE_GETHOSTBYNAME_LOCK</name></expr></argument>)</argument_list></call> || <call><name>defined</name><argument_list>(<argument><expr><name>USE_GETADDRINFO_LOCK</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pythread.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>PYCC_VACPP</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;types.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;io.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/ioctl.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utils.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;ctype.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__VMS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;ioctl.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>PYOS_OS2</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INCL_DOS</name></cpp:macro></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INCL_DOSERRORS</name></cpp:macro></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INCL_NOPMAPI</name></cpp:macro></cpp:define>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;os2.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__sgi</name></expr></argument>)</argument_list></call> &amp;&amp; <name>_COMPILER_VERSION</name>&gt;700 &amp;&amp; !<name>_SGIAPI</name></expr></cpp:if>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>_SGIAPI</name></cpp:undef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>_SGIAPI</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>_XOPEN_SOURCE</name></cpp:undef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/socket.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/types.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;netinet/in.h&gt;</cpp:file></cpp:include>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_SS_ALIGNSIZE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HAVE_GETADDRINFO</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HAVE_GETNAMEINFO</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HAVE_INET_PTON</name></cpp:macro></cpp:define>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;netdb.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>(<call><name>defined</name><argument_list>(<argument><expr><name>__sgi</name></expr></argument>)</argument_list></call> || <call><name>defined</name><argument_list>(<argument><expr><name>sun</name></expr></argument>)</argument_list></call>) &amp;&amp; !<call><name>defined</name><argument_list>(<argument><expr><name>INET_ADDRSTRLEN</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INET_ADDRSTRLEN</name></cpp:macro> <cpp:value>16</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_SYS_TYPES_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/types.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PySocket_BUILDING_SOCKET</name></cpp:macro></cpp:define>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"socketmodule.h"</cpp:file></cpp:include>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>MS_WINDOWS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;netdb.h&gt;</cpp:file></cpp:include>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__BEOS__</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;net/netdb.h&gt;</cpp:file></cpp:include>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>PYOS_OS2</name></expr></argument>)</argument_list></call> &amp;&amp; <call><name>defined</name><argument_list>(<argument><expr><name>PYCC_VACPP</name></expr></argument>)</argument_list></call></expr></cpp:elif>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;netdb.h&gt;</cpp:file></cpp:include>
<typedef>typedef <type><name>size_t</name></type> <name>socklen_t</name>;</typedef>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;arpa/inet.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>RISCOS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;fcntl.h&gt;</cpp:file></cpp:include>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/ioctl.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;socklib.h&gt;</cpp:file></cpp:include>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NO_DUP</name></cpp:macro></cpp:define>
<decl_stmt><decl><type><name>int</name></type> <name>h_errno</name></decl>;</decl_stmt>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INET_ADDRSTRLEN</name></cpp:macro> <cpp:value>16</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_FCNTL_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;fcntl.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stddef.h&gt;</cpp:file></cpp:include>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>offsetof</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>offsetof</name><parameter_list>(<param><type><name>type</name></type></param>, <param><type><name>member</name></type></param>)</parameter_list></cpp:macro> <cpp:value>((size_t)(&amp;((type *)0)-&gt;member))</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>O_NONBLOCK</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>O_NONBLOCK</name></cpp:macro> <cpp:value>O_NDELAY</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__sgi</name></expr></argument>)</argument_list></call> &amp;&amp; <name>_COMPILER_VERSION</name>&gt;700 &amp;&amp; <call><name>defined</name><argument_list>(<argument><expr><name>_SS_ALIGNSIZE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_MSC_VER</name></expr></argument>)</argument_list></call> &amp;&amp; <name>_MSC_VER</name>&gt;1201</expr></cpp:elif>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"addrinfo.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>HAVE_INET_PTON</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>NTDDI_VERSION</name></expr></argument>)</argument_list></call> || (<name>NTDDI_VERSION</name> &lt; <name>NTDDI_LONGHORN</name>)</expr></cpp:if>
<function_decl><type><name>int</name></type> <name>inet_pton</name><parameter_list>(<param><decl><type><name>int</name></type> <name>af</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>src</name></decl></param>, <param><decl><type><name>void</name> *</type><name>dst</name></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><specifier>const</specifier> <name>char</name> *</type><name>inet_ntop</name><parameter_list>(<param><decl><type><name>int</name></type> <name>af</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>void</name> *</type><name>src</name></decl></param>, <param><decl><type><name>char</name> *</type><name>dst</name></decl></param>, <param><decl><type><name>socklen_t</name></type> <name>size</name></decl></param>)</parameter_list>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__APPLE__</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>HAVE_GETNAMEINFO</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>HAVE_GETADDRINFO</name></cpp:undef>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_INET_ATON</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>USE_INET_ATON_WEAKLINK</name></cpp:macro></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>HAVE_GETADDRINFO</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>getaddrinfo</name></cpp:macro> <cpp:value>fake_getaddrinfo</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>gai_strerror</name></cpp:macro> <cpp:value>fake_gai_strerror</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>freeaddrinfo</name></cpp:macro> <cpp:value>fake_freeaddrinfo</cpp:value></cpp:define>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"getaddrinfo.c"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>HAVE_GETNAMEINFO</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>getnameinfo</name></cpp:macro> <cpp:value>fake_getnameinfo</cpp:value></cpp:define>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"getnameinfo.c"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MS_WINDOWS</name></expr></argument>)</argument_list></call> || <call><name>defined</name><argument_list>(<argument><expr><name>__BEOS__</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SOCKETCLOSE</name></cpp:macro> <cpp:value>closesocket</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NO_DUP</name></cpp:macro></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MS_WIN32</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>EAFNOSUPPORT</name></cpp:macro> <cpp:value>WSAEAFNOSUPPORT</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>snprintf</name></cpp:macro> <cpp:value>_snprintf</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>PYOS_OS2</name></expr></argument>)</argument_list></call> &amp;&amp; !<call><name>defined</name><argument_list>(<argument><expr><name>PYCC_GCC</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SOCKETCLOSE</name></cpp:macro> <cpp:value>soclose</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NO_DUP</name></cpp:macro></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>SOCKETCLOSE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SOCKETCLOSE</name></cpp:macro> <cpp:value>close</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_BLUETOOTH_H</name></expr></argument>)</argument_list></call> || <call><name>defined</name><argument_list>(<argument><expr><name>HAVE_BLUETOOTH_BLUETOOTH_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>USE_BLUETOOTH</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__FreeBSD__</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BTPROTO_L2CAP</name></cpp:macro> <cpp:value>BLUETOOTH_PROTO_L2CAP</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BTPROTO_RFCOMM</name></cpp:macro> <cpp:value>BLUETOOTH_PROTO_RFCOMM</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BTPROTO_HCI</name></cpp:macro> <cpp:value>BLUETOOTH_PROTO_HCI</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SOL_HCI</name></cpp:macro> <cpp:value>SOL_HCI_RAW</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HCI_FILTER</name></cpp:macro> <cpp:value>SO_HCI_RAW_FILTER</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>sockaddr_l2</name></cpp:macro> <cpp:value>sockaddr_l2cap</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>sockaddr_rc</name></cpp:macro> <cpp:value>sockaddr_rfcomm</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>hci_dev</name></cpp:macro> <cpp:value>hci_node</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>_BT_L2_MEMB</name><parameter_list>(<param><type><name>sa</name></type></param>, <param><type><name>memb</name></type></param>)</parameter_list></cpp:macro> <cpp:value>((sa)-&gt;l2cap_##memb)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>_BT_RC_MEMB</name><parameter_list>(<param><type><name>sa</name></type></param>, <param><type><name>memb</name></type></param>)</parameter_list></cpp:macro> <cpp:value>((sa)-&gt;rfcomm_##memb)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>_BT_HCI_MEMB</name><parameter_list>(<param><type><name>sa</name></type></param>, <param><type><name>memb</name></type></param>)</parameter_list></cpp:macro> <cpp:value>((sa)-&gt;hci_##memb)</cpp:value></cpp:define>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__NetBSD__</name></expr></argument>)</argument_list></call></expr></cpp:elif>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>sockaddr_l2</name></cpp:macro> <cpp:value>sockaddr_bt</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>sockaddr_rc</name></cpp:macro> <cpp:value>sockaddr_bt</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>sockaddr_hci</name></cpp:macro> <cpp:value>sockaddr_bt</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>sockaddr_sco</name></cpp:macro> <cpp:value>sockaddr_bt</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>_BT_L2_MEMB</name><parameter_list>(<param><type><name>sa</name></type></param>, <param><type><name>memb</name></type></param>)</parameter_list></cpp:macro> <cpp:value>((sa)-&gt;bt_##memb)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>_BT_RC_MEMB</name><parameter_list>(<param><type><name>sa</name></type></param>, <param><type><name>memb</name></type></param>)</parameter_list></cpp:macro> <cpp:value>((sa)-&gt;bt_##memb)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>_BT_HCI_MEMB</name><parameter_list>(<param><type><name>sa</name></type></param>, <param><type><name>memb</name></type></param>)</parameter_list></cpp:macro> <cpp:value>((sa)-&gt;bt_##memb)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>_BT_SCO_MEMB</name><parameter_list>(<param><type><name>sa</name></type></param>, <param><type><name>memb</name></type></param>)</parameter_list></cpp:macro> <cpp:value>((sa)-&gt;bt_##memb)</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>_BT_L2_MEMB</name><parameter_list>(<param><type><name>sa</name></type></param>, <param><type><name>memb</name></type></param>)</parameter_list></cpp:macro> <cpp:value>((sa)-&gt;l2_##memb)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>_BT_RC_MEMB</name><parameter_list>(<param><type><name>sa</name></type></param>, <param><type><name>memb</name></type></param>)</parameter_list></cpp:macro> <cpp:value>((sa)-&gt;rc_##memb)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>_BT_HCI_MEMB</name><parameter_list>(<param><type><name>sa</name></type></param>, <param><type><name>memb</name></type></param>)</parameter_list></cpp:macro> <cpp:value>((sa)-&gt;hci_##memb)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>_BT_SCO_MEMB</name><parameter_list>(<param><type><name>sa</name></type></param>, <param><type><name>memb</name></type></param>)</parameter_list></cpp:macro> <cpp:value>((sa)-&gt;sco_##memb)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__VMS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SEGMENT_SIZE</name></cpp:macro> <cpp:value>(32 * 1024 -1)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SAS2SA</name><parameter_list>(<param><type><name>x</name></type></param>)</parameter_list></cpp:macro> <cpp:value>((struct sockaddr *)(x))</cpp:value></cpp:define>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>NI_MAXHOST</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NI_MAXHOST</name></cpp:macro> <cpp:value>1025</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>NI_MAXSERV</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NI_MAXSERV</name></cpp:macro> <cpp:value>32</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<decl_stmt><decl><type><specifier>static</specifier> <name>PyObject</name> *</type><name>socket_error</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>PyObject</name> *</type><name>socket_herror</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>PyObject</name> *</type><name>socket_gaierror</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>PyObject</name> *</type><name>socket_timeout</name></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>RISCOS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>taskwindow</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<decl_stmt><decl><type><specifier>static</specifier> <name>PyTypeObject</name></type> <name>sock_type</name></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_POLL_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;poll.h&gt;</cpp:file></cpp:include>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_SYS_POLL_H</name></expr></argument>)</argument_list></call></expr></cpp:elif>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/poll.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>Py_SOCKET_FD_CAN_BE_GE_FD_SETSIZE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IS_SELECTABLE</name><parameter_list>(<param><type><name>s</name></type></param>)</parameter_list></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_POLL</name></expr></argument>)</argument_list></call></expr></cpp:elif>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IS_SELECTABLE</name><parameter_list>(<param><type><name>s</name></type></param>)</parameter_list></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IS_SELECTABLE</name><parameter_list>(<param><type><name>s</name></type></param>)</parameter_list></cpp:macro> <cpp:value>((s)-&gt;sock_fd &lt; FD_SETSIZE || s-&gt;sock_timeout &lt;= 0.0)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<function><type><specifier>static</specifier> <name>PyObject</name>*</type>
<name>select_error</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>socket_error</name></expr></argument>, <argument><expr>"unable to select on socket"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>set_error</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list> <block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MS_WINDOWS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>int</name></type> <name>err_no</name> <init>= <expr><call><name>WSAGetLastError</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>err_no</name></expr>)</condition><then>
<return>return <expr><call><name>PyErr_SetExcFromWindowsErr</name><argument_list>(<argument><expr><name>socket_error</name></expr></argument>, <argument><expr><name>err_no</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>PYOS_OS2</name></expr></argument>)</argument_list></call> &amp;&amp; !<call><name>defined</name><argument_list>(<argument><expr><name>PYCC_GCC</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if>if <condition>(<expr><call><name>sock_errno</name><argument_list>()</argument_list></call> != <name>NO_ERROR</name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>APIRET</name></type> <name>rc</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ULONG</name></type> <name>msglen</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name><name>outbuf</name><index>[<expr>100</expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>myerrorcode</name> <init>= <expr><call><name>sock_errno</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>rc</name> = <call><name>DosGetMessage</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>outbuf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>outbuf</name></expr></argument>)</argument_list></sizeof></expr></argument>,
<argument><expr><name>myerrorcode</name> - <name>SOCBASEERR</name> + 26</expr></argument>,
<argument><expr>"mptn.msg"</expr></argument>,
<argument><expr>&amp;<name>msglen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>rc</name> == <name>NO_ERROR</name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>v</name></decl>;</decl_stmt>
<expr_stmt><expr><name><name>outbuf</name><index>[<expr><name>msglen</name></expr>]</index></name> = '\0'</expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>strlen</name><argument_list>(<argument><expr><name>outbuf</name></expr></argument>)</argument_list></call> &gt; 0</expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>char</name> *</type><name>lastc</name> <init>= <expr>&amp;<name><name>outbuf</name><index>[ <expr><call><name>strlen</name><argument_list>(<argument><expr><name>outbuf</name></expr></argument>)</argument_list></call>-1</expr> ]</index></name></expr></init></decl>;</decl_stmt>
<while>while <condition>(<expr><name>lastc</name> &gt; <name>outbuf</name> &amp;&amp;
<call><name>isspace</name><argument_list>(<argument><expr><call><name>Py_CHARMASK</name><argument_list>(<argument><expr>*<name>lastc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{
<expr_stmt><expr>*<name>lastc</name>-- = '\0'</expr>;</expr_stmt>
}</block></while>
}</block></then></if>
<expr_stmt><expr><name>v</name> = <call><name>Py_BuildValue</name><argument_list>(<argument><expr>"(is)"</expr></argument>, <argument><expr><name>myerrorcode</name></expr></argument>, <argument><expr><name>outbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>v</name> != <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetObject</name><argument_list>(<argument><expr><name>socket_error</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
}</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>RISCOS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if>if <condition>(<expr><name><name>_inet_error</name>.<name>errnum</name></name> != <name>NULL</name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>v</name></decl>;</decl_stmt>
<expr_stmt><expr><name>v</name> = <call><name>Py_BuildValue</name><argument_list>(<argument><expr>"(is)"</expr></argument>, <argument><expr><name>errno</name></expr></argument>, <argument><expr><call><name>_inet_err</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>v</name> != <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetObject</name><argument_list>(<argument><expr><name>socket_error</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<return>return <expr><call><name>PyErr_SetFromErrno</name><argument_list>(<argument><expr><name>socket_error</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>set_herror</name><parameter_list>(<param><decl><type><name>int</name></type> <name>h_error</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>v</name></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_HSTRERROR</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><name>v</name> = <call><name>Py_BuildValue</name><argument_list>(<argument><expr>"(is)"</expr></argument>, <argument><expr><name>h_error</name></expr></argument>, <argument><expr>(<name>char</name> *)<call><name>hstrerror</name><argument_list>(<argument><expr><name>h_error</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<expr_stmt><expr><name>v</name> = <call><name>Py_BuildValue</name><argument_list>(<argument><expr>"(is)"</expr></argument>, <argument><expr><name>h_error</name></expr></argument>, <argument><expr>"host not found"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<if>if <condition>(<expr><name>v</name> != <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetObject</name><argument_list>(<argument><expr><name>socket_herror</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>set_gaierror</name><parameter_list>(<param><decl><type><name>int</name></type> <name>error</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>v</name></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>EAI_SYSTEM</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if>if <condition>(<expr><name>error</name> == <name>EAI_SYSTEM</name></expr>)</condition><then>
<return>return <expr><call><name>set_error</name><argument_list>()</argument_list></call></expr>;</return></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_GAI_STRERROR</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><name>v</name> = <call><name>Py_BuildValue</name><argument_list>(<argument><expr>"(is)"</expr></argument>, <argument><expr><name>error</name></expr></argument>, <argument><expr><call><name>gai_strerror</name><argument_list>(<argument><expr><name>error</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<expr_stmt><expr><name>v</name> = <call><name>Py_BuildValue</name><argument_list>(<argument><expr>"(is)"</expr></argument>, <argument><expr><name>error</name></expr></argument>, <argument><expr>"getaddrinfo failed"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<if>if <condition>(<expr><name>v</name> != <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetObject</name><argument_list>(<argument><expr><name>socket_gaierror</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></function>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__VMS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>sendsegmented</name><parameter_list>(<param><decl><type><name>int</name></type> <name>sock_fd</name></decl></param>, <param><decl><type><name>char</name> *</type><name>buf</name></decl></param>, <param><decl><type><name>int</name></type> <name>len</name></decl></param>, <param><decl><type><name>int</name></type> <name>flags</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>n</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>remaining</name> <init>= <expr><name>len</name></expr></init></decl>;</decl_stmt>
<while>while <condition>(<expr><name>remaining</name> &gt; 0</expr>)</condition> <block>{
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>segment</name></decl>;</decl_stmt>
<expr_stmt><expr><name>segment</name> = (<name>remaining</name> &gt;= <name>SEGMENT_SIZE</name> ? <name>SEGMENT_SIZE</name> : <name>remaining</name>)</expr>;</expr_stmt>
<expr_stmt><expr><name>n</name> = <call><name>send</name><argument_list>(<argument><expr><name>sock_fd</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>segment</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>n</name> &lt; 0</expr>)</condition><then> <block>{
<return>return <expr><name>n</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>remaining</name> -= <name>segment</name></expr>;</expr_stmt>
<expr_stmt><expr><name>buf</name> += <name>segment</name></expr>;</expr_stmt>
}</block></while>
<return>return <expr><name>len</name></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>internal_setblocking</name><parameter_list>(<param><decl><type><name>PySocketSockObject</name> *</type><name>s</name></decl></param>, <param><decl><type><name>int</name></type> <name>block</name></decl></param>)</parameter_list> <block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>RISCOS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>MS_WINDOWS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>int</name></type> <name>delay_flag</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<decl_stmt><decl><type><name>Py_BEGIN_ALLOW_THREADS</name></type>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__BEOS__</name></expr></argument>)</argument_list></call></expr></cpp:if>
<name>block</name> <init>= <expr>!<name>block</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>setsockopt</name><argument_list>(<argument><expr><name><name>s</name>-&gt;<name>sock_fd</name></name></expr></argument>, <argument><expr><name>SOL_SOCKET</name></expr></argument>, <argument><expr><name>SO_NONBLOCK</name></expr></argument>,
<argument><expr><call>(<name>void</name> *)<argument_list>(<argument><expr>&amp;<name>block</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>RISCOS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>MS_WINDOWS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>PYOS_OS2</name></expr></argument>)</argument_list></call> &amp;&amp; !<call><name>defined</name><argument_list>(<argument><expr><name>PYCC_GCC</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><name>block</name> = !<name>block</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ioctl</name><argument_list>(<argument><expr><name><name>s</name>-&gt;<name>sock_fd</name></name></expr></argument>, <argument><expr><name>FIONBIO</name></expr></argument>, <argument><expr>(<name>caddr_t</name>)&amp;<name>block</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>block</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__VMS</name></expr></argument>)</argument_list></call></expr></cpp:elif>
<expr_stmt><expr><name>block</name> = !<name>block</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ioctl</name><argument_list>(<argument><expr><name><name>s</name>-&gt;<name>sock_fd</name></name></expr></argument>, <argument><expr><name>FIONBIO</name></expr></argument>, <argument><expr>(<name>unsigned</name> <name>int</name> *)&amp;<name>block</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<expr_stmt><expr><name>delay_flag</name> = <call><name>fcntl</name><argument_list>(<argument><expr><name><name>s</name>-&gt;<name>sock_fd</name></name></expr></argument>, <argument><expr><name>F_GETFL</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>block</name></expr>)</condition><then>
<expr_stmt><expr><name>delay_flag</name> &amp;= (~<name>O_NONBLOCK</name>)</expr>;</expr_stmt></then>
<else>else
<expr_stmt><expr><name>delay_flag</name> |= <name>O_NONBLOCK</name></expr>;</expr_stmt></else></if>
<expr_stmt><expr><call><name>fcntl</name><argument_list>(<argument><expr><name><name>s</name>-&gt;<name>sock_fd</name></name></expr></argument>, <argument><expr><name>F_SETFL</name></expr></argument>, <argument><expr><name>delay_flag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<expr_stmt><expr><name>block</name> = !<name>block</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ioctlsocket</name><argument_list>(<argument><expr><name><name>s</name>-&gt;<name>sock_fd</name></name></expr></argument>, <argument><expr><name>FIONBIO</name></expr></argument>, <argument><expr>(<name>u_long</name>*)&amp;<name>block</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<expr_stmt><expr><name>block</name> = !<name>block</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>socketioctl</name><argument_list>(<argument><expr><name><name>s</name>-&gt;<name>sock_fd</name></name></expr></argument>, <argument><expr><name>FIONBIO</name></expr></argument>, <argument><expr>(<name>u_long</name>*)&amp;<name>block</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<macro><name>Py_END_ALLOW_THREADS</name></macro>
<return>return <expr>1</expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>internal_select</name><parameter_list>(<param><decl><type><name>PySocketSockObject</name> *</type><name>s</name></decl></param>, <param><decl><type><name>int</name></type> <name>writing</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>;</decl_stmt>
<if>if <condition>(<expr><name><name>s</name>-&gt;<name>sock_timeout</name></name> &lt;= 0.0</expr>)</condition><then>
<return>return <expr>0</expr>;</return></then></if>
<if>if <condition>(<expr><name><name>s</name>-&gt;<name>sock_fd</name></name> &lt; 0</expr>)</condition><then>
<return>return <expr>0</expr>;</return></then></if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_POLL</name></expr></argument>)</argument_list></call></expr></cpp:if>
<block>{
<decl_stmt><decl><type>struct <name>pollfd</name></type> <name>pollfd</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>timeout</name></decl>;</decl_stmt>
<expr_stmt><expr><name><name>pollfd</name>.<name>fd</name></name> = <name><name>s</name>-&gt;<name>sock_fd</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>pollfd</name>.<name>events</name></name> = <name>writing</name> ? <name>POLLOUT</name> : <name>POLLIN</name></expr>;</expr_stmt>
<expr_stmt><expr><name>timeout</name> = <call>(<name>int</name>)<argument_list>(<argument><expr><name><name>s</name>-&gt;<name>sock_timeout</name></name> * 1000 + 0.5</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>n</name> = <call><name>poll</name><argument_list>(<argument><expr>&amp;<name>pollfd</name></expr></argument>, <argument><expr>1</expr></argument>, <argument><expr><name>timeout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<block>{
<decl_stmt><decl><type><name>fd_set</name></type> <name>fds</name></decl>;</decl_stmt>
<decl_stmt><decl><type>struct <name>timeval</name></type> <name>tv</name></decl>;</decl_stmt>
<expr_stmt><expr><name><name>tv</name>.<name>tv_sec</name></name> = (<name>int</name>)<name><name>s</name>-&gt;<name>sock_timeout</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tv</name>.<name>tv_usec</name></name> = <call>(<name>int</name>)<argument_list>(<argument><expr>(<name><name>s</name>-&gt;<name>sock_timeout</name></name> - <name><name>tv</name>.<name>tv_sec</name></name>) * 1e6</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>FD_ZERO</name><argument_list>(<argument><expr>&amp;<name>fds</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>FD_SET</name><argument_list>(<argument><expr><name><name>s</name>-&gt;<name>sock_fd</name></name></expr></argument>, <argument><expr>&amp;<name>fds</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>writing</name></expr>)</condition><then>
<expr_stmt><expr><name>n</name> = <call><name>select</name><argument_list>(<argument><expr><name><name>s</name>-&gt;<name>sock_fd</name></name>+1</expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr>&amp;<name>fds</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr>&amp;<name>tv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
<else>else
<expr_stmt><expr><name>n</name> = <call><name>select</name><argument_list>(<argument><expr><name><name>s</name>-&gt;<name>sock_fd</name></name>+1</expr></argument>, <argument><expr>&amp;<name>fds</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr>&amp;<name>tv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<if>if <condition>(<expr><name>n</name> &lt; 0</expr>)</condition><then>
<return>return <expr>-1</expr>;</return></then></if>
<if>if <condition>(<expr><name>n</name> == 0</expr>)</condition><then>
<return>return <expr>1</expr>;</return></then></if>
<return>return <expr>0</expr>;</return>
}</block></function>
<decl_stmt><decl><type><specifier>static</specifier> <name>double</name></type> <name>defaulttimeout</name> <init>= <expr>-1.0</expr></init></decl>;</decl_stmt>
<function><type><name>PyMODINIT_FUNC</name></type>
<name>init_sockobject</name><parameter_list>(<param><decl><type><name>PySocketSockObject</name> *</type><name>s</name></decl></param>,
<param><decl><type><name>SOCKET_T</name></type> <name>fd</name></decl></param>, <param><decl><type><name>int</name></type> <name>family</name></decl></param>, <param><decl><type><name>int</name></type> <name>type</name></decl></param>, <param><decl><type><name>int</name></type> <name>proto</name></decl></param>)</parameter_list> <block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>RISCOS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>int</name></type> <name>block</name> <init>= <expr>1</expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><name><name>s</name>-&gt;<name>sock_fd</name></name> = <name>fd</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name>-&gt;<name>sock_family</name></name> = <name>family</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name>-&gt;<name>sock_type</name></name> = <name>type</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name>-&gt;<name>sock_proto</name></name> = <name>proto</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name>-&gt;<name>sock_timeout</name></name> = <name>defaulttimeout</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name>-&gt;<name>errorhandler</name></name> = &amp;<name>set_error</name></expr>;</expr_stmt>
<if>if <condition>(<expr><name>defaulttimeout</name> &gt;= 0.0</expr>)</condition><then>
<expr_stmt><expr><call><name>internal_setblocking</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>RISCOS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if>if <condition>(<expr><name>taskwindow</name></expr>)</condition><then>
<expr_stmt><expr><call><name>socketioctl</name><argument_list>(<argument><expr><name><name>s</name>-&gt;<name>sock_fd</name></name></expr></argument>, <argument><expr>0x80046679</expr></argument>, <argument><expr>(<name>u_long</name>*)&amp;<name>block</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></function>
<function><type><specifier>static</specifier> <name>PySocketSockObject</name> *</type>
<name>new_sockobject</name><parameter_list>(<param><decl><type><name>SOCKET_T</name></type> <name>fd</name></decl></param>, <param><decl><type><name>int</name></type> <name>family</name></decl></param>, <param><decl><type><name>int</name></type> <name>type</name></decl></param>, <param><decl><type><name>int</name></type> <name>proto</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PySocketSockObject</name> *</type><name>s</name></decl>;</decl_stmt>
<expr_stmt><expr><name>s</name> = (<name>PySocketSockObject</name> *)
<call><name>PyType_GenericNew</name><argument_list>(<argument><expr>&amp;<name>sock_type</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>s</name> != <name>NULL</name></expr>)</condition><then>
<expr_stmt><expr><call><name>init_sockobject</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>fd</name></expr></argument>, <argument><expr><name>family</name></expr></argument>, <argument><expr><name>type</name></expr></argument>, <argument><expr><name>proto</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<return>return <expr><name>s</name></expr>;</return>
}</block></function>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>USE_GETHOSTBYNAME_LOCK</name></expr></argument>)</argument_list></call> || <call><name>defined</name><argument_list>(<argument><expr><name>USE_GETADDRINFO_LOCK</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>PyThread_type_lock</name></type> <name>netdb_lock</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>setipaddr</name><parameter_list>(<param><decl><type><name>char</name> *</type><name>name</name></decl></param>, <param><decl><type>struct <name>sockaddr</name> *</type><name>addr_ret</name></decl></param>, <param><decl><type><name>size_t</name></type> <name>addr_ret_size</name></decl></param>, <param><decl><type><name>int</name></type> <name>af</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type>struct <name>addrinfo</name></type> <name>hints</name></decl>, *<decl><type ref="prev"/><name>res</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>error</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>d1</name></decl>, <decl><type ref="prev"/><name>d2</name></decl>, <decl><type ref="prev"/><name>d3</name></decl>, <decl><type ref="prev"/><name>d4</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name>ch</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr>(<name>void</name> *) <name>addr_ret</name></expr></argument>, <argument><expr>'\0'</expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>*<name>addr_ret</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>name</name><index>[<expr>0</expr>]</index></name> == '\0'</expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>siz</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr>&amp;<name>hints</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>hints</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>hints</name>.<name>ai_family</name></name> = <name>af</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>hints</name>.<name>ai_socktype</name></name> = <name>SOCK_DGRAM</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>hints</name>.<name>ai_flags</name></name> = <name>AI_PASSIVE</name></expr>;</expr_stmt>
<decl_stmt><decl><type><name>Py_BEGIN_ALLOW_THREADS</name>
<name>ACQUIRE_GETADDRINFO_LOCK</name></type>
<name>error</name> <init>= <expr><call><name>getaddrinfo</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr>"0"</expr></argument>, <argument><expr>&amp;<name>hints</name></expr></argument>, <argument><expr>&amp;<name>res</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>Py_END_ALLOW_THREADS</name>
<name>RELEASE_GETADDRINFO_LOCK</name></expr></expr_stmt>
<if>if <condition>(<expr><name>error</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>set_gaierror</name><argument_list>(<argument><expr><name>error</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>-1</expr>;</return>
}</block></then></if>
<switch>switch <condition>(<expr><name><name>res</name>-&gt;<name>ai_family</name></name></expr>)</condition> <block>{
<case>case <expr><name>AF_INET</name></expr>:
<expr_stmt><expr><name>siz</name> = 4</expr>;</expr_stmt>
<break>break;</break>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>ENABLE_IPV6</name></expr></argument>)</argument_list></call></expr></cpp:if>
</case><case>case <expr><name>AF_INET6</name></expr>:
<expr_stmt><expr><name>siz</name> = 16</expr>;</expr_stmt>
<break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</case><default>default:
<expr_stmt><expr><call><name>freeaddrinfo</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>socket_error</name></expr></argument>,
<argument><expr>"unsupported address family"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>-1</expr>;</return>
</default>}</block></switch>
<if>if <condition>(<expr><name><name>res</name>-&gt;<name>ai_next</name></name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>freeaddrinfo</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>socket_error</name></expr></argument>,
<argument><expr>"wildcard resolved to multiple address"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>-1</expr>;</return>
}</block></then></if>
<if>if <condition>(<expr><name><name>res</name>-&gt;<name>ai_addrlen</name></name> &lt; <name>addr_ret_size</name></expr>)</condition><then>
<expr_stmt><expr><name>addr_ret_size</name> = <name><name>res</name>-&gt;<name>ai_addrlen</name></name></expr>;</expr_stmt></then></if>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>addr_ret</name></expr></argument>, <argument><expr><name><name>res</name>-&gt;<name>ai_addr</name></name></expr></argument>, <argument><expr><name>addr_ret_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>freeaddrinfo</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>siz</name></expr>;</return>
}</block></then></if>
<if>if <condition>(<expr><name><name>name</name><index>[<expr>0</expr>]</index></name> == '&lt;' &amp;&amp; <call><name>strcmp</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr>"&lt;broadcast&gt;"</expr></argument>)</argument_list></call> == 0</expr>)</condition><then> <block>{
<decl_stmt><decl><type>struct <name>sockaddr_in</name> *</type><name>sin</name></decl>;</decl_stmt>
<if>if <condition>(<expr><name>af</name> != <name>AF_INET</name> &amp;&amp; <name>af</name> != <name>AF_UNSPEC</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>socket_error</name></expr></argument>,
<argument><expr>"address family mismatched"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>-1</expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>sin</name> = (struct <name>sockaddr_in</name> *)<name>addr_ret</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr>(<name>void</name> *) <name>sin</name></expr></argument>, <argument><expr>'\0'</expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>*<name>sin</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>sin</name>-&gt;<name>sin_family</name></name> = <name>AF_INET</name></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_SOCKADDR_SA_LEN</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><name><name>sin</name>-&gt;<name>sin_len</name></name> = <sizeof>sizeof<argument_list>(<argument><expr>*<name>sin</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><name><name>sin</name>-&gt;<name>sin_addr</name>.<name>s_addr</name></name> = <name>INADDR_BROADCAST</name></expr>;</expr_stmt>
<return>return <expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>sin</name>-&gt;<name>sin_addr</name></name></expr></argument>)</argument_list></sizeof></expr>;</return>
}</block></then></if>
<if>if <condition>(<expr><call><name>sscanf</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr>"%d.%d.%d.%d%c"</expr></argument>, <argument><expr>&amp;<name>d1</name></expr></argument>, <argument><expr>&amp;<name>d2</name></expr></argument>, <argument><expr>&amp;<name>d3</name></expr></argument>, <argument><expr>&amp;<name>d4</name></expr></argument>, <argument><expr>&amp;<name>ch</name></expr></argument>)</argument_list></call> == 4 &amp;&amp;
0 &lt;= <name>d1</name> &amp;&amp; <name>d1</name> &lt;= 255 &amp;&amp; 0 &lt;= <name>d2</name> &amp;&amp; <name>d2</name> &lt;= 255 &amp;&amp;
0 &lt;= <name>d3</name> &amp;&amp; <name>d3</name> &lt;= 255 &amp;&amp; 0 &lt;= <name>d4</name> &amp;&amp; <name>d4</name> &lt;= 255</expr>)</condition><then> <block>{
<decl_stmt><decl><type>struct <name>sockaddr_in</name> *</type><name>sin</name></decl>;</decl_stmt>
<expr_stmt><expr><name>sin</name> = (struct <name>sockaddr_in</name> *)<name>addr_ret</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>sin</name>-&gt;<name>sin_addr</name>.<name>s_addr</name></name> = <call><name>htonl</name><argument_list>(
<argument><expr>((<name>long</name>) <name>d1</name> &lt;&lt; 24) | ((<name>long</name>) <name>d2</name> &lt;&lt; 16) |
((<name>long</name>) <name>d3</name> &lt;&lt; 8) | ((<name>long</name>) <name>d4</name> &lt;&lt; 0)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>sin</name>-&gt;<name>sin_family</name></name> = <name>AF_INET</name></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_SOCKADDR_SA_LEN</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><name><name>sin</name>-&gt;<name>sin_len</name></name> = <sizeof>sizeof<argument_list>(<argument><expr>*<name>sin</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<return>return <expr>4</expr>;</return>
}</block></then></if>
<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr>&amp;<name>hints</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>hints</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>hints</name>.<name>ai_family</name></name> = <name>af</name></expr>;</expr_stmt>
<decl_stmt><decl><type><name>Py_BEGIN_ALLOW_THREADS</name>
<name>ACQUIRE_GETADDRINFO_LOCK</name></type>
<name>error</name> <init>= <expr><call><name>getaddrinfo</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr>&amp;<name>hints</name></expr></argument>, <argument><expr>&amp;<name>res</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__digital__</name></expr></argument>)</argument_list></call> &amp;&amp; <call><name>defined</name><argument_list>(<argument><expr><name>__unix__</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if>if <condition>(<expr><name>error</name> == <name>EAI_NONAME</name> &amp;&amp; <name>af</name> == <name>AF_UNSPEC</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>hints</name>.<name>ai_family</name></name> = <name>AF_INET</name></expr>;</expr_stmt>
<expr_stmt><expr><name>error</name> = <call><name>getaddrinfo</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr>&amp;<name>hints</name></expr></argument>, <argument><expr>&amp;<name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><name>Py_END_ALLOW_THREADS</name>
<name>RELEASE_GETADDRINFO_LOCK</name></expr></expr_stmt>
<if>if <condition>(<expr><name>error</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>set_gaierror</name><argument_list>(<argument><expr><name>error</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>-1</expr>;</return>
}</block></then></if>
<if>if <condition>(<expr><name><name>res</name>-&gt;<name>ai_addrlen</name></name> &lt; <name>addr_ret_size</name></expr>)</condition><then>
<expr_stmt><expr><name>addr_ret_size</name> = <name><name>res</name>-&gt;<name>ai_addrlen</name></name></expr>;</expr_stmt></then></if>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>(<name>char</name> *) <name>addr_ret</name></expr></argument>, <argument><expr><name><name>res</name>-&gt;<name>ai_addr</name></name></expr></argument>, <argument><expr><name>addr_ret_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>freeaddrinfo</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<switch>switch <condition>(<expr><name><name>addr_ret</name>-&gt;<name>sa_family</name></name></expr>)</condition> <block>{
<case>case <expr><name>AF_INET</name></expr>:
<return>return <expr>4</expr>;</return>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>ENABLE_IPV6</name></expr></argument>)</argument_list></call></expr></cpp:if>
</case><case>case <expr><name>AF_INET6</name></expr>:
<return>return <expr>16</expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</case><default>default:
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>socket_error</name></expr></argument>, <argument><expr>"unknown address family"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>-1</expr>;</return>
</default>}</block></switch>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>makeipaddr</name><parameter_list>(<param><decl><type>struct <name>sockaddr</name> *</type><name>addr</name></decl></param>, <param><decl><type><name>int</name></type> <name>addrlen</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>char</name></type> <name><name>buf</name><index>[<expr><name>NI_MAXHOST</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>error</name></decl>;</decl_stmt>
<expr_stmt><expr><name>error</name> = <call><name>getnameinfo</name><argument_list>(<argument><expr><name>addr</name></expr></argument>, <argument><expr><name>addrlen</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr>0</expr></argument>,
<argument><expr><name>NI_NUMERICHOST</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>error</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>set_gaierror</name><argument_list>(<argument><expr><name>error</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<return>return <expr><call><name>PyString_FromString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>USE_BLUETOOTH</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>setbdaddr</name><parameter_list>(<param><decl><type><name>char</name> *</type><name>name</name></decl></param>, <param><decl><type><name>bdaddr_t</name> *</type><name>bdaddr</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>b0</name></decl>, <decl><type ref="prev"/><name>b1</name></decl>, <decl><type ref="prev"/><name>b2</name></decl>, <decl><type ref="prev"/><name>b3</name></decl>, <decl><type ref="prev"/><name>b4</name></decl>, <decl><type ref="prev"/><name>b5</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name>ch</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>;</decl_stmt>
<expr_stmt><expr><name>n</name> = <call><name>sscanf</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr>"%X:%X:%X:%X:%X:%X%c"</expr></argument>,
<argument><expr>&amp;<name>b5</name></expr></argument>, <argument><expr>&amp;<name>b4</name></expr></argument>, <argument><expr>&amp;<name>b3</name></expr></argument>, <argument><expr>&amp;<name>b2</name></expr></argument>, <argument><expr>&amp;<name>b1</name></expr></argument>, <argument><expr>&amp;<name>b0</name></expr></argument>, <argument><expr>&amp;<name>ch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>n</name> == 6 &amp;&amp; (<name>b0</name> | <name>b1</name> | <name>b2</name> | <name>b3</name> | <name>b4</name> | <name>b5</name>) &lt; 256</expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>bdaddr</name>-&gt;<name>b</name><index>[<expr>0</expr>]</index></name> = <name>b0</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>bdaddr</name>-&gt;<name>b</name><index>[<expr>1</expr>]</index></name> = <name>b1</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>bdaddr</name>-&gt;<name>b</name><index>[<expr>2</expr>]</index></name> = <name>b2</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>bdaddr</name>-&gt;<name>b</name><index>[<expr>3</expr>]</index></name> = <name>b3</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>bdaddr</name>-&gt;<name>b</name><index>[<expr>4</expr>]</index></name> = <name>b4</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>bdaddr</name>-&gt;<name>b</name><index>[<expr>5</expr>]</index></name> = <name>b5</name></expr>;</expr_stmt>
<return>return <expr>6</expr>;</return>
}</block></then> <else>else <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>socket_error</name></expr></argument>, <argument><expr>"bad bluetooth address"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>-1</expr>;</return>
}</block></else></if>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>makebdaddr</name><parameter_list>(<param><decl><type><name>bdaddr_t</name> *</type><name>bdaddr</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>char</name></type> <name><name>buf</name><index>[<expr>(6 * 2) + 5 + 1</expr>]</index></name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr>"%02X:%02X:%02X:%02X:%02X:%02X"</expr></argument>,
<argument><expr><name><name>bdaddr</name>-&gt;<name>b</name><index>[<expr>5</expr>]</index></name></expr></argument>, <argument><expr><name><name>bdaddr</name>-&gt;<name>b</name><index>[<expr>4</expr>]</index></name></expr></argument>, <argument><expr><name><name>bdaddr</name>-&gt;<name>b</name><index>[<expr>3</expr>]</index></name></expr></argument>,
<argument><expr><name><name>bdaddr</name>-&gt;<name>b</name><index>[<expr>2</expr>]</index></name></expr></argument>, <argument><expr><name><name>bdaddr</name>-&gt;<name>b</name><index>[<expr>1</expr>]</index></name></expr></argument>, <argument><expr><name><name>bdaddr</name>-&gt;<name>b</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>PyString_FromString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>makesockaddr</name><parameter_list>(<param><decl><type><name>int</name></type> <name>sockfd</name></decl></param>, <param><decl><type>struct <name>sockaddr</name> *</type><name>addr</name></decl></param>, <param><decl><type><name>int</name></type> <name>addrlen</name></decl></param>, <param><decl><type><name>int</name></type> <name>proto</name></decl></param>)</parameter_list> <block>{
<if>if <condition>(<expr><name>addrlen</name> == 0</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>Py_None</name></expr>;</return>
}</block></then></if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__BEOS__</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><name><name>addr</name>-&gt;<name>sa_family</name></name> = <name>AF_INET</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<switch>switch <condition>(<expr><name><name>addr</name>-&gt;<name>sa_family</name></name></expr>)</condition> <block>{
<case>case <expr><name>AF_INET</name></expr>: <block>{
<decl_stmt><decl><type>struct <name>sockaddr_in</name> *</type><name>a</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>addrobj</name> <init>= <expr><call><name>makeipaddr</name><argument_list>(<argument><expr><name>addr</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>*<name>a</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>ret</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>addrobj</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>a</name> = (struct <name>sockaddr_in</name> *)<name>addr</name></expr>;</expr_stmt>
<expr_stmt><expr><name>ret</name> = <call><name>Py_BuildValue</name><argument_list>(<argument><expr>"Oi"</expr></argument>, <argument><expr><name>addrobj</name></expr></argument>, <argument><expr><call><name>ntohs</name><argument_list>(<argument><expr><name><name>a</name>-&gt;<name>sin_port</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>addrobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<return>return <expr><name>ret</name></expr>;</return>
}</block>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>AF_UNIX</name></expr></argument>)</argument_list></call></expr></cpp:if>
</case><case>case <expr><name>AF_UNIX</name></expr>: <block>{
<decl_stmt><decl><type>struct <name>sockaddr_un</name> *</type><name>a</name> <init>= <expr>(struct <name>sockaddr_un</name> *) <name>addr</name></expr></init></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>linux</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if>if <condition>(<expr><name><name>a</name>-&gt;<name>sun_path</name><index>[<expr>0</expr>]</index></name> == 0</expr>)</condition><then> <block>{
<expr_stmt><expr><name>addrlen</name> -= <call><name>offsetof</name><argument_list>(<argument>struct <expr><name>sockaddr_un</name></expr></argument>, <argument><expr><name>sun_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>PyString_FromStringAndSize</name><argument_list>(<argument><expr><name><name>a</name>-&gt;<name>sun_path</name></name></expr></argument>,
<argument><expr><name>addrlen</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></then> <else>else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<block>{
<return>return <expr><call><name>PyString_FromString</name><argument_list>(<argument><expr><name><name>a</name>-&gt;<name>sun_path</name></name></expr></argument>)</argument_list></call></expr>;</return>
}</block></else></if>
}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>AF_NETLINK</name></expr></argument>)</argument_list></call></expr></cpp:if>
</case><case>case <expr><name>AF_NETLINK</name></expr>: <block>{
<decl_stmt><decl><type>struct <name>sockaddr_nl</name> *</type><name>a</name> <init>= <expr>(struct <name>sockaddr_nl</name> *) <name>addr</name></expr></init></decl>;</decl_stmt>
<return>return <expr><call><name>Py_BuildValue</name><argument_list>(<argument><expr>"II"</expr></argument>, <argument><expr><name><name>a</name>-&gt;<name>nl_pid</name></name></expr></argument>, <argument><expr><name><name>a</name>-&gt;<name>nl_groups</name></name></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>ENABLE_IPV6</name></expr></argument>)</argument_list></call></expr></cpp:if>
</case><case>case <expr><name>AF_INET6</name></expr>: <block>{
<decl_stmt><decl><type>struct <name>sockaddr_in6</name> *</type><name>a</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>addrobj</name> <init>= <expr><call><name>makeipaddr</name><argument_list>(<argument><expr><name>addr</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>*<name>a</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>ret</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>addrobj</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>a</name> = (struct <name>sockaddr_in6</name> *)<name>addr</name></expr>;</expr_stmt>
<expr_stmt><expr><name>ret</name> = <call><name>Py_BuildValue</name><argument_list>(<argument><expr>"Oiii"</expr></argument>,
<argument><expr><name>addrobj</name></expr></argument>,
<argument><expr><call><name>ntohs</name><argument_list>(<argument><expr><name><name>a</name>-&gt;<name>sin6_port</name></name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name><name>a</name>-&gt;<name>sin6_flowinfo</name></name></expr></argument>,
<argument><expr><name><name>a</name>-&gt;<name>sin6_scope_id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>addrobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<return>return <expr><name>ret</name></expr>;</return>
}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>USE_BLUETOOTH</name></expr></argument>)</argument_list></call></expr></cpp:if>
</case><case>case <expr><name>AF_BLUETOOTH</name></expr>:
<switch>switch <condition>(<expr><name>proto</name></expr>)</condition> <block>{
<case>case <expr><name>BTPROTO_L2CAP</name></expr>: <block>{
<decl_stmt><decl><type>struct <name>sockaddr_l2</name> *</type><name>a</name> <init>= <expr>(struct <name>sockaddr_l2</name> *) <name>addr</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>addrobj</name> <init>= <expr><call><name>makebdaddr</name><argument_list>(<argument><expr>&amp;<call><name>_BT_L2_MEMB</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>bdaddr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>ret</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>addrobj</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>ret</name> = <call><name>Py_BuildValue</name><argument_list>(<argument><expr>"Oi"</expr></argument>,
<argument><expr><name>addrobj</name></expr></argument>,
<argument><expr><call><name>_BT_L2_MEMB</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>psm</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>addrobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<return>return <expr><name>ret</name></expr>;</return>
}</block>
</case><case>case <expr><name>BTPROTO_RFCOMM</name></expr>: <block>{
<decl_stmt><decl><type>struct <name>sockaddr_rc</name> *</type><name>a</name> <init>= <expr>(struct <name>sockaddr_rc</name> *) <name>addr</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>addrobj</name> <init>= <expr><call><name>makebdaddr</name><argument_list>(<argument><expr>&amp;<call><name>_BT_RC_MEMB</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>bdaddr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>ret</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>addrobj</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>ret</name> = <call><name>Py_BuildValue</name><argument_list>(<argument><expr>"Oi"</expr></argument>,
<argument><expr><name>addrobj</name></expr></argument>,
<argument><expr><call><name>_BT_RC_MEMB</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>channel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>addrobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<return>return <expr><name>ret</name></expr>;</return>
}</block>
</case><case>case <expr><name>BTPROTO_HCI</name></expr>: <block>{
<decl_stmt><decl><type>struct <name>sockaddr_hci</name> *</type><name>a</name> <init>= <expr>(struct <name>sockaddr_hci</name> *) <name>addr</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>ret</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>ret</name> = <call><name>Py_BuildValue</name><argument_list>(<argument><expr>"i"</expr></argument>, <argument><expr><call><name>_BT_HCI_MEMB</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>dev</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>ret</name></expr>;</return>
}</block>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>__FreeBSD__</name></expr></argument>)</argument_list></call></expr></cpp:if>
</case><case>case <expr><name>BTPROTO_SCO</name></expr>: <block>{
<decl_stmt><decl><type>struct <name>sockaddr_sco</name> *</type><name>a</name> <init>= <expr>(struct <name>sockaddr_sco</name> *) <name>addr</name></expr></init></decl>;</decl_stmt>
<return>return <expr><call><name>makebdaddr</name><argument_list>(<argument><expr>&amp;<call><name>_BT_SCO_MEMB</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>bdaddr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</case>}</block></switch>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_NETPACKET_PACKET_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
</case><case>case <expr><name>AF_PACKET</name></expr>: <block>{
<decl_stmt><decl><type>struct <name>sockaddr_ll</name> *</type><name>a</name> <init>= <expr>(struct <name>sockaddr_ll</name> *)<name>addr</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>ifname</name> <init>= <expr>""</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type>struct <name>ifreq</name></type> <name>ifr</name></decl>;</decl_stmt>
<if>if <condition>(<expr><name><name>a</name>-&gt;<name>sll_ifindex</name></name></expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>ifr</name>.<name>ifr_ifindex</name></name> = <name><name>a</name>-&gt;<name>sll_ifindex</name></name></expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>ioctl</name><argument_list>(<argument><expr><name>sockfd</name></expr></argument>, <argument><expr><name>SIOCGIFNAME</name></expr></argument>, <argument><expr>&amp;<name>ifr</name></expr></argument>)</argument_list></call> == 0</expr>)</condition><then>
<expr_stmt><expr><name>ifname</name> = <name><name>ifr</name>.<name>ifr_name</name></name></expr>;</expr_stmt></then></if>
}</block></then></if>
<return>return <expr><call><name>Py_BuildValue</name><argument_list>(<argument><expr>"shbhs#"</expr></argument>,
<argument><expr><name>ifname</name></expr></argument>,
<argument><expr><call><name>ntohs</name><argument_list>(<argument><expr><name><name>a</name>-&gt;<name>sll_protocol</name></name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name><name>a</name>-&gt;<name>sll_pkttype</name></name></expr></argument>,
<argument><expr><name><name>a</name>-&gt;<name>sll_hatype</name></name></expr></argument>,
<argument><expr><name><name>a</name>-&gt;<name>sll_addr</name></name></expr></argument>,
<argument><expr><name><name>a</name>-&gt;<name>sll_halen</name></name></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_LINUX_TIPC_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
</case><case>case <expr><name>AF_TIPC</name></expr>: <block>{
<decl_stmt><decl><type>struct <name>sockaddr_tipc</name> *</type><name>a</name> <init>= <expr>(struct <name>sockaddr_tipc</name> *) <name>addr</name></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name><name>a</name>-&gt;<name>addrtype</name></name> == <name>TIPC_ADDR_NAMESEQ</name></expr>)</condition><then> <block>{
<return>return <expr><call><name>Py_BuildValue</name><argument_list>(<argument><expr>"IIIII"</expr></argument>,
<argument><expr><name><name>a</name>-&gt;<name>addrtype</name></name></expr></argument>,
<argument><expr><name><name>a</name>-&gt;<name>addr</name>.<name>nameseq</name>.<name>type</name></name></expr></argument>,
<argument><expr><name><name>a</name>-&gt;<name>addr</name>.<name>nameseq</name>.<name>lower</name></name></expr></argument>,
<argument><expr><name><name>a</name>-&gt;<name>addr</name>.<name>nameseq</name>.<name>upper</name></name></expr></argument>,
<argument><expr><name><name>a</name>-&gt;<name>scope</name></name></expr></argument>)</argument_list></call></expr>;</return>
}</block></then> <else>else <if>if <condition>(<expr><name><name>a</name>-&gt;<name>addrtype</name></name> == <name>TIPC_ADDR_NAME</name></expr>)</condition><then> <block>{
<return>return <expr><call><name>Py_BuildValue</name><argument_list>(<argument><expr>"IIIII"</expr></argument>,
<argument><expr><name><name>a</name>-&gt;<name>addrtype</name></name></expr></argument>,
<argument><expr><name><name>a</name>-&gt;<name>addr</name>.<name>name</name>.<name>name</name>.<name>type</name></name></expr></argument>,
<argument><expr><name><name>a</name>-&gt;<name>addr</name>.<name>name</name>.<name>name</name>.<name>instance</name></name></expr></argument>,
<argument><expr><name><name>a</name>-&gt;<name>addr</name>.<name>name</name>.<name>name</name>.<name>instance</name></name></expr></argument>,
<argument><expr><name><name>a</name>-&gt;<name>scope</name></name></expr></argument>)</argument_list></call></expr>;</return>
}</block></then> <else>else <if>if <condition>(<expr><name><name>a</name>-&gt;<name>addrtype</name></name> == <name>TIPC_ADDR_ID</name></expr>)</condition><then> <block>{
<return>return <expr><call><name>Py_BuildValue</name><argument_list>(<argument><expr>"IIIII"</expr></argument>,
<argument><expr><name><name>a</name>-&gt;<name>addrtype</name></name></expr></argument>,
<argument><expr><name><name>a</name>-&gt;<name>addr</name>.<name>id</name>.<name>node</name></name></expr></argument>,
<argument><expr><name><name>a</name>-&gt;<name>addr</name>.<name>id</name>.<name>ref</name></name></expr></argument>,
<argument><expr>0</expr></argument>,
<argument><expr><name><name>a</name>-&gt;<name>scope</name></name></expr></argument>)</argument_list></call></expr>;</return>
}</block></then> <else>else <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
<argument><expr>"Invalid address type"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></else></if></else></if></else></if>
}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</case><default>default:
<return>return <expr><call><name>Py_BuildValue</name><argument_list>(<argument><expr>"is#"</expr></argument>,
<argument><expr><name><name>addr</name>-&gt;<name>sa_family</name></name></expr></argument>,
<argument><expr><name><name>addr</name>-&gt;<name>sa_data</name></name></expr></argument>,
<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>addr</name>-&gt;<name>sa_data</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</return>
</default>}</block></switch>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>getsockaddrarg</name><parameter_list>(<param><decl><type><name>PySocketSockObject</name> *</type><name>s</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>,
<param><decl><type>struct <name>sockaddr</name> *</type><name>addr_ret</name></decl></param>, <param><decl><type><name>int</name> *</type><name>len_ret</name></decl></param>)</parameter_list> <block>{
<switch>switch <condition>(<expr><name><name>s</name>-&gt;<name>sock_family</name></name></expr>)</condition> <block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>AF_UNIX</name></expr></argument>)</argument_list></call></expr></cpp:if>
<case>case <expr><name>AF_UNIX</name></expr>: <block>{
<decl_stmt><decl><type>struct <name>sockaddr_un</name>*</type> <name>addr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>path</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>len</name></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>PyArg_Parse</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"t#"</expr></argument>, <argument><expr>&amp;<name>path</name></expr></argument>, <argument><expr>&amp;<name>len</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr>0</expr>;</return></then></if>
<expr_stmt><expr><name>addr</name> = (struct <name>sockaddr_un</name>*)<name>addr_ret</name></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>linux</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if>if <condition>(<expr><name>len</name> &gt; 0 &amp;&amp; <name><name>path</name><index>[<expr>0</expr>]</index></name> == 0</expr>)</condition><then> <block>{
<if>if <condition>(<expr><name>len</name> &gt; sizeof <name><name>addr</name>-&gt;<name>sun_path</name></name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>socket_error</name></expr></argument>,
<argument><expr>"AF_UNIX path too long"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>0</expr>;</return>
}</block></then></if>
}</block></then> <else>else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<block>{
<if>if <condition>(<expr><name>len</name> &gt;= sizeof <name><name>addr</name>-&gt;<name>sun_path</name></name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>socket_error</name></expr></argument>,
<argument><expr>"AF_UNIX path too long"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>0</expr>;</return>
}</block></then></if>
<expr_stmt><expr><name><name>addr</name>-&gt;<name>sun_path</name><index>[<expr><name>len</name></expr>]</index></name> = 0</expr>;</expr_stmt>
}</block></else></if>
<expr_stmt><expr><name><name>addr</name>-&gt;<name>sun_family</name></name> = <name><name>s</name>-&gt;<name>sock_family</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>addr</name>-&gt;<name>sun_path</name></name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>PYOS_OS2</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr>*<name>len_ret</name> = <sizeof>sizeof<argument_list>(<argument><expr>*<name>addr</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<expr_stmt><expr>*<name>len_ret</name> = <name>len</name> + <call><name>offsetof</name><argument_list>(<argument>struct <expr><name>sockaddr_un</name></expr></argument>, <argument><expr><name>sun_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<return>return <expr>1</expr>;</return>
}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>AF_NETLINK</name></expr></argument>)</argument_list></call></expr></cpp:if>
</case><case>case <expr><name>AF_NETLINK</name></expr>: <block>{
<decl_stmt><decl><type>struct <name>sockaddr_nl</name>*</type> <name>addr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>pid</name></decl>, <decl><type ref="prev"/><name>groups</name></decl>;</decl_stmt>
<expr_stmt><expr><name>addr</name> = (struct <name>sockaddr_nl</name> *)<name>addr_ret</name></expr>;</expr_stmt>
<if>if <condition>(<expr>!<call><name>PyTuple_Check</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(
<argument><expr><name>PyExc_TypeError</name></expr></argument>,
<argument><expr>"getsockaddrarg: "
"AF_NETLINK address must be tuple, not %.500s"</expr></argument>,
<argument><expr><call><name>Py_TYPE</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call>-&gt;<name>tp_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>0</expr>;</return>
}</block></then></if>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"II:getsockaddrarg"</expr></argument>, <argument><expr>&amp;<name>pid</name></expr></argument>, <argument><expr>&amp;<name>groups</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr>0</expr>;</return></then></if>
<expr_stmt><expr><name><name>addr</name>-&gt;<name>nl_family</name></name> = <name>AF_NETLINK</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>addr</name>-&gt;<name>nl_pid</name></name> = <name>pid</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>addr</name>-&gt;<name>nl_groups</name></name> = <name>groups</name></expr>;</expr_stmt>
<expr_stmt><expr>*<name>len_ret</name> = <sizeof>sizeof<argument_list>(<argument><expr>*<name>addr</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
<return>return <expr>1</expr>;</return>
}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</case><case>case <expr><name>AF_INET</name></expr>: <block>{
<decl_stmt><decl><type>struct <name>sockaddr_in</name>*</type> <name>addr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>host</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>port</name></decl>, <decl><type ref="prev"/><name>result</name></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>PyTuple_Check</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(
<argument><expr><name>PyExc_TypeError</name></expr></argument>,
<argument><expr>"getsockaddrarg: "
"AF_INET address must be tuple, not %.500s"</expr></argument>,
<argument><expr><call><name>Py_TYPE</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call>-&gt;<name>tp_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>0</expr>;</return>
}</block></then></if>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"eti:getsockaddrarg"</expr></argument>,
<argument><expr>"idna"</expr></argument>, <argument><expr>&amp;<name>host</name></expr></argument>, <argument><expr>&amp;<name>port</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr>0</expr>;</return></then></if>
<expr_stmt><expr><name>addr</name>=(struct <name>sockaddr_in</name>*)<name>addr_ret</name></expr>;</expr_stmt>
<expr_stmt><expr><name>result</name> = <call><name>setipaddr</name><argument_list>(<argument><expr><name>host</name></expr></argument>, <argument><expr>(struct <name>sockaddr</name> *)<name>addr</name></expr></argument>,
<argument><expr><sizeof>sizeof<argument_list>(<argument><expr>*<name>addr</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>AF_INET</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyMem_Free</name><argument_list>(<argument><expr><name>host</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>result</name> &lt; 0</expr>)</condition><then>
<return>return <expr>0</expr>;</return></then></if>
<expr_stmt><expr><name><name>addr</name>-&gt;<name>sin_family</name></name> = <name>AF_INET</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>addr</name>-&gt;<name>sin_port</name></name> = <call><name>htons</name><argument_list>(<argument><expr>(<name>short</name>)<name>port</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr>*<name>len_ret</name> = sizeof *<name>addr</name></expr>;</expr_stmt>
<return>return <expr>1</expr>;</return>
}</block>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>ENABLE_IPV6</name></expr></argument>)</argument_list></call></expr></cpp:if>
</case><case>case <expr><name>AF_INET6</name></expr>: <block>{
<decl_stmt><decl><type>struct <name>sockaddr_in6</name>*</type> <name>addr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>host</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>port</name></decl>, <decl><type ref="prev"/><name>flowinfo</name></decl>, <decl><type ref="prev"/><name>scope_id</name></decl>, <decl><type ref="prev"/><name>result</name></decl>;</decl_stmt>
<expr_stmt><expr><name>flowinfo</name> = <name>scope_id</name> = 0</expr>;</expr_stmt>
<if>if <condition>(<expr>!<call><name>PyTuple_Check</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(
<argument><expr><name>PyExc_TypeError</name></expr></argument>,
<argument><expr>"getsockaddrarg: "
"AF_INET6 address must be tuple, not %.500s"</expr></argument>,
<argument><expr><call><name>Py_TYPE</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call>-&gt;<name>tp_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>0</expr>;</return>
}</block></then></if>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"eti|ii"</expr></argument>,
<argument><expr>"idna"</expr></argument>, <argument><expr>&amp;<name>host</name></expr></argument>, <argument><expr>&amp;<name>port</name></expr></argument>, <argument><expr>&amp;<name>flowinfo</name></expr></argument>,
<argument><expr>&amp;<name>scope_id</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<return>return <expr>0</expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>addr</name> = (struct <name>sockaddr_in6</name>*)<name>addr_ret</name></expr>;</expr_stmt>
<expr_stmt><expr><name>result</name> = <call><name>setipaddr</name><argument_list>(<argument><expr><name>host</name></expr></argument>, <argument><expr>(struct <name>sockaddr</name> *)<name>addr</name></expr></argument>,
<argument><expr><sizeof>sizeof<argument_list>(<argument><expr>*<name>addr</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>AF_INET6</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyMem_Free</name><argument_list>(<argument><expr><name>host</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>result</name> &lt; 0</expr>)</condition><then>
<return>return <expr>0</expr>;</return></then></if>
<expr_stmt><expr><name><name>addr</name>-&gt;<name>sin6_family</name></name> = <name><name>s</name>-&gt;<name>sock_family</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>addr</name>-&gt;<name>sin6_port</name></name> = <call><name>htons</name><argument_list>(<argument><expr>(<name>short</name>)<name>port</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>addr</name>-&gt;<name>sin6_flowinfo</name></name> = <name>flowinfo</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>addr</name>-&gt;<name>sin6_scope_id</name></name> = <name>scope_id</name></expr>;</expr_stmt>
<expr_stmt><expr>*<name>len_ret</name> = sizeof *<name>addr</name></expr>;</expr_stmt>
<return>return <expr>1</expr>;</return>
}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>USE_BLUETOOTH</name></expr></argument>)</argument_list></call></expr></cpp:if>
</case><case>case <expr><name>AF_BLUETOOTH</name></expr>: <block>{
<switch>switch <condition>(<expr><name><name>s</name>-&gt;<name>sock_proto</name></name></expr>)</condition> <block>{
<case>case <expr><name>BTPROTO_L2CAP</name></expr>: <block>{
<decl_stmt><decl><type>struct <name>sockaddr_l2</name> *</type><name>addr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>straddr</name></decl>;</decl_stmt>
<expr_stmt><expr><name>addr</name> = (struct <name>sockaddr_l2</name> *)<name>addr_ret</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>_BT_L2_MEMB</name><argument_list>(<argument><expr><name>addr</name></expr></argument>, <argument><expr><name>family</name></expr></argument>)</argument_list></call> = <name>AF_BLUETOOTH</name></expr>;</expr_stmt>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"si"</expr></argument>, <argument><expr>&amp;<name>straddr</name></expr></argument>,
<argument><expr>&amp;<call><name>_BT_L2_MEMB</name><argument_list>(<argument><expr><name>addr</name></expr></argument>, <argument><expr><name>psm</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>socket_error</name></expr></argument>, <argument><expr>"getsockaddrarg: "
"wrong format"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>0</expr>;</return>
}</block></then></if>
<if>if <condition>(<expr><call><name>setbdaddr</name><argument_list>(<argument><expr><name>straddr</name></expr></argument>, <argument><expr>&amp;<call><name>_BT_L2_MEMB</name><argument_list>(<argument><expr><name>addr</name></expr></argument>, <argument><expr><name>bdaddr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
<return>return <expr>0</expr>;</return></then></if>
<expr_stmt><expr>*<name>len_ret</name> = sizeof *<name>addr</name></expr>;</expr_stmt>
<return>return <expr>1</expr>;</return>
}</block>
</case><case>case <expr><name>BTPROTO_RFCOMM</name></expr>: <block>{
<decl_stmt><decl><type>struct <name>sockaddr_rc</name> *</type><name>addr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>straddr</name></decl>;</decl_stmt>
<expr_stmt><expr><name>addr</name> = (struct <name>sockaddr_rc</name> *)<name>addr_ret</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>_BT_RC_MEMB</name><argument_list>(<argument><expr><name>addr</name></expr></argument>, <argument><expr><name>family</name></expr></argument>)</argument_list></call> = <name>AF_BLUETOOTH</name></expr>;</expr_stmt>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"si"</expr></argument>, <argument><expr>&amp;<name>straddr</name></expr></argument>,
<argument><expr>&amp;<call><name>_BT_RC_MEMB</name><argument_list>(<argument><expr><name>addr</name></expr></argument>, <argument><expr><name>channel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>socket_error</name></expr></argument>, <argument><expr>"getsockaddrarg: "
"wrong format"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>0</expr>;</return>
}</block></then></if>
<if>if <condition>(<expr><call><name>setbdaddr</name><argument_list>(<argument><expr><name>straddr</name></expr></argument>, <argument><expr>&amp;<call><name>_BT_RC_MEMB</name><argument_list>(<argument><expr><name>addr</name></expr></argument>, <argument><expr><name>bdaddr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
<return>return <expr>0</expr>;</return></then></if>
<expr_stmt><expr>*<name>len_ret</name> = sizeof *<name>addr</name></expr>;</expr_stmt>
<return>return <expr>1</expr>;</return>
}</block>
</case><case>case <expr><name>BTPROTO_HCI</name></expr>: <block>{
<decl_stmt><decl><type>struct <name>sockaddr_hci</name> *</type><name>addr</name> <init>= <expr>(struct <name>sockaddr_hci</name> *)<name>addr_ret</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>_BT_HCI_MEMB</name><argument_list>(<argument><expr><name>addr</name></expr></argument>, <argument><expr><name>family</name></expr></argument>)</argument_list></call> = <name>AF_BLUETOOTH</name></expr>;</expr_stmt>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"i"</expr></argument>, <argument><expr>&amp;<call><name>_BT_HCI_MEMB</name><argument_list>(<argument><expr><name>addr</name></expr></argument>, <argument><expr><name>dev</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>socket_error</name></expr></argument>, <argument><expr>"getsockaddrarg: "
"wrong format"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>0</expr>;</return>
}</block></then></if>
<expr_stmt><expr>*<name>len_ret</name> = sizeof *<name>addr</name></expr>;</expr_stmt>
<return>return <expr>1</expr>;</return>
}</block>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>__FreeBSD__</name></expr></argument>)</argument_list></call></expr></cpp:if>
</case><case>case <expr><name>BTPROTO_SCO</name></expr>: <block>{
<decl_stmt><decl><type>struct <name>sockaddr_sco</name> *</type><name>addr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>straddr</name></decl>;</decl_stmt>
<expr_stmt><expr><name>addr</name> = (struct <name>sockaddr_sco</name> *)<name>addr_ret</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>_BT_SCO_MEMB</name><argument_list>(<argument><expr><name>addr</name></expr></argument>, <argument><expr><name>family</name></expr></argument>)</argument_list></call> = <name>AF_BLUETOOTH</name></expr>;</expr_stmt>
<expr_stmt><expr><name>straddr</name> = <call><name>PyString_AsString</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>straddr</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>socket_error</name></expr></argument>, <argument><expr>"getsockaddrarg: "
"wrong format"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>0</expr>;</return>
}</block></then></if>
<if>if <condition>(<expr><call><name>setbdaddr</name><argument_list>(<argument><expr><name>straddr</name></expr></argument>, <argument><expr>&amp;<call><name>_BT_SCO_MEMB</name><argument_list>(<argument><expr><name>addr</name></expr></argument>, <argument><expr><name>bdaddr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
<return>return <expr>0</expr>;</return></then></if>
<expr_stmt><expr>*<name>len_ret</name> = sizeof *<name>addr</name></expr>;</expr_stmt>
<return>return <expr>1</expr>;</return>
}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</case><default>default:
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>socket_error</name></expr></argument>, <argument><expr>"getsockaddrarg: unknown Bluetooth protocol"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>0</expr>;</return>
</default>}</block></switch>
}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_NETPACKET_PACKET_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
</case><case>case <expr><name>AF_PACKET</name></expr>: <block>{
<decl_stmt><decl><type>struct <name>sockaddr_ll</name>*</type> <name>addr</name></decl>;</decl_stmt>
<decl_stmt><decl><type>struct <name>ifreq</name></type> <name>ifr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>interfaceName</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>protoNumber</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>hatype</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>pkttype</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>haddr</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>halen</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>PyTuple_Check</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(
<argument><expr><name>PyExc_TypeError</name></expr></argument>,
<argument><expr>"getsockaddrarg: "
"AF_PACKET address must be tuple, not %.500s"</expr></argument>,
<argument><expr><call><name>Py_TYPE</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call>-&gt;<name>tp_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>0</expr>;</return>
}</block></then></if>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"si|iis#"</expr></argument>, <argument><expr>&amp;<name>interfaceName</name></expr></argument>,
<argument><expr>&amp;<name>protoNumber</name></expr></argument>, <argument><expr>&amp;<name>pkttype</name></expr></argument>, <argument><expr>&amp;<name>hatype</name></expr></argument>,
<argument><expr>&amp;<name>haddr</name></expr></argument>, <argument><expr>&amp;<name>halen</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr>0</expr>;</return></then></if>
<expr_stmt><expr><call><name>strncpy</name><argument_list>(<argument><expr><name><name>ifr</name>.<name>ifr_name</name></name></expr></argument>, <argument><expr><name>interfaceName</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>ifr</name>.<name>ifr_name</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ifr</name>.<name>ifr_name</name><index>[<expr>(<sizeof>sizeof<argument_list>(<argument><expr><name><name>ifr</name>.<name>ifr_name</name></name></expr></argument>)</argument_list></sizeof>)-1</expr>]</index></name> = '\0'</expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>ioctl</name><argument_list>(<argument><expr><name><name>s</name>-&gt;<name>sock_fd</name></name></expr></argument>, <argument><expr><name>SIOCGIFINDEX</name></expr></argument>, <argument><expr>&amp;<name>ifr</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name><name>s</name>-&gt;<name>errorhandler</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<return>return <expr>0</expr>;</return>
}</block></then></if>
<if>if <condition>(<expr><name>halen</name> &gt; 8</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>,
<argument><expr>"Hardware address must be 8 bytes or less"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>0</expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>addr</name> = (struct <name>sockaddr_ll</name>*)<name>addr_ret</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>addr</name>-&gt;<name>sll_family</name></name> = <name>AF_PACKET</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>addr</name>-&gt;<name>sll_protocol</name></name> = <call><name>htons</name><argument_list>(<argument><expr>(<name>short</name>)<name>protoNumber</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>addr</name>-&gt;<name>sll_ifindex</name></name> = <name><name>ifr</name>.<name>ifr_ifindex</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>addr</name>-&gt;<name>sll_pkttype</name></name> = <name>pkttype</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>addr</name>-&gt;<name>sll_hatype</name></name> = <name>hatype</name></expr>;</expr_stmt>
<if>if <condition>(<expr><name>halen</name> != 0</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name><name>addr</name>-&gt;<name>sll_addr</name></name></expr></argument>, <argument><expr><name>haddr</name></expr></argument>, <argument><expr><name>halen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><name><name>addr</name>-&gt;<name>sll_halen</name></name> = <name>halen</name></expr>;</expr_stmt>
<expr_stmt><expr>*<name>len_ret</name> = sizeof *<name>addr</name></expr>;</expr_stmt>
<return>return <expr>1</expr>;</return>
}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_LINUX_TIPC_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
</case><case>case <expr><name>AF_TIPC</name></expr>: <block>{
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>atype</name></decl>, <decl><type ref="prev"/><name>v1</name></decl>, <decl><type ref="prev"/><name>v2</name></decl>, <decl><type ref="prev"/><name>v3</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>scope</name> <init>= <expr><name>TIPC_CLUSTER_SCOPE</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type>struct <name>sockaddr_tipc</name> *</type><name>addr</name></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>PyTuple_Check</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(
<argument><expr><name>PyExc_TypeError</name></expr></argument>,
<argument><expr>"getsockaddrarg: "
"AF_TIPC address must be tuple, not %.500s"</expr></argument>,
<argument><expr><call><name>Py_TYPE</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call>-&gt;<name>tp_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>0</expr>;</return>
}</block></then></if>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>,
<argument><expr>"IIII|I;Invalid TIPC address format"</expr></argument>,
<argument><expr>&amp;<name>atype</name></expr></argument>, <argument><expr>&amp;<name>v1</name></expr></argument>, <argument><expr>&amp;<name>v2</name></expr></argument>, <argument><expr>&amp;<name>v3</name></expr></argument>, <argument><expr>&amp;<name>scope</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr>0</expr>;</return></then></if>
<expr_stmt><expr><name>addr</name> = (struct <name>sockaddr_tipc</name> *) <name>addr_ret</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>addr</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument>struct <expr><name>sockaddr_tipc</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>addr</name>-&gt;<name>family</name></name> = <name>AF_TIPC</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>addr</name>-&gt;<name>scope</name></name> = <name>scope</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>addr</name>-&gt;<name>addrtype</name></name> = <name>atype</name></expr>;</expr_stmt>
<if>if <condition>(<expr><name>atype</name> == <name>TIPC_ADDR_NAMESEQ</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>addr</name>-&gt;<name>addr</name>.<name>nameseq</name>.<name>type</name></name> = <name>v1</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>addr</name>-&gt;<name>addr</name>.<name>nameseq</name>.<name>lower</name></name> = <name>v2</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>addr</name>-&gt;<name>addr</name>.<name>nameseq</name>.<name>upper</name></name> = <name>v3</name></expr>;</expr_stmt>
}</block></then> <else>else <if>if <condition>(<expr><name>atype</name> == <name>TIPC_ADDR_NAME</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>addr</name>-&gt;<name>addr</name>.<name>name</name>.<name>name</name>.<name>type</name></name> = <name>v1</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>addr</name>-&gt;<name>addr</name>.<name>name</name>.<name>name</name>.<name>instance</name></name> = <name>v2</name></expr>;</expr_stmt>
}</block></then> <else>else <if>if <condition>(<expr><name>atype</name> == <name>TIPC_ADDR_ID</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>addr</name>-&gt;<name>addr</name>.<name>id</name>.<name>node</name></name> = <name>v1</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>addr</name>-&gt;<name>addr</name>.<name>id</name>.<name>ref</name></name> = <name>v2</name></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>, <argument><expr>"Invalid address type"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>0</expr>;</return>
}</block></else></if></else></if></else></if>
<expr_stmt><expr>*<name>len_ret</name> = <sizeof>sizeof<argument_list>(<argument><expr>*<name>addr</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
<return>return <expr>1</expr>;</return>
}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</case><default>default:
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>socket_error</name></expr></argument>, <argument><expr>"getsockaddrarg: bad family"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>0</expr>;</return>
</default>}</block></switch>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>getsockaddrlen</name><parameter_list>(<param><decl><type><name>PySocketSockObject</name> *</type><name>s</name></decl></param>, <param><decl><type><name>socklen_t</name> *</type><name>len_ret</name></decl></param>)</parameter_list> <block>{
<switch>switch <condition>(<expr><name><name>s</name>-&gt;<name>sock_family</name></name></expr>)</condition> <block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>AF_UNIX</name></expr></argument>)</argument_list></call></expr></cpp:if>
<case>case <expr><name>AF_UNIX</name></expr>: <block>{
<expr_stmt><expr>*<name>len_ret</name> = <sizeof>sizeof <argument_list>(<argument>struct <expr><name>sockaddr_un</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
<return>return <expr>1</expr>;</return>
}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>AF_NETLINK</name></expr></argument>)</argument_list></call></expr></cpp:if>
</case><case>case <expr><name>AF_NETLINK</name></expr>: <block>{
<expr_stmt><expr>*<name>len_ret</name> = <sizeof>sizeof <argument_list>(<argument>struct <expr><name>sockaddr_nl</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
<return>return <expr>1</expr>;</return>
}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</case><case>case <expr><name>AF_INET</name></expr>: <block>{
<expr_stmt><expr>*<name>len_ret</name> = <sizeof>sizeof <argument_list>(<argument>struct <expr><name>sockaddr_in</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
<return>return <expr>1</expr>;</return>
}</block>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>ENABLE_IPV6</name></expr></argument>)</argument_list></call></expr></cpp:if>
</case><case>case <expr><name>AF_INET6</name></expr>: <block>{
<expr_stmt><expr>*<name>len_ret</name> = <sizeof>sizeof <argument_list>(<argument>struct <expr><name>sockaddr_in6</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
<return>return <expr>1</expr>;</return>
}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>USE_BLUETOOTH</name></expr></argument>)</argument_list></call></expr></cpp:if>
</case><case>case <expr><name>AF_BLUETOOTH</name></expr>: <block>{
<switch>switch<condition>(<expr><name><name>s</name>-&gt;<name>sock_proto</name></name></expr>)</condition> <block>{
<case>case <expr><name>BTPROTO_L2CAP</name></expr>:
<expr_stmt><expr>*<name>len_ret</name> = <sizeof>sizeof <argument_list>(<argument>struct <expr><name>sockaddr_l2</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
<return>return <expr>1</expr>;</return>
</case><case>case <expr><name>BTPROTO_RFCOMM</name></expr>:
<expr_stmt><expr>*<name>len_ret</name> = <sizeof>sizeof <argument_list>(<argument>struct <expr><name>sockaddr_rc</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
<return>return <expr>1</expr>;</return>
</case><case>case <expr><name>BTPROTO_HCI</name></expr>:
<expr_stmt><expr>*<name>len_ret</name> = <sizeof>sizeof <argument_list>(<argument>struct <expr><name>sockaddr_hci</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
<return>return <expr>1</expr>;</return>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>__FreeBSD__</name></expr></argument>)</argument_list></call></expr></cpp:if>
</case><case>case <expr><name>BTPROTO_SCO</name></expr>:
<expr_stmt><expr>*<name>len_ret</name> = <sizeof>sizeof <argument_list>(<argument>struct <expr><name>sockaddr_sco</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
<return>return <expr>1</expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</case><default>default:
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>socket_error</name></expr></argument>, <argument><expr>"getsockaddrlen: "
"unknown BT protocol"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>0</expr>;</return>
</default>}</block></switch>
}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_NETPACKET_PACKET_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
</case><case>case <expr><name>AF_PACKET</name></expr>: <block>{
<expr_stmt><expr>*<name>len_ret</name> = <sizeof>sizeof <argument_list>(<argument>struct <expr><name>sockaddr_ll</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
<return>return <expr>1</expr>;</return>
}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_LINUX_TIPC_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
</case><case>case <expr><name>AF_TIPC</name></expr>: <block>{
<expr_stmt><expr>*<name>len_ret</name> = <sizeof>sizeof <argument_list>(<argument>struct <expr><name>sockaddr_tipc</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
<return>return <expr>1</expr>;</return>
}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</case><default>default:
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>socket_error</name></expr></argument>, <argument><expr>"getsockaddrlen: bad family"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>0</expr>;</return>
</default>}</block></switch>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>sock_accept</name><parameter_list>(<param><decl><type><name>PySocketSockObject</name> *</type><name>s</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>sock_addr_t</name></type> <name>addrbuf</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>SOCKET_T</name></type> <name>newfd</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>socklen_t</name></type> <name>addrlen</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>sock</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>addr</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>res</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>timeout</name></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>getsockaddrlen</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr>&amp;<name>addrlen</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr>&amp;<name>addrbuf</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>addrlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MS_WINDOWS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><name>newfd</name> = <name>INVALID_SOCKET</name></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<expr_stmt><expr><name>newfd</name> = -1</expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<if>if <condition>(<expr>!<call><name>IS_SELECTABLE</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><call><name>select_error</name><argument_list>()</argument_list></call></expr>;</return></then></if>
<decl_stmt><decl><type><name>Py_BEGIN_ALLOW_THREADS</name></type>
<name>timeout</name> <init>= <expr><call><name>internal_select</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr>!<name>timeout</name></expr>)</condition><then>
<expr_stmt><expr><name>newfd</name> = <call><name>accept</name><argument_list>(<argument><expr><name><name>s</name>-&gt;<name>sock_fd</name></name></expr></argument>, <argument><expr><call><name>SAS2SA</name><argument_list>(<argument><expr>&amp;<name>addrbuf</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>&amp;<name>addrlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<macro><name>Py_END_ALLOW_THREADS</name></macro>
<if>if <condition>(<expr><name>timeout</name> == 1</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>socket_timeout</name></expr></argument>, <argument><expr>"timed out"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MS_WINDOWS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if>if <condition>(<expr><name>newfd</name> == <name>INVALID_SOCKET</name></expr>)</condition><then>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<if>if <condition>(<expr><name>newfd</name> &lt; 0</expr>)</condition><then>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<return>return <expr><call><name><name>s</name>-&gt;<name>errorhandler</name></name><argument_list>()</argument_list></call></expr>;</return></then></if></then></if>
<expr_stmt><expr><name>sock</name> = (<name>PyObject</name> *) <call><name>new_sockobject</name><argument_list>(<argument><expr><name>newfd</name></expr></argument>,
<argument><expr><name><name>s</name>-&gt;<name>sock_family</name></name></expr></argument>,
<argument><expr><name><name>s</name>-&gt;<name>sock_type</name></name></expr></argument>,
<argument><expr><name><name>s</name>-&gt;<name>sock_proto</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>sock</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>SOCKETCLOSE</name><argument_list>(<argument><expr><name>newfd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>finally</name>;</goto>
}</block></then></if>
<expr_stmt><expr><name>addr</name> = <call><name>makesockaddr</name><argument_list>(<argument><expr><name><name>s</name>-&gt;<name>sock_fd</name></name></expr></argument>, <argument><expr><call><name>SAS2SA</name><argument_list>(<argument><expr>&amp;<name>addrbuf</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>addrlen</name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>sock_proto</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>addr</name> == <name>NULL</name></expr>)</condition><then>
<goto>goto <name>finally</name>;</goto></then></if>
<expr_stmt><expr><name>res</name> = <call><name>PyTuple_Pack</name><argument_list>(<argument><expr>2</expr></argument>, <argument><expr><name>sock</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<label><name>finally</name>:</label>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>sock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>res</name></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>accept_doc</name></expr></argument>,
<argument><expr>"accept() -&gt; (socket object, address info)\n\
\n\
Wait for an incoming connection. Return a new socket representing the\n\
connection, and the address of the client. For IP sockets, the address\n\
info is a pair (hostaddr, port)."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>sock_setblocking</name><parameter_list>(<param><decl><type><name>PySocketSockObject</name> *</type><name>s</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>arg</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>block</name></decl>;</decl_stmt>
<expr_stmt><expr><name>block</name> = <call><name>PyInt_AsLong</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>block</name> == -1 &amp;&amp; <call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name><name>s</name>-&gt;<name>sock_timeout</name></name> = <name>block</name> ? -1.0 : 0.0</expr>;</expr_stmt>
<expr_stmt><expr><call><name>internal_setblocking</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>block</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>Py_None</name></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>setblocking_doc</name></expr></argument>,
<argument><expr>"setblocking(flag)\n\
\n\
Set the socket to blocking (flag is true) or non-blocking (false).\n\
setblocking(True) is equivalent to settimeout(None);\n\
setblocking(False) is equivalent to settimeout(0.0)."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>sock_settimeout</name><parameter_list>(<param><decl><type><name>PySocketSockObject</name> *</type><name>s</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>arg</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>double</name></type> <name>timeout</name></decl>;</decl_stmt>
<if>if <condition>(<expr><name>arg</name> == <name>Py_None</name></expr>)</condition><then>
<expr_stmt><expr><name>timeout</name> = -1.0</expr>;</expr_stmt></then>
<else>else <block>{
<expr_stmt><expr><name>timeout</name> = <call><name>PyFloat_AsDouble</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>timeout</name> &lt; 0.0</expr>)</condition><then> <block>{
<if>if <condition>(<expr>!<call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then>
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>,
<argument><expr>"Timeout value out of range"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
}</block></else></if>
<expr_stmt><expr><name><name>s</name>-&gt;<name>sock_timeout</name></name> = <name>timeout</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>internal_setblocking</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>timeout</name> &lt; 0.0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>Py_None</name></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>settimeout_doc</name></expr></argument>,
<argument><expr>"settimeout(timeout)\n\
\n\
Set a timeout on socket operations. 'timeout' can be a float,\n\
giving in seconds, or None. Setting a timeout of None disables\n\
the timeout feature and is equivalent to setblocking(1).\n\
Setting a timeout of zero is the same as setblocking(0)."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>sock_gettimeout</name><parameter_list>(<param><decl><type><name>PySocketSockObject</name> *</type><name>s</name></decl></param>)</parameter_list> <block>{
<if>if <condition>(<expr><name><name>s</name>-&gt;<name>sock_timeout</name></name> &lt; 0.0</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>Py_None</name></expr>;</return>
}</block></then> <else>else
<return>return <expr><call><name>PyFloat_FromDouble</name><argument_list>(<argument><expr><name><name>s</name>-&gt;<name>sock_timeout</name></name></expr></argument>)</argument_list></call></expr>;</return></else></if>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>gettimeout_doc</name></expr></argument>,
<argument><expr>"gettimeout() -&gt; timeout\n\
\n\
Returns the timeout in floating seconds associated with socket \n\
operations. A timeout of None indicates that timeouts on socket \n\
operations are disabled."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>RISCOS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>sock_sleeptaskw</name><parameter_list>(<param><decl><type><name>PySocketSockObject</name> *</type><name>s</name></decl></param>,<param><decl><type><name>PyObject</name> *</type><name>arg</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>block</name></decl>;</decl_stmt>
<expr_stmt><expr><name>block</name> = <call><name>PyInt_AsLong</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>block</name> == -1 &amp;&amp; <call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<decl_stmt><decl><type><name>Py_BEGIN_ALLOW_THREADS</name></type>
<name>socketioctl</name><argument_list>(<argument><expr><name><name>s</name>-&gt;<name>sock_fd</name></name></expr></argument>, <argument><expr>0x80046679</expr></argument>, <argument><expr>(<name>u_long</name>*)&amp;<name>block</name></expr></argument>)</argument_list></decl>;</decl_stmt>
<function_decl><type><name>Py_END_ALLOW_THREADS</name></type>
<name>Py_INCREF</name><parameter_list>(<param><decl><type><name>Py_None</name></type></decl></param>)</parameter_list>;</function_decl>
<return>return <expr><name>Py_None</name></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>sleeptaskw_doc</name></expr></argument>,
<argument><expr>"sleeptaskw(flag)\n\
\n\
Allow sleeps in taskwindows."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>sock_setsockopt</name><parameter_list>(<param><decl><type><name>PySocketSockObject</name> *</type><name>s</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>level</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>optname</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>res</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>buf</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>buflen</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>flag</name></decl>;</decl_stmt>
<if>if <condition>(<expr><call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"iii:setsockopt"</expr></argument>,
<argument><expr>&amp;<name>level</name></expr></argument>, <argument><expr>&amp;<name>optname</name></expr></argument>, <argument><expr>&amp;<name>flag</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><name>buf</name> = (<name>char</name> *) &amp;<name>flag</name></expr>;</expr_stmt>
<expr_stmt><expr><name>buflen</name> = sizeof <name>flag</name></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr><call><name>PyErr_Clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"iis#:setsockopt"</expr></argument>,
<argument><expr>&amp;<name>level</name></expr></argument>, <argument><expr>&amp;<name>optname</name></expr></argument>, <argument><expr>&amp;<name>buf</name></expr></argument>, <argument><expr>&amp;<name>buflen</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
}</block></else></if>
<expr_stmt><expr><name>res</name> = <call><name>setsockopt</name><argument_list>(<argument><expr><name><name>s</name>-&gt;<name>sock_fd</name></name></expr></argument>, <argument><expr><name>level</name></expr></argument>, <argument><expr><name>optname</name></expr></argument>, <argument><expr>(<name>void</name> *)<name>buf</name></expr></argument>, <argument><expr><name>buflen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>res</name> &lt; 0</expr>)</condition><then>
<return>return <expr><call><name><name>s</name>-&gt;<name>errorhandler</name></name><argument_list>()</argument_list></call></expr>;</return></then></if>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>Py_None</name></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>setsockopt_doc</name></expr></argument>,
<argument><expr>"setsockopt(level, option, value)\n\
\n\
Set a socket option. See the Unix manual for level and option.\n\
The value argument can either be an integer or a string."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>sock_getsockopt</name><parameter_list>(<param><decl><type><name>PySocketSockObject</name> *</type><name>s</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>level</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>optname</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>res</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>buf</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>socklen_t</name></type> <name>buflen</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__BEOS__</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>socket_error</name></expr></argument>, <argument><expr>"getsockopt not supported"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"ii|i:getsockopt"</expr></argument>,
<argument><expr>&amp;<name>level</name></expr></argument>, <argument><expr>&amp;<name>optname</name></expr></argument>, <argument><expr>&amp;<name>buflen</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<if>if <condition>(<expr><name>buflen</name> == 0</expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>flag</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>socklen_t</name></type> <name>flagsize</name> <init>= <expr>sizeof <name>flag</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>res</name> = <call><name>getsockopt</name><argument_list>(<argument><expr><name><name>s</name>-&gt;<name>sock_fd</name></name></expr></argument>, <argument><expr><name>level</name></expr></argument>, <argument><expr><name>optname</name></expr></argument>,
<argument><expr>(<name>void</name> *)&amp;<name>flag</name></expr></argument>, <argument><expr>&amp;<name>flagsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>res</name> &lt; 0</expr>)</condition><then>
<return>return <expr><call><name><name>s</name>-&gt;<name>errorhandler</name></name><argument_list>()</argument_list></call></expr>;</return></then></if>
<return>return <expr><call><name>PyInt_FromLong</name><argument_list>(<argument><expr><name>flag</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></then></if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__VMS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if>if <condition>(<expr><name>buflen</name> &gt; 1024</expr>)</condition><then> <block>{
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<if>if <condition>(<expr><name>buflen</name> &lt;= 0 || <name>buflen</name> &gt; 1024</expr>)</condition><then> <block>{
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>socket_error</name></expr></argument>,
<argument><expr>"getsockopt buflen out of range"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>buf</name> = <call><name>PyString_FromStringAndSize</name><argument_list>(<argument><expr>(<name>char</name> *)<name>NULL</name></expr></argument>, <argument><expr><name>buflen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>buf</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>res</name> = <call><name>getsockopt</name><argument_list>(<argument><expr><name><name>s</name>-&gt;<name>sock_fd</name></name></expr></argument>, <argument><expr><name>level</name></expr></argument>, <argument><expr><name>optname</name></expr></argument>,
<argument><expr>(<name>void</name> *)<call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>&amp;<name>buflen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>res</name> &lt; 0</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name><name>s</name>-&gt;<name>errorhandler</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block></then></if>
<expr_stmt><expr><call><name>_PyString_Resize</name><argument_list>(<argument><expr>&amp;<name>buf</name></expr></argument>, <argument><expr><name>buflen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>buf</name></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></then></if>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>getsockopt_doc</name></expr></argument>,
<argument><expr>"getsockopt(level, option[, buffersize]) -&gt; value\n\
\n\
Get a socket option. See the Unix manual for level and option.\n\
If a nonzero buffersize argument is given, the return value is a\n\
string of that length; otherwise it is an integer."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>sock_bind</name><parameter_list>(<param><decl><type><name>PySocketSockObject</name> *</type><name>s</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>addro</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>sock_addr_t</name></type> <name>addrbuf</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>addrlen</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>res</name></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>getsockaddrarg</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>addro</name></expr></argument>, <argument><expr><call><name>SAS2SA</name><argument_list>(<argument><expr>&amp;<name>addrbuf</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>&amp;<name>addrlen</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<decl_stmt><decl><type><name>Py_BEGIN_ALLOW_THREADS</name></type>
<name>res</name> <init>= <expr><call><name>bind</name><argument_list>(<argument><expr><name><name>s</name>-&gt;<name>sock_fd</name></name></expr></argument>, <argument><expr><call><name>SAS2SA</name><argument_list>(<argument><expr>&amp;<name>addrbuf</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>addrlen</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<macro><name>Py_END_ALLOW_THREADS</name></macro>
<if>if <condition>(<expr><name>res</name> &lt; 0</expr>)</condition><then>
<return>return <expr><call><name><name>s</name>-&gt;<name>errorhandler</name></name><argument_list>()</argument_list></call></expr>;</return></then></if>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>Py_None</name></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>bind_doc</name></expr></argument>,
<argument><expr>"bind(address)\n\
\n\
Bind the socket to a local address. For IP sockets, the address is a\n\
pair (host, port); the host must refer to the local host. For raw packet\n\
sockets the address is a tuple (ifname, proto [,pkttype [,hatype]])"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>sock_close</name><parameter_list>(<param><decl><type><name>PySocketSockObject</name> *</type><name>s</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>SOCKET_T</name></type> <name>fd</name></decl>;</decl_stmt>
<if>if <condition>(<expr>(<name>fd</name> = <name><name>s</name>-&gt;<name>sock_fd</name></name>) != -1</expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>s</name>-&gt;<name>sock_fd</name></name> = -1</expr>;</expr_stmt>
<macro><name>Py_BEGIN_ALLOW_THREADS</name>
<argument_list>(<argument>void</argument>)</argument_list></macro> <expr_stmt><expr><call><name>SOCKETCLOSE</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>Py_END_ALLOW_THREADS</name></expr></expr_stmt>
}</block></then></if>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>Py_None</name></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>close_doc</name></expr></argument>,
<argument><expr>"close()\n\
\n\
Close the socket. It cannot be used after this call."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>internal_connect</name><parameter_list>(<param><decl><type><name>PySocketSockObject</name> *</type><name>s</name></decl></param>, <param><decl><type>struct <name>sockaddr</name> *</type><name>addr</name></decl></param>, <param><decl><type><name>int</name></type> <name>addrlen</name></decl></param>,
<param><decl><type><name>int</name> *</type><name>timeoutp</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>res</name></decl>, <decl><type ref="prev"/><name>timeout</name></decl>;</decl_stmt>
<expr_stmt><expr><name>timeout</name> = 0</expr>;</expr_stmt>
<expr_stmt><expr><name>res</name> = <call><name>connect</name><argument_list>(<argument><expr><name><name>s</name>-&gt;<name>sock_fd</name></name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><name>addrlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MS_WINDOWS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if>if <condition>(<expr><name><name>s</name>-&gt;<name>sock_timeout</name></name> &gt; 0.0</expr>)</condition><then> <block>{
<if>if <condition>(<expr><name>res</name> &lt; 0 &amp;&amp; <call><name>WSAGetLastError</name><argument_list>()</argument_list></call> == <name>WSAEWOULDBLOCK</name> &amp;&amp;
<call><name>IS_SELECTABLE</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>fd_set</name></type> <name>fds</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>fd_set</name></type> <name>fds_exc</name></decl>;</decl_stmt>
<decl_stmt><decl><type>struct <name>timeval</name></type> <name>tv</name></decl>;</decl_stmt>
<expr_stmt><expr><name><name>tv</name>.<name>tv_sec</name></name> = (<name>int</name>)<name><name>s</name>-&gt;<name>sock_timeout</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tv</name>.<name>tv_usec</name></name> = <call>(<name>int</name>)<argument_list>(<argument><expr>(<name><name>s</name>-&gt;<name>sock_timeout</name></name> - <name><name>tv</name>.<name>tv_sec</name></name>) * 1e6</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>FD_ZERO</name><argument_list>(<argument><expr>&amp;<name>fds</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>FD_SET</name><argument_list>(<argument><expr><name><name>s</name>-&gt;<name>sock_fd</name></name></expr></argument>, <argument><expr>&amp;<name>fds</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>FD_ZERO</name><argument_list>(<argument><expr>&amp;<name>fds_exc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>FD_SET</name><argument_list>(<argument><expr><name><name>s</name>-&gt;<name>sock_fd</name></name></expr></argument>, <argument><expr>&amp;<name>fds_exc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>res</name> = <call><name>select</name><argument_list>(<argument><expr><name><name>s</name>-&gt;<name>sock_fd</name></name>+1</expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr>&amp;<name>fds</name></expr></argument>, <argument><expr>&amp;<name>fds_exc</name></expr></argument>, <argument><expr>&amp;<name>tv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>res</name> == 0</expr>)</condition><then> <block>{
<expr_stmt><expr><name>res</name> = <name>WSAEWOULDBLOCK</name></expr>;</expr_stmt>
<expr_stmt><expr><name>timeout</name> = 1</expr>;</expr_stmt>
}</block></then> <else>else <if>if <condition>(<expr><name>res</name> &gt; 0</expr>)</condition><then> <block>{
<if>if <condition>(<expr><call><name>FD_ISSET</name><argument_list>(<argument><expr><name><name>s</name>-&gt;<name>sock_fd</name></name></expr></argument>, <argument><expr>&amp;<name>fds</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<expr_stmt><expr><name>res</name> = 0</expr>;</expr_stmt></then>
<else>else <block>{
<decl_stmt><decl><type><name>int</name></type> <name>res_size</name> <init>= <expr>sizeof <name>res</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>FD_ISSET</name><argument_list>(<argument><expr><name><name>s</name>-&gt;<name>sock_fd</name></name></expr></argument>, <argument><expr>&amp;<name>fds_exc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>0 == <call><name>getsockopt</name><argument_list>(<argument><expr><name><name>s</name>-&gt;<name>sock_fd</name></name></expr></argument>, <argument><expr><name>SOL_SOCKET</name></expr></argument>, <argument><expr><name>SO_ERROR</name></expr></argument>,
<argument><expr>(<name>char</name> *)&amp;<name>res</name></expr></argument>, <argument><expr>&amp;<name>res_size</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<expr_stmt><expr><call><name>WSASetLastError</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
<else>else
<expr_stmt><expr><name>res</name> = <call><name>WSAGetLastError</name><argument_list>()</argument_list></call></expr>;</expr_stmt></else></if>
}</block></else></if>
}</block></then></if></else></if>
}</block></then></if>
}</block></then></if>
<if>if <condition>(<expr><name>res</name> &lt; 0</expr>)</condition><then>
<expr_stmt><expr><name>res</name> = <call><name>WSAGetLastError</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<if>if <condition>(<expr><name><name>s</name>-&gt;<name>sock_timeout</name></name> &gt; 0.0</expr>)</condition><then> <block>{
<if>if <condition>(<expr><name>res</name> &lt; 0 &amp;&amp; <name>errno</name> == <name>EINPROGRESS</name> &amp;&amp; <call><name>IS_SELECTABLE</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><name>timeout</name> = <call><name>internal_select</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>timeout</name> == 0</expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>socklen_t</name></type> <name>res_size</name> <init>= <expr>sizeof <name>res</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr>(<name>void</name>)<call><name>getsockopt</name><argument_list>(<argument><expr><name><name>s</name>-&gt;<name>sock_fd</name></name></expr></argument>, <argument><expr><name>SOL_SOCKET</name></expr></argument>,
<argument><expr><name>SO_ERROR</name></expr></argument>, <argument><expr>&amp;<name>res</name></expr></argument>, <argument><expr>&amp;<name>res_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>res</name> == <name>EISCONN</name></expr>)</condition><then>
<expr_stmt><expr><name>res</name> = 0</expr>;</expr_stmt></then></if>
<expr_stmt><expr><name>errno</name> = <name>res</name></expr>;</expr_stmt>
}</block></then> <else>else <if>if <condition>(<expr><name>timeout</name> == -1</expr>)</condition><then> <block>{
<expr_stmt><expr><name>res</name> = <name>errno</name></expr>;</expr_stmt>
}</block></then> <else>else
<expr_stmt><expr><name>res</name> = <name>EWOULDBLOCK</name></expr>;</expr_stmt></else></if></else></if>
}</block></then></if>
}</block></then></if>
<if>if <condition>(<expr><name>res</name> &lt; 0</expr>)</condition><then>
<expr_stmt><expr><name>res</name> = <name>errno</name></expr>;</expr_stmt></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr>*<name>timeoutp</name> = <name>timeout</name></expr>;</expr_stmt>
<return>return <expr><name>res</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>sock_connect</name><parameter_list>(<param><decl><type><name>PySocketSockObject</name> *</type><name>s</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>addro</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>sock_addr_t</name></type> <name>addrbuf</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>addrlen</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>res</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>timeout</name></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>getsockaddrarg</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>addro</name></expr></argument>, <argument><expr><call><name>SAS2SA</name><argument_list>(<argument><expr>&amp;<name>addrbuf</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>&amp;<name>addrlen</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<decl_stmt><decl><type><name>Py_BEGIN_ALLOW_THREADS</name></type>
<name>res</name> <init>= <expr><call><name>internal_connect</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><call><name>SAS2SA</name><argument_list>(<argument><expr>&amp;<name>addrbuf</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>addrlen</name></expr></argument>, <argument><expr>&amp;<name>timeout</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<macro><name>Py_END_ALLOW_THREADS</name></macro>
<if>if <condition>(<expr><name>timeout</name> == 1</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>socket_timeout</name></expr></argument>, <argument><expr>"timed out"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<if>if <condition>(<expr><name>res</name> != 0</expr>)</condition><then>
<return>return <expr><call><name><name>s</name>-&gt;<name>errorhandler</name></name><argument_list>()</argument_list></call></expr>;</return></then></if>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>Py_None</name></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>connect_doc</name></expr></argument>,
<argument><expr>"connect(address)\n\
\n\
Connect the socket to a remote address. For IP sockets, the address\n\
is a pair (host, port)."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>sock_connect_ex</name><parameter_list>(<param><decl><type><name>PySocketSockObject</name> *</type><name>s</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>addro</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>sock_addr_t</name></type> <name>addrbuf</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>addrlen</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>res</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>timeout</name></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>getsockaddrarg</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>addro</name></expr></argument>, <argument><expr><call><name>SAS2SA</name><argument_list>(<argument><expr>&amp;<name>addrbuf</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>&amp;<name>addrlen</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<decl_stmt><decl><type><name>Py_BEGIN_ALLOW_THREADS</name></type>
<name>res</name> <init>= <expr><call><name>internal_connect</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><call><name>SAS2SA</name><argument_list>(<argument><expr>&amp;<name>addrbuf</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>addrlen</name></expr></argument>, <argument><expr>&amp;<name>timeout</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<macro><name>Py_END_ALLOW_THREADS</name></macro>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>EINTR</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if>if <condition>(<expr><name>res</name> == <name>EINTR</name> &amp;&amp; <call><name>PyErr_CheckSignals</name><argument_list>()</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<return>return <expr><call><name>PyInt_FromLong</name><argument_list>(<argument><expr>(<name>long</name>) <name>res</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>connect_ex_doc</name></expr></argument>,
<argument><expr>"connect_ex(address) -&gt; errno\n\
\n\
This is like connect(address), but returns an error code (the errno value)\n\
instead of raising an exception when an error occurs."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>sock_fileno</name><parameter_list>(<param><decl><type><name>PySocketSockObject</name> *</type><name>s</name></decl></param>)</parameter_list> <block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SIZEOF_SOCKET_T</name> &lt;= <name>SIZEOF_LONG</name></expr></cpp:if>
<return>return <expr><call><name>PyInt_FromLong</name><argument_list>(<argument><expr>(<name>long</name>) <name><name>s</name>-&gt;<name>sock_fd</name></name></expr></argument>)</argument_list></call></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<return>return <expr><call><name>PyLong_FromLongLong</name><argument_list>(<argument><expr>(<name>PY_LONG_LONG</name>)<name><name>s</name>-&gt;<name>sock_fd</name></name></expr></argument>)</argument_list></call></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>fileno_doc</name></expr></argument>,
<argument><expr>"fileno() -&gt; integer\n\
\n\
Return the integer file descriptor of the socket."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>NO_DUP</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>sock_dup</name><parameter_list>(<param><decl><type><name>PySocketSockObject</name> *</type><name>s</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>SOCKET_T</name></type> <name>newfd</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>sock</name></decl>;</decl_stmt>
<expr_stmt><expr><name>newfd</name> = <call><name>dup</name><argument_list>(<argument><expr><name><name>s</name>-&gt;<name>sock_fd</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>newfd</name> &lt; 0</expr>)</condition><then>
<return>return <expr><call><name><name>s</name>-&gt;<name>errorhandler</name></name><argument_list>()</argument_list></call></expr>;</return></then></if>
<expr_stmt><expr><name>sock</name> = (<name>PyObject</name> *) <call><name>new_sockobject</name><argument_list>(<argument><expr><name>newfd</name></expr></argument>,
<argument><expr><name><name>s</name>-&gt;<name>sock_family</name></name></expr></argument>,
<argument><expr><name><name>s</name>-&gt;<name>sock_type</name></name></expr></argument>,
<argument><expr><name><name>s</name>-&gt;<name>sock_proto</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>sock</name> == <name>NULL</name></expr>)</condition><then>
<expr_stmt><expr><call><name>SOCKETCLOSE</name><argument_list>(<argument><expr><name>newfd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<return>return <expr><name>sock</name></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>dup_doc</name></expr></argument>,
<argument><expr>"dup() -&gt; socket object\n\
\n\
Return a new socket object connected to the same system resource."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>sock_getsockname</name><parameter_list>(<param><decl><type><name>PySocketSockObject</name> *</type><name>s</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>sock_addr_t</name></type> <name>addrbuf</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>res</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>socklen_t</name></type> <name>addrlen</name></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>getsockaddrlen</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr>&amp;<name>addrlen</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr>&amp;<name>addrbuf</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>addrlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>Py_BEGIN_ALLOW_THREADS</name></type>
<name>res</name> <init>= <expr><call><name>getsockname</name><argument_list>(<argument><expr><name><name>s</name>-&gt;<name>sock_fd</name></name></expr></argument>, <argument><expr><call><name>SAS2SA</name><argument_list>(<argument><expr>&amp;<name>addrbuf</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>&amp;<name>addrlen</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<macro><name>Py_END_ALLOW_THREADS</name></macro>
<if>if <condition>(<expr><name>res</name> &lt; 0</expr>)</condition><then>
<return>return <expr><call><name><name>s</name>-&gt;<name>errorhandler</name></name><argument_list>()</argument_list></call></expr>;</return></then></if>
<return>return <expr><call><name>makesockaddr</name><argument_list>(<argument><expr><name><name>s</name>-&gt;<name>sock_fd</name></name></expr></argument>, <argument><expr><call><name>SAS2SA</name><argument_list>(<argument><expr>&amp;<name>addrbuf</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>addrlen</name></expr></argument>,
<argument><expr><name><name>s</name>-&gt;<name>sock_proto</name></name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>getsockname_doc</name></expr></argument>,
<argument><expr>"getsockname() -&gt; address info\n\
\n\
Return the address of the local endpoint. For IP sockets, the address\n\
info is a pair (hostaddr, port)."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_GETPEERNAME</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>sock_getpeername</name><parameter_list>(<param><decl><type><name>PySocketSockObject</name> *</type><name>s</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>sock_addr_t</name></type> <name>addrbuf</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>res</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>socklen_t</name></type> <name>addrlen</name></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>getsockaddrlen</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr>&amp;<name>addrlen</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr>&amp;<name>addrbuf</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>addrlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>Py_BEGIN_ALLOW_THREADS</name></type>
<name>res</name> <init>= <expr><call><name>getpeername</name><argument_list>(<argument><expr><name><name>s</name>-&gt;<name>sock_fd</name></name></expr></argument>, <argument><expr><call><name>SAS2SA</name><argument_list>(<argument><expr>&amp;<name>addrbuf</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>&amp;<name>addrlen</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<macro><name>Py_END_ALLOW_THREADS</name></macro>
<if>if <condition>(<expr><name>res</name> &lt; 0</expr>)</condition><then>
<return>return <expr><call><name><name>s</name>-&gt;<name>errorhandler</name></name><argument_list>()</argument_list></call></expr>;</return></then></if>
<return>return <expr><call><name>makesockaddr</name><argument_list>(<argument><expr><name><name>s</name>-&gt;<name>sock_fd</name></name></expr></argument>, <argument><expr><call><name>SAS2SA</name><argument_list>(<argument><expr>&amp;<name>addrbuf</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>addrlen</name></expr></argument>,
<argument><expr><name><name>s</name>-&gt;<name>sock_proto</name></name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>getpeername_doc</name></expr></argument>,
<argument><expr>"getpeername() -&gt; address info\n\
\n\
Return the address of the remote endpoint. For IP sockets, the address\n\
info is a pair (hostaddr, port)."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>sock_listen</name><parameter_list>(<param><decl><type><name>PySocketSockObject</name> *</type><name>s</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>arg</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>backlog</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>res</name></decl>;</decl_stmt>
<expr_stmt><expr><name>backlog</name> = <call><name>PyInt_AsLong</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>backlog</name> == -1 &amp;&amp; <call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<macro><name>Py_BEGIN_ALLOW_THREADS</name></macro>
<if>if <condition>(<expr><name>backlog</name> &lt; 1</expr>)</condition><then>
<expr_stmt><expr><name>backlog</name> = 1</expr>;</expr_stmt></then></if>
<expr_stmt><expr><name>res</name> = <call><name>listen</name><argument_list>(<argument><expr><name><name>s</name>-&gt;<name>sock_fd</name></name></expr></argument>, <argument><expr><name>backlog</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<macro><name>Py_END_ALLOW_THREADS</name></macro>
<if>if <condition>(<expr><name>res</name> &lt; 0</expr>)</condition><then>
<return>return <expr><call><name><name>s</name>-&gt;<name>errorhandler</name></name><argument_list>()</argument_list></call></expr>;</return></then></if>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>Py_None</name></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>listen_doc</name></expr></argument>,
<argument><expr>"listen(backlog)\n\
\n\
Enable a server to accept connections. The backlog argument must be at\n\
least 1; it specifies the number of unaccepted connection that the system\n\
will allow before refusing new connections."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>NO_DUP</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>sock_makefile</name><parameter_list>(<param><decl><type><name>PySocketSockObject</name> *</type><name>s</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<function_decl><type><specifier>extern</specifier> <name>int</name></type> <name>fclose</name><parameter_list>(<param><decl><type><name>FILE</name> *</type></decl></param>)</parameter_list>;</function_decl>
<decl_stmt><decl><type><name>char</name> *</type><name>mode</name> <init>= <expr>"r"</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>bufsize</name> <init>= <expr>-1</expr></init></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MS_WIN32</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>Py_intptr_t</name></type> <name>fd</name></decl>;</decl_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<decl_stmt><decl><type><name>int</name></type> <name>fd</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<decl_stmt><decl><type><name>FILE</name> *</type><name>fp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>f</name></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__VMS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>char</name> *</type><name>mode_r</name> <init>= <expr>"r"</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>mode_w</name> <init>= <expr>"w"</expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"|si:makefile"</expr></argument>, <argument><expr>&amp;<name>mode</name></expr></argument>, <argument><expr>&amp;<name>bufsize</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__VMS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>mode</name></expr></argument>,<argument><expr>"rb"</expr></argument>)</argument_list></call> == 0</expr>)</condition><then> <block>{
<expr_stmt><expr><name>mode</name> = <name>mode_r</name></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>mode</name></expr></argument>,<argument><expr>"wb"</expr></argument>)</argument_list></call> == 0</expr>)</condition><then> <block>{
<expr_stmt><expr><name>mode</name> = <name>mode_w</name></expr>;</expr_stmt>
}</block></then></if>
}</block></else></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MS_WIN32</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if>if <condition>(<expr>((<name>fd</name> = <call><name>_open_osfhandle</name><argument_list>(<argument><expr><name><name>s</name>-&gt;<name>sock_fd</name></name></expr></argument>, <argument><expr><name>_O_BINARY</name></expr></argument>)</argument_list></call>) &lt; 0) ||
((<name>fd</name> = <call><name>dup</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call>) &lt; 0) || ((<name>fp</name> = <call><name>fdopen</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>mode</name></expr></argument>)</argument_list></call>) == <name>NULL</name>)</expr>)</condition><then>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<if>if <condition>(<expr>(<name>fd</name> = <call><name>dup</name><argument_list>(<argument><expr><name><name>s</name>-&gt;<name>sock_fd</name></name></expr></argument>)</argument_list></call>) &lt; 0 || (<name>fp</name> = <call><name>fdopen</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>mode</name></expr></argument>)</argument_list></call>) == <name>NULL</name></expr>)</condition><then>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<block>{
<if>if <condition>(<expr><name>fd</name> &gt;= 0</expr>)</condition><then>
<expr_stmt><expr><call><name>SOCKETCLOSE</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<return>return <expr><call><name><name>s</name>-&gt;<name>errorhandler</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block></then></if></then></if>
<expr_stmt><expr><name>f</name> = <call><name>PyFile_FromFile</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr>"&lt;socket&gt;"</expr></argument>, <argument><expr><name>mode</name></expr></argument>, <argument><expr><name>fclose</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>f</name> != <name>NULL</name></expr>)</condition><then>
<expr_stmt><expr><call><name>PyFile_SetBufSize</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><name>bufsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<return>return <expr><name>f</name></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>makefile_doc</name></expr></argument>,
<argument><expr>"makefile([mode[, buffersize]]) -&gt; file object\n\
\n\
Return a regular file object corresponding to the socket.\n\
The mode and buffersize arguments are as for the built-in open() function."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<function><type><specifier>static</specifier> <name>ssize_t</name></type>
<name>sock_recv_guts</name><parameter_list>(<param><decl><type><name>PySocketSockObject</name> *</type><name>s</name></decl></param>, <param><decl><type><name>char</name>*</type> <name>cbuf</name></decl></param>, <param><decl><type><name>int</name></type> <name>len</name></decl></param>, <param><decl><type><name>int</name></type> <name>flags</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>ssize_t</name></type> <name>outlen</name> <init>= <expr>-1</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>timeout</name></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__VMS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>int</name></type> <name>remaining</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>read_buf</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<if>if <condition>(<expr>!<call><name>IS_SELECTABLE</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>select_error</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<return>return <expr>-1</expr>;</return>
}</block></then></if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>__VMS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>Py_BEGIN_ALLOW_THREADS</name></type>
<name>timeout</name> <init>= <expr><call><name>internal_select</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr>!<name>timeout</name></expr>)</condition><then>
<expr_stmt><expr><name>outlen</name> = <call><name>recv</name><argument_list>(<argument><expr><name><name>s</name>-&gt;<name>sock_fd</name></name></expr></argument>, <argument><expr><name>cbuf</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<macro><name>Py_END_ALLOW_THREADS</name></macro>
<if>if <condition>(<expr><name>timeout</name> == 1</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>socket_timeout</name></expr></argument>, <argument><expr>"timed out"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>-1</expr>;</return>
}</block></then></if>
<if>if <condition>(<expr><name>outlen</name> &lt; 0</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name><name>s</name>-&gt;<name>errorhandler</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<return>return <expr>-1</expr>;</return>
}</block></then></if>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<expr_stmt><expr><name>read_buf</name> = <name>cbuf</name></expr>;</expr_stmt>
<expr_stmt><expr><name>remaining</name> = <name>len</name></expr>;</expr_stmt>
<while>while <condition>(<expr><name>remaining</name> != 0</expr>)</condition> <block>{
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>segment</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>nread</name> <init>= <expr>-1</expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>segment</name> = <name>remaining</name> /<name>SEGMENT_SIZE</name></expr>;</expr_stmt>
<if>if <condition>(<expr><name>segment</name> != 0</expr>)</condition><then> <block>{
<expr_stmt><expr><name>segment</name> = <name>SEGMENT_SIZE</name></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr><name>segment</name> = <name>remaining</name></expr>;</expr_stmt>
}</block></else></if>
<decl_stmt><decl><type><name>Py_BEGIN_ALLOW_THREADS</name></type>
<name>timeout</name> <init>= <expr><call><name>internal_select</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr>!<name>timeout</name></expr>)</condition><then>
<expr_stmt><expr><name>nread</name> = <call><name>recv</name><argument_list>(<argument><expr><name><name>s</name>-&gt;<name>sock_fd</name></name></expr></argument>, <argument><expr><name>read_buf</name></expr></argument>, <argument><expr><name>segment</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<macro><name>Py_END_ALLOW_THREADS</name></macro>
<if>if <condition>(<expr><name>timeout</name> == 1</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>socket_timeout</name></expr></argument>, <argument><expr>"timed out"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>-1</expr>;</return>
}</block></then></if>
<if>if <condition>(<expr><name>nread</name> &lt; 0</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name><name>s</name>-&gt;<name>errorhandler</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<return>return <expr>-1</expr>;</return>
}</block></then></if>
<if>if <condition>(<expr><name>nread</name> != <name>remaining</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>read_buf</name> += <name>nread</name></expr>;</expr_stmt>
<break>break;</break>
}</block></then></if>
<expr_stmt><expr><name>remaining</name> -= <name>segment</name></expr>;</expr_stmt>
<expr_stmt><expr><name>read_buf</name> += <name>segment</name></expr>;</expr_stmt>
}</block></while>
<expr_stmt><expr><name>outlen</name> = <name>read_buf</name> - <name>cbuf</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<return>return <expr><name>outlen</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>sock_recv</name><parameter_list>(<param><decl><type><name>PySocketSockObject</name> *</type><name>s</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>recvlen</name></decl>, <decl><type ref="prev"/><name>flags</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ssize_t</name></type> <name>outlen</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>buf</name></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"i|i:recv"</expr></argument>, <argument><expr>&amp;<name>recvlen</name></expr></argument>, <argument><expr>&amp;<name>flags</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<if>if <condition>(<expr><name>recvlen</name> &lt; 0</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>,
<argument><expr>"negative buffersize in recv"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>buf</name> = <call><name>PyString_FromStringAndSize</name><argument_list>(<argument><expr>(<name>char</name> *) 0</expr></argument>, <argument><expr><name>recvlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>buf</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>outlen</name> = <call><name>sock_recv_guts</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>recvlen</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>outlen</name> &lt; 0</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<if>if <condition>(<expr><name>outlen</name> != <name>recvlen</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr><call><name>_PyString_Resize</name><argument_list>(<argument><expr>&amp;<name>buf</name></expr></argument>, <argument><expr><name>outlen</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
}</block></then></if>
<return>return <expr><name>buf</name></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>recv_doc</name></expr></argument>,
<argument><expr>"recv(buffersize[, flags]) -&gt; data\n\
\n\
Receive up to buffersize bytes from the socket. For the optional flags\n\
argument, see the Unix manual. When no data is available, block until\n\
at least one byte is available or until the remote end is closed. When\n\
the remote end is closed and all data is read, return the empty string."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name>*</type>
<name>sock_recv_into</name><parameter_list>(<param><decl><type><name>PySocketSockObject</name> *</type><name>s</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>kwds</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> *</type><name><name>kwlist</name><index>[]</index></name> <init>= <expr><block>{<expr>"buffer"</expr>, <expr>"nbytes"</expr>, <expr>"flags"</expr>, <expr>0</expr>}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>recvlen</name> <init>= <expr>0</expr></init>, <name>flags</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ssize_t</name></type> <name>readlen</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>buf</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>buflen</name></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTupleAndKeywords</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>kwds</name></expr></argument>, <argument><expr>"w#|ii:recv_into"</expr></argument>, <argument><expr><name>kwlist</name></expr></argument>,
<argument><expr>&amp;<name>buf</name></expr></argument>, <argument><expr>&amp;<name>buflen</name></expr></argument>, <argument><expr>&amp;<name>recvlen</name></expr></argument>, <argument><expr>&amp;<name>flags</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>buf</name> != 0 &amp;&amp; <name>buflen</name> &gt; 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>recvlen</name> &lt; 0</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>,
<argument><expr>"negative buffersize in recv_into"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<if>if <condition>(<expr><name>recvlen</name> == 0</expr>)</condition><then> <block>{
<expr_stmt><expr><name>recvlen</name> = <name>buflen</name></expr>;</expr_stmt>
}</block></then></if>
<if>if <condition>(<expr><name>buflen</name> &lt; <name>recvlen</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>,
<argument><expr>"buffer too small for requested bytes"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>readlen</name> = <call><name>sock_recv_guts</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>recvlen</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>readlen</name> &lt; 0</expr>)</condition><then> <block>{
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<return>return <expr><call><name>PyInt_FromSsize_t</name><argument_list>(<argument><expr><name>readlen</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>recv_into_doc</name></expr></argument>,
<argument><expr>"recv_into(buffer, [nbytes[, flags]]) -&gt; nbytes_read\n\
\n\
A version of recv() that stores its data into a buffer rather than creating \n\
a new string. Receive up to buffersize bytes from the socket. If buffersize \n\
is not specified (or 0), receive up to the size available in the given buffer.\n\
\n\
See recv() for documentation about the flags."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>ssize_t</name></type>
<name>sock_recvfrom_guts</name><parameter_list>(<param><decl><type><name>PySocketSockObject</name> *</type><name>s</name></decl></param>, <param><decl><type><name>char</name>*</type> <name>cbuf</name></decl></param>, <param><decl><type><name>int</name></type> <name>len</name></decl></param>, <param><decl><type><name>int</name></type> <name>flags</name></decl></param>,
<param><decl><type><name>PyObject</name>**</type> <name>addr</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>sock_addr_t</name></type> <name>addrbuf</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>timeout</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ssize_t</name></type> <name>n</name> <init>= <expr>-1</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>socklen_t</name></type> <name>addrlen</name></decl>;</decl_stmt>
<expr_stmt><expr>*<name>addr</name> = <name>NULL</name></expr>;</expr_stmt>
<if>if <condition>(<expr>!<call><name>getsockaddrlen</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr>&amp;<name>addrlen</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr>-1</expr>;</return></then></if>
<if>if <condition>(<expr>!<call><name>IS_SELECTABLE</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>select_error</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<return>return <expr>-1</expr>;</return>
}</block></then></if>
<decl_stmt><decl><type><name>Py_BEGIN_ALLOW_THREADS</name></type>
<name>memset</name><argument_list>(<argument><expr>&amp;<name>addrbuf</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>addrlen</name></expr></argument>)</argument_list></decl>;</decl_stmt>
<expr_stmt><expr><name>timeout</name> = <call><name>internal_select</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>timeout</name></expr>)</condition><then> <block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>MS_WINDOWS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>PYOS_OS2</name></expr></argument>)</argument_list></call> &amp;&amp; !<call><name>defined</name><argument_list>(<argument><expr><name>PYCC_GCC</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><name>n</name> = <call><name>recvfrom</name><argument_list>(<argument><expr><name><name>s</name>-&gt;<name>sock_fd</name></name></expr></argument>, <argument><expr><name>cbuf</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>,
<argument><expr><call><name>SAS2SA</name><argument_list>(<argument><expr>&amp;<name>addrbuf</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>&amp;<name>addrlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<expr_stmt><expr><name>n</name> = <call><name>recvfrom</name><argument_list>(<argument><expr><name><name>s</name>-&gt;<name>sock_fd</name></name></expr></argument>, <argument><expr><name>cbuf</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>,
<argument><expr>(<name>void</name> *) &amp;<name>addrbuf</name></expr></argument>, <argument><expr>&amp;<name>addrlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<expr_stmt><expr><name>n</name> = <call><name>recvfrom</name><argument_list>(<argument><expr><name><name>s</name>-&gt;<name>sock_fd</name></name></expr></argument>, <argument><expr><name>cbuf</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>,
<argument><expr><call><name>SAS2SA</name><argument_list>(<argument><expr>&amp;<name>addrbuf</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>&amp;<name>addrlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></then></if>
<macro><name>Py_END_ALLOW_THREADS</name></macro>
<if>if <condition>(<expr><name>timeout</name> == 1</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>socket_timeout</name></expr></argument>, <argument><expr>"timed out"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>-1</expr>;</return>
}</block></then></if>
<if>if <condition>(<expr><name>n</name> &lt; 0</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name><name>s</name>-&gt;<name>errorhandler</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<return>return <expr>-1</expr>;</return>
}</block></then></if>
<if>if <condition>(<expr>!(*<name>addr</name> = <call><name>makesockaddr</name><argument_list>(<argument><expr><name><name>s</name>-&gt;<name>sock_fd</name></name></expr></argument>, <argument><expr><call><name>SAS2SA</name><argument_list>(<argument><expr>&amp;<name>addrbuf</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>addrlen</name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>sock_proto</name></name></expr></argument>)</argument_list></call>)</expr>)</condition><then>
<return>return <expr>-1</expr>;</return></then></if>
<return>return <expr><name>n</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>sock_recvfrom</name><parameter_list>(<param><decl><type><name>PySocketSockObject</name> *</type><name>s</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>buf</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>addr</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>ret</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>recvlen</name></decl>, <decl><type ref="prev"/><name>flags</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ssize_t</name></type> <name>outlen</name></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"i|i:recvfrom"</expr></argument>, <argument><expr>&amp;<name>recvlen</name></expr></argument>, <argument><expr>&amp;<name>flags</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<if>if <condition>(<expr><name>recvlen</name> &lt; 0</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>,
<argument><expr>"negative buffersize in recvfrom"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>buf</name> = <call><name>PyString_FromStringAndSize</name><argument_list>(<argument><expr>(<name>char</name> *) 0</expr></argument>, <argument><expr><name>recvlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>buf</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>outlen</name> = <call><name>sock_recvfrom_guts</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>recvlen</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>, <argument><expr>&amp;<name>addr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>outlen</name> &lt; 0</expr>)</condition><then> <block>{
<goto>goto <name>finally</name>;</goto>
}</block></then></if>
<if>if <condition>(<expr><name>outlen</name> != <name>recvlen</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr><call><name>_PyString_Resize</name><argument_list>(<argument><expr>&amp;<name>buf</name></expr></argument>, <argument><expr><name>outlen</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
<goto>goto <name>finally</name>;</goto></then></if>
}</block></then></if>
<expr_stmt><expr><name>ret</name> = <call><name>PyTuple_Pack</name><argument_list>(<argument><expr>2</expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<label><name>finally</name>:</label>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>ret</name></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>recvfrom_doc</name></expr></argument>,
<argument><expr>"recvfrom(buffersize[, flags]) -&gt; (data, address info)\n\
\n\
Like recv(buffersize, flags) but also return the sender's address info."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>sock_recvfrom_into</name><parameter_list>(<param><decl><type><name>PySocketSockObject</name> *</type><name>s</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>, <param><decl><type><name>PyObject</name>*</type> <name>kwds</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> *</type><name><name>kwlist</name><index>[]</index></name> <init>= <expr><block>{<expr>"buffer"</expr>, <expr>"nbytes"</expr>, <expr>"flags"</expr>, <expr>0</expr>}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>recvlen</name> <init>= <expr>0</expr></init>, <name>flags</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ssize_t</name></type> <name>readlen</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>buf</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>buflen</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>addr</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTupleAndKeywords</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>kwds</name></expr></argument>, <argument><expr>"w#|ii:recvfrom_into"</expr></argument>,
<argument><expr><name>kwlist</name></expr></argument>, <argument><expr>&amp;<name>buf</name></expr></argument>, <argument><expr>&amp;<name>buflen</name></expr></argument>,
<argument><expr>&amp;<name>recvlen</name></expr></argument>, <argument><expr>&amp;<name>flags</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>buf</name> != 0 &amp;&amp; <name>buflen</name> &gt; 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>recvlen</name> &lt; 0</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>,
<argument><expr>"negative buffersize in recvfrom_into"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<if>if <condition>(<expr><name>recvlen</name> == 0</expr>)</condition><then> <block>{
<expr_stmt><expr><name>recvlen</name> = <name>buflen</name></expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><name>readlen</name> = <call><name>sock_recvfrom_guts</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>recvlen</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>, <argument><expr>&amp;<name>addr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>readlen</name> &lt; 0</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<return>return <expr><call><name>Py_BuildValue</name><argument_list>(<argument><expr>"lN"</expr></argument>, <argument><expr><name>readlen</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>recvfrom_into_doc</name></expr></argument>,
<argument><expr>"recvfrom_into(buffer[, nbytes[, flags]]) -&gt; (nbytes, address info)\n\
\n\
Like recv_into(buffer[, nbytes[, flags]]) but also return the sender's address info."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>sock_send</name><parameter_list>(<param><decl><type><name>PySocketSockObject</name> *</type><name>s</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>char</name> *</type><name>buf</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>len</name></decl>, <decl><type ref="prev"/><name>n</name> <init>= <expr>-1</expr></init>, <name>flags</name> <init>= <expr>0</expr></init>, <name>timeout</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_buffer</name></type> <name>pbuf</name></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"s*|i:send"</expr></argument>, <argument><expr>&amp;<name>pbuf</name></expr></argument>, <argument><expr>&amp;<name>flags</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<if>if <condition>(<expr>!<call><name>IS_SELECTABLE</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyBuffer_Release</name><argument_list>(<argument><expr>&amp;<name>pbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>select_error</name><argument_list>()</argument_list></call></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>buf</name> = <name><name>pbuf</name>.<name>buf</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>len</name> = <name><name>pbuf</name>.<name>len</name></name></expr>;</expr_stmt>
<decl_stmt><decl><type><name>Py_BEGIN_ALLOW_THREADS</name></type>
<name>timeout</name> <init>= <expr><call><name>internal_select</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr>!<name>timeout</name></expr>)</condition><then>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__VMS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><name>n</name> = <call><name>sendsegmented</name><argument_list>(<argument><expr><name><name>s</name>-&gt;<name>sock_fd</name></name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<expr_stmt><expr><name>n</name> = <call><name>send</name><argument_list>(<argument><expr><name><name>s</name>-&gt;<name>sock_fd</name></name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<decl_stmt><decl><type><name>Py_END_ALLOW_THREADS</name></type>
<name>PyBuffer_Release</name><argument_list>(<argument><expr>&amp;<name>pbuf</name></expr></argument>)</argument_list></decl>;</decl_stmt>
<if>if <condition>(<expr><name>timeout</name> == 1</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>socket_timeout</name></expr></argument>, <argument><expr>"timed out"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<if>if <condition>(<expr><name>n</name> &lt; 0</expr>)</condition><then>
<return>return <expr><call><name><name>s</name>-&gt;<name>errorhandler</name></name><argument_list>()</argument_list></call></expr>;</return></then></if>
<return>return <expr><call><name>PyInt_FromLong</name><argument_list>(<argument><expr>(<name>long</name>)<name>n</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>send_doc</name></expr></argument>,
<argument><expr>"send(data[, flags]) -&gt; count\n\
\n\
Send a data string to the socket. For the optional flags\n\
argument, see the Unix manual. Return the number of bytes\n\
sent; this may be less than len(data) if the network is busy."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>sock_sendall</name><parameter_list>(<param><decl><type><name>PySocketSockObject</name> *</type><name>s</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>char</name> *</type><name>buf</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>len</name></decl>, <decl><type ref="prev"/><name>n</name> <init>= <expr>-1</expr></init>, <name>flags</name> <init>= <expr>0</expr></init>, <name>timeout</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_buffer</name></type> <name>pbuf</name></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"s*|i:sendall"</expr></argument>, <argument><expr>&amp;<name>pbuf</name></expr></argument>, <argument><expr>&amp;<name>flags</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>buf</name> = <name><name>pbuf</name>.<name>buf</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>len</name> = <name><name>pbuf</name>.<name>len</name></name></expr>;</expr_stmt>
<if>if <condition>(<expr>!<call><name>IS_SELECTABLE</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyBuffer_Release</name><argument_list>(<argument><expr>&amp;<name>pbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>select_error</name><argument_list>()</argument_list></call></expr>;</return>
}</block></then></if>
<macro><name>Py_BEGIN_ALLOW_THREADS</name></macro>
<do>do <block>{
<expr_stmt><expr><name>timeout</name> = <call><name>internal_select</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>n</name> = -1</expr>;</expr_stmt>
<if>if <condition>(<expr><name>timeout</name></expr>)</condition><then>
<break>break;</break></then></if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__VMS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><name>n</name> = <call><name>sendsegmented</name><argument_list>(<argument><expr><name><name>s</name>-&gt;<name>sock_fd</name></name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<expr_stmt><expr><name>n</name> = <call><name>send</name><argument_list>(<argument><expr><name><name>s</name>-&gt;<name>sock_fd</name></name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<if>if <condition>(<expr><name>n</name> &lt; 0</expr>)</condition><then>
<break>break;</break></then></if>
<expr_stmt><expr><name>buf</name> += <name>n</name></expr>;</expr_stmt>
<expr_stmt><expr><name>len</name> -= <name>n</name></expr>;</expr_stmt>
}</block> while <condition>(<expr><name>len</name> &gt; 0</expr>)</condition>;</do>
<decl_stmt><decl><type><name>Py_END_ALLOW_THREADS</name></type>
<name>PyBuffer_Release</name><argument_list>(<argument><expr>&amp;<name>pbuf</name></expr></argument>)</argument_list></decl>;</decl_stmt>
<if>if <condition>(<expr><name>timeout</name> == 1</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>socket_timeout</name></expr></argument>, <argument><expr>"timed out"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<if>if <condition>(<expr><name>n</name> &lt; 0</expr>)</condition><then>
<return>return <expr><call><name><name>s</name>-&gt;<name>errorhandler</name></name><argument_list>()</argument_list></call></expr>;</return></then></if>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>Py_None</name></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>sendall_doc</name></expr></argument>,
<argument><expr>"sendall(data[, flags])\n\
\n\
Send a data string to the socket. For the optional flags\n\
argument, see the Unix manual. This calls send() repeatedly\n\
until all data is sent. If an error occurs, it's impossible\n\
to tell how much data has been sent."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>sock_sendto</name><parameter_list>(<param><decl><type><name>PySocketSockObject</name> *</type><name>s</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>Py_buffer</name></type> <name>pbuf</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>addro</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>buf</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>len</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>sock_addr_t</name></type> <name>addrbuf</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>addrlen</name></decl>, <decl><type ref="prev"/><name>n</name> <init>= <expr>-1</expr></init>, <name>flags</name></decl>, <decl><type ref="prev"/><name>timeout</name></decl>;</decl_stmt>
<expr_stmt><expr><name>flags</name> = 0</expr>;</expr_stmt>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"s*O:sendto"</expr></argument>, <argument><expr>&amp;<name>pbuf</name></expr></argument>, <argument><expr>&amp;<name>addro</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_Clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"s*iO:sendto"</expr></argument>,
<argument><expr>&amp;<name>pbuf</name></expr></argument>, <argument><expr>&amp;<name>flags</name></expr></argument>, <argument><expr>&amp;<name>addro</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
}</block></then></if>
<expr_stmt><expr><name>buf</name> = <name><name>pbuf</name>.<name>buf</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>len</name> = <name><name>pbuf</name>.<name>len</name></name></expr>;</expr_stmt>
<if>if <condition>(<expr>!<call><name>IS_SELECTABLE</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyBuffer_Release</name><argument_list>(<argument><expr>&amp;<name>pbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>select_error</name><argument_list>()</argument_list></call></expr>;</return>
}</block></then></if>
<if>if <condition>(<expr>!<call><name>getsockaddrarg</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>addro</name></expr></argument>, <argument><expr><call><name>SAS2SA</name><argument_list>(<argument><expr>&amp;<name>addrbuf</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>&amp;<name>addrlen</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyBuffer_Release</name><argument_list>(<argument><expr>&amp;<name>pbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<decl_stmt><decl><type><name>Py_BEGIN_ALLOW_THREADS</name></type>
<name>timeout</name> <init>= <expr><call><name>internal_select</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr>!<name>timeout</name></expr>)</condition><then>
<expr_stmt><expr><name>n</name> = <call><name>sendto</name><argument_list>(<argument><expr><name><name>s</name>-&gt;<name>sock_fd</name></name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>, <argument><expr><call><name>SAS2SA</name><argument_list>(<argument><expr>&amp;<name>addrbuf</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>addrlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<decl_stmt><decl><type><name>Py_END_ALLOW_THREADS</name></type>
<name>PyBuffer_Release</name><argument_list>(<argument><expr>&amp;<name>pbuf</name></expr></argument>)</argument_list></decl>;</decl_stmt>
<if>if <condition>(<expr><name>timeout</name> == 1</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>socket_timeout</name></expr></argument>, <argument><expr>"timed out"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<if>if <condition>(<expr><name>n</name> &lt; 0</expr>)</condition><then>
<return>return <expr><call><name><name>s</name>-&gt;<name>errorhandler</name></name><argument_list>()</argument_list></call></expr>;</return></then></if>
<return>return <expr><call><name>PyInt_FromLong</name><argument_list>(<argument><expr>(<name>long</name>)<name>n</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>sendto_doc</name></expr></argument>,
<argument><expr>"sendto(data[, flags], address) -&gt; count\n\
\n\
Like send(data, flags) but allows specifying the destination address.\n\
For IP sockets, the address is a pair (hostaddr, port)."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>sock_shutdown</name><parameter_list>(<param><decl><type><name>PySocketSockObject</name> *</type><name>s</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>arg</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>how</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>res</name></decl>;</decl_stmt>
<expr_stmt><expr><name>how</name> = <call><name>PyInt_AsLong</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>how</name> == -1 &amp;&amp; <call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<decl_stmt><decl><type><name>Py_BEGIN_ALLOW_THREADS</name></type>
<name>res</name> <init>= <expr><call><name>shutdown</name><argument_list>(<argument><expr><name><name>s</name>-&gt;<name>sock_fd</name></name></expr></argument>, <argument><expr><name>how</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<macro><name>Py_END_ALLOW_THREADS</name></macro>
<if>if <condition>(<expr><name>res</name> &lt; 0</expr>)</condition><then>
<return>return <expr><call><name><name>s</name>-&gt;<name>errorhandler</name></name><argument_list>()</argument_list></call></expr>;</return></then></if>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>Py_None</name></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>shutdown_doc</name></expr></argument>,
<argument><expr>"shutdown(flag)\n\
\n\
Shut down the reading side of the socket (flag == SHUT_RD), the writing side\n\
of the socket (flag == SHUT_WR), or both ends (flag == SHUT_RDWR)."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MS_WINDOWS</name></expr></argument>)</argument_list></call> &amp;&amp; <call><name>defined</name><argument_list>(<argument><expr><name>SIO_RCVALL</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function><type><specifier>static</specifier> <name>PyObject</name>*</type>
<name>sock_ioctl</name><parameter_list>(<param><decl><type><name>PySocketSockObject</name> *</type><name>s</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>arg</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>cmd</name> <init>= <expr><name>SIO_RCVALL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>option</name> <init>= <expr><name>RCVALL_ON</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>DWORD</name></type> <name>recv</name></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr>"kI:ioctl"</expr></argument>, <argument><expr>&amp;<name>cmd</name></expr></argument>, <argument><expr>&amp;<name>option</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<if>if <condition>(<expr><call><name>WSAIoctl</name><argument_list>(<argument><expr><name><name>s</name>-&gt;<name>sock_fd</name></name></expr></argument>, <argument><expr><name>cmd</name></expr></argument>, <argument><expr>&amp;<name>option</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>option</name></expr></argument>)</argument_list></sizeof></expr></argument>,
<argument><expr><name>NULL</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>&amp;<name>recv</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call> == <name>SOCKET_ERROR</name></expr>)</condition><then> <block>{
<return>return <expr><call><name>set_error</name><argument_list>()</argument_list></call></expr>;</return>
}</block></then></if>
<return>return <expr><call><name>PyLong_FromUnsignedLong</name><argument_list>(<argument><expr><name>recv</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>sock_ioctl_doc</name></expr></argument>,
<argument><expr>"ioctl(cmd, option) -&gt; long\n\
\n\
Control the socket with WSAIoctl syscall. Currently only socket.SIO_RCVALL\n\
is supported as control. Options must be one of the socket.RCVALL_*\n\
constants."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<decl_stmt><decl><type><specifier>static</specifier> <name>PyMethodDef</name></type> <name><name>sock_methods</name><index>[]</index></name> <init>= <expr><block>{
<expr><block>{
<expr>"accept"</expr>, <expr>(<name>PyCFunction</name>)<name>sock_accept</name></expr>, <expr><name>METH_NOARGS</name></expr>,
<expr><name>accept_doc</name></expr>
}</block></expr>,
<expr><block>{
<expr>"bind"</expr>, <expr>(<name>PyCFunction</name>)<name>sock_bind</name></expr>, <expr><name>METH_O</name></expr>,
<expr><name>bind_doc</name></expr>
}</block></expr>,
<expr><block>{
<expr>"close"</expr>, <expr>(<name>PyCFunction</name>)<name>sock_close</name></expr>, <expr><name>METH_NOARGS</name></expr>,
<expr><name>close_doc</name></expr>
}</block></expr>,
<expr><block>{
<expr>"connect"</expr>, <expr>(<name>PyCFunction</name>)<name>sock_connect</name></expr>, <expr><name>METH_O</name></expr>,
<expr><name>connect_doc</name></expr>
}</block></expr>,
<expr><block>{
<expr>"connect_ex"</expr>, <expr>(<name>PyCFunction</name>)<name>sock_connect_ex</name></expr>, <expr><name>METH_O</name></expr>,
<expr><name>connect_ex_doc</name></expr>
}</block></expr>,
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>NO_DUP</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{
<expr>"dup"</expr>, <expr>(<name>PyCFunction</name>)<name>sock_dup</name></expr>, <expr><name>METH_NOARGS</name></expr>,
<expr><name>dup_doc</name></expr>
}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr><block>{
<expr>"fileno"</expr>, <expr>(<name>PyCFunction</name>)<name>sock_fileno</name></expr>, <expr><name>METH_NOARGS</name></expr>,
<expr><name>fileno_doc</name></expr>
}</block></expr>,
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_GETPEERNAME</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{
<expr>"getpeername"</expr>, <expr>(<name>PyCFunction</name>)<name>sock_getpeername</name></expr>,
<expr><name>METH_NOARGS</name></expr>, <expr><name>getpeername_doc</name></expr>
}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr><block>{
<expr>"getsockname"</expr>, <expr>(<name>PyCFunction</name>)<name>sock_getsockname</name></expr>,
<expr><name>METH_NOARGS</name></expr>, <expr><name>getsockname_doc</name></expr>
}</block></expr>,
<expr><block>{
<expr>"getsockopt"</expr>, <expr>(<name>PyCFunction</name>)<name>sock_getsockopt</name></expr>, <expr><name>METH_VARARGS</name></expr>,
<expr><name>getsockopt_doc</name></expr>
}</block></expr>,
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MS_WINDOWS</name></expr></argument>)</argument_list></call> &amp;&amp; <call><name>defined</name><argument_list>(<argument><expr><name>SIO_RCVALL</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{
<expr>"ioctl"</expr>, <expr>(<name>PyCFunction</name>)<name>sock_ioctl</name></expr>, <expr><name>METH_VARARGS</name></expr>,
<expr><name>sock_ioctl_doc</name></expr>
}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr><block>{
<expr>"listen"</expr>, <expr>(<name>PyCFunction</name>)<name>sock_listen</name></expr>, <expr><name>METH_O</name></expr>,
<expr><name>listen_doc</name></expr>
}</block></expr>,
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>NO_DUP</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{
<expr>"makefile"</expr>, <expr>(<name>PyCFunction</name>)<name>sock_makefile</name></expr>, <expr><name>METH_VARARGS</name></expr>,
<expr><name>makefile_doc</name></expr>
}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr><block>{
<expr>"recv"</expr>, <expr>(<name>PyCFunction</name>)<name>sock_recv</name></expr>, <expr><name>METH_VARARGS</name></expr>,
<expr><name>recv_doc</name></expr>
}</block></expr>,
<expr><block>{
<expr>"recv_into"</expr>, <expr>(<name>PyCFunction</name>)<name>sock_recv_into</name></expr>, <expr><name>METH_VARARGS</name> | <name>METH_KEYWORDS</name></expr>,
<expr><name>recv_into_doc</name></expr>
}</block></expr>,
<expr><block>{
<expr>"recvfrom"</expr>, <expr>(<name>PyCFunction</name>)<name>sock_recvfrom</name></expr>, <expr><name>METH_VARARGS</name></expr>,
<expr><name>recvfrom_doc</name></expr>
}</block></expr>,
<expr><block>{
<expr>"recvfrom_into"</expr>, <expr>(<name>PyCFunction</name>)<name>sock_recvfrom_into</name></expr>, <expr><name>METH_VARARGS</name> | <name>METH_KEYWORDS</name></expr>,
<expr><name>recvfrom_into_doc</name></expr>
}</block></expr>,
<expr><block>{
<expr>"send"</expr>, <expr>(<name>PyCFunction</name>)<name>sock_send</name></expr>, <expr><name>METH_VARARGS</name></expr>,
<expr><name>send_doc</name></expr>
}</block></expr>,
<expr><block>{
<expr>"sendall"</expr>, <expr>(<name>PyCFunction</name>)<name>sock_sendall</name></expr>, <expr><name>METH_VARARGS</name></expr>,
<expr><name>sendall_doc</name></expr>
}</block></expr>,
<expr><block>{
<expr>"sendto"</expr>, <expr>(<name>PyCFunction</name>)<name>sock_sendto</name></expr>, <expr><name>METH_VARARGS</name></expr>,
<expr><name>sendto_doc</name></expr>
}</block></expr>,
<expr><block>{
<expr>"setblocking"</expr>, <expr>(<name>PyCFunction</name>)<name>sock_setblocking</name></expr>, <expr><name>METH_O</name></expr>,
<expr><name>setblocking_doc</name></expr>
}</block></expr>,
<expr><block>{
<expr>"settimeout"</expr>, <expr>(<name>PyCFunction</name>)<name>sock_settimeout</name></expr>, <expr><name>METH_O</name></expr>,
<expr><name>settimeout_doc</name></expr>
}</block></expr>,
<expr><block>{
<expr>"gettimeout"</expr>, <expr>(<name>PyCFunction</name>)<name>sock_gettimeout</name></expr>, <expr><name>METH_NOARGS</name></expr>,
<expr><name>gettimeout_doc</name></expr>
}</block></expr>,
<expr><block>{
<expr>"setsockopt"</expr>, <expr>(<name>PyCFunction</name>)<name>sock_setsockopt</name></expr>, <expr><name>METH_VARARGS</name></expr>,
<expr><name>setsockopt_doc</name></expr>
}</block></expr>,
<expr><block>{
<expr>"shutdown"</expr>, <expr>(<name>PyCFunction</name>)<name>sock_shutdown</name></expr>, <expr><name>METH_O</name></expr>,
<expr><name>shutdown_doc</name></expr>
}</block></expr>,
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>RISCOS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{
<expr>"sleeptaskw"</expr>, <expr>(<name>PyCFunction</name>)<name>sock_sleeptaskw</name></expr>, <expr><name>METH_O</name></expr>,
<expr><name>sleeptaskw_doc</name></expr>
}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr><block>{<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>}</block></expr>
}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>PyMemberDef</name></type> <name><name>sock_memberlist</name><index>[]</index></name> <init>= <expr><block>{
<expr><block>{<expr>"family"</expr>, <expr><name>T_INT</name></expr>, <expr><call><name>offsetof</name><argument_list>(<argument><expr><name>PySocketSockObject</name></expr></argument>, <argument><expr><name>sock_family</name></expr></argument>)</argument_list></call></expr>, <expr><name>READONLY</name></expr>, <expr>"the socket family"</expr>}</block></expr>,
<expr><block>{<expr>"type"</expr>, <expr><name>T_INT</name></expr>, <expr><call><name>offsetof</name><argument_list>(<argument><expr><name>PySocketSockObject</name></expr></argument>, <argument><expr><name>sock_type</name></expr></argument>)</argument_list></call></expr>, <expr><name>READONLY</name></expr>, <expr>"the socket type"</expr>}</block></expr>,
<expr><block>{<expr>"proto"</expr>, <expr><name>T_INT</name></expr>, <expr><call><name>offsetof</name><argument_list>(<argument><expr><name>PySocketSockObject</name></expr></argument>, <argument><expr><name>sock_proto</name></expr></argument>)</argument_list></call></expr>, <expr><name>READONLY</name></expr>, <expr>"the socket protocol"</expr>}</block></expr>,
<expr><block>{<expr>"timeout"</expr>, <expr><name>T_DOUBLE</name></expr>, <expr><call><name>offsetof</name><argument_list>(<argument><expr><name>PySocketSockObject</name></expr></argument>, <argument><expr><name>sock_timeout</name></expr></argument>)</argument_list></call></expr>, <expr><name>READONLY</name></expr>, <expr>"the socket timeout"</expr>}</block></expr>,
<expr><block>{<expr>0</expr>}</block></expr>,
}</block></expr></init></decl>;</decl_stmt>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>sock_dealloc</name><parameter_list>(<param><decl><type><name>PySocketSockObject</name> *</type><name>s</name></decl></param>)</parameter_list> <block>{
<if>if <condition>(<expr><name><name>s</name>-&gt;<name>sock_fd</name></name> != -1</expr>)</condition><then>
<expr_stmt><expr>(<name>void</name>) <call><name>SOCKETCLOSE</name><argument_list>(<argument><expr><name><name>s</name>-&gt;<name>sock_fd</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<expr_stmt><expr><call><name>Py_TYPE</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call>-&gt;<call><name>tp_free</name><argument_list>(<argument><expr>(<name>PyObject</name> *)<name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>sock_repr</name><parameter_list>(<param><decl><type><name>PySocketSockObject</name> *</type><name>s</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>char</name></type> <name><name>buf</name><index>[<expr>512</expr>]</index></name></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SIZEOF_SOCKET_T</name> &gt; <name>SIZEOF_LONG</name></expr></cpp:if>
<if>if <condition>(<expr><name><name>s</name>-&gt;<name>sock_fd</name></name> &gt; <name>LONG_MAX</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_OverflowError</name></expr></argument>,
<argument><expr>"no printf formatter to display "
"the socket descriptor in decimal"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><call><name>PyOS_snprintf</name><argument_list>(
<argument><expr><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>,
<argument><expr>"&lt;socket object, fd=%ld, family=%d, type=%d, protocol=%d&gt;"</expr></argument>,
<argument><expr>(<name>long</name>)<name><name>s</name>-&gt;<name>sock_fd</name></name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>sock_family</name></name></expr></argument>,
<argument><expr><name><name>s</name>-&gt;<name>sock_type</name></name></expr></argument>,
<argument><expr><name><name>s</name>-&gt;<name>sock_proto</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>PyString_FromString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>sock_new</name><parameter_list>(<param><decl><type><name>PyTypeObject</name> *</type><name>type</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>kwds</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>new</name></decl>;</decl_stmt>
<expr_stmt><expr><name>new</name> = <call><name><name>type</name>-&gt;<name>tp_alloc</name></name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>new</name> != <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr>((<name>PySocketSockObject</name> *)<name>new</name>)-&gt;<name>sock_fd</name> = -1</expr>;</expr_stmt>
<expr_stmt><expr>((<name>PySocketSockObject</name> *)<name>new</name>)-&gt;<name>sock_timeout</name> = -1.0</expr>;</expr_stmt>
<expr_stmt><expr>((<name>PySocketSockObject</name> *)<name>new</name>)-&gt;<name>errorhandler</name> = &amp;<name>set_error</name></expr>;</expr_stmt>
}</block></then></if>
<return>return <expr><name>new</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>sock_initobj</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>kwds</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PySocketSockObject</name> *</type><name>s</name> <init>= <expr>(<name>PySocketSockObject</name> *)<name>self</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>SOCKET_T</name></type> <name>fd</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>family</name> <init>= <expr><name>AF_INET</name></expr></init>, <name>type</name> <init>= <expr><name>SOCK_STREAM</name></expr></init>, <name>proto</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> *</type><name><name>keywords</name><index>[]</index></name> <init>= <expr><block>{<expr>"family"</expr>, <expr>"type"</expr>, <expr>"proto"</expr>, <expr>0</expr>}</block></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTupleAndKeywords</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>kwds</name></expr></argument>,
<argument><expr>"|iii:socket"</expr></argument>, <argument><expr><name>keywords</name></expr></argument>,
<argument><expr>&amp;<name>family</name></expr></argument>, <argument><expr>&amp;<name>type</name></expr></argument>, <argument><expr>&amp;<name>proto</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr>-1</expr>;</return></then></if>
<decl_stmt><decl><type><name>Py_BEGIN_ALLOW_THREADS</name></type>
<name>fd</name> <init>= <expr><call><name>socket</name><argument_list>(<argument><expr><name>family</name></expr></argument>, <argument><expr><name>type</name></expr></argument>, <argument><expr><name>proto</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<macro><name>Py_END_ALLOW_THREADS</name></macro>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MS_WINDOWS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if>if <condition>(<expr><name>fd</name> == <name>INVALID_SOCKET</name></expr>)</condition><then>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<if>if <condition>(<expr><name>fd</name> &lt; 0</expr>)</condition><then>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<block>{
<expr_stmt><expr><call><name>set_error</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<return>return <expr>-1</expr>;</return>
}</block></then></if></then></if>
<expr_stmt><expr><call><name>init_sockobject</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>fd</name></expr></argument>, <argument><expr><name>family</name></expr></argument>, <argument><expr><name>type</name></expr></argument>, <argument><expr><name>proto</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>0</expr>;</return>
}</block></function>
<decl_stmt><decl><type><specifier>static</specifier> <name>PyTypeObject</name></type> <name>sock_type</name> <init>= <expr><block>{
<expr><call><name>PyVarObject_HEAD_INIT</name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call>
"_socket.socket"</expr>,
<expr><sizeof>sizeof<argument_list>(<argument><expr><name>PySocketSockObject</name></expr></argument>)</argument_list></sizeof></expr>,
<expr>0</expr>,
<expr>(<name>destructor</name>)<name>sock_dealloc</name></expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>(<name>reprfunc</name>)<name>sock_repr</name></expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr><name>PyObject_GenericGetAttr</name></expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr><name>Py_TPFLAGS_DEFAULT</name> | <name>Py_TPFLAGS_BASETYPE</name></expr>,
<expr><name>sock_doc</name></expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr><name>sock_methods</name></expr>,
<expr><name>sock_memberlist</name></expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr><name>sock_initobj</name></expr>,
<expr><name>PyType_GenericAlloc</name></expr>,
<expr><name>sock_new</name></expr>,
<expr><name>PyObject_Del</name></expr>,
}</block></expr></init></decl>;</decl_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>socket_gethostname</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>unused</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>char</name></type> <name><name>buf</name><index>[<expr>1024</expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>res</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_BEGIN_ALLOW_THREADS</name></type>
<name>res</name> <init>= <expr><call><name>gethostname</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr>(<name>int</name>) sizeof <name>buf</name> - 1</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<macro><name>Py_END_ALLOW_THREADS</name></macro>
<if>if <condition>(<expr><name>res</name> &lt; 0</expr>)</condition><then>
<return>return <expr><call><name>set_error</name><argument_list>()</argument_list></call></expr>;</return></then></if>
<expr_stmt><expr><name><name>buf</name><index>[<expr/></index></name>sizeof <name>buf</name> - 1] = '\0'</expr>;</expr_stmt>
<return>return <expr><call><name>PyString_FromString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>gethostname_doc</name></expr></argument>,
<argument><expr>"gethostname() -&gt; string\n\
\n\
Return the current host name."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>socket_gethostbyname</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>char</name> *</type><name>name</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>sock_addr_t</name></type> <name>addrbuf</name></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"s:gethostbyname"</expr></argument>, <argument><expr>&amp;<name>name</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<if>if <condition>(<expr><call><name>setipaddr</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><call><name>SAS2SA</name><argument_list>(<argument><expr>&amp;<name>addrbuf</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>addrbuf</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>AF_INET</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<return>return <expr><call><name>makeipaddr</name><argument_list>(<argument><expr><call><name>SAS2SA</name><argument_list>(<argument><expr>&amp;<name>addrbuf</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument>struct <expr><name>sockaddr_in</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>gethostbyname_doc</name></expr></argument>,
<argument><expr>"gethostbyname(host) -&gt; address\n\
\n\
Return the IP address (a string of the form '255.255.255.255') for a host."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>gethost_common</name><parameter_list>(<param><decl><type>struct <name>hostent</name> *</type><name>h</name></decl></param>, <param><decl><type>struct <name>sockaddr</name> *</type><name>addr</name></decl></param>, <param><decl><type><name>int</name></type> <name>alen</name></decl></param>, <param><decl><type><name>int</name></type> <name>af</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>char</name> **</type><name>pch</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>rtn_tuple</name> <init>= <expr>(<name>PyObject</name> *)<name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>name_list</name> <init>= <expr>(<name>PyObject</name> *)<name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>addr_list</name> <init>= <expr>(<name>PyObject</name> *)<name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>tmp</name></decl>;</decl_stmt>
<if>if <condition>(<expr><name>h</name> == <name>NULL</name></expr>)</condition><then> <block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>RISCOS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>set_herror</name><argument_list>(<argument><expr><name>h_errno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>socket_error</name></expr></argument>, <argument><expr>"host not found"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<if>if <condition>(<expr><name><name>h</name>-&gt;<name>h_addrtype</name></name> != <name>af</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>socket_error</name></expr></argument>,
<argument><expr>(<name>char</name> *)<call><name>strerror</name><argument_list>(<argument><expr><name>EAFNOSUPPORT</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<switch>switch <condition>(<expr><name>af</name></expr>)</condition> <block>{
<case>case <expr><name>AF_INET</name></expr>:
<if>if <condition>(<expr><name>alen</name> &lt; <sizeof>sizeof<argument_list>(<argument>struct <expr><name>sockaddr_in</name></expr></argument>)</argument_list></sizeof></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<break>break;</break>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>ENABLE_IPV6</name></expr></argument>)</argument_list></call></expr></cpp:if>
</case><case>case <expr><name>AF_INET6</name></expr>:
<if>if <condition>(<expr><name>alen</name> &lt; <sizeof>sizeof<argument_list>(<argument>struct <expr><name>sockaddr_in6</name></expr></argument>)</argument_list></sizeof></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</case>}</block></switch>
<if>if <condition>(<expr>(<name>name_list</name> = <call><name>PyList_New</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call>) == <name>NULL</name></expr>)</condition><then>
<goto>goto <name>err</name>;</goto></then></if>
<if>if <condition>(<expr>(<name>addr_list</name> = <call><name>PyList_New</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call>) == <name>NULL</name></expr>)</condition><then>
<goto>goto <name>err</name>;</goto></then></if>
<if>if <condition>(<expr><name><name>h</name>-&gt;<name>h_aliases</name></name></expr>)</condition><then> <block>{
<for>for (<init><expr><name>pch</name> = <name><name>h</name>-&gt;<name>h_aliases</name></name></expr>;</init> <condition><expr>*<name>pch</name> != <name>NULL</name></expr>;</condition> <incr><expr><name>pch</name>++</expr></incr>) <block>{
<decl_stmt><decl><type><name>int</name></type> <name>status</name></decl>;</decl_stmt>
<expr_stmt><expr><name>tmp</name> = <call><name>PyString_FromString</name><argument_list>(<argument><expr>*<name>pch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>tmp</name> == <name>NULL</name></expr>)</condition><then>
<goto>goto <name>err</name>;</goto></then></if>
<expr_stmt><expr><name>status</name> = <call><name>PyList_Append</name><argument_list>(<argument><expr><name>name_list</name></expr></argument>, <argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>status</name></expr>)</condition><then>
<goto>goto <name>err</name>;</goto></then></if>
}</block></for>
}</block></then></if>
<for>for (<init><expr><name>pch</name> = <name><name>h</name>-&gt;<name>h_addr_list</name></name></expr>;</init> <condition><expr>*<name>pch</name> != <name>NULL</name></expr>;</condition> <incr><expr><name>pch</name>++</expr></incr>) <block>{
<decl_stmt><decl><type><name>int</name></type> <name>status</name></decl>;</decl_stmt>
<switch>switch <condition>(<expr><name>af</name></expr>)</condition> <block>{
<case>case <expr><name>AF_INET</name></expr>: <block>{
<decl_stmt><decl><type>struct <name>sockaddr_in</name></type> <name>sin</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr>&amp;<name>sin</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>sin</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>sin</name>.<name>sin_family</name></name> = <name>af</name></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_SOCKADDR_SA_LEN</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><name><name>sin</name>.<name>sin_len</name></name> = <sizeof>sizeof<argument_list>(<argument><expr><name>sin</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name><name>sin</name>.<name>sin_addr</name></name></expr></argument>, <argument><expr>*<name>pch</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>sin</name>.<name>sin_addr</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>tmp</name> = <call><name>makeipaddr</name><argument_list>(<argument><expr>(struct <name>sockaddr</name> *)&amp;<name>sin</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>sin</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>pch</name> == <name><name>h</name>-&gt;<name>h_addr_list</name></name> &amp;&amp; <name>alen</name> &gt;= <sizeof>sizeof<argument_list>(<argument><expr><name>sin</name></expr></argument>)</argument_list></sizeof></expr>)</condition><then>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>(<name>char</name> *) <name>addr</name></expr></argument>, <argument><expr>&amp;<name>sin</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>sin</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<break>break;</break>
}</block>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>ENABLE_IPV6</name></expr></argument>)</argument_list></call></expr></cpp:if>
</case><case>case <expr><name>AF_INET6</name></expr>: <block>{
<decl_stmt><decl><type>struct <name>sockaddr_in6</name></type> <name>sin6</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr>&amp;<name>sin6</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>sin6</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>sin6</name>.<name>sin6_family</name></name> = <name>af</name></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_SOCKADDR_SA_LEN</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><name><name>sin6</name>.<name>sin6_len</name></name> = <sizeof>sizeof<argument_list>(<argument><expr><name>sin6</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name><name>sin6</name>.<name>sin6_addr</name></name></expr></argument>, <argument><expr>*<name>pch</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>sin6</name>.<name>sin6_addr</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>tmp</name> = <call><name>makeipaddr</name><argument_list>(<argument><expr>(struct <name>sockaddr</name> *)&amp;<name>sin6</name></expr></argument>,
<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>sin6</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>pch</name> == <name><name>h</name>-&gt;<name>h_addr_list</name></name> &amp;&amp; <name>alen</name> &gt;= <sizeof>sizeof<argument_list>(<argument><expr><name>sin6</name></expr></argument>)</argument_list></sizeof></expr>)</condition><then>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>(<name>char</name> *) <name>addr</name></expr></argument>, <argument><expr>&amp;<name>sin6</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>sin6</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<break>break;</break>
}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</case><default>default:
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>socket_error</name></expr></argument>,
<argument><expr>"unsupported address family"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
</default>}</block></switch>
<if>if <condition>(<expr><name>tmp</name> == <name>NULL</name></expr>)</condition><then>
<goto>goto <name>err</name>;</goto></then></if>
<expr_stmt><expr><name>status</name> = <call><name>PyList_Append</name><argument_list>(<argument><expr><name>addr_list</name></expr></argument>, <argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>status</name></expr>)</condition><then>
<goto>goto <name>err</name>;</goto></then></if>
}</block></for>
<expr_stmt><expr><name>rtn_tuple</name> = <call><name>Py_BuildValue</name><argument_list>(<argument><expr>"sOO"</expr></argument>, <argument><expr><name><name>h</name>-&gt;<name>h_name</name></name></expr></argument>, <argument><expr><name>name_list</name></expr></argument>, <argument><expr><name>addr_list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<label><name>err</name>:</label>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>name_list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>addr_list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>rtn_tuple</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>socket_gethostbyname_ex</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>char</name> *</type><name>name</name></decl>;</decl_stmt>
<decl_stmt><decl><type>struct <name>hostent</name> *</type><name>h</name></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>ENABLE_IPV6</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type>struct <name>sockaddr_storage</name></type> <name>addr</name></decl>;</decl_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<decl_stmt><decl><type>struct <name>sockaddr_in</name></type> <name>addr</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<decl_stmt><decl><type>struct <name>sockaddr</name> *</type><name>sa</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>ret</name></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_GETHOSTBYNAME_R</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type>struct <name>hostent</name></type> <name>hp_allocated</name></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_GETHOSTBYNAME_R_3_ARG</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type>struct <name>hostent_data</name></type> <name>data</name></decl>;</decl_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<decl_stmt><decl><type><name>char</name></type> <name><name>buf</name><index>[<expr>16384</expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>buf_len</name> <init>= <expr>(sizeof <name>buf</name>) - 1</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>errnop</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_GETHOSTBYNAME_R_3_ARG</name></expr></argument>)</argument_list></call> || <call><name>defined</name><argument_list>(<argument><expr><name>HAVE_GETHOSTBYNAME_R_6_ARG</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>int</name></type> <name>result</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"s:gethostbyname_ex"</expr></argument>, <argument><expr>&amp;<name>name</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<if>if <condition>(<expr><call><name>setipaddr</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr>(struct <name>sockaddr</name> *)&amp;<name>addr</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>addr</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>AF_INET</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<decl_stmt><decl><type><name>Py_BEGIN_ALLOW_THREADS</name></type>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_GETHOSTBYNAME_R</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_GETHOSTBYNAME_R_6_ARG</name></expr></argument>)</argument_list></call></expr></cpp:if>
<name>result</name> <init>= <expr><call><name>gethostbyname_r</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr>&amp;<name>hp_allocated</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>buf_len</name></expr></argument>,
<argument><expr>&amp;<name>h</name></expr></argument>, <argument><expr>&amp;<name>errnop</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_GETHOSTBYNAME_R_5_ARG</name></expr></argument>)</argument_list></call></expr></cpp:elif>
<expr_stmt><expr><name>h</name> = <call><name>gethostbyname_r</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr>&amp;<name>hp_allocated</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>buf_len</name></expr></argument>, <argument><expr>&amp;<name>errnop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr>(<name>void</name> *) &amp;<name>data</name></expr></argument>, <argument><expr>'\0'</expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>data</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>result</name> = <call><name>gethostbyname_r</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr>&amp;<name>hp_allocated</name></expr></argument>, <argument><expr>&amp;<name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>h</name> = (<name>result</name> != 0) ? <name>NULL</name> : &amp;<name>hp_allocated</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>USE_GETHOSTBYNAME_LOCK</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyThread_acquire_lock</name><argument_list>(<argument><expr><name>netdb_lock</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><name>h</name> = <call><name>gethostbyname</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<decl_stmt><decl><type><name>Py_END_ALLOW_THREADS</name></type>
<name>sa</name> <init>= <expr>(struct <name>sockaddr</name>*)&amp;<name>addr</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>ret</name> = <call><name>gethost_common</name><argument_list>(<argument><expr><name>h</name></expr></argument>, <argument><expr>(struct <name>sockaddr</name> *)&amp;<name>addr</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>addr</name></expr></argument>)</argument_list></sizeof></expr></argument>,
<argument><expr><name><name>sa</name>-&gt;<name>sa_family</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>USE_GETHOSTBYNAME_LOCK</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyThread_release_lock</name><argument_list>(<argument><expr><name>netdb_lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<return>return <expr><name>ret</name></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>ghbn_ex_doc</name></expr></argument>,
<argument><expr>"gethostbyname_ex(host) -&gt; (name, aliaslist, addresslist)\n\
\n\
Return the true host name, a list of aliases, and a list of IP addresses,\n\
for a host. The host argument is a string giving a host name or IP number."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>socket_gethostbyaddr</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>ENABLE_IPV6</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type>struct <name>sockaddr_storage</name></type> <name>addr</name></decl>;</decl_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<decl_stmt><decl><type>struct <name>sockaddr_in</name></type> <name>addr</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<decl_stmt><decl><type>struct <name>sockaddr</name> *</type><name>sa</name> <init>= <expr>(struct <name>sockaddr</name> *)&amp;<name>addr</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>ip_num</name></decl>;</decl_stmt>
<decl_stmt><decl><type>struct <name>hostent</name> *</type><name>h</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>ret</name></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_GETHOSTBYNAME_R</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type>struct <name>hostent</name></type> <name>hp_allocated</name></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_GETHOSTBYNAME_R_3_ARG</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type>struct <name>hostent_data</name></type> <name>data</name></decl>;</decl_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<decl_stmt><decl><type><name>char</name></type> <name><name>buf</name><index>[<expr>16384</expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>buf_len</name> <init>= <expr>(sizeof <name>buf</name>) - 1</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>errnop</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_GETHOSTBYNAME_R_3_ARG</name></expr></argument>)</argument_list></call> || <call><name>defined</name><argument_list>(<argument><expr><name>HAVE_GETHOSTBYNAME_R_6_ARG</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>int</name></type> <name>result</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<decl_stmt><decl><type><name>char</name> *</type><name>ap</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>al</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>af</name></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"s:gethostbyaddr"</expr></argument>, <argument><expr>&amp;<name>ip_num</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>af</name> = <name>AF_UNSPEC</name></expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>setipaddr</name><argument_list>(<argument><expr><name>ip_num</name></expr></argument>, <argument><expr><name>sa</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>addr</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>af</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>af</name> = <name><name>sa</name>-&gt;<name>sa_family</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>ap</name> = <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name>al</name> = 0</expr>;</expr_stmt>
<switch>switch <condition>(<expr><name>af</name></expr>)</condition> <block>{
<case>case <expr><name>AF_INET</name></expr>:
<expr_stmt><expr><name>ap</name> = (<name>char</name> *)&amp;((struct <name>sockaddr_in</name> *)<name>sa</name>)-&gt;<name>sin_addr</name></expr>;</expr_stmt>
<expr_stmt><expr><name>al</name> = <sizeof>sizeof<argument_list>(<argument><expr>((struct <name>sockaddr_in</name> *)<name>sa</name>)-&gt;<name>sin_addr</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
<break>break;</break>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>ENABLE_IPV6</name></expr></argument>)</argument_list></call></expr></cpp:if>
</case><case>case <expr><name>AF_INET6</name></expr>:
<expr_stmt><expr><name>ap</name> = (<name>char</name> *)&amp;((struct <name>sockaddr_in6</name> *)<name>sa</name>)-&gt;<name>sin6_addr</name></expr>;</expr_stmt>
<expr_stmt><expr><name>al</name> = <sizeof>sizeof<argument_list>(<argument><expr>((struct <name>sockaddr_in6</name> *)<name>sa</name>)-&gt;<name>sin6_addr</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
<break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</case><default>default:
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>socket_error</name></expr></argument>, <argument><expr>"unsupported address family"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
</default>}</block></switch>
<decl_stmt><decl><type><name>Py_BEGIN_ALLOW_THREADS</name></type>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_GETHOSTBYNAME_R</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_GETHOSTBYNAME_R_6_ARG</name></expr></argument>)</argument_list></call></expr></cpp:if>
<name>result</name> <init>= <expr><call><name>gethostbyaddr_r</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>al</name></expr></argument>, <argument><expr><name>af</name></expr></argument>,
<argument><expr>&amp;<name>hp_allocated</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>buf_len</name></expr></argument>,
<argument><expr>&amp;<name>h</name></expr></argument>, <argument><expr>&amp;<name>errnop</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_GETHOSTBYNAME_R_5_ARG</name></expr></argument>)</argument_list></call></expr></cpp:elif>
<expr_stmt><expr><name>h</name> = <call><name>gethostbyaddr_r</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>al</name></expr></argument>, <argument><expr><name>af</name></expr></argument>,
<argument><expr>&amp;<name>hp_allocated</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>buf_len</name></expr></argument>, <argument><expr>&amp;<name>errnop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr>(<name>void</name> *) &amp;<name>data</name></expr></argument>, <argument><expr>'\0'</expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>data</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>result</name> = <call><name>gethostbyaddr_r</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>al</name></expr></argument>, <argument><expr><name>af</name></expr></argument>, <argument><expr>&amp;<name>hp_allocated</name></expr></argument>, <argument><expr>&amp;<name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>h</name> = (<name>result</name> != 0) ? <name>NULL</name> : &amp;<name>hp_allocated</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>USE_GETHOSTBYNAME_LOCK</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyThread_acquire_lock</name><argument_list>(<argument><expr><name>netdb_lock</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><name>h</name> = <call><name>gethostbyaddr</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>al</name></expr></argument>, <argument><expr><name>af</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<decl_stmt><decl><type><name>Py_END_ALLOW_THREADS</name></type>
<name>ret</name> <init>= <expr><call><name>gethost_common</name><argument_list>(<argument><expr><name>h</name></expr></argument>, <argument><expr>(struct <name>sockaddr</name> *)&amp;<name>addr</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>addr</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>af</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>USE_GETHOSTBYNAME_LOCK</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyThread_release_lock</name><argument_list>(<argument><expr><name>netdb_lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<return>return <expr><name>ret</name></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>gethostbyaddr_doc</name></expr></argument>,
<argument><expr>"gethostbyaddr(host) -&gt; (name, aliaslist, addresslist)\n\
\n\
Return the true host name, a list of aliases, and a list of IP addresses,\n\
for a host. The host argument is a string giving a host name or IP number."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>socket_getservbyname</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>char</name> *</type><name>name</name></decl>, *<decl><type ref="prev"/><name>proto</name><init>=<expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type>struct <name>servent</name> *</type><name>sp</name></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"s|s:getservbyname"</expr></argument>, <argument><expr>&amp;<name>name</name></expr></argument>, <argument><expr>&amp;<name>proto</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<decl_stmt><decl><type><name>Py_BEGIN_ALLOW_THREADS</name></type>
<name>sp</name> <init>= <expr><call><name>getservbyname</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>proto</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<macro><name>Py_END_ALLOW_THREADS</name></macro>
<if>if <condition>(<expr><name>sp</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>socket_error</name></expr></argument>, <argument><expr>"service/proto not found"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<return>return <expr><call><name>PyInt_FromLong</name><argument_list>(<argument><expr>(<name>long</name>) <call><name>ntohs</name><argument_list>(<argument><expr><name><name>sp</name>-&gt;<name>s_port</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>getservbyname_doc</name></expr></argument>,
<argument><expr>"getservbyname(servicename[, protocolname]) -&gt; integer\n\
\n\
Return a port number from a service name and protocol name.\n\
The optional protocol name, if given, should be 'tcp' or 'udp',\n\
otherwise any protocol will match."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>socket_getservbyport</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>unsigned</name> <name>short</name></type> <name>port</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>proto</name><init>=<expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type>struct <name>servent</name> *</type><name>sp</name></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"H|s:getservbyport"</expr></argument>, <argument><expr>&amp;<name>port</name></expr></argument>, <argument><expr>&amp;<name>proto</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<decl_stmt><decl><type><name>Py_BEGIN_ALLOW_THREADS</name></type>
<name>sp</name> <init>= <expr><call><name>getservbyport</name><argument_list>(<argument><expr><call><name>htons</name><argument_list>(<argument><expr><name>port</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>proto</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<macro><name>Py_END_ALLOW_THREADS</name></macro>
<if>if <condition>(<expr><name>sp</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>socket_error</name></expr></argument>, <argument><expr>"port/proto not found"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<return>return <expr><call><name>PyString_FromString</name><argument_list>(<argument><expr><name><name>sp</name>-&gt;<name>s_name</name></name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>getservbyport_doc</name></expr></argument>,
<argument><expr>"getservbyport(port[, protocolname]) -&gt; string\n\
\n\
Return the service name from a port number and protocol name.\n\
The optional protocol name, if given, should be 'tcp' or 'udp',\n\
otherwise any protocol will match."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>socket_getprotobyname</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>char</name> *</type><name>name</name></decl>;</decl_stmt>
<decl_stmt><decl><type>struct <name>protoent</name> *</type><name>sp</name></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__BEOS__</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>socket_error</name></expr></argument>, <argument><expr>"getprotobyname not supported"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"s:getprotobyname"</expr></argument>, <argument><expr>&amp;<name>name</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<decl_stmt><decl><type><name>Py_BEGIN_ALLOW_THREADS</name></type>
<name>sp</name> <init>= <expr><call><name>getprotobyname</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<macro><name>Py_END_ALLOW_THREADS</name></macro>
<if>if <condition>(<expr><name>sp</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>socket_error</name></expr></argument>, <argument><expr>"protocol not found"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<return>return <expr><call><name>PyInt_FromLong</name><argument_list>(<argument><expr>(<name>long</name>) <name><name>sp</name>-&gt;<name>p_proto</name></name></expr></argument>)</argument_list></call></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>getprotobyname_doc</name></expr></argument>,
<argument><expr>"getprotobyname(name) -&gt; integer\n\
\n\
Return the protocol number for the named protocol. (Rarely used.)"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_SOCKETPAIR</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>socket_socketpair</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PySocketSockObject</name> *</type><name>s0</name> <init>= <expr><name>NULL</name></expr></init>, *<name>s1</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>SOCKET_T</name></type> <name><name>sv</name><index>[<expr>2</expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>family</name></decl>, <decl><type ref="prev"/><name>type</name> <init>= <expr><name>SOCK_STREAM</name></expr></init>, <name>proto</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>res</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>AF_UNIX</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><name>family</name> = <name>AF_UNIX</name></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<expr_stmt><expr><name>family</name> = <name>AF_INET</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"|iii:socketpair"</expr></argument>,
<argument><expr>&amp;<name>family</name></expr></argument>, <argument><expr>&amp;<name>type</name></expr></argument>, <argument><expr>&amp;<name>proto</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<if>if <condition>(<expr><call><name>socketpair</name><argument_list>(<argument><expr><name>family</name></expr></argument>, <argument><expr><name>type</name></expr></argument>, <argument><expr><name>proto</name></expr></argument>, <argument><expr><name>sv</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
<return>return <expr><call><name>set_error</name><argument_list>()</argument_list></call></expr>;</return></then></if>
<expr_stmt><expr><name>s0</name> = <call><name>new_sockobject</name><argument_list>(<argument><expr><name><name>sv</name><index>[<expr>0</expr>]</index></name></expr></argument>, <argument><expr><name>family</name></expr></argument>, <argument><expr><name>type</name></expr></argument>, <argument><expr><name>proto</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>s0</name> == <name>NULL</name></expr>)</condition><then>
<goto>goto <name>finally</name>;</goto></then></if>
<expr_stmt><expr><name>s1</name> = <call><name>new_sockobject</name><argument_list>(<argument><expr><name><name>sv</name><index>[<expr>1</expr>]</index></name></expr></argument>, <argument><expr><name>family</name></expr></argument>, <argument><expr><name>type</name></expr></argument>, <argument><expr><name>proto</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>s1</name> == <name>NULL</name></expr>)</condition><then>
<goto>goto <name>finally</name>;</goto></then></if>
<expr_stmt><expr><name>res</name> = <call><name>PyTuple_Pack</name><argument_list>(<argument><expr>2</expr></argument>, <argument><expr><name>s0</name></expr></argument>, <argument><expr><name>s1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<label><name>finally</name>:</label>
<if>if <condition>(<expr><name>res</name> == <name>NULL</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr><name>s0</name> == <name>NULL</name></expr>)</condition><then>
<expr_stmt><expr><call><name>SOCKETCLOSE</name><argument_list>(<argument><expr><name><name>sv</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<if>if <condition>(<expr><name>s1</name> == <name>NULL</name></expr>)</condition><then>
<expr_stmt><expr><call><name>SOCKETCLOSE</name><argument_list>(<argument><expr><name><name>sv</name><index>[<expr>1</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
}</block></then></if>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>s0</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>s1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>res</name></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>socketpair_doc</name></expr></argument>,
<argument><expr>"socketpair([family[, type[, proto]]]) -&gt; (socket object, socket object)\n\
\n\
Create a pair of socket objects from the sockets returned by the platform\n\
socketpair() function.\n\
The arguments are the same as for socket() except the default family is\n\
AF_UNIX if defined on the platform; otherwise, the default is AF_INET."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>NO_DUP</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>socket_fromfd</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PySocketSockObject</name> *</type><name>s</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>SOCKET_T</name></type> <name>fd</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>family</name></decl>, <decl><type ref="prev"/><name>type</name></decl>, <decl><type ref="prev"/><name>proto</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"iii|i:fromfd"</expr></argument>,
<argument><expr>&amp;<name>fd</name></expr></argument>, <argument><expr>&amp;<name>family</name></expr></argument>, <argument><expr>&amp;<name>type</name></expr></argument>, <argument><expr>&amp;<name>proto</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>fd</name> = <call><name>dup</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>fd</name> &lt; 0</expr>)</condition><then>
<return>return <expr><call><name>set_error</name><argument_list>()</argument_list></call></expr>;</return></then></if>
<expr_stmt><expr><name>s</name> = <call><name>new_sockobject</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>family</name></expr></argument>, <argument><expr><name>type</name></expr></argument>, <argument><expr><name>proto</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>(<name>PyObject</name> *) <name>s</name></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>fromfd_doc</name></expr></argument>,
<argument><expr>"fromfd(fd, family, type[, proto]) -&gt; socket object\n\
\n\
Create a socket object from a duplicate of the given\n\
file descriptor.\n\
The remaining arguments are the same as for socket()."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>socket_ntohs</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>x1</name></decl>, <decl><type ref="prev"/><name>x2</name></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"i:ntohs"</expr></argument>, <argument><expr>&amp;<name>x1</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<if>if <condition>(<expr><name>x1</name> &lt; 0</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_OverflowError</name></expr></argument>,
<argument><expr>"can't convert negative number to unsigned long"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>x2</name> = (<name>unsigned</name> <name>int</name>)<call><name>ntohs</name><argument_list>(<argument><expr>(<name>unsigned</name> <name>short</name>)<name>x1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>PyInt_FromLong</name><argument_list>(<argument><expr><name>x2</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>ntohs_doc</name></expr></argument>,
<argument><expr>"ntohs(integer) -&gt; integer\n\
\n\
Convert a 16-bit integer from network to host byte order."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>socket_ntohl</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>arg</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>x</name></decl>;</decl_stmt>
<if>if <condition>(<expr><call><name>PyInt_Check</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><name>x</name> = <call><name>PyInt_AS_LONG</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>x</name> == (<name>unsigned</name> <name>long</name>) -1 &amp;&amp; <call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<if>if <condition>(<expr>(<name>long</name>)<name>x</name> &lt; 0</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_OverflowError</name></expr></argument>,
<argument><expr>"can't convert negative number to unsigned long"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
}</block></then> <else>else <if>if <condition>(<expr><call><name>PyLong_Check</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><name>x</name> = <call><name>PyLong_AsUnsignedLong</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>x</name> == (<name>unsigned</name> <name>long</name>) -1 &amp;&amp; <call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SIZEOF_LONG</name> &gt; 4</expr></cpp:if>
<block>{
<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>y</name></decl>;</decl_stmt>
<expr_stmt><expr><name>y</name> = <name>x</name> &amp; 0xFFFFFFFFUL</expr>;</expr_stmt>
<if>if <condition>(<expr><name>y</name> ^ <name>x</name></expr>)</condition><then>
<return>return <expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_OverflowError</name></expr></argument>,
<argument><expr>"long int larger than 32 bits"</expr></argument>)</argument_list></call></expr>;</return></then></if>
<expr_stmt><expr><name>x</name> = <name>y</name></expr>;</expr_stmt>
}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></then> <else>else
<return>return <expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
<argument><expr>"expected int/long, %s found"</expr></argument>,
<argument><expr><call><name>Py_TYPE</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call>-&gt;<name>tp_name</name></expr></argument>)</argument_list></call></expr>;</return></else></if></else></if>
<if>if <condition>(<expr><name>x</name> == (<name>unsigned</name> <name>long</name>) -1 &amp;&amp; <call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<return>return <expr><call><name>PyLong_FromUnsignedLong</name><argument_list>(<argument><expr><call><name>ntohl</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>ntohl_doc</name></expr></argument>,
<argument><expr>"ntohl(integer) -&gt; integer\n\
\n\
Convert a 32-bit integer from network to host byte order."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>socket_htons</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>x1</name></decl>, <decl><type ref="prev"/><name>x2</name></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"i:htons"</expr></argument>, <argument><expr>&amp;<name>x1</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<if>if <condition>(<expr><name>x1</name> &lt; 0</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_OverflowError</name></expr></argument>,
<argument><expr>"can't convert negative number to unsigned long"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>x2</name> = (<name>unsigned</name> <name>int</name>)<call><name>htons</name><argument_list>(<argument><expr>(<name>unsigned</name> <name>short</name>)<name>x1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>PyInt_FromLong</name><argument_list>(<argument><expr><name>x2</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>htons_doc</name></expr></argument>,
<argument><expr>"htons(integer) -&gt; integer\n\
\n\
Convert a 16-bit integer from host to network byte order."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>socket_htonl</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>arg</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>x</name></decl>;</decl_stmt>
<if>if <condition>(<expr><call><name>PyInt_Check</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><name>x</name> = <call><name>PyInt_AS_LONG</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>x</name> == (<name>unsigned</name> <name>long</name>) -1 &amp;&amp; <call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<if>if <condition>(<expr>(<name>long</name>)<name>x</name> &lt; 0</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_OverflowError</name></expr></argument>,
<argument><expr>"can't convert negative number to unsigned long"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
}</block></then> <else>else <if>if <condition>(<expr><call><name>PyLong_Check</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><name>x</name> = <call><name>PyLong_AsUnsignedLong</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>x</name> == (<name>unsigned</name> <name>long</name>) -1 &amp;&amp; <call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SIZEOF_LONG</name> &gt; 4</expr></cpp:if>
<block>{
<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>y</name></decl>;</decl_stmt>
<expr_stmt><expr><name>y</name> = <name>x</name> &amp; 0xFFFFFFFFUL</expr>;</expr_stmt>
<if>if <condition>(<expr><name>y</name> ^ <name>x</name></expr>)</condition><then>
<return>return <expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_OverflowError</name></expr></argument>,
<argument><expr>"long int larger than 32 bits"</expr></argument>)</argument_list></call></expr>;</return></then></if>
<expr_stmt><expr><name>x</name> = <name>y</name></expr>;</expr_stmt>
}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></then> <else>else
<return>return <expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
<argument><expr>"expected int/long, %s found"</expr></argument>,
<argument><expr><call><name>Py_TYPE</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call>-&gt;<name>tp_name</name></expr></argument>)</argument_list></call></expr>;</return></else></if></else></if>
<return>return <expr><call><name>PyLong_FromUnsignedLong</name><argument_list>(<argument><expr><call><name>htonl</name><argument_list>(<argument><expr>(<name>unsigned</name> <name>long</name>)<name>x</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>htonl_doc</name></expr></argument>,
<argument><expr>"htonl(integer) -&gt; integer\n\
\n\
Convert a 32-bit integer from host to network byte order."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>inet_aton_doc</name></expr></argument>,
<argument><expr>"inet_aton(string) -&gt; packed 32-bit IP representation\n\
\n\
Convert an IP address in string format (123.45.67.89) to the 32-bit packed\n\
binary format used in low-level network functions."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name>*</type>
<name>socket_inet_aton</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>INADDR_NONE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INADDR_NONE</name></cpp:macro> <cpp:value>(-1)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_INET_ATON</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type>struct <name>in_addr</name></type> <name>buf</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>HAVE_INET_ATON</name></expr></argument>)</argument_list></call> || <call><name>defined</name><argument_list>(<argument><expr><name>USE_INET_ATON_WEAKLINK</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>packed_addr</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<decl_stmt><decl><type><name>char</name> *</type><name>ip_addr</name></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"s:inet_aton"</expr></argument>, <argument><expr>&amp;<name>ip_addr</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_INET_ATON</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>USE_INET_ATON_WEAKLINK</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if>if <condition>(<expr><name>inet_aton</name> != <name>NULL</name></expr>)</condition><then> <block>{
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<if>if <condition>(<expr><call><name>inet_aton</name><argument_list>(<argument><expr><name>ip_addr</name></expr></argument>, <argument><expr>&amp;<name>buf</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><call><name>PyString_FromStringAndSize</name><argument_list>(<argument><expr><call>(<name>char</name> *)<argument_list>(<argument><expr>&amp;<name>buf</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</return></then></if>
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>socket_error</name></expr></argument>,
<argument><expr>"illegal IP address string passed to inet_aton"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>USE_INET_ATON_WEAKLINK</name></expr></argument>)</argument_list></call></expr></cpp:if>
}</block></then> <else>else <block>{
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>HAVE_INET_ATON</name></expr></argument>)</argument_list></call> || <call><name>defined</name><argument_list>(<argument><expr><name>USE_INET_ATON_WEAKLINK</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>ip_addr</name></expr></argument>, <argument><expr>"255.255.255.255"</expr></argument>)</argument_list></call> == 0</expr>)</condition><then> <block>{
<expr_stmt><expr><name>packed_addr</name> = 0xFFFFFFFF</expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr><name>packed_addr</name> = <call><name>inet_addr</name><argument_list>(<argument><expr><name>ip_addr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>packed_addr</name> == <name>INADDR_NONE</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>socket_error</name></expr></argument>,
<argument><expr>"illegal IP address string passed to inet_aton"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
}</block></else></if>
<return>return <expr><call><name>PyString_FromStringAndSize</name><argument_list>(<argument><expr>(<name>char</name> *) &amp;<name>packed_addr</name></expr></argument>,
<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>packed_addr</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</return>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>USE_INET_ATON_WEAKLINK</name></expr></argument>)</argument_list></call></expr></cpp:if>
}</block></else></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>inet_ntoa_doc</name></expr></argument>,
<argument><expr>"inet_ntoa(packed_ip) -&gt; ip_address_string\n\
\n\
Convert an IP address from 32-bit packed binary format to string format"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name>*</type>
<name>socket_inet_ntoa</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>char</name> *</type><name>packed_str</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>addr_len</name></decl>;</decl_stmt>
<decl_stmt><decl><type>struct <name>in_addr</name></type> <name>packed_addr</name></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"s#:inet_ntoa"</expr></argument>, <argument><expr>&amp;<name>packed_str</name></expr></argument>, <argument><expr>&amp;<name>addr_len</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<if>if <condition>(<expr><name>addr_len</name> != <sizeof>sizeof<argument_list>(<argument><expr><name>packed_addr</name></expr></argument>)</argument_list></sizeof></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>socket_error</name></expr></argument>,
<argument><expr>"packed IP wrong length for inet_ntoa"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name>packed_addr</name></expr></argument>, <argument><expr><name>packed_str</name></expr></argument>, <argument><expr><name>addr_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>PyString_FromString</name><argument_list>(<argument><expr><call><name>inet_ntoa</name><argument_list>(<argument><expr><name>packed_addr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_INET_PTON</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>inet_pton_doc</name></expr></argument>,
<argument><expr>"inet_pton(af, ip) -&gt; packed IP address string\n\
\n\
Convert an IP address from string format to a packed string suitable\n\
for use with low-level network functions."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>socket_inet_pton</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>af</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name>*</type> <name>ip</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>retval</name></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>ENABLE_IPV6</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>char</name></type> <name><name>packed</name><index>[<expr><call><name>MAX</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument>struct <argument><expr><name>in_addr</name></expr></argument></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument>struct <argument><expr><name>in6_addr</name></expr></argument></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>]</index></name></decl>;</decl_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<decl_stmt><decl><type><name>char</name></type> <name><name>packed</name><index>[<expr><sizeof>sizeof<argument_list>(<argument>struct <argument><expr><name>in_addr</name></expr></argument></argument>)</argument_list></sizeof></expr>]</index></name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"is:inet_pton"</expr></argument>, <argument><expr>&amp;<name>af</name></expr></argument>, <argument><expr>&amp;<name>ip</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>ENABLE_IPV6</name></expr></argument>)</argument_list></call> &amp;&amp; <call><name>defined</name><argument_list>(<argument><expr><name>AF_INET6</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if>if<condition>(<expr><name>af</name> == <name>AF_INET6</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>socket_error</name></expr></argument>,
<argument><expr>"can't use AF_INET6, IPv6 is disabled"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><name>retval</name> = <call><name>inet_pton</name><argument_list>(<argument><expr><name>af</name></expr></argument>, <argument><expr><name>ip</name></expr></argument>, <argument><expr><name>packed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>retval</name> &lt; 0</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetFromErrno</name><argument_list>(<argument><expr><name>socket_error</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then> <else>else <if>if <condition>(<expr><name>retval</name> == 0</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>socket_error</name></expr></argument>,
<argument><expr>"illegal IP address string passed to inet_pton"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then> <else>else <if>if <condition>(<expr><name>af</name> == <name>AF_INET</name></expr>)</condition><then> <block>{
<return>return <expr><call><name>PyString_FromStringAndSize</name><argument_list>(<argument><expr><name>packed</name></expr></argument>,
<argument><expr><sizeof>sizeof<argument_list>(<argument>struct <expr><name>in_addr</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</return>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>ENABLE_IPV6</name></expr></argument>)</argument_list></call></expr></cpp:if>
}</block></then> <else>else <if>if <condition>(<expr><name>af</name> == <name>AF_INET6</name></expr>)</condition><then> <block>{
<return>return <expr><call><name>PyString_FromStringAndSize</name><argument_list>(<argument><expr><name>packed</name></expr></argument>,
<argument><expr><sizeof>sizeof<argument_list>(<argument>struct <expr><name>in6_addr</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></then> <else>else <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>socket_error</name></expr></argument>, <argument><expr>"unknown address family"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></else></if></else></if></else></if></else></if>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>inet_ntop_doc</name></expr></argument>,
<argument><expr>"inet_ntop(af, packed_ip) -&gt; string formatted IP address\n\
\n\
Convert a packed IP address of the given family to string format."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>socket_inet_ntop</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>af</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name>*</type> <name>packed</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>len</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name>*</type> <name>retval</name></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>ENABLE_IPV6</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>char</name></type> <name><name>ip</name><index>[<expr><call><name>MAX</name><argument_list>(<argument><expr><name>INET_ADDRSTRLEN</name></expr></argument>, <argument><expr><name>INET6_ADDRSTRLEN</name></expr></argument>)</argument_list></call> + 1</expr>]</index></name></decl>;</decl_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<decl_stmt><decl><type><name>char</name></type> <name><name>ip</name><index>[<expr><name>INET_ADDRSTRLEN</name> + 1</expr>]</index></name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr>(<name>void</name> *) &amp;<name><name>ip</name><index>[<expr>0</expr>]</index></name></expr></argument>, <argument><expr>'\0'</expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ip</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"is#:inet_ntop"</expr></argument>, <argument><expr>&amp;<name>af</name></expr></argument>, <argument><expr>&amp;<name>packed</name></expr></argument>, <argument><expr>&amp;<name>len</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<if>if <condition>(<expr><name>af</name> == <name>AF_INET</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr><name>len</name> != <sizeof>sizeof<argument_list>(<argument>struct <expr><name>in_addr</name></expr></argument>)</argument_list></sizeof></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>,
<argument><expr>"invalid length of packed IP address string"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>ENABLE_IPV6</name></expr></argument>)</argument_list></call></expr></cpp:if>
}</block></then> <else>else <if>if <condition>(<expr><name>af</name> == <name>AF_INET6</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr><name>len</name> != <sizeof>sizeof<argument_list>(<argument>struct <expr><name>in6_addr</name></expr></argument>)</argument_list></sizeof></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>,
<argument><expr>"invalid length of packed IP address string"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></then> <else>else <block>{
<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>,
<argument><expr>"unknown address family %d"</expr></argument>, <argument><expr><name>af</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></else></if></else></if>
<expr_stmt><expr><name>retval</name> = <call><name>inet_ntop</name><argument_list>(<argument><expr><name>af</name></expr></argument>, <argument><expr><name>packed</name></expr></argument>, <argument><expr><name>ip</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ip</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>retval</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetFromErrno</name><argument_list>(<argument><expr><name>socket_error</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then> <else>else <block>{
<return>return <expr><call><name>PyString_FromString</name><argument_list>(<argument><expr><name>retval</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></else></if>
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_RuntimeError</name></expr></argument>, <argument><expr>"invalid handling of inet_ntop"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>socket_getaddrinfo</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type>struct <name>addrinfo</name></type> <name>hints</name></decl>, *<decl><type ref="prev"/><name>res</name></decl>;</decl_stmt>
<decl_stmt><decl><type>struct <name>addrinfo</name> *</type><name>res0</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>hobj</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>pobj</name> <init>= <expr>(<name>PyObject</name> *)<name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name><name>pbuf</name><index>[<expr>30</expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>hptr</name></decl>, *<decl><type ref="prev"/><name>pptr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>family</name></decl>, <decl><type ref="prev"/><name>socktype</name></decl>, <decl><type ref="prev"/><name>protocol</name></decl>, <decl><type ref="prev"/><name>flags</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>error</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>all</name> <init>= <expr>(<name>PyObject</name> *)<name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>single</name> <init>= <expr>(<name>PyObject</name> *)<name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>idna</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>family</name> = <name>socktype</name> = <name>protocol</name> = <name>flags</name> = 0</expr>;</expr_stmt>
<expr_stmt><expr><name>family</name> = <name>AF_UNSPEC</name></expr>;</expr_stmt>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"OO|iiii:getaddrinfo"</expr></argument>,
<argument><expr>&amp;<name>hobj</name></expr></argument>, <argument><expr>&amp;<name>pobj</name></expr></argument>, <argument><expr>&amp;<name>family</name></expr></argument>, <argument><expr>&amp;<name>socktype</name></expr></argument>,
<argument><expr>&amp;<name>protocol</name></expr></argument>, <argument><expr>&amp;<name>flags</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<if>if <condition>(<expr><name>hobj</name> == <name>Py_None</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>hptr</name> = <name>NULL</name></expr>;</expr_stmt>
}</block></then> <else>else <if>if <condition>(<expr><call><name>PyUnicode_Check</name><argument_list>(<argument><expr><name>hobj</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><name>idna</name> = <call><name>PyObject_CallMethod</name><argument_list>(<argument><expr><name>hobj</name></expr></argument>, <argument><expr>"encode"</expr></argument>, <argument><expr>"s"</expr></argument>, <argument><expr>"idna"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>idna</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>hptr</name> = <call><name>PyString_AsString</name><argument_list>(<argument><expr><name>idna</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else <if>if <condition>(<expr><call><name>PyString_Check</name><argument_list>(<argument><expr><name>hobj</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><name>hptr</name> = <call><name>PyString_AsString</name><argument_list>(<argument><expr><name>hobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
<argument><expr>"getaddrinfo() argument 1 must be string or None"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></else></if></else></if></else></if>
<if>if <condition>(<expr><call><name>PyInt_Check</name><argument_list>(<argument><expr><name>pobj</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyOS_snprintf</name><argument_list>(<argument><expr><name>pbuf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>pbuf</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr>"%ld"</expr></argument>, <argument><expr><call><name>PyInt_AsLong</name><argument_list>(<argument><expr><name>pobj</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>pptr</name> = <name>pbuf</name></expr>;</expr_stmt>
}</block></then> <else>else <if>if <condition>(<expr><call><name>PyString_Check</name><argument_list>(<argument><expr><name>pobj</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><name>pptr</name> = <call><name>PyString_AsString</name><argument_list>(<argument><expr><name>pobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else <if>if <condition>(<expr><name>pobj</name> == <name>Py_None</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>pptr</name> = (<name>char</name> *)<name>NULL</name></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>socket_error</name></expr></argument>, <argument><expr>"Int or String expected"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>err</name>;</goto>
}</block></else></if></else></if></else></if>
<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr>&amp;<name>hints</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>hints</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>hints</name>.<name>ai_family</name></name> = <name>family</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>hints</name>.<name>ai_socktype</name></name> = <name>socktype</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>hints</name>.<name>ai_protocol</name></name> = <name>protocol</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>hints</name>.<name>ai_flags</name></name> = <name>flags</name></expr>;</expr_stmt>
<decl_stmt><decl><type><name>Py_BEGIN_ALLOW_THREADS</name>
<name>ACQUIRE_GETADDRINFO_LOCK</name></type>
<name>error</name> <init>= <expr><call><name>getaddrinfo</name><argument_list>(<argument><expr><name>hptr</name></expr></argument>, <argument><expr><name>pptr</name></expr></argument>, <argument><expr>&amp;<name>hints</name></expr></argument>, <argument><expr>&amp;<name>res0</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>Py_END_ALLOW_THREADS</name>
<name>RELEASE_GETADDRINFO_LOCK</name></expr></expr_stmt>
<if>if <condition>(<expr><name>error</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>set_gaierror</name><argument_list>(<argument><expr><name>error</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>err</name>;</goto>
}</block></then></if>
<if>if <condition>(<expr>(<name>all</name> = <call><name>PyList_New</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call>) == <name>NULL</name></expr>)</condition><then>
<goto>goto <name>err</name>;</goto></then></if>
<for>for (<init><expr><name>res</name> = <name>res0</name></expr>;</init> <condition><expr><name>res</name></expr>;</condition> <incr><expr><name>res</name> = <name><name>res</name>-&gt;<name>ai_next</name></name></expr></incr>) <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>addr</name> <init>=
<expr><call><name>makesockaddr</name><argument_list>(<argument><expr>-1</expr></argument>, <argument><expr><name><name>res</name>-&gt;<name>ai_addr</name></name></expr></argument>, <argument><expr><name><name>res</name>-&gt;<name>ai_addrlen</name></name></expr></argument>, <argument><expr><name>protocol</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>addr</name> == <name>NULL</name></expr>)</condition><then>
<goto>goto <name>err</name>;</goto></then></if>
<expr_stmt><expr><name>single</name> = <call><name>Py_BuildValue</name><argument_list>(<argument><expr>"iiisO"</expr></argument>, <argument><expr><name><name>res</name>-&gt;<name>ai_family</name></name></expr></argument>,
<argument><expr><name><name>res</name>-&gt;<name>ai_socktype</name></name></expr></argument>, <argument><expr><name><name>res</name>-&gt;<name>ai_protocol</name></name></expr></argument>,
<argument><expr><name><name>res</name>-&gt;<name>ai_canonname</name></name> ? <name><name>res</name>-&gt;<name>ai_canonname</name></name> : ""</expr></argument>,
<argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>single</name> == <name>NULL</name></expr>)</condition><then>
<goto>goto <name>err</name>;</goto></then></if>
<if>if <condition>(<expr><call><name>PyList_Append</name><argument_list>(<argument><expr><name>all</name></expr></argument>, <argument><expr><name>single</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<goto>goto <name>err</name>;</goto></then></if>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>single</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></for>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>idna</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>res0</name></expr>)</condition><then>
<expr_stmt><expr><call><name>freeaddrinfo</name><argument_list>(<argument><expr><name>res0</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<return>return <expr><name>all</name></expr>;</return>
<label><name>err</name>:</label>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>single</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>all</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>idna</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>res0</name></expr>)</condition><then>
<expr_stmt><expr><call><name>freeaddrinfo</name><argument_list>(<argument><expr><name>res0</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<return>return <expr>(<name>PyObject</name> *)<name>NULL</name></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>getaddrinfo_doc</name></expr></argument>,
<argument><expr>"getaddrinfo(host, port [, family, socktype, proto, flags])\n\
-&gt; list of (family, socktype, proto, canonname, sockaddr)\n\
\n\
Resolve host and port into addrinfo struct."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>socket_getnameinfo</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>sa</name> <init>= <expr>(<name>PyObject</name> *)<name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>flags</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>hostp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>port</name></decl>, <decl><type ref="prev"/><name>flowinfo</name></decl>, <decl><type ref="prev"/><name>scope_id</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name><name>hbuf</name><index>[<expr><name>NI_MAXHOST</name></expr>]</index></name></decl>, <decl><type ref="prev"/><name><name>pbuf</name><index>[<expr><name>NI_MAXSERV</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type>struct <name>addrinfo</name></type> <name>hints</name></decl>, *<decl><type ref="prev"/><name>res</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>error</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>ret</name> <init>= <expr>(<name>PyObject</name> *)<name>NULL</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>flags</name> = <name>flowinfo</name> = <name>scope_id</name> = 0</expr>;</expr_stmt>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"Oi:getnameinfo"</expr></argument>, <argument><expr>&amp;<name>sa</name></expr></argument>, <argument><expr>&amp;<name>flags</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>sa</name></expr></argument>, <argument><expr>"si|ii"</expr></argument>,
<argument><expr>&amp;<name>hostp</name></expr></argument>, <argument><expr>&amp;<name>port</name></expr></argument>, <argument><expr>&amp;<name>flowinfo</name></expr></argument>, <argument><expr>&amp;<name>scope_id</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><call><name>PyOS_snprintf</name><argument_list>(<argument><expr><name>pbuf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>pbuf</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr>"%d"</expr></argument>, <argument><expr><name>port</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr>&amp;<name>hints</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>hints</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>hints</name>.<name>ai_family</name></name> = <name>AF_UNSPEC</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>hints</name>.<name>ai_socktype</name></name> = <name>SOCK_DGRAM</name></expr>;</expr_stmt>
<decl_stmt><decl><type><name>Py_BEGIN_ALLOW_THREADS</name>
<name>ACQUIRE_GETADDRINFO_LOCK</name></type>
<name>error</name> <init>= <expr><call><name>getaddrinfo</name><argument_list>(<argument><expr><name>hostp</name></expr></argument>, <argument><expr><name>pbuf</name></expr></argument>, <argument><expr>&amp;<name>hints</name></expr></argument>, <argument><expr>&amp;<name>res</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>Py_END_ALLOW_THREADS</name>
<name>RELEASE_GETADDRINFO_LOCK</name></expr></expr_stmt>
<if>if <condition>(<expr><name>error</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>set_gaierror</name><argument_list>(<argument><expr><name>error</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>fail</name>;</goto>
}</block></then></if>
<if>if <condition>(<expr><name><name>res</name>-&gt;<name>ai_next</name></name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>socket_error</name></expr></argument>,
<argument><expr>"sockaddr resolved to multiple addresses"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>fail</name>;</goto>
}</block></then></if>
<switch>switch <condition>(<expr><name><name>res</name>-&gt;<name>ai_family</name></name></expr>)</condition> <block>{
<case>case <expr><name>AF_INET</name></expr>: <block>{
<decl_stmt><decl><type><name>char</name> *</type><name>t1</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>t2</name></decl>;</decl_stmt>
<if>if <condition>(<expr><call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>sa</name></expr></argument>, <argument><expr>"si"</expr></argument>, <argument><expr>&amp;<name>t1</name></expr></argument>, <argument><expr>&amp;<name>t2</name></expr></argument>)</argument_list></call> == 0</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>socket_error</name></expr></argument>,
<argument><expr>"IPv4 sockaddr must be 2 tuple"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>fail</name>;</goto>
}</block></then></if>
<break>break;</break>
}</block>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>ENABLE_IPV6</name></expr></argument>)</argument_list></call></expr></cpp:if>
</case><case>case <expr><name>AF_INET6</name></expr>: <block>{
<decl_stmt><decl><type>struct <name>sockaddr_in6</name> *</type><name>sin6</name></decl>;</decl_stmt>
<expr_stmt><expr><name>sin6</name> = (struct <name>sockaddr_in6</name> *)<name><name>res</name>-&gt;<name>ai_addr</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>sin6</name>-&gt;<name>sin6_flowinfo</name></name> = <name>flowinfo</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>sin6</name>-&gt;<name>sin6_scope_id</name></name> = <name>scope_id</name></expr>;</expr_stmt>
<break>break;</break>
}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</case>}</block></switch>
<expr_stmt><expr><name>error</name> = <call><name>getnameinfo</name><argument_list>(<argument><expr><name><name>res</name>-&gt;<name>ai_addr</name></name></expr></argument>, <argument><expr><name><name>res</name>-&gt;<name>ai_addrlen</name></name></expr></argument>,
<argument><expr><name>hbuf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>hbuf</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>pbuf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>pbuf</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>error</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>set_gaierror</name><argument_list>(<argument><expr><name>error</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>fail</name>;</goto>
}</block></then></if>
<expr_stmt><expr><name>ret</name> = <call><name>Py_BuildValue</name><argument_list>(<argument><expr>"ss"</expr></argument>, <argument><expr><name>hbuf</name></expr></argument>, <argument><expr><name>pbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<label><name>fail</name>:</label>
<if>if <condition>(<expr><name>res</name></expr>)</condition><then>
<expr_stmt><expr><call><name>freeaddrinfo</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<return>return <expr><name>ret</name></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>getnameinfo_doc</name></expr></argument>,
<argument><expr>"getnameinfo(sockaddr, flags) --&gt; (host, port)\n\
\n\
Get host and port for a sockaddr."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>socket_getdefaulttimeout</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>)</parameter_list> <block>{
<if>if <condition>(<expr><name>defaulttimeout</name> &lt; 0.0</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>Py_None</name></expr>;</return>
}</block></then> <else>else
<return>return <expr><call><name>PyFloat_FromDouble</name><argument_list>(<argument><expr><name>defaulttimeout</name></expr></argument>)</argument_list></call></expr>;</return></else></if>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>getdefaulttimeout_doc</name></expr></argument>,
<argument><expr>"getdefaulttimeout() -&gt; timeout\n\
\n\
Returns the default timeout in floating seconds for new socket objects.\n\
A value of None indicates that new socket objects have no timeout.\n\
When the socket module is first imported, the default is None."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>socket_setdefaulttimeout</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>arg</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>double</name></type> <name>timeout</name></decl>;</decl_stmt>
<if>if <condition>(<expr><name>arg</name> == <name>Py_None</name></expr>)</condition><then>
<expr_stmt><expr><name>timeout</name> = -1.0</expr>;</expr_stmt></then>
<else>else <block>{
<expr_stmt><expr><name>timeout</name> = <call><name>PyFloat_AsDouble</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>timeout</name> &lt; 0.0</expr>)</condition><then> <block>{
<if>if <condition>(<expr>!<call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then>
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>,
<argument><expr>"Timeout value out of range"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
}</block></else></if>
<expr_stmt><expr><name>defaulttimeout</name> = <name>timeout</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>Py_None</name></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>setdefaulttimeout_doc</name></expr></argument>,
<argument><expr>"setdefaulttimeout(timeout)\n\
\n\
Set the default timeout in floating seconds for new socket objects.\n\
A value of None indicates that new socket objects have no timeout.\n\
When the socket module is first imported, the default is None."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>PyMethodDef</name></type> <name><name>socket_methods</name><index>[]</index></name> <init>= <expr><block>{
<expr><block>{
<expr>"gethostbyname"</expr>, <expr><name>socket_gethostbyname</name></expr>,
<expr><name>METH_VARARGS</name></expr>, <expr><name>gethostbyname_doc</name></expr>
}</block></expr>,
<expr><block>{
<expr>"gethostbyname_ex"</expr>, <expr><name>socket_gethostbyname_ex</name></expr>,
<expr><name>METH_VARARGS</name></expr>, <expr><name>ghbn_ex_doc</name></expr>
}</block></expr>,
<expr><block>{
<expr>"gethostbyaddr"</expr>, <expr><name>socket_gethostbyaddr</name></expr>,
<expr><name>METH_VARARGS</name></expr>, <expr><name>gethostbyaddr_doc</name></expr>
}</block></expr>,
<expr><block>{
<expr>"gethostname"</expr>, <expr><name>socket_gethostname</name></expr>,
<expr><name>METH_NOARGS</name></expr>, <expr><name>gethostname_doc</name></expr>
}</block></expr>,
<expr><block>{
<expr>"getservbyname"</expr>, <expr><name>socket_getservbyname</name></expr>,
<expr><name>METH_VARARGS</name></expr>, <expr><name>getservbyname_doc</name></expr>
}</block></expr>,
<expr><block>{
<expr>"getservbyport"</expr>, <expr><name>socket_getservbyport</name></expr>,
<expr><name>METH_VARARGS</name></expr>, <expr><name>getservbyport_doc</name></expr>
}</block></expr>,
<expr><block>{
<expr>"getprotobyname"</expr>, <expr><name>socket_getprotobyname</name></expr>,
<expr><name>METH_VARARGS</name></expr>, <expr><name>getprotobyname_doc</name></expr>
}</block></expr>,
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>NO_DUP</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{
<expr>"fromfd"</expr>, <expr><name>socket_fromfd</name></expr>,
<expr><name>METH_VARARGS</name></expr>, <expr><name>fromfd_doc</name></expr>
}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_SOCKETPAIR</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{
<expr>"socketpair"</expr>, <expr><name>socket_socketpair</name></expr>,
<expr><name>METH_VARARGS</name></expr>, <expr><name>socketpair_doc</name></expr>
}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr><block>{
<expr>"ntohs"</expr>, <expr><name>socket_ntohs</name></expr>,
<expr><name>METH_VARARGS</name></expr>, <expr><name>ntohs_doc</name></expr>
}</block></expr>,
<expr><block>{
<expr>"ntohl"</expr>, <expr><name>socket_ntohl</name></expr>,
<expr><name>METH_O</name></expr>, <expr><name>ntohl_doc</name></expr>
}</block></expr>,
<expr><block>{
<expr>"htons"</expr>, <expr><name>socket_htons</name></expr>,
<expr><name>METH_VARARGS</name></expr>, <expr><name>htons_doc</name></expr>
}</block></expr>,
<expr><block>{
<expr>"htonl"</expr>, <expr><name>socket_htonl</name></expr>,
<expr><name>METH_O</name></expr>, <expr><name>htonl_doc</name></expr>
}</block></expr>,
<expr><block>{
<expr>"inet_aton"</expr>, <expr><name>socket_inet_aton</name></expr>,
<expr><name>METH_VARARGS</name></expr>, <expr><name>inet_aton_doc</name></expr>
}</block></expr>,
<expr><block>{
<expr>"inet_ntoa"</expr>, <expr><name>socket_inet_ntoa</name></expr>,
<expr><name>METH_VARARGS</name></expr>, <expr><name>inet_ntoa_doc</name></expr>
}</block></expr>,
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_INET_PTON</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{
<expr>"inet_pton"</expr>, <expr><name>socket_inet_pton</name></expr>,
<expr><name>METH_VARARGS</name></expr>, <expr><name>inet_pton_doc</name></expr>
}</block></expr>,
<expr><block>{
<expr>"inet_ntop"</expr>, <expr><name>socket_inet_ntop</name></expr>,
<expr><name>METH_VARARGS</name></expr>, <expr><name>inet_ntop_doc</name></expr>
}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr><block>{
<expr>"getaddrinfo"</expr>, <expr><name>socket_getaddrinfo</name></expr>,
<expr><name>METH_VARARGS</name></expr>, <expr><name>getaddrinfo_doc</name></expr>
}</block></expr>,
<expr><block>{
<expr>"getnameinfo"</expr>, <expr><name>socket_getnameinfo</name></expr>,
<expr><name>METH_VARARGS</name></expr>, <expr><name>getnameinfo_doc</name></expr>
}</block></expr>,
<expr><block>{
<expr>"getdefaulttimeout"</expr>, <expr>(<name>PyCFunction</name>)<name>socket_getdefaulttimeout</name></expr>,
<expr><name>METH_NOARGS</name></expr>, <expr><name>getdefaulttimeout_doc</name></expr>
}</block></expr>,
<expr><block>{
<expr>"setdefaulttimeout"</expr>, <expr><name>socket_setdefaulttimeout</name></expr>,
<expr><name>METH_O</name></expr>, <expr><name>setdefaulttimeout_doc</name></expr>
}</block></expr>,
<expr><block>{<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>}</block></expr>
}</block></expr></init></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>RISCOS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>OS_INIT_DEFINED</name></cpp:macro></cpp:define>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>os_init</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>_kernel_swi_regs</name></type> <name>r</name></decl>;</decl_stmt>
<expr_stmt><expr><name><name>r</name>.<name>r</name><index>[<expr>0</expr>]</index></name> = 0</expr>;</expr_stmt>
<expr_stmt><expr><call><name>_kernel_swi</name><argument_list>(<argument><expr>0x43380</expr></argument>, <argument><expr>&amp;<name>r</name></expr></argument>, <argument><expr>&amp;<name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>taskwindow</name> = <name><name>r</name>.<name>r</name><index>[<expr>0</expr>]</index></name></expr>;</expr_stmt>
<return>return <expr>1</expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MS_WINDOWS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>OS_INIT_DEFINED</name></cpp:macro></cpp:define>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>os_cleanup</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list> <block>{
<expr_stmt><expr><call><name>WSACleanup</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>os_init</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>WSADATA</name></type> <name>WSAData</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name><name>buf</name><index>[<expr>100</expr>]</index></name></decl>;</decl_stmt>
<expr_stmt><expr><name>ret</name> = <call><name>WSAStartup</name><argument_list>(<argument><expr>0x0101</expr></argument>, <argument><expr>&amp;<name>WSAData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<switch>switch <condition>(<expr><name>ret</name></expr>)</condition> <block>{
<case>case <expr>0</expr>:
<expr_stmt><expr><call><name>Py_AtExit</name><argument_list>(<argument><expr><name>os_cleanup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>1</expr>;</return>
</case><case>case <expr><name>WSASYSNOTREADY</name></expr>:
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ImportError</name></expr></argument>,
<argument><expr>"WSAStartup failed: network not ready"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr><name>WSAVERNOTSUPPORTED</name></expr>:
</case><case>case <expr><name>WSAEINVAL</name></expr>:
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(
<argument><expr><name>PyExc_ImportError</name></expr></argument>,
<argument><expr>"WSAStartup failed: requested version not supported"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</case><default>default:
<expr_stmt><expr><call><name>PyOS_snprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>,
<argument><expr>"WSAStartup failed: error code %d"</expr></argument>, <argument><expr><name>ret</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ImportError</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</default>}</block></switch>
<return>return <expr>0</expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>PYOS_OS2</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>OS_INIT_DEFINED</name></cpp:macro></cpp:define>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>os_init</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list> <block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>PYCC_GCC</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>char</name></type> <name><name>reason</name><index>[<expr>64</expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><call><name>sock_init</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>rc</name> == 0</expr>)</condition><then> <block>{
<return>return <expr>1</expr>;</return>
}</block></then></if>
<expr_stmt><expr><call><name>PyOS_snprintf</name><argument_list>(<argument><expr><name>reason</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>reason</name></expr></argument>)</argument_list></sizeof></expr></argument>,
<argument><expr>"OS/2 TCP/IP Error#%d"</expr></argument>, <argument><expr><call><name>sock_errno</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ImportError</name></expr></argument>, <argument><expr><name>reason</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>0</expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<return>return <expr>1</expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>OS_INIT_DEFINED</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>os_init</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list> <block>{
<return>return <expr>1</expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<decl_stmt><decl><type><specifier>static</specifier>
<name>PySocketModule_APIObject</name></type> <name>PySocketModuleAPI</name> <init>= <expr><block>{
<expr>&amp;<name>sock_type</name></expr>,
<expr><name>NULL</name></expr>
}</block></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>socket_doc</name></expr></argument>,
<argument><expr>"Implementation module for socket operations.\n\
\n\
See the socket module for documentation."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><name>PyMODINIT_FUNC</name></type>
<name>init_socket</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>m</name></decl>, *<decl><type ref="prev"/><name>has_ipv6</name></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>os_init</name><argument_list>()</argument_list></call></expr>)</condition><then>
<return>return;</return></then></if>
<expr_stmt><expr><call><name>Py_TYPE</name><argument_list>(<argument><expr>&amp;<name>sock_type</name></expr></argument>)</argument_list></call> = &amp;<name>PyType_Type</name></expr>;</expr_stmt>
<expr_stmt><expr><name>m</name> = <call><name>Py_InitModule3</name><argument_list>(<argument><expr><name>PySocket_MODULE_NAME</name></expr></argument>,
<argument><expr><name>socket_methods</name></expr></argument>,
<argument><expr><name>socket_doc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>m</name> == <name>NULL</name></expr>)</condition><then>
<return>return;</return></then></if>
<expr_stmt><expr><name>socket_error</name> = <call><name>PyErr_NewException</name><argument_list>(<argument><expr>"socket.error"</expr></argument>,
<argument><expr><name>PyExc_IOError</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>socket_error</name> == <name>NULL</name></expr>)</condition><then>
<return>return;</return></then></if>
<expr_stmt><expr><name><name>PySocketModuleAPI</name>.<name>error</name></name> = <name>socket_error</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>socket_error</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyModule_AddObject</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"error"</expr></argument>, <argument><expr><name>socket_error</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>socket_herror</name> = <call><name>PyErr_NewException</name><argument_list>(<argument><expr>"socket.herror"</expr></argument>,
<argument><expr><name>socket_error</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>socket_herror</name> == <name>NULL</name></expr>)</condition><then>
<return>return;</return></then></if>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>socket_herror</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyModule_AddObject</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"herror"</expr></argument>, <argument><expr><name>socket_herror</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>socket_gaierror</name> = <call><name>PyErr_NewException</name><argument_list>(<argument><expr>"socket.gaierror"</expr></argument>, <argument><expr><name>socket_error</name></expr></argument>,
<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>socket_gaierror</name> == <name>NULL</name></expr>)</condition><then>
<return>return;</return></then></if>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>socket_gaierror</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyModule_AddObject</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"gaierror"</expr></argument>, <argument><expr><name>socket_gaierror</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>socket_timeout</name> = <call><name>PyErr_NewException</name><argument_list>(<argument><expr>"socket.timeout"</expr></argument>,
<argument><expr><name>socket_error</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>socket_timeout</name> == <name>NULL</name></expr>)</condition><then>
<return>return;</return></then></if>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>socket_timeout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyModule_AddObject</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"timeout"</expr></argument>, <argument><expr><name>socket_timeout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr>(<name>PyObject</name> *)&amp;<name>sock_type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>PyModule_AddObject</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"SocketType"</expr></argument>,
<argument><expr>(<name>PyObject</name> *)&amp;<name>sock_type</name></expr></argument>)</argument_list></call> != 0</expr>)</condition><then>
<return>return;</return></then></if>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr>(<name>PyObject</name> *)&amp;<name>sock_type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>PyModule_AddObject</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"socket"</expr></argument>,
<argument><expr>(<name>PyObject</name> *)&amp;<name>sock_type</name></expr></argument>)</argument_list></call> != 0</expr>)</condition><then>
<return>return;</return></then></if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>ENABLE_IPV6</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><name>has_ipv6</name> = <name>Py_True</name></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<expr_stmt><expr><name>has_ipv6</name> = <name>Py_False</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>has_ipv6</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyModule_AddObject</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"has_ipv6"</expr></argument>, <argument><expr><name>has_ipv6</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>PyModule_AddObject</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr><name>PySocket_CAPI_NAME</name></expr></argument>,
<argument><expr><call><name>PyCObject_FromVoidPtr</name><argument_list>(<argument><expr>(<name>void</name> *)&amp;<name>PySocketModuleAPI</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></argument>
)</argument_list></call> != 0</expr>)</condition><then>
<return>return;</return></then></if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>AF_UNSPEC</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"AF_UNSPEC"</expr></argument>, <argument><expr><name>AF_UNSPEC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"AF_INET"</expr></argument>, <argument><expr><name>AF_INET</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>AF_INET6</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"AF_INET6"</expr></argument>, <argument><expr><name>AF_INET6</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>AF_UNIX</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"AF_UNIX"</expr></argument>, <argument><expr><name>AF_UNIX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>AF_AX25</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"AF_AX25"</expr></argument>, <argument><expr><name>AF_AX25</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>AF_IPX</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"AF_IPX"</expr></argument>, <argument><expr><name>AF_IPX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>AF_APPLETALK</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"AF_APPLETALK"</expr></argument>, <argument><expr><name>AF_APPLETALK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>AF_NETROM</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"AF_NETROM"</expr></argument>, <argument><expr><name>AF_NETROM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>AF_BRIDGE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"AF_BRIDGE"</expr></argument>, <argument><expr><name>AF_BRIDGE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>AF_ATMPVC</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"AF_ATMPVC"</expr></argument>, <argument><expr><name>AF_ATMPVC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>AF_AAL5</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"AF_AAL5"</expr></argument>, <argument><expr><name>AF_AAL5</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>AF_X25</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"AF_X25"</expr></argument>, <argument><expr><name>AF_X25</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>AF_INET6</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"AF_INET6"</expr></argument>, <argument><expr><name>AF_INET6</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>AF_ROSE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"AF_ROSE"</expr></argument>, <argument><expr><name>AF_ROSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>AF_DECnet</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"AF_DECnet"</expr></argument>, <argument><expr><name>AF_DECnet</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>AF_NETBEUI</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"AF_NETBEUI"</expr></argument>, <argument><expr><name>AF_NETBEUI</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>AF_SECURITY</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"AF_SECURITY"</expr></argument>, <argument><expr><name>AF_SECURITY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>AF_KEY</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"AF_KEY"</expr></argument>, <argument><expr><name>AF_KEY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>AF_NETLINK</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"AF_NETLINK"</expr></argument>, <argument><expr><name>AF_NETLINK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"NETLINK_ROUTE"</expr></argument>, <argument><expr><name>NETLINK_ROUTE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>NETLINK_SKIP</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"NETLINK_SKIP"</expr></argument>, <argument><expr><name>NETLINK_SKIP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>NETLINK_W1</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"NETLINK_W1"</expr></argument>, <argument><expr><name>NETLINK_W1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"NETLINK_USERSOCK"</expr></argument>, <argument><expr><name>NETLINK_USERSOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"NETLINK_FIREWALL"</expr></argument>, <argument><expr><name>NETLINK_FIREWALL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>NETLINK_TCPDIAG</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"NETLINK_TCPDIAG"</expr></argument>, <argument><expr><name>NETLINK_TCPDIAG</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>NETLINK_NFLOG</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"NETLINK_NFLOG"</expr></argument>, <argument><expr><name>NETLINK_NFLOG</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>NETLINK_XFRM</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"NETLINK_XFRM"</expr></argument>, <argument><expr><name>NETLINK_XFRM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>NETLINK_ARPD</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"NETLINK_ARPD"</expr></argument>, <argument><expr><name>NETLINK_ARPD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>NETLINK_ROUTE6</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"NETLINK_ROUTE6"</expr></argument>, <argument><expr><name>NETLINK_ROUTE6</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"NETLINK_IP6_FW"</expr></argument>, <argument><expr><name>NETLINK_IP6_FW</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>NETLINK_DNRTMSG</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"NETLINK_DNRTMSG"</expr></argument>, <argument><expr><name>NETLINK_DNRTMSG</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>NETLINK_TAPBASE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"NETLINK_TAPBASE"</expr></argument>, <argument><expr><name>NETLINK_TAPBASE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>AF_ROUTE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"AF_ROUTE"</expr></argument>, <argument><expr><name>AF_ROUTE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>AF_ASH</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"AF_ASH"</expr></argument>, <argument><expr><name>AF_ASH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>AF_ECONET</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"AF_ECONET"</expr></argument>, <argument><expr><name>AF_ECONET</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>AF_ATMSVC</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"AF_ATMSVC"</expr></argument>, <argument><expr><name>AF_ATMSVC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>AF_SNA</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"AF_SNA"</expr></argument>, <argument><expr><name>AF_SNA</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>AF_IRDA</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"AF_IRDA"</expr></argument>, <argument><expr><name>AF_IRDA</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>AF_PPPOX</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"AF_PPPOX"</expr></argument>, <argument><expr><name>AF_PPPOX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>AF_WANPIPE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"AF_WANPIPE"</expr></argument>, <argument><expr><name>AF_WANPIPE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>AF_LLC</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"AF_LLC"</expr></argument>, <argument><expr><name>AF_LLC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>USE_BLUETOOTH</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"AF_BLUETOOTH"</expr></argument>, <argument><expr><name>AF_BLUETOOTH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"BTPROTO_L2CAP"</expr></argument>, <argument><expr><name>BTPROTO_L2CAP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"BTPROTO_HCI"</expr></argument>, <argument><expr><name>BTPROTO_HCI</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"SOL_HCI"</expr></argument>, <argument><expr><name>SOL_HCI</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"HCI_FILTER"</expr></argument>, <argument><expr><name>HCI_FILTER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>__FreeBSD__</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"HCI_TIME_STAMP"</expr></argument>, <argument><expr><name>HCI_TIME_STAMP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"HCI_DATA_DIR"</expr></argument>, <argument><expr><name>HCI_DATA_DIR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"BTPROTO_SCO"</expr></argument>, <argument><expr><name>BTPROTO_SCO</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"BTPROTO_RFCOMM"</expr></argument>, <argument><expr><name>BTPROTO_RFCOMM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyModule_AddStringConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"BDADDR_ANY"</expr></argument>, <argument><expr>"00:00:00:00:00:00"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyModule_AddStringConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"BDADDR_LOCAL"</expr></argument>, <argument><expr>"00:00:00:FF:FF:FF"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_NETPACKET_PACKET_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"AF_PACKET"</expr></argument>, <argument><expr><name>AF_PACKET</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"PF_PACKET"</expr></argument>, <argument><expr><name>PF_PACKET</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"PACKET_HOST"</expr></argument>, <argument><expr><name>PACKET_HOST</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"PACKET_BROADCAST"</expr></argument>, <argument><expr><name>PACKET_BROADCAST</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"PACKET_MULTICAST"</expr></argument>, <argument><expr><name>PACKET_MULTICAST</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"PACKET_OTHERHOST"</expr></argument>, <argument><expr><name>PACKET_OTHERHOST</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"PACKET_OUTGOING"</expr></argument>, <argument><expr><name>PACKET_OUTGOING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"PACKET_LOOPBACK"</expr></argument>, <argument><expr><name>PACKET_LOOPBACK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"PACKET_FASTROUTE"</expr></argument>, <argument><expr><name>PACKET_FASTROUTE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_LINUX_TIPC_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"AF_TIPC"</expr></argument>, <argument><expr><name>AF_TIPC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"TIPC_ADDR_NAMESEQ"</expr></argument>, <argument><expr><name>TIPC_ADDR_NAMESEQ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"TIPC_ADDR_NAME"</expr></argument>, <argument><expr><name>TIPC_ADDR_NAME</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"TIPC_ADDR_ID"</expr></argument>, <argument><expr><name>TIPC_ADDR_ID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"TIPC_ZONE_SCOPE"</expr></argument>, <argument><expr><name>TIPC_ZONE_SCOPE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"TIPC_CLUSTER_SCOPE"</expr></argument>, <argument><expr><name>TIPC_CLUSTER_SCOPE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"TIPC_NODE_SCOPE"</expr></argument>, <argument><expr><name>TIPC_NODE_SCOPE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"SOL_TIPC"</expr></argument>, <argument><expr><name>SOL_TIPC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"TIPC_IMPORTANCE"</expr></argument>, <argument><expr><name>TIPC_IMPORTANCE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"TIPC_SRC_DROPPABLE"</expr></argument>, <argument><expr><name>TIPC_SRC_DROPPABLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"TIPC_DEST_DROPPABLE"</expr></argument>,
<argument><expr><name>TIPC_DEST_DROPPABLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"TIPC_CONN_TIMEOUT"</expr></argument>, <argument><expr><name>TIPC_CONN_TIMEOUT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"TIPC_LOW_IMPORTANCE"</expr></argument>,
<argument><expr><name>TIPC_LOW_IMPORTANCE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"TIPC_MEDIUM_IMPORTANCE"</expr></argument>,
<argument><expr><name>TIPC_MEDIUM_IMPORTANCE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"TIPC_HIGH_IMPORTANCE"</expr></argument>,
<argument><expr><name>TIPC_HIGH_IMPORTANCE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"TIPC_CRITICAL_IMPORTANCE"</expr></argument>,
<argument><expr><name>TIPC_CRITICAL_IMPORTANCE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"TIPC_SUB_PORTS"</expr></argument>, <argument><expr><name>TIPC_SUB_PORTS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"TIPC_SUB_SERVICE"</expr></argument>, <argument><expr><name>TIPC_SUB_SERVICE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>TIPC_SUB_CANCEL</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"TIPC_SUB_CANCEL"</expr></argument>, <argument><expr><name>TIPC_SUB_CANCEL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"TIPC_WAIT_FOREVER"</expr></argument>, <argument><expr><name>TIPC_WAIT_FOREVER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"TIPC_PUBLISHED"</expr></argument>, <argument><expr><name>TIPC_PUBLISHED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"TIPC_WITHDRAWN"</expr></argument>, <argument><expr><name>TIPC_WITHDRAWN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"TIPC_SUBSCR_TIMEOUT"</expr></argument>, <argument><expr><name>TIPC_SUBSCR_TIMEOUT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"TIPC_CFG_SRV"</expr></argument>, <argument><expr><name>TIPC_CFG_SRV</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"TIPC_TOP_SRV"</expr></argument>, <argument><expr><name>TIPC_TOP_SRV</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"SOCK_STREAM"</expr></argument>, <argument><expr><name>SOCK_STREAM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"SOCK_DGRAM"</expr></argument>, <argument><expr><name>SOCK_DGRAM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>__BEOS__</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"SOCK_RAW"</expr></argument>, <argument><expr><name>SOCK_RAW</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"SOCK_SEQPACKET"</expr></argument>, <argument><expr><name>SOCK_SEQPACKET</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SOCK_RDM</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"SOCK_RDM"</expr></argument>, <argument><expr><name>SOCK_RDM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SO_DEBUG</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"SO_DEBUG"</expr></argument>, <argument><expr><name>SO_DEBUG</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SO_ACCEPTCONN</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"SO_ACCEPTCONN"</expr></argument>, <argument><expr><name>SO_ACCEPTCONN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SO_REUSEADDR</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"SO_REUSEADDR"</expr></argument>, <argument><expr><name>SO_REUSEADDR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SO_EXCLUSIVEADDRUSE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"SO_EXCLUSIVEADDRUSE"</expr></argument>, <argument><expr><name>SO_EXCLUSIVEADDRUSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SO_KEEPALIVE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"SO_KEEPALIVE"</expr></argument>, <argument><expr><name>SO_KEEPALIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SO_DONTROUTE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"SO_DONTROUTE"</expr></argument>, <argument><expr><name>SO_DONTROUTE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SO_BROADCAST</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"SO_BROADCAST"</expr></argument>, <argument><expr><name>SO_BROADCAST</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SO_USELOOPBACK</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"SO_USELOOPBACK"</expr></argument>, <argument><expr><name>SO_USELOOPBACK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SO_LINGER</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"SO_LINGER"</expr></argument>, <argument><expr><name>SO_LINGER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SO_OOBINLINE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"SO_OOBINLINE"</expr></argument>, <argument><expr><name>SO_OOBINLINE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SO_REUSEPORT</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"SO_REUSEPORT"</expr></argument>, <argument><expr><name>SO_REUSEPORT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SO_SNDBUF</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"SO_SNDBUF"</expr></argument>, <argument><expr><name>SO_SNDBUF</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SO_RCVBUF</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"SO_RCVBUF"</expr></argument>, <argument><expr><name>SO_RCVBUF</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SO_SNDLOWAT</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"SO_SNDLOWAT"</expr></argument>, <argument><expr><name>SO_SNDLOWAT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SO_RCVLOWAT</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"SO_RCVLOWAT"</expr></argument>, <argument><expr><name>SO_RCVLOWAT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SO_SNDTIMEO</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"SO_SNDTIMEO"</expr></argument>, <argument><expr><name>SO_SNDTIMEO</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SO_RCVTIMEO</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"SO_RCVTIMEO"</expr></argument>, <argument><expr><name>SO_RCVTIMEO</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SO_ERROR</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"SO_ERROR"</expr></argument>, <argument><expr><name>SO_ERROR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SO_TYPE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"SO_TYPE"</expr></argument>, <argument><expr><name>SO_TYPE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SOMAXCONN</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"SOMAXCONN"</expr></argument>, <argument><expr><name>SOMAXCONN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"SOMAXCONN"</expr></argument>, <argument><expr>5</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MSG_OOB</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"MSG_OOB"</expr></argument>, <argument><expr><name>MSG_OOB</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MSG_PEEK</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"MSG_PEEK"</expr></argument>, <argument><expr><name>MSG_PEEK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MSG_DONTROUTE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"MSG_DONTROUTE"</expr></argument>, <argument><expr><name>MSG_DONTROUTE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MSG_DONTWAIT</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"MSG_DONTWAIT"</expr></argument>, <argument><expr><name>MSG_DONTWAIT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MSG_EOR</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"MSG_EOR"</expr></argument>, <argument><expr><name>MSG_EOR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MSG_TRUNC</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"MSG_TRUNC"</expr></argument>, <argument><expr><name>MSG_TRUNC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MSG_CTRUNC</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"MSG_CTRUNC"</expr></argument>, <argument><expr><name>MSG_CTRUNC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MSG_WAITALL</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"MSG_WAITALL"</expr></argument>, <argument><expr><name>MSG_WAITALL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MSG_BTAG</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"MSG_BTAG"</expr></argument>, <argument><expr><name>MSG_BTAG</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MSG_ETAG</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"MSG_ETAG"</expr></argument>, <argument><expr><name>MSG_ETAG</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SOL_SOCKET</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"SOL_SOCKET"</expr></argument>, <argument><expr><name>SOL_SOCKET</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SOL_IP</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"SOL_IP"</expr></argument>, <argument><expr><name>SOL_IP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"SOL_IP"</expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SOL_IPX</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"SOL_IPX"</expr></argument>, <argument><expr><name>SOL_IPX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SOL_AX25</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"SOL_AX25"</expr></argument>, <argument><expr><name>SOL_AX25</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SOL_ATALK</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"SOL_ATALK"</expr></argument>, <argument><expr><name>SOL_ATALK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SOL_NETROM</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"SOL_NETROM"</expr></argument>, <argument><expr><name>SOL_NETROM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SOL_ROSE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"SOL_ROSE"</expr></argument>, <argument><expr><name>SOL_ROSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SOL_TCP</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"SOL_TCP"</expr></argument>, <argument><expr><name>SOL_TCP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"SOL_TCP"</expr></argument>, <argument><expr>6</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SOL_UDP</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"SOL_UDP"</expr></argument>, <argument><expr><name>SOL_UDP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"SOL_UDP"</expr></argument>, <argument><expr>17</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>IPPROTO_IP</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"IPPROTO_IP"</expr></argument>, <argument><expr><name>IPPROTO_IP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"IPPROTO_IP"</expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>IPPROTO_HOPOPTS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"IPPROTO_HOPOPTS"</expr></argument>, <argument><expr><name>IPPROTO_HOPOPTS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>IPPROTO_ICMP</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"IPPROTO_ICMP"</expr></argument>, <argument><expr><name>IPPROTO_ICMP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"IPPROTO_ICMP"</expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>IPPROTO_IGMP</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"IPPROTO_IGMP"</expr></argument>, <argument><expr><name>IPPROTO_IGMP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>IPPROTO_GGP</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"IPPROTO_GGP"</expr></argument>, <argument><expr><name>IPPROTO_GGP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>IPPROTO_IPV4</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"IPPROTO_IPV4"</expr></argument>, <argument><expr><name>IPPROTO_IPV4</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>IPPROTO_IPV6</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"IPPROTO_IPV6"</expr></argument>, <argument><expr><name>IPPROTO_IPV6</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>IPPROTO_IPIP</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"IPPROTO_IPIP"</expr></argument>, <argument><expr><name>IPPROTO_IPIP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>IPPROTO_TCP</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"IPPROTO_TCP"</expr></argument>, <argument><expr><name>IPPROTO_TCP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"IPPROTO_TCP"</expr></argument>, <argument><expr>6</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>IPPROTO_EGP</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"IPPROTO_EGP"</expr></argument>, <argument><expr><name>IPPROTO_EGP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>IPPROTO_PUP</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"IPPROTO_PUP"</expr></argument>, <argument><expr><name>IPPROTO_PUP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>IPPROTO_UDP</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"IPPROTO_UDP"</expr></argument>, <argument><expr><name>IPPROTO_UDP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"IPPROTO_UDP"</expr></argument>, <argument><expr>17</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>IPPROTO_IDP</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"IPPROTO_IDP"</expr></argument>, <argument><expr><name>IPPROTO_IDP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>IPPROTO_HELLO</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"IPPROTO_HELLO"</expr></argument>, <argument><expr><name>IPPROTO_HELLO</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>IPPROTO_ND</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"IPPROTO_ND"</expr></argument>, <argument><expr><name>IPPROTO_ND</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>IPPROTO_TP</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"IPPROTO_TP"</expr></argument>, <argument><expr><name>IPPROTO_TP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>IPPROTO_IPV6</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"IPPROTO_IPV6"</expr></argument>, <argument><expr><name>IPPROTO_IPV6</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>IPPROTO_ROUTING</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"IPPROTO_ROUTING"</expr></argument>, <argument><expr><name>IPPROTO_ROUTING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>IPPROTO_FRAGMENT</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"IPPROTO_FRAGMENT"</expr></argument>, <argument><expr><name>IPPROTO_FRAGMENT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>IPPROTO_RSVP</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"IPPROTO_RSVP"</expr></argument>, <argument><expr><name>IPPROTO_RSVP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>IPPROTO_GRE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"IPPROTO_GRE"</expr></argument>, <argument><expr><name>IPPROTO_GRE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>IPPROTO_ESP</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"IPPROTO_ESP"</expr></argument>, <argument><expr><name>IPPROTO_ESP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>IPPROTO_AH</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"IPPROTO_AH"</expr></argument>, <argument><expr><name>IPPROTO_AH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>IPPROTO_MOBILE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"IPPROTO_MOBILE"</expr></argument>, <argument><expr><name>IPPROTO_MOBILE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>IPPROTO_ICMPV6</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"IPPROTO_ICMPV6"</expr></argument>, <argument><expr><name>IPPROTO_ICMPV6</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>IPPROTO_NONE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"IPPROTO_NONE"</expr></argument>, <argument><expr><name>IPPROTO_NONE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>IPPROTO_DSTOPTS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"IPPROTO_DSTOPTS"</expr></argument>, <argument><expr><name>IPPROTO_DSTOPTS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>IPPROTO_XTP</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"IPPROTO_XTP"</expr></argument>, <argument><expr><name>IPPROTO_XTP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>IPPROTO_EON</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"IPPROTO_EON"</expr></argument>, <argument><expr><name>IPPROTO_EON</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>IPPROTO_PIM</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"IPPROTO_PIM"</expr></argument>, <argument><expr><name>IPPROTO_PIM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>IPPROTO_IPCOMP</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"IPPROTO_IPCOMP"</expr></argument>, <argument><expr><name>IPPROTO_IPCOMP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>IPPROTO_VRRP</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"IPPROTO_VRRP"</expr></argument>, <argument><expr><name>IPPROTO_VRRP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>IPPROTO_BIP</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"IPPROTO_BIP"</expr></argument>, <argument><expr><name>IPPROTO_BIP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>IPPROTO_RAW</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"IPPROTO_RAW"</expr></argument>, <argument><expr><name>IPPROTO_RAW</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"IPPROTO_RAW"</expr></argument>, <argument><expr>255</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>IPPROTO_MAX</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"IPPROTO_MAX"</expr></argument>, <argument><expr><name>IPPROTO_MAX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>IPPORT_RESERVED</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"IPPORT_RESERVED"</expr></argument>, <argument><expr><name>IPPORT_RESERVED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"IPPORT_RESERVED"</expr></argument>, <argument><expr>1024</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>IPPORT_USERRESERVED</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"IPPORT_USERRESERVED"</expr></argument>, <argument><expr><name>IPPORT_USERRESERVED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"IPPORT_USERRESERVED"</expr></argument>, <argument><expr>5000</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>INADDR_ANY</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"INADDR_ANY"</expr></argument>, <argument><expr><name>INADDR_ANY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"INADDR_ANY"</expr></argument>, <argument><expr>0x00000000</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>INADDR_BROADCAST</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"INADDR_BROADCAST"</expr></argument>, <argument><expr><name>INADDR_BROADCAST</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"INADDR_BROADCAST"</expr></argument>, <argument><expr>0xffffffff</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>INADDR_LOOPBACK</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"INADDR_LOOPBACK"</expr></argument>, <argument><expr><name>INADDR_LOOPBACK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"INADDR_LOOPBACK"</expr></argument>, <argument><expr>0x7F000001</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>INADDR_UNSPEC_GROUP</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"INADDR_UNSPEC_GROUP"</expr></argument>, <argument><expr><name>INADDR_UNSPEC_GROUP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"INADDR_UNSPEC_GROUP"</expr></argument>, <argument><expr>0xe0000000</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>INADDR_ALLHOSTS_GROUP</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"INADDR_ALLHOSTS_GROUP"</expr></argument>,
<argument><expr><name>INADDR_ALLHOSTS_GROUP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"INADDR_ALLHOSTS_GROUP"</expr></argument>, <argument><expr>0xe0000001</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>INADDR_MAX_LOCAL_GROUP</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"INADDR_MAX_LOCAL_GROUP"</expr></argument>,
<argument><expr><name>INADDR_MAX_LOCAL_GROUP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"INADDR_MAX_LOCAL_GROUP"</expr></argument>, <argument><expr>0xe00000ff</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>INADDR_NONE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"INADDR_NONE"</expr></argument>, <argument><expr><name>INADDR_NONE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"INADDR_NONE"</expr></argument>, <argument><expr>0xffffffff</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>IP_OPTIONS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"IP_OPTIONS"</expr></argument>, <argument><expr><name>IP_OPTIONS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>IP_HDRINCL</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"IP_HDRINCL"</expr></argument>, <argument><expr><name>IP_HDRINCL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>IP_TOS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"IP_TOS"</expr></argument>, <argument><expr><name>IP_TOS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>IP_TTL</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"IP_TTL"</expr></argument>, <argument><expr><name>IP_TTL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>IP_RECVOPTS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"IP_RECVOPTS"</expr></argument>, <argument><expr><name>IP_RECVOPTS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>IP_RECVRETOPTS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"IP_RECVRETOPTS"</expr></argument>, <argument><expr><name>IP_RECVRETOPTS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>IP_RECVDSTADDR</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"IP_RECVDSTADDR"</expr></argument>, <argument><expr><name>IP_RECVDSTADDR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>IP_RETOPTS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"IP_RETOPTS"</expr></argument>, <argument><expr><name>IP_RETOPTS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>IP_MULTICAST_IF</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"IP_MULTICAST_IF"</expr></argument>, <argument><expr><name>IP_MULTICAST_IF</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>IP_MULTICAST_TTL</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"IP_MULTICAST_TTL"</expr></argument>, <argument><expr><name>IP_MULTICAST_TTL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>IP_MULTICAST_LOOP</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"IP_MULTICAST_LOOP"</expr></argument>, <argument><expr><name>IP_MULTICAST_LOOP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>IP_ADD_MEMBERSHIP</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"IP_ADD_MEMBERSHIP"</expr></argument>, <argument><expr><name>IP_ADD_MEMBERSHIP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>IP_DROP_MEMBERSHIP</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"IP_DROP_MEMBERSHIP"</expr></argument>, <argument><expr><name>IP_DROP_MEMBERSHIP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>IP_DEFAULT_MULTICAST_TTL</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"IP_DEFAULT_MULTICAST_TTL"</expr></argument>,
<argument><expr><name>IP_DEFAULT_MULTICAST_TTL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>IP_DEFAULT_MULTICAST_LOOP</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"IP_DEFAULT_MULTICAST_LOOP"</expr></argument>,
<argument><expr><name>IP_DEFAULT_MULTICAST_LOOP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>IP_MAX_MEMBERSHIPS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"IP_MAX_MEMBERSHIPS"</expr></argument>, <argument><expr><name>IP_MAX_MEMBERSHIPS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>IPV6_JOIN_GROUP</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"IPV6_JOIN_GROUP"</expr></argument>, <argument><expr><name>IPV6_JOIN_GROUP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>IPV6_LEAVE_GROUP</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"IPV6_LEAVE_GROUP"</expr></argument>, <argument><expr><name>IPV6_LEAVE_GROUP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>IPV6_MULTICAST_HOPS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"IPV6_MULTICAST_HOPS"</expr></argument>, <argument><expr><name>IPV6_MULTICAST_HOPS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>IPV6_MULTICAST_IF</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"IPV6_MULTICAST_IF"</expr></argument>, <argument><expr><name>IPV6_MULTICAST_IF</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>IPV6_MULTICAST_LOOP</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"IPV6_MULTICAST_LOOP"</expr></argument>, <argument><expr><name>IPV6_MULTICAST_LOOP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>IPV6_UNICAST_HOPS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"IPV6_UNICAST_HOPS"</expr></argument>, <argument><expr><name>IPV6_UNICAST_HOPS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>IPV6_V6ONLY</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"IPV6_V6ONLY"</expr></argument>, <argument><expr><name>IPV6_V6ONLY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>IPV6_CHECKSUM</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"IPV6_CHECKSUM"</expr></argument>, <argument><expr><name>IPV6_CHECKSUM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>IPV6_DONTFRAG</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"IPV6_DONTFRAG"</expr></argument>, <argument><expr><name>IPV6_DONTFRAG</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>IPV6_DSTOPTS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"IPV6_DSTOPTS"</expr></argument>, <argument><expr><name>IPV6_DSTOPTS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>IPV6_HOPLIMIT</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"IPV6_HOPLIMIT"</expr></argument>, <argument><expr><name>IPV6_HOPLIMIT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>IPV6_HOPOPTS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"IPV6_HOPOPTS"</expr></argument>, <argument><expr><name>IPV6_HOPOPTS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>IPV6_NEXTHOP</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"IPV6_NEXTHOP"</expr></argument>, <argument><expr><name>IPV6_NEXTHOP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>IPV6_PATHMTU</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"IPV6_PATHMTU"</expr></argument>, <argument><expr><name>IPV6_PATHMTU</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>IPV6_PKTINFO</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"IPV6_PKTINFO"</expr></argument>, <argument><expr><name>IPV6_PKTINFO</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>IPV6_RECVDSTOPTS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"IPV6_RECVDSTOPTS"</expr></argument>, <argument><expr><name>IPV6_RECVDSTOPTS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>IPV6_RECVHOPLIMIT</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"IPV6_RECVHOPLIMIT"</expr></argument>, <argument><expr><name>IPV6_RECVHOPLIMIT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>IPV6_RECVHOPOPTS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"IPV6_RECVHOPOPTS"</expr></argument>, <argument><expr><name>IPV6_RECVHOPOPTS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>IPV6_RECVPKTINFO</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"IPV6_RECVPKTINFO"</expr></argument>, <argument><expr><name>IPV6_RECVPKTINFO</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>IPV6_RECVRTHDR</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"IPV6_RECVRTHDR"</expr></argument>, <argument><expr><name>IPV6_RECVRTHDR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>IPV6_RECVTCLASS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"IPV6_RECVTCLASS"</expr></argument>, <argument><expr><name>IPV6_RECVTCLASS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>IPV6_RTHDR</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"IPV6_RTHDR"</expr></argument>, <argument><expr><name>IPV6_RTHDR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>IPV6_RTHDRDSTOPTS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"IPV6_RTHDRDSTOPTS"</expr></argument>, <argument><expr><name>IPV6_RTHDRDSTOPTS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>IPV6_RTHDR_TYPE_0</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"IPV6_RTHDR_TYPE_0"</expr></argument>, <argument><expr><name>IPV6_RTHDR_TYPE_0</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>IPV6_RECVPATHMTU</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"IPV6_RECVPATHMTU"</expr></argument>, <argument><expr><name>IPV6_RECVPATHMTU</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>IPV6_TCLASS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"IPV6_TCLASS"</expr></argument>, <argument><expr><name>IPV6_TCLASS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>IPV6_USE_MIN_MTU</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"IPV6_USE_MIN_MTU"</expr></argument>, <argument><expr><name>IPV6_USE_MIN_MTU</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>TCP_NODELAY</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"TCP_NODELAY"</expr></argument>, <argument><expr><name>TCP_NODELAY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>TCP_MAXSEG</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"TCP_MAXSEG"</expr></argument>, <argument><expr><name>TCP_MAXSEG</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>TCP_CORK</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"TCP_CORK"</expr></argument>, <argument><expr><name>TCP_CORK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>TCP_KEEPIDLE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"TCP_KEEPIDLE"</expr></argument>, <argument><expr><name>TCP_KEEPIDLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>TCP_KEEPINTVL</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"TCP_KEEPINTVL"</expr></argument>, <argument><expr><name>TCP_KEEPINTVL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>TCP_KEEPCNT</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"TCP_KEEPCNT"</expr></argument>, <argument><expr><name>TCP_KEEPCNT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>TCP_SYNCNT</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"TCP_SYNCNT"</expr></argument>, <argument><expr><name>TCP_SYNCNT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>TCP_LINGER2</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"TCP_LINGER2"</expr></argument>, <argument><expr><name>TCP_LINGER2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>TCP_DEFER_ACCEPT</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"TCP_DEFER_ACCEPT"</expr></argument>, <argument><expr><name>TCP_DEFER_ACCEPT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>TCP_WINDOW_CLAMP</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"TCP_WINDOW_CLAMP"</expr></argument>, <argument><expr><name>TCP_WINDOW_CLAMP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>TCP_INFO</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"TCP_INFO"</expr></argument>, <argument><expr><name>TCP_INFO</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>TCP_QUICKACK</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"TCP_QUICKACK"</expr></argument>, <argument><expr><name>TCP_QUICKACK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>IPX_TYPE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"IPX_TYPE"</expr></argument>, <argument><expr><name>IPX_TYPE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>EAI_ADDRFAMILY</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"EAI_ADDRFAMILY"</expr></argument>, <argument><expr><name>EAI_ADDRFAMILY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>EAI_AGAIN</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"EAI_AGAIN"</expr></argument>, <argument><expr><name>EAI_AGAIN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>EAI_BADFLAGS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"EAI_BADFLAGS"</expr></argument>, <argument><expr><name>EAI_BADFLAGS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>EAI_FAIL</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"EAI_FAIL"</expr></argument>, <argument><expr><name>EAI_FAIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>EAI_FAMILY</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"EAI_FAMILY"</expr></argument>, <argument><expr><name>EAI_FAMILY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>EAI_MEMORY</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"EAI_MEMORY"</expr></argument>, <argument><expr><name>EAI_MEMORY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>EAI_NODATA</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"EAI_NODATA"</expr></argument>, <argument><expr><name>EAI_NODATA</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>EAI_NONAME</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"EAI_NONAME"</expr></argument>, <argument><expr><name>EAI_NONAME</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>EAI_OVERFLOW</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"EAI_OVERFLOW"</expr></argument>, <argument><expr><name>EAI_OVERFLOW</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>EAI_SERVICE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"EAI_SERVICE"</expr></argument>, <argument><expr><name>EAI_SERVICE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>EAI_SOCKTYPE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"EAI_SOCKTYPE"</expr></argument>, <argument><expr><name>EAI_SOCKTYPE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>EAI_SYSTEM</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"EAI_SYSTEM"</expr></argument>, <argument><expr><name>EAI_SYSTEM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>EAI_BADHINTS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"EAI_BADHINTS"</expr></argument>, <argument><expr><name>EAI_BADHINTS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>EAI_PROTOCOL</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"EAI_PROTOCOL"</expr></argument>, <argument><expr><name>EAI_PROTOCOL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>EAI_MAX</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"EAI_MAX"</expr></argument>, <argument><expr><name>EAI_MAX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>AI_PASSIVE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"AI_PASSIVE"</expr></argument>, <argument><expr><name>AI_PASSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>AI_CANONNAME</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"AI_CANONNAME"</expr></argument>, <argument><expr><name>AI_CANONNAME</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>AI_NUMERICHOST</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"AI_NUMERICHOST"</expr></argument>, <argument><expr><name>AI_NUMERICHOST</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>AI_NUMERICSERV</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"AI_NUMERICSERV"</expr></argument>, <argument><expr><name>AI_NUMERICSERV</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>AI_MASK</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"AI_MASK"</expr></argument>, <argument><expr><name>AI_MASK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>AI_ALL</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"AI_ALL"</expr></argument>, <argument><expr><name>AI_ALL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>AI_V4MAPPED_CFG</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"AI_V4MAPPED_CFG"</expr></argument>, <argument><expr><name>AI_V4MAPPED_CFG</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>AI_ADDRCONFIG</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"AI_ADDRCONFIG"</expr></argument>, <argument><expr><name>AI_ADDRCONFIG</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>AI_V4MAPPED</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"AI_V4MAPPED"</expr></argument>, <argument><expr><name>AI_V4MAPPED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>AI_DEFAULT</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"AI_DEFAULT"</expr></argument>, <argument><expr><name>AI_DEFAULT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>NI_MAXHOST</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"NI_MAXHOST"</expr></argument>, <argument><expr><name>NI_MAXHOST</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>NI_MAXSERV</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"NI_MAXSERV"</expr></argument>, <argument><expr><name>NI_MAXSERV</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>NI_NOFQDN</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"NI_NOFQDN"</expr></argument>, <argument><expr><name>NI_NOFQDN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>NI_NUMERICHOST</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"NI_NUMERICHOST"</expr></argument>, <argument><expr><name>NI_NUMERICHOST</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>NI_NAMEREQD</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"NI_NAMEREQD"</expr></argument>, <argument><expr><name>NI_NAMEREQD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>NI_NUMERICSERV</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"NI_NUMERICSERV"</expr></argument>, <argument><expr><name>NI_NUMERICSERV</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>NI_DGRAM</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"NI_DGRAM"</expr></argument>, <argument><expr><name>NI_DGRAM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SHUT_RD</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"SHUT_RD"</expr></argument>, <argument><expr><name>SHUT_RD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SD_RECEIVE</name></expr></argument>)</argument_list></call></expr></cpp:elif>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"SHUT_RD"</expr></argument>, <argument><expr><name>SD_RECEIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"SHUT_RD"</expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SHUT_WR</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"SHUT_WR"</expr></argument>, <argument><expr><name>SHUT_WR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SD_SEND</name></expr></argument>)</argument_list></call></expr></cpp:elif>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"SHUT_WR"</expr></argument>, <argument><expr><name>SD_SEND</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"SHUT_WR"</expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SHUT_RDWR</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"SHUT_RDWR"</expr></argument>, <argument><expr><name>SHUT_RDWR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SD_BOTH</name></expr></argument>)</argument_list></call></expr></cpp:elif>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"SHUT_RDWR"</expr></argument>, <argument><expr><name>SD_BOTH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"SHUT_RDWR"</expr></argument>, <argument><expr>2</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SIO_RCVALL</name></expr></argument>)</argument_list></call></expr></cpp:if>
<block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>tmp</name></decl>;</decl_stmt>
<expr_stmt><expr><name>tmp</name> = <call><name>PyLong_FromUnsignedLong</name><argument_list>(<argument><expr><name>SIO_RCVALL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>tmp</name> == <name>NULL</name></expr>)</condition><then>
<return>return;</return></then></if>
<expr_stmt><expr><call><name>PyModule_AddObject</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"SIO_RCVALL"</expr></argument>, <argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"RCVALL_OFF"</expr></argument>, <argument><expr><name>RCVALL_OFF</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"RCVALL_ON"</expr></argument>, <argument><expr><name>RCVALL_ON</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"RCVALL_SOCKETLEVELONLY"</expr></argument>, <argument><expr><name>RCVALL_SOCKETLEVELONLY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>RCVALL_IPLEVEL</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"RCVALL_IPLEVEL"</expr></argument>, <argument><expr><name>RCVALL_IPLEVEL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>RCVALL_MAX</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"RCVALL_MAX"</expr></argument>, <argument><expr><name>RCVALL_MAX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>USE_GETHOSTBYNAME_LOCK</name></expr></argument>)</argument_list></call> || <call><name>defined</name><argument_list>(<argument><expr><name>USE_GETADDRINFO_LOCK</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><name>netdb_lock</name> = <call><name>PyThread_allocate_lock</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></function>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>HAVE_INET_PTON</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>NTDDI_VERSION</name></expr></argument>)</argument_list></call> || (<name>NTDDI_VERSION</name> &lt; <name>NTDDI_LONGHORN</name>)</expr></cpp:if>
<function><type><name>int</name></type>
<name>inet_pton</name><parameter_list>(<param><decl><type><name>int</name></type> <name>af</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>src</name></decl></param>, <param><decl><type><name>void</name> *</type><name>dst</name></decl></param>)</parameter_list> <block>{
<if>if <condition>(<expr><name>af</name> == <name>AF_INET</name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>long</name></type> <name>packed_addr</name></decl>;</decl_stmt>
<expr_stmt><expr><name>packed_addr</name> = <call><name>inet_addr</name><argument_list>(<argument><expr><name>src</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>packed_addr</name> == <name>INADDR_NONE</name></expr>)</condition><then>
<return>return <expr>0</expr>;</return></then></if>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>dst</name></expr></argument>, <argument><expr>&amp;<name>packed_addr</name></expr></argument>, <argument><expr>4</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>1</expr>;</return>
}</block></then></if>
<return>return <expr>-1</expr>;</return>
}</block></function>
<function><type><specifier>const</specifier> <name>char</name> *</type>
<name>inet_ntop</name><parameter_list>(<param><decl><type><name>int</name></type> <name>af</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>void</name> *</type><name>src</name></decl></param>, <param><decl><type><name>char</name> *</type><name>dst</name></decl></param>, <param><decl><type><name>socklen_t</name></type> <name>size</name></decl></param>)</parameter_list> <block>{
<if>if <condition>(<expr><name>af</name> == <name>AF_INET</name></expr>)</condition><then> <block>{
<decl_stmt><decl><type>struct <name>in_addr</name></type> <name>packed_addr</name></decl>;</decl_stmt>
<if>if <condition>(<expr><name>size</name> &lt; 16</expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name>packed_addr</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>packed_addr</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>strncpy</name><argument_list>(<argument><expr><name>dst</name></expr></argument>, <argument><expr><call><name>inet_ntoa</name><argument_list>(<argument><expr><name>packed_addr</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></then></if>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></function></block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</unit>
