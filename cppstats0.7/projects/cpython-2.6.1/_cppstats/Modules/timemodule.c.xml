<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C" filename="projects/cpython-2.6.1/_cppstats/Modules/timemodule.c"><cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"Python.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"structseq.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"timefuncs.h"</cpp:file></cpp:include>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__APPLE__</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_GETTIMEOFDAY</name></expr></argument>)</argument_list></call> &amp;&amp; <call><name>defined</name><argument_list>(<argument><expr><name>HAVE_FTIME</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>HAVE_FTIME</name></cpp:undef>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;ctype.h&gt;</cpp:file></cpp:include>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_SYS_TYPES_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/types.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>QUICKWIN</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;io.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_FTIME</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/timeb.h&gt;</cpp:file></cpp:include>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>MS_WINDOWS</name></expr></argument>)</argument_list></call> &amp;&amp; !<call><name>defined</name><argument_list>(<argument><expr><name>PYOS_OS2</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function_decl><type><specifier>extern</specifier> <name>int</name></type> <name>ftime</name><parameter_list>(<param><decl><type>struct</type> <name>timeb</name> *</decl></param>)</parameter_list>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__WATCOMC__</name></expr></argument>)</argument_list></call> &amp;&amp; !<call><name>defined</name><argument_list>(<argument><expr><name>__QNX__</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;i86.h&gt;</cpp:file></cpp:include>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MS_WINDOWS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WIN32_LEAN_AND_MEAN</name></cpp:macro></cpp:define>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;windows.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pythread.h"</cpp:file></cpp:include>
<decl_stmt><decl><type><specifier>static</specifier> <name>HANDLE</name></type> <name>hInterruptEvent</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<function><type><specifier>static</specifier> <name>BOOL</name> <name>WINAPI</name></type> <name>PyCtrlHandler</name><parameter_list>(<param><decl><type><name>DWORD</name></type> <name>dwCtrlType</name></decl></param>)</parameter_list> <block>{
<expr_stmt><expr><call><name>SetEvent</name><argument_list>(<argument><expr><name>hInterruptEvent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>FALSE</name></expr>;</return>
}</block></function>
<decl_stmt><decl><type><specifier>static</specifier> <name>long</name></type> <name>main_thread</name></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__BORLANDC__</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>timezone</name></cpp:macro> <cpp:value>_timezone</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>tzname</name></cpp:macro> <cpp:value>_tzname</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>daylight</name></cpp:macro> <cpp:value>_daylight</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MS_WINDOWS</name></expr></argument>)</argument_list></call> &amp;&amp; !<call><name>defined</name><argument_list>(<argument><expr><name>__BORLANDC__</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>HAVE_CLOCK</name></cpp:undef>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>PYOS_OS2</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INCL_DOS</name></cpp:macro></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INCL_ERRORS</name></cpp:macro></cpp:define>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;os2.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>PYCC_VACPP</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/time.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__BEOS__</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;time.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;support/SupportDefs.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;kernel/OS.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>RISCOS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function_decl><type><specifier>extern</specifier> <name>int</name></type> <name>riscos_sleep</name><parameter_list>(<param><decl><type><name>double</name></type></decl></param>)</parameter_list>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>floatsleep</name><parameter_list>(<param><decl><type><name>double</name></type></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>double</name></type> <name>floattime</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list>;</function_decl>
<decl_stmt><decl><type><specifier>static</specifier> <name>PyObject</name> *</type><name>moddict</name></decl>;</decl_stmt>
<function><type><name>time_t</name></type>
<name>_PyTime_DoubleToTimet</name><parameter_list>(<param><decl><type><name>double</name></type> <name>x</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>time_t</name></type> <name>result</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>double</name></type> <name>diff</name></decl>;</decl_stmt>
<expr_stmt><expr><name>result</name> = (<name>time_t</name>)<name>x</name></expr>;</expr_stmt>
<expr_stmt><expr><name>diff</name> = <name>x</name> - (<name>double</name>)<name>result</name></expr>;</expr_stmt>
<if>if <condition>(<expr><name>diff</name> &lt;= -1.0 || <name>diff</name> &gt;= 1.0</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>,
<argument><expr>"timestamp out of range for platform time_t"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>result</name> = (<name>time_t</name>)-1</expr>;</expr_stmt>
}</block></then></if>
<return>return <expr><name>result</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>time_time</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>unused</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>double</name></type> <name>secs</name></decl>;</decl_stmt>
<expr_stmt><expr><name>secs</name> = <call><name>floattime</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>secs</name> == 0.0</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetFromErrno</name><argument_list>(<argument><expr><name>PyExc_IOError</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<return>return <expr><call><name>PyFloat_FromDouble</name><argument_list>(<argument><expr><name>secs</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>time_doc</name></expr></argument>,
<argument><expr>"time() -&gt; floating point number\n\
\n\
Return the current time in seconds since the Epoch.\n\
Fractions of a second may be present if the system clock provides them."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_CLOCK</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>CLOCKS_PER_SEC</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>CLK_TCK</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CLOCKS_PER_SEC</name></cpp:macro> <cpp:value>CLK_TCK</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CLOCKS_PER_SEC</name></cpp:macro> <cpp:value>1000000</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>time_clock</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>unused</name></decl></param>)</parameter_list> <block>{
<return>return <expr><call><name>PyFloat_FromDouble</name><argument_list>(<argument><expr>((<name>double</name>)<call><name>clock</name><argument_list>()</argument_list></call>) / <name>CLOCKS_PER_SEC</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MS_WINDOWS</name></expr></argument>)</argument_list></call> &amp;&amp; !<call><name>defined</name><argument_list>(<argument><expr><name>__BORLANDC__</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>time_clock</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>unused</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><specifier>static</specifier> <name>LARGE_INTEGER</name></type> <name>ctrStart</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>double</name></type> <name>divisor</name> <init>= <expr>0.0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>LARGE_INTEGER</name></type> <name>now</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>double</name></type> <name>diff</name></decl>;</decl_stmt>
<if>if <condition>(<expr><name>divisor</name> == 0.0</expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>LARGE_INTEGER</name></type> <name>freq</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>QueryPerformanceCounter</name><argument_list>(<argument><expr>&amp;<name>ctrStart</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<call><name>QueryPerformanceFrequency</name><argument_list>(<argument><expr>&amp;<name>freq</name></expr></argument>)</argument_list></call> || <name><name>freq</name>.<name>QuadPart</name></name> == 0</expr>)</condition><then> <block>{
<return>return <expr><call><name>PyFloat_FromDouble</name><argument_list>(<argument><expr>((<name>double</name>)<call><name>clock</name><argument_list>()</argument_list></call>) /
<name>CLOCKS_PER_SEC</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>divisor</name> = (<name>double</name>)<name><name>freq</name>.<name>QuadPart</name></name></expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><call><name>QueryPerformanceCounter</name><argument_list>(<argument><expr>&amp;<name>now</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>diff</name> = <call>(<name>double</name>)<argument_list>(<argument><expr><name><name>now</name>.<name>QuadPart</name></name> - <name><name>ctrStart</name>.<name>QuadPart</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>PyFloat_FromDouble</name><argument_list>(<argument><expr><name>diff</name> / <name>divisor</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HAVE_CLOCK</name></cpp:macro></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_CLOCK</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>clock_doc</name></expr></argument>,
<argument><expr>"clock() -&gt; floating point number\n\
\n\
Return the CPU time or real time since the start of the process or since\n\
the first call to clock(). This has as much precision as the system\n\
records."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>time_sleep</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>double</name></type> <name>secs</name></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"d:sleep"</expr></argument>, <argument><expr>&amp;<name>secs</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<if>if <condition>(<expr><call><name>floatsleep</name><argument_list>(<argument><expr><name>secs</name></expr></argument>)</argument_list></call> != 0</expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>Py_None</name></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>sleep_doc</name></expr></argument>,
<argument><expr>"sleep(seconds)\n\
\n\
Delay execution for a given number of seconds. The argument may be\n\
a floating point number for subsecond precision."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>PyStructSequence_Field</name></type> <name><name>struct_time_type_fields</name><index>[]</index></name> <init>= <expr><block>{
<expr><block>{<expr>"tm_year"</expr>, <expr><name>NULL</name></expr>}</block></expr>,
<expr><block>{<expr>"tm_mon"</expr>, <expr><name>NULL</name></expr>}</block></expr>,
<expr><block>{<expr>"tm_mday"</expr>, <expr><name>NULL</name></expr>}</block></expr>,
<expr><block>{<expr>"tm_hour"</expr>, <expr><name>NULL</name></expr>}</block></expr>,
<expr><block>{<expr>"tm_min"</expr>, <expr><name>NULL</name></expr>}</block></expr>,
<expr><block>{<expr>"tm_sec"</expr>, <expr><name>NULL</name></expr>}</block></expr>,
<expr><block>{<expr>"tm_wday"</expr>, <expr><name>NULL</name></expr>}</block></expr>,
<expr><block>{<expr>"tm_yday"</expr>, <expr><name>NULL</name></expr>}</block></expr>,
<expr><block>{<expr>"tm_isdst"</expr>, <expr><name>NULL</name></expr>}</block></expr>,
<expr><block>{<expr>0</expr>}</block></expr>
}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>PyStructSequence_Desc</name></type> <name>struct_time_type_desc</name> <init>= <expr><block>{
<expr>"time.struct_time"</expr>,
<expr><name>NULL</name></expr>,
<expr><name>struct_time_type_fields</name></expr>,
<expr>9</expr>,
}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>initialized</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>PyTypeObject</name></type> <name>StructTimeType</name></decl>;</decl_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>tmtotuple</name><parameter_list>(<param><decl><type>struct <name>tm</name> *</type><name>p</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>v</name> <init>= <expr><call><name>PyStructSequence_New</name><argument_list>(<argument><expr>&amp;<name>StructTimeType</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>v</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SET</name><parameter_list>(<param><type><name>i</name></type></param>,<param><type><name>val</name></type></param>)</parameter_list></cpp:macro> <cpp:value>PyStructSequence_SET_ITEM(v, i, PyInt_FromLong((long) val))</cpp:value></cpp:define>
<expr_stmt><expr><call><name>SET</name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr><name><name>p</name>-&gt;<name>tm_year</name></name> + 1900</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SET</name><argument_list>(<argument><expr>1</expr></argument>, <argument><expr><name><name>p</name>-&gt;<name>tm_mon</name></name> + 1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SET</name><argument_list>(<argument><expr>2</expr></argument>, <argument><expr><name><name>p</name>-&gt;<name>tm_mday</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SET</name><argument_list>(<argument><expr>3</expr></argument>, <argument><expr><name><name>p</name>-&gt;<name>tm_hour</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SET</name><argument_list>(<argument><expr>4</expr></argument>, <argument><expr><name><name>p</name>-&gt;<name>tm_min</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SET</name><argument_list>(<argument><expr>5</expr></argument>, <argument><expr><name><name>p</name>-&gt;<name>tm_sec</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SET</name><argument_list>(<argument><expr>6</expr></argument>, <argument><expr>(<name><name>p</name>-&gt;<name>tm_wday</name></name> + 6) % 7</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SET</name><argument_list>(<argument><expr>7</expr></argument>, <argument><expr><name><name>p</name>-&gt;<name>tm_yday</name></name> + 1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SET</name><argument_list>(<argument><expr>8</expr></argument>, <argument><expr><name><name>p</name>-&gt;<name>tm_isdst</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>SET</name></cpp:undef>
<if>if <condition>(<expr><call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<return>return <expr><name>v</name></expr>;</return>
}</block></function>
<decl_stmt><decl><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>time_convert</name><argument_list>(<argument><expr><name>double</name> <name>when</name></expr></argument>, <argument>struct <expr><call><call><name>tm</name> * <argument_list>(<argument><expr>*<name>function</name></expr></argument>)</argument_list></call><argument_list>(<argument><expr>const <name>time_t</name> *</expr></argument>)</argument_list></call></expr></argument>)</argument_list> <block>{
<decl_stmt><decl><type>struct <name>tm</name> *</type><name>p</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>time_t</name></type> <name>whent</name> <init>= <expr><call><name>_PyTime_DoubleToTimet</name><argument_list>(<argument><expr><name>when</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>whent</name> == (<name>time_t</name>)-1 &amp;&amp; <call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>errno</name> = 0</expr>;</expr_stmt>
<expr_stmt><expr><name>p</name> = <call><name>function</name><argument_list>(<argument><expr>&amp;<name>whent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>p</name> == <name>NULL</name></expr>)</condition><then> <block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>EINVAL</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if>if <condition>(<expr><name>errno</name> == 0</expr>)</condition><then>
<expr_stmt><expr><name>errno</name> = <name>EINVAL</name></expr>;</expr_stmt></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<return>return <expr><call><name>PyErr_SetFromErrno</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></then></if>
<return>return <expr><call><name>tmtotuple</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></decl></decl_stmt>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>parse_time_double_args</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>, <param><decl><type><name>char</name> *</type><name>format</name></decl></param>, <param><decl><type><name>double</name> *</type><name>pwhen</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>ot</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>format</name></expr></argument>, <argument><expr>&amp;<name>ot</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr>0</expr>;</return></then></if>
<if>if <condition>(<expr><name>ot</name> == <name>NULL</name> || <name>ot</name> == <name>Py_None</name></expr>)</condition><then>
<expr_stmt><expr>*<name>pwhen</name> = <call><name>floattime</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then>
<else>else <block>{
<decl_stmt><decl><type><name>double</name></type> <name>when</name> <init>= <expr><call><name>PyFloat_AsDouble</name><argument_list>(<argument><expr><name>ot</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then>
<return>return <expr>0</expr>;</return></then></if>
<expr_stmt><expr>*<name>pwhen</name> = <name>when</name></expr>;</expr_stmt>
}</block></else></if>
<return>return <expr>1</expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>time_gmtime</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>double</name></type> <name>when</name></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>parse_time_double_args</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"|O:gmtime"</expr></argument>, <argument><expr>&amp;<name>when</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<return>return <expr><call><name>time_convert</name><argument_list>(<argument><expr><name>when</name></expr></argument>, <argument><expr><name>gmtime</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>gmtime_doc</name></expr></argument>,
<argument><expr>"gmtime([seconds]) -&gt; (tm_year, tm_mon, tm_mday, tm_hour, tm_min,\n\
tm_sec, tm_wday, tm_yday, tm_isdst)\n\
\n\
Convert seconds since the Epoch to a time tuple expressing UTC (a.k.a.\n\
GMT). When 'seconds' is not passed in, convert the current time instead."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>time_localtime</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>double</name></type> <name>when</name></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>parse_time_double_args</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"|O:localtime"</expr></argument>, <argument><expr>&amp;<name>when</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<return>return <expr><call><name>time_convert</name><argument_list>(<argument><expr><name>when</name></expr></argument>, <argument><expr><name>localtime</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>localtime_doc</name></expr></argument>,
<argument><expr>"localtime([seconds]) -&gt; (tm_year,tm_mon,tm_mday,tm_hour,tm_min,\n\
tm_sec,tm_wday,tm_yday,tm_isdst)\n\
\n\
Convert seconds since the Epoch to a time tuple expressing local time.\n\
When 'seconds' is not passed in, convert the current time instead."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>gettmarg</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>, <param><decl><type>struct <name>tm</name> *</type><name>p</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>y</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr>(<name>void</name> *) <name>p</name></expr></argument>, <argument><expr>'\0'</expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument>struct <expr><name>tm</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<call><name>PyArg_Parse</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"(iiiiiiiii)"</expr></argument>,
<argument><expr>&amp;<name>y</name></expr></argument>,
<argument><expr>&amp;<name><name>p</name>-&gt;<name>tm_mon</name></name></expr></argument>,
<argument><expr>&amp;<name><name>p</name>-&gt;<name>tm_mday</name></name></expr></argument>,
<argument><expr>&amp;<name><name>p</name>-&gt;<name>tm_hour</name></name></expr></argument>,
<argument><expr>&amp;<name><name>p</name>-&gt;<name>tm_min</name></name></expr></argument>,
<argument><expr>&amp;<name><name>p</name>-&gt;<name>tm_sec</name></name></expr></argument>,
<argument><expr>&amp;<name><name>p</name>-&gt;<name>tm_wday</name></name></expr></argument>,
<argument><expr>&amp;<name><name>p</name>-&gt;<name>tm_yday</name></name></expr></argument>,
<argument><expr>&amp;<name><name>p</name>-&gt;<name>tm_isdst</name></name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr>0</expr>;</return></then></if>
<if>if <condition>(<expr><name>y</name> &lt; 1900</expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>accept</name> <init>= <expr><call><name>PyDict_GetItemString</name><argument_list>(<argument><expr><name>moddict</name></expr></argument>,
<argument><expr>"accept2dyear"</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>accept</name> == <name>NULL</name> || !<call><name>PyInt_Check</name><argument_list>(<argument><expr><name>accept</name></expr></argument>)</argument_list></call> ||
<call><name>PyInt_AsLong</name><argument_list>(<argument><expr><name>accept</name></expr></argument>)</argument_list></call> == 0</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>,
<argument><expr>"year &gt;= 1900 required"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>0</expr>;</return>
}</block></then></if>
<if>if <condition>(<expr>69 &lt;= <name>y</name> &amp;&amp; <name>y</name> &lt;= 99</expr>)</condition><then>
<expr_stmt><expr><name>y</name> += 1900</expr>;</expr_stmt></then>
<else>else <if>if <condition>(<expr>0 &lt;= <name>y</name> &amp;&amp; <name>y</name> &lt;= 68</expr>)</condition><then>
<expr_stmt><expr><name>y</name> += 2000</expr>;</expr_stmt></then>
<else>else <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>,
<argument><expr>"year out of range"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>0</expr>;</return>
}</block></else></if></else></if>
}</block></then></if>
<expr_stmt><expr><name><name>p</name>-&gt;<name>tm_year</name></name> = <name>y</name> - 1900</expr>;</expr_stmt>
<expr_stmt><expr><name><name>p</name>-&gt;<name>tm_mon</name></name>--</expr>;</expr_stmt>
<expr_stmt><expr><name><name>p</name>-&gt;<name>tm_wday</name></name> = (<name><name>p</name>-&gt;<name>tm_wday</name></name> + 1) % 7</expr>;</expr_stmt>
<expr_stmt><expr><name><name>p</name>-&gt;<name>tm_yday</name></name>--</expr>;</expr_stmt>
<return>return <expr>1</expr>;</return>
}</block></function>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_STRFTIME</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>time_strftime</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>tup</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type>struct <name>tm</name></type> <name>buf</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>fmt</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>fmtlen</name></decl>, <decl><type ref="prev"/><name>buflen</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>outbuf</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>i</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr>(<name>void</name> *) &amp;<name>buf</name></expr></argument>, <argument><expr>'\0'</expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"s|O:strftime"</expr></argument>, <argument><expr>&amp;<name>fmt</name></expr></argument>, <argument><expr>&amp;<name>tup</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<if>if <condition>(<expr><name>tup</name> == <name>NULL</name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>time_t</name></type> <name>tt</name> <init>= <expr><call><name>time</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>buf</name> = *<call><name>localtime</name><argument_list>(<argument><expr>&amp;<name>tt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else <if>if <condition>(<expr>!<call><name>gettmarg</name><argument_list>(<argument><expr><name>tup</name></expr></argument>, <argument><expr>&amp;<name>buf</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if></else></if>
<if>if <condition>(<expr><name><name>buf</name>.<name>tm_mon</name></name> == -1</expr>)</condition><then>
<expr_stmt><expr><name><name>buf</name>.<name>tm_mon</name></name> = 0</expr>;</expr_stmt></then>
<else>else <if>if <condition>(<expr><name><name>buf</name>.<name>tm_mon</name></name> &lt; 0 || <name><name>buf</name>.<name>tm_mon</name></name> &gt; 11</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>, <argument><expr>"month out of range"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if></else></if>
<if>if <condition>(<expr><name><name>buf</name>.<name>tm_mday</name></name> == 0</expr>)</condition><then>
<expr_stmt><expr><name><name>buf</name>.<name>tm_mday</name></name> = 1</expr>;</expr_stmt></then>
<else>else <if>if <condition>(<expr><name><name>buf</name>.<name>tm_mday</name></name> &lt; 0 || <name><name>buf</name>.<name>tm_mday</name></name> &gt; 31</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>, <argument><expr>"day of month out of range"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if></else></if>
<if>if <condition>(<expr><name><name>buf</name>.<name>tm_hour</name></name> &lt; 0 || <name><name>buf</name>.<name>tm_hour</name></name> &gt; 23</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>, <argument><expr>"hour out of range"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<if>if <condition>(<expr><name><name>buf</name>.<name>tm_min</name></name> &lt; 0 || <name><name>buf</name>.<name>tm_min</name></name> &gt; 59</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>, <argument><expr>"minute out of range"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<if>if <condition>(<expr><name><name>buf</name>.<name>tm_sec</name></name> &lt; 0 || <name><name>buf</name>.<name>tm_sec</name></name> &gt; 61</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>, <argument><expr>"seconds out of range"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<if>if <condition>(<expr><name><name>buf</name>.<name>tm_wday</name></name> &lt; 0</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>, <argument><expr>"day of week out of range"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<if>if <condition>(<expr><name><name>buf</name>.<name>tm_yday</name></name> == -1</expr>)</condition><then>
<expr_stmt><expr><name><name>buf</name>.<name>tm_yday</name></name> = 0</expr>;</expr_stmt></then>
<else>else <if>if <condition>(<expr><name><name>buf</name>.<name>tm_yday</name></name> &lt; 0 || <name><name>buf</name>.<name>tm_yday</name></name> &gt; 365</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>, <argument><expr>"day of year out of range"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if></else></if>
<if>if <condition>(<expr><name><name>buf</name>.<name>tm_isdst</name></name> &lt; -1 || <name><name>buf</name>.<name>tm_isdst</name></name> &gt; 1</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>,
<argument><expr>"daylight savings flag out of range"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>fmtlen</name> = <call><name>strlen</name><argument_list>(<argument><expr><name>fmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for (<init><expr><name>i</name> = 1024</expr>;</init> <condition>;</condition> <incr><expr><name>i</name> += <name>i</name></expr></incr>) <block>{
<expr_stmt><expr><name>outbuf</name> = (<name>char</name> *)<call><name>malloc</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>outbuf</name> == <name>NULL</name></expr>)</condition><then> <block>{
<return>return <expr><call><name>PyErr_NoMemory</name><argument_list>()</argument_list></call></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>buflen</name> = <call><name>strftime</name><argument_list>(<argument><expr><name>outbuf</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>, <argument><expr>&amp;<name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>buflen</name> &gt; 0 || <name>i</name> &gt;= 256 * <name>fmtlen</name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>ret</name></decl>;</decl_stmt>
<expr_stmt><expr><name>ret</name> = <call><name>PyString_FromStringAndSize</name><argument_list>(<argument><expr><name>outbuf</name></expr></argument>, <argument><expr><name>buflen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>outbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>ret</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>outbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>defined</name> <name>_MSC_VER</name> &amp;&amp; <name>_MSC_VER</name> &gt;= 1400 &amp;&amp; <call><name>defined</name><argument_list>(<argument><expr><name>__STDC_SECURE_LIB__</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if>if <condition>(<expr><name>buflen</name> == 0 &amp;&amp; <name>errno</name> == <name>EINVAL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>, <argument><expr>"Invalid format string"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>0</expr>;</return>
}</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></for>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>strftime_doc</name></expr></argument>,
<argument><expr>"strftime(format[, tuple]) -&gt; string\n\
\n\
Convert a time tuple to a string according to a format specification.\n\
See the library reference manual for formatting codes. When the time tuple\n\
is not present, current time as returned by localtime() is used."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>time_strptime</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>strptime_module</name> <init>= <expr><call><name>PyImport_ImportModuleNoBlock</name><argument_list>(<argument><expr>"_strptime"</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>strptime_result</name></decl>;</decl_stmt>
<if>if <condition>(<expr>!<name>strptime_module</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>strptime_result</name> = <call><name>PyObject_CallMethod</name><argument_list>(<argument><expr><name>strptime_module</name></expr></argument>, <argument><expr>"_strptime_time"</expr></argument>, <argument><expr>"O"</expr></argument>, <argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>strptime_module</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>strptime_result</name></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>strptime_doc</name></expr></argument>,
<argument><expr>"strptime(string, format) -&gt; struct_time\n\
\n\
Parse a string to a time tuple according to a format specification.\n\
See the library reference manual for formatting codes (same as strftime())."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>time_asctime</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>tup</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type>struct <name>tm</name></type> <name>buf</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>p</name></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>PyArg_UnpackTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"asctime"</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>1</expr></argument>, <argument><expr>&amp;<name>tup</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<if>if <condition>(<expr><name>tup</name> == <name>NULL</name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>time_t</name></type> <name>tt</name> <init>= <expr><call><name>time</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>buf</name> = *<call><name>localtime</name><argument_list>(<argument><expr>&amp;<name>tt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else <if>if <condition>(<expr>!<call><name>gettmarg</name><argument_list>(<argument><expr><name>tup</name></expr></argument>, <argument><expr>&amp;<name>buf</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if></else></if>
<expr_stmt><expr><name>p</name> = <call><name>asctime</name><argument_list>(<argument><expr>&amp;<name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>p</name><index>[<expr>24</expr>]</index></name> == '\n'</expr>)</condition><then>
<expr_stmt><expr><name><name>p</name><index>[<expr>24</expr>]</index></name> = '\0'</expr>;</expr_stmt></then></if>
<return>return <expr><call><name>PyString_FromString</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>asctime_doc</name></expr></argument>,
<argument><expr>"asctime([tuple]) -&gt; string\n\
\n\
Convert a time tuple to a string, e.g. 'Sat Jun 06 16:26:11 1998'.\n\
When the time tuple is not present, current time as returned by localtime()\n\
is used."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>time_ctime</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>ot</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>time_t</name></type> <name>tt</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>p</name></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>PyArg_UnpackTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"ctime"</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>1</expr></argument>, <argument><expr>&amp;<name>ot</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<if>if <condition>(<expr><name>ot</name> == <name>NULL</name> || <name>ot</name> == <name>Py_None</name></expr>)</condition><then>
<expr_stmt><expr><name>tt</name> = <call><name>time</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
<else>else <block>{
<decl_stmt><decl><type><name>double</name></type> <name>dt</name> <init>= <expr><call><name>PyFloat_AsDouble</name><argument_list>(<argument><expr><name>ot</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>tt</name> = <call><name>_PyTime_DoubleToTimet</name><argument_list>(<argument><expr><name>dt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>tt</name> == (<name>time_t</name>)-1 &amp;&amp; <call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
}</block></else></if>
<expr_stmt><expr><name>p</name> = <call><name>ctime</name><argument_list>(<argument><expr>&amp;<name>tt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>p</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>, <argument><expr>"unconvertible time"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<if>if <condition>(<expr><name><name>p</name><index>[<expr>24</expr>]</index></name> == '\n'</expr>)</condition><then>
<expr_stmt><expr><name><name>p</name><index>[<expr>24</expr>]</index></name> = '\0'</expr>;</expr_stmt></then></if>
<return>return <expr><call><name>PyString_FromString</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>ctime_doc</name></expr></argument>,
<argument><expr>"ctime(seconds) -&gt; string\n\
\n\
Convert a time in seconds since the Epoch to a string in local time.\n\
This is equivalent to asctime(localtime(seconds)). When the time tuple is\n\
not present, current time as returned by localtime() is used."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_MKTIME</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>time_mktime</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>tup</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type>struct <name>tm</name></type> <name>buf</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>time_t</name></type> <name>tt</name></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>gettmarg</name><argument_list>(<argument><expr><name>tup</name></expr></argument>, <argument><expr>&amp;<name>buf</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>tt</name> = <call><name>mktime</name><argument_list>(<argument><expr>&amp;<name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>tt</name> == <call>(<name>time_t</name>)<argument_list>(<argument><expr>-1</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_OverflowError</name></expr></argument>,
<argument><expr>"mktime argument out of range"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<return>return <expr><call><name>PyFloat_FromDouble</name><argument_list>(<argument><expr>(<name>double</name>)<name>tt</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>mktime_doc</name></expr></argument>,
<argument><expr>"mktime(tuple) -&gt; floating point number\n\
\n\
Convert a time tuple in local time to seconds since the Epoch."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_WORKING_TZSET</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>inittimezone</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>module</name></decl></param>)</parameter_list>;</function_decl>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>time_tzset</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>unused</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyObject</name>*</type> <name>m</name></decl>;</decl_stmt>
<expr_stmt><expr><name>m</name> = <call><name>PyImport_ImportModuleNoBlock</name><argument_list>(<argument><expr>"time"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>m</name> == <name>NULL</name></expr>)</condition><then> <block>{
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><call><name>tzset</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>inittimezone</name><argument_list>(<argument><expr><name>m</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>m</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>Py_None</name></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>tzset_doc</name></expr></argument>,
<argument><expr>"tzset(zone)\n\
\n\
Initialize, or reinitialize, the local timezone to the value stored in\n\
os.environ['TZ']. The TZ environment variable should be specified in\n\
standard Unix timezone format as documented in the tzset man page\n\
(eg. 'US/Eastern', 'Europe/Amsterdam'). Unknown timezones will silently\n\
fall back to UTC. If the TZ environment variable is not set, the local\n\
timezone is set to the systems best guess of wallclock time.\n\
Changing the TZ environment variable without calling tzset *may* change\n\
the local timezone used by methods such as localtime, but this behaviour\n\
should not be relied on."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>inittimezone</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>m</name></decl></param>)</parameter_list> <block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_TZNAME</name></expr></argument>)</argument_list></call> &amp;&amp; !<call><name>defined</name><argument_list>(<argument><expr><name>__GLIBC__</name></expr></argument>)</argument_list></call> &amp;&amp; !<call><name>defined</name><argument_list>(<argument><expr><name>__CYGWIN__</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>tzset</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>PYOS_OS2</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"timezone"</expr></argument>, <argument><expr><name>_timezone</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"timezone"</expr></argument>, <argument><expr><name>timezone</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_ALTZONE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"altzone"</expr></argument>, <argument><expr><name>altzone</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>PYOS_OS2</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"altzone"</expr></argument>, <argument><expr><name>_timezone</name>-3600</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"altzone"</expr></argument>, <argument><expr><name>timezone</name>-3600</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"daylight"</expr></argument>, <argument><expr><name>daylight</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyModule_AddObject</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"tzname"</expr></argument>,
<argument><expr><call><name>Py_BuildValue</name><argument_list>(<argument><expr>"(zz)"</expr></argument>, <argument><expr><name><name>tzname</name><index>[<expr>0</expr>]</index></name></expr></argument>, <argument><expr><name><name>tzname</name><index>[<expr>1</expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_STRUCT_TM_TM_ZONE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<block>{
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>YEAR</name></cpp:macro> <cpp:value>((time_t)((365 * 24 + 6) * 3600))</cpp:value></cpp:define>
<decl_stmt><decl><type><name>time_t</name></type> <name>t</name></decl>;</decl_stmt>
<decl_stmt><decl><type>struct <name>tm</name> *</type><name>p</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>long</name></type> <name>janzone</name></decl>, <decl><type ref="prev"/><name>julyzone</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name><name>janname</name><index>[<expr>10</expr>]</index></name></decl>, <decl><type ref="prev"/><name><name>julyname</name><index>[<expr>10</expr>]</index></name></decl>;</decl_stmt>
<expr_stmt><expr><name>t</name> = (<call><name>time</name><argument_list>(<argument><expr>(<name>time_t</name> *)0</expr></argument>)</argument_list></call> / <name>YEAR</name>) * <name>YEAR</name></expr>;</expr_stmt>
<expr_stmt><expr><name>p</name> = <call><name>localtime</name><argument_list>(<argument><expr>&amp;<name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>janzone</name> = -<name><name>p</name>-&gt;<name>tm_gmtoff</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>strncpy</name><argument_list>(<argument><expr><name>janname</name></expr></argument>, <argument><expr><name><name>p</name>-&gt;<name>tm_zone</name></name> ? <name><name>p</name>-&gt;<name>tm_zone</name></name> : " "</expr></argument>, <argument><expr>9</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>janname</name><index>[<expr>9</expr>]</index></name> = '\0'</expr>;</expr_stmt>
<expr_stmt><expr><name>t</name> += <name>YEAR</name>/2</expr>;</expr_stmt>
<expr_stmt><expr><name>p</name> = <call><name>localtime</name><argument_list>(<argument><expr>&amp;<name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>julyzone</name> = -<name><name>p</name>-&gt;<name>tm_gmtoff</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>strncpy</name><argument_list>(<argument><expr><name>julyname</name></expr></argument>, <argument><expr><name><name>p</name>-&gt;<name>tm_zone</name></name> ? <name><name>p</name>-&gt;<name>tm_zone</name></name> : " "</expr></argument>, <argument><expr>9</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>julyname</name><index>[<expr>9</expr>]</index></name> = '\0'</expr>;</expr_stmt>
<if>if<condition>( <expr><name>janzone</name> &lt; <name>julyzone</name></expr> )</condition><then> <block>{
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"timezone"</expr></argument>, <argument><expr><name>julyzone</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"altzone"</expr></argument>, <argument><expr><name>janzone</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"daylight"</expr></argument>,
<argument><expr><name>janzone</name> != <name>julyzone</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyModule_AddObject</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"tzname"</expr></argument>,
<argument><expr><call><name>Py_BuildValue</name><argument_list>(<argument><expr>"(zz)"</expr></argument>,
<argument><expr><name>julyname</name></expr></argument>, <argument><expr><name>janname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"timezone"</expr></argument>, <argument><expr><name>janzone</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"altzone"</expr></argument>, <argument><expr><name>julyzone</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"daylight"</expr></argument>,
<argument><expr><name>janzone</name> != <name>julyzone</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyModule_AddObject</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"tzname"</expr></argument>,
<argument><expr><call><name>Py_BuildValue</name><argument_list>(<argument><expr>"(zz)"</expr></argument>,
<argument><expr><name>janname</name></expr></argument>, <argument><expr><name>julyname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></else></if>
}</block>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__CYGWIN__</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>tzset</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"timezone"</expr></argument>, <argument><expr><name>_timezone</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"altzone"</expr></argument>, <argument><expr><name>_timezone</name>-3600</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"daylight"</expr></argument>, <argument><expr><name>_daylight</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyModule_AddObject</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"tzname"</expr></argument>,
<argument><expr><call><name>Py_BuildValue</name><argument_list>(<argument><expr>"(zz)"</expr></argument>, <argument><expr><name><name>_tzname</name><index>[<expr>0</expr>]</index></name></expr></argument>, <argument><expr><name><name>_tzname</name><index>[<expr>1</expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></function>
<decl_stmt><decl><type><specifier>static</specifier> <name>PyMethodDef</name></type> <name><name>time_methods</name><index>[]</index></name> <init>= <expr><block>{
<expr><block>{<expr>"time"</expr>, <expr><name>time_time</name></expr>, <expr><name>METH_NOARGS</name></expr>, <expr><name>time_doc</name></expr>}</block></expr>,
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_CLOCK</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"clock"</expr>, <expr><name>time_clock</name></expr>, <expr><name>METH_NOARGS</name></expr>, <expr><name>clock_doc</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr><block>{<expr>"sleep"</expr>, <expr><name>time_sleep</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>sleep_doc</name></expr>}</block></expr>,
<expr><block>{<expr>"gmtime"</expr>, <expr><name>time_gmtime</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>gmtime_doc</name></expr>}</block></expr>,
<expr><block>{<expr>"localtime"</expr>, <expr><name>time_localtime</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>localtime_doc</name></expr>}</block></expr>,
<expr><block>{<expr>"asctime"</expr>, <expr><name>time_asctime</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>asctime_doc</name></expr>}</block></expr>,
<expr><block>{<expr>"ctime"</expr>, <expr><name>time_ctime</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>ctime_doc</name></expr>}</block></expr>,
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_MKTIME</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"mktime"</expr>, <expr><name>time_mktime</name></expr>, <expr><name>METH_O</name></expr>, <expr><name>mktime_doc</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_STRFTIME</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"strftime"</expr>, <expr><name>time_strftime</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>strftime_doc</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr><block>{<expr>"strptime"</expr>, <expr><name>time_strptime</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>strptime_doc</name></expr>}</block></expr>,
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_WORKING_TZSET</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"tzset"</expr>, <expr><name>time_tzset</name></expr>, <expr><name>METH_NOARGS</name></expr>, <expr><name>tzset_doc</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr><block>{<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>}</block></expr>
}</block></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>module_doc</name></expr></argument>,
<argument><expr>"This module provides various functions to manipulate time values.\n\
\n\
There are two standard representations of time. One is the number\n\
of seconds since the Epoch, in UTC (a.k.a. GMT). It may be an integer\n\
or a floating point number (to represent fractions of seconds).\n\
The Epoch is system-defined; on Unix, it is generally January 1st, 1970.\n\
The actual value can be retrieved by calling gmtime(0).\n\
\n\
The other representation is a tuple of 9 integers giving local time.\n\
The tuple items are:\n\
year (four digits, e.g. 1998)\n\
month (1-12)\n\
day (1-31)\n\
hours (0-23)\n\
minutes (0-59)\n\
seconds (0-59)\n\
weekday (0-6, Monday is 0)\n\
Julian day (day in the year, 1-366)\n\
DST (Daylight Savings Time) flag (-1, 0 or 1)\n\
If the DST flag is 0, the time is given in the regular time zone;\n\
if it is 1, the time is given in the DST time zone;\n\
if it is -1, mktime() should guess based on the date and time.\n\
\n\
Variables:\n\
\n\
timezone -- difference in seconds between UTC and local standard time\n\
altzone -- difference in seconds between UTC and local DST time\n\
daylight -- whether local time should reflect DST\n\
tzname -- tuple of (standard time zone name, DST time zone name)\n\
\n\
Functions:\n\
\n\
time() -- return current time in seconds since the Epoch as a float\n\
clock() -- return CPU time since process start as a float\n\
sleep() -- delay for a number of seconds given as a float\n\
gmtime() -- convert seconds since Epoch to UTC tuple\n\
localtime() -- convert seconds since Epoch to local time tuple\n\
asctime() -- convert time tuple to string\n\
ctime() -- convert time in seconds to string\n\
mktime() -- convert local time tuple to seconds since Epoch\n\
strftime() -- convert time tuple to string according to format specification\n\
strptime() -- parse string to time tuple according to format specification\n\
tzset() -- change the local timezone"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><name>PyMODINIT_FUNC</name></type>
<name>inittime</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>m</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>p</name></decl>;</decl_stmt>
<expr_stmt><expr><name>m</name> = <call><name>Py_InitModule3</name><argument_list>(<argument><expr>"time"</expr></argument>, <argument><expr><name>time_methods</name></expr></argument>, <argument><expr><name>module_doc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>m</name> == <name>NULL</name></expr>)</condition><then>
<return>return;</return></then></if>
<expr_stmt><expr><name>p</name> = <call><name>Py_GETENV</name><argument_list>(<argument><expr>"PYTHONY2K"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"accept2dyear"</expr></argument>, <argument><expr><call>(<name>long</name>) <argument_list>(<argument><expr>!<name>p</name> || !*<name>p</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>moddict</name> = <call><name>PyModule_GetDict</name><argument_list>(<argument><expr><name>m</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>moddict</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>inittimezone</name><argument_list>(<argument><expr><name>m</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MS_WINDOWS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><name>main_thread</name> = <call><name>PyThread_get_thread_ident</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>hInterruptEvent</name> = <call><name>CreateEvent</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SetConsoleCtrlHandler</name><argument_list>( <argument><expr><name>PyCtrlHandler</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<if>if <condition>(<expr>!<name>initialized</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyStructSequence_InitType</name><argument_list>(<argument><expr>&amp;<name>StructTimeType</name></expr></argument>,
<argument><expr>&amp;<name>struct_time_type_desc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr>&amp;<name>StructTimeType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyModule_AddObject</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"struct_time"</expr></argument>, <argument><expr>(<name>PyObject</name>*) &amp;<name>StructTimeType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>initialized</name> = 1</expr>;</expr_stmt>
}</block></function>
<function><type><specifier>static</specifier> <name>double</name></type>
<name>floattime</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list> <block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_GETTIMEOFDAY</name></expr></argument>)</argument_list></call></expr></cpp:if>
<block>{
<decl_stmt><decl><type>struct <name>timeval</name></type> <name>t</name></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>GETTIMEOFDAY_NO_TZ</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if>if <condition>(<expr><call><name>gettimeofday</name><argument_list>(<argument><expr>&amp;<name>t</name></expr></argument>)</argument_list></call> == 0</expr>)</condition><then>
<return>return <expr>(<name>double</name>)<name><name>t</name>.<name>tv_sec</name></name> + <name><name>t</name>.<name>tv_usec</name></name>*0.000001</expr>;</return></then></if>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<if>if <condition>(<expr><call><name>gettimeofday</name><argument_list>(<argument><expr>&amp;<name>t</name></expr></argument>, <argument><expr>(struct <name>timezone</name> *)<name>NULL</name></expr></argument>)</argument_list></call> == 0</expr>)</condition><then>
<return>return <expr>(<name>double</name>)<name><name>t</name>.<name>tv_sec</name></name> + <name><name>t</name>.<name>tv_usec</name></name>*0.000001</expr>;</return></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_FTIME</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type>struct <name>timeb</name></type> <name>t</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>ftime</name><argument_list>(<argument><expr>&amp;<name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>(<name>double</name>)<name><name>t</name>.<name>time</name></name> + (<name>double</name>)<name><name>t</name>.<name>millitm</name></name> * (<name>double</name>)0.001</expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<decl_stmt><decl><type><name>time_t</name></type> <name>secs</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>time</name><argument_list>(<argument><expr>&amp;<name>secs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>(<name>double</name>)<name>secs</name></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>floatsleep</name><parameter_list>(<param><decl><type><name>double</name></type> <name>secs</name></decl></param>)</parameter_list> <block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_SELECT</name></expr></argument>)</argument_list></call> &amp;&amp; !<call><name>defined</name><argument_list>(<argument><expr><name>__BEOS__</name></expr></argument>)</argument_list></call> &amp;&amp; !<call><name>defined</name><argument_list>(<argument><expr><name>__EMX__</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type>struct <name>timeval</name></type> <name>t</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>double</name></type> <name>frac</name></decl>;</decl_stmt>
<expr_stmt><expr><name>frac</name> = <call><name>fmod</name><argument_list>(<argument><expr><name>secs</name></expr></argument>, <argument><expr>1.0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>secs</name> = <call><name>floor</name><argument_list>(<argument><expr><name>secs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>t</name>.<name>tv_sec</name></name> = (<name>long</name>)<name>secs</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>t</name>.<name>tv_usec</name></name> = <call>(<name>long</name>)<argument_list>(<argument><expr><name>frac</name>*1000000.0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<macro><name>Py_BEGIN_ALLOW_THREADS</name></macro>
<if>if <condition>(<expr><call><name>select</name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr>(<name>fd_set</name> *)0</expr></argument>, <argument><expr>(<name>fd_set</name> *)0</expr></argument>, <argument><expr>(<name>fd_set</name> *)0</expr></argument>, <argument><expr>&amp;<name>t</name></expr></argument>)</argument_list></call> != 0</expr>)</condition><then> <block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>EINTR</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if>if <condition>(<expr><name>errno</name> != <name>EINTR</name></expr>)</condition><then> <block>{
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<if>if <condition>(<expr>1</expr>)</condition><then> <block>{
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<function_decl><type><name>Py_BLOCK_THREADS</name></type>
<name>PyErr_SetFromErrno</name><parameter_list>(<param><decl><type><name>PyExc_IOError</name></type></decl></param>)</parameter_list>;</function_decl>
<return>return <expr>-1</expr>;</return>
}</block></then></if>
}</block></then></if>
<macro><name>Py_END_ALLOW_THREADS</name></macro>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__WATCOMC__</name></expr></argument>)</argument_list></call> &amp;&amp; !<call><name>defined</name><argument_list>(<argument><expr><name>__QNX__</name></expr></argument>)</argument_list></call></expr></cpp:elif>
<decl_stmt><decl><type><name>Py_BEGIN_ALLOW_THREADS</name></type>
<name>delay</name><argument_list>(<argument><expr><call>(<name>int</name>)<argument_list>(<argument><expr><name>secs</name> * 1000 + 0.5</expr></argument>)</argument_list></call></expr></argument>)</argument_list></decl>;</decl_stmt>
<macro><name>Py_END_ALLOW_THREADS</name></macro>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MS_WINDOWS</name></expr></argument>)</argument_list></call></expr></cpp:elif>
<block>{
<decl_stmt><decl><type><name>double</name></type> <name>millisecs</name> <init>= <expr><name>secs</name> * 1000.0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>ul_millis</name></decl>;</decl_stmt>
<if>if <condition>(<expr><name>millisecs</name> &gt; (<name>double</name>)<name>ULONG_MAX</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_OverflowError</name></expr></argument>,
<argument><expr>"sleep length is too large"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>-1</expr>;</return>
}</block></then></if>
<decl_stmt><decl><type><name>Py_BEGIN_ALLOW_THREADS</name></type>
<name>ul_millis</name> <init>= <expr>(<name>unsigned</name> <name>long</name>)<name>millisecs</name></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>ul_millis</name> == 0 ||
<name>main_thread</name> != <call><name>PyThread_get_thread_ident</name><argument_list>()</argument_list></call></expr>)</condition><then>
<expr_stmt><expr><call><name>Sleep</name><argument_list>(<argument><expr><name>ul_millis</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
<else>else <block>{
<decl_stmt><decl><type><name>DWORD</name></type> <name>rc</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>ResetEvent</name><argument_list>(<argument><expr><name>hInterruptEvent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>rc</name> = <call><name>WaitForSingleObject</name><argument_list>(<argument><expr><name>hInterruptEvent</name></expr></argument>, <argument><expr><name>ul_millis</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>rc</name> == <name>WAIT_OBJECT_0</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Sleep</name><argument_list>(<argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>Py_BLOCK_THREADS</name></type>
<name>errno</name> <init>= <expr><name>EINTR</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>PyErr_SetFromErrno</name><argument_list>(<argument><expr><name>PyExc_IOError</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>-1</expr>;</return>
}</block></then></if>
}</block></else></if>
<expr_stmt><expr><name>Py_END_ALLOW_THREADS</name></expr></expr_stmt>
}</block>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>PYOS_OS2</name></expr></argument>)</argument_list></call></expr></cpp:elif>
<macro><name>Py_BEGIN_ALLOW_THREADS</name></macro>
<if>if <condition>(<expr><call><name>DosSleep</name><argument_list>(<argument><expr><name>secs</name> * 1000</expr></argument>)</argument_list></call> != <name>NO_ERROR</name></expr>)</condition><then> <block>{
<function_decl><type><name>Py_BLOCK_THREADS</name></type>
<name>PyErr_SetFromErrno</name><parameter_list>(<param><decl><type><name>PyExc_IOError</name></type></decl></param>)</parameter_list>;</function_decl>
<return>return <expr>-1</expr>;</return>
}</block></then></if>
<macro><name>Py_END_ALLOW_THREADS</name></macro>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__BEOS__</name></expr></argument>)</argument_list></call></expr></cpp:elif>
<block>{
<if>if<condition>( <expr><name>secs</name> &lt;= 0.0</expr> )</condition><then> <block>{
<return>return;</return>
}</block></then></if>
<macro><name>Py_BEGIN_ALLOW_THREADS</name></macro>
<if>if<condition>( <expr><call><name>snooze</name><argument_list>( <argument><expr><call>(<name>bigtime_t</name>)<argument_list>( <argument><expr><name>secs</name> * 1000.0 * 1000.0</expr></argument> )</argument_list></call></expr></argument> )</argument_list></call> == <name>B_INTERRUPTED</name></expr> )</condition><then> <block>{
<function_decl><type><name>Py_BLOCK_THREADS</name></type>
<name>PyErr_SetFromErrno</name><parameter_list>( <param><decl><type><name>PyExc_IOError</name></type></decl></param> )</parameter_list>;</function_decl>
<return>return <expr>-1</expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>Py_END_ALLOW_THREADS</name></expr></expr_stmt>
}</block>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>RISCOS</name></expr></argument>)</argument_list></call></expr></cpp:elif>
<if>if <condition>(<expr><name>secs</name> &lt;= 0.0</expr>)</condition><then>
<return>return <expr>0</expr>;</return></then></if>
<macro><name>Py_BEGIN_ALLOW_THREADS</name></macro>
<if>if <condition>( <expr><call><name>riscos_sleep</name><argument_list>(<argument><expr><name>secs</name></expr></argument>)</argument_list></call></expr> )</condition><then>
<return>return <expr>-1</expr>;</return></then></if>
<macro><name>Py_END_ALLOW_THREADS</name></macro>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>PLAN9</name></expr></argument>)</argument_list></call></expr></cpp:elif>
<block>{
<decl_stmt><decl><type><name>double</name></type> <name>millisecs</name> <init>= <expr><name>secs</name> * 1000.0</expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>millisecs</name> &gt; (<name>double</name>)<name>LONG_MAX</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_OverflowError</name></expr></argument>, <argument><expr>"sleep length is too large"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>-1</expr>;</return>
}</block></then></if>
<macro><name>Py_BEGIN_ALLOW_THREADS</name></macro>
<if>if<condition>(<expr><call><name>sleep</name><argument_list>(<argument><expr>(<name>long</name>)<name>millisecs</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then> <block>{
<function_decl><type><name>Py_BLOCK_THREADS</name></type>
<name>PyErr_SetFromErrno</name><parameter_list>(<param><decl><type><name>PyExc_IOError</name></type></decl></param>)</parameter_list>;</function_decl>
<return>return <expr>-1</expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>Py_END_ALLOW_THREADS</name></expr></expr_stmt>
}</block>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<decl_stmt><decl><type><name>Py_BEGIN_ALLOW_THREADS</name></type>
<name>sleep</name><argument_list>(<argument><expr>(<name>int</name>)<name>secs</name></expr></argument>)</argument_list></decl>;</decl_stmt>
<macro><name>Py_END_ALLOW_THREADS</name></macro>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<return>return <expr>0</expr>;</return>
}</block></then></if></block></function>
</unit>
