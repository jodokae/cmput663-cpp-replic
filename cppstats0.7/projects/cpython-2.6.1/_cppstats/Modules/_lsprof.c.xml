<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C" filename="projects/cpython-2.6.1/_cppstats/Modules/_lsprof.c"><cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"Python.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"compile.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"frameobject.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"structseq.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"rotatingtree.h"</cpp:file></cpp:include>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>HAVE_LONG_LONG</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:error>#<cpp:directive>error</cpp:directive> "This module requires long longs!"</cpp:error>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MS_WINDOWS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;windows.h&gt;</cpp:file></cpp:include>
<function><type><specifier>static</specifier> <name>PY_LONG_LONG</name></type>
<name>hpTimer</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>LARGE_INTEGER</name></type> <name>li</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>QueryPerformanceCounter</name><argument_list>(<argument><expr>&amp;<name>li</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name><name>li</name>.<name>QuadPart</name></name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>double</name></type>
<name>hpTimerUnit</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>LARGE_INTEGER</name></type> <name>li</name></decl>;</decl_stmt>
<if>if <condition>(<expr><call><name>QueryPerformanceFrequency</name><argument_list>(<argument><expr>&amp;<name>li</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr>1.0 / <name><name>li</name>.<name>QuadPart</name></name></expr>;</return></then>
<else>else
<return>return <expr>0.000001</expr>;</return></else></if>
}</block></function>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>HAVE_GETTIMEOFDAY</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:error>#<cpp:directive>error</cpp:directive> "This module requires gettimeofday() on non-Windows platforms!"</cpp:error>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>(<call><name>defined</name><argument_list>(<argument><expr><name>PYOS_OS2</name></expr></argument>)</argument_list></call> &amp;&amp; <call><name>defined</name><argument_list>(<argument><expr><name>PYCC_GCC</name></expr></argument>)</argument_list></call>)</expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/time.h&gt;</cpp:file></cpp:include>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/resource.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/times.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<function><type><specifier>static</specifier> <name>PY_LONG_LONG</name></type>
<name>hpTimer</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type>struct <name>timeval</name></type> <name>tv</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PY_LONG_LONG</name></type> <name>ret</name></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>GETTIMEOFDAY_NO_TZ</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>gettimeofday</name><argument_list>(<argument><expr>&amp;<name>tv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<expr_stmt><expr><call><name>gettimeofday</name><argument_list>(<argument><expr>&amp;<name>tv</name></expr></argument>, <argument><expr>(struct <name>timezone</name> *)<name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><name>ret</name> = <name><name>tv</name>.<name>tv_sec</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>ret</name> = <name>ret</name> * 1000000 + <name><name>tv</name>.<name>tv_usec</name></name></expr>;</expr_stmt>
<return>return <expr><name>ret</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>double</name></type>
<name>hpTimerUnit</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list> <block>{
<return>return <expr>0.000001</expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<struct_decl>struct <name>_ProfilerEntry</name>;</struct_decl>
<typedef>typedef <type><struct>struct <name>_ProfilerSubEntry</name> <block>{
<decl_stmt><decl><type><name>rotating_node_t</name></type> <name>header</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PY_LONG_LONG</name></type> <name>tt</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PY_LONG_LONG</name></type> <name>it</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>long</name></type> <name>callcount</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>long</name></type> <name>recursivecallcount</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>long</name></type> <name>recursionLevel</name></decl>;</decl_stmt>
}</block></struct></type> <name>ProfilerSubEntry</name>;</typedef>
<typedef>typedef <type><struct>struct <name>_ProfilerEntry</name> <block>{
<decl_stmt><decl><type><name>rotating_node_t</name></type> <name>header</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>userObj</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PY_LONG_LONG</name></type> <name>tt</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PY_LONG_LONG</name></type> <name>it</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>long</name></type> <name>callcount</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>long</name></type> <name>recursivecallcount</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>long</name></type> <name>recursionLevel</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>rotating_node_t</name> *</type><name>calls</name></decl>;</decl_stmt>
}</block></struct></type> <name>ProfilerEntry</name>;</typedef>
<typedef>typedef <type><struct>struct <name>_ProfilerContext</name> <block>{
<decl_stmt><decl><type><name>PY_LONG_LONG</name></type> <name>t0</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PY_LONG_LONG</name></type> <name>subt</name></decl>;</decl_stmt>
<decl_stmt><decl><type>struct <name>_ProfilerContext</name> *</type><name>previous</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ProfilerEntry</name> *</type><name>ctxEntry</name></decl>;</decl_stmt>
}</block></struct></type> <name>ProfilerContext</name>;</typedef>
<typedef>typedef <type><struct>struct <block>{
<decl_stmt><decl><type><name>PyObject_HEAD</name>
<name>rotating_node_t</name> *</type><name>profilerEntries</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ProfilerContext</name> *</type><name>currentProfilerContext</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ProfilerContext</name> *</type><name>freelistProfilerContext</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>flags</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>externalTimer</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>double</name></type> <name>externalTimerUnit</name></decl>;</decl_stmt>
}</block></struct></type> <name>ProfilerObject</name>;</typedef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>POF_ENABLED</name></cpp:macro> <cpp:value>0x001</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>POF_SUBCALLS</name></cpp:macro> <cpp:value>0x002</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>POF_BUILTINS</name></cpp:macro> <cpp:value>0x004</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>POF_NOMEMORY</name></cpp:macro> <cpp:value>0x100</cpp:value></cpp:define>
<decl_stmt><decl><type><name>staticforward</name> <name>PyTypeObject</name></type> <name>PyProfiler_Type</name></decl>;</decl_stmt>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PyProfiler_Check</name><parameter_list>(<param><type><name>op</name></type></param>)</parameter_list></cpp:macro> <cpp:value>PyObject_TypeCheck(op, &amp;PyProfiler_Type)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PyProfiler_CheckExact</name><parameter_list>(<param><type><name>op</name></type></param>)</parameter_list></cpp:macro> <cpp:value>(Py_TYPE(op) == &amp;PyProfiler_Type)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DOUBLE_TIMER_PRECISION</name></cpp:macro> <cpp:value>4294967296.0</cpp:value></cpp:define>
<decl_stmt><decl><type><specifier>static</specifier> <name>PyObject</name> *</type><name>empty_tuple</name></decl>;</decl_stmt>
<function><type><specifier>static</specifier> <name>PY_LONG_LONG</name></type> <name>CallExternalTimer</name><parameter_list>(<param><decl><type><name>ProfilerObject</name> *</type><name>pObj</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PY_LONG_LONG</name></type> <name>result</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>o</name> <init>= <expr><call><name>PyObject_Call</name><argument_list>(<argument><expr><name><name>pObj</name>-&gt;<name>externalTimer</name></name></expr></argument>, <argument><expr><name>empty_tuple</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>o</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_WriteUnraisable</name><argument_list>(<argument><expr><name><name>pObj</name>-&gt;<name>externalTimer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>0</expr>;</return>
}</block></then></if>
<if>if <condition>(<expr><name><name>pObj</name>-&gt;<name>externalTimerUnit</name></name> &gt; 0.0</expr>)</condition><then> <block>{
<expr_stmt><expr><name>result</name> = <call><name>PyLong_AsLongLong</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<decl_stmt><decl><type><name>double</name></type> <name>val</name> <init>= <expr><call><name>PyFloat_AsDouble</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>result</name> = <call>(<name>PY_LONG_LONG</name>) <argument_list>(<argument><expr><name>val</name> * <name>DOUBLE_TIMER_PRECISION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></else></if>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_WriteUnraisable</name><argument_list>(<argument><expr><name><name>pObj</name>-&gt;<name>externalTimer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>0</expr>;</return>
}</block></then></if>
<return>return <expr><name>result</name></expr>;</return>
}</block></function>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CALL_TIMER</name><parameter_list>(<param><type><name>pObj</name></type></param>)</parameter_list></cpp:macro> <cpp:value>((pObj)-&gt;externalTimer ? CallExternalTimer(pObj) : hpTimer())</cpp:value></cpp:define>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>normalizeUserObj</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>obj</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyCFunctionObject</name> *</type><name>fn</name></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>PyCFunction_Check</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>obj</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>fn</name> = (<name>PyCFunctionObject</name> *)<name>obj</name></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>fn</name>-&gt;<name>m_self</name></name> == <name>NULL</name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>mod</name> <init>= <expr><name><name>fn</name>-&gt;<name>m_module</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>modname</name></decl>;</decl_stmt>
<if>if <condition>(<expr><name>mod</name> &amp;&amp; <call><name>PyString_Check</name><argument_list>(<argument><expr><name>mod</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><name>modname</name> = <call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>mod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else <if>if <condition>(<expr><name>mod</name> &amp;&amp; <call><name>PyModule_Check</name><argument_list>(<argument><expr><name>mod</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><name>modname</name> = <call><name>PyModule_GetName</name><argument_list>(<argument><expr><name>mod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>modname</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_Clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>modname</name> = "__builtin__"</expr>;</expr_stmt>
}</block></then></if>
}</block></then> <else>else <block>{
<expr_stmt><expr><name>modname</name> = "__builtin__"</expr>;</expr_stmt>
}</block></else></if></else></if>
<if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>modname</name></expr></argument>, <argument><expr>"__builtin__"</expr></argument>)</argument_list></call> != 0</expr>)</condition><then>
<return>return <expr><call><name>PyString_FromFormat</name><argument_list>(<argument><expr>"&lt;%s.%s&gt;"</expr></argument>,
<argument><expr><name>modname</name></expr></argument>,
<argument><expr><name><name>fn</name>-&gt;<name>m_ml</name>-&gt;<name>ml_name</name></name></expr></argument>)</argument_list></call></expr>;</return></then>
<else>else
<return>return <expr><call><name>PyString_FromFormat</name><argument_list>(<argument><expr>"&lt;%s&gt;"</expr></argument>,
<argument><expr><name><name>fn</name>-&gt;<name>m_ml</name>-&gt;<name>ml_name</name></name></expr></argument>)</argument_list></call></expr>;</return></else></if>
}</block></then> <else>else <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>self</name> <init>= <expr><name><name>fn</name>-&gt;<name>m_self</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>name</name> <init>= <expr><call><name>PyString_FromString</name><argument_list>(<argument><expr><name><name>fn</name>-&gt;<name>m_ml</name>-&gt;<name>ml_name</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>name</name> != <name>NULL</name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>mo</name> <init>= <expr><call><name>_PyType_Lookup</name><argument_list>(<argument><expr><call><name>Py_TYPE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>Py_XINCREF</name><argument_list>(<argument><expr><name>mo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>mo</name> != <name>NULL</name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>res</name> <init>= <expr><call><name>PyObject_Repr</name><argument_list>(<argument><expr><name>mo</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>mo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>res</name> != <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>res</name></expr>;</return></then></if>
}</block></then></if>
}</block></then></if>
<expr_stmt><expr><call><name>PyErr_Clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>PyString_FromFormat</name><argument_list>(<argument><expr>"&lt;built-in method %s&gt;"</expr></argument>,
<argument><expr><name><name>fn</name>-&gt;<name>m_ml</name>-&gt;<name>ml_name</name></name></expr></argument>)</argument_list></call></expr>;</return>
}</block></else></if>
}</block></function>
<function><type><specifier>static</specifier> <name>ProfilerEntry</name>*</type>
<name>newProfilerEntry</name><parameter_list>(<param><decl><type><name>ProfilerObject</name> *</type><name>pObj</name></decl></param>, <param><decl><type><name>void</name> *</type><name>key</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>userObj</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>ProfilerEntry</name> *</type><name>self</name></decl>;</decl_stmt>
<expr_stmt><expr><name>self</name> = (<name>ProfilerEntry</name>*) <call><name>malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ProfilerEntry</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>self</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>pObj</name>-&gt;<name>flags</name></name> |= <name>POF_NOMEMORY</name></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>userObj</name> = <call><name>normalizeUserObj</name><argument_list>(<argument><expr><name>userObj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>userObj</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_Clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>pObj</name>-&gt;<name>flags</name></name> |= <name>POF_NOMEMORY</name></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name><name>self</name>-&gt;<name>header</name>.<name>key</name></name> = <name>key</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>self</name>-&gt;<name>userObj</name></name> = <name>userObj</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>self</name>-&gt;<name>tt</name></name> = 0</expr>;</expr_stmt>
<expr_stmt><expr><name><name>self</name>-&gt;<name>it</name></name> = 0</expr>;</expr_stmt>
<expr_stmt><expr><name><name>self</name>-&gt;<name>callcount</name></name> = 0</expr>;</expr_stmt>
<expr_stmt><expr><name><name>self</name>-&gt;<name>recursivecallcount</name></name> = 0</expr>;</expr_stmt>
<expr_stmt><expr><name><name>self</name>-&gt;<name>recursionLevel</name></name> = 0</expr>;</expr_stmt>
<expr_stmt><expr><name><name>self</name>-&gt;<name>calls</name></name> = <name>EMPTY_ROTATING_TREE</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>RotatingTree_Add</name><argument_list>(<argument><expr>&amp;<name><name>pObj</name>-&gt;<name>profilerEntries</name></name></expr></argument>, <argument><expr>&amp;<name><name>self</name>-&gt;<name>header</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>self</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>ProfilerEntry</name>*</type>
<name>getEntry</name><parameter_list>(<param><decl><type><name>ProfilerObject</name> *</type><name>pObj</name></decl></param>, <param><decl><type><name>void</name> *</type><name>key</name></decl></param>)</parameter_list> <block>{
<return>return <expr>(<name>ProfilerEntry</name>*) <call><name>RotatingTree_Get</name><argument_list>(<argument><expr>&amp;<name><name>pObj</name>-&gt;<name>profilerEntries</name></name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>ProfilerSubEntry</name> *</type>
<name>getSubEntry</name><parameter_list>(<param><decl><type><name>ProfilerObject</name> *</type><name>pObj</name></decl></param>, <param><decl><type><name>ProfilerEntry</name> *</type><name>caller</name></decl></param>, <param><decl><type><name>ProfilerEntry</name>*</type> <name>entry</name></decl></param>)</parameter_list> <block>{
<return>return <expr>(<name>ProfilerSubEntry</name>*) <call><name>RotatingTree_Get</name><argument_list>(<argument><expr>&amp;<name><name>caller</name>-&gt;<name>calls</name></name></expr></argument>,
<argument><expr>(<name>void</name> *)<name>entry</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>ProfilerSubEntry</name> *</type>
<name>newSubEntry</name><parameter_list>(<param><decl><type><name>ProfilerObject</name> *</type><name>pObj</name></decl></param>, <param><decl><type><name>ProfilerEntry</name> *</type><name>caller</name></decl></param>, <param><decl><type><name>ProfilerEntry</name>*</type> <name>entry</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>ProfilerSubEntry</name> *</type><name>self</name></decl>;</decl_stmt>
<expr_stmt><expr><name>self</name> = (<name>ProfilerSubEntry</name>*) <call><name>malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ProfilerSubEntry</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>self</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>pObj</name>-&gt;<name>flags</name></name> |= <name>POF_NOMEMORY</name></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name><name>self</name>-&gt;<name>header</name>.<name>key</name></name> = (<name>void</name> *)<name>entry</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>self</name>-&gt;<name>tt</name></name> = 0</expr>;</expr_stmt>
<expr_stmt><expr><name><name>self</name>-&gt;<name>it</name></name> = 0</expr>;</expr_stmt>
<expr_stmt><expr><name><name>self</name>-&gt;<name>callcount</name></name> = 0</expr>;</expr_stmt>
<expr_stmt><expr><name><name>self</name>-&gt;<name>recursivecallcount</name></name> = 0</expr>;</expr_stmt>
<expr_stmt><expr><name><name>self</name>-&gt;<name>recursionLevel</name></name> = 0</expr>;</expr_stmt>
<expr_stmt><expr><call><name>RotatingTree_Add</name><argument_list>(<argument><expr>&amp;<name><name>caller</name>-&gt;<name>calls</name></name></expr></argument>, <argument><expr>&amp;<name><name>self</name>-&gt;<name>header</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>self</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>freeSubEntry</name><parameter_list>(<param><decl><type><name>rotating_node_t</name> *</type><name>header</name></decl></param>, <param><decl><type><name>void</name> *</type><name>arg</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>ProfilerSubEntry</name> *</type><name>subentry</name> <init>= <expr>(<name>ProfilerSubEntry</name>*) <name>header</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>subentry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>0</expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>freeEntry</name><parameter_list>(<param><decl><type><name>rotating_node_t</name> *</type><name>header</name></decl></param>, <param><decl><type><name>void</name> *</type><name>arg</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>ProfilerEntry</name> *</type><name>entry</name> <init>= <expr>(<name>ProfilerEntry</name>*) <name>header</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>RotatingTree_Enum</name><argument_list>(<argument><expr><name><name>entry</name>-&gt;<name>calls</name></name></expr></argument>, <argument><expr><name>freeSubEntry</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name><name>entry</name>-&gt;<name>userObj</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>0</expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>clearEntries</name><parameter_list>(<param><decl><type><name>ProfilerObject</name> *</type><name>pObj</name></decl></param>)</parameter_list> <block>{
<expr_stmt><expr><call><name>RotatingTree_Enum</name><argument_list>(<argument><expr><name><name>pObj</name>-&gt;<name>profilerEntries</name></name></expr></argument>, <argument><expr><name>freeEntry</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>pObj</name>-&gt;<name>profilerEntries</name></name> = <name>EMPTY_ROTATING_TREE</name></expr>;</expr_stmt>
<while>while <condition>(<expr><name><name>pObj</name>-&gt;<name>freelistProfilerContext</name></name></expr>)</condition> <block>{
<decl_stmt><decl><type><name>ProfilerContext</name> *</type><name>c</name> <init>= <expr><name><name>pObj</name>-&gt;<name>freelistProfilerContext</name></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>pObj</name>-&gt;<name>freelistProfilerContext</name></name> = <name><name>c</name>-&gt;<name>previous</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></while>
}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>initContext</name><parameter_list>(<param><decl><type><name>ProfilerObject</name> *</type><name>pObj</name></decl></param>, <param><decl><type><name>ProfilerContext</name> *</type><name>self</name></decl></param>, <param><decl><type><name>ProfilerEntry</name> *</type><name>entry</name></decl></param>)</parameter_list> <block>{
<expr_stmt><expr><name><name>self</name>-&gt;<name>ctxEntry</name></name> = <name>entry</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>self</name>-&gt;<name>subt</name></name> = 0</expr>;</expr_stmt>
<expr_stmt><expr><name><name>self</name>-&gt;<name>previous</name></name> = <name><name>pObj</name>-&gt;<name>currentProfilerContext</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>pObj</name>-&gt;<name>currentProfilerContext</name></name> = <name>self</name></expr>;</expr_stmt>
<expr_stmt><expr>++<name><name>entry</name>-&gt;<name>recursionLevel</name></name></expr>;</expr_stmt>
<if>if <condition>(<expr>(<name><name>pObj</name>-&gt;<name>flags</name></name> &amp; <name>POF_SUBCALLS</name>) &amp;&amp; <name><name>self</name>-&gt;<name>previous</name></name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>ProfilerEntry</name> *</type><name>caller</name> <init>= <expr><name><name>self</name>-&gt;<name>previous</name>-&gt;<name>ctxEntry</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ProfilerSubEntry</name> *</type><name>subentry</name> <init>= <expr><call><name>getSubEntry</name><argument_list>(<argument><expr><name>pObj</name></expr></argument>, <argument><expr><name>caller</name></expr></argument>, <argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>subentry</name> == <name>NULL</name></expr>)</condition><then>
<expr_stmt><expr><name>subentry</name> = <call><name>newSubEntry</name><argument_list>(<argument><expr><name>pObj</name></expr></argument>, <argument><expr><name>caller</name></expr></argument>, <argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<if>if <condition>(<expr><name>subentry</name></expr>)</condition><then>
<expr_stmt><expr>++<name><name>subentry</name>-&gt;<name>recursionLevel</name></name></expr>;</expr_stmt></then></if>
}</block></then></if>
<expr_stmt><expr><name><name>self</name>-&gt;<name>t0</name></name> = <call><name>CALL_TIMER</name><argument_list>(<argument><expr><name>pObj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>Stop</name><parameter_list>(<param><decl><type><name>ProfilerObject</name> *</type><name>pObj</name></decl></param>, <param><decl><type><name>ProfilerContext</name> *</type><name>self</name></decl></param>, <param><decl><type><name>ProfilerEntry</name> *</type><name>entry</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PY_LONG_LONG</name></type> <name>tt</name> <init>= <expr><call><name>CALL_TIMER</name><argument_list>(<argument><expr><name>pObj</name></expr></argument>)</argument_list></call> - <name><name>self</name>-&gt;<name>t0</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PY_LONG_LONG</name></type> <name>it</name> <init>= <expr><name>tt</name> - <name><name>self</name>-&gt;<name>subt</name></name></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name><name>self</name>-&gt;<name>previous</name></name></expr>)</condition><then>
<expr_stmt><expr><name><name>self</name>-&gt;<name>previous</name>-&gt;<name>subt</name></name> += <name>tt</name></expr>;</expr_stmt></then></if>
<expr_stmt><expr><name><name>pObj</name>-&gt;<name>currentProfilerContext</name></name> = <name><name>self</name>-&gt;<name>previous</name></name></expr>;</expr_stmt>
<if>if <condition>(<expr>--<name><name>entry</name>-&gt;<name>recursionLevel</name></name> == 0</expr>)</condition><then>
<expr_stmt><expr><name><name>entry</name>-&gt;<name>tt</name></name> += <name>tt</name></expr>;</expr_stmt></then>
<else>else
<expr_stmt><expr>++<name><name>entry</name>-&gt;<name>recursivecallcount</name></name></expr>;</expr_stmt></else></if>
<expr_stmt><expr><name><name>entry</name>-&gt;<name>it</name></name> += <name>it</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>entry</name>-&gt;<name>callcount</name></name>++</expr>;</expr_stmt>
<if>if <condition>(<expr>(<name><name>pObj</name>-&gt;<name>flags</name></name> &amp; <name>POF_SUBCALLS</name>) &amp;&amp; <name><name>self</name>-&gt;<name>previous</name></name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>ProfilerEntry</name> *</type><name>caller</name> <init>= <expr><name><name>self</name>-&gt;<name>previous</name>-&gt;<name>ctxEntry</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ProfilerSubEntry</name> *</type><name>subentry</name> <init>= <expr><call><name>getSubEntry</name><argument_list>(<argument><expr><name>pObj</name></expr></argument>, <argument><expr><name>caller</name></expr></argument>, <argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>subentry</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr>--<name><name>subentry</name>-&gt;<name>recursionLevel</name></name> == 0</expr>)</condition><then>
<expr_stmt><expr><name><name>subentry</name>-&gt;<name>tt</name></name> += <name>tt</name></expr>;</expr_stmt></then>
<else>else
<expr_stmt><expr>++<name><name>subentry</name>-&gt;<name>recursivecallcount</name></name></expr>;</expr_stmt></else></if>
<expr_stmt><expr><name><name>subentry</name>-&gt;<name>it</name></name> += <name>it</name></expr>;</expr_stmt>
<expr_stmt><expr>++<name><name>subentry</name>-&gt;<name>callcount</name></name></expr>;</expr_stmt>
}</block></then></if>
}</block></then></if>
}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ptrace_enter_call</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>void</name> *</type><name>key</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>userObj</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>ProfilerObject</name> *</type><name>pObj</name> <init>= <expr>(<name>ProfilerObject</name>*)<name>self</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ProfilerEntry</name> *</type><name>profEntry</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ProfilerContext</name> *</type><name>pContext</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>last_type</name></decl>, *<decl><type ref="prev"/><name>last_value</name></decl>, *<decl><type ref="prev"/><name>last_tb</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>PyErr_Fetch</name><argument_list>(<argument><expr>&amp;<name>last_type</name></expr></argument>, <argument><expr>&amp;<name>last_value</name></expr></argument>, <argument><expr>&amp;<name>last_tb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>profEntry</name> = <call><name>getEntry</name><argument_list>(<argument><expr><name>pObj</name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>profEntry</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>profEntry</name> = <call><name>newProfilerEntry</name><argument_list>(<argument><expr><name>pObj</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>userObj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>profEntry</name> == <name>NULL</name></expr>)</condition><then>
<goto>goto <name>restorePyerr</name>;</goto></then></if>
}</block></then></if>
<expr_stmt><expr><name>pContext</name> = <name><name>pObj</name>-&gt;<name>freelistProfilerContext</name></name></expr>;</expr_stmt>
<if>if <condition>(<expr><name>pContext</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>pObj</name>-&gt;<name>freelistProfilerContext</name></name> = <name><name>pContext</name>-&gt;<name>previous</name></name></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr><name>pContext</name> = (<name>ProfilerContext</name>*)
<call><name>malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ProfilerContext</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>pContext</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>pObj</name>-&gt;<name>flags</name></name> |= <name>POF_NOMEMORY</name></expr>;</expr_stmt>
<goto>goto <name>restorePyerr</name>;</goto>
}</block></then></if>
}</block></else></if>
<expr_stmt><expr><call><name>initContext</name><argument_list>(<argument><expr><name>pObj</name></expr></argument>, <argument><expr><name>pContext</name></expr></argument>, <argument><expr><name>profEntry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<label><name>restorePyerr</name>:</label>
<expr_stmt><expr><call><name>PyErr_Restore</name><argument_list>(<argument><expr><name>last_type</name></expr></argument>, <argument><expr><name>last_value</name></expr></argument>, <argument><expr><name>last_tb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ptrace_leave_call</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>void</name> *</type><name>key</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>ProfilerObject</name> *</type><name>pObj</name> <init>= <expr>(<name>ProfilerObject</name>*)<name>self</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ProfilerEntry</name> *</type><name>profEntry</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ProfilerContext</name> *</type><name>pContext</name></decl>;</decl_stmt>
<expr_stmt><expr><name>pContext</name> = <name><name>pObj</name>-&gt;<name>currentProfilerContext</name></name></expr>;</expr_stmt>
<if>if <condition>(<expr><name>pContext</name> == <name>NULL</name></expr>)</condition><then>
<return>return;</return></then></if>
<expr_stmt><expr><name>profEntry</name> = <call><name>getEntry</name><argument_list>(<argument><expr><name>pObj</name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>profEntry</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Stop</name><argument_list>(<argument><expr><name>pObj</name></expr></argument>, <argument><expr><name>pContext</name></expr></argument>, <argument><expr><name>profEntry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr><name><name>pObj</name>-&gt;<name>currentProfilerContext</name></name> = <name><name>pContext</name>-&gt;<name>previous</name></name></expr>;</expr_stmt>
}</block></else></if>
<expr_stmt><expr><name><name>pContext</name>-&gt;<name>previous</name></name> = <name><name>pObj</name>-&gt;<name>freelistProfilerContext</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>pObj</name>-&gt;<name>freelistProfilerContext</name></name> = <name>pContext</name></expr>;</expr_stmt>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>profiler_callback</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyFrameObject</name> *</type><name>frame</name></decl></param>, <param><decl><type><name>int</name></type> <name>what</name></decl></param>,
<param><decl><type><name>PyObject</name> *</type><name>arg</name></decl></param>)</parameter_list> <block>{
<switch>switch <condition>(<expr><name>what</name></expr>)</condition> <block>{
<case>case <expr><name>PyTrace_CALL</name></expr>:
<expr_stmt><expr><call><name>ptrace_enter_call</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr>(<name>void</name> *)<name><name>frame</name>-&gt;<name>f_code</name></name></expr></argument>,
<argument><expr>(<name>PyObject</name> *)<name><name>frame</name>-&gt;<name>f_code</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr><name>PyTrace_RETURN</name></expr>:
<expr_stmt><expr><call><name>ptrace_leave_call</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr>(<name>void</name> *)<name><name>frame</name>-&gt;<name>f_code</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>PyTrace_C_CALL</name></expr></argument>)</argument_list></call></expr></cpp:if>
</case><case>case <expr><name>PyTrace_C_CALL</name></expr>:
<if>if <condition>(<expr>(((<name>ProfilerObject</name> *)<name>self</name>)-&gt;<name>flags</name> &amp; <name>POF_BUILTINS</name>)
&amp;&amp; <call><name>PyCFunction_Check</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>ptrace_enter_call</name><argument_list>(<argument><expr><name>self</name></expr></argument>,
<argument><expr>((<name>PyCFunctionObject</name> *)<name>arg</name>)-&gt;<name>m_ml</name></expr></argument>,
<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<break>break;</break>
</case><case>case <expr><name>PyTrace_C_RETURN</name></expr>:
</case><case>case <expr><name>PyTrace_C_EXCEPTION</name></expr>:
<if>if <condition>(<expr>(((<name>ProfilerObject</name> *)<name>self</name>)-&gt;<name>flags</name> &amp; <name>POF_BUILTINS</name>)
&amp;&amp; <call><name>PyCFunction_Check</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>ptrace_leave_call</name><argument_list>(<argument><expr><name>self</name></expr></argument>,
<argument><expr>((<name>PyCFunctionObject</name> *)<name>arg</name>)-&gt;<name>m_ml</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</case><default>default:
<break>break;</break>
</default>}</block></switch>
<return>return <expr>0</expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>pending_exception</name><parameter_list>(<param><decl><type><name>ProfilerObject</name> *</type><name>pObj</name></decl></param>)</parameter_list> <block>{
<if>if <condition>(<expr><name><name>pObj</name>-&gt;<name>flags</name></name> &amp; <name>POF_NOMEMORY</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>pObj</name>-&gt;<name>flags</name></name> -= <name>POF_NOMEMORY</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_MemoryError</name></expr></argument>,
<argument><expr>"memory was exhausted while profiling"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>-1</expr>;</return>
}</block></then></if>
<return>return <expr>0</expr>;</return>
}</block></function>
<decl_stmt><decl><type><specifier>static</specifier> <name>PyStructSequence_Field</name></type> <name><name>profiler_entry_fields</name><index>[]</index></name> <init>= <expr><block>{
<expr><block>{<expr>"code"</expr>, <expr>"code object or built-in function name"</expr>}</block></expr>,
<expr><block>{<expr>"callcount"</expr>, <expr>"how many times this was called"</expr>}</block></expr>,
<expr><block>{<expr>"reccallcount"</expr>, <expr>"how many times called recursively"</expr>}</block></expr>,
<expr><block>{<expr>"totaltime"</expr>, <expr>"total time in this entry"</expr>}</block></expr>,
<expr><block>{<expr>"inlinetime"</expr>, <expr>"inline time in this entry (not in subcalls)"</expr>}</block></expr>,
<expr><block>{<expr>"calls"</expr>, <expr>"details of the calls"</expr>}</block></expr>,
<expr><block>{<expr>0</expr>}</block></expr>
}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>PyStructSequence_Field</name></type> <name><name>profiler_subentry_fields</name><index>[]</index></name> <init>= <expr><block>{
<expr><block>{<expr>"code"</expr>, <expr>"called code object or built-in function name"</expr>}</block></expr>,
<expr><block>{<expr>"callcount"</expr>, <expr>"how many times this is called"</expr>}</block></expr>,
<expr><block>{<expr>"reccallcount"</expr>, <expr>"how many times this is called recursively"</expr>}</block></expr>,
<expr><block>{<expr>"totaltime"</expr>, <expr>"total time spent in this call"</expr>}</block></expr>,
<expr><block>{<expr>"inlinetime"</expr>, <expr>"inline time (not in further subcalls)"</expr>}</block></expr>,
<expr><block>{<expr>0</expr>}</block></expr>
}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>PyStructSequence_Desc</name></type> <name>profiler_entry_desc</name> <init>= <expr><block>{
<expr>"_lsprof.profiler_entry"</expr>,
<expr><name>NULL</name></expr>,
<expr><name>profiler_entry_fields</name></expr>,
<expr>6</expr>
}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>PyStructSequence_Desc</name></type> <name>profiler_subentry_desc</name> <init>= <expr><block>{
<expr>"_lsprof.profiler_subentry"</expr>,
<expr><name>NULL</name></expr>,
<expr><name>profiler_subentry_fields</name></expr>,
<expr>5</expr>
}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>initialized</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>PyTypeObject</name></type> <name>StatsEntryType</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>PyTypeObject</name></type> <name>StatsSubEntryType</name></decl>;</decl_stmt>
<typedef>typedef <type><struct>struct <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>list</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>sublist</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>double</name></type> <name>factor</name></decl>;</decl_stmt>
}</block></struct></type> <name>statscollector_t</name>;</typedef>
<function><type><specifier>static</specifier> <name>int</name></type> <name>statsForSubEntry</name><parameter_list>(<param><decl><type><name>rotating_node_t</name> *</type><name>node</name></decl></param>, <param><decl><type><name>void</name> *</type><name>arg</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>ProfilerSubEntry</name> *</type><name>sentry</name> <init>= <expr>(<name>ProfilerSubEntry</name>*) <name>node</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>statscollector_t</name> *</type><name>collect</name> <init>= <expr>(<name>statscollector_t</name>*) <name>arg</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ProfilerEntry</name> *</type><name>entry</name> <init>= <expr>(<name>ProfilerEntry</name>*) <name><name>sentry</name>-&gt;<name>header</name>.<name>key</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>err</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>sinfo</name></decl>;</decl_stmt>
<expr_stmt><expr><name>sinfo</name> = <call><name>PyObject_CallFunction</name><argument_list>(<argument><expr>(<name>PyObject</name>*) &amp;<name>StatsSubEntryType</name></expr></argument>,
<argument><expr>"((Olldd))"</expr></argument>,
<argument><expr><name><name>entry</name>-&gt;<name>userObj</name></name></expr></argument>,
<argument><expr><name><name>sentry</name>-&gt;<name>callcount</name></name></expr></argument>,
<argument><expr><name><name>sentry</name>-&gt;<name>recursivecallcount</name></name></expr></argument>,
<argument><expr><name><name>collect</name>-&gt;<name>factor</name></name> * <name><name>sentry</name>-&gt;<name>tt</name></name></expr></argument>,
<argument><expr><name><name>collect</name>-&gt;<name>factor</name></name> * <name><name>sentry</name>-&gt;<name>it</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>sinfo</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr>-1</expr>;</return></then></if>
<expr_stmt><expr><name>err</name> = <call><name>PyList_Append</name><argument_list>(<argument><expr><name><name>collect</name>-&gt;<name>sublist</name></name></expr></argument>, <argument><expr><name>sinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>sinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>err</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>statsForEntry</name><parameter_list>(<param><decl><type><name>rotating_node_t</name> *</type><name>node</name></decl></param>, <param><decl><type><name>void</name> *</type><name>arg</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>ProfilerEntry</name> *</type><name>entry</name> <init>= <expr>(<name>ProfilerEntry</name>*) <name>node</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>statscollector_t</name> *</type><name>collect</name> <init>= <expr>(<name>statscollector_t</name>*) <name>arg</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>info</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>err</name></decl>;</decl_stmt>
<if>if <condition>(<expr><name><name>entry</name>-&gt;<name>callcount</name></name> == 0</expr>)</condition><then>
<return>return <expr>0</expr>;</return></then></if>
<if>if <condition>(<expr><name><name>entry</name>-&gt;<name>calls</name></name> != <name>EMPTY_ROTATING_TREE</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>collect</name>-&gt;<name>sublist</name></name> = <call><name>PyList_New</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>collect</name>-&gt;<name>sublist</name></name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr>-1</expr>;</return></then></if>
<if>if <condition>(<expr><call><name>RotatingTree_Enum</name><argument_list>(<argument><expr><name><name>entry</name>-&gt;<name>calls</name></name></expr></argument>,
<argument><expr><name>statsForSubEntry</name></expr></argument>, <argument><expr><name>collect</name></expr></argument>)</argument_list></call> != 0</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name><name>collect</name>-&gt;<name>sublist</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>-1</expr>;</return>
}</block></then></if>
}</block></then> <else>else <block>{
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>collect</name>-&gt;<name>sublist</name></name> = <name>Py_None</name></expr>;</expr_stmt>
}</block></else></if>
<expr_stmt><expr><name>info</name> = <call><name>PyObject_CallFunction</name><argument_list>(<argument><expr>(<name>PyObject</name>*) &amp;<name>StatsEntryType</name></expr></argument>,
<argument><expr>"((OllddO))"</expr></argument>,
<argument><expr><name><name>entry</name>-&gt;<name>userObj</name></name></expr></argument>,
<argument><expr><name><name>entry</name>-&gt;<name>callcount</name></name></expr></argument>,
<argument><expr><name><name>entry</name>-&gt;<name>recursivecallcount</name></name></expr></argument>,
<argument><expr><name><name>collect</name>-&gt;<name>factor</name></name> * <name><name>entry</name>-&gt;<name>tt</name></name></expr></argument>,
<argument><expr><name><name>collect</name>-&gt;<name>factor</name></name> * <name><name>entry</name>-&gt;<name>it</name></name></expr></argument>,
<argument><expr><name><name>collect</name>-&gt;<name>sublist</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name><name>collect</name>-&gt;<name>sublist</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>info</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr>-1</expr>;</return></then></if>
<expr_stmt><expr><name>err</name> = <call><name>PyList_Append</name><argument_list>(<argument><expr><name><name>collect</name>-&gt;<name>list</name></name></expr></argument>, <argument><expr><name>info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>err</name></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>getstats_doc</name></expr></argument>, <argument><expr>"\
getstats() -&gt; list of profiler_entry objects\n\
\n\
Return all information collected by the profiler.\n\
Each profiler_entry is a tuple-like object with the\n\
following attributes:\n\
\n\
code code object\n\
callcount how many times this was called\n\
reccallcount how many times called recursively\n\
totaltime total time in this entry\n\
inlinetime inline time in this entry (not in subcalls)\n\
calls details of the calls\n\
\n\
The calls attribute is either None or a list of\n\
profiler_subentry objects:\n\
\n\
code called code object\n\
callcount how many times this is called\n\
reccallcount how many times this is called recursively\n\
totaltime total time spent in this call\n\
inlinetime inline time (not in further subcalls)\n\
"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name>*</type>
<name>profiler_getstats</name><parameter_list>(<param><decl><type><name>ProfilerObject</name> *</type><name>pObj</name></decl></param>, <param><decl><type><name>PyObject</name>*</type> <name>noarg</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>statscollector_t</name></type> <name>collect</name></decl>;</decl_stmt>
<if>if <condition>(<expr><call><name>pending_exception</name><argument_list>(<argument><expr><name>pObj</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<if>if <condition>(<expr>!<name><name>pObj</name>-&gt;<name>externalTimer</name></name></expr>)</condition><then>
<expr_stmt><expr><name><name>collect</name>.<name>factor</name></name> = <call><name>hpTimerUnit</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then>
<else>else <if>if <condition>(<expr><name><name>pObj</name>-&gt;<name>externalTimerUnit</name></name> &gt; 0.0</expr>)</condition><then>
<expr_stmt><expr><name><name>collect</name>.<name>factor</name></name> = <name><name>pObj</name>-&gt;<name>externalTimerUnit</name></name></expr>;</expr_stmt></then>
<else>else
<expr_stmt><expr><name><name>collect</name>.<name>factor</name></name> = 1.0 / <name>DOUBLE_TIMER_PRECISION</name></expr>;</expr_stmt></else></if></else></if>
<expr_stmt><expr><name><name>collect</name>.<name>list</name></name> = <call><name>PyList_New</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>collect</name>.<name>list</name></name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<if>if <condition>(<expr><call><name>RotatingTree_Enum</name><argument_list>(<argument><expr><name><name>pObj</name>-&gt;<name>profilerEntries</name></name></expr></argument>, <argument><expr><name>statsForEntry</name></expr></argument>, <argument><expr>&amp;<name>collect</name></expr></argument>)</argument_list></call>
!= 0</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name><name>collect</name>.<name>list</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<return>return <expr><name><name>collect</name>.<name>list</name></name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>setSubcalls</name><parameter_list>(<param><decl><type><name>ProfilerObject</name> *</type><name>pObj</name></decl></param>, <param><decl><type><name>int</name></type> <name>nvalue</name></decl></param>)</parameter_list> <block>{
<if>if <condition>(<expr><name>nvalue</name> == 0</expr>)</condition><then>
<expr_stmt><expr><name><name>pObj</name>-&gt;<name>flags</name></name> &amp;= ~<name>POF_SUBCALLS</name></expr>;</expr_stmt></then>
<else>else <if>if <condition>(<expr><name>nvalue</name> &gt; 0</expr>)</condition><then>
<expr_stmt><expr><name><name>pObj</name>-&gt;<name>flags</name></name> |= <name>POF_SUBCALLS</name></expr>;</expr_stmt></then></if></else></if>
<return>return <expr>0</expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>setBuiltins</name><parameter_list>(<param><decl><type><name>ProfilerObject</name> *</type><name>pObj</name></decl></param>, <param><decl><type><name>int</name></type> <name>nvalue</name></decl></param>)</parameter_list> <block>{
<if>if <condition>(<expr><name>nvalue</name> == 0</expr>)</condition><then>
<expr_stmt><expr><name><name>pObj</name>-&gt;<name>flags</name></name> &amp;= ~<name>POF_BUILTINS</name></expr>;</expr_stmt></then>
<else>else <if>if <condition>(<expr><name>nvalue</name> &gt; 0</expr>)</condition><then> <block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>PyTrace_C_CALL</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>,
<argument><expr>"builtins=True requires Python &gt;= 2.4"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>-1</expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<expr_stmt><expr><name><name>pObj</name>-&gt;<name>flags</name></name> |= <name>POF_BUILTINS</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></then></if></else></if>
<return>return <expr>0</expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>enable_doc</name></expr></argument>, <argument><expr>"\
enable(subcalls=True, builtins=True)\n\
\n\
Start collecting profiling information.\n\
If 'subcalls' is True, also records for each function\n\
statistics separated according to its current caller.\n\
If 'builtins' is True, records the time spent in\n\
built-in functions separately from their caller.\n\
"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name>*</type>
<name>profiler_enable</name><parameter_list>(<param><decl><type><name>ProfilerObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>kwds</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>subcalls</name> <init>= <expr>-1</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>builtins</name> <init>= <expr>-1</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> *</type><name><name>kwlist</name><index>[]</index></name> <init>= <expr><block>{<expr>"subcalls"</expr>, <expr>"builtins"</expr>, <expr>0</expr>}</block></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTupleAndKeywords</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>kwds</name></expr></argument>, <argument><expr>"|ii:enable"</expr></argument>,
<argument><expr><name>kwlist</name></expr></argument>, <argument><expr>&amp;<name>subcalls</name></expr></argument>, <argument><expr>&amp;<name>builtins</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<if>if <condition>(<expr><call><name>setSubcalls</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>subcalls</name></expr></argument>)</argument_list></call> &lt; 0 || <call><name>setBuiltins</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>builtins</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><call><name>PyEval_SetProfile</name><argument_list>(<argument><expr><name>profiler_callback</name></expr></argument>, <argument><expr>(<name>PyObject</name>*)<name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>self</name>-&gt;<name>flags</name></name> |= <name>POF_ENABLED</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>Py_None</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>flush_unmatched</name><parameter_list>(<param><decl><type><name>ProfilerObject</name> *</type><name>pObj</name></decl></param>)</parameter_list> <block>{
<while>while <condition>(<expr><name><name>pObj</name>-&gt;<name>currentProfilerContext</name></name></expr>)</condition> <block>{
<decl_stmt><decl><type><name>ProfilerContext</name> *</type><name>pContext</name> <init>= <expr><name><name>pObj</name>-&gt;<name>currentProfilerContext</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ProfilerEntry</name> *</type><name>profEntry</name><init>= <expr><name><name>pContext</name>-&gt;<name>ctxEntry</name></name></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>profEntry</name></expr>)</condition><then>
<expr_stmt><expr><call><name>Stop</name><argument_list>(<argument><expr><name>pObj</name></expr></argument>, <argument><expr><name>pContext</name></expr></argument>, <argument><expr><name>profEntry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
<else>else
<expr_stmt><expr><name><name>pObj</name>-&gt;<name>currentProfilerContext</name></name> = <name><name>pContext</name>-&gt;<name>previous</name></name></expr>;</expr_stmt></else></if>
<if>if <condition>(<expr><name>pContext</name></expr>)</condition><then>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>pContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
}</block></while>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>disable_doc</name></expr></argument>, <argument><expr>"\
disable()\n\
\n\
Stop collecting profiling information.\n\
"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name>*</type>
<name>profiler_disable</name><parameter_list>(<param><decl><type><name>ProfilerObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name>*</type> <name>noarg</name></decl></param>)</parameter_list> <block>{
<expr_stmt><expr><name><name>self</name>-&gt;<name>flags</name></name> &amp;= ~<name>POF_ENABLED</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyEval_SetProfile</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>flush_unmatched</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>pending_exception</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>Py_None</name></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>clear_doc</name></expr></argument>, <argument><expr>"\
clear()\n\
\n\
Clear all profiling information collected so far.\n\
"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name>*</type>
<name>profiler_clear</name><parameter_list>(<param><decl><type><name>ProfilerObject</name> *</type><name>pObj</name></decl></param>, <param><decl><type><name>PyObject</name>*</type> <name>noarg</name></decl></param>)</parameter_list> <block>{
<expr_stmt><expr><call><name>clearEntries</name><argument_list>(<argument><expr><name>pObj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>Py_None</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>profiler_dealloc</name><parameter_list>(<param><decl><type><name>ProfilerObject</name> *</type><name>op</name></decl></param>)</parameter_list> <block>{
<if>if <condition>(<expr><name><name>op</name>-&gt;<name>flags</name></name> &amp; <name>POF_ENABLED</name></expr>)</condition><then>
<expr_stmt><expr><call><name>PyEval_SetProfile</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<expr_stmt><expr><call><name>flush_unmatched</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>clearEntries</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name><name>op</name>-&gt;<name>externalTimer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_TYPE</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call>-&gt;<call><name>tp_free</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>profiler_init</name><parameter_list>(<param><decl><type><name>ProfilerObject</name> *</type><name>pObj</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>kw</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>o</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>timer</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>double</name></type> <name>timeunit</name> <init>= <expr>0.0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>subcalls</name> <init>= <expr>1</expr></init></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>PyTrace_C_CALL</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>int</name></type> <name>builtins</name> <init>= <expr>1</expr></init></decl>;</decl_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<decl_stmt><decl><type><name>int</name></type> <name>builtins</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> *</type><name><name>kwlist</name><index>[]</index></name> <init>= <expr><block>{<expr>"timer"</expr>, <expr>"timeunit"</expr>,
<expr>"subcalls"</expr>, <expr>"builtins"</expr>, <expr>0</expr>
}</block></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTupleAndKeywords</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>kw</name></expr></argument>, <argument><expr>"|Odii:Profiler"</expr></argument>, <argument><expr><name>kwlist</name></expr></argument>,
<argument><expr>&amp;<name>timer</name></expr></argument>, <argument><expr>&amp;<name>timeunit</name></expr></argument>,
<argument><expr>&amp;<name>subcalls</name></expr></argument>, <argument><expr>&amp;<name>builtins</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr>-1</expr>;</return></then></if>
<if>if <condition>(<expr><call><name>setSubcalls</name><argument_list>(<argument><expr><name>pObj</name></expr></argument>, <argument><expr><name>subcalls</name></expr></argument>)</argument_list></call> &lt; 0 || <call><name>setBuiltins</name><argument_list>(<argument><expr><name>pObj</name></expr></argument>, <argument><expr><name>builtins</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
<return>return <expr>-1</expr>;</return></then></if>
<expr_stmt><expr><name>o</name> = <name><name>pObj</name>-&gt;<name>externalTimer</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>pObj</name>-&gt;<name>externalTimer</name></name> = <name>timer</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_XINCREF</name><argument_list>(<argument><expr><name>timer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>pObj</name>-&gt;<name>externalTimerUnit</name></name> = <name>timeunit</name></expr>;</expr_stmt>
<return>return <expr>0</expr>;</return>
}</block></function>
<decl_stmt><decl><type><specifier>static</specifier> <name>PyMethodDef</name></type> <name><name>profiler_methods</name><index>[]</index></name> <init>= <expr><block>{
<expr><block>{
<expr>"getstats"</expr>, <expr>(<name>PyCFunction</name>)<name>profiler_getstats</name></expr>,
<expr><name>METH_NOARGS</name></expr>, <expr><name>getstats_doc</name></expr>
}</block></expr>,
<expr><block>{
<expr>"enable"</expr>, <expr>(<name>PyCFunction</name>)<name>profiler_enable</name></expr>,
<expr><name>METH_VARARGS</name> | <name>METH_KEYWORDS</name></expr>, <expr><name>enable_doc</name></expr>
}</block></expr>,
<expr><block>{
<expr>"disable"</expr>, <expr>(<name>PyCFunction</name>)<name>profiler_disable</name></expr>,
<expr><name>METH_NOARGS</name></expr>, <expr><name>disable_doc</name></expr>
}</block></expr>,
<expr><block>{
<expr>"clear"</expr>, <expr>(<name>PyCFunction</name>)<name>profiler_clear</name></expr>,
<expr><name>METH_NOARGS</name></expr>, <expr><name>clear_doc</name></expr>
}</block></expr>,
<expr><block>{<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>}</block></expr>
}</block></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>profiler_doc</name></expr></argument>, <argument><expr>"\
Profiler(custom_timer=None, time_unit=None, subcalls=True, builtins=True)\n\
\n\
Builds a profiler object using the specified timer function.\n\
The default timer is a fast built-in one based on real time.\n\
For custom timer functions returning integers, time_unit can\n\
be a float specifying a scale (i.e. how long each integer unit\n\
is, in seconds).\n\
"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>statichere</name> <name>PyTypeObject</name></type> <name>PyProfiler_Type</name> <init>= <expr><block>{
<expr><call><name>PyObject_HEAD_INIT</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call>
0</expr>,
<expr>"_lsprof.Profiler"</expr>,
<expr><sizeof>sizeof<argument_list>(<argument><expr><name>ProfilerObject</name></expr></argument>)</argument_list></sizeof></expr>,
<expr>0</expr>,
<expr>(<name>destructor</name>)<name>profiler_dealloc</name></expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr><name>Py_TPFLAGS_DEFAULT</name> | <name>Py_TPFLAGS_BASETYPE</name></expr>,
<expr><name>profiler_doc</name></expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr><name>profiler_methods</name></expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>(<name>initproc</name>)<name>profiler_init</name></expr>,
<expr><name>PyType_GenericAlloc</name></expr>,
<expr><name>PyType_GenericNew</name></expr>,
<expr><name>PyObject_Del</name></expr>,
}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>PyMethodDef</name></type> <name><name>moduleMethods</name><index>[]</index></name> <init>= <expr><block>{
<expr><block>{<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>}</block></expr>
}</block></expr></init></decl>;</decl_stmt>
<function><type><name>PyMODINIT_FUNC</name></type>
<name>init_lsprof</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>module</name></decl>, *<decl><type ref="prev"/><name>d</name></decl>;</decl_stmt>
<expr_stmt><expr><name>module</name> = <call><name>Py_InitModule3</name><argument_list>(<argument><expr>"_lsprof"</expr></argument>, <argument><expr><name>moduleMethods</name></expr></argument>, <argument><expr>"Fast profiler"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>module</name> == <name>NULL</name></expr>)</condition><then>
<return>return;</return></then></if>
<expr_stmt><expr><name>d</name> = <call><name>PyModule_GetDict</name><argument_list>(<argument><expr><name>module</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>PyType_Ready</name><argument_list>(<argument><expr>&amp;<name>PyProfiler_Type</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
<return>return;</return></then></if>
<expr_stmt><expr><call><name>PyDict_SetItemString</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr>"Profiler"</expr></argument>, <argument><expr>(<name>PyObject</name> *)&amp;<name>PyProfiler_Type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>initialized</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyStructSequence_InitType</name><argument_list>(<argument><expr>&amp;<name>StatsEntryType</name></expr></argument>,
<argument><expr>&amp;<name>profiler_entry_desc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyStructSequence_InitType</name><argument_list>(<argument><expr>&amp;<name>StatsSubEntryType</name></expr></argument>,
<argument><expr>&amp;<name>profiler_subentry_desc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr>(<name>PyObject</name>*) &amp;<name>StatsEntryType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr>(<name>PyObject</name>*) &amp;<name>StatsSubEntryType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyModule_AddObject</name><argument_list>(<argument><expr><name>module</name></expr></argument>, <argument><expr>"profiler_entry"</expr></argument>,
<argument><expr>(<name>PyObject</name>*) &amp;<name>StatsEntryType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyModule_AddObject</name><argument_list>(<argument><expr><name>module</name></expr></argument>, <argument><expr>"profiler_subentry"</expr></argument>,
<argument><expr>(<name>PyObject</name>*) &amp;<name>StatsSubEntryType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>empty_tuple</name> = <call><name>PyTuple_New</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>initialized</name> = 1</expr>;</expr_stmt>
}</block></function>
</unit>
