<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C" filename="projects/cpython-2.6.1/_cppstats/Modules/bz2module.c"><cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"Python.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdio.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;bzlib.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"structmember.h"</cpp:file></cpp:include>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>WITH_THREAD</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pythread.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name><name>__author__</name><index>[]</index></name> <init>=
<expr>"The bz2 python module was written by:\n\
\n\
Gustavo Niemeyer &lt;niemeyer@conectiva.com&gt;\n\
"</expr></init></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>HAVE_LARGEFILE_SUPPORT</name></expr></argument>)</argument_list></call></expr></cpp:if>
<typedef>typedef <type><name>off_t</name></type> <name>Py_off_t</name>;</typedef>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>SIZEOF_OFF_T</name> &gt;= 8</expr></cpp:elif>
<typedef>typedef <type><name>off_t</name></type> <name>Py_off_t</name>;</typedef>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>SIZEOF_FPOS_T</name> &gt;= 8</expr></cpp:elif>
<typedef>typedef <type><name>fpos_t</name></type> <name>Py_off_t</name>;</typedef>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:error>#<cpp:directive>error</cpp:directive> "Large file support, but neither off_t nor fpos_t is large enough."</cpp:error>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BUF</name><parameter_list>(<param><type><name>v</name></type></param>)</parameter_list></cpp:macro> <cpp:value>PyString_AS_STRING((PyStringObject *)v)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MODE_CLOSED</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MODE_READ</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MODE_READ_EOF</name></cpp:macro> <cpp:value>2</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MODE_WRITE</name></cpp:macro> <cpp:value>3</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BZ2FileObject_Check</name><parameter_list>(<param><type><name>v</name></type></param>)</parameter_list></cpp:macro> <cpp:value>(Py_TYPE(v) == &amp;BZ2File_Type)</cpp:value></cpp:define>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>BZ_CONFIG_ERROR</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SIZEOF_LONG</name> &gt;= 8</expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BZS_TOTAL_OUT</name><parameter_list>(<param><type><name>bzs</name></type></param>)</parameter_list></cpp:macro> <cpp:value>(((long)bzs-&gt;total_out_hi32 &lt;&lt; 32) + bzs-&gt;total_out_lo32)</cpp:value></cpp:define>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>SIZEOF_LONG_LONG</name> &gt;= 8</expr></cpp:elif>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BZS_TOTAL_OUT</name><parameter_list>(<param><type><name>bzs</name></type></param>)</parameter_list></cpp:macro> <cpp:value>(((PY_LONG_LONG)bzs-&gt;total_out_hi32 &lt;&lt; 32) + bzs-&gt;total_out_lo32)</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BZS_TOTAL_OUT</name><parameter_list>(<param><type><name>bzs</name></type></param>)</parameter_list></cpp:macro> <cpp:value>bzs-&gt;total_out_lo32</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BZ2_bzRead</name></cpp:macro> <cpp:value>bzRead</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BZ2_bzReadOpen</name></cpp:macro> <cpp:value>bzReadOpen</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BZ2_bzReadClose</name></cpp:macro> <cpp:value>bzReadClose</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BZ2_bzWrite</name></cpp:macro> <cpp:value>bzWrite</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BZ2_bzWriteOpen</name></cpp:macro> <cpp:value>bzWriteOpen</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BZ2_bzWriteClose</name></cpp:macro> <cpp:value>bzWriteClose</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BZ2_bzCompress</name></cpp:macro> <cpp:value>bzCompress</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BZ2_bzCompressInit</name></cpp:macro> <cpp:value>bzCompressInit</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BZ2_bzCompressEnd</name></cpp:macro> <cpp:value>bzCompressEnd</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BZ2_bzDecompress</name></cpp:macro> <cpp:value>bzDecompress</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BZ2_bzDecompressInit</name></cpp:macro> <cpp:value>bzDecompressInit</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BZ2_bzDecompressEnd</name></cpp:macro> <cpp:value>bzDecompressEnd</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BZS_TOTAL_OUT</name><parameter_list>(<param><type><name>bzs</name></type></param>)</parameter_list></cpp:macro> <cpp:value>bzs-&gt;total_out</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>WITH_THREAD</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ACQUIRE_LOCK</name><parameter_list>(<param><type><name>obj</name></type></param>)</parameter_list></cpp:macro> <cpp:value>PyThread_acquire_lock(obj-&gt;lock, 1)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RELEASE_LOCK</name><parameter_list>(<param><type><name>obj</name></type></param>)</parameter_list></cpp:macro> <cpp:value>PyThread_release_lock(obj-&gt;lock)</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ACQUIRE_LOCK</name><parameter_list>(<param><type><name>obj</name></type></param>)</parameter_list></cpp:macro></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RELEASE_LOCK</name><parameter_list>(<param><type><name>obj</name></type></param>)</parameter_list></cpp:macro></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NEWLINE_UNKNOWN</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NEWLINE_CR</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NEWLINE_LF</name></cpp:macro> <cpp:value>2</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NEWLINE_CRLF</name></cpp:macro> <cpp:value>4</cpp:value></cpp:define>
<typedef>typedef <type><struct>struct <block>{
<decl_stmt><decl><type><name>PyObject_HEAD</name>
<name>PyObject</name> *</type><name>file</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name>*</type> <name>f_buf</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name>*</type> <name>f_bufend</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name>*</type> <name>f_bufptr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>f_softspace</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>f_univ_newline</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>f_newlinetypes</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>f_skipnextlf</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BZFILE</name> *</type><name>fp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>mode</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_off_t</name></type> <name>pos</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_off_t</name></type> <name>size</name></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>WITH_THREAD</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>PyThread_type_lock</name></type> <name>lock</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></struct></type> <name>BZ2FileObject</name>;</typedef>
<typedef>typedef <type><struct>struct <block>{
<decl_stmt><decl><type><name>PyObject_HEAD</name>
<name>bz_stream</name></type> <name>bzs</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>running</name></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>WITH_THREAD</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>PyThread_type_lock</name></type> <name>lock</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></struct></type> <name>BZ2CompObject</name>;</typedef>
<typedef>typedef <type><struct>struct <block>{
<decl_stmt><decl><type><name>PyObject_HEAD</name>
<name>bz_stream</name></type> <name>bzs</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>running</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>unused_data</name></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>WITH_THREAD</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>PyThread_type_lock</name></type> <name>lock</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></struct></type> <name>BZ2DecompObject</name>;</typedef>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>Util_CatchBZ2Error</name><parameter_list>(<param><decl><type><name>int</name></type> <name>bzerror</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>ret</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<switch>switch<condition>(<expr><name>bzerror</name></expr>)</condition> <block>{
<case>case <expr><name>BZ_OK</name></expr>:
</case><case>case <expr><name>BZ_STREAM_END</name></expr>:
<break>break;</break>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>BZ_CONFIG_ERROR</name></expr></argument>)</argument_list></call></expr></cpp:if>
</case><case>case <expr><name>BZ_CONFIG_ERROR</name></expr>:
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_SystemError</name></expr></argument>,
<argument><expr>"the bz2 library was not compiled "
"correctly"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ret</name> = 1</expr>;</expr_stmt>
<break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</case><case>case <expr><name>BZ_PARAM_ERROR</name></expr>:
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>,
<argument><expr>"the bz2 library has received wrong "
"parameters"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ret</name> = 1</expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr><name>BZ_MEM_ERROR</name></expr>:
<expr_stmt><expr><call><name>PyErr_NoMemory</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ret</name> = 1</expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr><name>BZ_DATA_ERROR</name></expr>:
</case><case>case <expr><name>BZ_DATA_ERROR_MAGIC</name></expr>:
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_IOError</name></expr></argument>, <argument><expr>"invalid data stream"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ret</name> = 1</expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr><name>BZ_IO_ERROR</name></expr>:
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_IOError</name></expr></argument>, <argument><expr>"unknown IO error"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ret</name> = 1</expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr><name>BZ_UNEXPECTED_EOF</name></expr>:
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_EOFError</name></expr></argument>,
<argument><expr>"compressed file ended before the "
"logical end-of-stream was detected"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ret</name> = 1</expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr><name>BZ_SEQUENCE_ERROR</name></expr>:
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_RuntimeError</name></expr></argument>,
<argument><expr>"wrong sequence of bz2 library "
"commands used"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ret</name> = 1</expr>;</expr_stmt>
<break>break;</break>
</case>}</block></switch>
<return>return <expr><name>ret</name></expr>;</return>
}</block></function>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>BUFSIZ</name> &lt; 8192</expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SMALLCHUNK</name></cpp:macro> <cpp:value>8192</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SMALLCHUNK</name></cpp:macro> <cpp:value>BUFSIZ</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SIZEOF_INT</name> &lt; 4</expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BIGCHUNK</name></cpp:macro> <cpp:value>(512 * 32)</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BIGCHUNK</name></cpp:macro> <cpp:value>(512 * 1024)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<function><type><specifier>static</specifier> <name>size_t</name></type>
<name>Util_NewBufferSize</name><parameter_list>(<param><decl><type><name>size_t</name></type> <name>currentsize</name></decl></param>)</parameter_list> <block>{
<if>if <condition>(<expr><name>currentsize</name> &gt; <name>SMALLCHUNK</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr><name>currentsize</name> &lt;= <name>BIGCHUNK</name></expr>)</condition><then>
<return>return <expr><name>currentsize</name> + <name>currentsize</name></expr>;</return></then>
<else>else
<return>return <expr><name>currentsize</name> + <name>BIGCHUNK</name></expr>;</return></else></if>
}</block></then></if>
<return>return <expr><name>currentsize</name> + <name>SMALLCHUNK</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>Util_GetLine</name><parameter_list>(<param><decl><type><name>BZ2FileObject</name> *</type><name>f</name></decl></param>, <param><decl><type><name>int</name></type> <name>n</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>char</name></type> <name>c</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>buf</name></decl>, *<decl><type ref="prev"/><name>end</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>total_v_size</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>used_v_size</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>increment</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>v</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>bzerror</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>bytes_read</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>newlinetypes</name> <init>= <expr><name><name>f</name>-&gt;<name>f_newlinetypes</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>skipnextlf</name> <init>= <expr><name><name>f</name>-&gt;<name>f_skipnextlf</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>univ_newline</name> <init>= <expr><name><name>f</name>-&gt;<name>f_univ_newline</name></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>total_v_size</name> = <name>n</name> &gt; 0 ? <name>n</name> : 100</expr>;</expr_stmt>
<expr_stmt><expr><name>v</name> = <call><name>PyString_FromStringAndSize</name><argument_list>(<argument><expr>(<name>char</name> *)<name>NULL</name></expr></argument>, <argument><expr><name>total_v_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>v</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>buf</name> = <call><name>BUF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>end</name> = <name>buf</name> + <name>total_v_size</name></expr>;</expr_stmt>
<for>for (<init>;</init><condition>;</condition><incr/>) <block>{
<macro><name>Py_BEGIN_ALLOW_THREADS</name></macro>
<while>while <condition>(<expr><name>buf</name> != <name>end</name></expr>)</condition> <block>{
<expr_stmt><expr><name>bytes_read</name> = <call><name>BZ2_bzRead</name><argument_list>(<argument><expr>&amp;<name>bzerror</name></expr></argument>, <argument><expr><name><name>f</name>-&gt;<name>fp</name></name></expr></argument>, <argument><expr>&amp;<name>c</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>f</name>-&gt;<name>pos</name></name>++</expr>;</expr_stmt>
<if>if <condition>(<expr><name>bytes_read</name> == 0</expr>)</condition><then> <break>break;</break></then></if>
<if>if <condition>(<expr><name>univ_newline</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr><name>skipnextlf</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>skipnextlf</name> = 0</expr>;</expr_stmt>
<if>if <condition>(<expr><name>c</name> == '\n'</expr>)</condition><then> <block>{
<expr_stmt><expr><name>newlinetypes</name> |= <name>NEWLINE_CRLF</name></expr>;</expr_stmt>
<if>if <condition>(<expr><name>bzerror</name> != <name>BZ_OK</name></expr>)</condition><then> <break>break;</break></then></if>
<expr_stmt><expr><name>bytes_read</name> = <call><name>BZ2_bzRead</name><argument_list>(<argument><expr>&amp;<name>bzerror</name></expr></argument>, <argument><expr><name><name>f</name>-&gt;<name>fp</name></name></expr></argument>, <argument><expr>&amp;<name>c</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>f</name>-&gt;<name>pos</name></name>++</expr>;</expr_stmt>
<if>if <condition>(<expr><name>bytes_read</name> == 0</expr>)</condition><then> <break>break;</break></then></if>
}</block></then> <else>else <block>{
<expr_stmt><expr><name>newlinetypes</name> |= <name>NEWLINE_CR</name></expr>;</expr_stmt>
}</block></else></if>
}</block></then></if>
<if>if <condition>(<expr><name>c</name> == '\r'</expr>)</condition><then> <block>{
<expr_stmt><expr><name>skipnextlf</name> = 1</expr>;</expr_stmt>
<expr_stmt><expr><name>c</name> = '\n'</expr>;</expr_stmt>
}</block></then> <else>else <if>if <condition>(<expr><name>c</name> == '\n'</expr>)</condition><then>
<expr_stmt><expr><name>newlinetypes</name> |= <name>NEWLINE_LF</name></expr>;</expr_stmt></then></if></else></if>
}</block></then></if>
<expr_stmt><expr>*<name>buf</name>++ = <name>c</name></expr>;</expr_stmt>
<if>if <condition>(<expr><name>bzerror</name> != <name>BZ_OK</name> || <name>c</name> == '\n'</expr>)</condition><then> <break>break;</break></then></if>
}</block></while>
<if>if <condition>(<expr><name>univ_newline</name> &amp;&amp; <name>bzerror</name> == <name>BZ_STREAM_END</name> &amp;&amp; <name>skipnextlf</name></expr>)</condition><then>
<expr_stmt><expr><name>newlinetypes</name> |= <name>NEWLINE_CR</name></expr>;</expr_stmt></then></if>
<decl_stmt><decl><type><name>Py_END_ALLOW_THREADS</name></type>
<name><name>f</name>-&gt;<name>f_newlinetypes</name></name> <init>= <expr><name>newlinetypes</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>f</name>-&gt;<name>f_skipnextlf</name></name> = <name>skipnextlf</name></expr>;</expr_stmt>
<if>if <condition>(<expr><name>bzerror</name> == <name>BZ_STREAM_END</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>f</name>-&gt;<name>size</name></name> = <name><name>f</name>-&gt;<name>pos</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>f</name>-&gt;<name>mode</name></name> = <name>MODE_READ_EOF</name></expr>;</expr_stmt>
<break>break;</break>
}</block></then> <else>else <if>if <condition>(<expr><name>bzerror</name> != <name>BZ_OK</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Util_CatchBZ2Error</name><argument_list>(<argument><expr><name>bzerror</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if></else></if>
<if>if <condition>(<expr><name>c</name> == '\n'</expr>)</condition><then>
<break>break;</break></then></if>
<if>if <condition>(<expr><name>n</name> &gt; 0</expr>)</condition><then>
<break>break;</break></then></if>
<expr_stmt><expr><name>used_v_size</name> = <name>total_v_size</name></expr>;</expr_stmt>
<expr_stmt><expr><name>increment</name> = <name>total_v_size</name> &gt;&gt; 2</expr>;</expr_stmt>
<expr_stmt><expr><name>total_v_size</name> += <name>increment</name></expr>;</expr_stmt>
<if>if <condition>(<expr><name>total_v_size</name> &gt; <name>INT_MAX</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_OverflowError</name></expr></argument>,
<argument><expr>"line is longer than a Python string can hold"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<if>if <condition>(<expr><call><name>_PyString_Resize</name><argument_list>(<argument><expr>&amp;<name>v</name></expr></argument>, <argument><expr><name>total_v_size</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>buf</name> = <call><name>BUF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call> + <name>used_v_size</name></expr>;</expr_stmt>
<expr_stmt><expr><name>end</name> = <call><name>BUF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call> + <name>total_v_size</name></expr>;</expr_stmt>
}</block></for>
<expr_stmt><expr><name>used_v_size</name> = <name>buf</name> - <call><name>BUF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>used_v_size</name> != <name>total_v_size</name></expr>)</condition><then>
<expr_stmt><expr><call><name>_PyString_Resize</name><argument_list>(<argument><expr>&amp;<name>v</name></expr></argument>, <argument><expr><name>used_v_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<return>return <expr><name>v</name></expr>;</return>
}</block></function>
<function><type><name>size_t</name></type>
<name>Util_UnivNewlineRead</name><parameter_list>(<param><decl><type><name>int</name> *</type><name>bzerror</name></decl></param>, <param><decl><type><name>BZFILE</name> *</type><name>stream</name></decl></param>,
<param><decl><type><name>char</name>*</type> <name>buf</name></decl></param>, <param><decl><type><name>size_t</name></type> <name>n</name></decl></param>, <param><decl><type><name>BZ2FileObject</name> *</type><name>f</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>char</name> *</type><name>dst</name> <init>= <expr><name>buf</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>newlinetypes</name></decl>, <decl><type ref="prev"/><name>skipnextlf</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>buf</name> != <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>stream</name> != <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name><name>f</name>-&gt;<name>f_univ_newline</name></name></expr>)</condition><then>
<return>return <expr><call><name>BZ2_bzRead</name><argument_list>(<argument><expr><name>bzerror</name></expr></argument>, <argument><expr><name>stream</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
<expr_stmt><expr><name>newlinetypes</name> = <name><name>f</name>-&gt;<name>f_newlinetypes</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>skipnextlf</name> = <name><name>f</name>-&gt;<name>f_skipnextlf</name></name></expr>;</expr_stmt>
<while>while <condition>(<expr><name>n</name></expr>)</condition> <block>{
<decl_stmt><decl><type><name>size_t</name></type> <name>nread</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>shortread</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>src</name> <init>= <expr><name>dst</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>nread</name> = <call><name>BZ2_bzRead</name><argument_list>(<argument><expr><name>bzerror</name></expr></argument>, <argument><expr><name>stream</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>nread</name> &lt;= <name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>n</name> -= <name>nread</name></expr>;</expr_stmt>
<expr_stmt><expr><name>shortread</name> = <name>n</name> != 0</expr>;</expr_stmt>
<while>while <condition>(<expr><name>nread</name>--</expr>)</condition> <block>{
<decl_stmt><decl><type><name>char</name></type> <name>c</name> <init>= <expr>*<name>src</name>++</expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>c</name> == '\r'</expr>)</condition><then> <block>{
<expr_stmt><expr>*<name>dst</name>++ = '\n'</expr>;</expr_stmt>
<expr_stmt><expr><name>skipnextlf</name> = 1</expr>;</expr_stmt>
}</block></then> <else>else <if>if <condition>(<expr><name>skipnextlf</name> &amp;&amp; <name>c</name> == '\n'</expr>)</condition><then> <block>{
<expr_stmt><expr><name>skipnextlf</name> = 0</expr>;</expr_stmt>
<expr_stmt><expr><name>newlinetypes</name> |= <name>NEWLINE_CRLF</name></expr>;</expr_stmt>
<expr_stmt><expr>++<name>n</name></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<if>if <condition>(<expr><name>c</name> == '\n'</expr>)</condition><then>
<expr_stmt><expr><name>newlinetypes</name> |= <name>NEWLINE_LF</name></expr>;</expr_stmt></then>
<else>else <if>if <condition>(<expr><name>skipnextlf</name></expr>)</condition><then>
<expr_stmt><expr><name>newlinetypes</name> |= <name>NEWLINE_CR</name></expr>;</expr_stmt></then></if></else></if>
<expr_stmt><expr>*<name>dst</name>++ = <name>c</name></expr>;</expr_stmt>
<expr_stmt><expr><name>skipnextlf</name> = 0</expr>;</expr_stmt>
}</block></else></if></else></if>
}</block></while>
<if>if <condition>(<expr><name>shortread</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr><name>skipnextlf</name> &amp;&amp; *<name>bzerror</name> == <name>BZ_STREAM_END</name></expr>)</condition><then>
<expr_stmt><expr><name>newlinetypes</name> |= <name>NEWLINE_CR</name></expr>;</expr_stmt></then></if>
<break>break;</break>
}</block></then></if>
}</block></while>
<expr_stmt><expr><name><name>f</name>-&gt;<name>f_newlinetypes</name></name> = <name>newlinetypes</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>f</name>-&gt;<name>f_skipnextlf</name></name> = <name>skipnextlf</name></expr>;</expr_stmt>
<return>return <expr><name>dst</name> - <name>buf</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>Util_DropReadAhead</name><parameter_list>(<param><decl><type><name>BZ2FileObject</name> *</type><name>f</name></decl></param>)</parameter_list> <block>{
<if>if <condition>(<expr><name><name>f</name>-&gt;<name>f_buf</name></name> != <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyMem_Free</name><argument_list>(<argument><expr><name><name>f</name>-&gt;<name>f_buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>f</name>-&gt;<name>f_buf</name></name> = <name>NULL</name></expr>;</expr_stmt>
}</block></then></if>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>Util_ReadAhead</name><parameter_list>(<param><decl><type><name>BZ2FileObject</name> *</type><name>f</name></decl></param>, <param><decl><type><name>int</name></type> <name>bufsize</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>chunksize</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>bzerror</name></decl>;</decl_stmt>
<if>if <condition>(<expr><name><name>f</name>-&gt;<name>f_buf</name></name> != <name>NULL</name></expr>)</condition><then> <block>{
<if>if<condition>(<expr>(<name><name>f</name>-&gt;<name>f_bufend</name></name> - <name><name>f</name>-&gt;<name>f_bufptr</name></name>) &gt;= 1</expr>)</condition><then>
<return>return <expr>0</expr>;</return></then>
<else>else
<expr_stmt><expr><call><name>Util_DropReadAhead</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
}</block></then></if>
<if>if <condition>(<expr><name><name>f</name>-&gt;<name>mode</name></name> == <name>MODE_READ_EOF</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>f</name>-&gt;<name>f_bufptr</name></name> = <name><name>f</name>-&gt;<name>f_buf</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>f</name>-&gt;<name>f_bufend</name></name> = <name><name>f</name>-&gt;<name>f_buf</name></name></expr>;</expr_stmt>
<return>return <expr>0</expr>;</return>
}</block></then></if>
<if>if <condition>(<expr>(<name><name>f</name>-&gt;<name>f_buf</name></name> = <call><name>PyMem_Malloc</name><argument_list>(<argument><expr><name>bufsize</name></expr></argument>)</argument_list></call>) == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_NoMemory</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<return>return <expr>-1</expr>;</return>
}</block></then></if>
<decl_stmt><decl><type><name>Py_BEGIN_ALLOW_THREADS</name></type>
<name>chunksize</name> <init>= <expr><call><name>Util_UnivNewlineRead</name><argument_list>(<argument><expr>&amp;<name>bzerror</name></expr></argument>, <argument><expr><name><name>f</name>-&gt;<name>fp</name></name></expr></argument>, <argument><expr><name><name>f</name>-&gt;<name>f_buf</name></name></expr></argument>,
<argument><expr><name>bufsize</name></expr></argument>, <argument><expr><name>f</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>Py_END_ALLOW_THREADS</name>
<name><name>f</name>-&gt;<name>pos</name></name> += <name>chunksize</name></expr>;</expr_stmt>
<if>if <condition>(<expr><name>bzerror</name> == <name>BZ_STREAM_END</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>f</name>-&gt;<name>size</name></name> = <name><name>f</name>-&gt;<name>pos</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>f</name>-&gt;<name>mode</name></name> = <name>MODE_READ_EOF</name></expr>;</expr_stmt>
}</block></then> <else>else <if>if <condition>(<expr><name>bzerror</name> != <name>BZ_OK</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Util_CatchBZ2Error</name><argument_list>(<argument><expr><name>bzerror</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Util_DropReadAhead</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>-1</expr>;</return>
}</block></then></if></else></if>
<expr_stmt><expr><name><name>f</name>-&gt;<name>f_bufptr</name></name> = <name><name>f</name>-&gt;<name>f_buf</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>f</name>-&gt;<name>f_bufend</name></name> = <name><name>f</name>-&gt;<name>f_buf</name></name> + <name>chunksize</name></expr>;</expr_stmt>
<return>return <expr>0</expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>PyStringObject</name> *</type>
<name>Util_ReadAheadGetLineSkip</name><parameter_list>(<param><decl><type><name>BZ2FileObject</name> *</type><name>f</name></decl></param>, <param><decl><type><name>int</name></type> <name>skip</name></decl></param>, <param><decl><type><name>int</name></type> <name>bufsize</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyStringObject</name>*</type> <name>s</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>bufptr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>buf</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>len</name></decl>;</decl_stmt>
<if>if <condition>(<expr><name><name>f</name>-&gt;<name>f_buf</name></name> == <name>NULL</name></expr>)</condition><then>
<if>if <condition>(<expr><call><name>Util_ReadAhead</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><name>bufsize</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if></then></if>
<expr_stmt><expr><name>len</name> = <name><name>f</name>-&gt;<name>f_bufend</name></name> - <name><name>f</name>-&gt;<name>f_bufptr</name></name></expr>;</expr_stmt>
<if>if <condition>(<expr><name>len</name> == 0</expr>)</condition><then>
<return>return <expr>(<name>PyStringObject</name> *)
<call><name>PyString_FromStringAndSize</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>skip</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
<expr_stmt><expr><name>bufptr</name> = <call><name>memchr</name><argument_list>(<argument><expr><name><name>f</name>-&gt;<name>f_bufptr</name></name></expr></argument>, <argument><expr>'\n'</expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>bufptr</name> != <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>bufptr</name>++</expr>;</expr_stmt>
<expr_stmt><expr><name>len</name> = <name>bufptr</name> - <name><name>f</name>-&gt;<name>f_bufptr</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>s</name> = (<name>PyStringObject</name> *)
<call><name>PyString_FromStringAndSize</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>skip</name>+<name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>s</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call>+<name>skip</name></expr></argument>, <argument><expr><name><name>f</name>-&gt;<name>f_bufptr</name></name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>f</name>-&gt;<name>f_bufptr</name></name> = <name>bufptr</name></expr>;</expr_stmt>
<if>if <condition>(<expr><name>bufptr</name> == <name><name>f</name>-&gt;<name>f_bufend</name></name></expr>)</condition><then>
<expr_stmt><expr><call><name>Util_DropReadAhead</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
}</block></then> <else>else <block>{
<expr_stmt><expr><name>bufptr</name> = <name><name>f</name>-&gt;<name>f_bufptr</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>buf</name> = <name><name>f</name>-&gt;<name>f_buf</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>f</name>-&gt;<name>f_buf</name></name> = <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name>s</name> = <call><name>Util_ReadAheadGetLineSkip</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><name>skip</name>+<name>len</name></expr></argument>,
<argument><expr><name>bufsize</name> + (<name>bufsize</name>&gt;&gt;2)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>s</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyMem_Free</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call>+<name>skip</name></expr></argument>, <argument><expr><name>bufptr</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyMem_Free</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></else></if>
<return>return <expr><name>s</name></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>BZ2File_read__doc__</name></expr></argument>,
<argument><expr>"read([size]) -&gt; string\n\
\n\
Read at most size uncompressed bytes, returned as a string. If the size\n\
argument is negative or omitted, read until EOF is reached.\n\
"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>BZ2File_read</name><parameter_list>(<param><decl><type><name>BZ2FileObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>long</name></type> <name>bytesrequested</name> <init>= <expr>-1</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>bytesread</name></decl>, <decl><type ref="prev"/><name>buffersize</name></decl>, <decl><type ref="prev"/><name>chunksize</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>bzerror</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>ret</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"|l:read"</expr></argument>, <argument><expr>&amp;<name>bytesrequested</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><call><name>ACQUIRE_LOCK</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<switch>switch <condition>(<expr><name><name>self</name>-&gt;<name>mode</name></name></expr>)</condition> <block>{
<case>case <expr><name>MODE_READ</name></expr>:
<break>break;</break>
</case><case>case <expr><name>MODE_READ_EOF</name></expr>:
<expr_stmt><expr><name>ret</name> = <call><name>PyString_FromString</name><argument_list>(<argument><expr>""</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>cleanup</name>;</goto>
</case><case>case <expr><name>MODE_CLOSED</name></expr>:
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>,
<argument><expr>"I/O operation on closed file"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>cleanup</name>;</goto>
</case><default>default:
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_IOError</name></expr></argument>,
<argument><expr>"file is not ready for reading"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>cleanup</name>;</goto>
</default>}</block></switch>
<if>if <condition>(<expr><name>bytesrequested</name> &lt; 0</expr>)</condition><then>
<expr_stmt><expr><name>buffersize</name> = <call><name>Util_NewBufferSize</name><argument_list>(<argument><expr>(<name>size_t</name>)0</expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
<else>else
<expr_stmt><expr><name>buffersize</name> = <name>bytesrequested</name></expr>;</expr_stmt></else></if>
<if>if <condition>(<expr><name>buffersize</name> &gt; <name>INT_MAX</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_OverflowError</name></expr></argument>,
<argument><expr>"requested number of bytes is "
"more than a Python string can hold"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>cleanup</name>;</goto>
}</block></then></if>
<expr_stmt><expr><name>ret</name> = <call><name>PyString_FromStringAndSize</name><argument_list>(<argument><expr>(<name>char</name> *)<name>NULL</name></expr></argument>, <argument><expr><name>buffersize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>ret</name> == <name>NULL</name></expr>)</condition><then>
<goto>goto <name>cleanup</name>;</goto></then></if>
<expr_stmt><expr><name>bytesread</name> = 0</expr>;</expr_stmt>
<for>for (<init>;</init><condition>;</condition><incr/>) <block>{
<decl_stmt><decl><type><name>Py_BEGIN_ALLOW_THREADS</name></type>
<name>chunksize</name> <init>= <expr><call><name>Util_UnivNewlineRead</name><argument_list>(<argument><expr>&amp;<name>bzerror</name></expr></argument>, <argument><expr><name><name>self</name>-&gt;<name>fp</name></name></expr></argument>,
<argument><expr><call><name>BUF</name><argument_list>(<argument><expr><name>ret</name></expr></argument>)</argument_list></call>+<name>bytesread</name></expr></argument>,
<argument><expr><name>buffersize</name>-<name>bytesread</name></expr></argument>,
<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>self</name>-&gt;<name>pos</name></name> += <name>chunksize</name></expr>;</expr_stmt>
<expr_stmt><expr><name>Py_END_ALLOW_THREADS</name>
<name>bytesread</name> += <name>chunksize</name></expr>;</expr_stmt>
<if>if <condition>(<expr><name>bzerror</name> == <name>BZ_STREAM_END</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>self</name>-&gt;<name>size</name></name> = <name><name>self</name>-&gt;<name>pos</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>self</name>-&gt;<name>mode</name></name> = <name>MODE_READ_EOF</name></expr>;</expr_stmt>
<break>break;</break>
}</block></then> <else>else <if>if <condition>(<expr><name>bzerror</name> != <name>BZ_OK</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Util_CatchBZ2Error</name><argument_list>(<argument><expr><name>bzerror</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>ret</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ret</name> = <name>NULL</name></expr>;</expr_stmt>
<goto>goto <name>cleanup</name>;</goto>
}</block></then></if></else></if>
<if>if <condition>(<expr><name>bytesrequested</name> &lt; 0</expr>)</condition><then> <block>{
<expr_stmt><expr><name>buffersize</name> = <call><name>Util_NewBufferSize</name><argument_list>(<argument><expr><name>buffersize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>_PyString_Resize</name><argument_list>(<argument><expr>&amp;<name>ret</name></expr></argument>, <argument><expr><name>buffersize</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
<goto>goto <name>cleanup</name>;</goto></then></if>
}</block></then> <else>else <block>{
<break>break;</break>
}</block></else></if>
}</block></for>
<if>if <condition>(<expr><name>bytesread</name> != <name>buffersize</name></expr>)</condition><then>
<expr_stmt><expr><call><name>_PyString_Resize</name><argument_list>(<argument><expr>&amp;<name>ret</name></expr></argument>, <argument><expr><name>bytesread</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<label><name>cleanup</name>:</label>
<expr_stmt><expr><call><name>RELEASE_LOCK</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>ret</name></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>BZ2File_readline__doc__</name></expr></argument>,
<argument><expr>"readline([size]) -&gt; string\n\
\n\
Return the next line from the file, as a string, retaining newline.\n\
A non-negative size argument will limit the maximum number of bytes to\n\
return (an incomplete line may be returned then). Return an empty\n\
string at EOF.\n\
"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>BZ2File_readline</name><parameter_list>(<param><decl><type><name>BZ2FileObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>ret</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>sizehint</name> <init>= <expr>-1</expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"|i:readline"</expr></argument>, <argument><expr>&amp;<name>sizehint</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><call><name>ACQUIRE_LOCK</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<switch>switch <condition>(<expr><name><name>self</name>-&gt;<name>mode</name></name></expr>)</condition> <block>{
<case>case <expr><name>MODE_READ</name></expr>:
<break>break;</break>
</case><case>case <expr><name>MODE_READ_EOF</name></expr>:
<expr_stmt><expr><name>ret</name> = <call><name>PyString_FromString</name><argument_list>(<argument><expr>""</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>cleanup</name>;</goto>
</case><case>case <expr><name>MODE_CLOSED</name></expr>:
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>,
<argument><expr>"I/O operation on closed file"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>cleanup</name>;</goto>
</case><default>default:
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_IOError</name></expr></argument>,
<argument><expr>"file is not ready for reading"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>cleanup</name>;</goto>
</default>}</block></switch>
<if>if <condition>(<expr><name>sizehint</name> == 0</expr>)</condition><then>
<expr_stmt><expr><name>ret</name> = <call><name>PyString_FromString</name><argument_list>(<argument><expr>""</expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
<else>else
<expr_stmt><expr><name>ret</name> = <call><name>Util_GetLine</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr>(<name>sizehint</name> &lt; 0) ? 0 : <name>sizehint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
<label><name>cleanup</name>:</label>
<expr_stmt><expr><call><name>RELEASE_LOCK</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>ret</name></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>BZ2File_readlines__doc__</name></expr></argument>,
<argument><expr>"readlines([size]) -&gt; list\n\
\n\
Call readline() repeatedly and return a list of lines read.\n\
The optional size argument, if given, is an approximate bound on the\n\
total number of bytes in the lines returned.\n\
"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>BZ2File_readlines</name><parameter_list>(<param><decl><type><name>BZ2FileObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>long</name></type> <name>sizehint</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>list</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>line</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name><name>small_buffer</name><index>[<expr><name>SMALLCHUNK</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>buffer</name> <init>= <expr><name>small_buffer</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>buffersize</name> <init>= <expr><name>SMALLCHUNK</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>big_buffer</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>nfilled</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>nread</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>totalread</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>p</name></decl>, *<decl><type ref="prev"/><name>q</name></decl>, *<decl><type ref="prev"/><name>end</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>err</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>shortread</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>bzerror</name></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"|l:readlines"</expr></argument>, <argument><expr>&amp;<name>sizehint</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><call><name>ACQUIRE_LOCK</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<switch>switch <condition>(<expr><name><name>self</name>-&gt;<name>mode</name></name></expr>)</condition> <block>{
<case>case <expr><name>MODE_READ</name></expr>:
<break>break;</break>
</case><case>case <expr><name>MODE_READ_EOF</name></expr>:
<expr_stmt><expr><name>list</name> = <call><name>PyList_New</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>cleanup</name>;</goto>
</case><case>case <expr><name>MODE_CLOSED</name></expr>:
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>,
<argument><expr>"I/O operation on closed file"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>cleanup</name>;</goto>
</case><default>default:
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_IOError</name></expr></argument>,
<argument><expr>"file is not ready for reading"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>cleanup</name>;</goto>
</default>}</block></switch>
<if>if <condition>(<expr>(<name>list</name> = <call><name>PyList_New</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call>) == <name>NULL</name></expr>)</condition><then>
<goto>goto <name>cleanup</name>;</goto></then></if>
<for>for (<init>;</init><condition>;</condition><incr/>) <block>{
<decl_stmt><decl><type><name>Py_BEGIN_ALLOW_THREADS</name></type>
<name>nread</name> <init>= <expr><call><name>Util_UnivNewlineRead</name><argument_list>(<argument><expr>&amp;<name>bzerror</name></expr></argument>, <argument><expr><name><name>self</name>-&gt;<name>fp</name></name></expr></argument>,
<argument><expr><name>buffer</name>+<name>nfilled</name></expr></argument>,
<argument><expr><name>buffersize</name>-<name>nfilled</name></expr></argument>, <argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>self</name>-&gt;<name>pos</name></name> += <name>nread</name></expr>;</expr_stmt>
<macro><name>Py_END_ALLOW_THREADS</name></macro>
<if>if <condition>(<expr><name>bzerror</name> == <name>BZ_STREAM_END</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>self</name>-&gt;<name>size</name></name> = <name><name>self</name>-&gt;<name>pos</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>self</name>-&gt;<name>mode</name></name> = <name>MODE_READ_EOF</name></expr>;</expr_stmt>
<if>if <condition>(<expr><name>nread</name> == 0</expr>)</condition><then> <block>{
<expr_stmt><expr><name>sizehint</name> = 0</expr>;</expr_stmt>
<break>break;</break>
}</block></then></if>
<expr_stmt><expr><name>shortread</name> = 1</expr>;</expr_stmt>
}</block></then> <else>else <if>if <condition>(<expr><name>bzerror</name> != <name>BZ_OK</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Util_CatchBZ2Error</name><argument_list>(<argument><expr><name>bzerror</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<label><name>error</name>:</label>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>list</name> = <name>NULL</name></expr>;</expr_stmt>
<goto>goto <name>cleanup</name>;</goto>
}</block></then></if></else></if>
<expr_stmt><expr><name>totalread</name> += <name>nread</name></expr>;</expr_stmt>
<expr_stmt><expr><name>p</name> = <call><name>memchr</name><argument_list>(<argument><expr><name>buffer</name>+<name>nfilled</name></expr></argument>, <argument><expr>'\n'</expr></argument>, <argument><expr><name>nread</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>shortread</name> &amp;&amp; <name>p</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>nfilled</name> += <name>nread</name></expr>;</expr_stmt>
<expr_stmt><expr><name>buffersize</name> *= 2</expr>;</expr_stmt>
<if>if <condition>(<expr><name>buffersize</name> &gt; <name>INT_MAX</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_OverflowError</name></expr></argument>,
<argument><expr>"line is longer than a Python string can hold"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>error</name>;</goto>
}</block></then></if>
<if>if <condition>(<expr><name>big_buffer</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>big_buffer</name> = <call><name>PyString_FromStringAndSize</name><argument_list>(
<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>buffersize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>big_buffer</name> == <name>NULL</name></expr>)</condition><then>
<goto>goto <name>error</name>;</goto></then></if>
<expr_stmt><expr><name>buffer</name> = <call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>big_buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>small_buffer</name></expr></argument>, <argument><expr><name>nfilled</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr><call><name>_PyString_Resize</name><argument_list>(<argument><expr>&amp;<name>big_buffer</name></expr></argument>, <argument><expr><name>buffersize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>buffer</name> = <call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>big_buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></else></if>
<continue>continue;</continue>
}</block></then></if>
<expr_stmt><expr><name>end</name> = <name>buffer</name>+<name>nfilled</name>+<name>nread</name></expr>;</expr_stmt>
<expr_stmt><expr><name>q</name> = <name>buffer</name></expr>;</expr_stmt>
<while>while <condition>(<expr><name>p</name> != <name>NULL</name></expr>)</condition> <block>{
<expr_stmt><expr><name>p</name>++</expr>;</expr_stmt>
<expr_stmt><expr><name>line</name> = <call><name>PyString_FromStringAndSize</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><name>p</name>-<name>q</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>line</name> == <name>NULL</name></expr>)</condition><then>
<goto>goto <name>error</name>;</goto></then></if>
<expr_stmt><expr><name>err</name> = <call><name>PyList_Append</name><argument_list>(<argument><expr><name>list</name></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>err</name> != 0</expr>)</condition><then>
<goto>goto <name>error</name>;</goto></then></if>
<expr_stmt><expr><name>q</name> = <name>p</name></expr>;</expr_stmt>
<expr_stmt><expr><name>p</name> = <call><name>memchr</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr>'\n'</expr></argument>, <argument><expr><name>end</name>-<name>q</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></while>
<expr_stmt><expr><name>nfilled</name> = <name>end</name>-<name>q</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>q</name></expr></argument>, <argument><expr><name>nfilled</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>sizehint</name> &gt; 0</expr>)</condition><then>
<if>if <condition>(<expr><name>totalread</name> &gt;= (<name>size_t</name>)<name>sizehint</name></expr>)</condition><then>
<break>break;</break></then></if></then></if>
<if>if <condition>(<expr><name>shortread</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>sizehint</name> = 0</expr>;</expr_stmt>
<break>break;</break>
}</block></then></if>
}</block></for>
<if>if <condition>(<expr><name>nfilled</name> != 0</expr>)</condition><then> <block>{
<expr_stmt><expr><name>line</name> = <call><name>PyString_FromStringAndSize</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>nfilled</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>line</name> == <name>NULL</name></expr>)</condition><then>
<goto>goto <name>error</name>;</goto></then></if>
<if>if <condition>(<expr><name>sizehint</name> &gt; 0</expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>rest</name> <init>= <expr><call><name>Util_GetLine</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>rest</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>error</name>;</goto>
}</block></then></if>
<expr_stmt><expr><call><name>PyString_Concat</name><argument_list>(<argument><expr>&amp;<name>line</name></expr></argument>, <argument><expr><name>rest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>rest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>line</name> == <name>NULL</name></expr>)</condition><then>
<goto>goto <name>error</name>;</goto></then></if>
}</block></then></if>
<expr_stmt><expr><name>err</name> = <call><name>PyList_Append</name><argument_list>(<argument><expr><name>list</name></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>err</name> != 0</expr>)</condition><then>
<goto>goto <name>error</name>;</goto></then></if>
}</block></then></if>
<label><name>cleanup</name>:</label>
<expr_stmt><expr><call><name>RELEASE_LOCK</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>big_buffer</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>big_buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<return>return <expr><name>list</name></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>BZ2File_xreadlines__doc__</name></expr></argument>,
<argument><expr>"xreadlines() -&gt; self\n\
\n\
For backward compatibility. BZ2File objects now include the performance\n\
optimizations previously implemented in the xreadlines module.\n\
"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>BZ2File_write__doc__</name></expr></argument>,
<argument><expr>"write(data) -&gt; None\n\
\n\
Write the 'data' string to file. Note that due to buffering, close() may\n\
be needed before the file on disk reflects the data written.\n\
"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>BZ2File_write</name><parameter_list>(<param><decl><type><name>BZ2FileObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>ret</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_buffer</name></type> <name>pbuf</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>buf</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>len</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>bzerror</name></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"s*:write"</expr></argument>, <argument><expr>&amp;<name>pbuf</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>buf</name> = <name><name>pbuf</name>.<name>buf</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>len</name> = <name><name>pbuf</name>.<name>len</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ACQUIRE_LOCK</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<switch>switch <condition>(<expr><name><name>self</name>-&gt;<name>mode</name></name></expr>)</condition> <block>{
<case>case <expr><name>MODE_WRITE</name></expr>:
<break>break;</break>
</case><case>case <expr><name>MODE_CLOSED</name></expr>:
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>,
<argument><expr>"I/O operation on closed file"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>cleanup</name>;</goto>
</case><default>default:
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_IOError</name></expr></argument>,
<argument><expr>"file is not ready for writing"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>cleanup</name>;</goto>
</default>}</block></switch>
<expr_stmt><expr><name><name>self</name>-&gt;<name>f_softspace</name></name> = 0</expr>;</expr_stmt>
<decl_stmt><decl><type><name>Py_BEGIN_ALLOW_THREADS</name></type>
<name>BZ2_bzWrite</name> <argument_list>(<argument><expr>&amp;<name>bzerror</name></expr></argument>, <argument><expr><name><name>self</name>-&gt;<name>fp</name></name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></decl>;</decl_stmt>
<expr_stmt><expr><name><name>self</name>-&gt;<name>pos</name></name> += <name>len</name></expr>;</expr_stmt>
<macro><name>Py_END_ALLOW_THREADS</name></macro>
<if>if <condition>(<expr><name>bzerror</name> != <name>BZ_OK</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Util_CatchBZ2Error</name><argument_list>(<argument><expr><name>bzerror</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>cleanup</name>;</goto>
}</block></then></if>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ret</name> = <name>Py_None</name></expr>;</expr_stmt>
<label><name>cleanup</name>:</label>
<expr_stmt><expr><call><name>PyBuffer_Release</name><argument_list>(<argument><expr>&amp;<name>pbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>RELEASE_LOCK</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>ret</name></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>BZ2File_writelines__doc__</name></expr></argument>,
<argument><expr>"writelines(sequence_of_strings) -&gt; None\n\
\n\
Write the sequence of strings to the file. Note that newlines are not\n\
added. The sequence can be any iterable object producing strings. This is\n\
equivalent to calling write() for each string.\n\
"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>BZ2File_writelines</name><parameter_list>(<param><decl><type><name>BZ2FileObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>seq</name></decl></param>)</parameter_list> <block>{
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CHUNKSIZE</name></cpp:macro> <cpp:value>1000</cpp:value></cpp:define>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>list</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>iter</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>ret</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>line</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>, <decl><type ref="prev"/><name>index</name></decl>, <decl><type ref="prev"/><name>len</name></decl>, <decl><type ref="prev"/><name>islist</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>bzerror</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>ACQUIRE_LOCK</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<switch>switch <condition>(<expr><name><name>self</name>-&gt;<name>mode</name></name></expr>)</condition> <block>{
<case>case <expr><name>MODE_WRITE</name></expr>:
<break>break;</break>
</case><case>case <expr><name>MODE_CLOSED</name></expr>:
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>,
<argument><expr>"I/O operation on closed file"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>error</name>;</goto>
</case><default>default:
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_IOError</name></expr></argument>,
<argument><expr>"file is not ready for writing"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>error</name>;</goto>
</default>}</block></switch>
<expr_stmt><expr><name>islist</name> = <call><name>PyList_Check</name><argument_list>(<argument><expr><name>seq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>islist</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>iter</name> = <call><name>PyObject_GetIter</name><argument_list>(<argument><expr><name>seq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>iter</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
<argument><expr>"writelines() requires an iterable argument"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>error</name>;</goto>
}</block></then></if>
<expr_stmt><expr><name>list</name> = <call><name>PyList_New</name><argument_list>(<argument><expr><name>CHUNKSIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>list</name> == <name>NULL</name></expr>)</condition><then>
<goto>goto <name>error</name>;</goto></then></if>
}</block></then></if>
<for>for (<init><expr><name>index</name> = 0</expr>;</init> <condition>;</condition> <incr><expr><name>index</name> += <name>CHUNKSIZE</name></expr></incr>) <block>{
<if>if <condition>(<expr><name>islist</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>list</name> = <call><name>PyList_GetSlice</name><argument_list>(<argument><expr><name>seq</name></expr></argument>, <argument><expr><name>index</name></expr></argument>, <argument><expr><name>index</name>+<name>CHUNKSIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>list</name> == <name>NULL</name></expr>)</condition><then>
<goto>goto <name>error</name>;</goto></then></if>
<expr_stmt><expr><name>j</name> = <call><name>PyList_GET_SIZE</name><argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<for>for (<init><expr><name>j</name> = 0</expr>;</init> <condition><expr><name>j</name> &lt; <name>CHUNKSIZE</name></expr>;</condition> <incr><expr><name>j</name>++</expr></incr>) <block>{
<expr_stmt><expr><name>line</name> = <call><name>PyIter_Next</name><argument_list>(<argument><expr><name>iter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>line</name> == <name>NULL</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr><call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then>
<goto>goto <name>error</name>;</goto></then></if>
<break>break;</break>
}</block></then></if>
<expr_stmt><expr><call><name>PyList_SetItem</name><argument_list>(<argument><expr><name>list</name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></for>
}</block></else></if>
<if>if <condition>(<expr><name>j</name> == 0</expr>)</condition><then>
<break>break;</break></then></if>
<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>j</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>v</name> <init>= <expr><call><name>PyList_GET_ITEM</name><argument_list>(<argument><expr><name>list</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>PyString_Check</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>buffer</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>len</name></decl>;</decl_stmt>
<if>if <condition>(<expr><call><name>PyObject_AsCharBuffer</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr>&amp;<name>buffer</name></expr></argument>, <argument><expr>&amp;<name>len</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
<argument><expr>"writelines() "
"argument must be "
"a sequence of "
"strings"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>error</name>;</goto>
}</block></then></if>
<expr_stmt><expr><name>line</name> = <call><name>PyString_FromStringAndSize</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>,
<argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>line</name> == <name>NULL</name></expr>)</condition><then>
<goto>goto <name>error</name>;</goto></then></if>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyList_SET_ITEM</name><argument_list>(<argument><expr><name>list</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
}</block></for>
<expr_stmt><expr><name><name>self</name>-&gt;<name>f_softspace</name></name> = 0</expr>;</expr_stmt>
<macro><name>Py_BEGIN_ALLOW_THREADS</name></macro>
<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>j</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
<expr_stmt><expr><name>line</name> = <call><name>PyList_GET_ITEM</name><argument_list>(<argument><expr><name>list</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>len</name> = <call><name>PyString_GET_SIZE</name><argument_list>(<argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>BZ2_bzWrite</name> <argument_list>(<argument><expr>&amp;<name>bzerror</name></expr></argument>, <argument><expr><name><name>self</name>-&gt;<name>fp</name></name></expr></argument>,
<argument><expr><call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>line</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>bzerror</name> != <name>BZ_OK</name></expr>)</condition><then> <block>{
<function_decl><type><name>Py_BLOCK_THREADS</name></type>
<name>Util_CatchBZ2Error</name><parameter_list>(<param><decl><type><name>bzerror</name></type></decl></param>)</parameter_list>;</function_decl>
<goto>goto <name>error</name>;</goto>
}</block></then></if>
}</block></for>
<macro><name>Py_END_ALLOW_THREADS</name></macro>
<if>if <condition>(<expr><name>j</name> &lt; <name>CHUNKSIZE</name></expr>)</condition><then>
<break>break;</break></then></if>
}</block></for>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ret</name> = <name>Py_None</name></expr>;</expr_stmt>
<label><name>error</name>:</label>
<expr_stmt><expr><call><name>RELEASE_LOCK</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>iter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>ret</name></expr>;</return>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>CHUNKSIZE</name></cpp:undef>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>BZ2File_seek__doc__</name></expr></argument>,
<argument><expr>"seek(offset [, whence]) -&gt; None\n\
\n\
Move to new file position. Argument offset is a byte count. Optional\n\
argument whence defaults to 0 (offset from start of file, offset\n\
should be &gt;= 0); other values are 1 (move relative to current position,\n\
positive or negative), and 2 (move relative to end of file, usually\n\
negative, although many platforms allow seeking beyond the end of a file).\n\
\n\
Note that seeking of bz2 files is emulated, and depending on the parameters\n\
the operation may be extremely slow.\n\
"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>BZ2File_seek</name><parameter_list>(<param><decl><type><name>BZ2FileObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>where</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>offobj</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_off_t</name></type> <name>offset</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name><name>small_buffer</name><index>[<expr><name>SMALLCHUNK</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>buffer</name> <init>= <expr><name>small_buffer</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>buffersize</name> <init>= <expr><name>SMALLCHUNK</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_off_t</name></type> <name>bytesread</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>readsize</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>chunksize</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>bzerror</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>ret</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"O|i:seek"</expr></argument>, <argument><expr>&amp;<name>offobj</name></expr></argument>, <argument><expr>&amp;<name>where</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>HAVE_LARGEFILE_SUPPORT</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><name>offset</name> = <call><name>PyInt_AsLong</name><argument_list>(<argument><expr><name>offobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<expr_stmt><expr><name>offset</name> = <call><name>PyLong_Check</name><argument_list>(<argument><expr><name>offobj</name></expr></argument>)</argument_list></call> ?
<call><name>PyLong_AsLongLong</name><argument_list>(<argument><expr><name>offobj</name></expr></argument>)</argument_list></call> : <call><name>PyInt_AsLong</name><argument_list>(<argument><expr><name>offobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<if>if <condition>(<expr><call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><call><name>ACQUIRE_LOCK</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Util_DropReadAhead</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<switch>switch <condition>(<expr><name><name>self</name>-&gt;<name>mode</name></name></expr>)</condition> <block>{
<case>case <expr><name>MODE_READ</name></expr>:
</case><case>case <expr><name>MODE_READ_EOF</name></expr>:
<break>break;</break>
</case><case>case <expr><name>MODE_CLOSED</name></expr>:
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>,
<argument><expr>"I/O operation on closed file"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>cleanup</name>;</goto>
</case><default>default:
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_IOError</name></expr></argument>,
<argument><expr>"seek works only while reading"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>cleanup</name>;</goto>
</default>}</block></switch>
<if>if <condition>(<expr><name>where</name> == 2</expr>)</condition><then> <block>{
<if>if <condition>(<expr><name><name>self</name>-&gt;<name>size</name></name> == -1</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>mode</name></name> != <name>MODE_READ_EOF</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for (<init>;</init><condition>;</condition><incr/>) <block>{
<decl_stmt><decl><type><name>Py_BEGIN_ALLOW_THREADS</name></type>
<name>chunksize</name> <init>= <expr><call><name>Util_UnivNewlineRead</name><argument_list>(
<argument><expr>&amp;<name>bzerror</name></expr></argument>, <argument><expr><name><name>self</name>-&gt;<name>fp</name></name></expr></argument>,
<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>buffersize</name></expr></argument>,
<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>self</name>-&gt;<name>pos</name></name> += <name>chunksize</name></expr>;</expr_stmt>
<expr_stmt><expr><name>Py_END_ALLOW_THREADS</name>
<name>bytesread</name> += <name>chunksize</name></expr>;</expr_stmt>
<if>if <condition>(<expr><name>bzerror</name> == <name>BZ_STREAM_END</name></expr>)</condition><then> <block>{
<break>break;</break>
}</block></then> <else>else <if>if <condition>(<expr><name>bzerror</name> != <name>BZ_OK</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Util_CatchBZ2Error</name><argument_list>(<argument><expr><name>bzerror</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>cleanup</name>;</goto>
}</block></then></if></else></if>
}</block></for>
<expr_stmt><expr><name><name>self</name>-&gt;<name>mode</name></name> = <name>MODE_READ_EOF</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>self</name>-&gt;<name>size</name></name> = <name><name>self</name>-&gt;<name>pos</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>bytesread</name> = 0</expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><name>offset</name> = <name><name>self</name>-&gt;<name>size</name></name> + <name>offset</name></expr>;</expr_stmt>
}</block></then> <else>else <if>if <condition>(<expr><name>where</name> == 1</expr>)</condition><then> <block>{
<expr_stmt><expr><name>offset</name> = <name><name>self</name>-&gt;<name>pos</name></name> + <name>offset</name></expr>;</expr_stmt>
}</block></then></if></else></if>
<if>if <condition>(<expr><name>offset</name> &gt;= <name><name>self</name>-&gt;<name>pos</name></name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>offset</name> -= <name><name>self</name>-&gt;<name>pos</name></name></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr><call><name>BZ2_bzReadClose</name><argument_list>(<argument><expr>&amp;<name>bzerror</name></expr></argument>, <argument><expr><name><name>self</name>-&gt;<name>fp</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>self</name>-&gt;<name>fp</name></name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyFile_DecUseCount</name><argument_list>(<argument><expr>(<name>PyFileObject</name> *)<name><name>self</name>-&gt;<name>file</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>self</name>-&gt;<name>fp</name></name> = <name>NULL</name></expr>;</expr_stmt>
}</block></then></if>
<if>if <condition>(<expr><name>bzerror</name> != <name>BZ_OK</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Util_CatchBZ2Error</name><argument_list>(<argument><expr><name>bzerror</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>cleanup</name>;</goto>
}</block></then></if>
<expr_stmt><expr><name>ret</name> = <call><name>PyObject_CallMethod</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>file</name></name></expr></argument>, <argument><expr>"seek"</expr></argument>, <argument><expr>"(i)"</expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>ret</name></expr>)</condition><then>
<goto>goto <name>cleanup</name>;</goto></then></if>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>ret</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ret</name> = <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>self</name>-&gt;<name>pos</name></name> = 0</expr>;</expr_stmt>
<expr_stmt><expr><name><name>self</name>-&gt;<name>fp</name></name> = <call><name>BZ2_bzReadOpen</name><argument_list>(<argument><expr>&amp;<name>bzerror</name></expr></argument>, <argument><expr><call><name>PyFile_AsFile</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>file</name></name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>self</name>-&gt;<name>fp</name></name></expr>)</condition><then>
<expr_stmt><expr><call><name>PyFile_IncUseCount</name><argument_list>(<argument><expr>(<name>PyFileObject</name> *)<name><name>self</name>-&gt;<name>file</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<if>if <condition>(<expr><name>bzerror</name> != <name>BZ_OK</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Util_CatchBZ2Error</name><argument_list>(<argument><expr><name>bzerror</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>cleanup</name>;</goto>
}</block></then></if>
<expr_stmt><expr><name><name>self</name>-&gt;<name>mode</name></name> = <name>MODE_READ</name></expr>;</expr_stmt>
}</block></else></if>
<if>if <condition>(<expr><name>offset</name> &lt;= 0 || <name><name>self</name>-&gt;<name>mode</name></name> == <name>MODE_READ_EOF</name></expr>)</condition><then>
<goto>goto <name>exit</name>;</goto></then></if>
<for>for (<init>;</init><condition>;</condition><incr/>) <block>{
<if>if <condition>(<expr><name>offset</name>-<name>bytesread</name> &gt; <name>buffersize</name></expr>)</condition><then>
<expr_stmt><expr><name>readsize</name> = <name>buffersize</name></expr>;</expr_stmt></then>
<else>else
<expr_stmt><expr><name>readsize</name> = <call>(<name>size_t</name>)<argument_list>(<argument><expr><name>offset</name>-<name>bytesread</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
<decl_stmt><decl><type><name>Py_BEGIN_ALLOW_THREADS</name></type>
<name>chunksize</name> <init>= <expr><call><name>Util_UnivNewlineRead</name><argument_list>(<argument><expr>&amp;<name>bzerror</name></expr></argument>, <argument><expr><name><name>self</name>-&gt;<name>fp</name></name></expr></argument>,
<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>readsize</name></expr></argument>, <argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>self</name>-&gt;<name>pos</name></name> += <name>chunksize</name></expr>;</expr_stmt>
<expr_stmt><expr><name>Py_END_ALLOW_THREADS</name>
<name>bytesread</name> += <name>chunksize</name></expr>;</expr_stmt>
<if>if <condition>(<expr><name>bzerror</name> == <name>BZ_STREAM_END</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>self</name>-&gt;<name>size</name></name> = <name><name>self</name>-&gt;<name>pos</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>self</name>-&gt;<name>mode</name></name> = <name>MODE_READ_EOF</name></expr>;</expr_stmt>
<break>break;</break>
}</block></then> <else>else <if>if <condition>(<expr><name>bzerror</name> != <name>BZ_OK</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Util_CatchBZ2Error</name><argument_list>(<argument><expr><name>bzerror</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>cleanup</name>;</goto>
}</block></then></if></else></if>
<if>if <condition>(<expr><name>bytesread</name> == <name>offset</name></expr>)</condition><then>
<break>break;</break></then></if>
}</block></for>
<label><name>exit</name>:</label>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ret</name> = <name>Py_None</name></expr>;</expr_stmt>
<label><name>cleanup</name>:</label>
<expr_stmt><expr><call><name>RELEASE_LOCK</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>ret</name></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>BZ2File_tell__doc__</name></expr></argument>,
<argument><expr>"tell() -&gt; int\n\
\n\
Return the current file position, an integer (may be a long integer).\n\
"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>BZ2File_tell</name><parameter_list>(<param><decl><type><name>BZ2FileObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>ret</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name><name>self</name>-&gt;<name>mode</name></name> == <name>MODE_CLOSED</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>,
<argument><expr>"I/O operation on closed file"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>cleanup</name>;</goto>
}</block></then></if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>HAVE_LARGEFILE_SUPPORT</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><name>ret</name> = <call><name>PyInt_FromLong</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>pos</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<expr_stmt><expr><name>ret</name> = <call><name>PyLong_FromLongLong</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>pos</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<label><name>cleanup</name>:</label>
<return>return <expr><name>ret</name></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>BZ2File_close__doc__</name></expr></argument>,
<argument><expr>"close() -&gt; None or (perhaps) an integer\n\
\n\
Close the file. Sets data attribute .closed to true. A closed file\n\
cannot be used for further I/O operations. close() may be called more\n\
than once without error.\n\
"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>BZ2File_close</name><parameter_list>(<param><decl><type><name>BZ2FileObject</name> *</type><name>self</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>ret</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>bzerror</name> <init>= <expr><name>BZ_OK</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>ACQUIRE_LOCK</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<switch>switch <condition>(<expr><name><name>self</name>-&gt;<name>mode</name></name></expr>)</condition> <block>{
<case>case <expr><name>MODE_READ</name></expr>:
</case><case>case <expr><name>MODE_READ_EOF</name></expr>:
<expr_stmt><expr><call><name>BZ2_bzReadClose</name><argument_list>(<argument><expr>&amp;<name>bzerror</name></expr></argument>, <argument><expr><name><name>self</name>-&gt;<name>fp</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr><name>MODE_WRITE</name></expr>:
<expr_stmt><expr><call><name>BZ2_bzWriteClose</name><argument_list>(<argument><expr>&amp;<name>bzerror</name></expr></argument>, <argument><expr><name><name>self</name>-&gt;<name>fp</name></name></expr></argument>,
<argument><expr>0</expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</case>}</block></switch>
<if>if <condition>(<expr><name><name>self</name>-&gt;<name>fp</name></name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyFile_DecUseCount</name><argument_list>(<argument><expr>(<name>PyFileObject</name> *)<name><name>self</name>-&gt;<name>file</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>self</name>-&gt;<name>fp</name></name> = <name>NULL</name></expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><name><name>self</name>-&gt;<name>mode</name></name> = <name>MODE_CLOSED</name></expr>;</expr_stmt>
<expr_stmt><expr><name>ret</name> = <call><name>PyObject_CallMethod</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>file</name></name></expr></argument>, <argument><expr>"close"</expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>bzerror</name> != <name>BZ_OK</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Util_CatchBZ2Error</name><argument_list>(<argument><expr><name>bzerror</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>ret</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ret</name> = <name>NULL</name></expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><call><name>RELEASE_LOCK</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>ret</name></expr>;</return>
}</block></function>
<function_decl><type><specifier>static</specifier> <name>PyObject</name> *</type><name>BZ2File_getiter</name><parameter_list>(<param><decl><type><name>BZ2FileObject</name> *</type><name>self</name></decl></param>)</parameter_list>;</function_decl>
<decl_stmt><decl><type><specifier>static</specifier> <name>PyMethodDef</name></type> <name><name>BZ2File_methods</name><index>[]</index></name> <init>= <expr><block>{
<expr><block>{<expr>"read"</expr>, <expr>(<name>PyCFunction</name>)<name>BZ2File_read</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>BZ2File_read__doc__</name></expr>}</block></expr>,
<expr><block>{<expr>"readline"</expr>, <expr>(<name>PyCFunction</name>)<name>BZ2File_readline</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>BZ2File_readline__doc__</name></expr>}</block></expr>,
<expr><block>{<expr>"readlines"</expr>, <expr>(<name>PyCFunction</name>)<name>BZ2File_readlines</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>BZ2File_readlines__doc__</name></expr>}</block></expr>,
<expr><block>{<expr>"xreadlines"</expr>, <expr>(<name>PyCFunction</name>)<name>BZ2File_getiter</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>BZ2File_xreadlines__doc__</name></expr>}</block></expr>,
<expr><block>{<expr>"write"</expr>, <expr>(<name>PyCFunction</name>)<name>BZ2File_write</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>BZ2File_write__doc__</name></expr>}</block></expr>,
<expr><block>{<expr>"writelines"</expr>, <expr>(<name>PyCFunction</name>)<name>BZ2File_writelines</name></expr>, <expr><name>METH_O</name></expr>, <expr><name>BZ2File_writelines__doc__</name></expr>}</block></expr>,
<expr><block>{<expr>"seek"</expr>, <expr>(<name>PyCFunction</name>)<name>BZ2File_seek</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>BZ2File_seek__doc__</name></expr>}</block></expr>,
<expr><block>{<expr>"tell"</expr>, <expr>(<name>PyCFunction</name>)<name>BZ2File_tell</name></expr>, <expr><name>METH_NOARGS</name></expr>, <expr><name>BZ2File_tell__doc__</name></expr>}</block></expr>,
<expr><block>{<expr>"close"</expr>, <expr>(<name>PyCFunction</name>)<name>BZ2File_close</name></expr>, <expr><name>METH_NOARGS</name></expr>, <expr><name>BZ2File_close__doc__</name></expr>}</block></expr>,
<expr><block>{<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>}</block></expr>
}</block></expr></init></decl>;</decl_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>BZ2File_get_newlines</name><parameter_list>(<param><decl><type><name>BZ2FileObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>void</name> *</type><name>closure</name></decl></param>)</parameter_list> <block>{
<switch>switch <condition>(<expr><name><name>self</name>-&gt;<name>f_newlinetypes</name></name></expr>)</condition> <block>{
<case>case <expr><name>NEWLINE_UNKNOWN</name></expr>:
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>Py_None</name></expr>;</return>
</case><case>case <expr><name>NEWLINE_CR</name></expr>:
<return>return <expr><call><name>PyString_FromString</name><argument_list>(<argument><expr>"\r"</expr></argument>)</argument_list></call></expr>;</return>
</case><case>case <expr><name>NEWLINE_LF</name></expr>:
<return>return <expr><call><name>PyString_FromString</name><argument_list>(<argument><expr>"\n"</expr></argument>)</argument_list></call></expr>;</return>
</case><case>case <expr><name>NEWLINE_CR</name>|<name>NEWLINE_LF</name></expr>:
<return>return <expr><call><name>Py_BuildValue</name><argument_list>(<argument><expr>"(ss)"</expr></argument>, <argument><expr>"\r"</expr></argument>, <argument><expr>"\n"</expr></argument>)</argument_list></call></expr>;</return>
</case><case>case <expr><name>NEWLINE_CRLF</name></expr>:
<return>return <expr><call><name>PyString_FromString</name><argument_list>(<argument><expr>"\r\n"</expr></argument>)</argument_list></call></expr>;</return>
</case><case>case <expr><name>NEWLINE_CR</name>|<name>NEWLINE_CRLF</name></expr>:
<return>return <expr><call><name>Py_BuildValue</name><argument_list>(<argument><expr>"(ss)"</expr></argument>, <argument><expr>"\r"</expr></argument>, <argument><expr>"\r\n"</expr></argument>)</argument_list></call></expr>;</return>
</case><case>case <expr><name>NEWLINE_LF</name>|<name>NEWLINE_CRLF</name></expr>:
<return>return <expr><call><name>Py_BuildValue</name><argument_list>(<argument><expr>"(ss)"</expr></argument>, <argument><expr>"\n"</expr></argument>, <argument><expr>"\r\n"</expr></argument>)</argument_list></call></expr>;</return>
</case><case>case <expr><name>NEWLINE_CR</name>|<name>NEWLINE_LF</name>|<name>NEWLINE_CRLF</name></expr>:
<return>return <expr><call><name>Py_BuildValue</name><argument_list>(<argument><expr>"(sss)"</expr></argument>, <argument><expr>"\r"</expr></argument>, <argument><expr>"\n"</expr></argument>, <argument><expr>"\r\n"</expr></argument>)</argument_list></call></expr>;</return>
</case><default>default:
<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_SystemError</name></expr></argument>,
<argument><expr>"Unknown newlines value 0x%x\n"</expr></argument>,
<argument><expr><name><name>self</name>-&gt;<name>f_newlinetypes</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
</default>}</block></switch>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>BZ2File_get_closed</name><parameter_list>(<param><decl><type><name>BZ2FileObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>void</name> *</type><name>closure</name></decl></param>)</parameter_list> <block>{
<return>return <expr><call><name>PyInt_FromLong</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>mode</name></name> == <name>MODE_CLOSED</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>BZ2File_get_mode</name><parameter_list>(<param><decl><type><name>BZ2FileObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>void</name> *</type><name>closure</name></decl></param>)</parameter_list> <block>{
<return>return <expr><call><name>PyObject_GetAttrString</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>file</name></name></expr></argument>, <argument><expr>"mode"</expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>BZ2File_get_name</name><parameter_list>(<param><decl><type><name>BZ2FileObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>void</name> *</type><name>closure</name></decl></param>)</parameter_list> <block>{
<return>return <expr><call><name>PyObject_GetAttrString</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>file</name></name></expr></argument>, <argument><expr>"name"</expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<decl_stmt><decl><type><specifier>static</specifier> <name>PyGetSetDef</name></type> <name><name>BZ2File_getset</name><index>[]</index></name> <init>= <expr><block>{
<expr><block>{
<expr>"closed"</expr>, <expr>(<name>getter</name>)<name>BZ2File_get_closed</name></expr>, <expr><name>NULL</name></expr>,
<expr>"True if the file is closed"</expr>
}</block></expr>,
<expr><block>{
<expr>"newlines"</expr>, <expr>(<name>getter</name>)<name>BZ2File_get_newlines</name></expr>, <expr><name>NULL</name></expr>,
<expr>"end-of-line convention used in this file"</expr>
}</block></expr>,
<expr><block>{
<expr>"mode"</expr>, <expr>(<name>getter</name>)<name>BZ2File_get_mode</name></expr>, <expr><name>NULL</name></expr>,
<expr>"file mode ('r', 'w', or 'U')"</expr>
}</block></expr>,
<expr><block>{
<expr>"name"</expr>, <expr>(<name>getter</name>)<name>BZ2File_get_name</name></expr>, <expr><name>NULL</name></expr>,
<expr>"file name"</expr>
}</block></expr>,
<expr><block>{<expr><name>NULL</name></expr>}</block></expr>
}</block></expr></init></decl>;</decl_stmt>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>OFF</name></cpp:undef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>OFF</name><parameter_list>(<param><type><name>x</name></type></param>)</parameter_list></cpp:macro> <cpp:value>offsetof(BZ2FileObject, x)</cpp:value></cpp:define>
<decl_stmt><decl><type><specifier>static</specifier> <name>PyMemberDef</name></type> <name><name>BZ2File_members</name><index>[]</index></name> <init>= <expr><block>{
<expr><block>{
<expr>"softspace"</expr>, <expr><name>T_INT</name></expr>, <expr><call><name>OFF</name><argument_list>(<argument><expr><name>f_softspace</name></expr></argument>)</argument_list></call></expr>, <expr>0</expr>,
<expr>"flag indicating that a space needs to be printed; used by print"</expr>
}</block></expr>,
<expr><block>{<expr><name>NULL</name></expr>}</block></expr>
}</block></expr></init></decl>;</decl_stmt>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>BZ2File_init</name><parameter_list>(<param><decl><type><name>BZ2FileObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>kwargs</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> *</type><name><name>kwlist</name><index>[]</index></name> <init>= <expr><block>{<expr>"filename"</expr>, <expr>"mode"</expr>, <expr>"buffering"</expr>,
<expr>"compresslevel"</expr>, <expr>0</expr>
}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>name</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>mode</name> <init>= <expr>"r"</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>buffering</name> <init>= <expr>-1</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>compresslevel</name> <init>= <expr>9</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>bzerror</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>mode_char</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>self</name>-&gt;<name>size</name></name> = -1</expr>;</expr_stmt>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTupleAndKeywords</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>kwargs</name></expr></argument>, <argument><expr>"O|sii:BZ2File"</expr></argument>,
<argument><expr><name>kwlist</name></expr></argument>, <argument><expr>&amp;<name>name</name></expr></argument>, <argument><expr>&amp;<name>mode</name></expr></argument>, <argument><expr>&amp;<name>buffering</name></expr></argument>,
<argument><expr>&amp;<name>compresslevel</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr>-1</expr>;</return></then></if>
<if>if <condition>(<expr><name>compresslevel</name> &lt; 1 || <name>compresslevel</name> &gt; 9</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>,
<argument><expr>"compresslevel must be between 1 and 9"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>-1</expr>;</return>
}</block></then></if>
<for>for (<init>;</init><condition>;</condition><incr/>) <block>{
<decl_stmt><decl><type><name>int</name></type> <name>error</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<switch>switch <condition>(<expr>*<name>mode</name></expr>)</condition> <block>{
<case>case <expr>'r'</expr>:
</case><case>case <expr>'w'</expr>:
<if>if <condition>(<expr><name>mode_char</name></expr>)</condition><then>
<expr_stmt><expr><name>error</name> = 1</expr>;</expr_stmt></then></if>
<expr_stmt><expr><name>mode_char</name> = *<name>mode</name></expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr>'b'</expr>:
<break>break;</break>
</case><case>case <expr>'U'</expr>:
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__VMS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><name><name>self</name>-&gt;<name>f_univ_newline</name></name> = 0</expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<expr_stmt><expr><name><name>self</name>-&gt;<name>f_univ_newline</name></name> = 1</expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<break>break;</break>
</case><default>default:
<expr_stmt><expr><name>error</name> = 1</expr>;</expr_stmt>
<break>break;</break>
</default>}</block></switch>
<if>if <condition>(<expr><name>error</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>,
<argument><expr>"invalid mode char %c"</expr></argument>, <argument><expr>*<name>mode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>-1</expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>mode</name>++</expr>;</expr_stmt>
<if>if <condition>(<expr>*<name>mode</name> == '\0'</expr>)</condition><then>
<break>break;</break></then></if>
}</block></for>
<if>if <condition>(<expr><name>mode_char</name> == 0</expr>)</condition><then> <block>{
<expr_stmt><expr><name>mode_char</name> = 'r'</expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><name>mode</name> = (<name>mode_char</name> == 'r') ? "rb" : "wb"</expr>;</expr_stmt>
<expr_stmt><expr><name><name>self</name>-&gt;<name>file</name></name> = <call><name>PyObject_CallFunction</name><argument_list>(<argument><expr>(<name>PyObject</name>*)&amp;<name>PyFile_Type</name></expr></argument>, <argument><expr>"(Osi)"</expr></argument>,
<argument><expr><name>name</name></expr></argument>, <argument><expr><name>mode</name></expr></argument>, <argument><expr><name>buffering</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>self</name>-&gt;<name>file</name></name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr>-1</expr>;</return></then></if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>WITH_THREAD</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><name><name>self</name>-&gt;<name>lock</name></name> = <call><name>PyThread_allocate_lock</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name><name>self</name>-&gt;<name>lock</name></name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_MemoryError</name></expr></argument>, <argument><expr>"unable to allocate lock"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>error</name>;</goto>
}</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<if>if <condition>(<expr><name>mode_char</name> == 'r'</expr>)</condition><then>
<expr_stmt><expr><name><name>self</name>-&gt;<name>fp</name></name> = <call><name>BZ2_bzReadOpen</name><argument_list>(<argument><expr>&amp;<name>bzerror</name></expr></argument>,
<argument><expr><call><name>PyFile_AsFile</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>file</name></name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
<else>else
<expr_stmt><expr><name><name>self</name>-&gt;<name>fp</name></name> = <call><name>BZ2_bzWriteOpen</name><argument_list>(<argument><expr>&amp;<name>bzerror</name></expr></argument>,
<argument><expr><call><name>PyFile_AsFile</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>file</name></name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>compresslevel</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
<if>if <condition>(<expr><name>bzerror</name> != <name>BZ_OK</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Util_CatchBZ2Error</name><argument_list>(<argument><expr><name>bzerror</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>error</name>;</goto>
}</block></then></if>
<expr_stmt><expr><call><name>PyFile_IncUseCount</name><argument_list>(<argument><expr>(<name>PyFileObject</name> *)<name><name>self</name>-&gt;<name>file</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>self</name>-&gt;<name>mode</name></name> = (<name>mode_char</name> == 'r') ? <name>MODE_READ</name> : <name>MODE_WRITE</name></expr>;</expr_stmt>
<return>return <expr>0</expr>;</return>
<label><name>error</name>:</label>
<expr_stmt><expr><call><name>Py_CLEAR</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>file</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>WITH_THREAD</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if>if <condition>(<expr><name><name>self</name>-&gt;<name>lock</name></name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyThread_free_lock</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>self</name>-&gt;<name>lock</name></name> = <name>NULL</name></expr>;</expr_stmt>
}</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<return>return <expr>-1</expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>BZ2File_dealloc</name><parameter_list>(<param><decl><type><name>BZ2FileObject</name> *</type><name>self</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>bzerror</name></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>WITH_THREAD</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if>if <condition>(<expr><name><name>self</name>-&gt;<name>lock</name></name></expr>)</condition><then>
<expr_stmt><expr><call><name>PyThread_free_lock</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<switch>switch <condition>(<expr><name><name>self</name>-&gt;<name>mode</name></name></expr>)</condition> <block>{
<case>case <expr><name>MODE_READ</name></expr>:
</case><case>case <expr><name>MODE_READ_EOF</name></expr>:
<expr_stmt><expr><call><name>BZ2_bzReadClose</name><argument_list>(<argument><expr>&amp;<name>bzerror</name></expr></argument>, <argument><expr><name><name>self</name>-&gt;<name>fp</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr><name>MODE_WRITE</name></expr>:
<expr_stmt><expr><call><name>BZ2_bzWriteClose</name><argument_list>(<argument><expr>&amp;<name>bzerror</name></expr></argument>, <argument><expr><name><name>self</name>-&gt;<name>fp</name></name></expr></argument>,
<argument><expr>0</expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</case>}</block></switch>
<if>if <condition>(<expr><name><name>self</name>-&gt;<name>fp</name></name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyFile_DecUseCount</name><argument_list>(<argument><expr>(<name>PyFileObject</name> *)<name><name>self</name>-&gt;<name>file</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>self</name>-&gt;<name>fp</name></name> = <name>NULL</name></expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><call><name>Util_DropReadAhead</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>file</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_TYPE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call>-&gt;<call><name>tp_free</name><argument_list>(<argument><expr>(<name>PyObject</name> *)<name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>BZ2File_getiter</name><parameter_list>(<param><decl><type><name>BZ2FileObject</name> *</type><name>self</name></decl></param>)</parameter_list> <block>{
<if>if <condition>(<expr><name><name>self</name>-&gt;<name>mode</name></name> == <name>MODE_CLOSED</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>,
<argument><expr>"I/O operation on closed file"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr>(<name>PyObject</name>*)<name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>(<name>PyObject</name> *)<name>self</name></expr>;</return>
}</block></function>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>READAHEAD_BUFSIZE</name></cpp:macro> <cpp:value>8192</cpp:value></cpp:define>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>BZ2File_iternext</name><parameter_list>(<param><decl><type><name>BZ2FileObject</name> *</type><name>self</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyStringObject</name>*</type> <name>ret</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>ACQUIRE_LOCK</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>self</name>-&gt;<name>mode</name></name> == <name>MODE_CLOSED</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>RELEASE_LOCK</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>,
<argument><expr>"I/O operation on closed file"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>ret</name> = <call><name>Util_ReadAheadGetLineSkip</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>READAHEAD_BUFSIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>RELEASE_LOCK</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>ret</name> == <name>NULL</name> || <call><name>PyString_GET_SIZE</name><argument_list>(<argument><expr><name>ret</name></expr></argument>)</argument_list></call> == 0</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>ret</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<return>return <expr>(<name>PyObject</name> *)<name>ret</name></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_VAR</name><argument_list>(<argument><expr><name>BZ2File__doc__</name></expr></argument>)</argument_list></call> =
<macro><name>PyDoc_STR</name><argument_list>(
<argument>"BZ2File(name [, mode='r', buffering=0, compresslevel=9]) -&gt; file object\n\
\n\
Open a bz2 file. The mode can be 'r' or 'w', for reading (default) or\n\
writing. When opened for writing, the file will be created if it doesn't\n\
exist, and truncated otherwise. If the buffering argument is given, 0 means\n\
unbuffered, and larger numbers specify the buffer size. If compresslevel\n\
is given, must be a number between 1 and 9.\n\
"</argument>)</argument_list></macro>
<call><name>PyDoc_STR</name><argument_list>(
<argument><expr>"\n\
Add a 'U' to mode to open the file for input with universal newline\n\
support. Any line ending in the input file will be seen as a '\\n' in\n\
Python. Also, a file so opened gains the attribute 'newlines'; the value\n\
for this attribute is one of None (no newline read yet), '\\r', '\\n',\n\
'\\r\\n' or a tuple containing all the newline types seen. Universal\n\
newlines are available only when reading.\n\
"</expr></argument>)</argument_list></call></expr>
;</expr_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>PyTypeObject</name></type> <name>BZ2File_Type</name> <init>= <expr><block>{
<expr><call><name>PyVarObject_HEAD_INIT</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call>
"bz2.BZ2File"</expr>,
<expr><sizeof>sizeof<argument_list>(<argument><expr><name>BZ2FileObject</name></expr></argument>)</argument_list></sizeof></expr>,
<expr>0</expr>,
<expr>(<name>destructor</name>)<name>BZ2File_dealloc</name></expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr><name>PyObject_GenericGetAttr</name></expr>,
<expr><name>PyObject_GenericSetAttr</name></expr>,
<expr>0</expr>,
<expr><name>Py_TPFLAGS_DEFAULT</name>|<name>Py_TPFLAGS_BASETYPE</name></expr>,
<expr><name>BZ2File__doc__</name></expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>(<name>getiterfunc</name>)<name>BZ2File_getiter</name></expr>,
<expr>(<name>iternextfunc</name>)<name>BZ2File_iternext</name></expr>,
<expr><name>BZ2File_methods</name></expr>,
<expr><name>BZ2File_members</name></expr>,
<expr><name>BZ2File_getset</name></expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>(<name>initproc</name>)<name>BZ2File_init</name></expr>,
<expr><name>PyType_GenericAlloc</name></expr>,
<expr><name>PyType_GenericNew</name></expr>,
<expr><name>_PyObject_Del</name></expr>,
<expr>0</expr>,
}</block></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>BZ2Comp_compress__doc__</name></expr></argument>,
<argument><expr>"compress(data) -&gt; string\n\
\n\
Provide more data to the compressor object. It will return chunks of\n\
compressed data whenever possible. When you've finished providing data\n\
to compress, call the flush() method to finish the compression process,\n\
and return what is left in the internal buffers.\n\
"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>BZ2Comp_compress</name><parameter_list>(<param><decl><type><name>BZ2CompObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>Py_buffer</name></type> <name>pdata</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>data</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>datasize</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>bufsize</name> <init>= <expr><name>SMALLCHUNK</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PY_LONG_LONG</name></type> <name>totalout</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>ret</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bz_stream</name> *</type><name>bzs</name> <init>= <expr>&amp;<name><name>self</name>-&gt;<name>bzs</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>bzerror</name></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"s*:compress"</expr></argument>, <argument><expr>&amp;<name>pdata</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>data</name> = <name><name>pdata</name>.<name>buf</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>datasize</name> = <name><name>pdata</name>.<name>len</name></name></expr>;</expr_stmt>
<if>if <condition>(<expr><name>datasize</name> == 0</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyBuffer_Release</name><argument_list>(<argument><expr>&amp;<name>pdata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>PyString_FromString</name><argument_list>(<argument><expr>""</expr></argument>)</argument_list></call></expr>;</return>
}</block></then></if>
<expr_stmt><expr><call><name>ACQUIRE_LOCK</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name><name>self</name>-&gt;<name>running</name></name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>,
<argument><expr>"this object was already flushed"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>error</name>;</goto>
}</block></then></if>
<expr_stmt><expr><name>ret</name> = <call><name>PyString_FromStringAndSize</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>bufsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>ret</name></expr>)</condition><then>
<goto>goto <name>error</name>;</goto></then></if>
<expr_stmt><expr><name><name>bzs</name>-&gt;<name>next_in</name></name> = <name>data</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>bzs</name>-&gt;<name>avail_in</name></name> = <name>datasize</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>bzs</name>-&gt;<name>next_out</name></name> = <call><name>BUF</name><argument_list>(<argument><expr><name>ret</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>bzs</name>-&gt;<name>avail_out</name></name> = <name>bufsize</name></expr>;</expr_stmt>
<expr_stmt><expr><name>totalout</name> = <call><name>BZS_TOTAL_OUT</name><argument_list>(<argument><expr><name>bzs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for (<init>;</init><condition>;</condition><incr/>) <block>{
<decl_stmt><decl><type><name>Py_BEGIN_ALLOW_THREADS</name></type>
<name>bzerror</name> <init>= <expr><call><name>BZ2_bzCompress</name><argument_list>(<argument><expr><name>bzs</name></expr></argument>, <argument><expr><name>BZ_RUN</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<macro><name>Py_END_ALLOW_THREADS</name></macro>
<if>if <condition>(<expr><name>bzerror</name> != <name>BZ_RUN_OK</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Util_CatchBZ2Error</name><argument_list>(<argument><expr><name>bzerror</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>error</name>;</goto>
}</block></then></if>
<if>if <condition>(<expr><name><name>bzs</name>-&gt;<name>avail_in</name></name> == 0</expr>)</condition><then>
<break>break;</break></then></if>
<if>if <condition>(<expr><name><name>bzs</name>-&gt;<name>avail_out</name></name> == 0</expr>)</condition><then> <block>{
<expr_stmt><expr><name>bufsize</name> = <call><name>Util_NewBufferSize</name><argument_list>(<argument><expr><name>bufsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>_PyString_Resize</name><argument_list>(<argument><expr>&amp;<name>ret</name></expr></argument>, <argument><expr><name>bufsize</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>BZ2_bzCompressEnd</name><argument_list>(<argument><expr><name>bzs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>error</name>;</goto>
}</block></then></if>
<expr_stmt><expr><name><name>bzs</name>-&gt;<name>next_out</name></name> = <call><name>BUF</name><argument_list>(<argument><expr><name>ret</name></expr></argument>)</argument_list></call> + (<call><name>BZS_TOTAL_OUT</name><argument_list>(<argument><expr><name>bzs</name></expr></argument>)</argument_list></call>
- <name>totalout</name>)</expr>;</expr_stmt>
<expr_stmt><expr><name><name>bzs</name>-&gt;<name>avail_out</name></name> = <name>bufsize</name> - (<name><name>bzs</name>-&gt;<name>next_out</name></name> - <call><name>BUF</name><argument_list>(<argument><expr><name>ret</name></expr></argument>)</argument_list></call>)</expr>;</expr_stmt>
}</block></then></if>
}</block></for>
<expr_stmt><expr><call><name>_PyString_Resize</name><argument_list>(<argument><expr>&amp;<name>ret</name></expr></argument>, <argument><expr><call>(<name>Py_ssize_t</name>)<argument_list>(<argument><expr><call><name>BZS_TOTAL_OUT</name><argument_list>(<argument><expr><name>bzs</name></expr></argument>)</argument_list></call> - <name>totalout</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>RELEASE_LOCK</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyBuffer_Release</name><argument_list>(<argument><expr>&amp;<name>pdata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>ret</name></expr>;</return>
<label><name>error</name>:</label>
<expr_stmt><expr><call><name>RELEASE_LOCK</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyBuffer_Release</name><argument_list>(<argument><expr>&amp;<name>pdata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>ret</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>BZ2Comp_flush__doc__</name></expr></argument>,
<argument><expr>"flush() -&gt; string\n\
\n\
Finish the compression process and return what is left in internal buffers.\n\
You must not use the compressor object after calling this method.\n\
"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>BZ2Comp_flush</name><parameter_list>(<param><decl><type><name>BZ2CompObject</name> *</type><name>self</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>bufsize</name> <init>= <expr><name>SMALLCHUNK</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>ret</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bz_stream</name> *</type><name>bzs</name> <init>= <expr>&amp;<name><name>self</name>-&gt;<name>bzs</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PY_LONG_LONG</name></type> <name>totalout</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>bzerror</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>ACQUIRE_LOCK</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name><name>self</name>-&gt;<name>running</name></name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>, <argument><expr>"object was already "
"flushed"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>error</name>;</goto>
}</block></then></if>
<expr_stmt><expr><name><name>self</name>-&gt;<name>running</name></name> = 0</expr>;</expr_stmt>
<expr_stmt><expr><name>ret</name> = <call><name>PyString_FromStringAndSize</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>bufsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>ret</name></expr>)</condition><then>
<goto>goto <name>error</name>;</goto></then></if>
<expr_stmt><expr><name><name>bzs</name>-&gt;<name>next_out</name></name> = <call><name>BUF</name><argument_list>(<argument><expr><name>ret</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>bzs</name>-&gt;<name>avail_out</name></name> = <name>bufsize</name></expr>;</expr_stmt>
<expr_stmt><expr><name>totalout</name> = <call><name>BZS_TOTAL_OUT</name><argument_list>(<argument><expr><name>bzs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for (<init>;</init><condition>;</condition><incr/>) <block>{
<decl_stmt><decl><type><name>Py_BEGIN_ALLOW_THREADS</name></type>
<name>bzerror</name> <init>= <expr><call><name>BZ2_bzCompress</name><argument_list>(<argument><expr><name>bzs</name></expr></argument>, <argument><expr><name>BZ_FINISH</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<macro><name>Py_END_ALLOW_THREADS</name></macro>
<if>if <condition>(<expr><name>bzerror</name> == <name>BZ_STREAM_END</name></expr>)</condition><then> <block>{
<break>break;</break>
}</block></then> <else>else <if>if <condition>(<expr><name>bzerror</name> != <name>BZ_FINISH_OK</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Util_CatchBZ2Error</name><argument_list>(<argument><expr><name>bzerror</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>error</name>;</goto>
}</block></then></if></else></if>
<if>if <condition>(<expr><name><name>bzs</name>-&gt;<name>avail_out</name></name> == 0</expr>)</condition><then> <block>{
<expr_stmt><expr><name>bufsize</name> = <call><name>Util_NewBufferSize</name><argument_list>(<argument><expr><name>bufsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>_PyString_Resize</name><argument_list>(<argument><expr>&amp;<name>ret</name></expr></argument>, <argument><expr><name>bufsize</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
<goto>goto <name>error</name>;</goto></then></if>
<expr_stmt><expr><name><name>bzs</name>-&gt;<name>next_out</name></name> = <call><name>BUF</name><argument_list>(<argument><expr><name>ret</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>bzs</name>-&gt;<name>next_out</name></name> = <call><name>BUF</name><argument_list>(<argument><expr><name>ret</name></expr></argument>)</argument_list></call> + (<call><name>BZS_TOTAL_OUT</name><argument_list>(<argument><expr><name>bzs</name></expr></argument>)</argument_list></call>
- <name>totalout</name>)</expr>;</expr_stmt>
<expr_stmt><expr><name><name>bzs</name>-&gt;<name>avail_out</name></name> = <name>bufsize</name> - (<name><name>bzs</name>-&gt;<name>next_out</name></name> - <call><name>BUF</name><argument_list>(<argument><expr><name>ret</name></expr></argument>)</argument_list></call>)</expr>;</expr_stmt>
}</block></then></if>
}</block></for>
<if>if <condition>(<expr><name><name>bzs</name>-&gt;<name>avail_out</name></name> != 0</expr>)</condition><then>
<expr_stmt><expr><call><name>_PyString_Resize</name><argument_list>(<argument><expr>&amp;<name>ret</name></expr></argument>, <argument><expr><call>(<name>Py_ssize_t</name>)<argument_list>(<argument><expr><call><name>BZS_TOTAL_OUT</name><argument_list>(<argument><expr><name>bzs</name></expr></argument>)</argument_list></call> - <name>totalout</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<expr_stmt><expr><call><name>RELEASE_LOCK</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>ret</name></expr>;</return>
<label><name>error</name>:</label>
<expr_stmt><expr><call><name>RELEASE_LOCK</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>ret</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></function>
<decl_stmt><decl><type><specifier>static</specifier> <name>PyMethodDef</name></type> <name><name>BZ2Comp_methods</name><index>[]</index></name> <init>= <expr><block>{
<expr><block>{
<expr>"compress"</expr>, <expr>(<name>PyCFunction</name>)<name>BZ2Comp_compress</name></expr>, <expr><name>METH_VARARGS</name></expr>,
<expr><name>BZ2Comp_compress__doc__</name></expr>
}</block></expr>,
<expr><block>{
<expr>"flush"</expr>, <expr>(<name>PyCFunction</name>)<name>BZ2Comp_flush</name></expr>, <expr><name>METH_NOARGS</name></expr>,
<expr><name>BZ2Comp_flush__doc__</name></expr>
}</block></expr>,
<expr><block>{<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>}</block></expr>
}</block></expr></init></decl>;</decl_stmt>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>BZ2Comp_init</name><parameter_list>(<param><decl><type><name>BZ2CompObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>kwargs</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>compresslevel</name> <init>= <expr>9</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>bzerror</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> *</type><name><name>kwlist</name><index>[]</index></name> <init>= <expr><block>{<expr>"compresslevel"</expr>, <expr>0</expr>}</block></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTupleAndKeywords</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>kwargs</name></expr></argument>, <argument><expr>"|i:BZ2Compressor"</expr></argument>,
<argument><expr><name>kwlist</name></expr></argument>, <argument><expr>&amp;<name>compresslevel</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr>-1</expr>;</return></then></if>
<if>if <condition>(<expr><name>compresslevel</name> &lt; 1 || <name>compresslevel</name> &gt; 9</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>,
<argument><expr>"compresslevel must be between 1 and 9"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>error</name>;</goto>
}</block></then></if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>WITH_THREAD</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><name><name>self</name>-&gt;<name>lock</name></name> = <call><name>PyThread_allocate_lock</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name><name>self</name>-&gt;<name>lock</name></name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_MemoryError</name></expr></argument>, <argument><expr>"unable to allocate lock"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>error</name>;</goto>
}</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr>&amp;<name><name>self</name>-&gt;<name>bzs</name></name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>bz_stream</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>bzerror</name> = <call><name>BZ2_bzCompressInit</name><argument_list>(<argument><expr>&amp;<name><name>self</name>-&gt;<name>bzs</name></name></expr></argument>, <argument><expr><name>compresslevel</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>bzerror</name> != <name>BZ_OK</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Util_CatchBZ2Error</name><argument_list>(<argument><expr><name>bzerror</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>error</name>;</goto>
}</block></then></if>
<expr_stmt><expr><name><name>self</name>-&gt;<name>running</name></name> = 1</expr>;</expr_stmt>
<return>return <expr>0</expr>;</return>
<label><name>error</name>:</label>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>WITH_THREAD</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if>if <condition>(<expr><name><name>self</name>-&gt;<name>lock</name></name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyThread_free_lock</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>self</name>-&gt;<name>lock</name></name> = <name>NULL</name></expr>;</expr_stmt>
}</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<return>return <expr>-1</expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>BZ2Comp_dealloc</name><parameter_list>(<param><decl><type><name>BZ2CompObject</name> *</type><name>self</name></decl></param>)</parameter_list> <block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>WITH_THREAD</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if>if <condition>(<expr><name><name>self</name>-&gt;<name>lock</name></name></expr>)</condition><then>
<expr_stmt><expr><call><name>PyThread_free_lock</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><call><name>BZ2_bzCompressEnd</name><argument_list>(<argument><expr>&amp;<name><name>self</name>-&gt;<name>bzs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_TYPE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call>-&gt;<call><name>tp_free</name><argument_list>(<argument><expr>(<name>PyObject</name> *)<name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>BZ2Comp__doc__</name></expr></argument>,
<argument><expr>"BZ2Compressor([compresslevel=9]) -&gt; compressor object\n\
\n\
Create a new compressor object. This object may be used to compress\n\
data sequentially. If you want to compress data in one shot, use the\n\
compress() function instead. The compresslevel parameter, if given,\n\
must be a number between 1 and 9.\n\
"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>PyTypeObject</name></type> <name>BZ2Comp_Type</name> <init>= <expr><block>{
<expr><call><name>PyVarObject_HEAD_INIT</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call>
"bz2.BZ2Compressor"</expr>,
<expr><sizeof>sizeof<argument_list>(<argument><expr><name>BZ2CompObject</name></expr></argument>)</argument_list></sizeof></expr>,
<expr>0</expr>,
<expr>(<name>destructor</name>)<name>BZ2Comp_dealloc</name></expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr><name>PyObject_GenericGetAttr</name></expr>,
<expr><name>PyObject_GenericSetAttr</name></expr>,
<expr>0</expr>,
<expr><name>Py_TPFLAGS_DEFAULT</name>|<name>Py_TPFLAGS_BASETYPE</name></expr>,
<expr><name>BZ2Comp__doc__</name></expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr><name>BZ2Comp_methods</name></expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>(<name>initproc</name>)<name>BZ2Comp_init</name></expr>,
<expr><name>PyType_GenericAlloc</name></expr>,
<expr><name>PyType_GenericNew</name></expr>,
<expr><name>_PyObject_Del</name></expr>,
<expr>0</expr>,
}</block></expr></init></decl>;</decl_stmt>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>OFF</name></cpp:undef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>OFF</name><parameter_list>(<param><type><name>x</name></type></param>)</parameter_list></cpp:macro> <cpp:value>offsetof(BZ2DecompObject, x)</cpp:value></cpp:define>
<decl_stmt><decl><type><specifier>static</specifier> <name>PyMemberDef</name></type> <name><name>BZ2Decomp_members</name><index>[]</index></name> <init>= <expr><block>{
<expr><block>{<expr>"unused_data"</expr>, <expr><name>T_OBJECT</name></expr>, <expr><call><name>OFF</name><argument_list>(<argument><expr><name>unused_data</name></expr></argument>)</argument_list></call></expr>, <expr><name>RO</name></expr>}</block></expr>,
<expr><block>{<expr><name>NULL</name></expr>}</block></expr>
}</block></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>BZ2Decomp_decompress__doc__</name></expr></argument>,
<argument><expr>"decompress(data) -&gt; string\n\
\n\
Provide more data to the decompressor object. It will return chunks\n\
of decompressed data whenever possible. If you try to decompress data\n\
after the end of stream is found, EOFError will be raised. If any data\n\
was found after the end of stream, it'll be ignored and saved in\n\
unused_data attribute.\n\
"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>BZ2Decomp_decompress</name><parameter_list>(<param><decl><type><name>BZ2DecompObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>Py_buffer</name></type> <name>pdata</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>data</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>datasize</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>bufsize</name> <init>= <expr><name>SMALLCHUNK</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PY_LONG_LONG</name></type> <name>totalout</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>ret</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bz_stream</name> *</type><name>bzs</name> <init>= <expr>&amp;<name><name>self</name>-&gt;<name>bzs</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>bzerror</name></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"s*:decompress"</expr></argument>, <argument><expr>&amp;<name>pdata</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>data</name> = <name><name>pdata</name>.<name>buf</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>datasize</name> = <name><name>pdata</name>.<name>len</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ACQUIRE_LOCK</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name><name>self</name>-&gt;<name>running</name></name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_EOFError</name></expr></argument>, <argument><expr>"end of stream was "
"already found"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>error</name>;</goto>
}</block></then></if>
<expr_stmt><expr><name>ret</name> = <call><name>PyString_FromStringAndSize</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>bufsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>ret</name></expr>)</condition><then>
<goto>goto <name>error</name>;</goto></then></if>
<expr_stmt><expr><name><name>bzs</name>-&gt;<name>next_in</name></name> = <name>data</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>bzs</name>-&gt;<name>avail_in</name></name> = <name>datasize</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>bzs</name>-&gt;<name>next_out</name></name> = <call><name>BUF</name><argument_list>(<argument><expr><name>ret</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>bzs</name>-&gt;<name>avail_out</name></name> = <name>bufsize</name></expr>;</expr_stmt>
<expr_stmt><expr><name>totalout</name> = <call><name>BZS_TOTAL_OUT</name><argument_list>(<argument><expr><name>bzs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for (<init>;</init><condition>;</condition><incr/>) <block>{
<decl_stmt><decl><type><name>Py_BEGIN_ALLOW_THREADS</name></type>
<name>bzerror</name> <init>= <expr><call><name>BZ2_bzDecompress</name><argument_list>(<argument><expr><name>bzs</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<macro><name>Py_END_ALLOW_THREADS</name></macro>
<if>if <condition>(<expr><name>bzerror</name> == <name>BZ_STREAM_END</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr><name><name>bzs</name>-&gt;<name>avail_in</name></name> != 0</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>unused_data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>self</name>-&gt;<name>unused_data</name></name> =
<call><name>PyString_FromStringAndSize</name><argument_list>(<argument><expr><name><name>bzs</name>-&gt;<name>next_in</name></name></expr></argument>,
<argument><expr><name><name>bzs</name>-&gt;<name>avail_in</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><name><name>self</name>-&gt;<name>running</name></name> = 0</expr>;</expr_stmt>
<break>break;</break>
}</block></then></if>
<if>if <condition>(<expr><name>bzerror</name> != <name>BZ_OK</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Util_CatchBZ2Error</name><argument_list>(<argument><expr><name>bzerror</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>error</name>;</goto>
}</block></then></if>
<if>if <condition>(<expr><name><name>bzs</name>-&gt;<name>avail_in</name></name> == 0</expr>)</condition><then>
<break>break;</break></then></if>
<if>if <condition>(<expr><name><name>bzs</name>-&gt;<name>avail_out</name></name> == 0</expr>)</condition><then> <block>{
<expr_stmt><expr><name>bufsize</name> = <call><name>Util_NewBufferSize</name><argument_list>(<argument><expr><name>bufsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>_PyString_Resize</name><argument_list>(<argument><expr>&amp;<name>ret</name></expr></argument>, <argument><expr><name>bufsize</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>BZ2_bzDecompressEnd</name><argument_list>(<argument><expr><name>bzs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>error</name>;</goto>
}</block></then></if>
<expr_stmt><expr><name><name>bzs</name>-&gt;<name>next_out</name></name> = <call><name>BUF</name><argument_list>(<argument><expr><name>ret</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>bzs</name>-&gt;<name>next_out</name></name> = <call><name>BUF</name><argument_list>(<argument><expr><name>ret</name></expr></argument>)</argument_list></call> + (<call><name>BZS_TOTAL_OUT</name><argument_list>(<argument><expr><name>bzs</name></expr></argument>)</argument_list></call>
- <name>totalout</name>)</expr>;</expr_stmt>
<expr_stmt><expr><name><name>bzs</name>-&gt;<name>avail_out</name></name> = <name>bufsize</name> - (<name><name>bzs</name>-&gt;<name>next_out</name></name> - <call><name>BUF</name><argument_list>(<argument><expr><name>ret</name></expr></argument>)</argument_list></call>)</expr>;</expr_stmt>
}</block></then></if>
}</block></for>
<if>if <condition>(<expr><name><name>bzs</name>-&gt;<name>avail_out</name></name> != 0</expr>)</condition><then>
<expr_stmt><expr><call><name>_PyString_Resize</name><argument_list>(<argument><expr>&amp;<name>ret</name></expr></argument>, <argument><expr><call>(<name>Py_ssize_t</name>)<argument_list>(<argument><expr><call><name>BZS_TOTAL_OUT</name><argument_list>(<argument><expr><name>bzs</name></expr></argument>)</argument_list></call> - <name>totalout</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<expr_stmt><expr><call><name>RELEASE_LOCK</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyBuffer_Release</name><argument_list>(<argument><expr>&amp;<name>pdata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>ret</name></expr>;</return>
<label><name>error</name>:</label>
<expr_stmt><expr><call><name>RELEASE_LOCK</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyBuffer_Release</name><argument_list>(<argument><expr>&amp;<name>pdata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>ret</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></function>
<decl_stmt><decl><type><specifier>static</specifier> <name>PyMethodDef</name></type> <name><name>BZ2Decomp_methods</name><index>[]</index></name> <init>= <expr><block>{
<expr><block>{<expr>"decompress"</expr>, <expr>(<name>PyCFunction</name>)<name>BZ2Decomp_decompress</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>BZ2Decomp_decompress__doc__</name></expr>}</block></expr>,
<expr><block>{<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>}</block></expr>
}</block></expr></init></decl>;</decl_stmt>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>BZ2Decomp_init</name><parameter_list>(<param><decl><type><name>BZ2DecompObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>kwargs</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>bzerror</name></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>":BZ2Decompressor"</expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr>-1</expr>;</return></then></if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>WITH_THREAD</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><name><name>self</name>-&gt;<name>lock</name></name> = <call><name>PyThread_allocate_lock</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name><name>self</name>-&gt;<name>lock</name></name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_MemoryError</name></expr></argument>, <argument><expr>"unable to allocate lock"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>error</name>;</goto>
}</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><name><name>self</name>-&gt;<name>unused_data</name></name> = <call><name>PyString_FromString</name><argument_list>(<argument><expr>""</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name><name>self</name>-&gt;<name>unused_data</name></name></expr>)</condition><then>
<goto>goto <name>error</name>;</goto></then></if>
<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr>&amp;<name><name>self</name>-&gt;<name>bzs</name></name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>bz_stream</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>bzerror</name> = <call><name>BZ2_bzDecompressInit</name><argument_list>(<argument><expr>&amp;<name><name>self</name>-&gt;<name>bzs</name></name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>bzerror</name> != <name>BZ_OK</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Util_CatchBZ2Error</name><argument_list>(<argument><expr><name>bzerror</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>error</name>;</goto>
}</block></then></if>
<expr_stmt><expr><name><name>self</name>-&gt;<name>running</name></name> = 1</expr>;</expr_stmt>
<return>return <expr>0</expr>;</return>
<label><name>error</name>:</label>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>WITH_THREAD</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if>if <condition>(<expr><name><name>self</name>-&gt;<name>lock</name></name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyThread_free_lock</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>self</name>-&gt;<name>lock</name></name> = <name>NULL</name></expr>;</expr_stmt>
}</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><call><name>Py_CLEAR</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>unused_data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>-1</expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>BZ2Decomp_dealloc</name><parameter_list>(<param><decl><type><name>BZ2DecompObject</name> *</type><name>self</name></decl></param>)</parameter_list> <block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>WITH_THREAD</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if>if <condition>(<expr><name><name>self</name>-&gt;<name>lock</name></name></expr>)</condition><then>
<expr_stmt><expr><call><name>PyThread_free_lock</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>unused_data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>BZ2_bzDecompressEnd</name><argument_list>(<argument><expr>&amp;<name><name>self</name>-&gt;<name>bzs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_TYPE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call>-&gt;<call><name>tp_free</name><argument_list>(<argument><expr>(<name>PyObject</name> *)<name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>BZ2Decomp__doc__</name></expr></argument>,
<argument><expr>"BZ2Decompressor() -&gt; decompressor object\n\
\n\
Create a new decompressor object. This object may be used to decompress\n\
data sequentially. If you want to decompress data in one shot, use the\n\
decompress() function instead.\n\
"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>PyTypeObject</name></type> <name>BZ2Decomp_Type</name> <init>= <expr><block>{
<expr><call><name>PyVarObject_HEAD_INIT</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call>
"bz2.BZ2Decompressor"</expr>,
<expr><sizeof>sizeof<argument_list>(<argument><expr><name>BZ2DecompObject</name></expr></argument>)</argument_list></sizeof></expr>,
<expr>0</expr>,
<expr>(<name>destructor</name>)<name>BZ2Decomp_dealloc</name></expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr><name>PyObject_GenericGetAttr</name></expr>,
<expr><name>PyObject_GenericSetAttr</name></expr>,
<expr>0</expr>,
<expr><name>Py_TPFLAGS_DEFAULT</name>|<name>Py_TPFLAGS_BASETYPE</name></expr>,
<expr><name>BZ2Decomp__doc__</name></expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr><name>BZ2Decomp_methods</name></expr>,
<expr><name>BZ2Decomp_members</name></expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>(<name>initproc</name>)<name>BZ2Decomp_init</name></expr>,
<expr><name>PyType_GenericAlloc</name></expr>,
<expr><name>PyType_GenericNew</name></expr>,
<expr><name>_PyObject_Del</name></expr>,
<expr>0</expr>,
}</block></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>bz2_compress__doc__</name></expr></argument>,
<argument><expr>"compress(data [, compresslevel=9]) -&gt; string\n\
\n\
Compress data in one shot. If you want to compress data sequentially,\n\
use an instance of BZ2Compressor instead. The compresslevel parameter, if\n\
given, must be a number between 1 and 9.\n\
"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>bz2_compress</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>kwargs</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>compresslevel</name><init>=<expr>9</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_buffer</name></type> <name>pdata</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>data</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>datasize</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>bufsize</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>ret</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bz_stream</name></type> <name>_bzs</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bz_stream</name> *</type><name>bzs</name> <init>= <expr>&amp;<name>_bzs</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>bzerror</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> *</type><name><name>kwlist</name><index>[]</index></name> <init>= <expr><block>{<expr>"data"</expr>, <expr>"compresslevel"</expr>, <expr>0</expr>}</block></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTupleAndKeywords</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>kwargs</name></expr></argument>, <argument><expr>"s*|i"</expr></argument>,
<argument><expr><name>kwlist</name></expr></argument>, <argument><expr>&amp;<name>pdata</name></expr></argument>,
<argument><expr>&amp;<name>compresslevel</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>data</name> = <name><name>pdata</name>.<name>buf</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>datasize</name> = <name><name>pdata</name>.<name>len</name></name></expr>;</expr_stmt>
<if>if <condition>(<expr><name>compresslevel</name> &lt; 1 || <name>compresslevel</name> &gt; 9</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>,
<argument><expr>"compresslevel must be between 1 and 9"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyBuffer_Release</name><argument_list>(<argument><expr>&amp;<name>pdata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>bufsize</name> = <name>datasize</name> + (<name>datasize</name>/100+1) + 600</expr>;</expr_stmt>
<expr_stmt><expr><name>ret</name> = <call><name>PyString_FromStringAndSize</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>bufsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>ret</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyBuffer_Release</name><argument_list>(<argument><expr>&amp;<name>pdata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>bzs</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>bz_stream</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>bzs</name>-&gt;<name>next_in</name></name> = <name>data</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>bzs</name>-&gt;<name>avail_in</name></name> = <name>datasize</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>bzs</name>-&gt;<name>next_out</name></name> = <call><name>BUF</name><argument_list>(<argument><expr><name>ret</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>bzs</name>-&gt;<name>avail_out</name></name> = <name>bufsize</name></expr>;</expr_stmt>
<expr_stmt><expr><name>bzerror</name> = <call><name>BZ2_bzCompressInit</name><argument_list>(<argument><expr><name>bzs</name></expr></argument>, <argument><expr><name>compresslevel</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>bzerror</name> != <name>BZ_OK</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Util_CatchBZ2Error</name><argument_list>(<argument><expr><name>bzerror</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyBuffer_Release</name><argument_list>(<argument><expr>&amp;<name>pdata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>ret</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<for>for (<init>;</init><condition>;</condition><incr/>) <block>{
<decl_stmt><decl><type><name>Py_BEGIN_ALLOW_THREADS</name></type>
<name>bzerror</name> <init>= <expr><call><name>BZ2_bzCompress</name><argument_list>(<argument><expr><name>bzs</name></expr></argument>, <argument><expr><name>BZ_FINISH</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<macro><name>Py_END_ALLOW_THREADS</name></macro>
<if>if <condition>(<expr><name>bzerror</name> == <name>BZ_STREAM_END</name></expr>)</condition><then> <block>{
<break>break;</break>
}</block></then> <else>else <if>if <condition>(<expr><name>bzerror</name> != <name>BZ_FINISH_OK</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>BZ2_bzCompressEnd</name><argument_list>(<argument><expr><name>bzs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Util_CatchBZ2Error</name><argument_list>(<argument><expr><name>bzerror</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyBuffer_Release</name><argument_list>(<argument><expr>&amp;<name>pdata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>ret</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if></else></if>
<if>if <condition>(<expr><name><name>bzs</name>-&gt;<name>avail_out</name></name> == 0</expr>)</condition><then> <block>{
<expr_stmt><expr><name>bufsize</name> = <call><name>Util_NewBufferSize</name><argument_list>(<argument><expr><name>bufsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>_PyString_Resize</name><argument_list>(<argument><expr>&amp;<name>ret</name></expr></argument>, <argument><expr><name>bufsize</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>BZ2_bzCompressEnd</name><argument_list>(<argument><expr><name>bzs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyBuffer_Release</name><argument_list>(<argument><expr>&amp;<name>pdata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>ret</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name><name>bzs</name>-&gt;<name>next_out</name></name> = <call><name>BUF</name><argument_list>(<argument><expr><name>ret</name></expr></argument>)</argument_list></call> + <call><name>BZS_TOTAL_OUT</name><argument_list>(<argument><expr><name>bzs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>bzs</name>-&gt;<name>avail_out</name></name> = <name>bufsize</name> - (<name><name>bzs</name>-&gt;<name>next_out</name></name> - <call><name>BUF</name><argument_list>(<argument><expr><name>ret</name></expr></argument>)</argument_list></call>)</expr>;</expr_stmt>
}</block></then></if>
}</block></for>
<if>if <condition>(<expr><name><name>bzs</name>-&gt;<name>avail_out</name></name> != 0</expr>)</condition><then>
<expr_stmt><expr><call><name>_PyString_Resize</name><argument_list>(<argument><expr>&amp;<name>ret</name></expr></argument>, <argument><expr>(<name>Py_ssize_t</name>)<call><name>BZS_TOTAL_OUT</name><argument_list>(<argument><expr><name>bzs</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<expr_stmt><expr><call><name>BZ2_bzCompressEnd</name><argument_list>(<argument><expr><name>bzs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyBuffer_Release</name><argument_list>(<argument><expr>&amp;<name>pdata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>ret</name></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>bz2_decompress__doc__</name></expr></argument>,
<argument><expr>"decompress(data) -&gt; decompressed data\n\
\n\
Decompress data in one shot. If you want to decompress data sequentially,\n\
use an instance of BZ2Decompressor instead.\n\
"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>bz2_decompress</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>Py_buffer</name></type> <name>pdata</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>data</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>datasize</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>bufsize</name> <init>= <expr><name>SMALLCHUNK</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>ret</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bz_stream</name></type> <name>_bzs</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bz_stream</name> *</type><name>bzs</name> <init>= <expr>&amp;<name>_bzs</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>bzerror</name></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"s*:decompress"</expr></argument>, <argument><expr>&amp;<name>pdata</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>data</name> = <name><name>pdata</name>.<name>buf</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>datasize</name> = <name><name>pdata</name>.<name>len</name></name></expr>;</expr_stmt>
<if>if <condition>(<expr><name>datasize</name> == 0</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyBuffer_Release</name><argument_list>(<argument><expr>&amp;<name>pdata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>PyString_FromString</name><argument_list>(<argument><expr>""</expr></argument>)</argument_list></call></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>ret</name> = <call><name>PyString_FromStringAndSize</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>bufsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>ret</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyBuffer_Release</name><argument_list>(<argument><expr>&amp;<name>pdata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>bzs</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>bz_stream</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>bzs</name>-&gt;<name>next_in</name></name> = <name>data</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>bzs</name>-&gt;<name>avail_in</name></name> = <name>datasize</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>bzs</name>-&gt;<name>next_out</name></name> = <call><name>BUF</name><argument_list>(<argument><expr><name>ret</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>bzs</name>-&gt;<name>avail_out</name></name> = <name>bufsize</name></expr>;</expr_stmt>
<expr_stmt><expr><name>bzerror</name> = <call><name>BZ2_bzDecompressInit</name><argument_list>(<argument><expr><name>bzs</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>bzerror</name> != <name>BZ_OK</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Util_CatchBZ2Error</name><argument_list>(<argument><expr><name>bzerror</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>ret</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyBuffer_Release</name><argument_list>(<argument><expr>&amp;<name>pdata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<for>for (<init>;</init><condition>;</condition><incr/>) <block>{
<decl_stmt><decl><type><name>Py_BEGIN_ALLOW_THREADS</name></type>
<name>bzerror</name> <init>= <expr><call><name>BZ2_bzDecompress</name><argument_list>(<argument><expr><name>bzs</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<macro><name>Py_END_ALLOW_THREADS</name></macro>
<if>if <condition>(<expr><name>bzerror</name> == <name>BZ_STREAM_END</name></expr>)</condition><then> <block>{
<break>break;</break>
}</block></then> <else>else <if>if <condition>(<expr><name>bzerror</name> != <name>BZ_OK</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>BZ2_bzDecompressEnd</name><argument_list>(<argument><expr><name>bzs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Util_CatchBZ2Error</name><argument_list>(<argument><expr><name>bzerror</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyBuffer_Release</name><argument_list>(<argument><expr>&amp;<name>pdata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>ret</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if></else></if>
<if>if <condition>(<expr><name><name>bzs</name>-&gt;<name>avail_in</name></name> == 0</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>BZ2_bzDecompressEnd</name><argument_list>(<argument><expr><name>bzs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>,
<argument><expr>"couldn't find end of stream"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyBuffer_Release</name><argument_list>(<argument><expr>&amp;<name>pdata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>ret</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<if>if <condition>(<expr><name><name>bzs</name>-&gt;<name>avail_out</name></name> == 0</expr>)</condition><then> <block>{
<expr_stmt><expr><name>bufsize</name> = <call><name>Util_NewBufferSize</name><argument_list>(<argument><expr><name>bufsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>_PyString_Resize</name><argument_list>(<argument><expr>&amp;<name>ret</name></expr></argument>, <argument><expr><name>bufsize</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>BZ2_bzDecompressEnd</name><argument_list>(<argument><expr><name>bzs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyBuffer_Release</name><argument_list>(<argument><expr>&amp;<name>pdata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>ret</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name><name>bzs</name>-&gt;<name>next_out</name></name> = <call><name>BUF</name><argument_list>(<argument><expr><name>ret</name></expr></argument>)</argument_list></call> + <call><name>BZS_TOTAL_OUT</name><argument_list>(<argument><expr><name>bzs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>bzs</name>-&gt;<name>avail_out</name></name> = <name>bufsize</name> - (<name><name>bzs</name>-&gt;<name>next_out</name></name> - <call><name>BUF</name><argument_list>(<argument><expr><name>ret</name></expr></argument>)</argument_list></call>)</expr>;</expr_stmt>
}</block></then></if>
}</block></for>
<if>if <condition>(<expr><name><name>bzs</name>-&gt;<name>avail_out</name></name> != 0</expr>)</condition><then>
<expr_stmt><expr><call><name>_PyString_Resize</name><argument_list>(<argument><expr>&amp;<name>ret</name></expr></argument>, <argument><expr>(<name>Py_ssize_t</name>)<call><name>BZS_TOTAL_OUT</name><argument_list>(<argument><expr><name>bzs</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<expr_stmt><expr><call><name>BZ2_bzDecompressEnd</name><argument_list>(<argument><expr><name>bzs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyBuffer_Release</name><argument_list>(<argument><expr>&amp;<name>pdata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>ret</name></expr>;</return>
}</block></function>
<decl_stmt><decl><type><specifier>static</specifier> <name>PyMethodDef</name></type> <name><name>bz2_methods</name><index>[]</index></name> <init>= <expr><block>{
<expr><block>{
<expr>"compress"</expr>, <expr>(<name>PyCFunction</name>) <name>bz2_compress</name></expr>, <expr><name>METH_VARARGS</name>|<name>METH_KEYWORDS</name></expr>,
<expr><name>bz2_compress__doc__</name></expr>
}</block></expr>,
<expr><block>{
<expr>"decompress"</expr>, <expr>(<name>PyCFunction</name>) <name>bz2_decompress</name></expr>, <expr><name>METH_VARARGS</name></expr>,
<expr><name>bz2_decompress__doc__</name></expr>
}</block></expr>,
<expr><block>{<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>}</block></expr>
}</block></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>bz2__doc__</name></expr></argument>,
<argument><expr>"The python bz2 module provides a comprehensive interface for\n\
the bz2 compression library. It implements a complete file\n\
interface, one shot (de)compression functions, and types for\n\
sequential (de)compression.\n\
"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><name>PyMODINIT_FUNC</name></type>
<name>initbz2</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>m</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>Py_TYPE</name><argument_list>(<argument><expr>&amp;<name>BZ2File_Type</name></expr></argument>)</argument_list></call> = &amp;<name>PyType_Type</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_TYPE</name><argument_list>(<argument><expr>&amp;<name>BZ2Comp_Type</name></expr></argument>)</argument_list></call> = &amp;<name>PyType_Type</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_TYPE</name><argument_list>(<argument><expr>&amp;<name>BZ2Decomp_Type</name></expr></argument>)</argument_list></call> = &amp;<name>PyType_Type</name></expr>;</expr_stmt>
<expr_stmt><expr><name>m</name> = <call><name>Py_InitModule3</name><argument_list>(<argument><expr>"bz2"</expr></argument>, <argument><expr><name>bz2_methods</name></expr></argument>, <argument><expr><name>bz2__doc__</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>m</name> == <name>NULL</name></expr>)</condition><then>
<return>return;</return></then></if>
<expr_stmt><expr><call><name>PyModule_AddObject</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"__author__"</expr></argument>, <argument><expr><call><name>PyString_FromString</name><argument_list>(<argument><expr><name>__author__</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr>&amp;<name>BZ2File_Type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyModule_AddObject</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"BZ2File"</expr></argument>, <argument><expr>(<name>PyObject</name> *)&amp;<name>BZ2File_Type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr>&amp;<name>BZ2Comp_Type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyModule_AddObject</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"BZ2Compressor"</expr></argument>, <argument><expr>(<name>PyObject</name> *)&amp;<name>BZ2Comp_Type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr>&amp;<name>BZ2Decomp_Type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyModule_AddObject</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"BZ2Decompressor"</expr></argument>, <argument><expr>(<name>PyObject</name> *)&amp;<name>BZ2Decomp_Type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>
</unit>
