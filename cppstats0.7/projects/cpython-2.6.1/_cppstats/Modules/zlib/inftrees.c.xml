<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C" filename="projects/cpython-2.6.1/_cppstats/Modules/zlib/inftrees.c"><cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"zutil.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"inftrees.h"</cpp:file></cpp:include>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAXBITS</name></cpp:macro> <cpp:value>15</cpp:value></cpp:define>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name></type> <name><name>inflate_copyright</name><index>[]</index></name> <init>=
<expr>" inflate 1.2.3 Copyright 1995-2005 Mark Adler "</expr></init></decl>;</decl_stmt>
<function><type><name>int</name></type> <name>inflate_table</name><parameter_list>(<param><decl><type><name>type</name></type></decl></param>, <param><decl><type><name>lens</name></type></decl></param>, <param><decl><type><name>codes</name></type></decl></param>, <param><decl><type><name>table</name></type></decl></param>, <param><decl><type><name>bits</name></type></decl></param>, <param><decl><type><name>work</name></type></decl></param>)</parameter_list>
<decl_stmt><decl><type><name>codetype</name></type> <name>type</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>short</name> <name>FAR</name> *</type><name>lens</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name></type> <name>codes</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>code</name> <name>FAR</name> * <name>FAR</name> *</type><name>table</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>FAR</name> *</type><name>bits</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>short</name> <name>FAR</name> *</type><name>work</name></decl>;</decl_stmt>
<block>{
<decl_stmt><decl><type><name>unsigned</name></type> <name>len</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name></type> <name>sym</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name></type> <name>min</name></decl>, <decl><type ref="prev"/><name>max</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name></type> <name>root</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name></type> <name>curr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name></type> <name>drop</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>left</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name></type> <name>used</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name></type> <name>huff</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name></type> <name>incr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name></type> <name>fill</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name></type> <name>low</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name></type> <name>mask</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>code</name></type> <name>this</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>code</name> <name>FAR</name> *</type><name>next</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>short</name> <name>FAR</name> *</type><name>base</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>short</name> <name>FAR</name> *</type><name>extra</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>end</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>short</name></type> <name><name>count</name><index>[<expr><name>MAXBITS</name>+1</expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>short</name></type> <name><name>offs</name><index>[<expr><name>MAXBITS</name>+1</expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>unsigned</name> <name>short</name></type> <name><name>lbase</name><index>[<expr>31</expr>]</index></name> <init>= <expr><block>{
<expr>3</expr>, <expr>4</expr>, <expr>5</expr>, <expr>6</expr>, <expr>7</expr>, <expr>8</expr>, <expr>9</expr>, <expr>10</expr>, <expr>11</expr>, <expr>13</expr>, <expr>15</expr>, <expr>17</expr>, <expr>19</expr>, <expr>23</expr>, <expr>27</expr>, <expr>31</expr>,
<expr>35</expr>, <expr>43</expr>, <expr>51</expr>, <expr>59</expr>, <expr>67</expr>, <expr>83</expr>, <expr>99</expr>, <expr>115</expr>, <expr>131</expr>, <expr>163</expr>, <expr>195</expr>, <expr>227</expr>, <expr>258</expr>, <expr>0</expr>, <expr>0</expr>
}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>unsigned</name> <name>short</name></type> <name><name>lext</name><index>[<expr>31</expr>]</index></name> <init>= <expr><block>{
<expr>16</expr>, <expr>16</expr>, <expr>16</expr>, <expr>16</expr>, <expr>16</expr>, <expr>16</expr>, <expr>16</expr>, <expr>16</expr>, <expr>17</expr>, <expr>17</expr>, <expr>17</expr>, <expr>17</expr>, <expr>18</expr>, <expr>18</expr>, <expr>18</expr>, <expr>18</expr>,
<expr>19</expr>, <expr>19</expr>, <expr>19</expr>, <expr>19</expr>, <expr>20</expr>, <expr>20</expr>, <expr>20</expr>, <expr>20</expr>, <expr>21</expr>, <expr>21</expr>, <expr>21</expr>, <expr>21</expr>, <expr>16</expr>, <expr>201</expr>, <expr>196</expr>
}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>unsigned</name> <name>short</name></type> <name><name>dbase</name><index>[<expr>32</expr>]</index></name> <init>= <expr><block>{
<expr>1</expr>, <expr>2</expr>, <expr>3</expr>, <expr>4</expr>, <expr>5</expr>, <expr>7</expr>, <expr>9</expr>, <expr>13</expr>, <expr>17</expr>, <expr>25</expr>, <expr>33</expr>, <expr>49</expr>, <expr>65</expr>, <expr>97</expr>, <expr>129</expr>, <expr>193</expr>,
<expr>257</expr>, <expr>385</expr>, <expr>513</expr>, <expr>769</expr>, <expr>1025</expr>, <expr>1537</expr>, <expr>2049</expr>, <expr>3073</expr>, <expr>4097</expr>, <expr>6145</expr>,
<expr>8193</expr>, <expr>12289</expr>, <expr>16385</expr>, <expr>24577</expr>, <expr>0</expr>, <expr>0</expr>
}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>unsigned</name> <name>short</name></type> <name><name>dext</name><index>[<expr>32</expr>]</index></name> <init>= <expr><block>{
<expr>16</expr>, <expr>16</expr>, <expr>16</expr>, <expr>16</expr>, <expr>17</expr>, <expr>17</expr>, <expr>18</expr>, <expr>18</expr>, <expr>19</expr>, <expr>19</expr>, <expr>20</expr>, <expr>20</expr>, <expr>21</expr>, <expr>21</expr>, <expr>22</expr>, <expr>22</expr>,
<expr>23</expr>, <expr>23</expr>, <expr>24</expr>, <expr>24</expr>, <expr>25</expr>, <expr>25</expr>, <expr>26</expr>, <expr>26</expr>, <expr>27</expr>, <expr>27</expr>,
<expr>28</expr>, <expr>28</expr>, <expr>29</expr>, <expr>29</expr>, <expr>64</expr>, <expr>64</expr>
}</block></expr></init></decl>;</decl_stmt>
<for>for (<init><expr><name>len</name> = 0</expr>;</init> <condition><expr><name>len</name> &lt;= <name>MAXBITS</name></expr>;</condition> <incr><expr><name>len</name>++</expr></incr>)
<expr_stmt><expr><name><name>count</name><index>[<expr><name>len</name></expr>]</index></name> = 0</expr>;</expr_stmt></for>
<for>for (<init><expr><name>sym</name> = 0</expr>;</init> <condition><expr><name>sym</name> &lt; <name>codes</name></expr>;</condition> <incr><expr><name>sym</name>++</expr></incr>)
<expr_stmt><expr><name><name>count</name><index>[<expr><name><name>lens</name><index>[<expr><name>sym</name></expr>]</index></name></expr>]</index></name>++</expr>;</expr_stmt></for>
<expr_stmt><expr><name>root</name> = *<name>bits</name></expr>;</expr_stmt>
<for>for (<init><expr><name>max</name> = <name>MAXBITS</name></expr>;</init> <condition><expr><name>max</name> &gt;= 1</expr>;</condition> <incr><expr><name>max</name>--</expr></incr>)
<if>if <condition>(<expr><name><name>count</name><index>[<expr><name>max</name></expr>]</index></name> != 0</expr>)</condition><then> <break>break;</break></then></if></for>
<if>if <condition>(<expr><name>root</name> &gt; <name>max</name></expr>)</condition><then> <expr_stmt><expr><name>root</name> = <name>max</name></expr>;</expr_stmt></then></if>
<if>if <condition>(<expr><name>max</name> == 0</expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>this</name>.<name>op</name></name> = (<name>unsigned</name> <name>char</name>)64</expr>;</expr_stmt>
<expr_stmt><expr><name><name>this</name>.<name>bits</name></name> = (<name>unsigned</name> <name>char</name>)1</expr>;</expr_stmt>
<expr_stmt><expr><name><name>this</name>.<name>val</name></name> = (<name>unsigned</name> <name>short</name>)0</expr>;</expr_stmt>
<expr_stmt><expr>*(*<name>table</name>)++ = <name>this</name></expr>;</expr_stmt>
<expr_stmt><expr>*(*<name>table</name>)++ = <name>this</name></expr>;</expr_stmt>
<expr_stmt><expr>*<name>bits</name> = 1</expr>;</expr_stmt>
<return>return <expr>0</expr>;</return>
}</block></then></if>
<for>for (<init><expr><name>min</name> = 1</expr>;</init> <condition><expr><name>min</name> &lt;= <name>MAXBITS</name></expr>;</condition> <incr><expr><name>min</name>++</expr></incr>)
<if>if <condition>(<expr><name><name>count</name><index>[<expr><name>min</name></expr>]</index></name> != 0</expr>)</condition><then> <break>break;</break></then></if></for>
<if>if <condition>(<expr><name>root</name> &lt; <name>min</name></expr>)</condition><then> <expr_stmt><expr><name>root</name> = <name>min</name></expr>;</expr_stmt></then></if>
<expr_stmt><expr><name>left</name> = 1</expr>;</expr_stmt>
<for>for (<init><expr><name>len</name> = 1</expr>;</init> <condition><expr><name>len</name> &lt;= <name>MAXBITS</name></expr>;</condition> <incr><expr><name>len</name>++</expr></incr>) <block>{
<expr_stmt><expr><name>left</name> &lt;&lt;= 1</expr>;</expr_stmt>
<expr_stmt><expr><name>left</name> -= <name><name>count</name><index>[<expr><name>len</name></expr>]</index></name></expr>;</expr_stmt>
<if>if <condition>(<expr><name>left</name> &lt; 0</expr>)</condition><then> <return>return <expr>-1</expr>;</return></then></if>
}</block></for>
<if>if <condition>(<expr><name>left</name> &gt; 0 &amp;&amp; (<name>type</name> == <name>CODES</name> || <name>max</name> != 1)</expr>)</condition><then>
<return>return <expr>-1</expr>;</return></then></if>
<expr_stmt><expr><name><name>offs</name><index>[<expr>1</expr>]</index></name> = 0</expr>;</expr_stmt>
<for>for (<init><expr><name>len</name> = 1</expr>;</init> <condition><expr><name>len</name> &lt; <name>MAXBITS</name></expr>;</condition> <incr><expr><name>len</name>++</expr></incr>)
<expr_stmt><expr><name><name>offs</name><index>[<expr><name>len</name> + 1</expr>]</index></name> = <name><name>offs</name><index>[<expr><name>len</name></expr>]</index></name> + <name><name>count</name><index>[<expr><name>len</name></expr>]</index></name></expr>;</expr_stmt></for>
<for>for (<init><expr><name>sym</name> = 0</expr>;</init> <condition><expr><name>sym</name> &lt; <name>codes</name></expr>;</condition> <incr><expr><name>sym</name>++</expr></incr>)
<if>if <condition>(<expr><name><name>lens</name><index>[<expr><name>sym</name></expr>]</index></name> != 0</expr>)</condition><then> <expr_stmt><expr><name><name>work</name><index>[<expr><name><name>offs</name><index>[<expr><name><name>lens</name><index>[<expr><name>sym</name></expr>]</index></name></expr>]</index></name>++</expr>]</index></name> = (<name>unsigned</name> <name>short</name>)<name>sym</name></expr>;</expr_stmt></then></if></for>
<switch>switch <condition>(<expr><name>type</name></expr>)</condition> <block>{
<case>case <expr><name>CODES</name></expr>:
<expr_stmt><expr><name>base</name> = <name>extra</name> = <name>work</name></expr>;</expr_stmt>
<expr_stmt><expr><name>end</name> = 19</expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr><name>LENS</name></expr>:
<expr_stmt><expr><name>base</name> = <name>lbase</name></expr>;</expr_stmt>
<expr_stmt><expr><name>base</name> -= 257</expr>;</expr_stmt>
<expr_stmt><expr><name>extra</name> = <name>lext</name></expr>;</expr_stmt>
<expr_stmt><expr><name>extra</name> -= 257</expr>;</expr_stmt>
<expr_stmt><expr><name>end</name> = 256</expr>;</expr_stmt>
<break>break;</break>
</case><default>default:
<expr_stmt><expr><name>base</name> = <name>dbase</name></expr>;</expr_stmt>
<expr_stmt><expr><name>extra</name> = <name>dext</name></expr>;</expr_stmt>
<expr_stmt><expr><name>end</name> = -1</expr>;</expr_stmt>
</default>}</block></switch>
<expr_stmt><expr><name>huff</name> = 0</expr>;</expr_stmt>
<expr_stmt><expr><name>sym</name> = 0</expr>;</expr_stmt>
<expr_stmt><expr><name>len</name> = <name>min</name></expr>;</expr_stmt>
<expr_stmt><expr><name>next</name> = *<name>table</name></expr>;</expr_stmt>
<expr_stmt><expr><name>curr</name> = <name>root</name></expr>;</expr_stmt>
<expr_stmt><expr><name>drop</name> = 0</expr>;</expr_stmt>
<expr_stmt><expr><name>low</name> = <call>(<name>unsigned</name>)<argument_list>(<argument><expr>-1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>used</name> = 1U &lt;&lt; <name>root</name></expr>;</expr_stmt>
<expr_stmt><expr><name>mask</name> = <name>used</name> - 1</expr>;</expr_stmt>
<if>if <condition>(<expr><name>type</name> == <name>LENS</name> &amp;&amp; <name>used</name> &gt;= <name>ENOUGH</name> - <name>MAXD</name></expr>)</condition><then>
<return>return <expr>1</expr>;</return></then></if>
<for>for (<init>;</init><condition>;</condition><incr/>) <block>{
<expr_stmt><expr><name><name>this</name>.<name>bits</name></name> = <call>(<name>unsigned</name> <name>char</name>)<argument_list>(<argument><expr><name>len</name> - <name>drop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><call>(<name>int</name>)<argument_list>(<argument><expr><name><name>work</name><index>[<expr><name>sym</name></expr>]</index></name></expr></argument>)</argument_list></call> &lt; <name>end</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>this</name>.<name>op</name></name> = (<name>unsigned</name> <name>char</name>)0</expr>;</expr_stmt>
<expr_stmt><expr><name><name>this</name>.<name>val</name></name> = <name><name>work</name><index>[<expr><name>sym</name></expr>]</index></name></expr>;</expr_stmt>
}</block></then> <else>else <if>if <condition>(<expr><call>(<name>int</name>)<argument_list>(<argument><expr><name><name>work</name><index>[<expr><name>sym</name></expr>]</index></name></expr></argument>)</argument_list></call> &gt; <name>end</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>this</name>.<name>op</name></name> = <call>(<name>unsigned</name> <name>char</name>)<argument_list>(<argument><expr><name><name>extra</name><index>[<expr><name><name>work</name><index>[<expr><name>sym</name></expr>]</index></name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>this</name>.<name>val</name></name> = <name><name>base</name><index>[<expr><name><name>work</name><index>[<expr><name>sym</name></expr>]</index></name></expr>]</index></name></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr><name><name>this</name>.<name>op</name></name> = <call>(<name>unsigned</name> <name>char</name>)<argument_list>(<argument><expr>32 + 64</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>this</name>.<name>val</name></name> = 0</expr>;</expr_stmt>
}</block></else></if></else></if>
<expr_stmt><expr><name>incr</name> = 1U &lt;&lt; (<name>len</name> - <name>drop</name>)</expr>;</expr_stmt>
<expr_stmt><expr><name>fill</name> = 1U &lt;&lt; <name>curr</name></expr>;</expr_stmt>
<expr_stmt><expr><name>min</name> = <name>fill</name></expr>;</expr_stmt>
<do>do <block>{
<expr_stmt><expr><name>fill</name> -= <name>incr</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>next</name><index>[<expr>(<name>huff</name> &gt;&gt; <name>drop</name>) + <name>fill</name></expr>]</index></name> = <name>this</name></expr>;</expr_stmt>
}</block> while <condition>(<expr><name>fill</name> != 0</expr>)</condition>;</do>
<expr_stmt><expr><name>incr</name> = 1U &lt;&lt; (<name>len</name> - 1)</expr>;</expr_stmt>
<while>while <condition>(<expr><name>huff</name> &amp; <name>incr</name></expr>)</condition>
<expr_stmt><expr><name>incr</name> &gt;&gt;= 1</expr>;</expr_stmt></while>
<if>if <condition>(<expr><name>incr</name> != 0</expr>)</condition><then> <block>{
<expr_stmt><expr><name>huff</name> &amp;= <name>incr</name> - 1</expr>;</expr_stmt>
<expr_stmt><expr><name>huff</name> += <name>incr</name></expr>;</expr_stmt>
}</block></then> <else>else
<expr_stmt><expr><name>huff</name> = 0</expr>;</expr_stmt></else></if>
<expr_stmt><expr><name>sym</name>++</expr>;</expr_stmt>
<if>if <condition>(<expr>--(<name><name>count</name><index>[<expr><name>len</name></expr>]</index></name>) == 0</expr>)</condition><then> <block>{
<if>if <condition>(<expr><name>len</name> == <name>max</name></expr>)</condition><then> <break>break;</break></then></if>
<expr_stmt><expr><name>len</name> = <name><name>lens</name><index>[<expr><name><name>work</name><index>[<expr><name>sym</name></expr>]</index></name></expr>]</index></name></expr>;</expr_stmt>
}</block></then></if>
<if>if <condition>(<expr><name>len</name> &gt; <name>root</name> &amp;&amp; (<name>huff</name> &amp; <name>mask</name>) != <name>low</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr><name>drop</name> == 0</expr>)</condition><then>
<expr_stmt><expr><name>drop</name> = <name>root</name></expr>;</expr_stmt></then></if>
<expr_stmt><expr><name>next</name> += <name>min</name></expr>;</expr_stmt>
<expr_stmt><expr><name>curr</name> = <name>len</name> - <name>drop</name></expr>;</expr_stmt>
<expr_stmt><expr><name>left</name> = <call>(<name>int</name>)<argument_list>(<argument><expr>1 &lt;&lt; <name>curr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<while>while <condition>(<expr><name>curr</name> + <name>drop</name> &lt; <name>max</name></expr>)</condition> <block>{
<expr_stmt><expr><name>left</name> -= <name><name>count</name><index>[<expr><name>curr</name> + <name>drop</name></expr>]</index></name></expr>;</expr_stmt>
<if>if <condition>(<expr><name>left</name> &lt;= 0</expr>)</condition><then> <break>break;</break></then></if>
<expr_stmt><expr><name>curr</name>++</expr>;</expr_stmt>
<expr_stmt><expr><name>left</name> &lt;&lt;= 1</expr>;</expr_stmt>
}</block></while>
<expr_stmt><expr><name>used</name> += 1U &lt;&lt; <name>curr</name></expr>;</expr_stmt>
<if>if <condition>(<expr><name>type</name> == <name>LENS</name> &amp;&amp; <name>used</name> &gt;= <name>ENOUGH</name> - <name>MAXD</name></expr>)</condition><then>
<return>return <expr>1</expr>;</return></then></if>
<expr_stmt><expr><name>low</name> = <name>huff</name> &amp; <name>mask</name></expr>;</expr_stmt>
<expr_stmt><expr>(*<name>table</name>)<index>[<expr><name>low</name></expr>]</index>.<name>op</name> = (<name>unsigned</name> <name>char</name>)<name>curr</name></expr>;</expr_stmt>
<expr_stmt><expr>(*<name>table</name>)<index>[<expr><name>low</name></expr>]</index>.<name>bits</name> = (<name>unsigned</name> <name>char</name>)<name>root</name></expr>;</expr_stmt>
<expr_stmt><expr>(*<name>table</name>)<index>[<expr><name>low</name></expr>]</index>.<name>val</name> = <call>(<name>unsigned</name> <name>short</name>)<argument_list>(<argument><expr><name>next</name> - *<name>table</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
}</block></for>
<expr_stmt><expr><name><name>this</name>.<name>op</name></name> = (<name>unsigned</name> <name>char</name>)64</expr>;</expr_stmt>
<expr_stmt><expr><name><name>this</name>.<name>bits</name></name> = <call>(<name>unsigned</name> <name>char</name>)<argument_list>(<argument><expr><name>len</name> - <name>drop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>this</name>.<name>val</name></name> = (<name>unsigned</name> <name>short</name>)0</expr>;</expr_stmt>
<while>while <condition>(<expr><name>huff</name> != 0</expr>)</condition> <block>{
<if>if <condition>(<expr><name>drop</name> != 0 &amp;&amp; (<name>huff</name> &amp; <name>mask</name>) != <name>low</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>drop</name> = 0</expr>;</expr_stmt>
<expr_stmt><expr><name>len</name> = <name>root</name></expr>;</expr_stmt>
<expr_stmt><expr><name>next</name> = *<name>table</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>this</name>.<name>bits</name></name> = (<name>unsigned</name> <name>char</name>)<name>len</name></expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><name><name>next</name><index>[<expr><name>huff</name> &gt;&gt; <name>drop</name></expr>]</index></name> = <name>this</name></expr>;</expr_stmt>
<expr_stmt><expr><name>incr</name> = 1U &lt;&lt; (<name>len</name> - 1)</expr>;</expr_stmt>
<while>while <condition>(<expr><name>huff</name> &amp; <name>incr</name></expr>)</condition>
<expr_stmt><expr><name>incr</name> &gt;&gt;= 1</expr>;</expr_stmt></while>
<if>if <condition>(<expr><name>incr</name> != 0</expr>)</condition><then> <block>{
<expr_stmt><expr><name>huff</name> &amp;= <name>incr</name> - 1</expr>;</expr_stmt>
<expr_stmt><expr><name>huff</name> += <name>incr</name></expr>;</expr_stmt>
}</block></then> <else>else
<expr_stmt><expr><name>huff</name> = 0</expr>;</expr_stmt></else></if>
}</block></while>
<expr_stmt><expr>*<name>table</name> += <name>used</name></expr>;</expr_stmt>
<expr_stmt><expr>*<name>bits</name> = <name>root</name></expr>;</expr_stmt>
<return>return <expr>0</expr>;</return>
}</block></function>
</unit>
