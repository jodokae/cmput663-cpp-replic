<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C" filename="Modules/zlib/trees.c"><cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"deflate.h"</cpp:file></cpp:include>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>DEBUG</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;ctype.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAX_BL_BITS</name></cpp:macro> <cpp:value>7</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>END_BLOCK</name></cpp:macro> <cpp:value>256</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>REP_3_6</name></cpp:macro> <cpp:value>16</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>REPZ_3_10</name></cpp:macro> <cpp:value>17</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>REPZ_11_138</name></cpp:macro> <cpp:value>18</cpp:value></cpp:define>
<decl_stmt><decl><type><name>local</name> <specifier>const</specifier> <name>int</name></type> <name><name>extra_lbits</name><index>[<expr><name>LENGTH_CODES</name></expr>]</index></name>
<init>= <expr><block>{<expr>0</expr>,<expr>0</expr>,<expr>0</expr>,<expr>0</expr>,<expr>0</expr>,<expr>0</expr>,<expr>0</expr>,<expr>0</expr>,<expr>1</expr>,<expr>1</expr>,<expr>1</expr>,<expr>1</expr>,<expr>2</expr>,<expr>2</expr>,<expr>2</expr>,<expr>2</expr>,<expr>3</expr>,<expr>3</expr>,<expr>3</expr>,<expr>3</expr>,<expr>4</expr>,<expr>4</expr>,<expr>4</expr>,<expr>4</expr>,<expr>5</expr>,<expr>5</expr>,<expr>5</expr>,<expr>5</expr>,<expr>0</expr>}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>local</name> <specifier>const</specifier> <name>int</name></type> <name><name>extra_dbits</name><index>[<expr><name>D_CODES</name></expr>]</index></name>
<init>= <expr><block>{<expr>0</expr>,<expr>0</expr>,<expr>0</expr>,<expr>0</expr>,<expr>1</expr>,<expr>1</expr>,<expr>2</expr>,<expr>2</expr>,<expr>3</expr>,<expr>3</expr>,<expr>4</expr>,<expr>4</expr>,<expr>5</expr>,<expr>5</expr>,<expr>6</expr>,<expr>6</expr>,<expr>7</expr>,<expr>7</expr>,<expr>8</expr>,<expr>8</expr>,<expr>9</expr>,<expr>9</expr>,<expr>10</expr>,<expr>10</expr>,<expr>11</expr>,<expr>11</expr>,<expr>12</expr>,<expr>12</expr>,<expr>13</expr>,<expr>13</expr>}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>local</name> <specifier>const</specifier> <name>int</name></type> <name><name>extra_blbits</name><index>[<expr><name>BL_CODES</name></expr>]</index></name>
<init>= <expr><block>{<expr>0</expr>,<expr>0</expr>,<expr>0</expr>,<expr>0</expr>,<expr>0</expr>,<expr>0</expr>,<expr>0</expr>,<expr>0</expr>,<expr>0</expr>,<expr>0</expr>,<expr>0</expr>,<expr>0</expr>,<expr>0</expr>,<expr>0</expr>,<expr>0</expr>,<expr>0</expr>,<expr>2</expr>,<expr>3</expr>,<expr>7</expr>}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>local</name> <specifier>const</specifier> <name>uch</name></type> <name><name>bl_order</name><index>[<expr><name>BL_CODES</name></expr>]</index></name>
<init>= <expr><block>{<expr>16</expr>,<expr>17</expr>,<expr>18</expr>,<expr>0</expr>,<expr>8</expr>,<expr>7</expr>,<expr>9</expr>,<expr>6</expr>,<expr>10</expr>,<expr>5</expr>,<expr>11</expr>,<expr>4</expr>,<expr>12</expr>,<expr>3</expr>,<expr>13</expr>,<expr>2</expr>,<expr>14</expr>,<expr>1</expr>,<expr>15</expr>}</block></expr></init></decl>;</decl_stmt>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Buf_size</name></cpp:macro> <cpp:value>(8 * 2*sizeof(char))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DIST_CODE_LEN</name></cpp:macro> <cpp:value>512</cpp:value></cpp:define>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>GEN_TREES_H</name></expr></argument>)</argument_list></call> || !<call><name>defined</name><argument_list>(<argument><expr><name>STDC</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>local</name> <name>ct_data</name></type> <name><name>static_ltree</name><index>[<expr><name>L_CODES</name>+2</expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>local</name> <name>ct_data</name></type> <name><name>static_dtree</name><index>[<expr><name>D_CODES</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uch</name></type> <name><name>_dist_code</name><index>[<expr><name>DIST_CODE_LEN</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uch</name></type> <name><name>_length_code</name><index>[<expr><name>MAX_MATCH</name>-<name>MIN_MATCH</name>+1</expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>local</name> <name>int</name></type> <name><name>base_length</name><index>[<expr><name>LENGTH_CODES</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>local</name> <name>int</name></type> <name><name>base_dist</name><index>[<expr><name>D_CODES</name></expr>]</index></name></decl>;</decl_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"trees.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<struct>struct <name>static_tree_desc_s</name> <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>ct_data</name> *</type><name>static_tree</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>intf</name> *</type><name>extra_bits</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>extra_base</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>elems</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>max_length</name></decl>;</decl_stmt>
}</block>;</struct>
<decl_stmt><decl><type><name>local</name> <name>static_tree_desc</name></type> <name>static_l_desc</name> <init>=
<expr><block>{<expr><name>static_ltree</name></expr>, <expr><name>extra_lbits</name></expr>, <expr><name>LITERALS</name>+1</expr>, <expr><name>L_CODES</name></expr>, <expr><name>MAX_BITS</name></expr>}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>local</name> <name>static_tree_desc</name></type> <name>static_d_desc</name> <init>=
<expr><block>{<expr><name>static_dtree</name></expr>, <expr><name>extra_dbits</name></expr>, <expr>0</expr>, <expr><name>D_CODES</name></expr>, <expr><name>MAX_BITS</name></expr>}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>local</name> <name>static_tree_desc</name></type> <name>static_bl_desc</name> <init>=
<expr><block>{<expr>(const <name>ct_data</name> *)0</expr>, <expr><name>extra_blbits</name></expr>, <expr>0</expr>, <expr><name>BL_CODES</name></expr>, <expr><name>MAX_BL_BITS</name></expr>}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>local</name> <name>void</name> <name>tr_static_init</name></type> <name>OF</name><argument_list>(<argument><expr>(<name>void</name>)</expr></argument>)</argument_list></decl>;</decl_stmt>
<decl_stmt><decl><type><name>local</name> <name>void</name> <name>init_block</name></type> <name>OF</name><argument_list>(<argument><expr>(<name>deflate_state</name> *<name>s</name>)</expr></argument>)</argument_list></decl>;</decl_stmt>
<decl_stmt><decl><type><name>local</name> <name>void</name> <name>pqdownheap</name></type> <name>OF</name><argument_list>(<argument><expr>(<name>deflate_state</name> *<name>s</name>, <name>ct_data</name> *<name>tree</name>, <name>int</name> <name>k</name>)</expr></argument>)</argument_list></decl>;</decl_stmt>
<decl_stmt><decl><type><name>local</name> <name>void</name> <name>gen_bitlen</name></type> <name>OF</name><argument_list>(<argument><expr>(<name>deflate_state</name> *<name>s</name>, <name>tree_desc</name> *<name>desc</name>)</expr></argument>)</argument_list></decl>;</decl_stmt>
<decl_stmt><decl><type><name>local</name> <name>void</name> <name>gen_codes</name></type> <name>OF</name><argument_list>(<argument><expr>(<name>ct_data</name> *<name>tree</name>, <name>int</name> <name>max_code</name>, <name>ushf</name> *<name>bl_count</name>)</expr></argument>)</argument_list></decl>;</decl_stmt>
<decl_stmt><decl><type><name>local</name> <name>void</name> <name>build_tree</name></type> <name>OF</name><argument_list>(<argument><expr>(<name>deflate_state</name> *<name>s</name>, <name>tree_desc</name> *<name>desc</name>)</expr></argument>)</argument_list></decl>;</decl_stmt>
<decl_stmt><decl><type><name>local</name> <name>void</name> <name>scan_tree</name></type> <name>OF</name><argument_list>(<argument><expr>(<name>deflate_state</name> *<name>s</name>, <name>ct_data</name> *<name>tree</name>, <name>int</name> <name>max_code</name>)</expr></argument>)</argument_list></decl>;</decl_stmt>
<decl_stmt><decl><type><name>local</name> <name>void</name> <name>send_tree</name></type> <name>OF</name><argument_list>(<argument><expr>(<name>deflate_state</name> *<name>s</name>, <name>ct_data</name> *<name>tree</name>, <name>int</name> <name>max_code</name>)</expr></argument>)</argument_list></decl>;</decl_stmt>
<decl_stmt><decl><type><name>local</name> <name>int</name> <name>build_bl_tree</name></type> <name>OF</name><argument_list>(<argument><expr>(<name>deflate_state</name> *<name>s</name>)</expr></argument>)</argument_list></decl>;</decl_stmt>
<decl_stmt><decl><type><name>local</name> <name>void</name> <name>send_all_trees</name></type> <name>OF</name><argument_list>(<argument><expr>(<name>deflate_state</name> *<name>s</name>, <name>int</name> <name>lcodes</name>, <name>int</name> <name>dcodes</name>,
<name>int</name> <name>blcodes</name>)</expr></argument>)</argument_list></decl>;</decl_stmt>
<decl_stmt><decl><type><name>local</name> <name>void</name> <name>compress_block</name></type> <name>OF</name><argument_list>(<argument><expr>(<name>deflate_state</name> *<name>s</name>, <name>ct_data</name> *<name>ltree</name>,
<name>ct_data</name> *<name>dtree</name>)</expr></argument>)</argument_list></decl>;</decl_stmt>
<decl_stmt><decl><type><name>local</name> <name>void</name> <name>set_data_type</name></type> <name>OF</name><argument_list>(<argument><expr>(<name>deflate_state</name> *<name>s</name>)</expr></argument>)</argument_list></decl>;</decl_stmt>
<decl_stmt><decl><type><name>local</name> <name>unsigned</name> <name>bi_reverse</name></type> <name>OF</name><argument_list>(<argument><expr>(<name>unsigned</name> <name>value</name>, <name>int</name> <name>length</name>)</expr></argument>)</argument_list></decl>;</decl_stmt>
<decl_stmt><decl><type><name>local</name> <name>void</name> <name>bi_windup</name></type> <name>OF</name><argument_list>(<argument><expr>(<name>deflate_state</name> *<name>s</name>)</expr></argument>)</argument_list></decl>;</decl_stmt>
<decl_stmt><decl><type><name>local</name> <name>void</name> <name>bi_flush</name></type> <name>OF</name><argument_list>(<argument><expr>(<name>deflate_state</name> *<name>s</name>)</expr></argument>)</argument_list></decl>;</decl_stmt>
<decl_stmt><decl><type><name>local</name> <name>void</name> <name>copy_block</name></type> <name>OF</name><argument_list>(<argument><expr>(<name>deflate_state</name> *<name>s</name>, <name>charf</name> *<name>buf</name>, <name>unsigned</name> <name>len</name>,
<name>int</name> <name>header</name>)</expr></argument>)</argument_list></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>GEN_TREES_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>local</name> <name>void</name> <name>gen_trees_header</name></type> <name>OF</name><argument_list>(<argument><expr>(<name>void</name>)</expr></argument>)</argument_list></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>DEBUG</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>send_code</name><parameter_list>(<param><type><name>s</name></type></param>, <param><type><name>c</name></type></param>, <param><type><name>tree</name></type></param>)</parameter_list></cpp:macro> <cpp:value>send_bits(s, tree[c].Code, tree[c].Len)</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>send_code</name><parameter_list>(<param><type><name>s</name></type></param>, <param><type><name>c</name></type></param>, <param><type><name>tree</name></type></param>)</parameter_list></cpp:macro> <cpp:value>{ if (z_verbose&gt;2) fprintf(stderr,"\ncd %3d ",(c)); send_bits(s, tree[c].Code, tree[c].Len); }</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>put_short</name><parameter_list>(<param><type><name>s</name></type></param>, <param><type><name>w</name></type></param>)</parameter_list></cpp:macro> <cpp:value>{ put_byte(s, (uch)((w) &amp; 0xff)); put_byte(s, (uch)((ush)(w) &gt;&gt; 8)); }</cpp:value></cpp:define>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>DEBUG</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>local</name> <name>void</name> <name>send_bits</name></type> <name>OF</name><argument_list>(<argument><expr>(<name>deflate_state</name> *<name>s</name>, <name>int</name> <name>value</name>, <name>int</name> <name>length</name>)</expr></argument>)</argument_list></decl>;</decl_stmt>
<function><type><name>local</name> <name>void</name></type> <name>send_bits</name><parameter_list>(<param><decl><type><name>s</name></type></decl></param>, <param><decl><type><name>value</name></type></decl></param>, <param><decl><type><name>length</name></type></decl></param>)</parameter_list>
<decl_stmt><decl><type><name>deflate_state</name> *</type><name>s</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>value</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>length</name></decl>;</decl_stmt>
<block>{
<expr_stmt><expr><call><name>Tracevv</name><argument_list>(<argument><expr>(<name>stderr</name>," l %2d v %4x ", <name>length</name>, <name>value</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>length</name> &gt; 0 &amp;&amp; <name>length</name> &lt;= 15</expr></argument>, <argument><expr>"invalid length"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name>-&gt;<name>bits_sent</name></name> += (<name>ulg</name>)<name>length</name></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>s</name>-&gt;<name>bi_valid</name></name> &gt; (<name>int</name>)<name>Buf_size</name> - <name>length</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>s</name>-&gt;<name>bi_buf</name></name> |= (<name>value</name> &lt;&lt; <name><name>s</name>-&gt;<name>bi_valid</name></name>)</expr>;</expr_stmt>
<expr_stmt><expr><call><name>put_short</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>bi_buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name>-&gt;<name>bi_buf</name></name> = (<name>ush</name>)<name>value</name> &gt;&gt; (<name>Buf_size</name> - <name><name>s</name>-&gt;<name>bi_valid</name></name>)</expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name>-&gt;<name>bi_valid</name></name> += <name>length</name> - <name>Buf_size</name></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr><name><name>s</name>-&gt;<name>bi_buf</name></name> |= <name>value</name> &lt;&lt; <name><name>s</name>-&gt;<name>bi_valid</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name>-&gt;<name>bi_valid</name></name> += <name>length</name></expr>;</expr_stmt>
}</block></else></if>
}</block></function>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>send_bits</name><parameter_list>(<param><type><name>s</name></type></param>, <param><type><name>value</name></type></param>, <param><type><name>length</name></type></param>)</parameter_list></cpp:macro> <cpp:value>{ int len = length;if (s-&gt;bi_valid &gt; (int)Buf_size - len) {int val = value;s-&gt;bi_buf |= (val &lt;&lt; s-&gt;bi_valid);put_short(s, s-&gt;bi_buf);s-&gt;bi_buf = (ush)val &gt;&gt; (Buf_size - s-&gt;bi_valid);s-&gt;bi_valid += len - Buf_size;} else {s-&gt;bi_buf |= (value) &lt;&lt; s-&gt;bi_valid;s-&gt;bi_valid += len;}}</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<function><type><name>local</name> <name>void</name></type> <name>tr_static_init</name><parameter_list>()</parameter_list> <block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>GEN_TREES_H</name></expr></argument>)</argument_list></call> || !<call><name>defined</name><argument_list>(<argument><expr><name>STDC</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>static_init_done</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>bits</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>length</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>code</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>dist</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ush</name></type> <name><name>bl_count</name><index>[<expr><name>MAX_BITS</name>+1</expr>]</index></name></decl>;</decl_stmt>
<if>if <condition>(<expr><name>static_init_done</name></expr>)</condition><then> <return>return;</return></then></if>
<expr_stmt><expr><name><name>static_l_desc</name>.<name>static_tree</name></name> = <name>static_ltree</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>static_l_desc</name>.<name>extra_bits</name></name> = <name>extra_lbits</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>static_d_desc</name>.<name>static_tree</name></name> = <name>static_dtree</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>static_d_desc</name>.<name>extra_bits</name></name> = <name>extra_dbits</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>static_bl_desc</name>.<name>extra_bits</name></name> = <name>extra_blbits</name></expr>;</expr_stmt>
<expr_stmt><expr><name>length</name> = 0</expr>;</expr_stmt>
<for>for (<init><expr><name>code</name> = 0</expr>;</init> <condition><expr><name>code</name> &lt; <name>LENGTH_CODES</name>-1</expr>;</condition> <incr><expr><name>code</name>++</expr></incr>) <block>{
<expr_stmt><expr><name><name>base_length</name><index>[<expr><name>code</name></expr>]</index></name> = <name>length</name></expr>;</expr_stmt>
<for>for (<init><expr><name>n</name> = 0</expr>;</init> <condition><expr><name>n</name> &lt; (1&lt;&lt;<name><name>extra_lbits</name><index>[<expr><name>code</name></expr>]</index></name>)</expr>;</condition> <incr><expr><name>n</name>++</expr></incr>) <block>{
<expr_stmt><expr><name><name>_length_code</name><index>[<expr><name>length</name>++</expr>]</index></name> = (<name>uch</name>)<name>code</name></expr>;</expr_stmt>
}</block></for>
}</block></for>
<expr_stmt><expr><call><name>Assert</name> <argument_list>(<argument><expr><name>length</name> == 256</expr></argument>, <argument><expr>"tr_static_init: length != 256"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>_length_code</name><index>[<expr><name>length</name>-1</expr>]</index></name> = (<name>uch</name>)<name>code</name></expr>;</expr_stmt>
<expr_stmt><expr><name>dist</name> = 0</expr>;</expr_stmt>
<for>for (<init><expr><name>code</name> = 0</expr> ;</init> <condition><expr><name>code</name> &lt; 16</expr>;</condition> <incr><expr><name>code</name>++</expr></incr>) <block>{
<expr_stmt><expr><name><name>base_dist</name><index>[<expr><name>code</name></expr>]</index></name> = <name>dist</name></expr>;</expr_stmt>
<for>for (<init><expr><name>n</name> = 0</expr>;</init> <condition><expr><name>n</name> &lt; (1&lt;&lt;<name><name>extra_dbits</name><index>[<expr><name>code</name></expr>]</index></name>)</expr>;</condition> <incr><expr><name>n</name>++</expr></incr>) <block>{
<expr_stmt><expr><name><name>_dist_code</name><index>[<expr><name>dist</name>++</expr>]</index></name> = (<name>uch</name>)<name>code</name></expr>;</expr_stmt>
}</block></for>
}</block></for>
<expr_stmt><expr><call><name>Assert</name> <argument_list>(<argument><expr><name>dist</name> == 256</expr></argument>, <argument><expr>"tr_static_init: dist != 256"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>dist</name> &gt;&gt;= 7</expr>;</expr_stmt>
<for>for ( <init>;</init> <condition><expr><name>code</name> &lt; <name>D_CODES</name></expr>;</condition> <incr><expr><name>code</name>++</expr></incr>) <block>{
<expr_stmt><expr><name><name>base_dist</name><index>[<expr><name>code</name></expr>]</index></name> = <name>dist</name> &lt;&lt; 7</expr>;</expr_stmt>
<for>for (<init><expr><name>n</name> = 0</expr>;</init> <condition><expr><name>n</name> &lt; (1&lt;&lt;(<name><name>extra_dbits</name><index>[<expr><name>code</name></expr>]</index></name>-7))</expr>;</condition> <incr><expr><name>n</name>++</expr></incr>) <block>{
<expr_stmt><expr><name><name>_dist_code</name><index>[<expr>256 + <name>dist</name>++</expr>]</index></name> = (<name>uch</name>)<name>code</name></expr>;</expr_stmt>
}</block></for>
}</block></for>
<expr_stmt><expr><call><name>Assert</name> <argument_list>(<argument><expr><name>dist</name> == 256</expr></argument>, <argument><expr>"tr_static_init: 256+dist != 512"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for (<init><expr><name>bits</name> = 0</expr>;</init> <condition><expr><name>bits</name> &lt;= <name>MAX_BITS</name></expr>;</condition> <incr><expr><name>bits</name>++</expr></incr>) <expr_stmt><expr><name><name>bl_count</name><index>[<expr><name>bits</name></expr>]</index></name> = 0</expr>;</expr_stmt></for>
<expr_stmt><expr><name>n</name> = 0</expr>;</expr_stmt>
<while>while <condition>(<expr><name>n</name> &lt;= 143</expr>)</condition> <expr_stmt><expr><name><name>static_ltree</name><index>[<expr><name>n</name>++</expr>]</index></name>.<name>Len</name> = 8</expr>, <expr><name><name>bl_count</name><index>[<expr>8</expr>]</index></name>++</expr>;</expr_stmt></while>
<while>while <condition>(<expr><name>n</name> &lt;= 255</expr>)</condition> <expr_stmt><expr><name><name>static_ltree</name><index>[<expr><name>n</name>++</expr>]</index></name>.<name>Len</name> = 9</expr>, <expr><name><name>bl_count</name><index>[<expr>9</expr>]</index></name>++</expr>;</expr_stmt></while>
<while>while <condition>(<expr><name>n</name> &lt;= 279</expr>)</condition> <expr_stmt><expr><name><name>static_ltree</name><index>[<expr><name>n</name>++</expr>]</index></name>.<name>Len</name> = 7</expr>, <expr><name><name>bl_count</name><index>[<expr>7</expr>]</index></name>++</expr>;</expr_stmt></while>
<while>while <condition>(<expr><name>n</name> &lt;= 287</expr>)</condition> <expr_stmt><expr><name><name>static_ltree</name><index>[<expr><name>n</name>++</expr>]</index></name>.<name>Len</name> = 8</expr>, <expr><name><name>bl_count</name><index>[<expr>8</expr>]</index></name>++</expr>;</expr_stmt></while>
<expr_stmt><expr><call><name>gen_codes</name><argument_list>(<argument><expr>(<name>ct_data</name> *)<name>static_ltree</name></expr></argument>, <argument><expr><name>L_CODES</name>+1</expr></argument>, <argument><expr><name>bl_count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for (<init><expr><name>n</name> = 0</expr>;</init> <condition><expr><name>n</name> &lt; <name>D_CODES</name></expr>;</condition> <incr><expr><name>n</name>++</expr></incr>) <block>{
<expr_stmt><expr><name><name>static_dtree</name><index>[<expr><name>n</name></expr>]</index></name>.<name>Len</name> = 5</expr>;</expr_stmt>
<expr_stmt><expr><name><name>static_dtree</name><index>[<expr><name>n</name></expr>]</index></name>.<name>Code</name> = <call><name>bi_reverse</name><argument_list>(<argument><expr>(<name>unsigned</name>)<name>n</name></expr></argument>, <argument><expr>5</expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></for>
<expr_stmt><expr><name>static_init_done</name> = 1</expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>GEN_TREES_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>gen_trees_header</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></function>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>GEN_TREES_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>DEBUG</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdio.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SEPARATOR</name><parameter_list>(<param><type><name>i</name></type></param>, <param><type><name>last</name></type></param>, <param><type><name>width</name></type></param>)</parameter_list></cpp:macro> <cpp:value>((i) == (last)? "\n};\n\n" : ((i) % (width) == (width)-1 ? ",\n" : ", "))</cpp:value></cpp:define>
<function><type><name>void</name></type> <name>gen_trees_header</name><parameter_list>()</parameter_list> <block>{
<decl_stmt><decl><type><name>FILE</name> *</type><name>header</name> <init>= <expr><call><name>fopen</name><argument_list>(<argument><expr>"trees.h"</expr></argument>, <argument><expr>"w"</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>Assert</name> <argument_list>(<argument><expr><name>header</name> != <name>NULL</name></expr></argument>, <argument><expr>"Can't open trees.h"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>header</name></expr></argument>,
<argument><expr>"/* header created automatically with -DGEN_TREES_H */\n\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>header</name></expr></argument>, <argument><expr>"local const ct_data static_ltree[L_CODES+2] = {\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>L_CODES</name>+2</expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>header</name></expr></argument>, <argument><expr>"{{%3u},{%3u}}%s"</expr></argument>, <argument><expr><name><name>static_ltree</name><index>[<expr><name>i</name></expr>]</index></name>.<name>Code</name></expr></argument>,
<argument><expr><name><name>static_ltree</name><index>[<expr><name>i</name></expr>]</index></name>.<name>Len</name></expr></argument>, <argument><expr><call><name>SEPARATOR</name><argument_list>(<argument><expr><name>i</name></expr></argument>, <argument><expr><name>L_CODES</name>+1</expr></argument>, <argument><expr>5</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></for>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>header</name></expr></argument>, <argument><expr>"local const ct_data static_dtree[D_CODES] = {\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>D_CODES</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>header</name></expr></argument>, <argument><expr>"{{%2u},{%2u}}%s"</expr></argument>, <argument><expr><name><name>static_dtree</name><index>[<expr><name>i</name></expr>]</index></name>.<name>Code</name></expr></argument>,
<argument><expr><name><name>static_dtree</name><index>[<expr><name>i</name></expr>]</index></name>.<name>Len</name></expr></argument>, <argument><expr><call><name>SEPARATOR</name><argument_list>(<argument><expr><name>i</name></expr></argument>, <argument><expr><name>D_CODES</name>-1</expr></argument>, <argument><expr>5</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></for>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>header</name></expr></argument>, <argument><expr>"const uch _dist_code[DIST_CODE_LEN] = {\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>DIST_CODE_LEN</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>header</name></expr></argument>, <argument><expr>"%2u%s"</expr></argument>, <argument><expr><name><name>_dist_code</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
<argument><expr><call><name>SEPARATOR</name><argument_list>(<argument><expr><name>i</name></expr></argument>, <argument><expr><name>DIST_CODE_LEN</name>-1</expr></argument>, <argument><expr>20</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></for>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>header</name></expr></argument>, <argument><expr>"const uch _length_code[MAX_MATCH-MIN_MATCH+1]= {\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>MAX_MATCH</name>-<name>MIN_MATCH</name>+1</expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>header</name></expr></argument>, <argument><expr>"%2u%s"</expr></argument>, <argument><expr><name><name>_length_code</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
<argument><expr><call><name>SEPARATOR</name><argument_list>(<argument><expr><name>i</name></expr></argument>, <argument><expr><name>MAX_MATCH</name>-<name>MIN_MATCH</name></expr></argument>, <argument><expr>20</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></for>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>header</name></expr></argument>, <argument><expr>"local const int base_length[LENGTH_CODES] = {\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>LENGTH_CODES</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>header</name></expr></argument>, <argument><expr>"%1u%s"</expr></argument>, <argument><expr><name><name>base_length</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
<argument><expr><call><name>SEPARATOR</name><argument_list>(<argument><expr><name>i</name></expr></argument>, <argument><expr><name>LENGTH_CODES</name>-1</expr></argument>, <argument><expr>20</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></for>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>header</name></expr></argument>, <argument><expr>"local const int base_dist[D_CODES] = {\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>D_CODES</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>header</name></expr></argument>, <argument><expr>"%5u%s"</expr></argument>, <argument><expr><name><name>base_dist</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
<argument><expr><call><name>SEPARATOR</name><argument_list>(<argument><expr><name>i</name></expr></argument>, <argument><expr><name>D_CODES</name>-1</expr></argument>, <argument><expr>10</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></for>
<expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>header</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<function><type><name>void</name></type> <name>_tr_init</name><parameter_list>(<param><decl><type><name>s</name></type></decl></param>)</parameter_list>
<decl_stmt><decl><type><name>deflate_state</name> *</type><name>s</name></decl>;</decl_stmt>
<block>{
<expr_stmt><expr><call><name>tr_static_init</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name>-&gt;<name>l_desc</name>.<name>dyn_tree</name></name> = <name><name>s</name>-&gt;<name>dyn_ltree</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name>-&gt;<name>l_desc</name>.<name>stat_desc</name></name> = &amp;<name>static_l_desc</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name>-&gt;<name>d_desc</name>.<name>dyn_tree</name></name> = <name><name>s</name>-&gt;<name>dyn_dtree</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name>-&gt;<name>d_desc</name>.<name>stat_desc</name></name> = &amp;<name>static_d_desc</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name>-&gt;<name>bl_desc</name>.<name>dyn_tree</name></name> = <name><name>s</name>-&gt;<name>bl_tree</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name>-&gt;<name>bl_desc</name>.<name>stat_desc</name></name> = &amp;<name>static_bl_desc</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name>-&gt;<name>bi_buf</name></name> = 0</expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name>-&gt;<name>bi_valid</name></name> = 0</expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name>-&gt;<name>last_eob_len</name></name> = 8</expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>DEBUG</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><name><name>s</name>-&gt;<name>compressed_len</name></name> = 0L</expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name>-&gt;<name>bits_sent</name></name> = 0L</expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><call><name>init_block</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>
<function><type><name>local</name> <name>void</name></type> <name>init_block</name><parameter_list>(<param><decl><type><name>s</name></type></decl></param>)</parameter_list>
<decl_stmt><decl><type><name>deflate_state</name> *</type><name>s</name></decl>;</decl_stmt>
<block>{
<decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>;</decl_stmt>
<for>for (<init><expr><name>n</name> = 0</expr>;</init> <condition><expr><name>n</name> &lt; <name>L_CODES</name></expr>;</condition> <incr><expr><name>n</name>++</expr></incr>) <expr_stmt><expr><name><name>s</name>-&gt;<name>dyn_ltree</name><index>[<expr><name>n</name></expr>]</index></name>.<name>Freq</name> = 0</expr>;</expr_stmt></for>
<for>for (<init><expr><name>n</name> = 0</expr>;</init> <condition><expr><name>n</name> &lt; <name>D_CODES</name></expr>;</condition> <incr><expr><name>n</name>++</expr></incr>) <expr_stmt><expr><name><name>s</name>-&gt;<name>dyn_dtree</name><index>[<expr><name>n</name></expr>]</index></name>.<name>Freq</name> = 0</expr>;</expr_stmt></for>
<for>for (<init><expr><name>n</name> = 0</expr>;</init> <condition><expr><name>n</name> &lt; <name>BL_CODES</name></expr>;</condition> <incr><expr><name>n</name>++</expr></incr>) <expr_stmt><expr><name><name>s</name>-&gt;<name>bl_tree</name><index>[<expr><name>n</name></expr>]</index></name>.<name>Freq</name> = 0</expr>;</expr_stmt></for>
<expr_stmt><expr><name><name>s</name>-&gt;<name>dyn_ltree</name><index>[<expr><name>END_BLOCK</name></expr>]</index></name>.<name>Freq</name> = 1</expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name>-&gt;<name>opt_len</name></name> = <name><name>s</name>-&gt;<name>static_len</name></name> = 0L</expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name>-&gt;<name>last_lit</name></name> = <name><name>s</name>-&gt;<name>matches</name></name> = 0</expr>;</expr_stmt>
}</block></function>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SMALLEST</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>pqremove</name><parameter_list>(<param><type><name>s</name></type></param>, <param><type><name>tree</name></type></param>, <param><type><name>top</name></type></param>)</parameter_list></cpp:macro> <cpp:value>{top = s-&gt;heap[SMALLEST]; s-&gt;heap[SMALLEST] = s-&gt;heap[s-&gt;heap_len--]; pqdownheap(s, tree, SMALLEST); }</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>smaller</name><parameter_list>(<param><type><name>tree</name></type></param>, <param><type><name>n</name></type></param>, <param><type><name>m</name></type></param>, <param><type><name>depth</name></type></param>)</parameter_list></cpp:macro> <cpp:value>(tree[n].Freq &lt; tree[m].Freq || (tree[n].Freq == tree[m].Freq &amp;&amp; depth[n] &lt;= depth[m]))</cpp:value></cpp:define>
<function><type><name>local</name> <name>void</name></type> <name>pqdownheap</name><parameter_list>(<param><decl><type><name>s</name></type></decl></param>, <param><decl><type><name>tree</name></type></decl></param>, <param><decl><type><name>k</name></type></decl></param>)</parameter_list>
<decl_stmt><decl><type><name>deflate_state</name> *</type><name>s</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ct_data</name> *</type><name>tree</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>k</name></decl>;</decl_stmt>
<block>{
<decl_stmt><decl><type><name>int</name></type> <name>v</name> <init>= <expr><name><name>s</name>-&gt;<name>heap</name><index>[<expr><name>k</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>j</name> <init>= <expr><name>k</name> &lt;&lt; 1</expr></init></decl>;</decl_stmt>
<while>while <condition>(<expr><name>j</name> &lt;= <name><name>s</name>-&gt;<name>heap_len</name></name></expr>)</condition> <block>{
<if>if <condition>(<expr><name>j</name> &lt; <name><name>s</name>-&gt;<name>heap_len</name></name> &amp;&amp;
<call><name>smaller</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>heap</name><index>[<expr><name>j</name>+1</expr>]</index></name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>heap</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>depth</name></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><name>j</name>++</expr>;</expr_stmt>
}</block></then></if>
<if>if <condition>(<expr><call><name>smaller</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr><name>v</name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>heap</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>depth</name></name></expr></argument>)</argument_list></call></expr>)</condition><then> <break>break;</break></then></if>
<expr_stmt><expr><name><name>s</name>-&gt;<name>heap</name><index>[<expr><name>k</name></expr>]</index></name> = <name><name>s</name>-&gt;<name>heap</name><index>[<expr><name>j</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name>k</name> = <name>j</name></expr>;</expr_stmt>
<expr_stmt><expr><name>j</name> &lt;&lt;= 1</expr>;</expr_stmt>
}</block></while>
<expr_stmt><expr><name><name>s</name>-&gt;<name>heap</name><index>[<expr><name>k</name></expr>]</index></name> = <name>v</name></expr>;</expr_stmt>
}</block></function>
<function><type><name>local</name> <name>void</name></type> <name>gen_bitlen</name><parameter_list>(<param><decl><type><name>s</name></type></decl></param>, <param><decl><type><name>desc</name></type></decl></param>)</parameter_list>
<decl_stmt><decl><type><name>deflate_state</name> *</type><name>s</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>tree_desc</name> *</type><name>desc</name></decl>;</decl_stmt>
<block>{
<decl_stmt><decl><type><name>ct_data</name> *</type><name>tree</name> <init>= <expr><name><name>desc</name>-&gt;<name>dyn_tree</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>max_code</name> <init>= <expr><name><name>desc</name>-&gt;<name>max_code</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>ct_data</name> *</type><name>stree</name> <init>= <expr><name><name>desc</name>-&gt;<name>stat_desc</name>-&gt;<name>static_tree</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>intf</name> *</type><name>extra</name> <init>= <expr><name><name>desc</name>-&gt;<name>stat_desc</name>-&gt;<name>extra_bits</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>base</name> <init>= <expr><name><name>desc</name>-&gt;<name>stat_desc</name>-&gt;<name>extra_base</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>max_length</name> <init>= <expr><name><name>desc</name>-&gt;<name>stat_desc</name>-&gt;<name>max_length</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>h</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>, <decl><type ref="prev"/><name>m</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>bits</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>xbits</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ush</name></type> <name>f</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>overflow</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<for>for (<init><expr><name>bits</name> = 0</expr>;</init> <condition><expr><name>bits</name> &lt;= <name>MAX_BITS</name></expr>;</condition> <incr><expr><name>bits</name>++</expr></incr>) <expr_stmt><expr><name><name>s</name>-&gt;<name>bl_count</name><index>[<expr><name>bits</name></expr>]</index></name> = 0</expr>;</expr_stmt></for>
<expr_stmt><expr><name><name>tree</name><index>[<expr><name><name>s</name>-&gt;<name>heap</name><index>[<expr><name><name>s</name>-&gt;<name>heap_max</name></name></expr>]</index></name></expr>]</index></name>.<name>Len</name> = 0</expr>;</expr_stmt>
<for>for (<init><expr><name>h</name> = <name><name>s</name>-&gt;<name>heap_max</name></name>+1</expr>;</init> <condition><expr><name>h</name> &lt; <name>HEAP_SIZE</name></expr>;</condition> <incr><expr><name>h</name>++</expr></incr>) <block>{
<expr_stmt><expr><name>n</name> = <name><name>s</name>-&gt;<name>heap</name><index>[<expr><name>h</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name>bits</name> = <name><name>tree</name><index>[<expr><name><name>tree</name><index>[<expr><name>n</name></expr>]</index></name>.<name>Dad</name></expr>]</index></name>.<name>Len</name> + 1</expr>;</expr_stmt>
<if>if <condition>(<expr><name>bits</name> &gt; <name>max_length</name></expr>)</condition><then> <expr_stmt><expr><name>bits</name> = <name>max_length</name></expr>, <expr><name>overflow</name>++</expr>;</expr_stmt></then></if>
<expr_stmt><expr><name><name>tree</name><index>[<expr><name>n</name></expr>]</index></name>.<name>Len</name> = (<name>ush</name>)<name>bits</name></expr>;</expr_stmt>
<if>if <condition>(<expr><name>n</name> &gt; <name>max_code</name></expr>)</condition><then> <continue>continue;</continue></then></if>
<expr_stmt><expr><name><name>s</name>-&gt;<name>bl_count</name><index>[<expr><name>bits</name></expr>]</index></name>++</expr>;</expr_stmt>
<expr_stmt><expr><name>xbits</name> = 0</expr>;</expr_stmt>
<if>if <condition>(<expr><name>n</name> &gt;= <name>base</name></expr>)</condition><then> <expr_stmt><expr><name>xbits</name> = <name><name>extra</name><index>[<expr><name>n</name>-<name>base</name></expr>]</index></name></expr>;</expr_stmt></then></if>
<expr_stmt><expr><name>f</name> = <name><name>tree</name><index>[<expr><name>n</name></expr>]</index></name>.<name>Freq</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name>-&gt;<name>opt_len</name></name> += (<name>ulg</name>)<call><name>f</name> * <argument_list>(<argument><expr><name>bits</name> + <name>xbits</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>stree</name></expr>)</condition><then> <expr_stmt><expr><name><name>s</name>-&gt;<name>static_len</name></name> += (<name>ulg</name>)<call><name>f</name> * <argument_list>(<argument><expr><name><name>stree</name><index>[<expr><name>n</name></expr>]</index></name>.<name>Len</name> + <name>xbits</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
}</block></for>
<if>if <condition>(<expr><name>overflow</name> == 0</expr>)</condition><then> <return>return;</return></then></if>
<expr_stmt><expr><call><name>Trace</name><argument_list>(<argument><expr>(<name>stderr</name>,"\nbit length overflow\n")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<do>do <block>{
<expr_stmt><expr><name>bits</name> = <name>max_length</name>-1</expr>;</expr_stmt>
<while>while <condition>(<expr><name><name>s</name>-&gt;<name>bl_count</name><index>[<expr><name>bits</name></expr>]</index></name> == 0</expr>)</condition> <expr_stmt><expr><name>bits</name>--</expr>;</expr_stmt></while>
<expr_stmt><expr><name><name>s</name>-&gt;<name>bl_count</name><index>[<expr><name>bits</name></expr>]</index></name>--</expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name>-&gt;<name>bl_count</name><index>[<expr><name>bits</name>+1</expr>]</index></name> += 2</expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name>-&gt;<name>bl_count</name><index>[<expr><name>max_length</name></expr>]</index></name>--</expr>;</expr_stmt>
<expr_stmt><expr><name>overflow</name> -= 2</expr>;</expr_stmt>
}</block> while <condition>(<expr><name>overflow</name> &gt; 0</expr>)</condition>;</do>
<for>for (<init><expr><name>bits</name> = <name>max_length</name></expr>;</init> <condition><expr><name>bits</name> != 0</expr>;</condition> <incr><expr><name>bits</name>--</expr></incr>) <block>{
<expr_stmt><expr><name>n</name> = <name><name>s</name>-&gt;<name>bl_count</name><index>[<expr><name>bits</name></expr>]</index></name></expr>;</expr_stmt>
<while>while <condition>(<expr><name>n</name> != 0</expr>)</condition> <block>{
<expr_stmt><expr><name>m</name> = <name><name>s</name>-&gt;<name>heap</name><index>[<expr>--<name>h</name></expr>]</index></name></expr>;</expr_stmt>
<if>if <condition>(<expr><name>m</name> &gt; <name>max_code</name></expr>)</condition><then> <continue>continue;</continue></then></if>
<if>if <condition>(<expr>(<name>unsigned</name>) <name><name>tree</name><index>[<expr><name>m</name></expr>]</index></name>.<name>Len</name> != (<name>unsigned</name>) <name>bits</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Trace</name><argument_list>(<argument><expr>(<name>stderr</name>,"code %d bits %d-&gt;%d\n", <name>m</name>, <name><name>tree</name><index>[<expr><name>m</name></expr>]</index></name>.<name>Len</name>, <name>bits</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name>-&gt;<name>opt_len</name></name> += ((<name>long</name>)<name>bits</name> - (<name>long</name>)<name><name>tree</name><index>[<expr><name>m</name></expr>]</index></name>.<name>Len</name>)
*(<name>long</name>)<name><name>tree</name><index>[<expr><name>m</name></expr>]</index></name>.<name>Freq</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tree</name><index>[<expr><name>m</name></expr>]</index></name>.<name>Len</name> = (<name>ush</name>)<name>bits</name></expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><name>n</name>--</expr>;</expr_stmt>
}</block></while>
}</block></for>
}</block></function>
<function><type><name>local</name> <name>void</name></type> <name>gen_codes</name> <parameter_list>(<param><decl><type><name>tree</name></type></decl></param>, <param><decl><type><name>max_code</name></type></decl></param>, <param><decl><type><name>bl_count</name></type></decl></param>)</parameter_list>
<decl_stmt><decl><type><name>ct_data</name> *</type><name>tree</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>max_code</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ushf</name> *</type><name>bl_count</name></decl>;</decl_stmt>
<block>{
<decl_stmt><decl><type><name>ush</name></type> <name><name>next_code</name><index>[<expr><name>MAX_BITS</name>+1</expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ush</name></type> <name>code</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>bits</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>;</decl_stmt>
<for>for (<init><expr><name>bits</name> = 1</expr>;</init> <condition><expr><name>bits</name> &lt;= <name>MAX_BITS</name></expr>;</condition> <incr><expr><name>bits</name>++</expr></incr>) <block>{
<expr_stmt><expr><name><name>next_code</name><index>[<expr><name>bits</name></expr>]</index></name> = <name>code</name> = (<name>code</name> + <name><name>bl_count</name><index>[<expr><name>bits</name>-1</expr>]</index></name>) &lt;&lt; 1</expr>;</expr_stmt>
}</block></for>
<expr_stmt><expr><call><name>Assert</name> <argument_list>(<argument><expr><name>code</name> + <name><name>bl_count</name><index>[<expr><name>MAX_BITS</name></expr>]</index></name>-1 == (1&lt;&lt;<name>MAX_BITS</name>)-1</expr></argument>,
<argument><expr>"inconsistent bit counts"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Tracev</name><argument_list>(<argument><expr>(<name>stderr</name>,"\ngen_codes: max_code %d ", <name>max_code</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for (<init><expr><name>n</name> = 0</expr>;</init> <condition><expr><name>n</name> &lt;= <name>max_code</name></expr>;</condition> <incr><expr><name>n</name>++</expr></incr>) <block>{
<decl_stmt><decl><type><name>int</name></type> <name>len</name> <init>= <expr><name><name>tree</name><index>[<expr><name>n</name></expr>]</index></name>.<name>Len</name></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>len</name> == 0</expr>)</condition><then> <continue>continue;</continue></then></if>
<expr_stmt><expr><name><name>tree</name><index>[<expr><name>n</name></expr>]</index></name>.<name>Code</name> = <call><name>bi_reverse</name><argument_list>(<argument><expr><name><name>next_code</name><index>[<expr><name>len</name></expr>]</index></name>++</expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Tracecv</name><argument_list>(<argument><expr><name>tree</name> != <name>static_ltree</name></expr></argument>, <argument><expr>(<name>stderr</name>,"\nn %3d %c l %2d c %4x (%x) ",
<name>n</name>, (<call><name>isgraph</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call> ? <name>n</name> : ' '), <name>len</name>, <name><name>tree</name><index>[<expr><name>n</name></expr>]</index></name>.<name>Code</name>, <name><name>next_code</name><index>[<expr><name>len</name></expr>]</index></name>-1)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></for>
}</block></function>
<function><type><name>local</name> <name>void</name></type> <name>build_tree</name><parameter_list>(<param><decl><type><name>s</name></type></decl></param>, <param><decl><type><name>desc</name></type></decl></param>)</parameter_list>
<decl_stmt><decl><type><name>deflate_state</name> *</type><name>s</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>tree_desc</name> *</type><name>desc</name></decl>;</decl_stmt>
<block>{
<decl_stmt><decl><type><name>ct_data</name> *</type><name>tree</name> <init>= <expr><name><name>desc</name>-&gt;<name>dyn_tree</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>ct_data</name> *</type><name>stree</name> <init>= <expr><name><name>desc</name>-&gt;<name>stat_desc</name>-&gt;<name>static_tree</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>elems</name> <init>= <expr><name><name>desc</name>-&gt;<name>stat_desc</name>-&gt;<name>elems</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>, <decl><type ref="prev"/><name>m</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>max_code</name> <init>= <expr>-1</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>node</name></decl>;</decl_stmt>
<expr_stmt><expr><name><name>s</name>-&gt;<name>heap_len</name></name> = 0</expr>, <expr><name><name>s</name>-&gt;<name>heap_max</name></name> = <name>HEAP_SIZE</name></expr>;</expr_stmt>
<for>for (<init><expr><name>n</name> = 0</expr>;</init> <condition><expr><name>n</name> &lt; <name>elems</name></expr>;</condition> <incr><expr><name>n</name>++</expr></incr>) <block>{
<if>if <condition>(<expr><name><name>tree</name><index>[<expr><name>n</name></expr>]</index></name>.<name>Freq</name> != 0</expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>s</name>-&gt;<name>heap</name><index>[<expr>++(<name><name>s</name>-&gt;<name>heap_len</name></name>)</expr>]</index></name> = <name>max_code</name> = <name>n</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name>-&gt;<name>depth</name><index>[<expr><name>n</name></expr>]</index></name> = 0</expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr><name><name>tree</name><index>[<expr><name>n</name></expr>]</index></name>.<name>Len</name> = 0</expr>;</expr_stmt>
}</block></else></if>
}</block></for>
<while>while <condition>(<expr><name><name>s</name>-&gt;<name>heap_len</name></name> &lt; 2</expr>)</condition> <block>{
<expr_stmt><expr><name>node</name> = <name><name>s</name>-&gt;<name>heap</name><index>[<expr>++(<name><name>s</name>-&gt;<name>heap_len</name></name>)</expr>]</index></name> = (<name>max_code</name> &lt; 2 ? ++<name>max_code</name> : 0)</expr>;</expr_stmt>
<expr_stmt><expr><name><name>tree</name><index>[<expr><name>node</name></expr>]</index></name>.<name>Freq</name> = 1</expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name>-&gt;<name>depth</name><index>[<expr><name>node</name></expr>]</index></name> = 0</expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name>-&gt;<name>opt_len</name></name>--</expr>;</expr_stmt>
<if>if <condition>(<expr><name>stree</name></expr>)</condition><then> <expr_stmt><expr><name><name>s</name>-&gt;<name>static_len</name></name> -= <name><name>stree</name><index>[<expr><name>node</name></expr>]</index></name>.<name>Len</name></expr>;</expr_stmt></then></if>
}</block></while>
<expr_stmt><expr><name><name>desc</name>-&gt;<name>max_code</name></name> = <name>max_code</name></expr>;</expr_stmt>
<for>for (<init><expr><name>n</name> = <name><name>s</name>-&gt;<name>heap_len</name></name>/2</expr>;</init> <condition><expr><name>n</name> &gt;= 1</expr>;</condition> <incr><expr><name>n</name>--</expr></incr>) <expr_stmt><expr><call><name>pqdownheap</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>tree</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></for>
<expr_stmt><expr><name>node</name> = <name>elems</name></expr>;</expr_stmt>
<do>do <block>{
<expr_stmt><expr><call><name>pqremove</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>tree</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>m</name> = <name><name>s</name>-&gt;<name>heap</name><index>[<expr><name>SMALLEST</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name>-&gt;<name>heap</name><index>[<expr>--(<name><name>s</name>-&gt;<name>heap_max</name></name>)</expr>]</index></name> = <name>n</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name>-&gt;<name>heap</name><index>[<expr>--(<name><name>s</name>-&gt;<name>heap_max</name></name>)</expr>]</index></name> = <name>m</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tree</name><index>[<expr><name>node</name></expr>]</index></name>.<name>Freq</name> = <name><name>tree</name><index>[<expr><name>n</name></expr>]</index></name>.<name>Freq</name> + <name><name>tree</name><index>[<expr><name>m</name></expr>]</index></name>.<name>Freq</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name>-&gt;<name>depth</name><index>[<expr><name>node</name></expr>]</index></name> = <call>(<name>uch</name>)<argument_list>(<argument><expr>(<name><name>s</name>-&gt;<name>depth</name><index>[<expr><name>n</name></expr>]</index></name> &gt;= <name><name>s</name>-&gt;<name>depth</name><index>[<expr><name>m</name></expr>]</index></name> ?
<name><name>s</name>-&gt;<name>depth</name><index>[<expr><name>n</name></expr>]</index></name> : <name><name>s</name>-&gt;<name>depth</name><index>[<expr><name>m</name></expr>]</index></name>) + 1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tree</name><index>[<expr><name>n</name></expr>]</index></name>.<name>Dad</name> = <name><name>tree</name><index>[<expr><name>m</name></expr>]</index></name>.<name>Dad</name> = (<name>ush</name>)<name>node</name></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>DUMP_BL_TREE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if>if <condition>(<expr><name>tree</name> == <name><name>s</name>-&gt;<name>bl_tree</name></name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,<argument><expr>"\nnode %d(%d), sons %d(%d) %d(%d)"</expr></argument>,
<argument><expr><name>node</name></expr></argument>, <argument><expr><name><name>tree</name><index>[<expr><name>node</name></expr>]</index></name>.<name>Freq</name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><name><name>tree</name><index>[<expr><name>n</name></expr>]</index></name>.<name>Freq</name></expr></argument>, <argument><expr><name>m</name></expr></argument>, <argument><expr><name><name>tree</name><index>[<expr><name>m</name></expr>]</index></name>.<name>Freq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><name><name>s</name>-&gt;<name>heap</name><index>[<expr><name>SMALLEST</name></expr>]</index></name> = <name>node</name>++</expr>;</expr_stmt>
<expr_stmt><expr><call><name>pqdownheap</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>tree</name></expr></argument>, <argument><expr><name>SMALLEST</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block> while <condition>(<expr><name><name>s</name>-&gt;<name>heap_len</name></name> &gt;= 2</expr>)</condition>;</do>
<expr_stmt><expr><name><name>s</name>-&gt;<name>heap</name><index>[<expr>--(<name><name>s</name>-&gt;<name>heap_max</name></name>)</expr>]</index></name> = <name><name>s</name>-&gt;<name>heap</name><index>[<expr><name>SMALLEST</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>gen_bitlen</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr>(<name>tree_desc</name> *)<name>desc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>gen_codes</name> <argument_list>(<argument><expr>(<name>ct_data</name> *)<name>tree</name></expr></argument>, <argument><expr><name>max_code</name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>bl_count</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>
<function><type><name>local</name> <name>void</name></type> <name>scan_tree</name> <parameter_list>(<param><decl><type><name>s</name></type></decl></param>, <param><decl><type><name>tree</name></type></decl></param>, <param><decl><type><name>max_code</name></type></decl></param>)</parameter_list>
<decl_stmt><decl><type><name>deflate_state</name> *</type><name>s</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ct_data</name> *</type><name>tree</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>max_code</name></decl>;</decl_stmt>
<block>{
<decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>prevlen</name> <init>= <expr>-1</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>curlen</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>nextlen</name> <init>= <expr><name><name>tree</name><index>[<expr>0</expr>]</index></name>.<name>Len</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>count</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>max_count</name> <init>= <expr>7</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>min_count</name> <init>= <expr>4</expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>nextlen</name> == 0</expr>)</condition><then> <expr_stmt><expr><name>max_count</name> = 138</expr>, <expr><name>min_count</name> = 3</expr>;</expr_stmt></then></if>
<expr_stmt><expr><name><name>tree</name><index>[<expr><name>max_code</name>+1</expr>]</index></name>.<name>Len</name> = (<name>ush</name>)0xffff</expr>;</expr_stmt>
<for>for (<init><expr><name>n</name> = 0</expr>;</init> <condition><expr><name>n</name> &lt;= <name>max_code</name></expr>;</condition> <incr><expr><name>n</name>++</expr></incr>) <block>{
<expr_stmt><expr><name>curlen</name> = <name>nextlen</name></expr>;</expr_stmt>
<expr_stmt><expr><name>nextlen</name> = <name><name>tree</name><index>[<expr><name>n</name>+1</expr>]</index></name>.<name>Len</name></expr>;</expr_stmt>
<if>if <condition>(<expr>++<name>count</name> &lt; <name>max_count</name> &amp;&amp; <name>curlen</name> == <name>nextlen</name></expr>)</condition><then> <block>{
<continue>continue;</continue>
}</block></then> <else>else <if>if <condition>(<expr><name>count</name> &lt; <name>min_count</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>s</name>-&gt;<name>bl_tree</name><index>[<expr><name>curlen</name></expr>]</index></name>.<name>Freq</name> += <name>count</name></expr>;</expr_stmt>
}</block></then> <else>else <if>if <condition>(<expr><name>curlen</name> != 0</expr>)</condition><then> <block>{
<if>if <condition>(<expr><name>curlen</name> != <name>prevlen</name></expr>)</condition><then> <expr_stmt><expr><name><name>s</name>-&gt;<name>bl_tree</name><index>[<expr><name>curlen</name></expr>]</index></name>.<name>Freq</name>++</expr>;</expr_stmt></then></if>
<expr_stmt><expr><name><name>s</name>-&gt;<name>bl_tree</name><index>[<expr><name>REP_3_6</name></expr>]</index></name>.<name>Freq</name>++</expr>;</expr_stmt>
}</block></then> <else>else <if>if <condition>(<expr><name>count</name> &lt;= 10</expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>s</name>-&gt;<name>bl_tree</name><index>[<expr><name>REPZ_3_10</name></expr>]</index></name>.<name>Freq</name>++</expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr><name><name>s</name>-&gt;<name>bl_tree</name><index>[<expr><name>REPZ_11_138</name></expr>]</index></name>.<name>Freq</name>++</expr>;</expr_stmt>
}</block></else></if></else></if></else></if></else></if>
<expr_stmt><expr><name>count</name> = 0</expr>;</expr_stmt>
<expr_stmt><expr><name>prevlen</name> = <name>curlen</name></expr>;</expr_stmt>
<if>if <condition>(<expr><name>nextlen</name> == 0</expr>)</condition><then> <block>{
<expr_stmt><expr><name>max_count</name> = 138</expr>, <expr><name>min_count</name> = 3</expr>;</expr_stmt>
}</block></then> <else>else <if>if <condition>(<expr><name>curlen</name> == <name>nextlen</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>max_count</name> = 6</expr>, <expr><name>min_count</name> = 3</expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr><name>max_count</name> = 7</expr>, <expr><name>min_count</name> = 4</expr>;</expr_stmt>
}</block></else></if></else></if>
}</block></for>
}</block></function>
<function><type><name>local</name> <name>void</name></type> <name>send_tree</name> <parameter_list>(<param><decl><type><name>s</name></type></decl></param>, <param><decl><type><name>tree</name></type></decl></param>, <param><decl><type><name>max_code</name></type></decl></param>)</parameter_list>
<decl_stmt><decl><type><name>deflate_state</name> *</type><name>s</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ct_data</name> *</type><name>tree</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>max_code</name></decl>;</decl_stmt>
<block>{
<decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>prevlen</name> <init>= <expr>-1</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>curlen</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>nextlen</name> <init>= <expr><name><name>tree</name><index>[<expr>0</expr>]</index></name>.<name>Len</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>count</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>max_count</name> <init>= <expr>7</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>min_count</name> <init>= <expr>4</expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>nextlen</name> == 0</expr>)</condition><then> <expr_stmt><expr><name>max_count</name> = 138</expr>, <expr><name>min_count</name> = 3</expr>;</expr_stmt></then></if>
<for>for (<init><expr><name>n</name> = 0</expr>;</init> <condition><expr><name>n</name> &lt;= <name>max_code</name></expr>;</condition> <incr><expr><name>n</name>++</expr></incr>) <block>{
<expr_stmt><expr><name>curlen</name> = <name>nextlen</name></expr>;</expr_stmt>
<expr_stmt><expr><name>nextlen</name> = <name><name>tree</name><index>[<expr><name>n</name>+1</expr>]</index></name>.<name>Len</name></expr>;</expr_stmt>
<if>if <condition>(<expr>++<name>count</name> &lt; <name>max_count</name> &amp;&amp; <name>curlen</name> == <name>nextlen</name></expr>)</condition><then> <block>{
<continue>continue;</continue>
}</block></then> <else>else <if>if <condition>(<expr><name>count</name> &lt; <name>min_count</name></expr>)</condition><then> <block>{
<do>do <block>{
<expr_stmt><expr><call><name>send_code</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>curlen</name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>bl_tree</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block> while <condition>(<expr>--<name>count</name> != 0</expr>)</condition>;</do>
}</block></then> <else>else <if>if <condition>(<expr><name>curlen</name> != 0</expr>)</condition><then> <block>{
<if>if <condition>(<expr><name>curlen</name> != <name>prevlen</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>send_code</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>curlen</name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>bl_tree</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>count</name>--</expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>count</name> &gt;= 3 &amp;&amp; <name>count</name> &lt;= 6</expr></argument>, <argument><expr>" 3_6?"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>send_code</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>REP_3_6</name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>bl_tree</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>send_bits</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>count</name>-3</expr></argument>, <argument><expr>2</expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else <if>if <condition>(<expr><name>count</name> &lt;= 10</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>send_code</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>REPZ_3_10</name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>bl_tree</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>send_bits</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>count</name>-3</expr></argument>, <argument><expr>3</expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr><call><name>send_code</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>REPZ_11_138</name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>bl_tree</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>send_bits</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>count</name>-11</expr></argument>, <argument><expr>7</expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></else></if></else></if></else></if></else></if>
<expr_stmt><expr><name>count</name> = 0</expr>;</expr_stmt>
<expr_stmt><expr><name>prevlen</name> = <name>curlen</name></expr>;</expr_stmt>
<if>if <condition>(<expr><name>nextlen</name> == 0</expr>)</condition><then> <block>{
<expr_stmt><expr><name>max_count</name> = 138</expr>, <expr><name>min_count</name> = 3</expr>;</expr_stmt>
}</block></then> <else>else <if>if <condition>(<expr><name>curlen</name> == <name>nextlen</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>max_count</name> = 6</expr>, <expr><name>min_count</name> = 3</expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr><name>max_count</name> = 7</expr>, <expr><name>min_count</name> = 4</expr>;</expr_stmt>
}</block></else></if></else></if>
}</block></for>
}</block></function>
<function><type><name>local</name> <name>int</name></type> <name>build_bl_tree</name><parameter_list>(<param><decl><type><name>s</name></type></decl></param>)</parameter_list>
<decl_stmt><decl><type><name>deflate_state</name> *</type><name>s</name></decl>;</decl_stmt>
<block>{
<decl_stmt><decl><type><name>int</name></type> <name>max_blindex</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>scan_tree</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr>(<name>ct_data</name> *)<name><name>s</name>-&gt;<name>dyn_ltree</name></name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>l_desc</name>.<name>max_code</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>scan_tree</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr>(<name>ct_data</name> *)<name><name>s</name>-&gt;<name>dyn_dtree</name></name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>d_desc</name>.<name>max_code</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>build_tree</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><call>(<name>tree_desc</name> *)<argument_list>(<argument><expr>&amp;(<name><name>s</name>-&gt;<name>bl_desc</name></name>)</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for (<init><expr><name>max_blindex</name> = <name>BL_CODES</name>-1</expr>;</init> <condition><expr><name>max_blindex</name> &gt;= 3</expr>;</condition> <incr><expr><name>max_blindex</name>--</expr></incr>) <block>{
<if>if <condition>(<expr><name><name>s</name>-&gt;<name>bl_tree</name><index>[<expr><name><name>bl_order</name><index>[<expr><name>max_blindex</name></expr>]</index></name></expr>]</index></name>.<name>Len</name> != 0</expr>)</condition><then> <break>break;</break></then></if>
}</block></for>
<expr_stmt><expr><name><name>s</name>-&gt;<name>opt_len</name></name> += 3*(<name>max_blindex</name>+1) + 5+5+4</expr>;</expr_stmt>
<expr_stmt><expr><call><name>Tracev</name><argument_list>(<argument><expr>(<name>stderr</name>, "\ndyn trees: dyn %ld, stat %ld",
<name><name>s</name>-&gt;<name>opt_len</name></name>, <name><name>s</name>-&gt;<name>static_len</name></name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>max_blindex</name></expr>;</return>
}</block></function>
<function><type><name>local</name> <name>void</name></type> <name>send_all_trees</name><parameter_list>(<param><decl><type><name>s</name></type></decl></param>, <param><decl><type><name>lcodes</name></type></decl></param>, <param><decl><type><name>dcodes</name></type></decl></param>, <param><decl><type><name>blcodes</name></type></decl></param>)</parameter_list>
<decl_stmt><decl><type><name>deflate_state</name> *</type><name>s</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>lcodes</name></decl>, <decl><type ref="prev"/><name>dcodes</name></decl>, <decl><type ref="prev"/><name>blcodes</name></decl>;</decl_stmt>
<block>{
<decl_stmt><decl><type><name>int</name></type> <name>rank</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>Assert</name> <argument_list>(<argument><expr><name>lcodes</name> &gt;= 257 &amp;&amp; <name>dcodes</name> &gt;= 1 &amp;&amp; <name>blcodes</name> &gt;= 4</expr></argument>, <argument><expr>"not enough codes"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Assert</name> <argument_list>(<argument><expr><name>lcodes</name> &lt;= <name>L_CODES</name> &amp;&amp; <name>dcodes</name> &lt;= <name>D_CODES</name> &amp;&amp; <name>blcodes</name> &lt;= <name>BL_CODES</name></expr></argument>,
<argument><expr>"too many codes"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Tracev</name><argument_list>(<argument><expr>(<name>stderr</name>, "\nbl counts: ")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>send_bits</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>lcodes</name>-257</expr></argument>, <argument><expr>5</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>send_bits</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>dcodes</name>-1</expr></argument>, <argument><expr>5</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>send_bits</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>blcodes</name>-4</expr></argument>, <argument><expr>4</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for (<init><expr><name>rank</name> = 0</expr>;</init> <condition><expr><name>rank</name> &lt; <name>blcodes</name></expr>;</condition> <incr><expr><name>rank</name>++</expr></incr>) <block>{
<expr_stmt><expr><call><name>Tracev</name><argument_list>(<argument><expr>(<name>stderr</name>, "\nbl code %2d ", <name><name>bl_order</name><index>[<expr><name>rank</name></expr>]</index></name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>send_bits</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>bl_tree</name><index>[<expr><name><name>bl_order</name><index>[<expr><name>rank</name></expr>]</index></name></expr>]</index></name>.<name>Len</name></expr></argument>, <argument><expr>3</expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></for>
<expr_stmt><expr><call><name>Tracev</name><argument_list>(<argument><expr>(<name>stderr</name>, "\nbl tree: sent %ld", <name><name>s</name>-&gt;<name>bits_sent</name></name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>send_tree</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr>(<name>ct_data</name> *)<name><name>s</name>-&gt;<name>dyn_ltree</name></name></expr></argument>, <argument><expr><name>lcodes</name>-1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Tracev</name><argument_list>(<argument><expr>(<name>stderr</name>, "\nlit tree: sent %ld", <name><name>s</name>-&gt;<name>bits_sent</name></name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>send_tree</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr>(<name>ct_data</name> *)<name><name>s</name>-&gt;<name>dyn_dtree</name></name></expr></argument>, <argument><expr><name>dcodes</name>-1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Tracev</name><argument_list>(<argument><expr>(<name>stderr</name>, "\ndist tree: sent %ld", <name><name>s</name>-&gt;<name>bits_sent</name></name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>
<function><type><name>void</name></type> <name>_tr_stored_block</name><parameter_list>(<param><decl><type><name>s</name></type></decl></param>, <param><decl><type><name>buf</name></type></decl></param>, <param><decl><type><name>stored_len</name></type></decl></param>, <param><decl><type><name>eof</name></type></decl></param>)</parameter_list>
<decl_stmt><decl><type><name>deflate_state</name> *</type><name>s</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>charf</name> *</type><name>buf</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ulg</name></type> <name>stored_len</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>eof</name></decl>;</decl_stmt>
<block>{
<expr_stmt><expr><call><name>send_bits</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr>(<name>STORED_BLOCK</name>&lt;&lt;1)+<name>eof</name></expr></argument>, <argument><expr>3</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>DEBUG</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><name><name>s</name>-&gt;<name>compressed_len</name></name> = (<name><name>s</name>-&gt;<name>compressed_len</name></name> + 3 + 7) &amp; (<name>ulg</name>)~7L</expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name>-&gt;<name>compressed_len</name></name> += (<name>stored_len</name> + 4) &lt;&lt; 3</expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><call><name>copy_block</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr>(<name>unsigned</name>)<name>stored_len</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>
<function><type><name>void</name></type> <name>_tr_align</name><parameter_list>(<param><decl><type><name>s</name></type></decl></param>)</parameter_list>
<decl_stmt><decl><type><name>deflate_state</name> *</type><name>s</name></decl>;</decl_stmt>
<block>{
<expr_stmt><expr><call><name>send_bits</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>STATIC_TREES</name>&lt;&lt;1</expr></argument>, <argument><expr>3</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>send_code</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>END_BLOCK</name></expr></argument>, <argument><expr><name>static_ltree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>DEBUG</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><name><name>s</name>-&gt;<name>compressed_len</name></name> += 10L</expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><call><name>bi_flush</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>1 + <name><name>s</name>-&gt;<name>last_eob_len</name></name> + 10 - <name><name>s</name>-&gt;<name>bi_valid</name></name> &lt; 9</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>send_bits</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>STATIC_TREES</name>&lt;&lt;1</expr></argument>, <argument><expr>3</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>send_code</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>END_BLOCK</name></expr></argument>, <argument><expr><name>static_ltree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>DEBUG</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><name><name>s</name>-&gt;<name>compressed_len</name></name> += 10L</expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><call><name>bi_flush</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><name><name>s</name>-&gt;<name>last_eob_len</name></name> = 7</expr>;</expr_stmt>
}</block></function>
<function><type><name>void</name></type> <name>_tr_flush_block</name><parameter_list>(<param><decl><type><name>s</name></type></decl></param>, <param><decl><type><name>buf</name></type></decl></param>, <param><decl><type><name>stored_len</name></type></decl></param>, <param><decl><type><name>eof</name></type></decl></param>)</parameter_list>
<decl_stmt><decl><type><name>deflate_state</name> *</type><name>s</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>charf</name> *</type><name>buf</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ulg</name></type> <name>stored_len</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>eof</name></decl>;</decl_stmt>
<block>{
<decl_stmt><decl><type><name>ulg</name></type> <name>opt_lenb</name></decl>, <decl><type ref="prev"/><name>static_lenb</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>max_blindex</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name><name>s</name>-&gt;<name>level</name></name> &gt; 0</expr>)</condition><then> <block>{
<if>if <condition>(<expr><name>stored_len</name> &gt; 0 &amp;&amp; <name><name>s</name>-&gt;<name>strm</name>-&gt;<name>data_type</name></name> == <name>Z_UNKNOWN</name></expr>)</condition><then>
<expr_stmt><expr><call><name>set_data_type</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<expr_stmt><expr><call><name>build_tree</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><call>(<name>tree_desc</name> *)<argument_list>(<argument><expr>&amp;(<name><name>s</name>-&gt;<name>l_desc</name></name>)</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Tracev</name><argument_list>(<argument><expr>(<name>stderr</name>, "\nlit data: dyn %ld, stat %ld", <name><name>s</name>-&gt;<name>opt_len</name></name>,
<name><name>s</name>-&gt;<name>static_len</name></name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>build_tree</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><call>(<name>tree_desc</name> *)<argument_list>(<argument><expr>&amp;(<name><name>s</name>-&gt;<name>d_desc</name></name>)</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Tracev</name><argument_list>(<argument><expr>(<name>stderr</name>, "\ndist data: dyn %ld, stat %ld", <name><name>s</name>-&gt;<name>opt_len</name></name>,
<name><name>s</name>-&gt;<name>static_len</name></name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>max_blindex</name> = <call><name>build_bl_tree</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>opt_lenb</name> = (<name><name>s</name>-&gt;<name>opt_len</name></name>+3+7)&gt;&gt;3</expr>;</expr_stmt>
<expr_stmt><expr><name>static_lenb</name> = (<name><name>s</name>-&gt;<name>static_len</name></name>+3+7)&gt;&gt;3</expr>;</expr_stmt>
<expr_stmt><expr><call><name>Tracev</name><argument_list>(<argument><expr>(<name>stderr</name>, "\nopt %lu(%lu) stat %lu(%lu) stored %lu lit %u ",
<name>opt_lenb</name>, <name><name>s</name>-&gt;<name>opt_len</name></name>, <name>static_lenb</name>, <name><name>s</name>-&gt;<name>static_len</name></name>, <name>stored_len</name>,
<name><name>s</name>-&gt;<name>last_lit</name></name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>static_lenb</name> &lt;= <name>opt_lenb</name></expr>)</condition><then> <expr_stmt><expr><name>opt_lenb</name> = <name>static_lenb</name></expr>;</expr_stmt></then></if>
}</block></then> <else>else <block>{
<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>buf</name> != (<name>char</name>*)0</expr></argument>, <argument><expr>"lost buf"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>opt_lenb</name> = <name>static_lenb</name> = <name>stored_len</name> + 5</expr>;</expr_stmt>
}</block></else></if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FORCE_STORED</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if>if <condition>(<expr><name>buf</name> != (<name>char</name>*)0</expr>)</condition><then> <block>{
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<if>if <condition>(<expr><name>stored_len</name>+4 &lt;= <name>opt_lenb</name> &amp;&amp; <name>buf</name> != (<name>char</name>*)0</expr>)</condition><then> <block>{
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><call><name>_tr_stored_block</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>stored_len</name></expr></argument>, <argument><expr><name>eof</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FORCE_STATIC</name></expr></argument>)</argument_list></call></expr></cpp:if>
}</block></then> <else>else <if>if <condition>(<expr><name>static_lenb</name> &gt;= 0</expr>)</condition><then> <block>{
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
}</block></then> <else>else <if>if <condition>(<expr><name><name>s</name>-&gt;<name>strategy</name></name> == <name>Z_FIXED</name> || <name>static_lenb</name> == <name>opt_lenb</name></expr>)</condition><then> <block>{
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><call><name>send_bits</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr>(<name>STATIC_TREES</name>&lt;&lt;1)+<name>eof</name></expr></argument>, <argument><expr>3</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>compress_block</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr>(<name>ct_data</name> *)<name>static_ltree</name></expr></argument>, <argument><expr>(<name>ct_data</name> *)<name>static_dtree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>DEBUG</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><name><name>s</name>-&gt;<name>compressed_len</name></name> += 3 + <name><name>s</name>-&gt;<name>static_len</name></name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></then> <else>else <block>{
<expr_stmt><expr><call><name>send_bits</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr>(<name>DYN_TREES</name>&lt;&lt;1)+<name>eof</name></expr></argument>, <argument><expr>3</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>send_all_trees</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>l_desc</name>.<name>max_code</name></name>+1</expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>d_desc</name>.<name>max_code</name></name>+1</expr></argument>,
<argument><expr><name>max_blindex</name>+1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>compress_block</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr>(<name>ct_data</name> *)<name><name>s</name>-&gt;<name>dyn_ltree</name></name></expr></argument>, <argument><expr>(<name>ct_data</name> *)<name><name>s</name>-&gt;<name>dyn_dtree</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>DEBUG</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><name><name>s</name>-&gt;<name>compressed_len</name></name> += 3 + <name><name>s</name>-&gt;<name>opt_len</name></name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></else></if></else></if></else></if>
<expr_stmt><expr><call><name>Assert</name> <argument_list>(<argument><expr><name><name>s</name>-&gt;<name>compressed_len</name></name> == <name><name>s</name>-&gt;<name>bits_sent</name></name></expr></argument>, <argument><expr>"bad compressed size"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>init_block</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>eof</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>bi_windup</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>DEBUG</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><name><name>s</name>-&gt;<name>compressed_len</name></name> += 7</expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></then></if>
<expr_stmt><expr><call><name>Tracev</name><argument_list>(<argument><expr>(<name>stderr</name>,"\ncomprlen %lu(%lu) ", <name><name>s</name>-&gt;<name>compressed_len</name></name>&gt;&gt;3,
<name><name>s</name>-&gt;<name>compressed_len</name></name>-7*<name>eof</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<function><type><name>int</name></type> <name>_tr_tally</name> <parameter_list>(<param><decl><type><name>s</name></type></decl></param>, <param><decl><type><name>dist</name></type></decl></param>, <param><decl><type><name>lc</name></type></decl></param>)</parameter_list>
<decl_stmt><decl><type><name>deflate_state</name> *</type><name>s</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name></type> <name>dist</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name></type> <name>lc</name></decl>;</decl_stmt>
<block>{
<expr_stmt><expr><name><name>s</name>-&gt;<name>d_buf</name><index>[<expr><name><name>s</name>-&gt;<name>last_lit</name></name></expr>]</index></name> = (<name>ush</name>)<name>dist</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name>-&gt;<name>l_buf</name><index>[<expr><name><name>s</name>-&gt;<name>last_lit</name></name>++</expr>]</index></name> = (<name>uch</name>)<name>lc</name></expr>;</expr_stmt>
<if>if <condition>(<expr><name>dist</name> == 0</expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>s</name>-&gt;<name>dyn_ltree</name><index>[<expr><name>lc</name></expr>]</index></name>.<name>Freq</name>++</expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr><name><name>s</name>-&gt;<name>matches</name></name>++</expr>;</expr_stmt>
<expr_stmt><expr><name>dist</name>--</expr>;</expr_stmt>
<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr>(<name>ush</name>)<name>dist</name> &lt; (<name>ush</name>)<call><name>MAX_DIST</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call> &amp;&amp;
(<name>ush</name>)<name>lc</name> &lt;= <call>(<name>ush</name>)<argument_list>(<argument><expr><name>MAX_MATCH</name>-<name>MIN_MATCH</name></expr></argument>)</argument_list></call> &amp;&amp;
(<name>ush</name>)<call><name>d_code</name><argument_list>(<argument><expr><name>dist</name></expr></argument>)</argument_list></call> &lt; (<name>ush</name>)<name>D_CODES</name></expr></argument>, <argument><expr>"_tr_tally: bad match"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name>-&gt;<name>dyn_ltree</name><index>[<expr><name><name>_length_code</name><index>[<expr><name>lc</name></expr>]</index></name>+<name>LITERALS</name>+1</expr>]</index></name>.<name>Freq</name>++</expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name>-&gt;<name>dyn_dtree</name><index>[<expr><call><name>d_code</name><argument_list>(<argument><expr><name>dist</name></expr></argument>)</argument_list></call></expr>]</index></name>.<name>Freq</name>++</expr>;</expr_stmt>
}</block></else></if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>TRUNCATE_BLOCK</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if>if <condition>(<expr>(<name><name>s</name>-&gt;<name>last_lit</name></name> &amp; 0x1fff) == 0 &amp;&amp; <name><name>s</name>-&gt;<name>level</name></name> &gt; 2</expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>ulg</name></type> <name>out_length</name> <init>= <expr>(<name>ulg</name>)<name><name>s</name>-&gt;<name>last_lit</name></name>*8L</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ulg</name></type> <name>in_length</name> <init>= <expr><call>(<name>ulg</name>)<argument_list>(<argument><expr>(<name>long</name>)<name><name>s</name>-&gt;<name>strstart</name></name> - <name><name>s</name>-&gt;<name>block_start</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>dcode</name></decl>;</decl_stmt>
<for>for (<init><expr><name>dcode</name> = 0</expr>;</init> <condition><expr><name>dcode</name> &lt; <name>D_CODES</name></expr>;</condition> <incr><expr><name>dcode</name>++</expr></incr>) <block>{
<expr_stmt><expr><name>out_length</name> += (<name>ulg</name>)<name><name>s</name>-&gt;<name>dyn_dtree</name><index>[<expr><name>dcode</name></expr>]</index></name>.<call><name>Freq</name> *
<argument_list>(<argument><expr>5L+<name><name>extra_dbits</name><index>[<expr><name>dcode</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></for>
<expr_stmt><expr><name>out_length</name> &gt;&gt;= 3</expr>;</expr_stmt>
<expr_stmt><expr><call><name>Tracev</name><argument_list>(<argument><expr>(<name>stderr</name>,"\nlast_lit %u, in %ld, out ~%ld(%ld%%) ",
<name><name>s</name>-&gt;<name>last_lit</name></name>, <name>in_length</name>, <name>out_length</name>,
100L - <name>out_length</name>*100L/<name>in_length</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>s</name>-&gt;<name>matches</name></name> &lt; <name><name>s</name>-&gt;<name>last_lit</name></name>/2 &amp;&amp; <name>out_length</name> &lt; <name>in_length</name>/2</expr>)</condition><then> <return>return <expr>1</expr>;</return></then></if>
}</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<return>return <expr>(<name><name>s</name>-&gt;<name>last_lit</name></name> == <name><name>s</name>-&gt;<name>lit_bufsize</name></name>-1)</expr>;</return>
}</block></function>
<function><type><name>local</name> <name>void</name></type> <name>compress_block</name><parameter_list>(<param><decl><type><name>s</name></type></decl></param>, <param><decl><type><name>ltree</name></type></decl></param>, <param><decl><type><name>dtree</name></type></decl></param>)</parameter_list>
<decl_stmt><decl><type><name>deflate_state</name> *</type><name>s</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ct_data</name> *</type><name>ltree</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ct_data</name> *</type><name>dtree</name></decl>;</decl_stmt>
<block>{
<decl_stmt><decl><type><name>unsigned</name></type> <name>dist</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>lc</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name></type> <name>lx</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name></type> <name>code</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>extra</name></decl>;</decl_stmt>
<if>if <condition>(<expr><name><name>s</name>-&gt;<name>last_lit</name></name> != 0</expr>)</condition><then> <do>do <block>{
<expr_stmt><expr><name>dist</name> = <name><name>s</name>-&gt;<name>d_buf</name><index>[<expr><name>lx</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name>lc</name> = <name><name>s</name>-&gt;<name>l_buf</name><index>[<expr><name>lx</name>++</expr>]</index></name></expr>;</expr_stmt>
<if>if <condition>(<expr><name>dist</name> == 0</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>send_code</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>lc</name></expr></argument>, <argument><expr><name>ltree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Tracecv</name><argument_list>(<argument><expr><call><name>isgraph</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>(<name>stderr</name>," '%c' ", <name>lc</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr><name>code</name> = <name><name>_length_code</name><index>[<expr><name>lc</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>send_code</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>code</name>+<name>LITERALS</name>+1</expr></argument>, <argument><expr><name>ltree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>extra</name> = <name><name>extra_lbits</name><index>[<expr><name>code</name></expr>]</index></name></expr>;</expr_stmt>
<if>if <condition>(<expr><name>extra</name> != 0</expr>)</condition><then> <block>{
<expr_stmt><expr><name>lc</name> -= <name><name>base_length</name><index>[<expr><name>code</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>send_bits</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>lc</name></expr></argument>, <argument><expr><name>extra</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><name>dist</name>--</expr>;</expr_stmt>
<expr_stmt><expr><name>code</name> = <call><name>d_code</name><argument_list>(<argument><expr><name>dist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Assert</name> <argument_list>(<argument><expr><name>code</name> &lt; <name>D_CODES</name></expr></argument>, <argument><expr>"bad d_code"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>send_code</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>code</name></expr></argument>, <argument><expr><name>dtree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>extra</name> = <name><name>extra_dbits</name><index>[<expr><name>code</name></expr>]</index></name></expr>;</expr_stmt>
<if>if <condition>(<expr><name>extra</name> != 0</expr>)</condition><then> <block>{
<expr_stmt><expr><name>dist</name> -= <name><name>base_dist</name><index>[<expr><name>code</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>send_bits</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>dist</name></expr></argument>, <argument><expr><name>extra</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
}</block></else></if>
<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call>(<name>uInt</name>)<argument_list>(<argument><expr><name><name>s</name>-&gt;<name>pending</name></name></expr></argument>)</argument_list></call> &lt; <name><name>s</name>-&gt;<name>lit_bufsize</name></name> + 2*<name>lx</name></expr></argument>,
<argument><expr>"pendingBuf overflow"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block> while <condition>(<expr><name>lx</name> &lt; <name><name>s</name>-&gt;<name>last_lit</name></name></expr>)</condition>;</do></then></if>
<expr_stmt><expr><call><name>send_code</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>END_BLOCK</name></expr></argument>, <argument><expr><name>ltree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name>-&gt;<name>last_eob_len</name></name> = <name><name>ltree</name><index>[<expr><name>END_BLOCK</name></expr>]</index></name>.<name>Len</name></expr>;</expr_stmt>
}</block></function>
<function><type><name>local</name> <name>void</name></type> <name>set_data_type</name><parameter_list>(<param><decl><type><name>s</name></type></decl></param>)</parameter_list>
<decl_stmt><decl><type><name>deflate_state</name> *</type><name>s</name></decl>;</decl_stmt>
<block>{
<decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>;</decl_stmt>
<for>for (<init><expr><name>n</name> = 0</expr>;</init> <condition><expr><name>n</name> &lt; 9</expr>;</condition> <incr><expr><name>n</name>++</expr></incr>)
<if>if <condition>(<expr><name><name>s</name>-&gt;<name>dyn_ltree</name><index>[<expr><name>n</name></expr>]</index></name>.<name>Freq</name> != 0</expr>)</condition><then>
<break>break;</break></then></if></for>
<if>if <condition>(<expr><name>n</name> == 9</expr>)</condition><then>
<for>for (<init><expr><name>n</name> = 14</expr>;</init> <condition><expr><name>n</name> &lt; 32</expr>;</condition> <incr><expr><name>n</name>++</expr></incr>)
<if>if <condition>(<expr><name><name>s</name>-&gt;<name>dyn_ltree</name><index>[<expr><name>n</name></expr>]</index></name>.<name>Freq</name> != 0</expr>)</condition><then>
<break>break;</break></then></if></for></then></if>
<expr_stmt><expr><name><name>s</name>-&gt;<name>strm</name>-&gt;<name>data_type</name></name> = (<name>n</name> == 32) ? <name>Z_TEXT</name> : <name>Z_BINARY</name></expr>;</expr_stmt>
}</block></function>
<function><type><name>local</name> <name>unsigned</name></type> <name>bi_reverse</name><parameter_list>(<param><decl><type><name>code</name></type></decl></param>, <param><decl><type><name>len</name></type></decl></param>)</parameter_list>
<decl_stmt><decl><type><name>unsigned</name></type> <name>code</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>len</name></decl>;</decl_stmt>
<block>{
<decl_stmt><decl><type><name>register</name> <name>unsigned</name></type> <name>res</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<do>do <block>{
<expr_stmt><expr><name>res</name> |= <name>code</name> &amp; 1</expr>;</expr_stmt>
<expr_stmt><expr><name>code</name> &gt;&gt;= 1</expr>, <expr><name>res</name> &lt;&lt;= 1</expr>;</expr_stmt>
}</block> while <condition>(<expr>--<name>len</name> &gt; 0</expr>)</condition>;</do>
<return>return <expr><name>res</name> &gt;&gt; 1</expr>;</return>
}</block></function>
<function><type><name>local</name> <name>void</name></type> <name>bi_flush</name><parameter_list>(<param><decl><type><name>s</name></type></decl></param>)</parameter_list>
<decl_stmt><decl><type><name>deflate_state</name> *</type><name>s</name></decl>;</decl_stmt>
<block>{
<if>if <condition>(<expr><name><name>s</name>-&gt;<name>bi_valid</name></name> == 16</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>put_short</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>bi_buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name>-&gt;<name>bi_buf</name></name> = 0</expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name>-&gt;<name>bi_valid</name></name> = 0</expr>;</expr_stmt>
}</block></then> <else>else <if>if <condition>(<expr><name><name>s</name>-&gt;<name>bi_valid</name></name> &gt;= 8</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>put_byte</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr>(<name>Byte</name>)<name><name>s</name>-&gt;<name>bi_buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name>-&gt;<name>bi_buf</name></name> &gt;&gt;= 8</expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name>-&gt;<name>bi_valid</name></name> -= 8</expr>;</expr_stmt>
}</block></then></if></else></if>
}</block></function>
<function><type><name>local</name> <name>void</name></type> <name>bi_windup</name><parameter_list>(<param><decl><type><name>s</name></type></decl></param>)</parameter_list>
<decl_stmt><decl><type><name>deflate_state</name> *</type><name>s</name></decl>;</decl_stmt>
<block>{
<if>if <condition>(<expr><name><name>s</name>-&gt;<name>bi_valid</name></name> &gt; 8</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>put_short</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>bi_buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else <if>if <condition>(<expr><name><name>s</name>-&gt;<name>bi_valid</name></name> &gt; 0</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>put_byte</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr>(<name>Byte</name>)<name><name>s</name>-&gt;<name>bi_buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if></else></if>
<expr_stmt><expr><name><name>s</name>-&gt;<name>bi_buf</name></name> = 0</expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name>-&gt;<name>bi_valid</name></name> = 0</expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>DEBUG</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><name><name>s</name>-&gt;<name>bits_sent</name></name> = (<name><name>s</name>-&gt;<name>bits_sent</name></name>+7) &amp; ~7</expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></function>
<function><type><name>local</name> <name>void</name></type> <name>copy_block</name><parameter_list>(<param><decl><type><name>s</name></type></decl></param>, <param><decl><type><name>buf</name></type></decl></param>, <param><decl><type><name>len</name></type></decl></param>, <param><decl><type><name>header</name></type></decl></param>)</parameter_list>
<decl_stmt><decl><type><name>deflate_state</name> *</type><name>s</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>charf</name> *</type><name>buf</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name></type> <name>len</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>header</name></decl>;</decl_stmt>
<block>{
<expr_stmt><expr><call><name>bi_windup</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name>-&gt;<name>last_eob_len</name></name> = 8</expr>;</expr_stmt>
<if>if <condition>(<expr><name>header</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>put_short</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr>(<name>ush</name>)<name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>put_short</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr>(<name>ush</name>)~<name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>DEBUG</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><name><name>s</name>-&gt;<name>bits_sent</name></name> += 2*16</expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></then></if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>DEBUG</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><name><name>s</name>-&gt;<name>bits_sent</name></name> += (<name>ulg</name>)<name>len</name>&lt;&lt;3</expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<while>while <condition>(<expr><name>len</name>--</expr>)</condition> <block>{
<expr_stmt><expr><call><name>put_byte</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr>*<name>buf</name>++</expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></while>
}</block></function></block></function>
</unit>
