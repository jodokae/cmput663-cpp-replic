<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C" filename="Modules/zlib/deflate.c"><cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"deflate.h"</cpp:file></cpp:include>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name></type> <name><name>deflate_copyright</name><index>[]</index></name> <init>=
<expr>" deflate 1.2.3 Copyright 1995-2005 Jean-loup Gailly "</expr></init></decl>;</decl_stmt>
<typedef>typedef <type><enum>enum <block>{
<decl><name>need_more</name></decl>,
<decl><name>block_done</name></decl>,
<decl><name>finish_started</name></decl>,
<decl><name>finish_done</name></decl>
}</block></enum></type> <name>block_state</name>;</typedef>
<typedef>typedef <macro><name>block_state</name> <argument_list>(<argument>*compress_func</argument>)</argument_list></macro> <expr_stmt><expr><call><name>OF</name><argument_list>(<argument><expr>(<name>deflate_state</name> *<name>s</name>, <name>int</name> <name>flush</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt></typedef>
<decl_stmt><decl><type><name>local</name> <name>void</name> <name>fill_window</name></type> <name>OF</name><argument_list>(<argument><expr>(<name>deflate_state</name> *<name>s</name>)</expr></argument>)</argument_list></decl>;</decl_stmt>
<decl_stmt><decl><type><name>local</name> <name>block_state</name> <name>deflate_stored</name></type> <name>OF</name><argument_list>(<argument><expr>(<name>deflate_state</name> *<name>s</name>, <name>int</name> <name>flush</name>)</expr></argument>)</argument_list></decl>;</decl_stmt>
<decl_stmt><decl><type><name>local</name> <name>block_state</name> <name>deflate_fast</name></type> <name>OF</name><argument_list>(<argument><expr>(<name>deflate_state</name> *<name>s</name>, <name>int</name> <name>flush</name>)</expr></argument>)</argument_list></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>FASTEST</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>local</name> <name>block_state</name> <name>deflate_slow</name></type> <name>OF</name><argument_list>(<argument><expr>(<name>deflate_state</name> *<name>s</name>, <name>int</name> <name>flush</name>)</expr></argument>)</argument_list></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<decl_stmt><decl><type><name>local</name> <name>void</name> <name>lm_init</name></type> <name>OF</name><argument_list>(<argument><expr>(<name>deflate_state</name> *<name>s</name>)</expr></argument>)</argument_list></decl>;</decl_stmt>
<decl_stmt><decl><type><name>local</name> <name>void</name> <name>putShortMSB</name></type> <name>OF</name><argument_list>(<argument><expr>(<name>deflate_state</name> *<name>s</name>, <name>uInt</name> <name>b</name>)</expr></argument>)</argument_list></decl>;</decl_stmt>
<decl_stmt><decl><type><name>local</name> <name>void</name> <name>flush_pending</name></type> <name>OF</name><argument_list>(<argument><expr>(<name>z_streamp</name> <name>strm</name>)</expr></argument>)</argument_list></decl>;</decl_stmt>
<decl_stmt><decl><type><name>local</name> <name>int</name> <name>read_buf</name></type> <name>OF</name><argument_list>(<argument><expr>(<name>z_streamp</name> <name>strm</name>, <name>Bytef</name> *<name>buf</name>, <name>unsigned</name> <name>size</name>)</expr></argument>)</argument_list></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>FASTEST</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>ASMV</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>void</name> <name>match_init</name></type> <name>OF</name><argument_list>(<argument><expr>(<name>void</name>)</expr></argument>)</argument_list></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uInt</name> <name>longest_match</name></type> <name>OF</name><argument_list>(<argument><expr>(<name>deflate_state</name> *<name>s</name>, <name>IPos</name> <name>cur_match</name>)</expr></argument>)</argument_list></decl>;</decl_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<decl_stmt><decl><type><name>local</name> <name>uInt</name> <name>longest_match</name></type> <name>OF</name><argument_list>(<argument><expr>(<name>deflate_state</name> *<name>s</name>, <name>IPos</name> <name>cur_match</name>)</expr></argument>)</argument_list></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<decl_stmt><decl><type><name>local</name> <name>uInt</name> <name>longest_match_fast</name></type> <name>OF</name><argument_list>(<argument><expr>(<name>deflate_state</name> *<name>s</name>, <name>IPos</name> <name>cur_match</name>)</expr></argument>)</argument_list></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>DEBUG</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>local</name> <name>void</name> <name>check_match</name></type> <name>OF</name><argument_list>(<argument><expr>(<name>deflate_state</name> *<name>s</name>, <name>IPos</name> <name>start</name>, <name>IPos</name> <name>match</name>,
<name>int</name> <name>length</name>)</expr></argument>)</argument_list></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NIL</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>TOO_FAR</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TOO_FAR</name></cpp:macro> <cpp:value>4096</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MIN_LOOKAHEAD</name></cpp:macro> <cpp:value>(MAX_MATCH+MIN_MATCH+1)</cpp:value></cpp:define>
<typedef>typedef <type><struct>struct <name>config_s</name> <block>{
<decl_stmt><decl><type><name>ush</name></type> <name>good_length</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ush</name></type> <name>max_lazy</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ush</name></type> <name>nice_length</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ush</name></type> <name>max_chain</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>compress_func</name></type> <name>func</name></decl>;</decl_stmt>
}</block></struct></type> <name>config</name>;</typedef>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FASTEST</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>local</name> <specifier>const</specifier> <name>config</name></type> <name><name>configuration_table</name><index>[<expr>2</expr>]</index></name> <init>= <expr><block>{
<expr><block>{<expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr><name>deflate_stored</name></expr>}</block></expr>,
<expr><block>{<expr>4</expr>, <expr>4</expr>, <expr>8</expr>, <expr>4</expr>, <expr><name>deflate_fast</name></expr>}</block></expr>
}</block></expr></init></decl>;</decl_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<decl_stmt><decl><type><name>local</name> <specifier>const</specifier> <name>config</name></type> <name><name>configuration_table</name><index>[<expr>10</expr>]</index></name> <init>= <expr><block>{
<expr><block>{<expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr><name>deflate_stored</name></expr>}</block></expr>,
<expr><block>{<expr>4</expr>, <expr>4</expr>, <expr>8</expr>, <expr>4</expr>, <expr><name>deflate_fast</name></expr>}</block></expr>,
<expr><block>{<expr>4</expr>, <expr>5</expr>, <expr>16</expr>, <expr>8</expr>, <expr><name>deflate_fast</name></expr>}</block></expr>,
<expr><block>{<expr>4</expr>, <expr>6</expr>, <expr>32</expr>, <expr>32</expr>, <expr><name>deflate_fast</name></expr>}</block></expr>,
<expr><block>{<expr>4</expr>, <expr>4</expr>, <expr>16</expr>, <expr>16</expr>, <expr><name>deflate_slow</name></expr>}</block></expr>,
<expr><block>{<expr>8</expr>, <expr>16</expr>, <expr>32</expr>, <expr>32</expr>, <expr><name>deflate_slow</name></expr>}</block></expr>,
<expr><block>{<expr>8</expr>, <expr>16</expr>, <expr>128</expr>, <expr>128</expr>, <expr><name>deflate_slow</name></expr>}</block></expr>,
<expr><block>{<expr>8</expr>, <expr>32</expr>, <expr>128</expr>, <expr>256</expr>, <expr><name>deflate_slow</name></expr>}</block></expr>,
<expr><block>{<expr>32</expr>, <expr>128</expr>, <expr>258</expr>, <expr>1024</expr>, <expr><name>deflate_slow</name></expr>}</block></expr>,
<expr><block>{<expr>32</expr>, <expr>258</expr>, <expr>258</expr>, <expr>4096</expr>, <expr><name>deflate_slow</name></expr>}</block></expr>
}</block></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>EQUAL</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>NO_DUMMY_DECL</name></expr></argument>)</argument_list></call></expr></cpp:if>
<struct>struct <name>static_tree_desc_s</name> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>dummy</name></decl>;</decl_stmt>
}</block>;</struct>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>UPDATE_HASH</name><parameter_list>(<param><type><name>s</name></type></param>,<param><type><name>h</name></type></param>,<param><type><name>c</name></type></param>)</parameter_list></cpp:macro> <cpp:value>(h = (((h)&lt;&lt;s-&gt;hash_shift) ^ (c)) &amp; s-&gt;hash_mask)</cpp:value></cpp:define>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FASTEST</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INSERT_STRING</name><parameter_list>(<param><type><name>s</name></type></param>, <param><type><name>str</name></type></param>, <param><type><name>match_head</name></type></param>)</parameter_list></cpp:macro> <cpp:value>(UPDATE_HASH(s, s-&gt;ins_h, s-&gt;window[(str) + (MIN_MATCH-1)]), match_head = s-&gt;head[s-&gt;ins_h], s-&gt;head[s-&gt;ins_h] = (Pos)(str))</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INSERT_STRING</name><parameter_list>(<param><type><name>s</name></type></param>, <param><type><name>str</name></type></param>, <param><type><name>match_head</name></type></param>)</parameter_list></cpp:macro> <cpp:value>(UPDATE_HASH(s, s-&gt;ins_h, s-&gt;window[(str) + (MIN_MATCH-1)]), match_head = s-&gt;prev[(str) &amp; s-&gt;w_mask] = s-&gt;head[s-&gt;ins_h], s-&gt;head[s-&gt;ins_h] = (Pos)(str))</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CLEAR_HASH</name><parameter_list>(<param><type><name>s</name></type></param>)</parameter_list></cpp:macro> <cpp:value>s-&gt;head[s-&gt;hash_size-1] = NIL; zmemzero((Bytef *)s-&gt;head, (unsigned)(s-&gt;hash_size-1)*sizeof(*s-&gt;head));</cpp:value></cpp:define>
<function><type><name>int</name> <name>ZEXPORT</name></type> <name>deflateInit_</name><parameter_list>(<param><decl><type><name>strm</name></type></decl></param>, <param><decl><type><name>level</name></type></decl></param>, <param><decl><type><name>version</name></type></decl></param>, <param><decl><type><name>stream_size</name></type></decl></param>)</parameter_list>
<decl_stmt><decl><type><name>z_streamp</name></type> <name>strm</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>level</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>version</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>stream_size</name></decl>;</decl_stmt>
<block>{
<return>return <expr><call><name>deflateInit2_</name><argument_list>(<argument><expr><name>strm</name></expr></argument>, <argument><expr><name>level</name></expr></argument>, <argument><expr><name>Z_DEFLATED</name></expr></argument>, <argument><expr><name>MAX_WBITS</name></expr></argument>, <argument><expr><name>DEF_MEM_LEVEL</name></expr></argument>,
<argument><expr><name>Z_DEFAULT_STRATEGY</name></expr></argument>, <argument><expr><name>version</name></expr></argument>, <argument><expr><name>stream_size</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><name>int</name> <name>ZEXPORT</name></type> <name>deflateInit2_</name><parameter_list>(<param><decl><type><name>strm</name></type></decl></param>, <param><decl><type><name>level</name></type></decl></param>, <param><decl><type><name>method</name></type></decl></param>, <param><decl><type><name>windowBits</name></type></decl></param>, <param><decl><type><name>memLevel</name></type></decl></param>, <param><decl><type><name>strategy</name></type></decl></param>,
<param><decl><type><name>version</name></type></decl></param>, <param><decl><type><name>stream_size</name></type></decl></param>)</parameter_list>
<decl_stmt><decl><type><name>z_streamp</name></type> <name>strm</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>level</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>method</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>windowBits</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>memLevel</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>strategy</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>version</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>stream_size</name></decl>;</decl_stmt>
<block>{
<decl_stmt><decl><type><name>deflate_state</name> *</type><name>s</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>wrap</name> <init>= <expr>1</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name></type> <name><name>my_version</name><index>[]</index></name> <init>= <expr><name>ZLIB_VERSION</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ushf</name> *</type><name>overlay</name></decl>;</decl_stmt>
<if>if <condition>(<expr><name>version</name> == <name>Z_NULL</name> || <name><name>version</name><index>[<expr>0</expr>]</index></name> != <name><name>my_version</name><index>[<expr>0</expr>]</index></name> ||
<name>stream_size</name> != <sizeof>sizeof<argument_list>(<argument><expr><name>z_stream</name></expr></argument>)</argument_list></sizeof></expr>)</condition><then> <block>{
<return>return <expr><name>Z_VERSION_ERROR</name></expr>;</return>
}</block></then></if>
<if>if <condition>(<expr><name>strm</name> == <name>Z_NULL</name></expr>)</condition><then> <return>return <expr><name>Z_STREAM_ERROR</name></expr>;</return></then></if>
<expr_stmt><expr><name><name>strm</name>-&gt;<name>msg</name></name> = <name>Z_NULL</name></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>strm</name>-&gt;<name>zalloc</name></name> == (<name>alloc_func</name>)0</expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>strm</name>-&gt;<name>zalloc</name></name> = <name>zcalloc</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>strm</name>-&gt;<name>opaque</name></name> = (<name>voidpf</name>)0</expr>;</expr_stmt>
}</block></then></if>
<if>if <condition>(<expr><name><name>strm</name>-&gt;<name>zfree</name></name> == (<name>free_func</name>)0</expr>)</condition><then> <expr_stmt><expr><name><name>strm</name>-&gt;<name>zfree</name></name> = <name>zcfree</name></expr>;</expr_stmt></then></if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FASTEST</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if>if <condition>(<expr><name>level</name> != 0</expr>)</condition><then> <expr_stmt><expr><name>level</name> = 1</expr>;</expr_stmt></then></if>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<if>if <condition>(<expr><name>level</name> == <name>Z_DEFAULT_COMPRESSION</name></expr>)</condition><then> <expr_stmt><expr><name>level</name> = 6</expr>;</expr_stmt></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<if>if <condition>(<expr><name>windowBits</name> &lt; 0</expr>)</condition><then> <block>{
<expr_stmt><expr><name>wrap</name> = 0</expr>;</expr_stmt>
<expr_stmt><expr><name>windowBits</name> = -<name>windowBits</name></expr>;</expr_stmt>
}</block></then>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>GZIP</name></expr></argument>)</argument_list></call></expr></cpp:if>
<else>else <if>if <condition>(<expr><name>windowBits</name> &gt; 15</expr>)</condition><then> <block>{
<expr_stmt><expr><name>wrap</name> = 2</expr>;</expr_stmt>
<expr_stmt><expr><name>windowBits</name> -= 16</expr>;</expr_stmt>
}</block></then></if></else></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<if>if <condition>(<expr><name>memLevel</name> &lt; 1 || <name>memLevel</name> &gt; <name>MAX_MEM_LEVEL</name> || <name>method</name> != <name>Z_DEFLATED</name> ||
<name>windowBits</name> &lt; 8 || <name>windowBits</name> &gt; 15 || <name>level</name> &lt; 0 || <name>level</name> &gt; 9 ||
<name>strategy</name> &lt; 0 || <name>strategy</name> &gt; <name>Z_FIXED</name></expr>)</condition><then> <block>{
<return>return <expr><name>Z_STREAM_ERROR</name></expr>;</return>
}</block></then></if>
<if>if <condition>(<expr><name>windowBits</name> == 8</expr>)</condition><then> <expr_stmt><expr><name>windowBits</name> = 9</expr>;</expr_stmt></then></if>
<expr_stmt><expr><name>s</name> = (<name>deflate_state</name> *) <call><name>ZALLOC</name><argument_list>(<argument><expr><name>strm</name></expr></argument>, <argument><expr>1</expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>deflate_state</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>s</name> == <name>Z_NULL</name></expr>)</condition><then> <return>return <expr><name>Z_MEM_ERROR</name></expr>;</return></then></if>
<expr_stmt><expr><name><name>strm</name>-&gt;<name>state</name></name> = (struct <name>internal_state</name> <name>FAR</name> *)<name>s</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name>-&gt;<name>strm</name></name> = <name>strm</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name>-&gt;<name>wrap</name></name> = <name>wrap</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name>-&gt;<name>gzhead</name></name> = <name>Z_NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name>-&gt;<name>w_bits</name></name> = <name>windowBits</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name>-&gt;<name>w_size</name></name> = 1 &lt;&lt; <name><name>s</name>-&gt;<name>w_bits</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name>-&gt;<name>w_mask</name></name> = <name><name>s</name>-&gt;<name>w_size</name></name> - 1</expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name>-&gt;<name>hash_bits</name></name> = <name>memLevel</name> + 7</expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name>-&gt;<name>hash_size</name></name> = 1 &lt;&lt; <name><name>s</name>-&gt;<name>hash_bits</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name>-&gt;<name>hash_mask</name></name> = <name><name>s</name>-&gt;<name>hash_size</name></name> - 1</expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name>-&gt;<name>hash_shift</name></name> = ((<name><name>s</name>-&gt;<name>hash_bits</name></name>+<name>MIN_MATCH</name>-1)/<name>MIN_MATCH</name>)</expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name>-&gt;<name>window</name></name> = (<name>Bytef</name> *) <call><name>ZALLOC</name><argument_list>(<argument><expr><name>strm</name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>w_size</name></name></expr></argument>, <argument><expr>2*<sizeof>sizeof<argument_list>(<argument><expr><name>Byte</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name>-&gt;<name>prev</name></name> = (<name>Posf</name> *) <call><name>ZALLOC</name><argument_list>(<argument><expr><name>strm</name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>w_size</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Pos</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name>-&gt;<name>head</name></name> = (<name>Posf</name> *) <call><name>ZALLOC</name><argument_list>(<argument><expr><name>strm</name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>hash_size</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Pos</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name>-&gt;<name>lit_bufsize</name></name> = 1 &lt;&lt; (<name>memLevel</name> + 6)</expr>;</expr_stmt>
<expr_stmt><expr><name>overlay</name> = (<name>ushf</name> *) <call><name>ZALLOC</name><argument_list>(<argument><expr><name>strm</name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>lit_bufsize</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ush</name></expr></argument>)</argument_list></sizeof>+2</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name>-&gt;<name>pending_buf</name></name> = (<name>uchf</name> *) <name>overlay</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name>-&gt;<name>pending_buf_size</name></name> = (<name>ulg</name>)<name><name>s</name>-&gt;<name>lit_bufsize</name></name> * (<sizeof>sizeof<argument_list>(<argument><expr><name>ush</name></expr></argument>)</argument_list></sizeof>+2L)</expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>s</name>-&gt;<name>window</name></name> == <name>Z_NULL</name> || <name><name>s</name>-&gt;<name>prev</name></name> == <name>Z_NULL</name> || <name><name>s</name>-&gt;<name>head</name></name> == <name>Z_NULL</name> ||
<name><name>s</name>-&gt;<name>pending_buf</name></name> == <name>Z_NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>s</name>-&gt;<name>status</name></name> = <name>FINISH_STATE</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>strm</name>-&gt;<name>msg</name></name> = (<name>char</name>*)<call><name>ERR_MSG</name><argument_list>(<argument><expr><name>Z_MEM_ERROR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>deflateEnd</name> <argument_list>(<argument><expr><name>strm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>Z_MEM_ERROR</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name><name>s</name>-&gt;<name>d_buf</name></name> = <name>overlay</name> + <name><name>s</name>-&gt;<name>lit_bufsize</name></name>/<sizeof>sizeof<argument_list>(<argument><expr><name>ush</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name>-&gt;<name>l_buf</name></name> = <name><name>s</name>-&gt;<name>pending_buf</name></name> + (1+<sizeof>sizeof<argument_list>(<argument><expr><name>ush</name></expr></argument>)</argument_list></sizeof>)*<name><name>s</name>-&gt;<name>lit_bufsize</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name>-&gt;<name>level</name></name> = <name>level</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name>-&gt;<name>strategy</name></name> = <name>strategy</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name>-&gt;<name>method</name></name> = (<name>Byte</name>)<name>method</name></expr>;</expr_stmt>
<return>return <expr><call><name>deflateReset</name><argument_list>(<argument><expr><name>strm</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><name>int</name> <name>ZEXPORT</name></type> <name>deflateSetDictionary</name> <parameter_list>(<param><decl><type><name>strm</name></type></decl></param>, <param><decl><type><name>dictionary</name></type></decl></param>, <param><decl><type><name>dictLength</name></type></decl></param>)</parameter_list>
<decl_stmt><decl><type><name>z_streamp</name></type> <name>strm</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>Bytef</name> *</type><name>dictionary</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uInt</name></type> <name>dictLength</name></decl>;</decl_stmt>
<block>{
<decl_stmt><decl><type><name>deflate_state</name> *</type><name>s</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uInt</name></type> <name>length</name> <init>= <expr><name>dictLength</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uInt</name></type> <name>n</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>IPos</name></type> <name>hash_head</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>strm</name> == <name>Z_NULL</name> || <name><name>strm</name>-&gt;<name>state</name></name> == <name>Z_NULL</name> || <name>dictionary</name> == <name>Z_NULL</name> ||
<name><name>strm</name>-&gt;<name>state</name>-&gt;<name>wrap</name></name> == 2 ||
(<name><name>strm</name>-&gt;<name>state</name>-&gt;<name>wrap</name></name> == 1 &amp;&amp; <name><name>strm</name>-&gt;<name>state</name>-&gt;<name>status</name></name> != <name>INIT_STATE</name>)</expr>)</condition><then>
<return>return <expr><name>Z_STREAM_ERROR</name></expr>;</return></then></if>
<expr_stmt><expr><name>s</name> = <name><name>strm</name>-&gt;<name>state</name></name></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>s</name>-&gt;<name>wrap</name></name></expr>)</condition><then>
<expr_stmt><expr><name><name>strm</name>-&gt;<name>adler</name></name> = <call><name>adler32</name><argument_list>(<argument><expr><name><name>strm</name>-&gt;<name>adler</name></name></expr></argument>, <argument><expr><name>dictionary</name></expr></argument>, <argument><expr><name>dictLength</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<if>if <condition>(<expr><name>length</name> &lt; <name>MIN_MATCH</name></expr>)</condition><then> <return>return <expr><name>Z_OK</name></expr>;</return></then></if>
<if>if <condition>(<expr><name>length</name> &gt; <call><name>MAX_DIST</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><name>length</name> = <call><name>MAX_DIST</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>dictionary</name> += <name>dictLength</name> - <name>length</name></expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><call><name>zmemcpy</name><argument_list>(<argument><expr><name><name>s</name>-&gt;<name>window</name></name></expr></argument>, <argument><expr><name>dictionary</name></expr></argument>, <argument><expr><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name>-&gt;<name>strstart</name></name> = <name>length</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name>-&gt;<name>block_start</name></name> = (<name>long</name>)<name>length</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name>-&gt;<name>ins_h</name></name> = <name><name>s</name>-&gt;<name>window</name><index>[<expr>0</expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>UPDATE_HASH</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>ins_h</name></name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>window</name><index>[<expr>1</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for (<init><expr><name>n</name> = 0</expr>;</init> <condition><expr><name>n</name> &lt;= <name>length</name> - <name>MIN_MATCH</name></expr>;</condition> <incr><expr><name>n</name>++</expr></incr>) <block>{
<expr_stmt><expr><call><name>INSERT_STRING</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><name>hash_head</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></for>
<if>if <condition>(<expr><name>hash_head</name></expr>)</condition><then> <expr_stmt><expr><name>hash_head</name> = 0</expr>;</expr_stmt></then></if>
<return>return <expr><name>Z_OK</name></expr>;</return>
}</block></function>
<function><type><name>int</name> <name>ZEXPORT</name></type> <name>deflateReset</name> <parameter_list>(<param><decl><type><name>strm</name></type></decl></param>)</parameter_list>
<decl_stmt><decl><type><name>z_streamp</name></type> <name>strm</name></decl>;</decl_stmt>
<block>{
<decl_stmt><decl><type><name>deflate_state</name> *</type><name>s</name></decl>;</decl_stmt>
<if>if <condition>(<expr><name>strm</name> == <name>Z_NULL</name> || <name><name>strm</name>-&gt;<name>state</name></name> == <name>Z_NULL</name> ||
<name><name>strm</name>-&gt;<name>zalloc</name></name> == (<name>alloc_func</name>)0 || <name><name>strm</name>-&gt;<name>zfree</name></name> == (<name>free_func</name>)0</expr>)</condition><then> <block>{
<return>return <expr><name>Z_STREAM_ERROR</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name><name>strm</name>-&gt;<name>total_in</name></name> = <name><name>strm</name>-&gt;<name>total_out</name></name> = 0</expr>;</expr_stmt>
<expr_stmt><expr><name><name>strm</name>-&gt;<name>msg</name></name> = <name>Z_NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>strm</name>-&gt;<name>data_type</name></name> = <name>Z_UNKNOWN</name></expr>;</expr_stmt>
<expr_stmt><expr><name>s</name> = (<name>deflate_state</name> *)<name><name>strm</name>-&gt;<name>state</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name>-&gt;<name>pending</name></name> = 0</expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name>-&gt;<name>pending_out</name></name> = <name><name>s</name>-&gt;<name>pending_buf</name></name></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>s</name>-&gt;<name>wrap</name></name> &lt; 0</expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>s</name>-&gt;<name>wrap</name></name> = -<name><name>s</name>-&gt;<name>wrap</name></name></expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><name><name>s</name>-&gt;<name>status</name></name> = <name><name>s</name>-&gt;<name>wrap</name></name> ? <name>INIT_STATE</name> : <name>BUSY_STATE</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>strm</name>-&gt;<name>adler</name></name> =
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>GZIP</name></expr></argument>)</argument_list></call></expr></cpp:if>
<name><name>s</name>-&gt;<name>wrap</name></name> == 2 ? <call><name>crc32</name><argument_list>(<argument><expr>0L</expr></argument>, <argument><expr><name>Z_NULL</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call> :
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<call><name>adler32</name><argument_list>(<argument><expr>0L</expr></argument>, <argument><expr><name>Z_NULL</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name>-&gt;<name>last_flush</name></name> = <name>Z_NO_FLUSH</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>_tr_init</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>lm_init</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>Z_OK</name></expr>;</return>
}</block></function>
<function><type><name>int</name> <name>ZEXPORT</name></type> <name>deflateSetHeader</name> <parameter_list>(<param><decl><type><name>strm</name></type></decl></param>, <param><decl><type><name>head</name></type></decl></param>)</parameter_list>
<decl_stmt><decl><type><name>z_streamp</name></type> <name>strm</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>gz_headerp</name></type> <name>head</name></decl>;</decl_stmt>
<block>{
<if>if <condition>(<expr><name>strm</name> == <name>Z_NULL</name> || <name><name>strm</name>-&gt;<name>state</name></name> == <name>Z_NULL</name></expr>)</condition><then> <return>return <expr><name>Z_STREAM_ERROR</name></expr>;</return></then></if>
<if>if <condition>(<expr><name><name>strm</name>-&gt;<name>state</name>-&gt;<name>wrap</name></name> != 2</expr>)</condition><then> <return>return <expr><name>Z_STREAM_ERROR</name></expr>;</return></then></if>
<expr_stmt><expr><name><name>strm</name>-&gt;<name>state</name>-&gt;<name>gzhead</name></name> = <name>head</name></expr>;</expr_stmt>
<return>return <expr><name>Z_OK</name></expr>;</return>
}</block></function>
<function><type><name>int</name> <name>ZEXPORT</name></type> <name>deflatePrime</name> <parameter_list>(<param><decl><type><name>strm</name></type></decl></param>, <param><decl><type><name>bits</name></type></decl></param>, <param><decl><type><name>value</name></type></decl></param>)</parameter_list>
<decl_stmt><decl><type><name>z_streamp</name></type> <name>strm</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>bits</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>value</name></decl>;</decl_stmt>
<block>{
<if>if <condition>(<expr><name>strm</name> == <name>Z_NULL</name> || <name><name>strm</name>-&gt;<name>state</name></name> == <name>Z_NULL</name></expr>)</condition><then> <return>return <expr><name>Z_STREAM_ERROR</name></expr>;</return></then></if>
<expr_stmt><expr><name><name>strm</name>-&gt;<name>state</name>-&gt;<name>bi_valid</name></name> = <name>bits</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>strm</name>-&gt;<name>state</name>-&gt;<name>bi_buf</name></name> = <call>(<name>ush</name>)<argument_list>(<argument><expr><name>value</name> &amp; ((1 &lt;&lt; <name>bits</name>) - 1)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>Z_OK</name></expr>;</return>
}</block></function>
<function><type><name>int</name> <name>ZEXPORT</name></type> <name>deflateParams</name><parameter_list>(<param><decl><type><name>strm</name></type></decl></param>, <param><decl><type><name>level</name></type></decl></param>, <param><decl><type><name>strategy</name></type></decl></param>)</parameter_list>
<decl_stmt><decl><type><name>z_streamp</name></type> <name>strm</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>level</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>strategy</name></decl>;</decl_stmt>
<block>{
<decl_stmt><decl><type><name>deflate_state</name> *</type><name>s</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>compress_func</name></type> <name>func</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>err</name> <init>= <expr><name>Z_OK</name></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>strm</name> == <name>Z_NULL</name> || <name><name>strm</name>-&gt;<name>state</name></name> == <name>Z_NULL</name></expr>)</condition><then> <return>return <expr><name>Z_STREAM_ERROR</name></expr>;</return></then></if>
<expr_stmt><expr><name>s</name> = <name><name>strm</name>-&gt;<name>state</name></name></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FASTEST</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if>if <condition>(<expr><name>level</name> != 0</expr>)</condition><then> <expr_stmt><expr><name>level</name> = 1</expr>;</expr_stmt></then></if>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<if>if <condition>(<expr><name>level</name> == <name>Z_DEFAULT_COMPRESSION</name></expr>)</condition><then> <expr_stmt><expr><name>level</name> = 6</expr>;</expr_stmt></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<if>if <condition>(<expr><name>level</name> &lt; 0 || <name>level</name> &gt; 9 || <name>strategy</name> &lt; 0 || <name>strategy</name> &gt; <name>Z_FIXED</name></expr>)</condition><then> <block>{
<return>return <expr><name>Z_STREAM_ERROR</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>func</name> = <name><name>configuration_table</name><index>[<expr><name><name>s</name>-&gt;<name>level</name></name></expr>]</index></name>.<name>func</name></expr>;</expr_stmt>
<if>if <condition>(<expr><name>func</name> != <name><name>configuration_table</name><index>[<expr><name>level</name></expr>]</index></name>.<name>func</name> &amp;&amp; <name><name>strm</name>-&gt;<name>total_in</name></name> != 0</expr>)</condition><then> <block>{
<expr_stmt><expr><name>err</name> = <call><name>deflate</name><argument_list>(<argument><expr><name>strm</name></expr></argument>, <argument><expr><name>Z_PARTIAL_FLUSH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<if>if <condition>(<expr><name><name>s</name>-&gt;<name>level</name></name> != <name>level</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>s</name>-&gt;<name>level</name></name> = <name>level</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name>-&gt;<name>max_lazy_match</name></name> = <name><name>configuration_table</name><index>[<expr><name>level</name></expr>]</index></name>.<name>max_lazy</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name>-&gt;<name>good_match</name></name> = <name><name>configuration_table</name><index>[<expr><name>level</name></expr>]</index></name>.<name>good_length</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name>-&gt;<name>nice_match</name></name> = <name><name>configuration_table</name><index>[<expr><name>level</name></expr>]</index></name>.<name>nice_length</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name>-&gt;<name>max_chain_length</name></name> = <name><name>configuration_table</name><index>[<expr><name>level</name></expr>]</index></name>.<name>max_chain</name></expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><name><name>s</name>-&gt;<name>strategy</name></name> = <name>strategy</name></expr>;</expr_stmt>
<return>return <expr><name>err</name></expr>;</return>
}</block></function>
<function><type><name>int</name> <name>ZEXPORT</name></type> <name>deflateTune</name><parameter_list>(<param><decl><type><name>strm</name></type></decl></param>, <param><decl><type><name>good_length</name></type></decl></param>, <param><decl><type><name>max_lazy</name></type></decl></param>, <param><decl><type><name>nice_length</name></type></decl></param>, <param><decl><type><name>max_chain</name></type></decl></param>)</parameter_list>
<decl_stmt><decl><type><name>z_streamp</name></type> <name>strm</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>good_length</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>max_lazy</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>nice_length</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>max_chain</name></decl>;</decl_stmt>
<block>{
<decl_stmt><decl><type><name>deflate_state</name> *</type><name>s</name></decl>;</decl_stmt>
<if>if <condition>(<expr><name>strm</name> == <name>Z_NULL</name> || <name><name>strm</name>-&gt;<name>state</name></name> == <name>Z_NULL</name></expr>)</condition><then> <return>return <expr><name>Z_STREAM_ERROR</name></expr>;</return></then></if>
<expr_stmt><expr><name>s</name> = <name><name>strm</name>-&gt;<name>state</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name>-&gt;<name>good_match</name></name> = <name>good_length</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name>-&gt;<name>max_lazy_match</name></name> = <name>max_lazy</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name>-&gt;<name>nice_match</name></name> = <name>nice_length</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name>-&gt;<name>max_chain_length</name></name> = <name>max_chain</name></expr>;</expr_stmt>
<return>return <expr><name>Z_OK</name></expr>;</return>
}</block></function>
<function><type><name>uLong</name> <name>ZEXPORT</name></type> <name>deflateBound</name><parameter_list>(<param><decl><type><name>strm</name></type></decl></param>, <param><decl><type><name>sourceLen</name></type></decl></param>)</parameter_list>
<decl_stmt><decl><type><name>z_streamp</name></type> <name>strm</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uLong</name></type> <name>sourceLen</name></decl>;</decl_stmt>
<block>{
<decl_stmt><decl><type><name>deflate_state</name> *</type><name>s</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uLong</name></type> <name>destLen</name></decl>;</decl_stmt>
<expr_stmt><expr><name>destLen</name> = <name>sourceLen</name> +
((<name>sourceLen</name> + 7) &gt;&gt; 3) + ((<name>sourceLen</name> + 63) &gt;&gt; 6) + 11</expr>;</expr_stmt>
<if>if <condition>(<expr><name>strm</name> == <name>Z_NULL</name> || <name><name>strm</name>-&gt;<name>state</name></name> == <name>Z_NULL</name></expr>)</condition><then>
<return>return <expr><name>destLen</name></expr>;</return></then></if>
<expr_stmt><expr><name>s</name> = <name><name>strm</name>-&gt;<name>state</name></name></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>s</name>-&gt;<name>w_bits</name></name> != 15 || <name><name>s</name>-&gt;<name>hash_bits</name></name> != 8 + 7</expr>)</condition><then>
<return>return <expr><name>destLen</name></expr>;</return></then></if>
<return>return <expr><call><name>compressBound</name><argument_list>(<argument><expr><name>sourceLen</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><name>local</name> <name>void</name></type> <name>putShortMSB</name> <parameter_list>(<param><decl><type><name>s</name></type></decl></param>, <param><decl><type><name>b</name></type></decl></param>)</parameter_list>
<decl_stmt><decl><type><name>deflate_state</name> *</type><name>s</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uInt</name></type> <name>b</name></decl>;</decl_stmt>
<block>{
<expr_stmt><expr><call><name>put_byte</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><call>(<name>Byte</name>)<argument_list>(<argument><expr><name>b</name> &gt;&gt; 8</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>put_byte</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><call>(<name>Byte</name>)<argument_list>(<argument><expr><name>b</name> &amp; 0xff</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>
<function><type><name>local</name> <name>void</name></type> <name>flush_pending</name><parameter_list>(<param><decl><type><name>strm</name></type></decl></param>)</parameter_list>
<decl_stmt><decl><type><name>z_streamp</name></type> <name>strm</name></decl>;</decl_stmt>
<block>{
<decl_stmt><decl><type><name>unsigned</name></type> <name>len</name> <init>= <expr><name><name>strm</name>-&gt;<name>state</name>-&gt;<name>pending</name></name></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>len</name> &gt; <name><name>strm</name>-&gt;<name>avail_out</name></name></expr>)</condition><then> <expr_stmt><expr><name>len</name> = <name><name>strm</name>-&gt;<name>avail_out</name></name></expr>;</expr_stmt></then></if>
<if>if <condition>(<expr><name>len</name> == 0</expr>)</condition><then> <return>return;</return></then></if>
<expr_stmt><expr><call><name>zmemcpy</name><argument_list>(<argument><expr><name><name>strm</name>-&gt;<name>next_out</name></name></expr></argument>, <argument><expr><name><name>strm</name>-&gt;<name>state</name>-&gt;<name>pending_out</name></name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>strm</name>-&gt;<name>next_out</name></name> += <name>len</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>strm</name>-&gt;<name>state</name>-&gt;<name>pending_out</name></name> += <name>len</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>strm</name>-&gt;<name>total_out</name></name> += <name>len</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>strm</name>-&gt;<name>avail_out</name></name> -= <name>len</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>strm</name>-&gt;<name>state</name>-&gt;<name>pending</name></name> -= <name>len</name></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>strm</name>-&gt;<name>state</name>-&gt;<name>pending</name></name> == 0</expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>strm</name>-&gt;<name>state</name>-&gt;<name>pending_out</name></name> = <name><name>strm</name>-&gt;<name>state</name>-&gt;<name>pending_buf</name></name></expr>;</expr_stmt>
}</block></then></if>
}</block></function>
<function><type><name>int</name> <name>ZEXPORT</name></type> <name>deflate</name> <parameter_list>(<param><decl><type><name>strm</name></type></decl></param>, <param><decl><type><name>flush</name></type></decl></param>)</parameter_list>
<decl_stmt><decl><type><name>z_streamp</name></type> <name>strm</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>flush</name></decl>;</decl_stmt>
<block>{
<decl_stmt><decl><type><name>int</name></type> <name>old_flush</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>deflate_state</name> *</type><name>s</name></decl>;</decl_stmt>
<if>if <condition>(<expr><name>strm</name> == <name>Z_NULL</name> || <name><name>strm</name>-&gt;<name>state</name></name> == <name>Z_NULL</name> ||
<name>flush</name> &gt; <name>Z_FINISH</name> || <name>flush</name> &lt; 0</expr>)</condition><then> <block>{
<return>return <expr><name>Z_STREAM_ERROR</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>s</name> = <name><name>strm</name>-&gt;<name>state</name></name></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>strm</name>-&gt;<name>next_out</name></name> == <name>Z_NULL</name> ||
(<name><name>strm</name>-&gt;<name>next_in</name></name> == <name>Z_NULL</name> &amp;&amp; <name><name>strm</name>-&gt;<name>avail_in</name></name> != 0) ||
(<name><name>s</name>-&gt;<name>status</name></name> == <name>FINISH_STATE</name> &amp;&amp; <name>flush</name> != <name>Z_FINISH</name>)</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>ERR_RETURN</name><argument_list>(<argument><expr><name>strm</name></expr></argument>, <argument><expr><name>Z_STREAM_ERROR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<if>if <condition>(<expr><name><name>strm</name>-&gt;<name>avail_out</name></name> == 0</expr>)</condition><then> <expr_stmt><expr><call><name>ERR_RETURN</name><argument_list>(<argument><expr><name>strm</name></expr></argument>, <argument><expr><name>Z_BUF_ERROR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<expr_stmt><expr><name><name>s</name>-&gt;<name>strm</name></name> = <name>strm</name></expr>;</expr_stmt>
<expr_stmt><expr><name>old_flush</name> = <name><name>s</name>-&gt;<name>last_flush</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name>-&gt;<name>last_flush</name></name> = <name>flush</name></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>s</name>-&gt;<name>status</name></name> == <name>INIT_STATE</name></expr>)</condition><then> <block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>GZIP</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if>if <condition>(<expr><name><name>s</name>-&gt;<name>wrap</name></name> == 2</expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>strm</name>-&gt;<name>adler</name></name> = <call><name>crc32</name><argument_list>(<argument><expr>0L</expr></argument>, <argument><expr><name>Z_NULL</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>put_byte</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr>31</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>put_byte</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr>139</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>put_byte</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr>8</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>s</name>-&gt;<name>gzhead</name></name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>put_byte</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>put_byte</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>put_byte</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>put_byte</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>put_byte</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>put_byte</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>level</name></name> == 9 ? 2 :
(<name><name>s</name>-&gt;<name>strategy</name></name> &gt;= <name>Z_HUFFMAN_ONLY</name> || <name><name>s</name>-&gt;<name>level</name></name> &lt; 2 ?
4 : 0)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>put_byte</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>OS_CODE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name>-&gt;<name>status</name></name> = <name>BUSY_STATE</name></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr><call><name>put_byte</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr>(<name><name>s</name>-&gt;<name>gzhead</name>-&gt;<name>text</name></name> ? 1 : 0) +
(<name><name>s</name>-&gt;<name>gzhead</name>-&gt;<name>hcrc</name></name> ? 2 : 0) +
(<name><name>s</name>-&gt;<name>gzhead</name>-&gt;<name>extra</name></name> == <name>Z_NULL</name> ? 0 : 4) +
(<name><name>s</name>-&gt;<name>gzhead</name>-&gt;<name>name</name></name> == <name>Z_NULL</name> ? 0 : 8) +
(<name><name>s</name>-&gt;<name>gzhead</name>-&gt;<name>comment</name></name> == <name>Z_NULL</name> ? 0 : 16)</expr></argument>
)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>put_byte</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><call>(<name>Byte</name>)<argument_list>(<argument><expr><name><name>s</name>-&gt;<name>gzhead</name>-&gt;<name>time</name></name> &amp; 0xff</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>put_byte</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><call>(<name>Byte</name>)<argument_list>(<argument><expr>(<name><name>s</name>-&gt;<name>gzhead</name>-&gt;<name>time</name></name> &gt;&gt; 8) &amp; 0xff</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>put_byte</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><call>(<name>Byte</name>)<argument_list>(<argument><expr>(<name><name>s</name>-&gt;<name>gzhead</name>-&gt;<name>time</name></name> &gt;&gt; 16) &amp; 0xff</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>put_byte</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><call>(<name>Byte</name>)<argument_list>(<argument><expr>(<name><name>s</name>-&gt;<name>gzhead</name>-&gt;<name>time</name></name> &gt;&gt; 24) &amp; 0xff</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>put_byte</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>level</name></name> == 9 ? 2 :
(<name><name>s</name>-&gt;<name>strategy</name></name> &gt;= <name>Z_HUFFMAN_ONLY</name> || <name><name>s</name>-&gt;<name>level</name></name> &lt; 2 ?
4 : 0)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>put_byte</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>gzhead</name>-&gt;<name>os</name></name> &amp; 0xff</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>s</name>-&gt;<name>gzhead</name>-&gt;<name>extra</name></name> != <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>put_byte</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>gzhead</name>-&gt;<name>extra_len</name></name> &amp; 0xff</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>put_byte</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr>(<name><name>s</name>-&gt;<name>gzhead</name>-&gt;<name>extra_len</name></name> &gt;&gt; 8) &amp; 0xff</expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<if>if <condition>(<expr><name><name>s</name>-&gt;<name>gzhead</name>-&gt;<name>hcrc</name></name></expr>)</condition><then>
<expr_stmt><expr><name><name>strm</name>-&gt;<name>adler</name></name> = <call><name>crc32</name><argument_list>(<argument><expr><name><name>strm</name>-&gt;<name>adler</name></name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>pending_buf</name></name></expr></argument>,
<argument><expr><name><name>s</name>-&gt;<name>pending</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<expr_stmt><expr><name><name>s</name>-&gt;<name>gzindex</name></name> = 0</expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name>-&gt;<name>status</name></name> = <name>EXTRA_STATE</name></expr>;</expr_stmt>
}</block></else></if>
}</block></then> <else>else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<block>{
<decl_stmt><decl><type><name>uInt</name></type> <name>header</name> <init>= <expr>(<name>Z_DEFLATED</name> + ((<name><name>s</name>-&gt;<name>w_bits</name></name>-8)&lt;&lt;4)) &lt;&lt; 8</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uInt</name></type> <name>level_flags</name></decl>;</decl_stmt>
<if>if <condition>(<expr><name><name>s</name>-&gt;<name>strategy</name></name> &gt;= <name>Z_HUFFMAN_ONLY</name> || <name><name>s</name>-&gt;<name>level</name></name> &lt; 2</expr>)</condition><then>
<expr_stmt><expr><name>level_flags</name> = 0</expr>;</expr_stmt></then>
<else>else <if>if <condition>(<expr><name><name>s</name>-&gt;<name>level</name></name> &lt; 6</expr>)</condition><then>
<expr_stmt><expr><name>level_flags</name> = 1</expr>;</expr_stmt></then>
<else>else <if>if <condition>(<expr><name><name>s</name>-&gt;<name>level</name></name> == 6</expr>)</condition><then>
<expr_stmt><expr><name>level_flags</name> = 2</expr>;</expr_stmt></then>
<else>else
<expr_stmt><expr><name>level_flags</name> = 3</expr>;</expr_stmt></else></if></else></if></else></if>
<expr_stmt><expr><name>header</name> |= (<name>level_flags</name> &lt;&lt; 6)</expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>s</name>-&gt;<name>strstart</name></name> != 0</expr>)</condition><then> <expr_stmt><expr><name>header</name> |= <name>PRESET_DICT</name></expr>;</expr_stmt></then></if>
<expr_stmt><expr><name>header</name> += 31 - (<name>header</name> % 31)</expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name>-&gt;<name>status</name></name> = <name>BUSY_STATE</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>putShortMSB</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>header</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>s</name>-&gt;<name>strstart</name></name> != 0</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>putShortMSB</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><call>(<name>uInt</name>)<argument_list>(<argument><expr><name><name>strm</name>-&gt;<name>adler</name></name> &gt;&gt; 16</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>putShortMSB</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><call>(<name>uInt</name>)<argument_list>(<argument><expr><name><name>strm</name>-&gt;<name>adler</name></name> &amp; 0xffff</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><name><name>strm</name>-&gt;<name>adler</name></name> = <call><name>adler32</name><argument_list>(<argument><expr>0L</expr></argument>, <argument><expr><name>Z_NULL</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></else></if>
}</block></then></if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>GZIP</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if>if <condition>(<expr><name><name>s</name>-&gt;<name>status</name></name> == <name>EXTRA_STATE</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr><name><name>s</name>-&gt;<name>gzhead</name>-&gt;<name>extra</name></name> != <name>NULL</name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>uInt</name></type> <name>beg</name> <init>= <expr><name><name>s</name>-&gt;<name>pending</name></name></expr></init></decl>;</decl_stmt>
<while>while <condition>(<expr><name><name>s</name>-&gt;<name>gzindex</name></name> &lt; (<name><name>s</name>-&gt;<name>gzhead</name>-&gt;<name>extra_len</name></name> &amp; 0xffff)</expr>)</condition> <block>{
<if>if <condition>(<expr><name><name>s</name>-&gt;<name>pending</name></name> == <name><name>s</name>-&gt;<name>pending_buf_size</name></name></expr>)</condition><then> <block>{
<if>if <condition>(<expr><name><name>s</name>-&gt;<name>gzhead</name>-&gt;<name>hcrc</name></name> &amp;&amp; <name><name>s</name>-&gt;<name>pending</name></name> &gt; <name>beg</name></expr>)</condition><then>
<expr_stmt><expr><name><name>strm</name>-&gt;<name>adler</name></name> = <call><name>crc32</name><argument_list>(<argument><expr><name><name>strm</name>-&gt;<name>adler</name></name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>pending_buf</name></name> + <name>beg</name></expr></argument>,
<argument><expr><name><name>s</name>-&gt;<name>pending</name></name> - <name>beg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<expr_stmt><expr><call><name>flush_pending</name><argument_list>(<argument><expr><name>strm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>beg</name> = <name><name>s</name>-&gt;<name>pending</name></name></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>s</name>-&gt;<name>pending</name></name> == <name><name>s</name>-&gt;<name>pending_buf_size</name></name></expr>)</condition><then>
<break>break;</break></then></if>
}</block></then></if>
<expr_stmt><expr><call><name>put_byte</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>gzhead</name>-&gt;<name>extra</name><index>[<expr><name><name>s</name>-&gt;<name>gzindex</name></name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name>-&gt;<name>gzindex</name></name>++</expr>;</expr_stmt>
}</block></while>
<if>if <condition>(<expr><name><name>s</name>-&gt;<name>gzhead</name>-&gt;<name>hcrc</name></name> &amp;&amp; <name><name>s</name>-&gt;<name>pending</name></name> &gt; <name>beg</name></expr>)</condition><then>
<expr_stmt><expr><name><name>strm</name>-&gt;<name>adler</name></name> = <call><name>crc32</name><argument_list>(<argument><expr><name><name>strm</name>-&gt;<name>adler</name></name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>pending_buf</name></name> + <name>beg</name></expr></argument>,
<argument><expr><name><name>s</name>-&gt;<name>pending</name></name> - <name>beg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<if>if <condition>(<expr><name><name>s</name>-&gt;<name>gzindex</name></name> == <name><name>s</name>-&gt;<name>gzhead</name>-&gt;<name>extra_len</name></name></expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>s</name>-&gt;<name>gzindex</name></name> = 0</expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name>-&gt;<name>status</name></name> = <name>NAME_STATE</name></expr>;</expr_stmt>
}</block></then></if>
}</block></then> <else>else
<expr_stmt><expr><name><name>s</name>-&gt;<name>status</name></name> = <name>NAME_STATE</name></expr>;</expr_stmt></else></if>
}</block></then></if>
<if>if <condition>(<expr><name><name>s</name>-&gt;<name>status</name></name> == <name>NAME_STATE</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr><name><name>s</name>-&gt;<name>gzhead</name>-&gt;<name>name</name></name> != <name>NULL</name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>uInt</name></type> <name>beg</name> <init>= <expr><name><name>s</name>-&gt;<name>pending</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>val</name></decl>;</decl_stmt>
<do>do <block>{
<if>if <condition>(<expr><name><name>s</name>-&gt;<name>pending</name></name> == <name><name>s</name>-&gt;<name>pending_buf_size</name></name></expr>)</condition><then> <block>{
<if>if <condition>(<expr><name><name>s</name>-&gt;<name>gzhead</name>-&gt;<name>hcrc</name></name> &amp;&amp; <name><name>s</name>-&gt;<name>pending</name></name> &gt; <name>beg</name></expr>)</condition><then>
<expr_stmt><expr><name><name>strm</name>-&gt;<name>adler</name></name> = <call><name>crc32</name><argument_list>(<argument><expr><name><name>strm</name>-&gt;<name>adler</name></name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>pending_buf</name></name> + <name>beg</name></expr></argument>,
<argument><expr><name><name>s</name>-&gt;<name>pending</name></name> - <name>beg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<expr_stmt><expr><call><name>flush_pending</name><argument_list>(<argument><expr><name>strm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>beg</name> = <name><name>s</name>-&gt;<name>pending</name></name></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>s</name>-&gt;<name>pending</name></name> == <name><name>s</name>-&gt;<name>pending_buf_size</name></name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>val</name> = 1</expr>;</expr_stmt>
<break>break;</break>
}</block></then></if>
}</block></then></if>
<expr_stmt><expr><name>val</name> = <name><name>s</name>-&gt;<name>gzhead</name>-&gt;<name>name</name><index>[<expr><name><name>s</name>-&gt;<name>gzindex</name></name>++</expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>put_byte</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block> while <condition>(<expr><name>val</name> != 0</expr>)</condition>;</do>
<if>if <condition>(<expr><name><name>s</name>-&gt;<name>gzhead</name>-&gt;<name>hcrc</name></name> &amp;&amp; <name><name>s</name>-&gt;<name>pending</name></name> &gt; <name>beg</name></expr>)</condition><then>
<expr_stmt><expr><name><name>strm</name>-&gt;<name>adler</name></name> = <call><name>crc32</name><argument_list>(<argument><expr><name><name>strm</name>-&gt;<name>adler</name></name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>pending_buf</name></name> + <name>beg</name></expr></argument>,
<argument><expr><name><name>s</name>-&gt;<name>pending</name></name> - <name>beg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<if>if <condition>(<expr><name>val</name> == 0</expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>s</name>-&gt;<name>gzindex</name></name> = 0</expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name>-&gt;<name>status</name></name> = <name>COMMENT_STATE</name></expr>;</expr_stmt>
}</block></then></if>
}</block></then> <else>else
<expr_stmt><expr><name><name>s</name>-&gt;<name>status</name></name> = <name>COMMENT_STATE</name></expr>;</expr_stmt></else></if>
}</block></then></if>
<if>if <condition>(<expr><name><name>s</name>-&gt;<name>status</name></name> == <name>COMMENT_STATE</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr><name><name>s</name>-&gt;<name>gzhead</name>-&gt;<name>comment</name></name> != <name>NULL</name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>uInt</name></type> <name>beg</name> <init>= <expr><name><name>s</name>-&gt;<name>pending</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>val</name></decl>;</decl_stmt>
<do>do <block>{
<if>if <condition>(<expr><name><name>s</name>-&gt;<name>pending</name></name> == <name><name>s</name>-&gt;<name>pending_buf_size</name></name></expr>)</condition><then> <block>{
<if>if <condition>(<expr><name><name>s</name>-&gt;<name>gzhead</name>-&gt;<name>hcrc</name></name> &amp;&amp; <name><name>s</name>-&gt;<name>pending</name></name> &gt; <name>beg</name></expr>)</condition><then>
<expr_stmt><expr><name><name>strm</name>-&gt;<name>adler</name></name> = <call><name>crc32</name><argument_list>(<argument><expr><name><name>strm</name>-&gt;<name>adler</name></name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>pending_buf</name></name> + <name>beg</name></expr></argument>,
<argument><expr><name><name>s</name>-&gt;<name>pending</name></name> - <name>beg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<expr_stmt><expr><call><name>flush_pending</name><argument_list>(<argument><expr><name>strm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>beg</name> = <name><name>s</name>-&gt;<name>pending</name></name></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>s</name>-&gt;<name>pending</name></name> == <name><name>s</name>-&gt;<name>pending_buf_size</name></name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>val</name> = 1</expr>;</expr_stmt>
<break>break;</break>
}</block></then></if>
}</block></then></if>
<expr_stmt><expr><name>val</name> = <name><name>s</name>-&gt;<name>gzhead</name>-&gt;<name>comment</name><index>[<expr><name><name>s</name>-&gt;<name>gzindex</name></name>++</expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>put_byte</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block> while <condition>(<expr><name>val</name> != 0</expr>)</condition>;</do>
<if>if <condition>(<expr><name><name>s</name>-&gt;<name>gzhead</name>-&gt;<name>hcrc</name></name> &amp;&amp; <name><name>s</name>-&gt;<name>pending</name></name> &gt; <name>beg</name></expr>)</condition><then>
<expr_stmt><expr><name><name>strm</name>-&gt;<name>adler</name></name> = <call><name>crc32</name><argument_list>(<argument><expr><name><name>strm</name>-&gt;<name>adler</name></name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>pending_buf</name></name> + <name>beg</name></expr></argument>,
<argument><expr><name><name>s</name>-&gt;<name>pending</name></name> - <name>beg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<if>if <condition>(<expr><name>val</name> == 0</expr>)</condition><then>
<expr_stmt><expr><name><name>s</name>-&gt;<name>status</name></name> = <name>HCRC_STATE</name></expr>;</expr_stmt></then></if>
}</block></then> <else>else
<expr_stmt><expr><name><name>s</name>-&gt;<name>status</name></name> = <name>HCRC_STATE</name></expr>;</expr_stmt></else></if>
}</block></then></if>
<if>if <condition>(<expr><name><name>s</name>-&gt;<name>status</name></name> == <name>HCRC_STATE</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr><name><name>s</name>-&gt;<name>gzhead</name>-&gt;<name>hcrc</name></name></expr>)</condition><then> <block>{
<if>if <condition>(<expr><name><name>s</name>-&gt;<name>pending</name></name> + 2 &gt; <name><name>s</name>-&gt;<name>pending_buf_size</name></name></expr>)</condition><then>
<expr_stmt><expr><call><name>flush_pending</name><argument_list>(<argument><expr><name>strm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<if>if <condition>(<expr><name><name>s</name>-&gt;<name>pending</name></name> + 2 &lt;= <name><name>s</name>-&gt;<name>pending_buf_size</name></name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>put_byte</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><call>(<name>Byte</name>)<argument_list>(<argument><expr><name><name>strm</name>-&gt;<name>adler</name></name> &amp; 0xff</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>put_byte</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><call>(<name>Byte</name>)<argument_list>(<argument><expr>(<name><name>strm</name>-&gt;<name>adler</name></name> &gt;&gt; 8) &amp; 0xff</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>strm</name>-&gt;<name>adler</name></name> = <call><name>crc32</name><argument_list>(<argument><expr>0L</expr></argument>, <argument><expr><name>Z_NULL</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name>-&gt;<name>status</name></name> = <name>BUSY_STATE</name></expr>;</expr_stmt>
}</block></then></if>
}</block></then> <else>else
<expr_stmt><expr><name><name>s</name>-&gt;<name>status</name></name> = <name>BUSY_STATE</name></expr>;</expr_stmt></else></if>
}</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<if>if <condition>(<expr><name><name>s</name>-&gt;<name>pending</name></name> != 0</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>flush_pending</name><argument_list>(<argument><expr><name>strm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>strm</name>-&gt;<name>avail_out</name></name> == 0</expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>s</name>-&gt;<name>last_flush</name></name> = -1</expr>;</expr_stmt>
<return>return <expr><name>Z_OK</name></expr>;</return>
}</block></then></if>
}</block></then> <else>else <if>if <condition>(<expr><name><name>strm</name>-&gt;<name>avail_in</name></name> == 0 &amp;&amp; <name>flush</name> &lt;= <name>old_flush</name> &amp;&amp;
<name>flush</name> != <name>Z_FINISH</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>ERR_RETURN</name><argument_list>(<argument><expr><name>strm</name></expr></argument>, <argument><expr><name>Z_BUF_ERROR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if></else></if>
<if>if <condition>(<expr><name><name>s</name>-&gt;<name>status</name></name> == <name>FINISH_STATE</name> &amp;&amp; <name><name>strm</name>-&gt;<name>avail_in</name></name> != 0</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>ERR_RETURN</name><argument_list>(<argument><expr><name>strm</name></expr></argument>, <argument><expr><name>Z_BUF_ERROR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<if>if <condition>(<expr><name><name>strm</name>-&gt;<name>avail_in</name></name> != 0 || <name><name>s</name>-&gt;<name>lookahead</name></name> != 0 ||
(<name>flush</name> != <name>Z_NO_FLUSH</name> &amp;&amp; <name><name>s</name>-&gt;<name>status</name></name> != <name>FINISH_STATE</name>)</expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>block_state</name></type> <name>bstate</name></decl>;</decl_stmt>
<expr_stmt><expr><name>bstate</name> = (*(<name><name>configuration_table</name><index>[<expr><name><name>s</name>-&gt;<name>level</name></name></expr>]</index></name>.<name>func</name>))(<name>s</name>, <name>flush</name>)</expr>;</expr_stmt>
<if>if <condition>(<expr><name>bstate</name> == <name>finish_started</name> || <name>bstate</name> == <name>finish_done</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>s</name>-&gt;<name>status</name></name> = <name>FINISH_STATE</name></expr>;</expr_stmt>
}</block></then></if>
<if>if <condition>(<expr><name>bstate</name> == <name>need_more</name> || <name>bstate</name> == <name>finish_started</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr><name><name>strm</name>-&gt;<name>avail_out</name></name> == 0</expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>s</name>-&gt;<name>last_flush</name></name> = -1</expr>;</expr_stmt>
}</block></then></if>
<return>return <expr><name>Z_OK</name></expr>;</return>
}</block></then></if>
<if>if <condition>(<expr><name>bstate</name> == <name>block_done</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr><name>flush</name> == <name>Z_PARTIAL_FLUSH</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>_tr_align</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr><call><name>_tr_stored_block</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr>(<name>char</name>*)0</expr></argument>, <argument><expr>0L</expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>flush</name> == <name>Z_FULL_FLUSH</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>CLEAR_HASH</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
}</block></else></if>
<expr_stmt><expr><call><name>flush_pending</name><argument_list>(<argument><expr><name>strm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>strm</name>-&gt;<name>avail_out</name></name> == 0</expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>s</name>-&gt;<name>last_flush</name></name> = -1</expr>;</expr_stmt>
<return>return <expr><name>Z_OK</name></expr>;</return>
}</block></then></if>
}</block></then></if>
}</block></then></if>
<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>strm</name>-&gt;<name>avail_out</name></name> &gt; 0</expr></argument>, <argument><expr>"bug2"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>flush</name> != <name>Z_FINISH</name></expr>)</condition><then> <return>return <expr><name>Z_OK</name></expr>;</return></then></if>
<if>if <condition>(<expr><name><name>s</name>-&gt;<name>wrap</name></name> &lt;= 0</expr>)</condition><then> <return>return <expr><name>Z_STREAM_END</name></expr>;</return></then></if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>GZIP</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if>if <condition>(<expr><name><name>s</name>-&gt;<name>wrap</name></name> == 2</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>put_byte</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><call>(<name>Byte</name>)<argument_list>(<argument><expr><name><name>strm</name>-&gt;<name>adler</name></name> &amp; 0xff</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>put_byte</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><call>(<name>Byte</name>)<argument_list>(<argument><expr>(<name><name>strm</name>-&gt;<name>adler</name></name> &gt;&gt; 8) &amp; 0xff</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>put_byte</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><call>(<name>Byte</name>)<argument_list>(<argument><expr>(<name><name>strm</name>-&gt;<name>adler</name></name> &gt;&gt; 16) &amp; 0xff</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>put_byte</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><call>(<name>Byte</name>)<argument_list>(<argument><expr>(<name><name>strm</name>-&gt;<name>adler</name></name> &gt;&gt; 24) &amp; 0xff</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>put_byte</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><call>(<name>Byte</name>)<argument_list>(<argument><expr><name><name>strm</name>-&gt;<name>total_in</name></name> &amp; 0xff</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>put_byte</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><call>(<name>Byte</name>)<argument_list>(<argument><expr>(<name><name>strm</name>-&gt;<name>total_in</name></name> &gt;&gt; 8) &amp; 0xff</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>put_byte</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><call>(<name>Byte</name>)<argument_list>(<argument><expr>(<name><name>strm</name>-&gt;<name>total_in</name></name> &gt;&gt; 16) &amp; 0xff</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>put_byte</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><call>(<name>Byte</name>)<argument_list>(<argument><expr>(<name><name>strm</name>-&gt;<name>total_in</name></name> &gt;&gt; 24) &amp; 0xff</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<block>{
<expr_stmt><expr><call><name>putShortMSB</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><call>(<name>uInt</name>)<argument_list>(<argument><expr><name><name>strm</name>-&gt;<name>adler</name></name> &gt;&gt; 16</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>putShortMSB</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><call>(<name>uInt</name>)<argument_list>(<argument><expr><name><name>strm</name>-&gt;<name>adler</name></name> &amp; 0xffff</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></else></if>
<expr_stmt><expr><call><name>flush_pending</name><argument_list>(<argument><expr><name>strm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>s</name>-&gt;<name>wrap</name></name> &gt; 0</expr>)</condition><then> <expr_stmt><expr><name><name>s</name>-&gt;<name>wrap</name></name> = -<name><name>s</name>-&gt;<name>wrap</name></name></expr>;</expr_stmt></then></if>
<return>return <expr><name><name>s</name>-&gt;<name>pending</name></name> != 0 ? <name>Z_OK</name> : <name>Z_STREAM_END</name></expr>;</return>
}</block></function>
<function><type><name>int</name> <name>ZEXPORT</name></type> <name>deflateEnd</name> <parameter_list>(<param><decl><type><name>strm</name></type></decl></param>)</parameter_list>
<decl_stmt><decl><type><name>z_streamp</name></type> <name>strm</name></decl>;</decl_stmt>
<block>{
<decl_stmt><decl><type><name>int</name></type> <name>status</name></decl>;</decl_stmt>
<if>if <condition>(<expr><name>strm</name> == <name>Z_NULL</name> || <name><name>strm</name>-&gt;<name>state</name></name> == <name>Z_NULL</name></expr>)</condition><then> <return>return <expr><name>Z_STREAM_ERROR</name></expr>;</return></then></if>
<expr_stmt><expr><name>status</name> = <name><name>strm</name>-&gt;<name>state</name>-&gt;<name>status</name></name></expr>;</expr_stmt>
<if>if <condition>(<expr><name>status</name> != <name>INIT_STATE</name> &amp;&amp;
<name>status</name> != <name>EXTRA_STATE</name> &amp;&amp;
<name>status</name> != <name>NAME_STATE</name> &amp;&amp;
<name>status</name> != <name>COMMENT_STATE</name> &amp;&amp;
<name>status</name> != <name>HCRC_STATE</name> &amp;&amp;
<name>status</name> != <name>BUSY_STATE</name> &amp;&amp;
<name>status</name> != <name>FINISH_STATE</name></expr>)</condition><then> <block>{
<return>return <expr><name>Z_STREAM_ERROR</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><call><name>TRY_FREE</name><argument_list>(<argument><expr><name>strm</name></expr></argument>, <argument><expr><name><name>strm</name>-&gt;<name>state</name>-&gt;<name>pending_buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>TRY_FREE</name><argument_list>(<argument><expr><name>strm</name></expr></argument>, <argument><expr><name><name>strm</name>-&gt;<name>state</name>-&gt;<name>head</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>TRY_FREE</name><argument_list>(<argument><expr><name>strm</name></expr></argument>, <argument><expr><name><name>strm</name>-&gt;<name>state</name>-&gt;<name>prev</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>TRY_FREE</name><argument_list>(<argument><expr><name>strm</name></expr></argument>, <argument><expr><name><name>strm</name>-&gt;<name>state</name>-&gt;<name>window</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ZFREE</name><argument_list>(<argument><expr><name>strm</name></expr></argument>, <argument><expr><name><name>strm</name>-&gt;<name>state</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>strm</name>-&gt;<name>state</name></name> = <name>Z_NULL</name></expr>;</expr_stmt>
<return>return <expr><name>status</name> == <name>BUSY_STATE</name> ? <name>Z_DATA_ERROR</name> : <name>Z_OK</name></expr>;</return>
}</block></function>
<function><type><name>int</name> <name>ZEXPORT</name></type> <name>deflateCopy</name> <parameter_list>(<param><decl><type><name>dest</name></type></decl></param>, <param><decl><type><name>source</name></type></decl></param>)</parameter_list>
<decl_stmt><decl><type><name>z_streamp</name></type> <name>dest</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>z_streamp</name></type> <name>source</name></decl>;</decl_stmt>
<block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MAXSEG_64K</name></expr></argument>)</argument_list></call></expr></cpp:if>
<return>return <expr><name>Z_STREAM_ERROR</name></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<decl_stmt><decl><type><name>deflate_state</name> *</type><name>ds</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>deflate_state</name> *</type><name>ss</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ushf</name> *</type><name>overlay</name></decl>;</decl_stmt>
<if>if <condition>(<expr><name>source</name> == <name>Z_NULL</name> || <name>dest</name> == <name>Z_NULL</name> || <name><name>source</name>-&gt;<name>state</name></name> == <name>Z_NULL</name></expr>)</condition><then> <block>{
<return>return <expr><name>Z_STREAM_ERROR</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>ss</name> = <name><name>source</name>-&gt;<name>state</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>zmemcpy</name><argument_list>(<argument><expr><name>dest</name></expr></argument>, <argument><expr><name>source</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>z_stream</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ds</name> = (<name>deflate_state</name> *) <call><name>ZALLOC</name><argument_list>(<argument><expr><name>dest</name></expr></argument>, <argument><expr>1</expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>deflate_state</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>ds</name> == <name>Z_NULL</name></expr>)</condition><then> <return>return <expr><name>Z_MEM_ERROR</name></expr>;</return></then></if>
<expr_stmt><expr><name><name>dest</name>-&gt;<name>state</name></name> = (struct <name>internal_state</name> <name>FAR</name> *) <name>ds</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>zmemcpy</name><argument_list>(<argument><expr><name>ds</name></expr></argument>, <argument><expr><name>ss</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>deflate_state</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ds</name>-&gt;<name>strm</name></name> = <name>dest</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ds</name>-&gt;<name>window</name></name> = (<name>Bytef</name> *) <call><name>ZALLOC</name><argument_list>(<argument><expr><name>dest</name></expr></argument>, <argument><expr><name><name>ds</name>-&gt;<name>w_size</name></name></expr></argument>, <argument><expr>2*<sizeof>sizeof<argument_list>(<argument><expr><name>Byte</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ds</name>-&gt;<name>prev</name></name> = (<name>Posf</name> *) <call><name>ZALLOC</name><argument_list>(<argument><expr><name>dest</name></expr></argument>, <argument><expr><name><name>ds</name>-&gt;<name>w_size</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Pos</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ds</name>-&gt;<name>head</name></name> = (<name>Posf</name> *) <call><name>ZALLOC</name><argument_list>(<argument><expr><name>dest</name></expr></argument>, <argument><expr><name><name>ds</name>-&gt;<name>hash_size</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Pos</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>overlay</name> = (<name>ushf</name> *) <call><name>ZALLOC</name><argument_list>(<argument><expr><name>dest</name></expr></argument>, <argument><expr><name><name>ds</name>-&gt;<name>lit_bufsize</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ush</name></expr></argument>)</argument_list></sizeof>+2</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ds</name>-&gt;<name>pending_buf</name></name> = (<name>uchf</name> *) <name>overlay</name></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>ds</name>-&gt;<name>window</name></name> == <name>Z_NULL</name> || <name><name>ds</name>-&gt;<name>prev</name></name> == <name>Z_NULL</name> || <name><name>ds</name>-&gt;<name>head</name></name> == <name>Z_NULL</name> ||
<name><name>ds</name>-&gt;<name>pending_buf</name></name> == <name>Z_NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>deflateEnd</name> <argument_list>(<argument><expr><name>dest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>Z_MEM_ERROR</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><call><name>zmemcpy</name><argument_list>(<argument><expr><name><name>ds</name>-&gt;<name>window</name></name></expr></argument>, <argument><expr><name><name>ss</name>-&gt;<name>window</name></name></expr></argument>, <argument><expr><name><name>ds</name>-&gt;<name>w_size</name></name> * 2 * <sizeof>sizeof<argument_list>(<argument><expr><name>Byte</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>zmemcpy</name><argument_list>(<argument><expr><name><name>ds</name>-&gt;<name>prev</name></name></expr></argument>, <argument><expr><name><name>ss</name>-&gt;<name>prev</name></name></expr></argument>, <argument><expr><name><name>ds</name>-&gt;<name>w_size</name></name> * <sizeof>sizeof<argument_list>(<argument><expr><name>Pos</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>zmemcpy</name><argument_list>(<argument><expr><name><name>ds</name>-&gt;<name>head</name></name></expr></argument>, <argument><expr><name><name>ss</name>-&gt;<name>head</name></name></expr></argument>, <argument><expr><name><name>ds</name>-&gt;<name>hash_size</name></name> * <sizeof>sizeof<argument_list>(<argument><expr><name>Pos</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>zmemcpy</name><argument_list>(<argument><expr><name><name>ds</name>-&gt;<name>pending_buf</name></name></expr></argument>, <argument><expr><name><name>ss</name>-&gt;<name>pending_buf</name></name></expr></argument>, <argument><expr>(<name>uInt</name>)<name><name>ds</name>-&gt;<name>pending_buf_size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ds</name>-&gt;<name>pending_out</name></name> = <name><name>ds</name>-&gt;<name>pending_buf</name></name> + (<name><name>ss</name>-&gt;<name>pending_out</name></name> - <name><name>ss</name>-&gt;<name>pending_buf</name></name>)</expr>;</expr_stmt>
<expr_stmt><expr><name><name>ds</name>-&gt;<name>d_buf</name></name> = <name>overlay</name> + <name><name>ds</name>-&gt;<name>lit_bufsize</name></name>/<sizeof>sizeof<argument_list>(<argument><expr><name>ush</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ds</name>-&gt;<name>l_buf</name></name> = <name><name>ds</name>-&gt;<name>pending_buf</name></name> + (1+<sizeof>sizeof<argument_list>(<argument><expr><name>ush</name></expr></argument>)</argument_list></sizeof>)*<name><name>ds</name>-&gt;<name>lit_bufsize</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ds</name>-&gt;<name>l_desc</name>.<name>dyn_tree</name></name> = <name><name>ds</name>-&gt;<name>dyn_ltree</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ds</name>-&gt;<name>d_desc</name>.<name>dyn_tree</name></name> = <name><name>ds</name>-&gt;<name>dyn_dtree</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ds</name>-&gt;<name>bl_desc</name>.<name>dyn_tree</name></name> = <name><name>ds</name>-&gt;<name>bl_tree</name></name></expr>;</expr_stmt>
<return>return <expr><name>Z_OK</name></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></function>
<function><type><name>local</name> <name>int</name></type> <name>read_buf</name><parameter_list>(<param><decl><type><name>strm</name></type></decl></param>, <param><decl><type><name>buf</name></type></decl></param>, <param><decl><type><name>size</name></type></decl></param>)</parameter_list>
<decl_stmt><decl><type><name>z_streamp</name></type> <name>strm</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Bytef</name> *</type><name>buf</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name></type> <name>size</name></decl>;</decl_stmt>
<block>{
<decl_stmt><decl><type><name>unsigned</name></type> <name>len</name> <init>= <expr><name><name>strm</name>-&gt;<name>avail_in</name></name></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>len</name> &gt; <name>size</name></expr>)</condition><then> <expr_stmt><expr><name>len</name> = <name>size</name></expr>;</expr_stmt></then></if>
<if>if <condition>(<expr><name>len</name> == 0</expr>)</condition><then> <return>return <expr>0</expr>;</return></then></if>
<expr_stmt><expr><name><name>strm</name>-&gt;<name>avail_in</name></name> -= <name>len</name></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>strm</name>-&gt;<name>state</name>-&gt;<name>wrap</name></name> == 1</expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>strm</name>-&gt;<name>adler</name></name> = <call><name>adler32</name><argument_list>(<argument><expr><name><name>strm</name>-&gt;<name>adler</name></name></expr></argument>, <argument><expr><name><name>strm</name>-&gt;<name>next_in</name></name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>GZIP</name></expr></argument>)</argument_list></call></expr></cpp:if>
<else>else <if>if <condition>(<expr><name><name>strm</name>-&gt;<name>state</name>-&gt;<name>wrap</name></name> == 2</expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>strm</name>-&gt;<name>adler</name></name> = <call><name>crc32</name><argument_list>(<argument><expr><name><name>strm</name>-&gt;<name>adler</name></name></expr></argument>, <argument><expr><name><name>strm</name>-&gt;<name>next_in</name></name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if></else></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><call><name>zmemcpy</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name><name>strm</name>-&gt;<name>next_in</name></name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>strm</name>-&gt;<name>next_in</name></name> += <name>len</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>strm</name>-&gt;<name>total_in</name></name> += <name>len</name></expr>;</expr_stmt>
<return>return <expr>(<name>int</name>)<name>len</name></expr>;</return>
}</block></function>
<function><type><name>local</name> <name>void</name></type> <name>lm_init</name> <parameter_list>(<param><decl><type><name>s</name></type></decl></param>)</parameter_list>
<decl_stmt><decl><type><name>deflate_state</name> *</type><name>s</name></decl>;</decl_stmt>
<block>{
<expr_stmt><expr><name><name>s</name>-&gt;<name>window_size</name></name> = (<name>ulg</name>)2L*<name><name>s</name>-&gt;<name>w_size</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>CLEAR_HASH</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name>-&gt;<name>max_lazy_match</name></name> = <name><name>configuration_table</name><index>[<expr><name><name>s</name>-&gt;<name>level</name></name></expr>]</index></name>.<name>max_lazy</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name>-&gt;<name>good_match</name></name> = <name><name>configuration_table</name><index>[<expr><name><name>s</name>-&gt;<name>level</name></name></expr>]</index></name>.<name>good_length</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name>-&gt;<name>nice_match</name></name> = <name><name>configuration_table</name><index>[<expr><name><name>s</name>-&gt;<name>level</name></name></expr>]</index></name>.<name>nice_length</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name>-&gt;<name>max_chain_length</name></name> = <name><name>configuration_table</name><index>[<expr><name><name>s</name>-&gt;<name>level</name></name></expr>]</index></name>.<name>max_chain</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name>-&gt;<name>strstart</name></name> = 0</expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name>-&gt;<name>block_start</name></name> = 0L</expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name>-&gt;<name>lookahead</name></name> = 0</expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name>-&gt;<name>match_length</name></name> = <name><name>s</name>-&gt;<name>prev_length</name></name> = <name>MIN_MATCH</name>-1</expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name>-&gt;<name>match_available</name></name> = 0</expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name>-&gt;<name>ins_h</name></name> = 0</expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>FASTEST</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>ASMV</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>match_init</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></function>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>FASTEST</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>ASMV</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function><type><name>local</name> <name>uInt</name></type> <name>longest_match</name><parameter_list>(<param><decl><type><name>s</name></type></decl></param>, <param><decl><type><name>cur_match</name></type></decl></param>)</parameter_list>
<decl_stmt><decl><type><name>deflate_state</name> *</type><name>s</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>IPos</name></type> <name>cur_match</name></decl>;</decl_stmt>
<block>{
<decl_stmt><decl><type><name>unsigned</name></type> <name>chain_length</name> <init>= <expr><name><name>s</name>-&gt;<name>max_chain_length</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>register</name> <name>Bytef</name> *</type><name>scan</name> <init>= <expr><name><name>s</name>-&gt;<name>window</name></name> + <name><name>s</name>-&gt;<name>strstart</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>register</name> <name>Bytef</name> *</type><name>match</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>register</name> <name>int</name></type> <name>len</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>best_len</name> <init>= <expr><name><name>s</name>-&gt;<name>prev_length</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>nice_match</name> <init>= <expr><name><name>s</name>-&gt;<name>nice_match</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>IPos</name></type> <name>limit</name> <init>= <expr><name><name>s</name>-&gt;<name>strstart</name></name> &gt; (<name>IPos</name>)<call><name>MAX_DIST</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call> ?
<name><name>s</name>-&gt;<name>strstart</name></name> - (<name>IPos</name>)<call><name>MAX_DIST</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call> : <name>NIL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Posf</name> *</type><name>prev</name> <init>= <expr><name><name>s</name>-&gt;<name>prev</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uInt</name></type> <name>wmask</name> <init>= <expr><name><name>s</name>-&gt;<name>w_mask</name></name></expr></init></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>UNALIGNED_OK</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>register</name> <name>Bytef</name> *</type><name>strend</name> <init>= <expr><name><name>s</name>-&gt;<name>window</name></name> + <name><name>s</name>-&gt;<name>strstart</name></name> + <name>MAX_MATCH</name> - 1</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>register</name> <name>ush</name></type> <name>scan_start</name> <init>= <expr>*(<name>ushf</name>*)<name>scan</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>register</name> <name>ush</name></type> <name>scan_end</name> <init>= <expr>*<call>(<name>ushf</name>*)<argument_list>(<argument><expr><name>scan</name>+<name>best_len</name>-1</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<decl_stmt><decl><type><name>register</name> <name>Bytef</name> *</type><name>strend</name> <init>= <expr><name><name>s</name>-&gt;<name>window</name></name> + <name><name>s</name>-&gt;<name>strstart</name></name> + <name>MAX_MATCH</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>register</name> <name>Byte</name></type> <name>scan_end1</name> <init>= <expr><name><name>scan</name><index>[<expr><name>best_len</name>-1</expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>register</name> <name>Byte</name></type> <name>scan_end</name> <init>= <expr><name><name>scan</name><index>[<expr><name>best_len</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>s</name>-&gt;<name>hash_bits</name></name> &gt;= 8 &amp;&amp; <name>MAX_MATCH</name> == 258</expr></argument>, <argument><expr>"Code too clever"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>s</name>-&gt;<name>prev_length</name></name> &gt;= <name><name>s</name>-&gt;<name>good_match</name></name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>chain_length</name> &gt;&gt;= 2</expr>;</expr_stmt>
}</block></then></if>
<if>if <condition>(<expr>(<name>uInt</name>)<name>nice_match</name> &gt; <name><name>s</name>-&gt;<name>lookahead</name></name></expr>)</condition><then> <expr_stmt><expr><name>nice_match</name> = <name><name>s</name>-&gt;<name>lookahead</name></name></expr>;</expr_stmt></then></if>
<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr>(<name>ulg</name>)<name><name>s</name>-&gt;<name>strstart</name></name> &lt;= <name><name>s</name>-&gt;<name>window_size</name></name>-<name>MIN_LOOKAHEAD</name></expr></argument>, <argument><expr>"need lookahead"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<do>do <block>{
<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>cur_match</name> &lt; <name><name>s</name>-&gt;<name>strstart</name></name></expr></argument>, <argument><expr>"no future"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>match</name> = <name><name>s</name>-&gt;<name>window</name></name> + <name>cur_match</name></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>(<call><name>defined</name><argument_list>(<argument><expr><name>UNALIGNED_OK</name></expr></argument>)</argument_list></call> &amp;&amp; <name>MAX_MATCH</name> == 258)</expr></cpp:if>
<if>if <condition>(<expr>*<call>(<name>ushf</name>*)<argument_list>(<argument><expr><name>match</name>+<name>best_len</name>-1</expr></argument>)</argument_list></call> != <name>scan_end</name> ||
*(<name>ushf</name>*)<name>match</name> != <name>scan_start</name></expr>)</condition><then> <continue>continue;</continue></then></if>
<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>scan</name><index>[<expr>2</expr>]</index></name> == <name><name>match</name><index>[<expr>2</expr>]</index></name></expr></argument>, <argument><expr>"scan[2]?"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>scan</name>++</expr>, <expr><name>match</name>++</expr>;</expr_stmt>
<do>do <block>{
}</block> while <condition>(<expr>*<call>(<name>ushf</name>*)<argument_list>(<argument><expr><name>scan</name>+=2</expr></argument>)</argument_list></call> == *<call>(<name>ushf</name>*)<argument_list>(<argument><expr><name>match</name>+=2</expr></argument>)</argument_list></call> &amp;&amp;
*<call>(<name>ushf</name>*)<argument_list>(<argument><expr><name>scan</name>+=2</expr></argument>)</argument_list></call> == *<call>(<name>ushf</name>*)<argument_list>(<argument><expr><name>match</name>+=2</expr></argument>)</argument_list></call> &amp;&amp;
*<call>(<name>ushf</name>*)<argument_list>(<argument><expr><name>scan</name>+=2</expr></argument>)</argument_list></call> == *<call>(<name>ushf</name>*)<argument_list>(<argument><expr><name>match</name>+=2</expr></argument>)</argument_list></call> &amp;&amp;
*<call>(<name>ushf</name>*)<argument_list>(<argument><expr><name>scan</name>+=2</expr></argument>)</argument_list></call> == *<call>(<name>ushf</name>*)<argument_list>(<argument><expr><name>match</name>+=2</expr></argument>)</argument_list></call> &amp;&amp;
<name>scan</name> &lt; <name>strend</name></expr>)</condition>;</do>
<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>scan</name> &lt;= <name><name>s</name>-&gt;<name>window</name></name>+<call>(<name>unsigned</name>)<argument_list>(<argument><expr><name><name>s</name>-&gt;<name>window_size</name></name>-1</expr></argument>)</argument_list></call></expr></argument>, <argument><expr>"wild scan"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>*<name>scan</name> == *<name>match</name></expr>)</condition><then> <expr_stmt><expr><name>scan</name>++</expr>;</expr_stmt></then></if>
<expr_stmt><expr><name>len</name> = (<name>MAX_MATCH</name> - 1) - <call>(<name>int</name>)<argument_list>(<argument><expr><name>strend</name>-<name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>scan</name> = <name>strend</name> - (<name>MAX_MATCH</name>-1)</expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<if>if <condition>(<expr><name><name>match</name><index>[<expr><name>best_len</name></expr>]</index></name> != <name>scan_end</name> ||
<name><name>match</name><index>[<expr><name>best_len</name>-1</expr>]</index></name> != <name>scan_end1</name> ||
*<name>match</name> != *<name>scan</name> ||
*++<name>match</name> != <name><name>scan</name><index>[<expr>1</expr>]</index></name></expr>)</condition><then> <continue>continue;</continue></then></if>
<expr_stmt><expr><name>scan</name> += 2</expr>, <expr><name>match</name>++</expr>;</expr_stmt>
<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr>*<name>scan</name> == *<name>match</name></expr></argument>, <argument><expr>"match[2]?"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<do>do <block>{
}</block> while <condition>(<expr>*++<name>scan</name> == *++<name>match</name> &amp;&amp; *++<name>scan</name> == *++<name>match</name> &amp;&amp;
*++<name>scan</name> == *++<name>match</name> &amp;&amp; *++<name>scan</name> == *++<name>match</name> &amp;&amp;
*++<name>scan</name> == *++<name>match</name> &amp;&amp; *++<name>scan</name> == *++<name>match</name> &amp;&amp;
*++<name>scan</name> == *++<name>match</name> &amp;&amp; *++<name>scan</name> == *++<name>match</name> &amp;&amp;
<name>scan</name> &lt; <name>strend</name></expr>)</condition>;</do>
<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>scan</name> &lt;= <name><name>s</name>-&gt;<name>window</name></name>+<call>(<name>unsigned</name>)<argument_list>(<argument><expr><name><name>s</name>-&gt;<name>window_size</name></name>-1</expr></argument>)</argument_list></call></expr></argument>, <argument><expr>"wild scan"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>len</name> = <name>MAX_MATCH</name> - <call>(<name>int</name>)<argument_list>(<argument><expr><name>strend</name> - <name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>scan</name> = <name>strend</name> - <name>MAX_MATCH</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<if>if <condition>(<expr><name>len</name> &gt; <name>best_len</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>s</name>-&gt;<name>match_start</name></name> = <name>cur_match</name></expr>;</expr_stmt>
<expr_stmt><expr><name>best_len</name> = <name>len</name></expr>;</expr_stmt>
<if>if <condition>(<expr><name>len</name> &gt;= <name>nice_match</name></expr>)</condition><then> <break>break;</break></then></if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>UNALIGNED_OK</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><name>scan_end</name> = *<call>(<name>ushf</name>*)<argument_list>(<argument><expr><name>scan</name>+<name>best_len</name>-1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<expr_stmt><expr><name>scan_end1</name> = <name><name>scan</name><index>[<expr><name>best_len</name>-1</expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name>scan_end</name> = <name><name>scan</name><index>[<expr><name>best_len</name></expr>]</index></name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></then></if>
}</block> while <condition>(<expr>(<name>cur_match</name> = <name><name>prev</name><index>[<expr><name>cur_match</name> &amp; <name>wmask</name></expr>]</index></name>) &gt; <name>limit</name>
&amp;&amp; --<name>chain_length</name> != 0</expr>)</condition>;</do>
<if>if <condition>(<expr>(<name>uInt</name>)<name>best_len</name> &lt;= <name><name>s</name>-&gt;<name>lookahead</name></name></expr>)</condition><then> <return>return <expr>(<name>uInt</name>)<name>best_len</name></expr>;</return></then></if>
<return>return <expr><name><name>s</name>-&gt;<name>lookahead</name></name></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<function><type><name>local</name> <name>uInt</name></type> <name>longest_match_fast</name><parameter_list>(<param><decl><type><name>s</name></type></decl></param>, <param><decl><type><name>cur_match</name></type></decl></param>)</parameter_list>
<decl_stmt><decl><type><name>deflate_state</name> *</type><name>s</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>IPos</name></type> <name>cur_match</name></decl>;</decl_stmt>
<block>{
<decl_stmt><decl><type><name>register</name> <name>Bytef</name> *</type><name>scan</name> <init>= <expr><name><name>s</name>-&gt;<name>window</name></name> + <name><name>s</name>-&gt;<name>strstart</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>register</name> <name>Bytef</name> *</type><name>match</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>register</name> <name>int</name></type> <name>len</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>register</name> <name>Bytef</name> *</type><name>strend</name> <init>= <expr><name><name>s</name>-&gt;<name>window</name></name> + <name><name>s</name>-&gt;<name>strstart</name></name> + <name>MAX_MATCH</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>s</name>-&gt;<name>hash_bits</name></name> &gt;= 8 &amp;&amp; <name>MAX_MATCH</name> == 258</expr></argument>, <argument><expr>"Code too clever"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr>(<name>ulg</name>)<name><name>s</name>-&gt;<name>strstart</name></name> &lt;= <name><name>s</name>-&gt;<name>window_size</name></name>-<name>MIN_LOOKAHEAD</name></expr></argument>, <argument><expr>"need lookahead"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>cur_match</name> &lt; <name><name>s</name>-&gt;<name>strstart</name></name></expr></argument>, <argument><expr>"no future"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>match</name> = <name><name>s</name>-&gt;<name>window</name></name> + <name>cur_match</name></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>match</name><index>[<expr>0</expr>]</index></name> != <name><name>scan</name><index>[<expr>0</expr>]</index></name> || <name><name>match</name><index>[<expr>1</expr>]</index></name> != <name><name>scan</name><index>[<expr>1</expr>]</index></name></expr>)</condition><then> <return>return <expr><name>MIN_MATCH</name>-1</expr>;</return></then></if>
<expr_stmt><expr><name>scan</name> += 2</expr>, <expr><name>match</name> += 2</expr>;</expr_stmt>
<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr>*<name>scan</name> == *<name>match</name></expr></argument>, <argument><expr>"match[2]?"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<do>do <block>{
}</block> while <condition>(<expr>*++<name>scan</name> == *++<name>match</name> &amp;&amp; *++<name>scan</name> == *++<name>match</name> &amp;&amp;
*++<name>scan</name> == *++<name>match</name> &amp;&amp; *++<name>scan</name> == *++<name>match</name> &amp;&amp;
*++<name>scan</name> == *++<name>match</name> &amp;&amp; *++<name>scan</name> == *++<name>match</name> &amp;&amp;
*++<name>scan</name> == *++<name>match</name> &amp;&amp; *++<name>scan</name> == *++<name>match</name> &amp;&amp;
<name>scan</name> &lt; <name>strend</name></expr>)</condition>;</do>
<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>scan</name> &lt;= <name><name>s</name>-&gt;<name>window</name></name>+<call>(<name>unsigned</name>)<argument_list>(<argument><expr><name><name>s</name>-&gt;<name>window_size</name></name>-1</expr></argument>)</argument_list></call></expr></argument>, <argument><expr>"wild scan"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>len</name> = <name>MAX_MATCH</name> - <call>(<name>int</name>)<argument_list>(<argument><expr><name>strend</name> - <name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>len</name> &lt; <name>MIN_MATCH</name></expr>)</condition><then> <return>return <expr><name>MIN_MATCH</name> - 1</expr>;</return></then></if>
<expr_stmt><expr><name><name>s</name>-&gt;<name>match_start</name></name> = <name>cur_match</name></expr>;</expr_stmt>
<return>return <expr>(<name>uInt</name>)<name>len</name> &lt;= <name><name>s</name>-&gt;<name>lookahead</name></name> ? (<name>uInt</name>)<name>len</name> : <name><name>s</name>-&gt;<name>lookahead</name></name></expr>;</return>
}</block></function>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>DEBUG</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function><type><name>local</name> <name>void</name></type> <name>check_match</name><parameter_list>(<param><decl><type><name>s</name></type></decl></param>, <param><decl><type><name>start</name></type></decl></param>, <param><decl><type><name>match</name></type></decl></param>, <param><decl><type><name>length</name></type></decl></param>)</parameter_list>
<decl_stmt><decl><type><name>deflate_state</name> *</type><name>s</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>IPos</name></type> <name>start</name></decl>, <decl><type ref="prev"/><name>match</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>length</name></decl>;</decl_stmt>
<block>{
<if>if <condition>(<expr><call><name>zmemcmp</name><argument_list>(<argument><expr><name><name>s</name>-&gt;<name>window</name></name> + <name>match</name></expr></argument>,
<argument><expr><name><name>s</name>-&gt;<name>window</name></name> + <name>start</name></expr></argument>, <argument><expr><name>length</name></expr></argument>)</argument_list></call> != <name>EQUAL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr>" start %u, match %u, length %d\n"</expr></argument>,
<argument><expr><name>start</name></expr></argument>, <argument><expr><name>match</name></expr></argument>, <argument><expr><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<do>do <block>{
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr>"%c%c"</expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>window</name><index>[<expr><name>match</name>++</expr>]</index></name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>window</name><index>[<expr><name>start</name>++</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block> while <condition>(<expr>--<name>length</name> != 0</expr>)</condition>;</do>
<expr_stmt><expr><call><name>z_error</name><argument_list>(<argument><expr>"invalid match"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<if>if <condition>(<expr><name>z_verbose</name> &gt; 1</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,<argument><expr>"\\[%d,%d]"</expr></argument>, <argument><expr><name>start</name>-<name>match</name></expr></argument>, <argument><expr><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<do>do <block>{
<expr_stmt><expr><call><name>putc</name><argument_list>(<argument><expr><name><name>s</name>-&gt;<name>window</name><index>[<expr><name>start</name>++</expr>]</index></name></expr></argument>, <argument><expr><name>stderr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block> while <condition>(<expr>--<name>length</name> != 0</expr>)</condition>;</do>
}</block></then></if>
}</block></function>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>check_match</name><parameter_list>(<param><type><name>s</name></type></param>, <param><type><name>start</name></type></param>, <param><type><name>match</name></type></param>, <param><type><name>length</name></type></param>)</parameter_list></cpp:macro></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<function><type><name>local</name> <name>void</name></type> <name>fill_window</name><parameter_list>(<param><decl><type><name>s</name></type></decl></param>)</parameter_list>
<decl_stmt><decl><type><name>deflate_state</name> *</type><name>s</name></decl>;</decl_stmt>
<block>{
<decl_stmt><decl><type><name>register</name> <name>unsigned</name></type> <name>n</name></decl>, <decl><type ref="prev"/><name>m</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>register</name> <name>Posf</name> *</type><name>p</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name></type> <name>more</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uInt</name></type> <name>wsize</name> <init>= <expr><name><name>s</name>-&gt;<name>w_size</name></name></expr></init></decl>;</decl_stmt>
<do>do <block>{
<expr_stmt><expr><name>more</name> = <call>(<name>unsigned</name>)<argument_list>(<argument><expr><name><name>s</name>-&gt;<name>window_size</name></name> -(<name>ulg</name>)<name><name>s</name>-&gt;<name>lookahead</name></name> -(<name>ulg</name>)<name><name>s</name>-&gt;<name>strstart</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof> &lt;= 2</expr>)</condition><then> <block>{
<if>if <condition>(<expr><name>more</name> == 0 &amp;&amp; <name><name>s</name>-&gt;<name>strstart</name></name> == 0 &amp;&amp; <name><name>s</name>-&gt;<name>lookahead</name></name> == 0</expr>)</condition><then> <block>{
<expr_stmt><expr><name>more</name> = <name>wsize</name></expr>;</expr_stmt>
}</block></then> <else>else <if>if <condition>(<expr><name>more</name> == <call>(<name>unsigned</name>)<argument_list>(<argument><expr>-1</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><name>more</name>--</expr>;</expr_stmt>
}</block></then></if></else></if>
}</block></then></if>
<if>if <condition>(<expr><name><name>s</name>-&gt;<name>strstart</name></name> &gt;= <name>wsize</name>+<call><name>MAX_DIST</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>zmemcpy</name><argument_list>(<argument><expr><name><name>s</name>-&gt;<name>window</name></name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>window</name></name>+<name>wsize</name></expr></argument>, <argument><expr>(<name>unsigned</name>)<name>wsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name>-&gt;<name>match_start</name></name> -= <name>wsize</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name>-&gt;<name>strstart</name></name> -= <name>wsize</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name>-&gt;<name>block_start</name></name> -= (<name>long</name>) <name>wsize</name></expr>;</expr_stmt>
<expr_stmt><expr><name>n</name> = <name><name>s</name>-&gt;<name>hash_size</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>p</name> = &amp;<name><name>s</name>-&gt;<name>head</name><index>[<expr><name>n</name></expr>]</index></name></expr>;</expr_stmt>
<do>do <block>{
<expr_stmt><expr><name>m</name> = *--<name>p</name></expr>;</expr_stmt>
<expr_stmt><expr>*<name>p</name> = <call>(<name>Pos</name>)<argument_list>(<argument><expr><name>m</name> &gt;= <name>wsize</name> ? <name>m</name>-<name>wsize</name> : <name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block> while <condition>(<expr>--<name>n</name></expr>)</condition>;</do>
<expr_stmt><expr><name>n</name> = <name>wsize</name></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>FASTEST</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><name>p</name> = &amp;<name><name>s</name>-&gt;<name>prev</name><index>[<expr><name>n</name></expr>]</index></name></expr>;</expr_stmt>
<do>do <block>{
<expr_stmt><expr><name>m</name> = *--<name>p</name></expr>;</expr_stmt>
<expr_stmt><expr>*<name>p</name> = <call>(<name>Pos</name>)<argument_list>(<argument><expr><name>m</name> &gt;= <name>wsize</name> ? <name>m</name>-<name>wsize</name> : <name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block> while <condition>(<expr>--<name>n</name></expr>)</condition>;</do>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><name>more</name> += <name>wsize</name></expr>;</expr_stmt>
}</block></then></if>
<if>if <condition>(<expr><name><name>s</name>-&gt;<name>strm</name>-&gt;<name>avail_in</name></name> == 0</expr>)</condition><then> <return>return;</return></then></if>
<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>more</name> &gt;= 2</expr></argument>, <argument><expr>"more &lt; 2"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>n</name> = <call><name>read_buf</name><argument_list>(<argument><expr><name><name>s</name>-&gt;<name>strm</name></name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>window</name></name> + <name><name>s</name>-&gt;<name>strstart</name></name> + <name><name>s</name>-&gt;<name>lookahead</name></name></expr></argument>, <argument><expr><name>more</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name>-&gt;<name>lookahead</name></name> += <name>n</name></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>s</name>-&gt;<name>lookahead</name></name> &gt;= <name>MIN_MATCH</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>s</name>-&gt;<name>ins_h</name></name> = <name><name>s</name>-&gt;<name>window</name><index>[<expr><name><name>s</name>-&gt;<name>strstart</name></name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>UPDATE_HASH</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>ins_h</name></name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>window</name><index>[<expr><name><name>s</name>-&gt;<name>strstart</name></name>+1</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>MIN_MATCH</name> != 3</expr></cpp:if>
<expr_stmt><expr><name>Call</name> <macro><name>UPDATE_HASH</name><argument_list>()</argument_list></macro> <name>MIN_MATCH</name>-3 <name>more</name> <name>times</name></expr></expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></then></if>
}</block> while <condition>(<expr><name><name>s</name>-&gt;<name>lookahead</name></name> &lt; <name>MIN_LOOKAHEAD</name> &amp;&amp; <name><name>s</name>-&gt;<name>strm</name>-&gt;<name>avail_in</name></name> != 0</expr>)</condition>;</do>
}</block></function>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FLUSH_BLOCK_ONLY</name><parameter_list>(<param><type><name>s</name></type></param>, <param><type><name>eof</name></type></param>)</parameter_list></cpp:macro> <cpp:value>{ _tr_flush_block(s, (s-&gt;block_start &gt;= 0L ? (charf *)&amp;s-&gt;window[(unsigned)s-&gt;block_start] : (charf *)Z_NULL), (ulg)((long)s-&gt;strstart - s-&gt;block_start), (eof)); s-&gt;block_start = s-&gt;strstart; flush_pending(s-&gt;strm); Tracev((stderr,"[FLUSH]")); }</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FLUSH_BLOCK</name><parameter_list>(<param><type><name>s</name></type></param>, <param><type><name>eof</name></type></param>)</parameter_list></cpp:macro> <cpp:value>{ FLUSH_BLOCK_ONLY(s, eof); if (s-&gt;strm-&gt;avail_out == 0) return (eof) ? finish_started : need_more; }</cpp:value></cpp:define>
<function><type><name>local</name> <name>block_state</name></type> <name>deflate_stored</name><parameter_list>(<param><decl><type><name>s</name></type></decl></param>, <param><decl><type><name>flush</name></type></decl></param>)</parameter_list>
<decl_stmt><decl><type><name>deflate_state</name> *</type><name>s</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>flush</name></decl>;</decl_stmt>
<block>{
<decl_stmt><decl><type><name>ulg</name></type> <name>max_block_size</name> <init>= <expr>0xffff</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ulg</name></type> <name>max_start</name></decl>;</decl_stmt>
<if>if <condition>(<expr><name>max_block_size</name> &gt; <name><name>s</name>-&gt;<name>pending_buf_size</name></name> - 5</expr>)</condition><then> <block>{
<expr_stmt><expr><name>max_block_size</name> = <name><name>s</name>-&gt;<name>pending_buf_size</name></name> - 5</expr>;</expr_stmt>
}</block></then></if>
<for>for (<init>;</init><condition>;</condition><incr/>) <block>{
<if>if <condition>(<expr><name><name>s</name>-&gt;<name>lookahead</name></name> &lt;= 1</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>s</name>-&gt;<name>strstart</name></name> &lt; <name><name>s</name>-&gt;<name>w_size</name></name>+<call><name>MAX_DIST</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call> ||
<name><name>s</name>-&gt;<name>block_start</name></name> &gt;= (<name>long</name>)<name><name>s</name>-&gt;<name>w_size</name></name></expr></argument>, <argument><expr>"slide too late"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>fill_window</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>s</name>-&gt;<name>lookahead</name></name> == 0 &amp;&amp; <name>flush</name> == <name>Z_NO_FLUSH</name></expr>)</condition><then> <return>return <expr><name>need_more</name></expr>;</return></then></if>
<if>if <condition>(<expr><name><name>s</name>-&gt;<name>lookahead</name></name> == 0</expr>)</condition><then> <break>break;</break></then></if>
}</block></then></if>
<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>s</name>-&gt;<name>block_start</name></name> &gt;= 0L</expr></argument>, <argument><expr>"block gone"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name>-&gt;<name>strstart</name></name> += <name><name>s</name>-&gt;<name>lookahead</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name>-&gt;<name>lookahead</name></name> = 0</expr>;</expr_stmt>
<expr_stmt><expr><name>max_start</name> = <name><name>s</name>-&gt;<name>block_start</name></name> + <name>max_block_size</name></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>s</name>-&gt;<name>strstart</name></name> == 0 || (<name>ulg</name>)<name><name>s</name>-&gt;<name>strstart</name></name> &gt;= <name>max_start</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>s</name>-&gt;<name>lookahead</name></name> = <call>(<name>uInt</name>)<argument_list>(<argument><expr><name><name>s</name>-&gt;<name>strstart</name></name> - <name>max_start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name>-&gt;<name>strstart</name></name> = (<name>uInt</name>)<name>max_start</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>FLUSH_BLOCK</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<if>if <condition>(<expr><name><name>s</name>-&gt;<name>strstart</name></name> - (<name>uInt</name>)<name><name>s</name>-&gt;<name>block_start</name></name> &gt;= <call><name>MAX_DIST</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>FLUSH_BLOCK</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
}</block></for>
<expr_stmt><expr><call><name>FLUSH_BLOCK</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>flush</name> == <name>Z_FINISH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>flush</name> == <name>Z_FINISH</name> ? <name>finish_done</name> : <name>block_done</name></expr>;</return>
}</block></function>
<function><type><name>local</name> <name>block_state</name></type> <name>deflate_fast</name><parameter_list>(<param><decl><type><name>s</name></type></decl></param>, <param><decl><type><name>flush</name></type></decl></param>)</parameter_list>
<decl_stmt><decl><type><name>deflate_state</name> *</type><name>s</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>flush</name></decl>;</decl_stmt>
<block>{
<decl_stmt><decl><type><name>IPos</name></type> <name>hash_head</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>bflush</name></decl>;</decl_stmt>
<for>for (<init>;</init><condition>;</condition><incr/>) <block>{
<if>if <condition>(<expr><name><name>s</name>-&gt;<name>lookahead</name></name> &lt; <name>MIN_LOOKAHEAD</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>fill_window</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>s</name>-&gt;<name>lookahead</name></name> &lt; <name>MIN_LOOKAHEAD</name> &amp;&amp; <name>flush</name> == <name>Z_NO_FLUSH</name></expr>)</condition><then> <block>{
<return>return <expr><name>need_more</name></expr>;</return>
}</block></then></if>
<if>if <condition>(<expr><name><name>s</name>-&gt;<name>lookahead</name></name> == 0</expr>)</condition><then> <break>break;</break></then></if>
}</block></then></if>
<if>if <condition>(<expr><name><name>s</name>-&gt;<name>lookahead</name></name> &gt;= <name>MIN_MATCH</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>INSERT_STRING</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>strstart</name></name></expr></argument>, <argument><expr><name>hash_head</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<if>if <condition>(<expr><name>hash_head</name> != <name>NIL</name> &amp;&amp; <name><name>s</name>-&gt;<name>strstart</name></name> - <name>hash_head</name> &lt;= <call><name>MAX_DIST</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FASTEST</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if>if <condition>(<expr>(<name><name>s</name>-&gt;<name>strategy</name></name> != <name>Z_HUFFMAN_ONLY</name> &amp;&amp; <name><name>s</name>-&gt;<name>strategy</name></name> != <name>Z_RLE</name>) ||
(<name><name>s</name>-&gt;<name>strategy</name></name> == <name>Z_RLE</name> &amp;&amp; <name><name>s</name>-&gt;<name>strstart</name></name> - <name>hash_head</name> == 1)</expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>s</name>-&gt;<name>match_length</name></name> = <call><name>longest_match_fast</name> <argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>hash_head</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<if>if <condition>(<expr><name><name>s</name>-&gt;<name>strategy</name></name> != <name>Z_HUFFMAN_ONLY</name> &amp;&amp; <name><name>s</name>-&gt;<name>strategy</name></name> != <name>Z_RLE</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>s</name>-&gt;<name>match_length</name></name> = <call><name>longest_match</name> <argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>hash_head</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else <if>if <condition>(<expr><name><name>s</name>-&gt;<name>strategy</name></name> == <name>Z_RLE</name> &amp;&amp; <name><name>s</name>-&gt;<name>strstart</name></name> - <name>hash_head</name> == 1</expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>s</name>-&gt;<name>match_length</name></name> = <call><name>longest_match_fast</name> <argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>hash_head</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if></else></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></then></if>
<if>if <condition>(<expr><name><name>s</name>-&gt;<name>match_length</name></name> &gt;= <name>MIN_MATCH</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>check_match</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>strstart</name></name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>match_start</name></name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>match_length</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>_tr_tally_dist</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>strstart</name></name> - <name><name>s</name>-&gt;<name>match_start</name></name></expr></argument>,
<argument><expr><name><name>s</name>-&gt;<name>match_length</name></name> - <name>MIN_MATCH</name></expr></argument>, <argument><expr><name>bflush</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name>-&gt;<name>lookahead</name></name> -= <name><name>s</name>-&gt;<name>match_length</name></name></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>FASTEST</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if>if <condition>(<expr><name><name>s</name>-&gt;<name>match_length</name></name> &lt;= <name><name>s</name>-&gt;<name>max_insert_length</name></name> &amp;&amp;
<name><name>s</name>-&gt;<name>lookahead</name></name> &gt;= <name>MIN_MATCH</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>s</name>-&gt;<name>match_length</name></name>--</expr>;</expr_stmt>
<do>do <block>{
<expr_stmt><expr><name><name>s</name>-&gt;<name>strstart</name></name>++</expr>;</expr_stmt>
<expr_stmt><expr><call><name>INSERT_STRING</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>strstart</name></name></expr></argument>, <argument><expr><name>hash_head</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block> while <condition>(<expr>--<name><name>s</name>-&gt;<name>match_length</name></name> != 0</expr>)</condition>;</do>
<expr_stmt><expr><name><name>s</name>-&gt;<name>strstart</name></name>++</expr>;</expr_stmt>
}</block></then> <else>else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<block>{
<expr_stmt><expr><name><name>s</name>-&gt;<name>strstart</name></name> += <name><name>s</name>-&gt;<name>match_length</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name>-&gt;<name>match_length</name></name> = 0</expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name>-&gt;<name>ins_h</name></name> = <name><name>s</name>-&gt;<name>window</name><index>[<expr><name><name>s</name>-&gt;<name>strstart</name></name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>UPDATE_HASH</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>ins_h</name></name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>window</name><index>[<expr><name><name>s</name>-&gt;<name>strstart</name></name>+1</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>MIN_MATCH</name> != 3</expr></cpp:if>
<expr_stmt><expr><name>Call</name> <macro><name>UPDATE_HASH</name><argument_list>()</argument_list></macro> <name>MIN_MATCH</name>-3 <name>more</name> <name>times</name></expr></expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></else></if>
}</block></then> <else>else <block>{
<expr_stmt><expr><call><name>Tracevv</name><argument_list>(<argument><expr>(<name>stderr</name>,"%c", <name><name>s</name>-&gt;<name>window</name><index>[<expr><name><name>s</name>-&gt;<name>strstart</name></name></expr>]</index></name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>_tr_tally_lit</name> <argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>window</name><index>[<expr><name><name>s</name>-&gt;<name>strstart</name></name></expr>]</index></name></expr></argument>, <argument><expr><name>bflush</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name>-&gt;<name>lookahead</name></name>--</expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name>-&gt;<name>strstart</name></name>++</expr>;</expr_stmt>
}</block></else></if>
<if>if <condition>(<expr><name>bflush</name></expr>)</condition><then> <expr_stmt><expr><call><name>FLUSH_BLOCK</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
}</block></for>
<expr_stmt><expr><call><name>FLUSH_BLOCK</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>flush</name> == <name>Z_FINISH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>flush</name> == <name>Z_FINISH</name> ? <name>finish_done</name> : <name>block_done</name></expr>;</return>
}</block></function>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>FASTEST</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function><type><name>local</name> <name>block_state</name></type> <name>deflate_slow</name><parameter_list>(<param><decl><type><name>s</name></type></decl></param>, <param><decl><type><name>flush</name></type></decl></param>)</parameter_list>
<decl_stmt><decl><type><name>deflate_state</name> *</type><name>s</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>flush</name></decl>;</decl_stmt>
<block>{
<decl_stmt><decl><type><name>IPos</name></type> <name>hash_head</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>bflush</name></decl>;</decl_stmt>
<for>for (<init>;</init><condition>;</condition><incr/>) <block>{
<if>if <condition>(<expr><name><name>s</name>-&gt;<name>lookahead</name></name> &lt; <name>MIN_LOOKAHEAD</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>fill_window</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>s</name>-&gt;<name>lookahead</name></name> &lt; <name>MIN_LOOKAHEAD</name> &amp;&amp; <name>flush</name> == <name>Z_NO_FLUSH</name></expr>)</condition><then> <block>{
<return>return <expr><name>need_more</name></expr>;</return>
}</block></then></if>
<if>if <condition>(<expr><name><name>s</name>-&gt;<name>lookahead</name></name> == 0</expr>)</condition><then> <break>break;</break></then></if>
}</block></then></if>
<if>if <condition>(<expr><name><name>s</name>-&gt;<name>lookahead</name></name> &gt;= <name>MIN_MATCH</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>INSERT_STRING</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>strstart</name></name></expr></argument>, <argument><expr><name>hash_head</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><name><name>s</name>-&gt;<name>prev_length</name></name> = <name><name>s</name>-&gt;<name>match_length</name></name></expr>, <expr><name><name>s</name>-&gt;<name>prev_match</name></name> = <name><name>s</name>-&gt;<name>match_start</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name>-&gt;<name>match_length</name></name> = <name>MIN_MATCH</name>-1</expr>;</expr_stmt>
<if>if <condition>(<expr><name>hash_head</name> != <name>NIL</name> &amp;&amp; <name><name>s</name>-&gt;<name>prev_length</name></name> &lt; <name><name>s</name>-&gt;<name>max_lazy_match</name></name> &amp;&amp;
<name><name>s</name>-&gt;<name>strstart</name></name> - <name>hash_head</name> &lt;= <call><name>MAX_DIST</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<if>if <condition>(<expr><name><name>s</name>-&gt;<name>strategy</name></name> != <name>Z_HUFFMAN_ONLY</name> &amp;&amp; <name><name>s</name>-&gt;<name>strategy</name></name> != <name>Z_RLE</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>s</name>-&gt;<name>match_length</name></name> = <call><name>longest_match</name> <argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>hash_head</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else <if>if <condition>(<expr><name><name>s</name>-&gt;<name>strategy</name></name> == <name>Z_RLE</name> &amp;&amp; <name><name>s</name>-&gt;<name>strstart</name></name> - <name>hash_head</name> == 1</expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>s</name>-&gt;<name>match_length</name></name> = <call><name>longest_match_fast</name> <argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>hash_head</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if></else></if>
<if>if <condition>(<expr><name><name>s</name>-&gt;<name>match_length</name></name> &lt;= 5 &amp;&amp; (<name><name>s</name>-&gt;<name>strategy</name></name> == <name>Z_FILTERED</name>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>TOO_FAR</name> &lt;= 32767</expr></cpp:if>
|| (<name><name>s</name>-&gt;<name>match_length</name></name> == <name>MIN_MATCH</name> &amp;&amp;
<name><name>s</name>-&gt;<name>strstart</name></name> - <name><name>s</name>-&gt;<name>match_start</name></name> &gt; <name>TOO_FAR</name>)
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
)</expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>s</name>-&gt;<name>match_length</name></name> = <name>MIN_MATCH</name>-1</expr>;</expr_stmt>
}</block></then></if>
}</block></then></if>
<if>if <condition>(<expr><name><name>s</name>-&gt;<name>prev_length</name></name> &gt;= <name>MIN_MATCH</name> &amp;&amp; <name><name>s</name>-&gt;<name>match_length</name></name> &lt;= <name><name>s</name>-&gt;<name>prev_length</name></name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>uInt</name></type> <name>max_insert</name> <init>= <expr><name><name>s</name>-&gt;<name>strstart</name></name> + <name><name>s</name>-&gt;<name>lookahead</name></name> - <name>MIN_MATCH</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>check_match</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>strstart</name></name>-1</expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>prev_match</name></name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>prev_length</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>_tr_tally_dist</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>strstart</name></name> -1 - <name><name>s</name>-&gt;<name>prev_match</name></name></expr></argument>,
<argument><expr><name><name>s</name>-&gt;<name>prev_length</name></name> - <name>MIN_MATCH</name></expr></argument>, <argument><expr><name>bflush</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name>-&gt;<name>lookahead</name></name> -= <name><name>s</name>-&gt;<name>prev_length</name></name>-1</expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name>-&gt;<name>prev_length</name></name> -= 2</expr>;</expr_stmt>
<do>do <block>{
<if>if <condition>(<expr>++<name><name>s</name>-&gt;<name>strstart</name></name> &lt;= <name>max_insert</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>INSERT_STRING</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>strstart</name></name></expr></argument>, <argument><expr><name>hash_head</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
}</block> while <condition>(<expr>--<name><name>s</name>-&gt;<name>prev_length</name></name> != 0</expr>)</condition>;</do>
<expr_stmt><expr><name><name>s</name>-&gt;<name>match_available</name></name> = 0</expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name>-&gt;<name>match_length</name></name> = <name>MIN_MATCH</name>-1</expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name>-&gt;<name>strstart</name></name>++</expr>;</expr_stmt>
<if>if <condition>(<expr><name>bflush</name></expr>)</condition><then> <expr_stmt><expr><call><name>FLUSH_BLOCK</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
}</block></then> <else>else <if>if <condition>(<expr><name><name>s</name>-&gt;<name>match_available</name></name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Tracevv</name><argument_list>(<argument><expr>(<name>stderr</name>,"%c", <name><name>s</name>-&gt;<name>window</name><index>[<expr><name><name>s</name>-&gt;<name>strstart</name></name>-1</expr>]</index></name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>_tr_tally_lit</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>window</name><index>[<expr><name><name>s</name>-&gt;<name>strstart</name></name>-1</expr>]</index></name></expr></argument>, <argument><expr><name>bflush</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>bflush</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>FLUSH_BLOCK_ONLY</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><name><name>s</name>-&gt;<name>strstart</name></name>++</expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name>-&gt;<name>lookahead</name></name>--</expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>s</name>-&gt;<name>strm</name>-&gt;<name>avail_out</name></name> == 0</expr>)</condition><then> <return>return <expr><name>need_more</name></expr>;</return></then></if>
}</block></then> <else>else <block>{
<expr_stmt><expr><name><name>s</name>-&gt;<name>match_available</name></name> = 1</expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name>-&gt;<name>strstart</name></name>++</expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name>-&gt;<name>lookahead</name></name>--</expr>;</expr_stmt>
}</block></else></if></else></if>
}</block></for>
<expr_stmt><expr><call><name>Assert</name> <argument_list>(<argument><expr><name>flush</name> != <name>Z_NO_FLUSH</name></expr></argument>, <argument><expr>"no flush?"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>s</name>-&gt;<name>match_available</name></name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Tracevv</name><argument_list>(<argument><expr>(<name>stderr</name>,"%c", <name><name>s</name>-&gt;<name>window</name><index>[<expr><name><name>s</name>-&gt;<name>strstart</name></name>-1</expr>]</index></name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>_tr_tally_lit</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>window</name><index>[<expr><name><name>s</name>-&gt;<name>strstart</name></name>-1</expr>]</index></name></expr></argument>, <argument><expr><name>bflush</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name>-&gt;<name>match_available</name></name> = 0</expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><call><name>FLUSH_BLOCK</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>flush</name> == <name>Z_FINISH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>flush</name> == <name>Z_FINISH</name> ? <name>finish_done</name> : <name>block_done</name></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>0</expr></cpp:if>
local block_state deflate_rle(s, flush)
deflate_state *s;
int flush;
{
int bflush;
uInt run;
uInt max;
uInt prev;
Bytef *scan;
for (;;) {
if (s-&gt;lookahead &lt; MAX_MATCH) {
fill_window(s);
if (s-&gt;lookahead &lt; MAX_MATCH &amp;&amp; flush == Z_NO_FLUSH) {
return need_more;
}
if (s-&gt;lookahead == 0) break;
}
run = 0;
if (s-&gt;strstart &gt; 0) {
max = s-&gt;lookahead &lt; MAX_MATCH ? s-&gt;lookahead : MAX_MATCH;
scan = s-&gt;window + s-&gt;strstart - 1;
prev = *scan++;
do {
if (*scan++ != prev)
break;
} while (++run &lt; max);
}
if (run &gt;= MIN_MATCH) {
check_match(s, s-&gt;strstart, s-&gt;strstart - 1, run);
_tr_tally_dist(s, 1, run - MIN_MATCH, bflush);
s-&gt;lookahead -= run;
s-&gt;strstart += run;
} else {
Tracevv((stderr,"%c", s-&gt;window[s-&gt;strstart]));
_tr_tally_lit (s, s-&gt;window[s-&gt;strstart], bflush);
s-&gt;lookahead--;
s-&gt;strstart++;
}
if (bflush) FLUSH_BLOCK(s, 0);
}
FLUSH_BLOCK(s, flush == Z_FINISH);
return flush == Z_FINISH ? finish_done : block_done;
}
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</unit>
