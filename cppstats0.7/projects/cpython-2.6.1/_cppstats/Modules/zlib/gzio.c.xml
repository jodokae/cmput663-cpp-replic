<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C" filename="projects/cpython-2.6.1/_cppstats/Modules/zlib/gzio.c"><cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdio.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"zutil.h"</cpp:file></cpp:include>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>NO_DEFLATE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NO_GZCOMPRESS</name></cpp:macro></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>NO_DUMMY_DECL</name></expr></argument>)</argument_list></call></expr></cpp:if>
<struct>struct <name>internal_state</name> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>dummy</name></decl>;</decl_stmt>
}</block>;</struct>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>Z_BUFSIZE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MAXSEG_64K</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Z_BUFSIZE</name></cpp:macro> <cpp:value>4096</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Z_BUFSIZE</name></cpp:macro> <cpp:value>16384</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>Z_PRINTF_BUFSIZE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Z_PRINTF_BUFSIZE</name></cpp:macro> <cpp:value>4096</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__MVS__</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:pragma>#<cpp:directive>pragma</cpp:directive> map (fdopen , "\174\174FDOPEN")</cpp:pragma>
<function_decl><type><name>FILE</name> *</type><name>fdopen</name><parameter_list>(<param><decl><type><name>int</name></type></decl></param>, <param><decl><type><specifier>const</specifier></type> <name>char</name> *</decl></param>)</parameter_list>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>STDC</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><specifier>extern</specifier> <name>voidp</name> <name>malloc</name></type> <name>OF</name><argument_list>(<argument><expr>(<name>uInt</name> <name>size</name>)</expr></argument>)</argument_list></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>extern</specifier> <name>void</name> <name>free</name></type> <name>OF</name><argument_list>(<argument><expr>(<name>voidpf</name> <name>ptr</name>)</expr></argument>)</argument_list></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ALLOC</name><parameter_list>(<param><type><name>size</name></type></param>)</parameter_list></cpp:macro> <cpp:value>malloc(size)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TRYFREE</name><parameter_list>(<param><type><name>p</name></type></param>)</parameter_list></cpp:macro> <cpp:value>{if (p) free(p);}</cpp:value></cpp:define>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name> <specifier>const</specifier></type> <name><name>gz_magic</name><index>[<expr>2</expr>]</index></name> <init>= <expr><block>{<expr>0x1f</expr>, <expr>0x8b</expr>}</block></expr></init></decl>;</decl_stmt>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ASCII_FLAG</name></cpp:macro> <cpp:value>0x01</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HEAD_CRC</name></cpp:macro> <cpp:value>0x02</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>EXTRA_FIELD</name></cpp:macro> <cpp:value>0x04</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ORIG_NAME</name></cpp:macro> <cpp:value>0x08</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>COMMENT</name></cpp:macro> <cpp:value>0x10</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RESERVED</name></cpp:macro> <cpp:value>0xE0</cpp:value></cpp:define>
<typedef>typedef <type><struct>struct <name>gz_stream</name> <block>{
<decl_stmt><decl><type><name>z_stream</name></type> <name>stream</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>z_err</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>z_eof</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>FILE</name> *</type><name>file</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Byte</name> *</type><name>inbuf</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Byte</name> *</type><name>outbuf</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uLong</name></type> <name>crc</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>msg</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>path</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>transparent</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name>mode</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>z_off_t</name></type> <name>start</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>z_off_t</name></type> <name>in</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>z_off_t</name></type> <name>out</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>back</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>last</name></decl>;</decl_stmt>
}</block></struct></type> <name>gz_stream</name>;</typedef>
<decl_stmt><decl><type><name>local</name> <name>gzFile</name> <name>gz_open</name></type> <name>OF</name><argument_list>(<argument><expr>(const <name>char</name> *<name>path</name>, const <name>char</name> *<name>mode</name>, <name>int</name> <name>fd</name>)</expr></argument>)</argument_list></decl>;</decl_stmt>
<decl_stmt><decl><type><name>local</name> <name>int</name> <name>do_flush</name></type> <name>OF</name><argument_list>(<argument><expr>(<name>gzFile</name> <name>file</name>, <name>int</name> <name>flush</name>)</expr></argument>)</argument_list></decl>;</decl_stmt>
<decl_stmt><decl><type><name>local</name> <name>int</name> <name>get_byte</name></type> <name>OF</name><argument_list>(<argument><expr>(<name>gz_stream</name> *<name>s</name>)</expr></argument>)</argument_list></decl>;</decl_stmt>
<decl_stmt><decl><type><name>local</name> <name>void</name> <name>check_header</name></type> <name>OF</name><argument_list>(<argument><expr>(<name>gz_stream</name> *<name>s</name>)</expr></argument>)</argument_list></decl>;</decl_stmt>
<decl_stmt><decl><type><name>local</name> <name>int</name> <name>destroy</name></type> <name>OF</name><argument_list>(<argument><expr>(<name>gz_stream</name> *<name>s</name>)</expr></argument>)</argument_list></decl>;</decl_stmt>
<decl_stmt><decl><type><name>local</name> <name>void</name> <name>putLong</name></type> <name>OF</name><argument_list>(<argument><expr>(<name>FILE</name> *<name>file</name>, <name>uLong</name> <name>x</name>)</expr></argument>)</argument_list></decl>;</decl_stmt>
<decl_stmt><decl><type><name>local</name> <name>uLong</name> <name>getLong</name></type> <name>OF</name><argument_list>(<argument><expr>(<name>gz_stream</name> *<name>s</name>)</expr></argument>)</argument_list></decl>;</decl_stmt>
<function><type><name>local</name> <name>gzFile</name></type> <name>gz_open</name> <parameter_list>(<param><decl><type><name>path</name></type></decl></param>, <param><decl><type><name>mode</name></type></decl></param>, <param><decl><type><name>fd</name></type></decl></param>)</parameter_list>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>mode</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>fd</name></decl>;</decl_stmt>
<block>{
<decl_stmt><decl><type><name>int</name></type> <name>err</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>level</name> <init>= <expr><name>Z_DEFAULT_COMPRESSION</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>strategy</name> <init>= <expr><name>Z_DEFAULT_STRATEGY</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>p</name> <init>= <expr>(<name>char</name>*)<name>mode</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>gz_stream</name> *</type><name>s</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name><name>fmode</name><index>[<expr>80</expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>m</name> <init>= <expr><name>fmode</name></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr>!<name>path</name> || !<name>mode</name></expr>)</condition><then> <return>return <expr><name>Z_NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>s</name> = (<name>gz_stream</name> *)<call><name>ALLOC</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>gz_stream</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>s</name></expr>)</condition><then> <return>return <expr><name>Z_NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name><name>s</name>-&gt;<name>stream</name>.<name>zalloc</name></name> = (<name>alloc_func</name>)0</expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name>-&gt;<name>stream</name>.<name>zfree</name></name> = (<name>free_func</name>)0</expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name>-&gt;<name>stream</name>.<name>opaque</name></name> = (<name>voidpf</name>)0</expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name>-&gt;<name>stream</name>.<name>next_in</name></name> = <name><name>s</name>-&gt;<name>inbuf</name></name> = <name>Z_NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name>-&gt;<name>stream</name>.<name>next_out</name></name> = <name><name>s</name>-&gt;<name>outbuf</name></name> = <name>Z_NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name>-&gt;<name>stream</name>.<name>avail_in</name></name> = <name><name>s</name>-&gt;<name>stream</name>.<name>avail_out</name></name> = 0</expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name>-&gt;<name>file</name></name> = <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name>-&gt;<name>z_err</name></name> = <name>Z_OK</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name>-&gt;<name>z_eof</name></name> = 0</expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name>-&gt;<name>in</name></name> = 0</expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name>-&gt;<name>out</name></name> = 0</expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name>-&gt;<name>back</name></name> = <name>EOF</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name>-&gt;<name>crc</name></name> = <call><name>crc32</name><argument_list>(<argument><expr>0L</expr></argument>, <argument><expr><name>Z_NULL</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name>-&gt;<name>msg</name></name> = <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name>-&gt;<name>transparent</name></name> = 0</expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name>-&gt;<name>path</name></name> = (<name>char</name>*)<call><name>ALLOC</name><argument_list>(<argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call>+1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>s</name>-&gt;<name>path</name></name> == <name>NULL</name></expr>)</condition><then> <block>{
<return>return <expr><call><name>destroy</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>, <expr>(<name>gzFile</name>)<name>Z_NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name><name>s</name>-&gt;<name>path</name></name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name>-&gt;<name>mode</name></name> = '\0'</expr>;</expr_stmt>
<do>do <block>{
<if>if <condition>(<expr>*<name>p</name> == 'r'</expr>)</condition><then> <expr_stmt><expr><name><name>s</name>-&gt;<name>mode</name></name> = 'r'</expr>;</expr_stmt></then></if>
<if>if <condition>(<expr>*<name>p</name> == 'w' || *<name>p</name> == 'a'</expr>)</condition><then> <expr_stmt><expr><name><name>s</name>-&gt;<name>mode</name></name> = 'w'</expr>;</expr_stmt></then></if>
<if>if <condition>(<expr>*<name>p</name> &gt;= '0' &amp;&amp; *<name>p</name> &lt;= '9'</expr>)</condition><then> <block>{
<expr_stmt><expr><name>level</name> = *<name>p</name> - '0'</expr>;</expr_stmt>
}</block></then> <else>else <if>if <condition>(<expr>*<name>p</name> == 'f'</expr>)</condition><then> <block>{
<expr_stmt><expr><name>strategy</name> = <name>Z_FILTERED</name></expr>;</expr_stmt>
}</block></then> <else>else <if>if <condition>(<expr>*<name>p</name> == 'h'</expr>)</condition><then> <block>{
<expr_stmt><expr><name>strategy</name> = <name>Z_HUFFMAN_ONLY</name></expr>;</expr_stmt>
}</block></then> <else>else <if>if <condition>(<expr>*<name>p</name> == 'R'</expr>)</condition><then> <block>{
<expr_stmt><expr><name>strategy</name> = <name>Z_RLE</name></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr>*<name>m</name>++ = *<name>p</name></expr>;</expr_stmt>
}</block></else></if></else></if></else></if></else></if>
}</block> while <condition>(<expr>*<name>p</name>++ &amp;&amp; <name>m</name> != <name>fmode</name> + <sizeof>sizeof<argument_list>(<argument><expr><name>fmode</name></expr></argument>)</argument_list></sizeof></expr>)</condition>;</do>
<if>if <condition>(<expr><name><name>s</name>-&gt;<name>mode</name></name> == '\0'</expr>)</condition><then> <return>return <expr><call><name>destroy</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>, <expr>(<name>gzFile</name>)<name>Z_NULL</name></expr>;</return></then></if>
<if>if <condition>(<expr><name><name>s</name>-&gt;<name>mode</name></name> == 'w'</expr>)</condition><then> <block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>NO_GZCOMPRESS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><name>err</name> = <name>Z_STREAM_ERROR</name></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<expr_stmt><expr><name>err</name> = <call><name>deflateInit2</name><argument_list>(<argument><expr>&amp;(<name><name>s</name>-&gt;<name>stream</name></name>)</expr></argument>, <argument><expr><name>level</name></expr></argument>,
<argument><expr><name>Z_DEFLATED</name></expr></argument>, <argument><expr>-<name>MAX_WBITS</name></expr></argument>, <argument><expr><name>DEF_MEM_LEVEL</name></expr></argument>, <argument><expr><name>strategy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name>-&gt;<name>stream</name>.<name>next_out</name></name> = <name><name>s</name>-&gt;<name>outbuf</name></name> = (<name>Byte</name>*)<call><name>ALLOC</name><argument_list>(<argument><expr><name>Z_BUFSIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<if>if <condition>(<expr><name>err</name> != <name>Z_OK</name> || <name><name>s</name>-&gt;<name>outbuf</name></name> == <name>Z_NULL</name></expr>)</condition><then> <block>{
<return>return <expr><call><name>destroy</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>, <expr>(<name>gzFile</name>)<name>Z_NULL</name></expr>;</return>
}</block></then></if>
}</block></then> <else>else <block>{
<expr_stmt><expr><name><name>s</name>-&gt;<name>stream</name>.<name>next_in</name></name> = <name><name>s</name>-&gt;<name>inbuf</name></name> = (<name>Byte</name>*)<call><name>ALLOC</name><argument_list>(<argument><expr><name>Z_BUFSIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>err</name> = <call><name>inflateInit2</name><argument_list>(<argument><expr>&amp;(<name><name>s</name>-&gt;<name>stream</name></name>)</expr></argument>, <argument><expr>-<name>MAX_WBITS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>err</name> != <name>Z_OK</name> || <name><name>s</name>-&gt;<name>inbuf</name></name> == <name>Z_NULL</name></expr>)</condition><then> <block>{
<return>return <expr><call><name>destroy</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>, <expr>(<name>gzFile</name>)<name>Z_NULL</name></expr>;</return>
}</block></then></if>
}</block></else></if>
<expr_stmt><expr><name><name>s</name>-&gt;<name>stream</name>.<name>avail_out</name></name> = <name>Z_BUFSIZE</name></expr>;</expr_stmt>
<expr_stmt><expr><name>errno</name> = 0</expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name>-&gt;<name>file</name></name> = <name>fd</name> &lt; 0 ? <call><name>F_OPEN</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>fmode</name></expr></argument>)</argument_list></call> : (<name>FILE</name>*)<call><name>fdopen</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>fmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>s</name>-&gt;<name>file</name></name> == <name>NULL</name></expr>)</condition><then> <block>{
<return>return <expr><call><name>destroy</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>, <expr>(<name>gzFile</name>)<name>Z_NULL</name></expr>;</return>
}</block></then></if>
<if>if <condition>(<expr><name><name>s</name>-&gt;<name>mode</name></name> == 'w'</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name><name>s</name>-&gt;<name>file</name></name></expr></argument>, <argument><expr>"%c%c%c%c%c%c%c%c%c%c"</expr></argument>, <argument><expr><name><name>gz_magic</name><index>[<expr>0</expr>]</index></name></expr></argument>, <argument><expr><name><name>gz_magic</name><index>[<expr>1</expr>]</index></name></expr></argument>,
<argument><expr><name>Z_DEFLATED</name></expr></argument>, <argument><expr>0</expr></argument> , <argument><expr>0</expr></argument>,<argument><expr>0</expr></argument>,<argument><expr>0</expr></argument>,<argument><expr>0</expr></argument> , <argument><expr>0</expr></argument> , <argument><expr><name>OS_CODE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name>-&gt;<name>start</name></name> = 10L</expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr><call><name>check_header</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name>-&gt;<name>start</name></name> = <call><name>ftell</name><argument_list>(<argument><expr><name><name>s</name>-&gt;<name>file</name></name></expr></argument>)</argument_list></call> - <name><name>s</name>-&gt;<name>stream</name>.<name>avail_in</name></name></expr>;</expr_stmt>
}</block></else></if>
<return>return <expr>(<name>gzFile</name>)<name>s</name></expr>;</return>
}</block></function>
<function><type><name>gzFile</name> <name>ZEXPORT</name></type> <name>gzopen</name> <parameter_list>(<param><decl><type><name>path</name></type></decl></param>, <param><decl><type><name>mode</name></type></decl></param>)</parameter_list>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>mode</name></decl>;</decl_stmt>
<block>{
<return>return <expr><call><name>gz_open</name> <argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>mode</name></expr></argument>, <argument><expr>-1</expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><name>gzFile</name> <name>ZEXPORT</name></type> <name>gzdopen</name> <parameter_list>(<param><decl><type><name>fd</name></type></decl></param>, <param><decl><type><name>mode</name></type></decl></param>)</parameter_list>
<decl_stmt><decl><type><name>int</name></type> <name>fd</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>mode</name></decl>;</decl_stmt>
<block>{
<decl_stmt><decl><type><name>char</name></type> <name><name>name</name><index>[<expr>46</expr>]</index></name></decl>;</decl_stmt>
<if>if <condition>(<expr><name>fd</name> &lt; 0</expr>)</condition><then> <return>return <expr>(<name>gzFile</name>)<name>Z_NULL</name></expr>;</return></then></if>
<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr>"&lt;fd:%d&gt;"</expr></argument>, <argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>gz_open</name> <argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>mode</name></expr></argument>, <argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><name>int</name> <name>ZEXPORT</name></type> <name>gzsetparams</name> <parameter_list>(<param><decl><type><name>file</name></type></decl></param>, <param><decl><type><name>level</name></type></decl></param>, <param><decl><type><name>strategy</name></type></decl></param>)</parameter_list>
<decl_stmt><decl><type><name>gzFile</name></type> <name>file</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>level</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>strategy</name></decl>;</decl_stmt>
<block>{
<decl_stmt><decl><type><name>gz_stream</name> *</type><name>s</name> <init>= <expr>(<name>gz_stream</name>*)<name>file</name></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>s</name> == <name>NULL</name> || <name><name>s</name>-&gt;<name>mode</name></name> != 'w'</expr>)</condition><then> <return>return <expr><name>Z_STREAM_ERROR</name></expr>;</return></then></if>
<if>if <condition>(<expr><name><name>s</name>-&gt;<name>stream</name>.<name>avail_out</name></name> == 0</expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>s</name>-&gt;<name>stream</name>.<name>next_out</name></name> = <name><name>s</name>-&gt;<name>outbuf</name></name></expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>fwrite</name><argument_list>(<argument><expr><name><name>s</name>-&gt;<name>outbuf</name></name></expr></argument>, <argument><expr>1</expr></argument>, <argument><expr><name>Z_BUFSIZE</name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>file</name></name></expr></argument>)</argument_list></call> != <name>Z_BUFSIZE</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>s</name>-&gt;<name>z_err</name></name> = <name>Z_ERRNO</name></expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><name><name>s</name>-&gt;<name>stream</name>.<name>avail_out</name></name> = <name>Z_BUFSIZE</name></expr>;</expr_stmt>
}</block></then></if>
<return>return <expr><call><name>deflateParams</name> <argument_list>(<argument><expr>&amp;(<name><name>s</name>-&gt;<name>stream</name></name>)</expr></argument>, <argument><expr><name>level</name></expr></argument>, <argument><expr><name>strategy</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><name>local</name> <name>int</name></type> <name>get_byte</name><parameter_list>(<param><decl><type><name>s</name></type></decl></param>)</parameter_list>
<decl_stmt><decl><type><name>gz_stream</name> *</type><name>s</name></decl>;</decl_stmt>
<block>{
<if>if <condition>(<expr><name><name>s</name>-&gt;<name>z_eof</name></name></expr>)</condition><then> <return>return <expr><name>EOF</name></expr>;</return></then></if>
<if>if <condition>(<expr><name><name>s</name>-&gt;<name>stream</name>.<name>avail_in</name></name> == 0</expr>)</condition><then> <block>{
<expr_stmt><expr><name>errno</name> = 0</expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name>-&gt;<name>stream</name>.<name>avail_in</name></name> = (<name>uInt</name>)<call><name>fread</name><argument_list>(<argument><expr><name><name>s</name>-&gt;<name>inbuf</name></name></expr></argument>, <argument><expr>1</expr></argument>, <argument><expr><name>Z_BUFSIZE</name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>file</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>s</name>-&gt;<name>stream</name>.<name>avail_in</name></name> == 0</expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>s</name>-&gt;<name>z_eof</name></name> = 1</expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>ferror</name><argument_list>(<argument><expr><name><name>s</name>-&gt;<name>file</name></name></expr></argument>)</argument_list></call></expr>)</condition><then> <expr_stmt><expr><name><name>s</name>-&gt;<name>z_err</name></name> = <name>Z_ERRNO</name></expr>;</expr_stmt></then></if>
<return>return <expr><name>EOF</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name><name>s</name>-&gt;<name>stream</name>.<name>next_in</name></name> = <name><name>s</name>-&gt;<name>inbuf</name></name></expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><name><name>s</name>-&gt;<name>stream</name>.<name>avail_in</name></name>--</expr>;</expr_stmt>
<return>return <expr>*(<name><name>s</name>-&gt;<name>stream</name>.<name>next_in</name></name>)++</expr>;</return>
}</block></function>
<function><type><name>local</name> <name>void</name></type> <name>check_header</name><parameter_list>(<param><decl><type><name>s</name></type></decl></param>)</parameter_list>
<decl_stmt><decl><type><name>gz_stream</name> *</type><name>s</name></decl>;</decl_stmt>
<block>{
<decl_stmt><decl><type><name>int</name></type> <name>method</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>flags</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uInt</name></type> <name>len</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>c</name></decl>;</decl_stmt>
<expr_stmt><expr><name>len</name> = <name><name>s</name>-&gt;<name>stream</name>.<name>avail_in</name></name></expr>;</expr_stmt>
<if>if <condition>(<expr><name>len</name> &lt; 2</expr>)</condition><then> <block>{
<if>if <condition>(<expr><name>len</name></expr>)</condition><then> <expr_stmt><expr><name><name>s</name>-&gt;<name>inbuf</name><index>[<expr>0</expr>]</index></name> = <name><name>s</name>-&gt;<name>stream</name>.<name>next_in</name><index>[<expr>0</expr>]</index></name></expr>;</expr_stmt></then></if>
<expr_stmt><expr><name>errno</name> = 0</expr>;</expr_stmt>
<expr_stmt><expr><name>len</name> = (<name>uInt</name>)<call><name>fread</name><argument_list>(<argument><expr><name><name>s</name>-&gt;<name>inbuf</name></name> + <name>len</name></expr></argument>, <argument><expr>1</expr></argument>, <argument><expr><name>Z_BUFSIZE</name> &gt;&gt; <name>len</name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>file</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>len</name> == 0 &amp;&amp; <call><name>ferror</name><argument_list>(<argument><expr><name><name>s</name>-&gt;<name>file</name></name></expr></argument>)</argument_list></call></expr>)</condition><then> <expr_stmt><expr><name><name>s</name>-&gt;<name>z_err</name></name> = <name>Z_ERRNO</name></expr>;</expr_stmt></then></if>
<expr_stmt><expr><name><name>s</name>-&gt;<name>stream</name>.<name>avail_in</name></name> += <name>len</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name>-&gt;<name>stream</name>.<name>next_in</name></name> = <name><name>s</name>-&gt;<name>inbuf</name></name></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>s</name>-&gt;<name>stream</name>.<name>avail_in</name></name> &lt; 2</expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>s</name>-&gt;<name>transparent</name></name> = <name><name>s</name>-&gt;<name>stream</name>.<name>avail_in</name></name></expr>;</expr_stmt>
<return>return;</return>
}</block></then></if>
}</block></then></if>
<if>if <condition>(<expr><name><name>s</name>-&gt;<name>stream</name>.<name>next_in</name><index>[<expr>0</expr>]</index></name> != <name><name>gz_magic</name><index>[<expr>0</expr>]</index></name> ||
<name><name>s</name>-&gt;<name>stream</name>.<name>next_in</name><index>[<expr>1</expr>]</index></name> != <name><name>gz_magic</name><index>[<expr>1</expr>]</index></name></expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>s</name>-&gt;<name>transparent</name></name> = 1</expr>;</expr_stmt>
<return>return;</return>
}</block></then></if>
<expr_stmt><expr><name><name>s</name>-&gt;<name>stream</name>.<name>avail_in</name></name> -= 2</expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name>-&gt;<name>stream</name>.<name>next_in</name></name> += 2</expr>;</expr_stmt>
<expr_stmt><expr><name>method</name> = <call><name>get_byte</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>flags</name> = <call><name>get_byte</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>method</name> != <name>Z_DEFLATED</name> || (<name>flags</name> &amp; <name>RESERVED</name>) != 0</expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>s</name>-&gt;<name>z_err</name></name> = <name>Z_DATA_ERROR</name></expr>;</expr_stmt>
<return>return;</return>
}</block></then></if>
<for>for (<init><expr><name>len</name> = 0</expr>;</init> <condition><expr><name>len</name> &lt; 6</expr>;</condition> <incr><expr><name>len</name>++</expr></incr>) <expr_stmt><expr>(<name>void</name>)<call><name>get_byte</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></for>
<if>if <condition>(<expr>(<name>flags</name> &amp; <name>EXTRA_FIELD</name>) != 0</expr>)</condition><then> <block>{
<expr_stmt><expr><name>len</name> = (<name>uInt</name>)<call><name>get_byte</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>len</name> += ((<name>uInt</name>)<call><name>get_byte</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call>)&lt;&lt;8</expr>;</expr_stmt>
<while>while <condition>(<expr><name>len</name>-- != 0 &amp;&amp; <call><name>get_byte</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call> != <name>EOF</name></expr>)</condition> <empty_stmt>;</empty_stmt></while>
}</block></then></if>
<if>if <condition>(<expr>(<name>flags</name> &amp; <name>ORIG_NAME</name>) != 0</expr>)</condition><then> <block>{
<while>while <condition>(<expr>(<name>c</name> = <call><name>get_byte</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call>) != 0 &amp;&amp; <name>c</name> != <name>EOF</name></expr>)</condition> <empty_stmt>;</empty_stmt></while>
}</block></then></if>
<if>if <condition>(<expr>(<name>flags</name> &amp; <name>COMMENT</name>) != 0</expr>)</condition><then> <block>{
<while>while <condition>(<expr>(<name>c</name> = <call><name>get_byte</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call>) != 0 &amp;&amp; <name>c</name> != <name>EOF</name></expr>)</condition> <empty_stmt>;</empty_stmt></while>
}</block></then></if>
<if>if <condition>(<expr>(<name>flags</name> &amp; <name>HEAD_CRC</name>) != 0</expr>)</condition><then> <block>{
<for>for (<init><expr><name>len</name> = 0</expr>;</init> <condition><expr><name>len</name> &lt; 2</expr>;</condition> <incr><expr><name>len</name>++</expr></incr>) <expr_stmt><expr>(<name>void</name>)<call><name>get_byte</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></for>
}</block></then></if>
<expr_stmt><expr><name><name>s</name>-&gt;<name>z_err</name></name> = <name><name>s</name>-&gt;<name>z_eof</name></name> ? <name>Z_DATA_ERROR</name> : <name>Z_OK</name></expr>;</expr_stmt>
}</block></function>
<function><type><name>local</name> <name>int</name></type> <name>destroy</name> <parameter_list>(<param><decl><type><name>s</name></type></decl></param>)</parameter_list>
<decl_stmt><decl><type><name>gz_stream</name> *</type><name>s</name></decl>;</decl_stmt>
<block>{
<decl_stmt><decl><type><name>int</name></type> <name>err</name> <init>= <expr><name>Z_OK</name></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr>!<name>s</name></expr>)</condition><then> <return>return <expr><name>Z_STREAM_ERROR</name></expr>;</return></then></if>
<expr_stmt><expr><call><name>TRYFREE</name><argument_list>(<argument><expr><name><name>s</name>-&gt;<name>msg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>s</name>-&gt;<name>stream</name>.<name>state</name></name> != <name>NULL</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr><name><name>s</name>-&gt;<name>mode</name></name> == 'w'</expr>)</condition><then> <block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>NO_GZCOMPRESS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><name>err</name> = <name>Z_STREAM_ERROR</name></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<expr_stmt><expr><name>err</name> = <call><name>deflateEnd</name><argument_list>(<argument><expr>&amp;(<name><name>s</name>-&gt;<name>stream</name></name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></then> <else>else <if>if <condition>(<expr><name><name>s</name>-&gt;<name>mode</name></name> == 'r'</expr>)</condition><then> <block>{
<expr_stmt><expr><name>err</name> = <call><name>inflateEnd</name><argument_list>(<argument><expr>&amp;(<name><name>s</name>-&gt;<name>stream</name></name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if></else></if>
}</block></then></if>
<if>if <condition>(<expr><name><name>s</name>-&gt;<name>file</name></name> != <name>NULL</name> &amp;&amp; <call><name>fclose</name><argument_list>(<argument><expr><name><name>s</name>-&gt;<name>file</name></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>ESPIPE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if>if <condition>(<expr><name>errno</name> != <name>ESPIPE</name></expr>)</condition><then>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><name>err</name> = <name>Z_ERRNO</name></expr>;</expr_stmt></then></if>
}</block></then></if>
<if>if <condition>(<expr><name><name>s</name>-&gt;<name>z_err</name></name> &lt; 0</expr>)</condition><then> <expr_stmt><expr><name>err</name> = <name><name>s</name>-&gt;<name>z_err</name></name></expr>;</expr_stmt></then></if>
<expr_stmt><expr><call><name>TRYFREE</name><argument_list>(<argument><expr><name><name>s</name>-&gt;<name>inbuf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>TRYFREE</name><argument_list>(<argument><expr><name><name>s</name>-&gt;<name>outbuf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>TRYFREE</name><argument_list>(<argument><expr><name><name>s</name>-&gt;<name>path</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>TRYFREE</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>err</name></expr>;</return>
}</block></function>
<function><type><name>int</name> <name>ZEXPORT</name></type> <name>gzread</name> <parameter_list>(<param><decl><type><name>file</name></type></decl></param>, <param><decl><type><name>buf</name></type></decl></param>, <param><decl><type><name>len</name></type></decl></param>)</parameter_list>
<decl_stmt><decl><type><name>gzFile</name></type> <name>file</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>voidp</name></type> <name>buf</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name></type> <name>len</name></decl>;</decl_stmt>
<block>{
<decl_stmt><decl><type><name>gz_stream</name> *</type><name>s</name> <init>= <expr>(<name>gz_stream</name>*)<name>file</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Bytef</name> *</type><name>start</name> <init>= <expr>(<name>Bytef</name>*)<name>buf</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Byte</name> *</type><name>next_out</name></decl>;</decl_stmt>
<if>if <condition>(<expr><name>s</name> == <name>NULL</name> || <name><name>s</name>-&gt;<name>mode</name></name> != 'r'</expr>)</condition><then> <return>return <expr><name>Z_STREAM_ERROR</name></expr>;</return></then></if>
<if>if <condition>(<expr><name><name>s</name>-&gt;<name>z_err</name></name> == <name>Z_DATA_ERROR</name> || <name><name>s</name>-&gt;<name>z_err</name></name> == <name>Z_ERRNO</name></expr>)</condition><then> <return>return <expr>-1</expr>;</return></then></if>
<if>if <condition>(<expr><name><name>s</name>-&gt;<name>z_err</name></name> == <name>Z_STREAM_END</name></expr>)</condition><then> <return>return <expr>0</expr>;</return></then></if>
<expr_stmt><expr><name>next_out</name> = (<name>Byte</name>*)<name>buf</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name>-&gt;<name>stream</name>.<name>next_out</name></name> = (<name>Bytef</name>*)<name>buf</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name>-&gt;<name>stream</name>.<name>avail_out</name></name> = <name>len</name></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>s</name>-&gt;<name>stream</name>.<name>avail_out</name></name> &amp;&amp; <name><name>s</name>-&gt;<name>back</name></name> != <name>EOF</name></expr>)</condition><then> <block>{
<expr_stmt><expr>*<name>next_out</name>++ = <name><name>s</name>-&gt;<name>back</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name>-&gt;<name>stream</name>.<name>next_out</name></name>++</expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name>-&gt;<name>stream</name>.<name>avail_out</name></name>--</expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name>-&gt;<name>back</name></name> = <name>EOF</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name>-&gt;<name>out</name></name>++</expr>;</expr_stmt>
<expr_stmt><expr><name>start</name>++</expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>s</name>-&gt;<name>last</name></name></expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>s</name>-&gt;<name>z_err</name></name> = <name>Z_STREAM_END</name></expr>;</expr_stmt>
<return>return <expr>1</expr>;</return>
}</block></then></if>
}</block></then></if>
<while>while <condition>(<expr><name><name>s</name>-&gt;<name>stream</name>.<name>avail_out</name></name> != 0</expr>)</condition> <block>{
<if>if <condition>(<expr><name><name>s</name>-&gt;<name>transparent</name></name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>uInt</name></type> <name>n</name> <init>= <expr><name><name>s</name>-&gt;<name>stream</name>.<name>avail_in</name></name></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>n</name> &gt; <name><name>s</name>-&gt;<name>stream</name>.<name>avail_out</name></name></expr>)</condition><then> <expr_stmt><expr><name>n</name> = <name><name>s</name>-&gt;<name>stream</name>.<name>avail_out</name></name></expr>;</expr_stmt></then></if>
<if>if <condition>(<expr><name>n</name> &gt; 0</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>zmemcpy</name><argument_list>(<argument><expr><name><name>s</name>-&gt;<name>stream</name>.<name>next_out</name></name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>stream</name>.<name>next_in</name></name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>next_out</name> += <name>n</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name>-&gt;<name>stream</name>.<name>next_out</name></name> = <name>next_out</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name>-&gt;<name>stream</name>.<name>next_in</name></name> += <name>n</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name>-&gt;<name>stream</name>.<name>avail_out</name></name> -= <name>n</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name>-&gt;<name>stream</name>.<name>avail_in</name></name> -= <name>n</name></expr>;</expr_stmt>
}</block></then></if>
<if>if <condition>(<expr><name><name>s</name>-&gt;<name>stream</name>.<name>avail_out</name></name> &gt; 0</expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>s</name>-&gt;<name>stream</name>.<name>avail_out</name></name> -=
(<name>uInt</name>)<call><name>fread</name><argument_list>(<argument><expr><name>next_out</name></expr></argument>, <argument><expr>1</expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>stream</name>.<name>avail_out</name></name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>file</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><name>len</name> -= <name><name>s</name>-&gt;<name>stream</name>.<name>avail_out</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name>-&gt;<name>in</name></name> += <name>len</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name>-&gt;<name>out</name></name> += <name>len</name></expr>;</expr_stmt>
<if>if <condition>(<expr><name>len</name> == 0</expr>)</condition><then> <expr_stmt><expr><name><name>s</name>-&gt;<name>z_eof</name></name> = 1</expr>;</expr_stmt></then></if>
<return>return <expr>(<name>int</name>)<name>len</name></expr>;</return>
}</block></then></if>
<if>if <condition>(<expr><name><name>s</name>-&gt;<name>stream</name>.<name>avail_in</name></name> == 0 &amp;&amp; !<name><name>s</name>-&gt;<name>z_eof</name></name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>errno</name> = 0</expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name>-&gt;<name>stream</name>.<name>avail_in</name></name> = (<name>uInt</name>)<call><name>fread</name><argument_list>(<argument><expr><name><name>s</name>-&gt;<name>inbuf</name></name></expr></argument>, <argument><expr>1</expr></argument>, <argument><expr><name>Z_BUFSIZE</name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>file</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>s</name>-&gt;<name>stream</name>.<name>avail_in</name></name> == 0</expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>s</name>-&gt;<name>z_eof</name></name> = 1</expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>ferror</name><argument_list>(<argument><expr><name><name>s</name>-&gt;<name>file</name></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>s</name>-&gt;<name>z_err</name></name> = <name>Z_ERRNO</name></expr>;</expr_stmt>
<break>break;</break>
}</block></then></if>
}</block></then></if>
<expr_stmt><expr><name><name>s</name>-&gt;<name>stream</name>.<name>next_in</name></name> = <name><name>s</name>-&gt;<name>inbuf</name></name></expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><name><name>s</name>-&gt;<name>in</name></name> += <name><name>s</name>-&gt;<name>stream</name>.<name>avail_in</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name>-&gt;<name>out</name></name> += <name><name>s</name>-&gt;<name>stream</name>.<name>avail_out</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name>-&gt;<name>z_err</name></name> = <call><name>inflate</name><argument_list>(<argument><expr>&amp;(<name><name>s</name>-&gt;<name>stream</name></name>)</expr></argument>, <argument><expr><name>Z_NO_FLUSH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name>-&gt;<name>in</name></name> -= <name><name>s</name>-&gt;<name>stream</name>.<name>avail_in</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name>-&gt;<name>out</name></name> -= <name><name>s</name>-&gt;<name>stream</name>.<name>avail_out</name></name></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>s</name>-&gt;<name>z_err</name></name> == <name>Z_STREAM_END</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>s</name>-&gt;<name>crc</name></name> = <call><name>crc32</name><argument_list>(<argument><expr><name><name>s</name>-&gt;<name>crc</name></name></expr></argument>, <argument><expr><name>start</name></expr></argument>, <argument><expr><call>(<name>uInt</name>)<argument_list>(<argument><expr><name><name>s</name>-&gt;<name>stream</name>.<name>next_out</name></name> - <name>start</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>start</name> = <name><name>s</name>-&gt;<name>stream</name>.<name>next_out</name></name></expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>getLong</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call> != <name><name>s</name>-&gt;<name>crc</name></name></expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>s</name>-&gt;<name>z_err</name></name> = <name>Z_DATA_ERROR</name></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr>(<name>void</name>)<call><name>getLong</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>check_header</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>s</name>-&gt;<name>z_err</name></name> == <name>Z_OK</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>inflateReset</name><argument_list>(<argument><expr>&amp;(<name><name>s</name>-&gt;<name>stream</name></name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name>-&gt;<name>crc</name></name> = <call><name>crc32</name><argument_list>(<argument><expr>0L</expr></argument>, <argument><expr><name>Z_NULL</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
}</block></else></if>
}</block></then></if>
<if>if <condition>(<expr><name><name>s</name>-&gt;<name>z_err</name></name> != <name>Z_OK</name> || <name><name>s</name>-&gt;<name>z_eof</name></name></expr>)</condition><then> <break>break;</break></then></if>
}</block></while>
<expr_stmt><expr><name><name>s</name>-&gt;<name>crc</name></name> = <call><name>crc32</name><argument_list>(<argument><expr><name><name>s</name>-&gt;<name>crc</name></name></expr></argument>, <argument><expr><name>start</name></expr></argument>, <argument><expr><call>(<name>uInt</name>)<argument_list>(<argument><expr><name><name>s</name>-&gt;<name>stream</name>.<name>next_out</name></name> - <name>start</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>len</name> == <name><name>s</name>-&gt;<name>stream</name>.<name>avail_out</name></name> &amp;&amp;
(<name><name>s</name>-&gt;<name>z_err</name></name> == <name>Z_DATA_ERROR</name> || <name><name>s</name>-&gt;<name>z_err</name></name> == <name>Z_ERRNO</name>)</expr>)</condition><then>
<return>return <expr>-1</expr>;</return></then></if>
<return>return <expr><call>(<name>int</name>)<argument_list>(<argument><expr><name>len</name> - <name><name>s</name>-&gt;<name>stream</name>.<name>avail_out</name></name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><name>int</name> <name>ZEXPORT</name></type> <name>gzgetc</name><parameter_list>(<param><decl><type><name>file</name></type></decl></param>)</parameter_list>
<decl_stmt><decl><type><name>gzFile</name></type> <name>file</name></decl>;</decl_stmt>
<block>{
<decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name>c</name></decl>;</decl_stmt>
<return>return <expr><call><name>gzread</name><argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr>&amp;<name>c</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call> == 1 ? <name>c</name> : -1</expr>;</return>
}</block></function>
<function><type><name>int</name> <name>ZEXPORT</name></type> <name>gzungetc</name><parameter_list>(<param><decl><type><name>c</name></type></decl></param>, <param><decl><type><name>file</name></type></decl></param>)</parameter_list>
<decl_stmt><decl><type><name>int</name></type> <name>c</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>gzFile</name></type> <name>file</name></decl>;</decl_stmt>
<block>{
<decl_stmt><decl><type><name>gz_stream</name> *</type><name>s</name> <init>= <expr>(<name>gz_stream</name>*)<name>file</name></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>s</name> == <name>NULL</name> || <name><name>s</name>-&gt;<name>mode</name></name> != 'r' || <name>c</name> == <name>EOF</name> || <name><name>s</name>-&gt;<name>back</name></name> != <name>EOF</name></expr>)</condition><then> <return>return <expr><name>EOF</name></expr>;</return></then></if>
<expr_stmt><expr><name><name>s</name>-&gt;<name>back</name></name> = <name>c</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name>-&gt;<name>out</name></name>--</expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name>-&gt;<name>last</name></name> = (<name><name>s</name>-&gt;<name>z_err</name></name> == <name>Z_STREAM_END</name>)</expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>s</name>-&gt;<name>last</name></name></expr>)</condition><then> <expr_stmt><expr><name><name>s</name>-&gt;<name>z_err</name></name> = <name>Z_OK</name></expr>;</expr_stmt></then></if>
<expr_stmt><expr><name><name>s</name>-&gt;<name>z_eof</name></name> = 0</expr>;</expr_stmt>
<return>return <expr><name>c</name></expr>;</return>
}</block></function>
<function><type><name>char</name> * <name>ZEXPORT</name></type> <name>gzgets</name><parameter_list>(<param><decl><type><name>file</name></type></decl></param>, <param><decl><type><name>buf</name></type></decl></param>, <param><decl><type><name>len</name></type></decl></param>)</parameter_list>
<decl_stmt><decl><type><name>gzFile</name></type> <name>file</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>buf</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>len</name></decl>;</decl_stmt>
<block>{
<decl_stmt><decl><type><name>char</name> *</type><name>b</name> <init>= <expr><name>buf</name></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>buf</name> == <name>Z_NULL</name> || <name>len</name> &lt;= 0</expr>)</condition><then> <return>return <expr><name>Z_NULL</name></expr>;</return></then></if>
<while>while <condition>(<expr>--<name>len</name> &gt; 0 &amp;&amp; <call><name>gzread</name><argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call> == 1 &amp;&amp; *<name>buf</name>++ != '\n'</expr>)</condition> <empty_stmt>;</empty_stmt></while>
<expr_stmt><expr>*<name>buf</name> = '\0'</expr>;</expr_stmt>
<return>return <expr><name>b</name> == <name>buf</name> &amp;&amp; <name>len</name> &gt; 0 ? <name>Z_NULL</name> : <name>b</name></expr>;</return>
}</block></function>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>NO_GZCOMPRESS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function><type><name>int</name> <name>ZEXPORT</name></type> <name>gzwrite</name> <parameter_list>(<param><decl><type><name>file</name></type></decl></param>, <param><decl><type><name>buf</name></type></decl></param>, <param><decl><type><name>len</name></type></decl></param>)</parameter_list>
<decl_stmt><decl><type><name>gzFile</name></type> <name>file</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>voidpc</name></type> <name>buf</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name></type> <name>len</name></decl>;</decl_stmt>
<block>{
<decl_stmt><decl><type><name>gz_stream</name> *</type><name>s</name> <init>= <expr>(<name>gz_stream</name>*)<name>file</name></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>s</name> == <name>NULL</name> || <name><name>s</name>-&gt;<name>mode</name></name> != 'w'</expr>)</condition><then> <return>return <expr><name>Z_STREAM_ERROR</name></expr>;</return></then></if>
<expr_stmt><expr><name><name>s</name>-&gt;<name>stream</name>.<name>next_in</name></name> = (<name>Bytef</name>*)<name>buf</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name>-&gt;<name>stream</name>.<name>avail_in</name></name> = <name>len</name></expr>;</expr_stmt>
<while>while <condition>(<expr><name><name>s</name>-&gt;<name>stream</name>.<name>avail_in</name></name> != 0</expr>)</condition> <block>{
<if>if <condition>(<expr><name><name>s</name>-&gt;<name>stream</name>.<name>avail_out</name></name> == 0</expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>s</name>-&gt;<name>stream</name>.<name>next_out</name></name> = <name><name>s</name>-&gt;<name>outbuf</name></name></expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>fwrite</name><argument_list>(<argument><expr><name><name>s</name>-&gt;<name>outbuf</name></name></expr></argument>, <argument><expr>1</expr></argument>, <argument><expr><name>Z_BUFSIZE</name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>file</name></name></expr></argument>)</argument_list></call> != <name>Z_BUFSIZE</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>s</name>-&gt;<name>z_err</name></name> = <name>Z_ERRNO</name></expr>;</expr_stmt>
<break>break;</break>
}</block></then></if>
<expr_stmt><expr><name><name>s</name>-&gt;<name>stream</name>.<name>avail_out</name></name> = <name>Z_BUFSIZE</name></expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><name><name>s</name>-&gt;<name>in</name></name> += <name><name>s</name>-&gt;<name>stream</name>.<name>avail_in</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name>-&gt;<name>out</name></name> += <name><name>s</name>-&gt;<name>stream</name>.<name>avail_out</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name>-&gt;<name>z_err</name></name> = <call><name>deflate</name><argument_list>(<argument><expr>&amp;(<name><name>s</name>-&gt;<name>stream</name></name>)</expr></argument>, <argument><expr><name>Z_NO_FLUSH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name>-&gt;<name>in</name></name> -= <name><name>s</name>-&gt;<name>stream</name>.<name>avail_in</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name>-&gt;<name>out</name></name> -= <name><name>s</name>-&gt;<name>stream</name>.<name>avail_out</name></name></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>s</name>-&gt;<name>z_err</name></name> != <name>Z_OK</name></expr>)</condition><then> <break>break;</break></then></if>
}</block></while>
<expr_stmt><expr><name><name>s</name>-&gt;<name>crc</name></name> = <call><name>crc32</name><argument_list>(<argument><expr><name><name>s</name>-&gt;<name>crc</name></name></expr></argument>, <argument><expr>(const <name>Bytef</name> *)<name>buf</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call>(<name>int</name>)<argument_list>(<argument><expr><name>len</name> - <name><name>s</name>-&gt;<name>stream</name>.<name>avail_in</name></name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>STDC</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdarg.h&gt;</cpp:file></cpp:include>
<function><type><name>int</name> <name>ZEXPORTVA</name></type> <name>gzprintf</name> <parameter_list>(<param><decl><type><name>gzFile</name></type> <name>file</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>format</name></decl></param>, <param><decl><type>...</type></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>char</name></type> <name><name>buf</name><index>[<expr><name>Z_PRINTF_BUFSIZE</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>va_list</name></type> <name>va</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>len</name></decl>;</decl_stmt>
<expr_stmt><expr><name><name>buf</name><index>[<expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof> - 1</expr>]</index></name> = 0</expr>;</expr_stmt>
<expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>va</name></expr></argument>, <argument><expr><name>format</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>NO_vsnprintf</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAS_vsprintf_void</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr>(<name>void</name>)<call><name>vsprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>format</name></expr></argument>, <argument><expr><name>va</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>va</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for (<init><expr><name>len</name> = 0</expr>;</init> <condition><expr><name>len</name> &lt; <sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr>;</condition> <incr><expr><name>len</name>++</expr></incr>)
<if>if <condition>(<expr><name><name>buf</name><index>[<expr><name>len</name></expr>]</index></name> == 0</expr>)</condition><then> <break>break;</break></then></if></for>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<expr_stmt><expr><name>len</name> = <call><name>vsprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>format</name></expr></argument>, <argument><expr><name>va</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>va</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAS_vsnprintf_void</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr>(<name>void</name>)<call><name>vsnprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>format</name></expr></argument>, <argument><expr><name>va</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>va</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>len</name> = <call><name>strlen</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<expr_stmt><expr><name>len</name> = <call><name>vsnprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>format</name></expr></argument>, <argument><expr><name>va</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>va</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<if>if <condition>(<expr><name>len</name> &lt;= 0 || <name>len</name> &gt;= (<name>int</name>)<sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof> || <name><name>buf</name><index>[<expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof> - 1</expr>]</index></name> != 0</expr>)</condition><then>
<return>return <expr>0</expr>;</return></then></if>
<return>return <expr><call><name>gzwrite</name><argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr>(<name>unsigned</name>)<name>len</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<function><type><name>int</name> <name>ZEXPORTVA</name></type> <name>gzprintf</name> <parameter_list>(<param><decl><type><name>file</name></type></decl></param>, <param><decl><type><name>format</name></type></decl></param>, <param><decl><type><name>a1</name></type></decl></param>, <param><decl><type><name>a2</name></type></decl></param>, <param><decl><type><name>a3</name></type></decl></param>, <param><decl><type><name>a4</name></type></decl></param>, <param><decl><type><name>a5</name></type></decl></param>, <param><decl><type><name>a6</name></type></decl></param>, <param><decl><type><name>a7</name></type></decl></param>, <param><decl><type><name>a8</name></type></decl></param>, <param><decl><type><name>a9</name></type></decl></param>, <param><decl><type><name>a10</name></type></decl></param>,
<param><decl><type><name>a11</name></type></decl></param>, <param><decl><type><name>a12</name></type></decl></param>, <param><decl><type><name>a13</name></type></decl></param>, <param><decl><type><name>a14</name></type></decl></param>, <param><decl><type><name>a15</name></type></decl></param>, <param><decl><type><name>a16</name></type></decl></param>, <param><decl><type><name>a17</name></type></decl></param>, <param><decl><type><name>a18</name></type></decl></param>, <param><decl><type><name>a19</name></type></decl></param>, <param><decl><type><name>a20</name></type></decl></param>)</parameter_list>
<decl_stmt><decl><type><name>gzFile</name></type> <name>file</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>format</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>a1</name></decl>, <decl><type ref="prev"/><name>a2</name></decl>, <decl><type ref="prev"/><name>a3</name></decl>, <decl><type ref="prev"/><name>a4</name></decl>, <decl><type ref="prev"/><name>a5</name></decl>, <decl><type ref="prev"/><name>a6</name></decl>, <decl><type ref="prev"/><name>a7</name></decl>, <decl><type ref="prev"/><name>a8</name></decl>, <decl><type ref="prev"/><name>a9</name></decl>, <decl><type ref="prev"/><name>a10</name></decl>,
<decl><type ref="prev"/><name>a11</name></decl>, <decl><type ref="prev"/><name>a12</name></decl>, <decl><type ref="prev"/><name>a13</name></decl>, <decl><type ref="prev"/><name>a14</name></decl>, <decl><type ref="prev"/><name>a15</name></decl>, <decl><type ref="prev"/><name>a16</name></decl>, <decl><type ref="prev"/><name>a17</name></decl>, <decl><type ref="prev"/><name>a18</name></decl>, <decl><type ref="prev"/><name>a19</name></decl>, <decl><type ref="prev"/><name>a20</name></decl>;</decl_stmt>
<block>{
<decl_stmt><decl><type><name>char</name></type> <name><name>buf</name><index>[<expr><name>Z_PRINTF_BUFSIZE</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>len</name></decl>;</decl_stmt>
<expr_stmt><expr><name><name>buf</name><index>[<expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof> - 1</expr>]</index></name> = 0</expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>NO_snprintf</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAS_sprintf_void</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>format</name></expr></argument>, <argument><expr><name>a1</name></expr></argument>, <argument><expr><name>a2</name></expr></argument>, <argument><expr><name>a3</name></expr></argument>, <argument><expr><name>a4</name></expr></argument>, <argument><expr><name>a5</name></expr></argument>, <argument><expr><name>a6</name></expr></argument>, <argument><expr><name>a7</name></expr></argument>, <argument><expr><name>a8</name></expr></argument>,
<argument><expr><name>a9</name></expr></argument>, <argument><expr><name>a10</name></expr></argument>, <argument><expr><name>a11</name></expr></argument>, <argument><expr><name>a12</name></expr></argument>, <argument><expr><name>a13</name></expr></argument>, <argument><expr><name>a14</name></expr></argument>, <argument><expr><name>a15</name></expr></argument>, <argument><expr><name>a16</name></expr></argument>, <argument><expr><name>a17</name></expr></argument>, <argument><expr><name>a18</name></expr></argument>, <argument><expr><name>a19</name></expr></argument>, <argument><expr><name>a20</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for (<init><expr><name>len</name> = 0</expr>;</init> <condition><expr><name>len</name> &lt; <sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr>;</condition> <incr><expr><name>len</name>++</expr></incr>)
<if>if <condition>(<expr><name><name>buf</name><index>[<expr><name>len</name></expr>]</index></name> == 0</expr>)</condition><then> <break>break;</break></then></if></for>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<expr_stmt><expr><name>len</name> = <call><name>sprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>format</name></expr></argument>, <argument><expr><name>a1</name></expr></argument>, <argument><expr><name>a2</name></expr></argument>, <argument><expr><name>a3</name></expr></argument>, <argument><expr><name>a4</name></expr></argument>, <argument><expr><name>a5</name></expr></argument>, <argument><expr><name>a6</name></expr></argument>, <argument><expr><name>a7</name></expr></argument>, <argument><expr><name>a8</name></expr></argument>,
<argument><expr><name>a9</name></expr></argument>, <argument><expr><name>a10</name></expr></argument>, <argument><expr><name>a11</name></expr></argument>, <argument><expr><name>a12</name></expr></argument>, <argument><expr><name>a13</name></expr></argument>, <argument><expr><name>a14</name></expr></argument>, <argument><expr><name>a15</name></expr></argument>, <argument><expr><name>a16</name></expr></argument>, <argument><expr><name>a17</name></expr></argument>, <argument><expr><name>a18</name></expr></argument>, <argument><expr><name>a19</name></expr></argument>, <argument><expr><name>a20</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAS_snprintf_void</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>format</name></expr></argument>, <argument><expr><name>a1</name></expr></argument>, <argument><expr><name>a2</name></expr></argument>, <argument><expr><name>a3</name></expr></argument>, <argument><expr><name>a4</name></expr></argument>, <argument><expr><name>a5</name></expr></argument>, <argument><expr><name>a6</name></expr></argument>, <argument><expr><name>a7</name></expr></argument>, <argument><expr><name>a8</name></expr></argument>,
<argument><expr><name>a9</name></expr></argument>, <argument><expr><name>a10</name></expr></argument>, <argument><expr><name>a11</name></expr></argument>, <argument><expr><name>a12</name></expr></argument>, <argument><expr><name>a13</name></expr></argument>, <argument><expr><name>a14</name></expr></argument>, <argument><expr><name>a15</name></expr></argument>, <argument><expr><name>a16</name></expr></argument>, <argument><expr><name>a17</name></expr></argument>, <argument><expr><name>a18</name></expr></argument>, <argument><expr><name>a19</name></expr></argument>, <argument><expr><name>a20</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>len</name> = <call><name>strlen</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<expr_stmt><expr><name>len</name> = <call><name>snprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>format</name></expr></argument>, <argument><expr><name>a1</name></expr></argument>, <argument><expr><name>a2</name></expr></argument>, <argument><expr><name>a3</name></expr></argument>, <argument><expr><name>a4</name></expr></argument>, <argument><expr><name>a5</name></expr></argument>, <argument><expr><name>a6</name></expr></argument>, <argument><expr><name>a7</name></expr></argument>, <argument><expr><name>a8</name></expr></argument>,
<argument><expr><name>a9</name></expr></argument>, <argument><expr><name>a10</name></expr></argument>, <argument><expr><name>a11</name></expr></argument>, <argument><expr><name>a12</name></expr></argument>, <argument><expr><name>a13</name></expr></argument>, <argument><expr><name>a14</name></expr></argument>, <argument><expr><name>a15</name></expr></argument>, <argument><expr><name>a16</name></expr></argument>, <argument><expr><name>a17</name></expr></argument>, <argument><expr><name>a18</name></expr></argument>, <argument><expr><name>a19</name></expr></argument>, <argument><expr><name>a20</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<if>if <condition>(<expr><name>len</name> &lt;= 0 || <name>len</name> &gt;= <sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof> || <name><name>buf</name><index>[<expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof> - 1</expr>]</index></name> != 0</expr>)</condition><then>
<return>return <expr>0</expr>;</return></then></if>
<return>return <expr><call><name>gzwrite</name><argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<function><type><name>int</name> <name>ZEXPORT</name></type> <name>gzputc</name><parameter_list>(<param><decl><type><name>file</name></type></decl></param>, <param><decl><type><name>c</name></type></decl></param>)</parameter_list>
<decl_stmt><decl><type><name>gzFile</name></type> <name>file</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>c</name></decl>;</decl_stmt>
<block>{
<decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name>cc</name> <init>= <expr>(<name>unsigned</name> <name>char</name>) <name>c</name></expr></init></decl>;</decl_stmt>
<return>return <expr><call><name>gzwrite</name><argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr>&amp;<name>cc</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call> == 1 ? (<name>int</name>)<name>cc</name> : -1</expr>;</return>
}</block></function>
<function><type><name>int</name> <name>ZEXPORT</name></type> <name>gzputs</name><parameter_list>(<param><decl><type><name>file</name></type></decl></param>, <param><decl><type><name>s</name></type></decl></param>)</parameter_list>
<decl_stmt><decl><type><name>gzFile</name></type> <name>file</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>s</name></decl>;</decl_stmt>
<block>{
<return>return <expr><call><name>gzwrite</name><argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr>(<name>char</name>*)<name>s</name></expr></argument>, <argument><expr>(<name>unsigned</name>)<call><name>strlen</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><name>local</name> <name>int</name></type> <name>do_flush</name> <parameter_list>(<param><decl><type><name>file</name></type></decl></param>, <param><decl><type><name>flush</name></type></decl></param>)</parameter_list>
<decl_stmt><decl><type><name>gzFile</name></type> <name>file</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>flush</name></decl>;</decl_stmt>
<block>{
<decl_stmt><decl><type><name>uInt</name></type> <name>len</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>done</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>gz_stream</name> *</type><name>s</name> <init>= <expr>(<name>gz_stream</name>*)<name>file</name></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>s</name> == <name>NULL</name> || <name><name>s</name>-&gt;<name>mode</name></name> != 'w'</expr>)</condition><then> <return>return <expr><name>Z_STREAM_ERROR</name></expr>;</return></then></if>
<expr_stmt><expr><name><name>s</name>-&gt;<name>stream</name>.<name>avail_in</name></name> = 0</expr>;</expr_stmt>
<for>for (<init>;</init><condition>;</condition><incr/>) <block>{
<expr_stmt><expr><name>len</name> = <name>Z_BUFSIZE</name> - <name><name>s</name>-&gt;<name>stream</name>.<name>avail_out</name></name></expr>;</expr_stmt>
<if>if <condition>(<expr><name>len</name> != 0</expr>)</condition><then> <block>{
<if>if <condition>(<expr>(<name>uInt</name>)<call><name>fwrite</name><argument_list>(<argument><expr><name><name>s</name>-&gt;<name>outbuf</name></name></expr></argument>, <argument><expr>1</expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>file</name></name></expr></argument>)</argument_list></call> != <name>len</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>s</name>-&gt;<name>z_err</name></name> = <name>Z_ERRNO</name></expr>;</expr_stmt>
<return>return <expr><name>Z_ERRNO</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name><name>s</name>-&gt;<name>stream</name>.<name>next_out</name></name> = <name><name>s</name>-&gt;<name>outbuf</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name>-&gt;<name>stream</name>.<name>avail_out</name></name> = <name>Z_BUFSIZE</name></expr>;</expr_stmt>
}</block></then></if>
<if>if <condition>(<expr><name>done</name></expr>)</condition><then> <break>break;</break></then></if>
<expr_stmt><expr><name><name>s</name>-&gt;<name>out</name></name> += <name><name>s</name>-&gt;<name>stream</name>.<name>avail_out</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name>-&gt;<name>z_err</name></name> = <call><name>deflate</name><argument_list>(<argument><expr>&amp;(<name><name>s</name>-&gt;<name>stream</name></name>)</expr></argument>, <argument><expr><name>flush</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name>-&gt;<name>out</name></name> -= <name><name>s</name>-&gt;<name>stream</name>.<name>avail_out</name></name></expr>;</expr_stmt>
<if>if <condition>(<expr><name>len</name> == 0 &amp;&amp; <name><name>s</name>-&gt;<name>z_err</name></name> == <name>Z_BUF_ERROR</name></expr>)</condition><then> <expr_stmt><expr><name><name>s</name>-&gt;<name>z_err</name></name> = <name>Z_OK</name></expr>;</expr_stmt></then></if>
<expr_stmt><expr><name>done</name> = (<name><name>s</name>-&gt;<name>stream</name>.<name>avail_out</name></name> != 0 || <name><name>s</name>-&gt;<name>z_err</name></name> == <name>Z_STREAM_END</name>)</expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>s</name>-&gt;<name>z_err</name></name> != <name>Z_OK</name> &amp;&amp; <name><name>s</name>-&gt;<name>z_err</name></name> != <name>Z_STREAM_END</name></expr>)</condition><then> <break>break;</break></then></if>
}</block></for>
<return>return <expr><name><name>s</name>-&gt;<name>z_err</name></name> == <name>Z_STREAM_END</name> ? <name>Z_OK</name> : <name><name>s</name>-&gt;<name>z_err</name></name></expr>;</return>
}</block></function>
<function><type><name>int</name> <name>ZEXPORT</name></type> <name>gzflush</name> <parameter_list>(<param><decl><type><name>file</name></type></decl></param>, <param><decl><type><name>flush</name></type></decl></param>)</parameter_list>
<decl_stmt><decl><type><name>gzFile</name></type> <name>file</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>flush</name></decl>;</decl_stmt>
<block>{
<decl_stmt><decl><type><name>gz_stream</name> *</type><name>s</name> <init>= <expr>(<name>gz_stream</name>*)<name>file</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>err</name> <init>= <expr><call><name>do_flush</name> <argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><name>flush</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>err</name></expr>)</condition><then> <return>return <expr><name>err</name></expr>;</return></then></if>
<expr_stmt><expr><call><name>fflush</name><argument_list>(<argument><expr><name><name>s</name>-&gt;<name>file</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name><name>s</name>-&gt;<name>z_err</name></name> == <name>Z_STREAM_END</name> ? <name>Z_OK</name> : <name><name>s</name>-&gt;<name>z_err</name></name></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<function><type><name>z_off_t</name> <name>ZEXPORT</name></type> <name>gzseek</name> <parameter_list>(<param><decl><type><name>file</name></type></decl></param>, <param><decl><type><name>offset</name></type></decl></param>, <param><decl><type><name>whence</name></type></decl></param>)</parameter_list>
<decl_stmt><decl><type><name>gzFile</name></type> <name>file</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>z_off_t</name></type> <name>offset</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>whence</name></decl>;</decl_stmt>
<block>{
<decl_stmt><decl><type><name>gz_stream</name> *</type><name>s</name> <init>= <expr>(<name>gz_stream</name>*)<name>file</name></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>s</name> == <name>NULL</name> || <name>whence</name> == <name>SEEK_END</name> ||
<name><name>s</name>-&gt;<name>z_err</name></name> == <name>Z_ERRNO</name> || <name><name>s</name>-&gt;<name>z_err</name></name> == <name>Z_DATA_ERROR</name></expr>)</condition><then> <block>{
<return>return <expr>-1L</expr>;</return>
}</block></then></if>
<if>if <condition>(<expr><name><name>s</name>-&gt;<name>mode</name></name> == 'w'</expr>)</condition><then> <block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>NO_GZCOMPRESS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<return>return <expr>-1L</expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<if>if <condition>(<expr><name>whence</name> == <name>SEEK_SET</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>offset</name> -= <name><name>s</name>-&gt;<name>in</name></name></expr>;</expr_stmt>
}</block></then></if>
<if>if <condition>(<expr><name>offset</name> &lt; 0</expr>)</condition><then> <return>return <expr>-1L</expr>;</return></then></if>
<if>if <condition>(<expr><name><name>s</name>-&gt;<name>inbuf</name></name> == <name>Z_NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>s</name>-&gt;<name>inbuf</name></name> = (<name>Byte</name>*)<call><name>ALLOC</name><argument_list>(<argument><expr><name>Z_BUFSIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>s</name>-&gt;<name>inbuf</name></name> == <name>Z_NULL</name></expr>)</condition><then> <return>return <expr>-1L</expr>;</return></then></if>
<expr_stmt><expr><call><name>zmemzero</name><argument_list>(<argument><expr><name><name>s</name>-&gt;<name>inbuf</name></name></expr></argument>, <argument><expr><name>Z_BUFSIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<while>while <condition>(<expr><name>offset</name> &gt; 0</expr>)</condition> <block>{
<decl_stmt><decl><type><name>uInt</name></type> <name>size</name> <init>= <expr><name>Z_BUFSIZE</name></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>offset</name> &lt; <name>Z_BUFSIZE</name></expr>)</condition><then> <expr_stmt><expr><name>size</name> = (<name>uInt</name>)<name>offset</name></expr>;</expr_stmt></then></if>
<expr_stmt><expr><name>size</name> = <call><name>gzwrite</name><argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>inbuf</name></name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>size</name> == 0</expr>)</condition><then> <return>return <expr>-1L</expr>;</return></then></if>
<expr_stmt><expr><name>offset</name> -= <name>size</name></expr>;</expr_stmt>
}</block></while>
<return>return <expr><name><name>s</name>-&gt;<name>in</name></name></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></then></if>
<if>if <condition>(<expr><name>whence</name> == <name>SEEK_CUR</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>offset</name> += <name><name>s</name>-&gt;<name>out</name></name></expr>;</expr_stmt>
}</block></then></if>
<if>if <condition>(<expr><name>offset</name> &lt; 0</expr>)</condition><then> <return>return <expr>-1L</expr>;</return></then></if>
<if>if <condition>(<expr><name><name>s</name>-&gt;<name>transparent</name></name></expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>s</name>-&gt;<name>back</name></name> = <name>EOF</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name>-&gt;<name>stream</name>.<name>avail_in</name></name> = 0</expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name>-&gt;<name>stream</name>.<name>next_in</name></name> = <name><name>s</name>-&gt;<name>inbuf</name></name></expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>fseek</name><argument_list>(<argument><expr><name><name>s</name>-&gt;<name>file</name></name></expr></argument>, <argument><expr><name>offset</name></expr></argument>, <argument><expr><name>SEEK_SET</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then> <return>return <expr>-1L</expr>;</return></then></if>
<expr_stmt><expr><name><name>s</name>-&gt;<name>in</name></name> = <name><name>s</name>-&gt;<name>out</name></name> = <name>offset</name></expr>;</expr_stmt>
<return>return <expr><name>offset</name></expr>;</return>
}</block></then></if>
<if>if <condition>(<expr><name>offset</name> &gt;= <name><name>s</name>-&gt;<name>out</name></name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>offset</name> -= <name><name>s</name>-&gt;<name>out</name></name></expr>;</expr_stmt>
}</block></then> <else>else <if>if <condition>(<expr><call><name>gzrewind</name><argument_list>(<argument><expr><name>file</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then> <block>{
<return>return <expr>-1L</expr>;</return>
}</block></then></if></else></if>
<if>if <condition>(<expr><name>offset</name> != 0 &amp;&amp; <name><name>s</name>-&gt;<name>outbuf</name></name> == <name>Z_NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>s</name>-&gt;<name>outbuf</name></name> = (<name>Byte</name>*)<call><name>ALLOC</name><argument_list>(<argument><expr><name>Z_BUFSIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>s</name>-&gt;<name>outbuf</name></name> == <name>Z_NULL</name></expr>)</condition><then> <return>return <expr>-1L</expr>;</return></then></if>
}</block></then></if>
<if>if <condition>(<expr><name>offset</name> &amp;&amp; <name><name>s</name>-&gt;<name>back</name></name> != <name>EOF</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>s</name>-&gt;<name>back</name></name> = <name>EOF</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name>-&gt;<name>out</name></name>++</expr>;</expr_stmt>
<expr_stmt><expr><name>offset</name>--</expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>s</name>-&gt;<name>last</name></name></expr>)</condition><then> <expr_stmt><expr><name><name>s</name>-&gt;<name>z_err</name></name> = <name>Z_STREAM_END</name></expr>;</expr_stmt></then></if>
}</block></then></if>
<while>while <condition>(<expr><name>offset</name> &gt; 0</expr>)</condition> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>size</name> <init>= <expr><name>Z_BUFSIZE</name></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>offset</name> &lt; <name>Z_BUFSIZE</name></expr>)</condition><then> <expr_stmt><expr><name>size</name> = (<name>int</name>)<name>offset</name></expr>;</expr_stmt></then></if>
<expr_stmt><expr><name>size</name> = <call><name>gzread</name><argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>outbuf</name></name></expr></argument>, <argument><expr>(<name>uInt</name>)<name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>size</name> &lt;= 0</expr>)</condition><then> <return>return <expr>-1L</expr>;</return></then></if>
<expr_stmt><expr><name>offset</name> -= <name>size</name></expr>;</expr_stmt>
}</block></while>
<return>return <expr><name><name>s</name>-&gt;<name>out</name></name></expr>;</return>
}</block></function>
<function><type><name>int</name> <name>ZEXPORT</name></type> <name>gzrewind</name> <parameter_list>(<param><decl><type><name>file</name></type></decl></param>)</parameter_list>
<decl_stmt><decl><type><name>gzFile</name></type> <name>file</name></decl>;</decl_stmt>
<block>{
<decl_stmt><decl><type><name>gz_stream</name> *</type><name>s</name> <init>= <expr>(<name>gz_stream</name>*)<name>file</name></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>s</name> == <name>NULL</name> || <name><name>s</name>-&gt;<name>mode</name></name> != 'r'</expr>)</condition><then> <return>return <expr>-1</expr>;</return></then></if>
<expr_stmt><expr><name><name>s</name>-&gt;<name>z_err</name></name> = <name>Z_OK</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name>-&gt;<name>z_eof</name></name> = 0</expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name>-&gt;<name>back</name></name> = <name>EOF</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name>-&gt;<name>stream</name>.<name>avail_in</name></name> = 0</expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name>-&gt;<name>stream</name>.<name>next_in</name></name> = <name><name>s</name>-&gt;<name>inbuf</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name>-&gt;<name>crc</name></name> = <call><name>crc32</name><argument_list>(<argument><expr>0L</expr></argument>, <argument><expr><name>Z_NULL</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name><name>s</name>-&gt;<name>transparent</name></name></expr>)</condition><then> <expr_stmt><expr>(<name>void</name>)<call><name>inflateReset</name><argument_list>(<argument><expr>&amp;<name><name>s</name>-&gt;<name>stream</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<expr_stmt><expr><name><name>s</name>-&gt;<name>in</name></name> = 0</expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name>-&gt;<name>out</name></name> = 0</expr>;</expr_stmt>
<return>return <expr><call><name>fseek</name><argument_list>(<argument><expr><name><name>s</name>-&gt;<name>file</name></name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>start</name></name></expr></argument>, <argument><expr><name>SEEK_SET</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><name>z_off_t</name> <name>ZEXPORT</name></type> <name>gztell</name> <parameter_list>(<param><decl><type><name>file</name></type></decl></param>)</parameter_list>
<decl_stmt><decl><type><name>gzFile</name></type> <name>file</name></decl>;</decl_stmt>
<block>{
<return>return <expr><call><name>gzseek</name><argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr>0L</expr></argument>, <argument><expr><name>SEEK_CUR</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><name>int</name> <name>ZEXPORT</name></type> <name>gzeof</name> <parameter_list>(<param><decl><type><name>file</name></type></decl></param>)</parameter_list>
<decl_stmt><decl><type><name>gzFile</name></type> <name>file</name></decl>;</decl_stmt>
<block>{
<decl_stmt><decl><type><name>gz_stream</name> *</type><name>s</name> <init>= <expr>(<name>gz_stream</name>*)<name>file</name></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>s</name> == <name>NULL</name> || <name><name>s</name>-&gt;<name>mode</name></name> != 'r'</expr>)</condition><then> <return>return <expr>0</expr>;</return></then></if>
<if>if <condition>(<expr><name><name>s</name>-&gt;<name>z_eof</name></name></expr>)</condition><then> <return>return <expr>1</expr>;</return></then></if>
<return>return <expr><name><name>s</name>-&gt;<name>z_err</name></name> == <name>Z_STREAM_END</name></expr>;</return>
}</block></function>
<function><type><name>int</name> <name>ZEXPORT</name></type> <name>gzdirect</name> <parameter_list>(<param><decl><type><name>file</name></type></decl></param>)</parameter_list>
<decl_stmt><decl><type><name>gzFile</name></type> <name>file</name></decl>;</decl_stmt>
<block>{
<decl_stmt><decl><type><name>gz_stream</name> *</type><name>s</name> <init>= <expr>(<name>gz_stream</name>*)<name>file</name></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>s</name> == <name>NULL</name> || <name><name>s</name>-&gt;<name>mode</name></name> != 'r'</expr>)</condition><then> <return>return <expr>0</expr>;</return></then></if>
<return>return <expr><name><name>s</name>-&gt;<name>transparent</name></name></expr>;</return>
}</block></function>
<function><type><name>local</name> <name>void</name></type> <name>putLong</name> <parameter_list>(<param><decl><type><name>file</name></type></decl></param>, <param><decl><type><name>x</name></type></decl></param>)</parameter_list>
<decl_stmt><decl><type><name>FILE</name> *</type><name>file</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uLong</name></type> <name>x</name></decl>;</decl_stmt>
<block>{
<decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>;</decl_stmt>
<for>for (<init><expr><name>n</name> = 0</expr>;</init> <condition><expr><name>n</name> &lt; 4</expr>;</condition> <incr><expr><name>n</name>++</expr></incr>) <block>{
<expr_stmt><expr><call><name>fputc</name><argument_list>(<argument><expr><call>(<name>int</name>)<argument_list>(<argument><expr><name>x</name> &amp; 0xff</expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>x</name> &gt;&gt;= 8</expr>;</expr_stmt>
}</block></for>
}</block></function>
<function><type><name>local</name> <name>uLong</name></type> <name>getLong</name> <parameter_list>(<param><decl><type><name>s</name></type></decl></param>)</parameter_list>
<decl_stmt><decl><type><name>gz_stream</name> *</type><name>s</name></decl>;</decl_stmt>
<block>{
<decl_stmt><decl><type><name>uLong</name></type> <name>x</name> <init>= <expr>(<name>uLong</name>)<call><name>get_byte</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>c</name></decl>;</decl_stmt>
<expr_stmt><expr><name>x</name> += ((<name>uLong</name>)<call><name>get_byte</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call>)&lt;&lt;8</expr>;</expr_stmt>
<expr_stmt><expr><name>x</name> += ((<name>uLong</name>)<call><name>get_byte</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call>)&lt;&lt;16</expr>;</expr_stmt>
<expr_stmt><expr><name>c</name> = <call><name>get_byte</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>c</name> == <name>EOF</name></expr>)</condition><then> <expr_stmt><expr><name><name>s</name>-&gt;<name>z_err</name></name> = <name>Z_DATA_ERROR</name></expr>;</expr_stmt></then></if>
<expr_stmt><expr><name>x</name> += ((<name>uLong</name>)<name>c</name>)&lt;&lt;24</expr>;</expr_stmt>
<return>return <expr><name>x</name></expr>;</return>
}</block></function>
<function><type><name>int</name> <name>ZEXPORT</name></type> <name>gzclose</name> <parameter_list>(<param><decl><type><name>file</name></type></decl></param>)</parameter_list>
<decl_stmt><decl><type><name>gzFile</name></type> <name>file</name></decl>;</decl_stmt>
<block>{
<decl_stmt><decl><type><name>gz_stream</name> *</type><name>s</name> <init>= <expr>(<name>gz_stream</name>*)<name>file</name></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>s</name> == <name>NULL</name></expr>)</condition><then> <return>return <expr><name>Z_STREAM_ERROR</name></expr>;</return></then></if>
<if>if <condition>(<expr><name><name>s</name>-&gt;<name>mode</name></name> == 'w'</expr>)</condition><then> <block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>NO_GZCOMPRESS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<return>return <expr><name>Z_STREAM_ERROR</name></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<if>if <condition>(<expr><call><name>do_flush</name> <argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><name>Z_FINISH</name></expr></argument>)</argument_list></call> != <name>Z_OK</name></expr>)</condition><then>
<return>return <expr><call><name>destroy</name><argument_list>(<argument><expr>(<name>gz_stream</name>*)<name>file</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
<expr_stmt><expr><call><name>putLong</name> <argument_list>(<argument><expr><name><name>s</name>-&gt;<name>file</name></name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>crc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>putLong</name> <argument_list>(<argument><expr><name><name>s</name>-&gt;<name>file</name></name></expr></argument>, <argument><expr><call>(<name>uLong</name>)<argument_list>(<argument><expr><name><name>s</name>-&gt;<name>in</name></name> &amp; 0xffffffff</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></then></if>
<return>return <expr><call><name>destroy</name><argument_list>(<argument><expr>(<name>gz_stream</name>*)<name>file</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>STDC</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>zstrerror</name><parameter_list>(<param><type><name>errnum</name></type></param>)</parameter_list></cpp:macro> <cpp:value>strerror(errnum)</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>zstrerror</name><parameter_list>(<param><type><name>errnum</name></type></param>)</parameter_list></cpp:macro> <cpp:value>""</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<function><type><specifier>const</specifier> <name>char</name> * <name>ZEXPORT</name></type> <name>gzerror</name> <parameter_list>(<param><decl><type><name>file</name></type></decl></param>, <param><decl><type><name>errnum</name></type></decl></param>)</parameter_list>
<decl_stmt><decl><type><name>gzFile</name></type> <name>file</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name> *</type><name>errnum</name></decl>;</decl_stmt>
<block>{
<decl_stmt><decl><type><name>char</name> *</type><name>m</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>gz_stream</name> *</type><name>s</name> <init>= <expr>(<name>gz_stream</name>*)<name>file</name></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>s</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr>*<name>errnum</name> = <name>Z_STREAM_ERROR</name></expr>;</expr_stmt>
<return>return <expr>(const <name>char</name>*)<call><name>ERR_MSG</name><argument_list>(<argument><expr><name>Z_STREAM_ERROR</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></then></if>
<expr_stmt><expr>*<name>errnum</name> = <name><name>s</name>-&gt;<name>z_err</name></name></expr>;</expr_stmt>
<if>if <condition>(<expr>*<name>errnum</name> == <name>Z_OK</name></expr>)</condition><then> <return>return <expr>(const <name>char</name>*)""</expr>;</return></then></if>
<expr_stmt><expr><name>m</name> = <call>(<name>char</name>*)<argument_list>(<argument><expr>*<name>errnum</name> == <name>Z_ERRNO</name> ? <call><name>zstrerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call> : <name><name>s</name>-&gt;<name>stream</name>.<name>msg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>m</name> == <name>NULL</name> || *<name>m</name> == '\0'</expr>)</condition><then> <expr_stmt><expr><name>m</name> = (<name>char</name>*)<call><name>ERR_MSG</name><argument_list>(<argument><expr><name><name>s</name>-&gt;<name>z_err</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<expr_stmt><expr><call><name>TRYFREE</name><argument_list>(<argument><expr><name><name>s</name>-&gt;<name>msg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name>-&gt;<name>msg</name></name> = (<name>char</name>*)<call><name>ALLOC</name><argument_list>(<argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name><name>s</name>-&gt;<name>path</name></name></expr></argument>)</argument_list></call> + <call><name>strlen</name><argument_list>(<argument><expr><name>m</name></expr></argument>)</argument_list></call> + 3</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>s</name>-&gt;<name>msg</name></name> == <name>Z_NULL</name></expr>)</condition><then> <return>return <expr>(const <name>char</name>*)<call><name>ERR_MSG</name><argument_list>(<argument><expr><name>Z_MEM_ERROR</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name><name>s</name>-&gt;<name>msg</name></name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>path</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>strcat</name><argument_list>(<argument><expr><name><name>s</name>-&gt;<name>msg</name></name></expr></argument>, <argument><expr>": "</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>strcat</name><argument_list>(<argument><expr><name><name>s</name>-&gt;<name>msg</name></name></expr></argument>, <argument><expr><name>m</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>(const <name>char</name>*)<name><name>s</name>-&gt;<name>msg</name></name></expr>;</return>
}</block></function>
<function><type><name>void</name> <name>ZEXPORT</name></type> <name>gzclearerr</name> <parameter_list>(<param><decl><type><name>file</name></type></decl></param>)</parameter_list>
<decl_stmt><decl><type><name>gzFile</name></type> <name>file</name></decl>;</decl_stmt>
<block>{
<decl_stmt><decl><type><name>gz_stream</name> *</type><name>s</name> <init>= <expr>(<name>gz_stream</name>*)<name>file</name></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>s</name> == <name>NULL</name></expr>)</condition><then> <return>return;</return></then></if>
<if>if <condition>(<expr><name><name>s</name>-&gt;<name>z_err</name></name> != <name>Z_STREAM_END</name></expr>)</condition><then> <expr_stmt><expr><name><name>s</name>-&gt;<name>z_err</name></name> = <name>Z_OK</name></expr>;</expr_stmt></then></if>
<expr_stmt><expr><name><name>s</name>-&gt;<name>z_eof</name></name> = 0</expr>;</expr_stmt>
<expr_stmt><expr><call><name>clearerr</name><argument_list>(<argument><expr><name><name>s</name>-&gt;<name>file</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>
</unit>
