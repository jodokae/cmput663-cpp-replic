<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C" filename="projects/cpython-2.6.1/_cppstats/Objects/funcobject.c"><cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"Python.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"code.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"eval.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"structmember.h"</cpp:file></cpp:include>
<function><type><name>PyObject</name> *</type>
<name>PyFunction_New</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>code</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>globals</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyFunctionObject</name> *</type><name>op</name> <init>= <expr><call><name>PyObject_GC_New</name><argument_list>(<argument><expr><name>PyFunctionObject</name></expr></argument>,
<argument><expr>&amp;<name>PyFunction_Type</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>PyObject</name> *</type><name>__name__</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>op</name> != <name>NULL</name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>doc</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>consts</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>module</name></decl>;</decl_stmt>
<expr_stmt><expr><name><name>op</name>-&gt;<name>func_weakreflist</name></name> = <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>code</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>op</name>-&gt;<name>func_code</name></name> = <name>code</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>globals</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>op</name>-&gt;<name>func_globals</name></name> = <name>globals</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>op</name>-&gt;<name>func_name</name></name> = ((<name>PyCodeObject</name> *)<name>code</name>)-&gt;<name>co_name</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name><name>op</name>-&gt;<name>func_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>op</name>-&gt;<name>func_defaults</name></name> = <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>op</name>-&gt;<name>func_closure</name></name> = <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name>consts</name> = ((<name>PyCodeObject</name> *)<name>code</name>)-&gt;<name>co_consts</name></expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>PyTuple_Size</name><argument_list>(<argument><expr><name>consts</name></expr></argument>)</argument_list></call> &gt;= 1</expr>)</condition><then> <block>{
<expr_stmt><expr><name>doc</name> = <call><name>PyTuple_GetItem</name><argument_list>(<argument><expr><name>consts</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<call><name>PyString_Check</name><argument_list>(<argument><expr><name>doc</name></expr></argument>)</argument_list></call> &amp;&amp; !<call><name>PyUnicode_Check</name><argument_list>(<argument><expr><name>doc</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<expr_stmt><expr><name>doc</name> = <name>Py_None</name></expr>;</expr_stmt></then></if>
}</block></then> <else>else
<expr_stmt><expr><name>doc</name> = <name>Py_None</name></expr>;</expr_stmt></else></if>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>doc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>op</name>-&gt;<name>func_doc</name></name> = <name>doc</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>op</name>-&gt;<name>func_dict</name></name> = <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>op</name>-&gt;<name>func_module</name></name> = <name>NULL</name></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>__name__</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>__name__</name> = <call><name>PyString_InternFromString</name><argument_list>(<argument><expr>"__name__"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>__name__</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
}</block></then></if>
<expr_stmt><expr><name>module</name> = <call><name>PyDict_GetItem</name><argument_list>(<argument><expr><name>globals</name></expr></argument>, <argument><expr><name>__name__</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>module</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>module</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>op</name>-&gt;<name>func_module</name></name> = <name>module</name></expr>;</expr_stmt>
}</block></then></if>
}</block></then> <else>else
<return>return <expr><name>NULL</name></expr>;</return></else></if>
<expr_stmt><expr><call><name>_PyObject_GC_TRACK</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>(<name>PyObject</name> *)<name>op</name></expr>;</return>
}</block></function>
<function><type><name>PyObject</name> *</type>
<name>PyFunction_GetCode</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>op</name></decl></param>)</parameter_list> <block>{
<if>if <condition>(<expr>!<call><name>PyFunction_Check</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_BadInternalCall</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<return>return <expr>((<name>PyFunctionObject</name> *) <name>op</name>) -&gt; <name>func_code</name></expr>;</return>
}</block></function>
<function><type><name>PyObject</name> *</type>
<name>PyFunction_GetGlobals</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>op</name></decl></param>)</parameter_list> <block>{
<if>if <condition>(<expr>!<call><name>PyFunction_Check</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_BadInternalCall</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<return>return <expr>((<name>PyFunctionObject</name> *) <name>op</name>) -&gt; <name>func_globals</name></expr>;</return>
}</block></function>
<function><type><name>PyObject</name> *</type>
<name>PyFunction_GetModule</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>op</name></decl></param>)</parameter_list> <block>{
<if>if <condition>(<expr>!<call><name>PyFunction_Check</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_BadInternalCall</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<return>return <expr>((<name>PyFunctionObject</name> *) <name>op</name>) -&gt; <name>func_module</name></expr>;</return>
}</block></function>
<function><type><name>PyObject</name> *</type>
<name>PyFunction_GetDefaults</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>op</name></decl></param>)</parameter_list> <block>{
<if>if <condition>(<expr>!<call><name>PyFunction_Check</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_BadInternalCall</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<return>return <expr>((<name>PyFunctionObject</name> *) <name>op</name>) -&gt; <name>func_defaults</name></expr>;</return>
}</block></function>
<function><type><name>int</name></type>
<name>PyFunction_SetDefaults</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>op</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>defaults</name></decl></param>)</parameter_list> <block>{
<if>if <condition>(<expr>!<call><name>PyFunction_Check</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_BadInternalCall</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<return>return <expr>-1</expr>;</return>
}</block></then></if>
<if>if <condition>(<expr><name>defaults</name> == <name>Py_None</name></expr>)</condition><then>
<expr_stmt><expr><name>defaults</name> = <name>NULL</name></expr>;</expr_stmt></then>
<else>else <if>if <condition>(<expr><name>defaults</name> &amp;&amp; <call><name>PyTuple_Check</name><argument_list>(<argument><expr><name>defaults</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>defaults</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_SystemError</name></expr></argument>, <argument><expr>"non-tuple default args"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>-1</expr>;</return>
}</block></else></if></else></if>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr>((<name>PyFunctionObject</name> *) <name>op</name>) -&gt; <name>func_defaults</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr>((<name>PyFunctionObject</name> *) <name>op</name>) -&gt; <name>func_defaults</name> = <name>defaults</name></expr>;</expr_stmt>
<return>return <expr>0</expr>;</return>
}</block></function>
<function><type><name>PyObject</name> *</type>
<name>PyFunction_GetClosure</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>op</name></decl></param>)</parameter_list> <block>{
<if>if <condition>(<expr>!<call><name>PyFunction_Check</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_BadInternalCall</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<return>return <expr>((<name>PyFunctionObject</name> *) <name>op</name>) -&gt; <name>func_closure</name></expr>;</return>
}</block></function>
<function><type><name>int</name></type>
<name>PyFunction_SetClosure</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>op</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>closure</name></decl></param>)</parameter_list> <block>{
<if>if <condition>(<expr>!<call><name>PyFunction_Check</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_BadInternalCall</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<return>return <expr>-1</expr>;</return>
}</block></then></if>
<if>if <condition>(<expr><name>closure</name> == <name>Py_None</name></expr>)</condition><then>
<expr_stmt><expr><name>closure</name> = <name>NULL</name></expr>;</expr_stmt></then>
<else>else <if>if <condition>(<expr><call><name>PyTuple_Check</name><argument_list>(<argument><expr><name>closure</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>closure</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_SystemError</name></expr></argument>,
<argument><expr>"expected tuple for closure, got '%.100s'"</expr></argument>,
<argument><expr><name><name>closure</name>-&gt;<name>ob_type</name>-&gt;<name>tp_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>-1</expr>;</return>
}</block></else></if></else></if>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr>((<name>PyFunctionObject</name> *) <name>op</name>) -&gt; <name>func_closure</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr>((<name>PyFunctionObject</name> *) <name>op</name>) -&gt; <name>func_closure</name> = <name>closure</name></expr>;</expr_stmt>
<return>return <expr>0</expr>;</return>
}</block></function>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>OFF</name><parameter_list>(<param><type><name>x</name></type></param>)</parameter_list></cpp:macro> <cpp:value>offsetof(PyFunctionObject, x)</cpp:value></cpp:define>
<decl_stmt><decl><type><specifier>static</specifier> <name>PyMemberDef</name></type> <name><name>func_memberlist</name><index>[]</index></name> <init>= <expr><block>{
<expr><block>{
<expr>"func_closure"</expr>, <expr><name>T_OBJECT</name></expr>, <expr><call><name>OFF</name><argument_list>(<argument><expr><name>func_closure</name></expr></argument>)</argument_list></call></expr>,
<expr><name>RESTRICTED</name>|<name>READONLY</name></expr>
}</block></expr>,
<expr><block>{
<expr>"__closure__"</expr>, <expr><name>T_OBJECT</name></expr>, <expr><call><name>OFF</name><argument_list>(<argument><expr><name>func_closure</name></expr></argument>)</argument_list></call></expr>,
<expr><name>RESTRICTED</name>|<name>READONLY</name></expr>
}</block></expr>,
<expr><block>{<expr>"func_doc"</expr>, <expr><name>T_OBJECT</name></expr>, <expr><call><name>OFF</name><argument_list>(<argument><expr><name>func_doc</name></expr></argument>)</argument_list></call></expr>, <expr><name>PY_WRITE_RESTRICTED</name></expr>}</block></expr>,
<expr><block>{<expr>"__doc__"</expr>, <expr><name>T_OBJECT</name></expr>, <expr><call><name>OFF</name><argument_list>(<argument><expr><name>func_doc</name></expr></argument>)</argument_list></call></expr>, <expr><name>PY_WRITE_RESTRICTED</name></expr>}</block></expr>,
<expr><block>{
<expr>"func_globals"</expr>, <expr><name>T_OBJECT</name></expr>, <expr><call><name>OFF</name><argument_list>(<argument><expr><name>func_globals</name></expr></argument>)</argument_list></call></expr>,
<expr><name>RESTRICTED</name>|<name>READONLY</name></expr>
}</block></expr>,
<expr><block>{
<expr>"__globals__"</expr>, <expr><name>T_OBJECT</name></expr>, <expr><call><name>OFF</name><argument_list>(<argument><expr><name>func_globals</name></expr></argument>)</argument_list></call></expr>,
<expr><name>RESTRICTED</name>|<name>READONLY</name></expr>
}</block></expr>,
<expr><block>{<expr>"__module__"</expr>, <expr><name>T_OBJECT</name></expr>, <expr><call><name>OFF</name><argument_list>(<argument><expr><name>func_module</name></expr></argument>)</argument_list></call></expr>, <expr><name>PY_WRITE_RESTRICTED</name></expr>}</block></expr>,
<expr><block>{<expr><name>NULL</name></expr>}</block></expr>
}</block></expr></init></decl>;</decl_stmt>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>restricted</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list> <block>{
<if>if <condition>(<expr>!<call><name>PyEval_GetRestricted</name><argument_list>()</argument_list></call></expr>)</condition><then>
<return>return <expr>0</expr>;</return></then></if>
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_RuntimeError</name></expr></argument>,
<argument><expr>"function attributes not accessible in restricted mode"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>1</expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>func_get_dict</name><parameter_list>(<param><decl><type><name>PyFunctionObject</name> *</type><name>op</name></decl></param>)</parameter_list> <block>{
<if>if <condition>(<expr><call><name>restricted</name><argument_list>()</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<if>if <condition>(<expr><name><name>op</name>-&gt;<name>func_dict</name></name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>op</name>-&gt;<name>func_dict</name></name> = <call><name>PyDict_New</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>op</name>-&gt;<name>func_dict</name></name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
}</block></then></if>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name><name>op</name>-&gt;<name>func_dict</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name><name>op</name>-&gt;<name>func_dict</name></name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>func_set_dict</name><parameter_list>(<param><decl><type><name>PyFunctionObject</name> *</type><name>op</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>value</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>tmp</name></decl>;</decl_stmt>
<if>if <condition>(<expr><call><name>restricted</name><argument_list>()</argument_list></call></expr>)</condition><then>
<return>return <expr>-1</expr>;</return></then></if>
<if>if <condition>(<expr><name>value</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
<argument><expr>"function's dictionary may not be deleted"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>-1</expr>;</return>
}</block></then></if>
<if>if <condition>(<expr>!<call><name>PyDict_Check</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
<argument><expr>"setting function's dictionary to a non-dict"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>-1</expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>tmp</name> = <name><name>op</name>-&gt;<name>func_dict</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>op</name>-&gt;<name>func_dict</name></name> = <name>value</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>0</expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>func_get_code</name><parameter_list>(<param><decl><type><name>PyFunctionObject</name> *</type><name>op</name></decl></param>)</parameter_list> <block>{
<if>if <condition>(<expr><call><name>restricted</name><argument_list>()</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name><name>op</name>-&gt;<name>func_code</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name><name>op</name>-&gt;<name>func_code</name></name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>func_set_code</name><parameter_list>(<param><decl><type><name>PyFunctionObject</name> *</type><name>op</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>value</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>tmp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>nfree</name></decl>, <decl><type ref="prev"/><name>nclosure</name></decl>;</decl_stmt>
<if>if <condition>(<expr><call><name>restricted</name><argument_list>()</argument_list></call></expr>)</condition><then>
<return>return <expr>-1</expr>;</return></then></if>
<if>if <condition>(<expr><name>value</name> == <name>NULL</name> || !<call><name>PyCode_Check</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
<argument><expr>"__code__ must be set to a code object"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>-1</expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>nfree</name> = <call><name>PyCode_GetNumFree</name><argument_list>(<argument><expr>(<name>PyCodeObject</name> *)<name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>nclosure</name> = (<name><name>op</name>-&gt;<name>func_closure</name></name> == <name>NULL</name> ? 0 :
<call><name>PyTuple_GET_SIZE</name><argument_list>(<argument><expr><name><name>op</name>-&gt;<name>func_closure</name></name></expr></argument>)</argument_list></call>)</expr>;</expr_stmt>
<if>if <condition>(<expr><name>nclosure</name> != <name>nfree</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>,
<argument><expr>"%s() requires a code object with %zd free vars,"
" not %zd"</expr></argument>,
<argument><expr><call><name>PyString_AsString</name><argument_list>(<argument><expr><name><name>op</name>-&gt;<name>func_name</name></name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>nclosure</name></expr></argument>, <argument><expr><name>nfree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>-1</expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>tmp</name> = <name><name>op</name>-&gt;<name>func_code</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>op</name>-&gt;<name>func_code</name></name> = <name>value</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>0</expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>func_get_name</name><parameter_list>(<param><decl><type><name>PyFunctionObject</name> *</type><name>op</name></decl></param>)</parameter_list> <block>{
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name><name>op</name>-&gt;<name>func_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name><name>op</name>-&gt;<name>func_name</name></name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>func_set_name</name><parameter_list>(<param><decl><type><name>PyFunctionObject</name> *</type><name>op</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>value</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>tmp</name></decl>;</decl_stmt>
<if>if <condition>(<expr><call><name>restricted</name><argument_list>()</argument_list></call></expr>)</condition><then>
<return>return <expr>-1</expr>;</return></then></if>
<if>if <condition>(<expr><name>value</name> == <name>NULL</name> || !<call><name>PyString_Check</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
<argument><expr>"__name__ must be set to a string object"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>-1</expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>tmp</name> = <name><name>op</name>-&gt;<name>func_name</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>op</name>-&gt;<name>func_name</name></name> = <name>value</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>0</expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>func_get_defaults</name><parameter_list>(<param><decl><type><name>PyFunctionObject</name> *</type><name>op</name></decl></param>)</parameter_list> <block>{
<if>if <condition>(<expr><call><name>restricted</name><argument_list>()</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<if>if <condition>(<expr><name><name>op</name>-&gt;<name>func_defaults</name></name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>Py_None</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name><name>op</name>-&gt;<name>func_defaults</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name><name>op</name>-&gt;<name>func_defaults</name></name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>func_set_defaults</name><parameter_list>(<param><decl><type><name>PyFunctionObject</name> *</type><name>op</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>value</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>tmp</name></decl>;</decl_stmt>
<if>if <condition>(<expr><call><name>restricted</name><argument_list>()</argument_list></call></expr>)</condition><then>
<return>return <expr>-1</expr>;</return></then></if>
<if>if <condition>(<expr><name>value</name> == <name>Py_None</name></expr>)</condition><then>
<expr_stmt><expr><name>value</name> = <name>NULL</name></expr>;</expr_stmt></then></if>
<if>if <condition>(<expr><name>value</name> != <name>NULL</name> &amp;&amp; !<call><name>PyTuple_Check</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
<argument><expr>"__defaults__ must be set to a tuple object"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>-1</expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>tmp</name> = <name><name>op</name>-&gt;<name>func_defaults</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_XINCREF</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>op</name>-&gt;<name>func_defaults</name></name> = <name>value</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>0</expr>;</return>
}</block></function>
<decl_stmt><decl><type><specifier>static</specifier> <name>PyGetSetDef</name></type> <name><name>func_getsetlist</name><index>[]</index></name> <init>= <expr><block>{
<expr><block>{<expr>"func_code"</expr>, <expr>(<name>getter</name>)<name>func_get_code</name></expr>, <expr>(<name>setter</name>)<name>func_set_code</name></expr>}</block></expr>,
<expr><block>{<expr>"__code__"</expr>, <expr>(<name>getter</name>)<name>func_get_code</name></expr>, <expr>(<name>setter</name>)<name>func_set_code</name></expr>}</block></expr>,
<expr><block>{
<expr>"func_defaults"</expr>, <expr>(<name>getter</name>)<name>func_get_defaults</name></expr>,
<expr>(<name>setter</name>)<name>func_set_defaults</name></expr>
}</block></expr>,
<expr><block>{
<expr>"__defaults__"</expr>, <expr>(<name>getter</name>)<name>func_get_defaults</name></expr>,
<expr>(<name>setter</name>)<name>func_set_defaults</name></expr>
}</block></expr>,
<expr><block>{<expr>"func_dict"</expr>, <expr>(<name>getter</name>)<name>func_get_dict</name></expr>, <expr>(<name>setter</name>)<name>func_set_dict</name></expr>}</block></expr>,
<expr><block>{<expr>"__dict__"</expr>, <expr>(<name>getter</name>)<name>func_get_dict</name></expr>, <expr>(<name>setter</name>)<name>func_set_dict</name></expr>}</block></expr>,
<expr><block>{<expr>"func_name"</expr>, <expr>(<name>getter</name>)<name>func_get_name</name></expr>, <expr>(<name>setter</name>)<name>func_set_name</name></expr>}</block></expr>,
<expr><block>{<expr>"__name__"</expr>, <expr>(<name>getter</name>)<name>func_get_name</name></expr>, <expr>(<name>setter</name>)<name>func_set_name</name></expr>}</block></expr>,
<expr><block>{<expr><name>NULL</name></expr>}</block></expr>
}</block></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>func_doc</name></expr></argument>,
<argument><expr>"function(code, globals[, name[, argdefs[, closure]]])\n\
\n\
Create a function object from a code object and a dictionary.\n\
The optional name string overrides the name from the code object.\n\
The optional argdefs tuple specifies the default argument values.\n\
The optional closure tuple supplies the bindings for free variables."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>func_new</name><parameter_list>(<param><decl><type><name>PyTypeObject</name>*</type> <name>type</name></decl></param>, <param><decl><type><name>PyObject</name>*</type> <name>args</name></decl></param>, <param><decl><type><name>PyObject</name>*</type> <name>kw</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyCodeObject</name> *</type><name>code</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>globals</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>name</name> <init>= <expr><name>Py_None</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>defaults</name> <init>= <expr><name>Py_None</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>closure</name> <init>= <expr><name>Py_None</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyFunctionObject</name> *</type><name>newfunc</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>nfree</name></decl>, <decl><type ref="prev"/><name>nclosure</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> *</type><name><name>kwlist</name><index>[]</index></name> <init>= <expr><block>{<expr>"code"</expr>, <expr>"globals"</expr>, <expr>"name"</expr>,
<expr>"argdefs"</expr>, <expr>"closure"</expr>, <expr>0</expr>
}</block></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTupleAndKeywords</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>kw</name></expr></argument>, <argument><expr>"O!O!|OOO:function"</expr></argument>,
<argument><expr><name>kwlist</name></expr></argument>,
<argument><expr>&amp;<name>PyCode_Type</name></expr></argument>, <argument><expr>&amp;<name>code</name></expr></argument>,
<argument><expr>&amp;<name>PyDict_Type</name></expr></argument>, <argument><expr>&amp;<name>globals</name></expr></argument>,
<argument><expr>&amp;<name>name</name></expr></argument>, <argument><expr>&amp;<name>defaults</name></expr></argument>, <argument><expr>&amp;<name>closure</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<if>if <condition>(<expr><name>name</name> != <name>Py_None</name> &amp;&amp; !<call><name>PyString_Check</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
<argument><expr>"arg 3 (name) must be None or string"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<if>if <condition>(<expr><name>defaults</name> != <name>Py_None</name> &amp;&amp; !<call><name>PyTuple_Check</name><argument_list>(<argument><expr><name>defaults</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
<argument><expr>"arg 4 (defaults) must be None or tuple"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>nfree</name> = <call><name>PyTuple_GET_SIZE</name><argument_list>(<argument><expr><name><name>code</name>-&gt;<name>co_freevars</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<call><name>PyTuple_Check</name><argument_list>(<argument><expr><name>closure</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<if>if <condition>(<expr><name>nfree</name> &amp;&amp; <name>closure</name> == <name>Py_None</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
<argument><expr>"arg 5 (closure) must be tuple"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then> <else>else <if>if <condition>(<expr><name>closure</name> != <name>Py_None</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
<argument><expr>"arg 5 (closure) must be None or tuple"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if></else></if>
}</block></then></if>
<expr_stmt><expr><name>nclosure</name> = <name>closure</name> == <name>Py_None</name> ? 0 : <call><name>PyTuple_GET_SIZE</name><argument_list>(<argument><expr><name>closure</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>nfree</name> != <name>nclosure</name></expr>)</condition><then>
<return>return <expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>,
<argument><expr>"%s requires closure of length %zd, not %zd"</expr></argument>,
<argument><expr><call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name><name>code</name>-&gt;<name>co_name</name></name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>nfree</name></expr></argument>, <argument><expr><name>nclosure</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
<if>if <condition>(<expr><name>nclosure</name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>i</name></decl>;</decl_stmt>
<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>nclosure</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>o</name> <init>= <expr><call><name>PyTuple_GET_ITEM</name><argument_list>(<argument><expr><name>closure</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>PyCell_Check</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<return>return <expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
<argument><expr>"arg 5 (closure) expected cell, found %s"</expr></argument>,
<argument><expr><name><name>o</name>-&gt;<name>ob_type</name>-&gt;<name>tp_name</name></name></expr></argument>)</argument_list></call></expr>;</return>
}</block></then></if>
}</block></for>
}</block></then></if>
<expr_stmt><expr><name>newfunc</name> = (<name>PyFunctionObject</name> *)<call><name>PyFunction_New</name><argument_list>(<argument><expr>(<name>PyObject</name> *)<name>code</name></expr></argument>,
<argument><expr><name>globals</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>newfunc</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<if>if <condition>(<expr><name>name</name> != <name>Py_None</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name><name>newfunc</name>-&gt;<name>func_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>newfunc</name>-&gt;<name>func_name</name></name> = <name>name</name></expr>;</expr_stmt>
}</block></then></if>
<if>if <condition>(<expr><name>defaults</name> != <name>Py_None</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>defaults</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>newfunc</name>-&gt;<name>func_defaults</name></name> = <name>defaults</name></expr>;</expr_stmt>
}</block></then></if>
<if>if <condition>(<expr><name>closure</name> != <name>Py_None</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>closure</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>newfunc</name>-&gt;<name>func_closure</name></name> = <name>closure</name></expr>;</expr_stmt>
}</block></then></if>
<return>return <expr>(<name>PyObject</name> *)<name>newfunc</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>func_dealloc</name><parameter_list>(<param><decl><type><name>PyFunctionObject</name> *</type><name>op</name></decl></param>)</parameter_list> <block>{
<expr_stmt><expr><call><name>_PyObject_GC_UNTRACK</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>op</name>-&gt;<name>func_weakreflist</name></name> != <name>NULL</name></expr>)</condition><then>
<expr_stmt><expr><call><name>PyObject_ClearWeakRefs</name><argument_list>(<argument><expr>(<name>PyObject</name> *) <name>op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name><name>op</name>-&gt;<name>func_code</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name><name>op</name>-&gt;<name>func_globals</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name><name>op</name>-&gt;<name>func_module</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name><name>op</name>-&gt;<name>func_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name><name>op</name>-&gt;<name>func_defaults</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name><name>op</name>-&gt;<name>func_doc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name><name>op</name>-&gt;<name>func_dict</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name><name>op</name>-&gt;<name>func_closure</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyObject_GC_Del</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name>*</type>
<name>func_repr</name><parameter_list>(<param><decl><type><name>PyFunctionObject</name> *</type><name>op</name></decl></param>)</parameter_list> <block>{
<return>return <expr><call><name>PyString_FromFormat</name><argument_list>(<argument><expr>"&lt;function %s at %p&gt;"</expr></argument>,
<argument><expr><call><name>PyString_AsString</name><argument_list>(<argument><expr><name><name>op</name>-&gt;<name>func_name</name></name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>func_traverse</name><parameter_list>(<param><decl><type><name>PyFunctionObject</name> *</type><name>f</name></decl></param>, <param><decl><type><name>visitproc</name></type> <name>visit</name></decl></param>, <param><decl><type><name>void</name> *</type><name>arg</name></decl></param>)</parameter_list> <block>{
<expr_stmt><expr><call><name>Py_VISIT</name><argument_list>(<argument><expr><name><name>f</name>-&gt;<name>func_code</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_VISIT</name><argument_list>(<argument><expr><name><name>f</name>-&gt;<name>func_globals</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_VISIT</name><argument_list>(<argument><expr><name><name>f</name>-&gt;<name>func_module</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_VISIT</name><argument_list>(<argument><expr><name><name>f</name>-&gt;<name>func_defaults</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_VISIT</name><argument_list>(<argument><expr><name><name>f</name>-&gt;<name>func_doc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_VISIT</name><argument_list>(<argument><expr><name><name>f</name>-&gt;<name>func_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_VISIT</name><argument_list>(<argument><expr><name><name>f</name>-&gt;<name>func_dict</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_VISIT</name><argument_list>(<argument><expr><name><name>f</name>-&gt;<name>func_closure</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>0</expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>function_call</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>func</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>arg</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>kw</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>result</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>argdefs</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> **</type><name>d</name></decl>, **<decl><type ref="prev"/><name>k</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>nk</name></decl>, <decl><type ref="prev"/><name>nd</name></decl>;</decl_stmt>
<expr_stmt><expr><name>argdefs</name> = <call><name>PyFunction_GET_DEFAULTS</name><argument_list>(<argument><expr><name>func</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>argdefs</name> != <name>NULL</name> &amp;&amp; <call><name>PyTuple_Check</name><argument_list>(<argument><expr><name>argdefs</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><name>d</name> = &amp;<call><name>PyTuple_GET_ITEM</name><argument_list>(<argument><expr>(<name>PyTupleObject</name> *)<name>argdefs</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>nd</name> = <call><name>PyTuple_Size</name><argument_list>(<argument><expr><name>argdefs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr><name>d</name> = <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name>nd</name> = 0</expr>;</expr_stmt>
}</block></else></if>
<if>if <condition>(<expr><name>kw</name> != <name>NULL</name> &amp;&amp; <call><name>PyDict_Check</name><argument_list>(<argument><expr><name>kw</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>pos</name></decl>, <decl><type ref="prev"/><name>i</name></decl>;</decl_stmt>
<expr_stmt><expr><name>nk</name> = <call><name>PyDict_Size</name><argument_list>(<argument><expr><name>kw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>k</name> = <call><name>PyMem_NEW</name><argument_list>(<argument><expr><name>PyObject</name> *</expr></argument>, <argument><expr>2*<name>nk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>k</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_NoMemory</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>pos</name> = <name>i</name> = 0</expr>;</expr_stmt>
<while>while <condition>(<expr><call><name>PyDict_Next</name><argument_list>(<argument><expr><name>kw</name></expr></argument>, <argument><expr>&amp;<name>pos</name></expr></argument>, <argument><expr>&amp;<name><name>k</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr>&amp;<name><name>k</name><index>[<expr><name>i</name>+1</expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition>
<expr_stmt><expr><name>i</name> += 2</expr>;</expr_stmt></while>
<expr_stmt><expr><name>nk</name> = <name>i</name>/2</expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr><name>k</name> = <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name>nk</name> = 0</expr>;</expr_stmt>
}</block></else></if>
<expr_stmt><expr><name>result</name> = <call><name>PyEval_EvalCodeEx</name><argument_list>(
<argument><expr>(<name>PyCodeObject</name> *)<call><name>PyFunction_GET_CODE</name><argument_list>(<argument><expr><name>func</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name>PyFunction_GET_GLOBALS</name><argument_list>(<argument><expr><name>func</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>(<name>PyObject</name> *)<name>NULL</name></expr></argument>,
<argument><expr>&amp;<call><name>PyTuple_GET_ITEM</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>PyTuple_Size</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>k</name></expr></argument>, <argument><expr><name>nk</name></expr></argument>, <argument><expr><name>d</name></expr></argument>, <argument><expr><name>nd</name></expr></argument>,
<argument><expr><call><name>PyFunction_GET_CLOSURE</name><argument_list>(<argument><expr><name>func</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>k</name> != <name>NULL</name></expr>)</condition><then>
<expr_stmt><expr><call><name>PyMem_DEL</name><argument_list>(<argument><expr><name>k</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<return>return <expr><name>result</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>func_descr_get</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>func</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>obj</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>type</name></decl></param>)</parameter_list> <block>{
<if>if <condition>(<expr><name>obj</name> == <name>Py_None</name></expr>)</condition><then>
<expr_stmt><expr><name>obj</name> = <name>NULL</name></expr>;</expr_stmt></then></if>
<return>return <expr><call><name>PyMethod_New</name><argument_list>(<argument><expr><name>func</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>, <argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<decl_stmt><decl><type><name>PyTypeObject</name></type> <name>PyFunction_Type</name> <init>= <expr><block>{
<expr><call><name>PyVarObject_HEAD_INIT</name><argument_list>(<argument><expr>&amp;<name>PyType_Type</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call>
"function"</expr>,
<expr><sizeof>sizeof<argument_list>(<argument><expr><name>PyFunctionObject</name></expr></argument>)</argument_list></sizeof></expr>,
<expr>0</expr>,
<expr>(<name>destructor</name>)<name>func_dealloc</name></expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>(<name>reprfunc</name>)<name>func_repr</name></expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr><name>function_call</name></expr>,
<expr>0</expr>,
<expr><name>PyObject_GenericGetAttr</name></expr>,
<expr><name>PyObject_GenericSetAttr</name></expr>,
<expr>0</expr>,
<expr><name>Py_TPFLAGS_DEFAULT</name> | <name>Py_TPFLAGS_HAVE_GC</name></expr>,
<expr><name>func_doc</name></expr>,
<expr>(<name>traverseproc</name>)<name>func_traverse</name></expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr><call><name>offsetof</name><argument_list>(<argument><expr><name>PyFunctionObject</name></expr></argument>, <argument><expr><name>func_weakreflist</name></expr></argument>)</argument_list></call></expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr><name>func_memberlist</name></expr>,
<expr><name>func_getsetlist</name></expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr><name>func_descr_get</name></expr>,
<expr>0</expr>,
<expr><call><name>offsetof</name><argument_list>(<argument><expr><name>PyFunctionObject</name></expr></argument>, <argument><expr><name>func_dict</name></expr></argument>)</argument_list></call></expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr><name>func_new</name></expr>,
}</block></expr></init></decl>;</decl_stmt>
<typedef>typedef <type><struct>struct <block>{
<decl_stmt><decl><type><name>PyObject_HEAD</name>
<name>PyObject</name> *</type><name>cm_callable</name></decl>;</decl_stmt>
}</block></struct></type> <name>classmethod</name>;</typedef>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>cm_dealloc</name><parameter_list>(<param><decl><type><name>classmethod</name> *</type><name>cm</name></decl></param>)</parameter_list> <block>{
<expr_stmt><expr><call><name>_PyObject_GC_UNTRACK</name><argument_list>(<argument><expr>(<name>PyObject</name> *)<name>cm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name><name>cm</name>-&gt;<name>cm_callable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_TYPE</name><argument_list>(<argument><expr><name>cm</name></expr></argument>)</argument_list></call>-&gt;<call><name>tp_free</name><argument_list>(<argument><expr>(<name>PyObject</name> *)<name>cm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>cm_traverse</name><parameter_list>(<param><decl><type><name>classmethod</name> *</type><name>cm</name></decl></param>, <param><decl><type><name>visitproc</name></type> <name>visit</name></decl></param>, <param><decl><type><name>void</name> *</type><name>arg</name></decl></param>)</parameter_list> <block>{
<expr_stmt><expr><call><name>Py_VISIT</name><argument_list>(<argument><expr><name><name>cm</name>-&gt;<name>cm_callable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>0</expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>cm_clear</name><parameter_list>(<param><decl><type><name>classmethod</name> *</type><name>cm</name></decl></param>)</parameter_list> <block>{
<expr_stmt><expr><call><name>Py_CLEAR</name><argument_list>(<argument><expr><name><name>cm</name>-&gt;<name>cm_callable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>0</expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>cm_descr_get</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>obj</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>type</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>classmethod</name> *</type><name>cm</name> <init>= <expr>(<name>classmethod</name> *)<name>self</name></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name><name>cm</name>-&gt;<name>cm_callable</name></name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_RuntimeError</name></expr></argument>,
<argument><expr>"uninitialized classmethod object"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<if>if <condition>(<expr><name>type</name> == <name>NULL</name></expr>)</condition><then>
<expr_stmt><expr><name>type</name> = <call>(<name>PyObject</name> *)<argument_list>(<argument><expr><call><name>Py_TYPE</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<return>return <expr><call><name>PyMethod_New</name><argument_list>(<argument><expr><name><name>cm</name>-&gt;<name>cm_callable</name></name></expr></argument>,
<argument><expr><name>type</name></expr></argument>, <argument><expr><call>(<name>PyObject</name> *)<argument_list>(<argument><expr><call><name>Py_TYPE</name><argument_list>(<argument><expr><name>type</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>cm_init</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>kwds</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>classmethod</name> *</type><name>cm</name> <init>= <expr>(<name>classmethod</name> *)<name>self</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>callable</name></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>PyArg_UnpackTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"classmethod"</expr></argument>, <argument><expr>1</expr></argument>, <argument><expr>1</expr></argument>, <argument><expr>&amp;<name>callable</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr>-1</expr>;</return></then></if>
<if>if <condition>(<expr>!<call><name>_PyArg_NoKeywords</name><argument_list>(<argument><expr>"classmethod"</expr></argument>, <argument><expr><name>kwds</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr>-1</expr>;</return></then></if>
<if>if <condition>(<expr>!<call><name>PyCallable_Check</name><argument_list>(<argument><expr><name>callable</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>, <argument><expr>"'%s' object is not callable"</expr></argument>,
<argument><expr><name><name>callable</name>-&gt;<name>ob_type</name>-&gt;<name>tp_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>-1</expr>;</return>
}</block></then></if>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>callable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cm</name>-&gt;<name>cm_callable</name></name> = <name>callable</name></expr>;</expr_stmt>
<return>return <expr>0</expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>classmethod_doc</name></expr></argument>,
<argument><expr>"classmethod(function) -&gt; method\n\
\n\
Convert a function to be a class method.\n\
\n\
A class method receives the class as implicit first argument,\n\
just like an instance method receives the instance.\n\
To declare a class method, use this idiom:\n\
\n\
class C:\n\
def f(cls, arg1, arg2, ...): ...\n\
f = classmethod(f)\n\
\n\
It can be called either on the class (e.g. C.f()) or on an instance\n\
(e.g. C().f()). The instance is ignored except for its class.\n\
If a class method is called for a derived class, the derived class\n\
object is passed as the implied first argument.\n\
\n\
Class methods are different than C++ or Java static methods.\n\
If you want those, see the staticmethod builtin."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>PyTypeObject</name></type> <name>PyClassMethod_Type</name> <init>= <expr><block>{
<expr><call><name>PyVarObject_HEAD_INIT</name><argument_list>(<argument><expr>&amp;<name>PyType_Type</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call>
"classmethod"</expr>,
<expr><sizeof>sizeof<argument_list>(<argument><expr><name>classmethod</name></expr></argument>)</argument_list></sizeof></expr>,
<expr>0</expr>,
<expr>(<name>destructor</name>)<name>cm_dealloc</name></expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr><name>PyObject_GenericGetAttr</name></expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr><name>Py_TPFLAGS_DEFAULT</name> | <name>Py_TPFLAGS_BASETYPE</name> | <name>Py_TPFLAGS_HAVE_GC</name></expr>,
<expr><name>classmethod_doc</name></expr>,
<expr>(<name>traverseproc</name>)<name>cm_traverse</name></expr>,
<expr>(<name>inquiry</name>)<name>cm_clear</name></expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr><name>cm_descr_get</name></expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr><name>cm_init</name></expr>,
<expr><name>PyType_GenericAlloc</name></expr>,
<expr><name>PyType_GenericNew</name></expr>,
<expr><name>PyObject_GC_Del</name></expr>,
}</block></expr></init></decl>;</decl_stmt>
<function><type><name>PyObject</name> *</type>
<name>PyClassMethod_New</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>callable</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>classmethod</name> *</type><name>cm</name> <init>= <expr>(<name>classmethod</name> *)
<call><name>PyType_GenericAlloc</name><argument_list>(<argument><expr>&amp;<name>PyClassMethod_Type</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>cm</name> != <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>callable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cm</name>-&gt;<name>cm_callable</name></name> = <name>callable</name></expr>;</expr_stmt>
}</block></then></if>
<return>return <expr>(<name>PyObject</name> *)<name>cm</name></expr>;</return>
}</block></function>
<typedef>typedef <type><struct>struct <block>{
<decl_stmt><decl><type><name>PyObject_HEAD</name>
<name>PyObject</name> *</type><name>sm_callable</name></decl>;</decl_stmt>
}</block></struct></type> <name>staticmethod</name>;</typedef>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>sm_dealloc</name><parameter_list>(<param><decl><type><name>staticmethod</name> *</type><name>sm</name></decl></param>)</parameter_list> <block>{
<expr_stmt><expr><call><name>_PyObject_GC_UNTRACK</name><argument_list>(<argument><expr>(<name>PyObject</name> *)<name>sm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name><name>sm</name>-&gt;<name>sm_callable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_TYPE</name><argument_list>(<argument><expr><name>sm</name></expr></argument>)</argument_list></call>-&gt;<call><name>tp_free</name><argument_list>(<argument><expr>(<name>PyObject</name> *)<name>sm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>sm_traverse</name><parameter_list>(<param><decl><type><name>staticmethod</name> *</type><name>sm</name></decl></param>, <param><decl><type><name>visitproc</name></type> <name>visit</name></decl></param>, <param><decl><type><name>void</name> *</type><name>arg</name></decl></param>)</parameter_list> <block>{
<expr_stmt><expr><call><name>Py_VISIT</name><argument_list>(<argument><expr><name><name>sm</name>-&gt;<name>sm_callable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>0</expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>sm_clear</name><parameter_list>(<param><decl><type><name>staticmethod</name> *</type><name>sm</name></decl></param>)</parameter_list> <block>{
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name><name>sm</name>-&gt;<name>sm_callable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>sm</name>-&gt;<name>sm_callable</name></name> = <name>NULL</name></expr>;</expr_stmt>
<return>return <expr>0</expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>sm_descr_get</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>obj</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>type</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>staticmethod</name> *</type><name>sm</name> <init>= <expr>(<name>staticmethod</name> *)<name>self</name></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name><name>sm</name>-&gt;<name>sm_callable</name></name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_RuntimeError</name></expr></argument>,
<argument><expr>"uninitialized staticmethod object"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name><name>sm</name>-&gt;<name>sm_callable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name><name>sm</name>-&gt;<name>sm_callable</name></name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>sm_init</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>kwds</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>staticmethod</name> *</type><name>sm</name> <init>= <expr>(<name>staticmethod</name> *)<name>self</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>callable</name></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>PyArg_UnpackTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"staticmethod"</expr></argument>, <argument><expr>1</expr></argument>, <argument><expr>1</expr></argument>, <argument><expr>&amp;<name>callable</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr>-1</expr>;</return></then></if>
<if>if <condition>(<expr>!<call><name>_PyArg_NoKeywords</name><argument_list>(<argument><expr>"staticmethod"</expr></argument>, <argument><expr><name>kwds</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr>-1</expr>;</return></then></if>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>callable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>sm</name>-&gt;<name>sm_callable</name></name> = <name>callable</name></expr>;</expr_stmt>
<return>return <expr>0</expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>staticmethod_doc</name></expr></argument>,
<argument><expr>"staticmethod(function) -&gt; method\n\
\n\
Convert a function to be a static method.\n\
\n\
A static method does not receive an implicit first argument.\n\
To declare a static method, use this idiom:\n\
\n\
class C:\n\
def f(arg1, arg2, ...): ...\n\
f = staticmethod(f)\n\
\n\
It can be called either on the class (e.g. C.f()) or on an instance\n\
(e.g. C().f()). The instance is ignored except for its class.\n\
\n\
Static methods in Python are similar to those found in Java or C++.\n\
For a more advanced concept, see the classmethod builtin."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>PyTypeObject</name></type> <name>PyStaticMethod_Type</name> <init>= <expr><block>{
<expr><call><name>PyVarObject_HEAD_INIT</name><argument_list>(<argument><expr>&amp;<name>PyType_Type</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call>
"staticmethod"</expr>,
<expr><sizeof>sizeof<argument_list>(<argument><expr><name>staticmethod</name></expr></argument>)</argument_list></sizeof></expr>,
<expr>0</expr>,
<expr>(<name>destructor</name>)<name>sm_dealloc</name></expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr><name>PyObject_GenericGetAttr</name></expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr><name>Py_TPFLAGS_DEFAULT</name> | <name>Py_TPFLAGS_BASETYPE</name> | <name>Py_TPFLAGS_HAVE_GC</name></expr>,
<expr><name>staticmethod_doc</name></expr>,
<expr>(<name>traverseproc</name>)<name>sm_traverse</name></expr>,
<expr>(<name>inquiry</name>)<name>sm_clear</name></expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr><name>sm_descr_get</name></expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr><name>sm_init</name></expr>,
<expr><name>PyType_GenericAlloc</name></expr>,
<expr><name>PyType_GenericNew</name></expr>,
<expr><name>PyObject_GC_Del</name></expr>,
}</block></expr></init></decl>;</decl_stmt>
<function><type><name>PyObject</name> *</type>
<name>PyStaticMethod_New</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>callable</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>staticmethod</name> *</type><name>sm</name> <init>= <expr>(<name>staticmethod</name> *)
<call><name>PyType_GenericAlloc</name><argument_list>(<argument><expr>&amp;<name>PyStaticMethod_Type</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>sm</name> != <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>callable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>sm</name>-&gt;<name>sm_callable</name></name> = <name>callable</name></expr>;</expr_stmt>
}</block></then></if>
<return>return <expr>(<name>PyObject</name> *)<name>sm</name></expr>;</return>
}</block></function>
</unit>
