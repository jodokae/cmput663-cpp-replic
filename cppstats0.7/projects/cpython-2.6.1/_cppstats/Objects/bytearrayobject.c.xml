<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C" filename="projects/cpython-2.6.1/_cppstats/Objects/bytearrayobject.c"><cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PY_SSIZE_T_CLEAN</name></cpp:macro></cpp:define>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"Python.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"structmember.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"bytes_methods.h"</cpp:file></cpp:include>
<decl_stmt><decl><type><specifier>static</specifier> <name>PyByteArrayObject</name> *</type><name>nullbytes</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<function><type><name>void</name></type>
<name>PyByteArray_Fini</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list> <block>{
<expr_stmt><expr><call><name>Py_CLEAR</name><argument_list>(<argument><expr><name>nullbytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>
<function><type><name>int</name></type>
<name>PyByteArray_Init</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list> <block>{
<expr_stmt><expr><name>nullbytes</name> = <call><name>PyObject_New</name><argument_list>(<argument><expr><name>PyByteArrayObject</name></expr></argument>, <argument><expr>&amp;<name>PyByteArray_Type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>nullbytes</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr>0</expr>;</return></then></if>
<expr_stmt><expr><name><name>nullbytes</name>-&gt;<name>ob_bytes</name></name> = <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_SIZE</name><argument_list>(<argument><expr><name>nullbytes</name></expr></argument>)</argument_list></call> = <name><name>nullbytes</name>-&gt;<name>ob_alloc</name></name> = 0</expr>;</expr_stmt>
<expr_stmt><expr><name><name>nullbytes</name>-&gt;<name>ob_exports</name></name> = 0</expr>;</expr_stmt>
<return>return <expr>1</expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>_getbytevalue</name><parameter_list>(<param><decl><type><name>PyObject</name>*</type> <name>arg</name></decl></param>, <param><decl><type><name>int</name> *</type><name>value</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>long</name></type> <name>face_value</name></decl>;</decl_stmt>
<if>if <condition>(<expr><call><name>PyBytes_CheckExact</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<if>if <condition>(<expr><call><name>Py_SIZE</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call> != 1</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>, <argument><expr>"string must be of size 1"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>0</expr>;</return>
}</block></then></if>
<expr_stmt><expr>*<name>value</name> = <call><name>Py_CHARMASK</name><argument_list>(<argument><expr>((<name>PyBytesObject</name>*)<name>arg</name>)-&gt;<name><name>ob_sval</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>1</expr>;</return>
}</block></then> <else>else <if>if <condition>(<expr><call><name>PyInt_Check</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call> || <call><name>PyLong_Check</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><name>face_value</name> = <call><name>PyLong_AsLong</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>index</name> <init>= <expr><call><name>PyNumber_Index</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>index</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
<argument><expr>"an integer or string of size 1 is required"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>0</expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>face_value</name> = <call><name>PyLong_AsLong</name><argument_list>(<argument><expr><name>index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></else></if></else></if>
<if>if <condition>(<expr><name>face_value</name> &lt; 0 || <name>face_value</name> &gt;= 256</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>, <argument><expr>"byte must be in range(0, 256)"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>0</expr>;</return>
}</block></then></if>
<expr_stmt><expr>*<name>value</name> = <name>face_value</name></expr>;</expr_stmt>
<return>return <expr>1</expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>Py_ssize_t</name></type>
<name>bytes_buffer_getreadbuf</name><parameter_list>(<param><decl><type><name>PyByteArrayObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>index</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>void</name> **</type><name>ptr</name></decl></param>)</parameter_list> <block>{
<if>if <condition>( <expr><name>index</name> != 0</expr> )</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_SystemError</name></expr></argument>,
<argument><expr>"accessing non-existent bytes segment"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>-1</expr>;</return>
}</block></then></if>
<expr_stmt><expr>*<name>ptr</name> = (<name>void</name> *)<name><name>self</name>-&gt;<name>ob_bytes</name></name></expr>;</expr_stmt>
<return>return <expr><call><name>Py_SIZE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>Py_ssize_t</name></type>
<name>bytes_buffer_getwritebuf</name><parameter_list>(<param><decl><type><name>PyByteArrayObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>index</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>void</name> **</type><name>ptr</name></decl></param>)</parameter_list> <block>{
<if>if <condition>( <expr><name>index</name> != 0</expr> )</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_SystemError</name></expr></argument>,
<argument><expr>"accessing non-existent bytes segment"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>-1</expr>;</return>
}</block></then></if>
<expr_stmt><expr>*<name>ptr</name> = (<name>void</name> *)<name><name>self</name>-&gt;<name>ob_bytes</name></name></expr>;</expr_stmt>
<return>return <expr><call><name>Py_SIZE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>Py_ssize_t</name></type>
<name>bytes_buffer_getsegcount</name><parameter_list>(<param><decl><type><name>PyByteArrayObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>Py_ssize_t</name> *</type><name>lenp</name></decl></param>)</parameter_list> <block>{
<if>if <condition>( <expr><name>lenp</name></expr> )</condition><then>
<expr_stmt><expr>*<name>lenp</name> = <call><name>Py_SIZE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<return>return <expr>1</expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>Py_ssize_t</name></type>
<name>bytes_buffer_getcharbuf</name><parameter_list>(<param><decl><type><name>PyByteArrayObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>index</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> **</type><name>ptr</name></decl></param>)</parameter_list> <block>{
<if>if <condition>( <expr><name>index</name> != 0</expr> )</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_SystemError</name></expr></argument>,
<argument><expr>"accessing non-existent bytes segment"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>-1</expr>;</return>
}</block></then></if>
<expr_stmt><expr>*<name>ptr</name> = <name><name>self</name>-&gt;<name>ob_bytes</name></name></expr>;</expr_stmt>
<return>return <expr><call><name>Py_SIZE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>bytes_getbuffer</name><parameter_list>(<param><decl><type><name>PyByteArrayObject</name> *</type><name>obj</name></decl></param>, <param><decl><type><name>Py_buffer</name> *</type><name>view</name></decl></param>, <param><decl><type><name>int</name></type> <name>flags</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>void</name> *</type><name>ptr</name></decl>;</decl_stmt>
<if>if <condition>(<expr><name>view</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>obj</name>-&gt;<name>ob_exports</name></name>++</expr>;</expr_stmt>
<return>return <expr>0</expr>;</return>
}</block></then></if>
<if>if <condition>(<expr><name><name>obj</name>-&gt;<name>ob_bytes</name></name> == <name>NULL</name></expr>)</condition><then>
<expr_stmt><expr><name>ptr</name> = ""</expr>;</expr_stmt></then>
<else>else
<expr_stmt><expr><name>ptr</name> = <name><name>obj</name>-&gt;<name>ob_bytes</name></name></expr>;</expr_stmt></else></if>
<expr_stmt><expr><name>ret</name> = <call><name>PyBuffer_FillInfo</name><argument_list>(<argument><expr><name>view</name></expr></argument>, <argument><expr>(<name>PyObject</name>*)<name>obj</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><call><name>Py_SIZE</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>ret</name> &gt;= 0</expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>obj</name>-&gt;<name>ob_exports</name></name>++</expr>;</expr_stmt>
}</block></then></if>
<return>return <expr><name>ret</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>bytes_releasebuffer</name><parameter_list>(<param><decl><type><name>PyByteArrayObject</name> *</type><name>obj</name></decl></param>, <param><decl><type><name>Py_buffer</name> *</type><name>view</name></decl></param>)</parameter_list> <block>{
<expr_stmt><expr><name><name>obj</name>-&gt;<name>ob_exports</name></name>--</expr>;</expr_stmt>
}</block></function>
<function><type><specifier>static</specifier> <name>Py_ssize_t</name></type>
<name>_getbuffer</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>obj</name></decl></param>, <param><decl><type><name>Py_buffer</name> *</type><name>view</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyBufferProcs</name> *</type><name>buffer</name> <init>= <expr><call><name>Py_TYPE</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call>-&gt;<name>tp_as_buffer</name></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>buffer</name> == <name>NULL</name> || <name><name>buffer</name>-&gt;<name>bf_getbuffer</name></name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
<argument><expr>"Type %.100s doesn't support the buffer API"</expr></argument>,
<argument><expr><call><name>Py_TYPE</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call>-&gt;<name>tp_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>-1</expr>;</return>
}</block></then></if>
<if>if <condition>(<expr><call><name><name>buffer</name>-&gt;<name>bf_getbuffer</name></name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>view</name></expr></argument>, <argument><expr><name>PyBUF_SIMPLE</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
<return>return <expr>-1</expr>;</return></then></if>
<return>return <expr><name><name>view</name>-&gt;<name>len</name></name></expr>;</return>
}</block></function>
<function><type><name>PyObject</name> *</type>
<name>PyByteArray_FromObject</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>input</name></decl></param>)</parameter_list> <block>{
<return>return <expr><call><name>PyObject_CallFunctionObjArgs</name><argument_list>(<argument><expr>(<name>PyObject</name> *)&amp;<name>PyByteArray_Type</name></expr></argument>,
<argument><expr><name>input</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><name>PyObject</name> *</type>
<name>PyByteArray_FromStringAndSize</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>bytes</name></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>size</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyByteArrayObject</name> *</type><name>new</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>alloc</name></decl>;</decl_stmt>
<if>if <condition>(<expr><name>size</name> &lt; 0</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_SystemError</name></expr></argument>,
<argument><expr>"Negative size passed to PyByteArray_FromStringAndSize"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>new</name> = <call><name>PyObject_New</name><argument_list>(<argument><expr><name>PyByteArrayObject</name></expr></argument>, <argument><expr>&amp;<name>PyByteArray_Type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>new</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<if>if <condition>(<expr><name>size</name> == 0</expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>new</name>-&gt;<name>ob_bytes</name></name> = <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name>alloc</name> = 0</expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr><name>alloc</name> = <name>size</name> + 1</expr>;</expr_stmt>
<expr_stmt><expr><name><name>new</name>-&gt;<name>ob_bytes</name></name> = <call><name>PyMem_Malloc</name><argument_list>(<argument><expr><name>alloc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>new</name>-&gt;<name>ob_bytes</name></name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>new</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>PyErr_NoMemory</name><argument_list>()</argument_list></call></expr>;</return>
}</block></then></if>
<if>if <condition>(<expr><name>bytes</name> != <name>NULL</name></expr>)</condition><then>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>new</name>-&gt;<name>ob_bytes</name></name></expr></argument>, <argument><expr><name>bytes</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<expr_stmt><expr><name><name>new</name>-&gt;<name>ob_bytes</name><index>[<expr><name>size</name></expr>]</index></name> = '\0'</expr>;</expr_stmt>
}</block></else></if>
<expr_stmt><expr><call><name>Py_SIZE</name><argument_list>(<argument><expr><name>new</name></expr></argument>)</argument_list></call> = <name>size</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>new</name>-&gt;<name>ob_alloc</name></name> = <name>alloc</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>new</name>-&gt;<name>ob_exports</name></name> = 0</expr>;</expr_stmt>
<return>return <expr>(<name>PyObject</name> *)<name>new</name></expr>;</return>
}</block></function>
<function><type><name>Py_ssize_t</name></type>
<name>PyByteArray_Size</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>)</parameter_list> <block>{
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>self</name> != <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>PyByteArray_Check</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>PyByteArray_GET_SIZE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><name>char</name> *</type>
<name>PyByteArray_AsString</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>)</parameter_list> <block>{
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>self</name> != <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>PyByteArray_Check</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>PyByteArray_AS_STRING</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><name>int</name></type>
<name>PyByteArray_Resize</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>size</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>void</name> *</type><name>sval</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>alloc</name> <init>= <expr>((<name>PyByteArrayObject</name> *)<name>self</name>)-&gt;<name>ob_alloc</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>self</name> != <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>PyByteArray_Check</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>size</name> &gt;= 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>size</name> &lt; <name>alloc</name> / 2</expr>)</condition><then> <block>{
<expr_stmt><expr><name>alloc</name> = <name>size</name> + 1</expr>;</expr_stmt>
}</block></then> <else>else <if>if <condition>(<expr><name>size</name> &lt; <name>alloc</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_SIZE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call> = <name>size</name></expr>;</expr_stmt>
<expr_stmt><expr>((<name>PyByteArrayObject</name> *)<name>self</name>)-&gt;<name><name>ob_bytes</name><index>[<expr><name>size</name></expr>]</index></name> = '\0'</expr>;</expr_stmt>
<return>return <expr>0</expr>;</return>
}</block></then> <else>else <if>if <condition>(<expr><name>size</name> &lt;= <name>alloc</name> * 1.125</expr>)</condition><then> <block>{
<expr_stmt><expr><name>alloc</name> = <name>size</name> + (<name>size</name> &gt;&gt; 3) + (<name>size</name> &lt; 9 ? 3 : 6)</expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr><name>alloc</name> = <name>size</name> + 1</expr>;</expr_stmt>
}</block></else></if></else></if></else></if>
<if>if <condition>(<expr>((<name>PyByteArrayObject</name> *)<name>self</name>)-&gt;<name>ob_exports</name> &gt; 0</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_BufferError</name></expr></argument>,
<argument><expr>"Existing exports of data: object cannot be re-sized"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>-1</expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>sval</name> = <call><name>PyMem_Realloc</name><argument_list>(<argument><expr>((<name>PyByteArrayObject</name> *)<name>self</name>)-&gt;<name>ob_bytes</name></expr></argument>, <argument><expr><name>alloc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>sval</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_NoMemory</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<return>return <expr>-1</expr>;</return>
}</block></then></if>
<expr_stmt><expr>((<name>PyByteArrayObject</name> *)<name>self</name>)-&gt;<name>ob_bytes</name> = <name>sval</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_SIZE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call> = <name>size</name></expr>;</expr_stmt>
<expr_stmt><expr>((<name>PyByteArrayObject</name> *)<name>self</name>)-&gt;<name>ob_alloc</name> = <name>alloc</name></expr>;</expr_stmt>
<expr_stmt><expr>((<name>PyByteArrayObject</name> *)<name>self</name>)-&gt;<name><name>ob_bytes</name><index>[<expr><name>size</name></expr>]</index></name> = '\0'</expr>;</expr_stmt>
<return>return <expr>0</expr>;</return>
}</block></function>
<function><type><name>PyObject</name> *</type>
<name>PyByteArray_Concat</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>a</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>b</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>size</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_buffer</name></type> <name>va</name></decl>, <decl><type ref="prev"/><name>vb</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyByteArrayObject</name> *</type><name>result</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>va</name>.<name>len</name></name> = -1</expr>;</expr_stmt>
<expr_stmt><expr><name><name>vb</name>.<name>len</name></name> = -1</expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>_getbuffer</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr>&amp;<name>va</name></expr></argument>)</argument_list></call> &lt; 0 ||
<call><name>_getbuffer</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr>&amp;<name>vb</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>, <argument><expr>"can't concat %.100s to %.100s"</expr></argument>,
<argument><expr><call><name>Py_TYPE</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call>-&gt;<name>tp_name</name></expr></argument>, <argument><expr><call><name>Py_TYPE</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call>-&gt;<name>tp_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>done</name>;</goto>
}</block></then></if>
<expr_stmt><expr><name>size</name> = <name><name>va</name>.<name>len</name></name> + <name><name>vb</name>.<name>len</name></name></expr>;</expr_stmt>
<if>if <condition>(<expr><name>size</name> &lt; 0</expr>)</condition><then> <block>{
<return>return <expr><call><name>PyErr_NoMemory</name><argument_list>()</argument_list></call></expr>;</return>
<goto>goto <name>done</name>;</goto>
}</block></then></if>
<expr_stmt><expr><name>result</name> = (<name>PyByteArrayObject</name> *) <call><name>PyByteArray_FromStringAndSize</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>result</name> != <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>result</name>-&gt;<name>ob_bytes</name></name></expr></argument>, <argument><expr><name><name>va</name>.<name>buf</name></name></expr></argument>, <argument><expr><name><name>va</name>.<name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>result</name>-&gt;<name>ob_bytes</name></name> + <name><name>va</name>.<name>len</name></name></expr></argument>, <argument><expr><name><name>vb</name>.<name>buf</name></name></expr></argument>, <argument><expr><name><name>vb</name>.<name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<label><name>done</name>:</label>
<if>if <condition>(<expr><name><name>va</name>.<name>len</name></name> != -1</expr>)</condition><then>
<expr_stmt><expr><call><name>PyBuffer_Release</name><argument_list>(<argument><expr>&amp;<name>va</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<if>if <condition>(<expr><name><name>vb</name>.<name>len</name></name> != -1</expr>)</condition><then>
<expr_stmt><expr><call><name>PyBuffer_Release</name><argument_list>(<argument><expr>&amp;<name>vb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<return>return <expr>(<name>PyObject</name> *)<name>result</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>Py_ssize_t</name></type>
<name>bytes_length</name><parameter_list>(<param><decl><type><name>PyByteArrayObject</name> *</type><name>self</name></decl></param>)</parameter_list> <block>{
<return>return <expr><call><name>Py_SIZE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>bytes_iconcat</name><parameter_list>(<param><decl><type><name>PyByteArrayObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>other</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>mysize</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>size</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_buffer</name></type> <name>vo</name></decl>;</decl_stmt>
<if>if <condition>(<expr><call><name>_getbuffer</name><argument_list>(<argument><expr><name>other</name></expr></argument>, <argument><expr>&amp;<name>vo</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>, <argument><expr>"can't concat %.100s to %.100s"</expr></argument>,
<argument><expr><call><name>Py_TYPE</name><argument_list>(<argument><expr><name>other</name></expr></argument>)</argument_list></call>-&gt;<name>tp_name</name></expr></argument>, <argument><expr><call><name>Py_TYPE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call>-&gt;<name>tp_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>mysize</name> = <call><name>Py_SIZE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>size</name> = <name>mysize</name> + <name><name>vo</name>.<name>len</name></name></expr>;</expr_stmt>
<if>if <condition>(<expr><name>size</name> &lt; 0</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyBuffer_Release</name><argument_list>(<argument><expr>&amp;<name>vo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>PyErr_NoMemory</name><argument_list>()</argument_list></call></expr>;</return>
}</block></then></if>
<if>if <condition>(<expr><name>size</name> &lt; <name><name>self</name>-&gt;<name>ob_alloc</name></name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_SIZE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call> = <name>size</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>self</name>-&gt;<name>ob_bytes</name><index>[<expr><call><name>Py_SIZE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>]</index></name> = '\0'</expr>;</expr_stmt>
}</block></then> <else>else <if>if <condition>(<expr><call><name>PyByteArray_Resize</name><argument_list>(<argument><expr>(<name>PyObject</name> *)<name>self</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyBuffer_Release</name><argument_list>(<argument><expr>&amp;<name>vo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if></else></if>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>ob_bytes</name></name> + <name>mysize</name></expr></argument>, <argument><expr><name><name>vo</name>.<name>buf</name></name></expr></argument>, <argument><expr><name><name>vo</name>.<name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyBuffer_Release</name><argument_list>(<argument><expr>&amp;<name>vo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>(<name>PyObject</name> *)<name>self</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>bytes_repeat</name><parameter_list>(<param><decl><type><name>PyByteArrayObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>count</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyByteArrayObject</name> *</type><name>result</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>mysize</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>size</name></decl>;</decl_stmt>
<if>if <condition>(<expr><name>count</name> &lt; 0</expr>)</condition><then>
<expr_stmt><expr><name>count</name> = 0</expr>;</expr_stmt></then></if>
<expr_stmt><expr><name>mysize</name> = <call><name>Py_SIZE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>size</name> = <name>mysize</name> * <name>count</name></expr>;</expr_stmt>
<if>if <condition>(<expr><name>count</name> != 0 &amp;&amp; <name>size</name> / <name>count</name> != <name>mysize</name></expr>)</condition><then>
<return>return <expr><call><name>PyErr_NoMemory</name><argument_list>()</argument_list></call></expr>;</return></then></if>
<expr_stmt><expr><name>result</name> = (<name>PyByteArrayObject</name> *)<call><name>PyByteArray_FromStringAndSize</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>result</name> != <name>NULL</name> &amp;&amp; <name>size</name> != 0</expr>)</condition><then> <block>{
<if>if <condition>(<expr><name>mysize</name> == 1</expr>)</condition><then>
<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>result</name>-&gt;<name>ob_bytes</name></name></expr></argument>, <argument><expr><name><name>self</name>-&gt;<name>ob_bytes</name><index>[<expr>0</expr>]</index></name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
<else>else <block>{
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>i</name></decl>;</decl_stmt>
<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>count</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>result</name>-&gt;<name>ob_bytes</name></name> + <name>i</name>*<name>mysize</name></expr></argument>, <argument><expr><name><name>self</name>-&gt;<name>ob_bytes</name></name></expr></argument>, <argument><expr><name>mysize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></for>
}</block></else></if>
}</block></then></if>
<return>return <expr>(<name>PyObject</name> *)<name>result</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>bytes_irepeat</name><parameter_list>(<param><decl><type><name>PyByteArrayObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>count</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>mysize</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>size</name></decl>;</decl_stmt>
<if>if <condition>(<expr><name>count</name> &lt; 0</expr>)</condition><then>
<expr_stmt><expr><name>count</name> = 0</expr>;</expr_stmt></then></if>
<expr_stmt><expr><name>mysize</name> = <call><name>Py_SIZE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>size</name> = <name>mysize</name> * <name>count</name></expr>;</expr_stmt>
<if>if <condition>(<expr><name>count</name> != 0 &amp;&amp; <name>size</name> / <name>count</name> != <name>mysize</name></expr>)</condition><then>
<return>return <expr><call><name>PyErr_NoMemory</name><argument_list>()</argument_list></call></expr>;</return></then></if>
<if>if <condition>(<expr><name>size</name> &lt; <name><name>self</name>-&gt;<name>ob_alloc</name></name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_SIZE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call> = <name>size</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>self</name>-&gt;<name>ob_bytes</name><index>[<expr><call><name>Py_SIZE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>]</index></name> = '\0'</expr>;</expr_stmt>
}</block></then> <else>else <if>if <condition>(<expr><call><name>PyByteArray_Resize</name><argument_list>(<argument><expr>(<name>PyObject</name> *)<name>self</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if></else></if>
<if>if <condition>(<expr><name>mysize</name> == 1</expr>)</condition><then>
<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>ob_bytes</name></name></expr></argument>, <argument><expr><name><name>self</name>-&gt;<name>ob_bytes</name><index>[<expr>0</expr>]</index></name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
<else>else <block>{
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>i</name></decl>;</decl_stmt>
<for>for (<init><expr><name>i</name> = 1</expr>;</init> <condition><expr><name>i</name> &lt; <name>count</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>ob_bytes</name></name> + <name>i</name>*<name>mysize</name></expr></argument>, <argument><expr><name><name>self</name>-&gt;<name>ob_bytes</name></name></expr></argument>, <argument><expr><name>mysize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></for>
}</block></else></if>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>(<name>PyObject</name> *)<name>self</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>bytes_getitem</name><parameter_list>(<param><decl><type><name>PyByteArrayObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>i</name></decl></param>)</parameter_list> <block>{
<if>if <condition>(<expr><name>i</name> &lt; 0</expr>)</condition><then>
<expr_stmt><expr><name>i</name> += <call><name>Py_SIZE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<if>if <condition>(<expr><name>i</name> &lt; 0 || <name>i</name> &gt;= <call><name>Py_SIZE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_IndexError</name></expr></argument>, <argument><expr>"bytearray index out of range"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<return>return <expr><call><name>PyInt_FromLong</name><argument_list>(<argument><expr><call>(<name>unsigned</name> <name>char</name>)<argument_list>(<argument><expr><name><name>self</name>-&gt;<name>ob_bytes</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>bytes_subscript</name><parameter_list>(<param><decl><type><name>PyByteArrayObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>index</name></decl></param>)</parameter_list> <block>{
<if>if <condition>(<expr><call><name>PyIndex_Check</name><argument_list>(<argument><expr><name>index</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>i</name> <init>= <expr><call><name>PyNumber_AsSsize_t</name><argument_list>(<argument><expr><name>index</name></expr></argument>, <argument><expr><name>PyExc_IndexError</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>i</name> == -1 &amp;&amp; <call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<if>if <condition>(<expr><name>i</name> &lt; 0</expr>)</condition><then>
<expr_stmt><expr><name>i</name> += <call><name>PyByteArray_GET_SIZE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<if>if <condition>(<expr><name>i</name> &lt; 0 || <name>i</name> &gt;= <call><name>Py_SIZE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_IndexError</name></expr></argument>, <argument><expr>"bytearray index out of range"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<return>return <expr><call><name>PyInt_FromLong</name><argument_list>(<argument><expr><call>(<name>unsigned</name> <name>char</name>)<argument_list>(<argument><expr><name><name>self</name>-&gt;<name>ob_bytes</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></then> <else>else <if>if <condition>(<expr><call><name>PySlice_Check</name><argument_list>(<argument><expr><name>index</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>start</name></decl>, <decl><type ref="prev"/><name>stop</name></decl>, <decl><type ref="prev"/><name>step</name></decl>, <decl><type ref="prev"/><name>slicelength</name></decl>, <decl><type ref="prev"/><name>cur</name></decl>, <decl><type ref="prev"/><name>i</name></decl>;</decl_stmt>
<if>if <condition>(<expr><call><name>PySlice_GetIndicesEx</name><argument_list>(<argument><expr>(<name>PySliceObject</name> *)<name>index</name></expr></argument>,
<argument><expr><call><name>PyByteArray_GET_SIZE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr>&amp;<name>start</name></expr></argument>, <argument><expr>&amp;<name>stop</name></expr></argument>, <argument><expr>&amp;<name>step</name></expr></argument>, <argument><expr>&amp;<name>slicelength</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then> <block>{
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<if>if <condition>(<expr><name>slicelength</name> &lt;= 0</expr>)</condition><then>
<return>return <expr><call><name>PyByteArray_FromStringAndSize</name><argument_list>(<argument><expr>""</expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</return></then>
<else>else <if>if <condition>(<expr><name>step</name> == 1</expr>)</condition><then> <block>{
<return>return <expr><call><name>PyByteArray_FromStringAndSize</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>ob_bytes</name></name> + <name>start</name></expr></argument>,
<argument><expr><name>slicelength</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></then> <else>else <block>{
<decl_stmt><decl><type><name>char</name> *</type><name>source_buf</name> <init>= <expr><call><name>PyByteArray_AS_STRING</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>result_buf</name> <init>= <expr>(<name>char</name> *)<call><name>PyMem_Malloc</name><argument_list>(<argument><expr><name>slicelength</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>result</name></decl>;</decl_stmt>
<if>if <condition>(<expr><name>result_buf</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><call><name>PyErr_NoMemory</name><argument_list>()</argument_list></call></expr>;</return></then></if>
<for>for (<init><expr><name>cur</name> = <name>start</name></expr>, <expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>slicelength</name></expr>;</condition>
<incr><expr><name>cur</name> += <name>step</name></expr>, <expr><name>i</name>++</expr></incr>) <block>{
<expr_stmt><expr><name><name>result_buf</name><index>[<expr><name>i</name></expr>]</index></name> = <name><name>source_buf</name><index>[<expr><name>cur</name></expr>]</index></name></expr>;</expr_stmt>
}</block></for>
<expr_stmt><expr><name>result</name> = <call><name>PyByteArray_FromStringAndSize</name><argument_list>(<argument><expr><name>result_buf</name></expr></argument>, <argument><expr><name>slicelength</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyMem_Free</name><argument_list>(<argument><expr><name>result_buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>result</name></expr>;</return>
}</block></else></if></else></if>
}</block></then> <else>else <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>, <argument><expr>"bytearray indices must be integers"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></else></if></else></if>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>bytes_setslice</name><parameter_list>(<param><decl><type><name>PyByteArrayObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>lo</name></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>hi</name></decl></param>,
<param><decl><type><name>PyObject</name> *</type><name>values</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>avail</name></decl>, <decl><type ref="prev"/><name>needed</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>void</name> *</type><name>bytes</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_buffer</name></type> <name>vbytes</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>res</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>vbytes</name>.<name>len</name></name> = -1</expr>;</expr_stmt>
<if>if <condition>(<expr><name>values</name> == (<name>PyObject</name> *)<name>self</name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>err</name></decl>;</decl_stmt>
<expr_stmt><expr><name>values</name> = <call><name>PyByteArray_FromObject</name><argument_list>(<argument><expr><name>values</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>values</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr>-1</expr>;</return></then></if>
<expr_stmt><expr><name>err</name> = <call><name>bytes_setslice</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>lo</name></expr></argument>, <argument><expr><name>hi</name></expr></argument>, <argument><expr><name>values</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>values</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>err</name></expr>;</return>
}</block></then></if>
<if>if <condition>(<expr><name>values</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>bytes</name> = <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name>needed</name> = 0</expr>;</expr_stmt>
}</block></then> <else>else <block>{
<if>if <condition>(<expr><call><name>_getbuffer</name><argument_list>(<argument><expr><name>values</name></expr></argument>, <argument><expr>&amp;<name>vbytes</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
<argument><expr>"can't set bytearray slice from %.100s"</expr></argument>,
<argument><expr><call><name>Py_TYPE</name><argument_list>(<argument><expr><name>values</name></expr></argument>)</argument_list></call>-&gt;<name>tp_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>-1</expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>needed</name> = <name><name>vbytes</name>.<name>len</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>bytes</name> = <name><name>vbytes</name>.<name>buf</name></name></expr>;</expr_stmt>
}</block></else></if>
<if>if <condition>(<expr><name>lo</name> &lt; 0</expr>)</condition><then>
<expr_stmt><expr><name>lo</name> = 0</expr>;</expr_stmt></then></if>
<if>if <condition>(<expr><name>hi</name> &lt; <name>lo</name></expr>)</condition><then>
<expr_stmt><expr><name>hi</name> = <name>lo</name></expr>;</expr_stmt></then></if>
<if>if <condition>(<expr><name>hi</name> &gt; <call><name>Py_SIZE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<expr_stmt><expr><name>hi</name> = <call><name>Py_SIZE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<expr_stmt><expr><name>avail</name> = <name>hi</name> - <name>lo</name></expr>;</expr_stmt>
<if>if <condition>(<expr><name>avail</name> &lt; 0</expr>)</condition><then>
<expr_stmt><expr><name>lo</name> = <name>hi</name> = <name>avail</name> = 0</expr>;</expr_stmt></then></if>
<if>if <condition>(<expr><name>avail</name> != <name>needed</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr><name>avail</name> &gt; <name>needed</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>ob_bytes</name></name> + <name>lo</name> + <name>needed</name></expr></argument>, <argument><expr><name><name>self</name>-&gt;<name>ob_bytes</name></name> + <name>hi</name></expr></argument>,
<argument><expr><call><name>Py_SIZE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call> - <name>hi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<if>if <condition>(<expr><call><name>PyByteArray_Resize</name><argument_list>(<argument><expr>(<name>PyObject</name> *)<name>self</name></expr></argument>,
<argument><expr><call><name>Py_SIZE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call> + <name>needed</name> - <name>avail</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then> <block>{
<expr_stmt><expr><name>res</name> = -1</expr>;</expr_stmt>
<goto>goto <name>finish</name>;</goto>
}</block></then></if>
<if>if <condition>(<expr><name>avail</name> &lt; <name>needed</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>ob_bytes</name></name> + <name>lo</name> + <name>needed</name></expr></argument>, <argument><expr><name><name>self</name>-&gt;<name>ob_bytes</name></name> + <name>hi</name></expr></argument>,
<argument><expr><call><name>Py_SIZE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call> - <name>lo</name> - <name>needed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
}</block></then></if>
<if>if <condition>(<expr><name>needed</name> &gt; 0</expr>)</condition><then>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>ob_bytes</name></name> + <name>lo</name></expr></argument>, <argument><expr><name>bytes</name></expr></argument>, <argument><expr><name>needed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<label><name>finish</name>:</label>
<if>if <condition>(<expr><name><name>vbytes</name>.<name>len</name></name> != -1</expr>)</condition><then>
<expr_stmt><expr><call><name>PyBuffer_Release</name><argument_list>(<argument><expr>&amp;<name>vbytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<return>return <expr><name>res</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>bytes_setitem</name><parameter_list>(<param><decl><type><name>PyByteArrayObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>i</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>value</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>ival</name></decl>;</decl_stmt>
<if>if <condition>(<expr><name>i</name> &lt; 0</expr>)</condition><then>
<expr_stmt><expr><name>i</name> += <call><name>Py_SIZE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<if>if <condition>(<expr><name>i</name> &lt; 0 || <name>i</name> &gt;= <call><name>Py_SIZE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_IndexError</name></expr></argument>, <argument><expr>"bytearray index out of range"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>-1</expr>;</return>
}</block></then></if>
<if>if <condition>(<expr><name>value</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><call><name>bytes_setslice</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i</name>+1</expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
<if>if <condition>(<expr>!<call><name>_getbytevalue</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr>&amp;<name>ival</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr>-1</expr>;</return></then></if>
<expr_stmt><expr><name><name>self</name>-&gt;<name>ob_bytes</name><index>[<expr><name>i</name></expr>]</index></name> = <name>ival</name></expr>;</expr_stmt>
<return>return <expr>0</expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>bytes_ass_subscript</name><parameter_list>(<param><decl><type><name>PyByteArrayObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>index</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>values</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>start</name></decl>, <decl><type ref="prev"/><name>stop</name></decl>, <decl><type ref="prev"/><name>step</name></decl>, <decl><type ref="prev"/><name>slicelen</name></decl>, <decl><type ref="prev"/><name>needed</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>bytes</name></decl>;</decl_stmt>
<if>if <condition>(<expr><call><name>PyIndex_Check</name><argument_list>(<argument><expr><name>index</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>i</name> <init>= <expr><call><name>PyNumber_AsSsize_t</name><argument_list>(<argument><expr><name>index</name></expr></argument>, <argument><expr><name>PyExc_IndexError</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>i</name> == -1 &amp;&amp; <call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then>
<return>return <expr>-1</expr>;</return></then></if>
<if>if <condition>(<expr><name>i</name> &lt; 0</expr>)</condition><then>
<expr_stmt><expr><name>i</name> += <call><name>PyByteArray_GET_SIZE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<if>if <condition>(<expr><name>i</name> &lt; 0 || <name>i</name> &gt;= <call><name>Py_SIZE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_IndexError</name></expr></argument>, <argument><expr>"bytearray index out of range"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>-1</expr>;</return>
}</block></then></if>
<if>if <condition>(<expr><name>values</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>start</name> = <name>i</name></expr>;</expr_stmt>
<expr_stmt><expr><name>stop</name> = <name>i</name> + 1</expr>;</expr_stmt>
<expr_stmt><expr><name>step</name> = 1</expr>;</expr_stmt>
<expr_stmt><expr><name>slicelen</name> = 1</expr>;</expr_stmt>
}</block></then> <else>else <block>{
<decl_stmt><decl><type><name>int</name></type> <name>ival</name></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>_getbytevalue</name><argument_list>(<argument><expr><name>values</name></expr></argument>, <argument><expr>&amp;<name>ival</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr>-1</expr>;</return></then></if>
<expr_stmt><expr><name><name>self</name>-&gt;<name>ob_bytes</name><index>[<expr><name>i</name></expr>]</index></name> = (<name>char</name>)<name>ival</name></expr>;</expr_stmt>
<return>return <expr>0</expr>;</return>
}</block></else></if>
}</block></then> <else>else <if>if <condition>(<expr><call><name>PySlice_Check</name><argument_list>(<argument><expr><name>index</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<if>if <condition>(<expr><call><name>PySlice_GetIndicesEx</name><argument_list>(<argument><expr>(<name>PySliceObject</name> *)<name>index</name></expr></argument>,
<argument><expr><call><name>PyByteArray_GET_SIZE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr>&amp;<name>start</name></expr></argument>, <argument><expr>&amp;<name>stop</name></expr></argument>, <argument><expr>&amp;<name>step</name></expr></argument>, <argument><expr>&amp;<name>slicelen</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then> <block>{
<return>return <expr>-1</expr>;</return>
}</block></then></if>
}</block></then> <else>else <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>, <argument><expr>"bytearray indices must be integer"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>-1</expr>;</return>
}</block></else></if></else></if>
<if>if <condition>(<expr><name>values</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>bytes</name> = <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name>needed</name> = 0</expr>;</expr_stmt>
}</block></then> <else>else <if>if <condition>(<expr><name>values</name> == (<name>PyObject</name> *)<name>self</name> || !<call><name>PyByteArray_Check</name><argument_list>(<argument><expr><name>values</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>err</name></decl>;</decl_stmt>
<expr_stmt><expr><name>values</name> = <call><name>PyByteArray_FromObject</name><argument_list>(<argument><expr><name>values</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>values</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr>-1</expr>;</return></then></if>
<expr_stmt><expr><name>err</name> = <call><name>bytes_ass_subscript</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>index</name></expr></argument>, <argument><expr><name>values</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>values</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>err</name></expr>;</return>
}</block></then> <else>else <block>{
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>PyByteArray_Check</name><argument_list>(<argument><expr><name>values</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>bytes</name> = ((<name>PyByteArrayObject</name> *)<name>values</name>)-&gt;<name>ob_bytes</name></expr>;</expr_stmt>
<expr_stmt><expr><name>needed</name> = <call><name>Py_SIZE</name><argument_list>(<argument><expr><name>values</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></else></if></else></if>
<if>if <condition>(<expr>(<name>step</name> &lt; 0 &amp;&amp; <name>start</name> &lt; <name>stop</name>) ||
(<name>step</name> &gt; 0 &amp;&amp; <name>start</name> &gt; <name>stop</name>)</expr>)</condition><then>
<expr_stmt><expr><name>stop</name> = <name>start</name></expr>;</expr_stmt></then></if>
<if>if <condition>(<expr><name>step</name> == 1</expr>)</condition><then> <block>{
<if>if <condition>(<expr><name>slicelen</name> != <name>needed</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr><name>slicelen</name> &gt; <name>needed</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>ob_bytes</name></name> + <name>start</name> + <name>needed</name></expr></argument>, <argument><expr><name><name>self</name>-&gt;<name>ob_bytes</name></name> + <name>stop</name></expr></argument>,
<argument><expr><call><name>Py_SIZE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call> - <name>stop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<if>if <condition>(<expr><call><name>PyByteArray_Resize</name><argument_list>(<argument><expr>(<name>PyObject</name> *)<name>self</name></expr></argument>,
<argument><expr><call><name>Py_SIZE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call> + <name>needed</name> - <name>slicelen</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
<return>return <expr>-1</expr>;</return></then></if>
<if>if <condition>(<expr><name>slicelen</name> &lt; <name>needed</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>ob_bytes</name></name> + <name>start</name> + <name>needed</name></expr></argument>, <argument><expr><name><name>self</name>-&gt;<name>ob_bytes</name></name> + <name>stop</name></expr></argument>,
<argument><expr><call><name>Py_SIZE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call> - <name>start</name> - <name>needed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
}</block></then></if>
<if>if <condition>(<expr><name>needed</name> &gt; 0</expr>)</condition><then>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>ob_bytes</name></name> + <name>start</name></expr></argument>, <argument><expr><name>bytes</name></expr></argument>, <argument><expr><name>needed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<return>return <expr>0</expr>;</return>
}</block></then> <else>else <block>{
<if>if <condition>(<expr><name>needed</name> == 0</expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>cur</name></decl>, <decl><type ref="prev"/><name>i</name></decl>;</decl_stmt>
<if>if <condition>(<expr><name>step</name> &lt; 0</expr>)</condition><then> <block>{
<expr_stmt><expr><name>stop</name> = <name>start</name> + 1</expr>;</expr_stmt>
<expr_stmt><expr><name>start</name> = <name>stop</name> + <call><name>step</name> * <argument_list>(<argument><expr><name>slicelen</name> - 1</expr></argument>)</argument_list></call> - 1</expr>;</expr_stmt>
<expr_stmt><expr><name>step</name> = -<name>step</name></expr>;</expr_stmt>
}</block></then></if>
<for>for (<init><expr><name>cur</name> = <name>start</name></expr>, <expr><name>i</name> = 0</expr>;</init>
<condition><expr><name>i</name> &lt; <name>slicelen</name></expr>;</condition> <incr><expr><name>cur</name> += <name>step</name></expr>, <expr><name>i</name>++</expr></incr>) <block>{
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>lim</name> <init>= <expr><name>step</name> - 1</expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>cur</name> + <name>step</name> &gt;= <call><name>PyByteArray_GET_SIZE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<expr_stmt><expr><name>lim</name> = <call><name>PyByteArray_GET_SIZE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call> - <name>cur</name> - 1</expr>;</expr_stmt></then></if>
<expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>ob_bytes</name></name> + <name>cur</name> - <name>i</name></expr></argument>,
<argument><expr><name><name>self</name>-&gt;<name>ob_bytes</name></name> + <name>cur</name> + 1</expr></argument>, <argument><expr><name>lim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></for>
<expr_stmt><expr><name>cur</name> = <name>start</name> + <name>slicelen</name>*<name>step</name></expr>;</expr_stmt>
<if>if <condition>(<expr><name>cur</name> &lt; <call><name>PyByteArray_GET_SIZE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>ob_bytes</name></name> + <name>cur</name> - <name>slicelen</name></expr></argument>,
<argument><expr><name><name>self</name>-&gt;<name>ob_bytes</name></name> + <name>cur</name></expr></argument>,
<argument><expr><call><name>PyByteArray_GET_SIZE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call> - <name>cur</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<if>if <condition>(<expr><call><name>PyByteArray_Resize</name><argument_list>(<argument><expr>(<name>PyObject</name> *)<name>self</name></expr></argument>,
<argument><expr><call><name>PyByteArray_GET_SIZE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call> - <name>slicelen</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
<return>return <expr>-1</expr>;</return></then></if>
<return>return <expr>0</expr>;</return>
}</block></then> <else>else <block>{
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>cur</name></decl>, <decl><type ref="prev"/><name>i</name></decl>;</decl_stmt>
<if>if <condition>(<expr><name>needed</name> != <name>slicelen</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>,
<argument><expr>"attempt to assign bytes of size %zd "
"to extended slice of size %zd"</expr></argument>,
<argument><expr><name>needed</name></expr></argument>, <argument><expr><name>slicelen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>-1</expr>;</return>
}</block></then></if>
<for>for (<init><expr><name>cur</name> = <name>start</name></expr>, <expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>slicelen</name></expr>;</condition> <incr><expr><name>cur</name> += <name>step</name></expr>, <expr><name>i</name>++</expr></incr>)
<expr_stmt><expr><name><name>self</name>-&gt;<name>ob_bytes</name><index>[<expr><name>cur</name></expr>]</index></name> = <name><name>bytes</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt></for>
<return>return <expr>0</expr>;</return>
}</block></else></if>
}</block></else></if>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>bytes_init</name><parameter_list>(<param><decl><type><name>PyByteArrayObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>kwds</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> *</type><name><name>kwlist</name><index>[]</index></name> <init>= <expr><block>{<expr>"source"</expr>, <expr>"encoding"</expr>, <expr>"errors"</expr>, <expr>0</expr>}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>arg</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>encoding</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>errors</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>count</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>it</name></decl>;</decl_stmt>
<function_decl><type><name>PyObject</name> *</type>(*<name>iternext</name>)<parameter_list>(<param><decl><type><name>PyObject</name> *</type></decl></param>)</parameter_list>;</function_decl>
<if>if <condition>(<expr><call><name>Py_SIZE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call> != 0</expr>)</condition><then> <block>{
<if>if <condition>(<expr><call><name>PyByteArray_Resize</name><argument_list>(<argument><expr>(<name>PyObject</name> *)<name>self</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
<return>return <expr>-1</expr>;</return></then></if>
}</block></then></if>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTupleAndKeywords</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>kwds</name></expr></argument>, <argument><expr>"|Oss:bytearray"</expr></argument>, <argument><expr><name>kwlist</name></expr></argument>,
<argument><expr>&amp;<name>arg</name></expr></argument>, <argument><expr>&amp;<name>encoding</name></expr></argument>, <argument><expr>&amp;<name>errors</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr>-1</expr>;</return></then></if>
<if>if <condition>(<expr><name>arg</name> == <name>NULL</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr><name>encoding</name> != <name>NULL</name> || <name>errors</name> != <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
<argument><expr>"encoding or errors without sequence argument"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>-1</expr>;</return>
}</block></then></if>
<return>return <expr>0</expr>;</return>
}</block></then></if>
<if>if <condition>(<expr><call><name>PyBytes_Check</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>new</name></decl>, *<decl><type ref="prev"/><name>encoded</name></decl>;</decl_stmt>
<if>if <condition>(<expr><name>encoding</name> != <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>encoded</name> = <call><name>PyCodec_Encode</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><name>encoding</name></expr></argument>, <argument><expr><name>errors</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>encoded</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr>-1</expr>;</return></then></if>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>PyBytes_Check</name><argument_list>(<argument><expr><name>encoded</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr><name>encoded</name> = <name>arg</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></else></if>
<expr_stmt><expr><name>new</name> = <call><name>bytes_iconcat</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>encoded</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>new</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr>-1</expr>;</return></then></if>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>new</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>0</expr>;</return>
}</block></then></if>
<if>if <condition>(<expr><call><name>PyUnicode_Check</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>encoded</name></decl>, *<decl><type ref="prev"/><name>new</name></decl>;</decl_stmt>
<if>if <condition>(<expr><name>encoding</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
<argument><expr>"unicode argument without an encoding"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>-1</expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>encoded</name> = <call><name>PyCodec_Encode</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><name>encoding</name></expr></argument>, <argument><expr><name>errors</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>encoded</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr>-1</expr>;</return></then></if>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>PyBytes_Check</name><argument_list>(<argument><expr><name>encoded</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>new</name> = <call><name>bytes_iconcat</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>encoded</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>encoded</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>new</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr>-1</expr>;</return></then></if>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>new</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>0</expr>;</return>
}</block></then></if>
<if>if <condition>(<expr><name>encoding</name> != <name>NULL</name> || <name>errors</name> != <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
<argument><expr>"encoding or errors without a string argument"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>-1</expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>count</name> = <call><name>PyNumber_AsSsize_t</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><name>PyExc_ValueError</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>count</name> == -1 &amp;&amp; <call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then>
<expr_stmt><expr><call><name>PyErr_Clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then>
<else>else <block>{
<if>if <condition>(<expr><name>count</name> &lt; 0</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>, <argument><expr>"negative count"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>-1</expr>;</return>
}</block></then></if>
<if>if <condition>(<expr><name>count</name> &gt; 0</expr>)</condition><then> <block>{
<if>if <condition>(<expr><call><name>PyByteArray_Resize</name><argument_list>(<argument><expr>(<name>PyObject</name> *)<name>self</name></expr></argument>, <argument><expr><name>count</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr>-1</expr>;</return></then></if>
<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>ob_bytes</name></name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<return>return <expr>0</expr>;</return>
}</block></else></if>
<if>if <condition>(<expr><call><name>PyObject_CheckBuffer</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>size</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_buffer</name></type> <name>view</name></decl>;</decl_stmt>
<if>if <condition>(<expr><call><name>PyObject_GetBuffer</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr>&amp;<name>view</name></expr></argument>, <argument><expr><name>PyBUF_FULL_RO</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
<return>return <expr>-1</expr>;</return></then></if>
<expr_stmt><expr><name>size</name> = <name><name>view</name>.<name>len</name></name></expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>PyByteArray_Resize</name><argument_list>(<argument><expr>(<name>PyObject</name> *)<name>self</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then> <goto>goto <name>fail</name>;</goto></then></if>
<if>if <condition>(<expr><call><name>PyBuffer_ToContiguous</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>ob_bytes</name></name></expr></argument>, <argument><expr>&amp;<name>view</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr>'C'</expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
<goto>goto <name>fail</name>;</goto></then></if>
<expr_stmt><expr><call><name>PyBuffer_Release</name><argument_list>(<argument><expr>&amp;<name>view</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>0</expr>;</return>
<label><name>fail</name>:</label>
<expr_stmt><expr><call><name>PyBuffer_Release</name><argument_list>(<argument><expr>&amp;<name>view</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>-1</expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>it</name> = <call><name>PyObject_GetIter</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>it</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr>-1</expr>;</return></then></if>
<expr_stmt><expr><name>iternext</name> = *<call><name>Py_TYPE</name><argument_list>(<argument><expr><name>it</name></expr></argument>)</argument_list></call>-&gt;<name>tp_iternext</name></expr>;</expr_stmt>
<for>for (<init>;</init><condition>;</condition><incr/>) <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>item</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>, <decl><type ref="prev"/><name>value</name></decl>;</decl_stmt>
<expr_stmt><expr><name>item</name> = <call><name>iternext</name><argument_list>(<argument><expr><name>it</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>item</name> == <name>NULL</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr><call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
<if>if <condition>(<expr>!<call><name>PyErr_ExceptionMatches</name><argument_list>(<argument><expr><name>PyExc_StopIteration</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<goto>goto <name>error</name>;</goto></then></if>
<expr_stmt><expr><call><name>PyErr_Clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<break>break;</break>
}</block></then></if>
<expr_stmt><expr><name>rc</name> = <call><name>_getbytevalue</name><argument_list>(<argument><expr><name>item</name></expr></argument>, <argument><expr>&amp;<name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>rc</name></expr>)</condition><then>
<goto>goto <name>error</name>;</goto></then></if>
<if>if <condition>(<expr><call><name>Py_SIZE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call> &lt; <name><name>self</name>-&gt;<name>ob_alloc</name></name></expr>)</condition><then>
<expr_stmt><expr><call><name>Py_SIZE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call>++</expr>;</expr_stmt></then>
<else>else <if>if <condition>(<expr><call><name>PyByteArray_Resize</name><argument_list>(<argument><expr>(<name>PyObject</name> *)<name>self</name></expr></argument>, <argument><expr><call><name>Py_SIZE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call>+1</expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
<goto>goto <name>error</name>;</goto></then></if></else></if>
<expr_stmt><expr><name><name>self</name>-&gt;<name>ob_bytes</name><index>[<expr><call><name>Py_SIZE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call>-1</expr>]</index></name> = <name>value</name></expr>;</expr_stmt>
}</block></for>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>it</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>0</expr>;</return>
<label><name>error</name>:</label>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>it</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>-1</expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>bytes_repr</name><parameter_list>(<param><decl><type><name>PyByteArrayObject</name> *</type><name>self</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> *</type><name>hexdigits</name> <init>= <expr>"0123456789abcdef"</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>quote_prefix</name> <init>= <expr>"bytearray(b"</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>quote_postfix</name> <init>= <expr>")"</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>length</name> <init>= <expr><call><name>Py_SIZE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>newsize</name> <init>= <expr>14 + 4 * <name>length</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>v</name></decl>;</decl_stmt>
<if>if <condition>(<expr><name>newsize</name> &gt; <name>PY_SSIZE_T_MAX</name> || <name>newsize</name> / 4 - 3 != <name>length</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_OverflowError</name></expr></argument>,
<argument><expr>"bytearray object is too large to make repr"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>v</name> = <call><name>PyUnicode_FromUnicode</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>newsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>v</name> == <name>NULL</name></expr>)</condition><then> <block>{
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then> <else>else <block>{
<decl_stmt><decl><type><name>register</name> <name>Py_ssize_t</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>register</name> <name>Py_UNICODE</name></type> <name>c</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>register</name> <name>Py_UNICODE</name> *</type><name>p</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>quote</name></decl>;</decl_stmt>
<expr_stmt><expr><name>quote</name> = '\''</expr>;</expr_stmt>
<block>{
<decl_stmt><decl><type><name>char</name> *</type><name>test</name></decl>, *<decl><type ref="prev"/><name>start</name></decl>;</decl_stmt>
<expr_stmt><expr><name>start</name> = <call><name>PyByteArray_AS_STRING</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for (<init><expr><name>test</name> = <name>start</name></expr>;</init> <condition><expr><name>test</name> &lt; <name>start</name>+<name>length</name></expr>;</condition> <incr><expr>++<name>test</name></expr></incr>) <block>{
<if>if <condition>(<expr>*<name>test</name> == '"'</expr>)</condition><then> <block>{
<expr_stmt><expr><name>quote</name> = '\''</expr>;</expr_stmt>
<goto>goto <name>decided</name>;</goto>
}</block></then> <else>else <if>if <condition>(<expr>*<name>test</name> == '\''</expr>)</condition><then>
<expr_stmt><expr><name>quote</name> = '"'</expr>;</expr_stmt></then></if></else></if>
}</block></for>
<label><name>decided</name>:</label>
<empty_stmt>;</empty_stmt>
}</block>
<expr_stmt><expr><name>p</name> = <call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<while>while <condition>(<expr>*<name>quote_prefix</name></expr>)</condition>
<expr_stmt><expr>*<name>p</name>++ = *<name>quote_prefix</name>++</expr>;</expr_stmt></while>
<expr_stmt><expr>*<name>p</name>++ = <name>quote</name></expr>;</expr_stmt>
<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>length</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>newsize</name> - (<name>p</name> - <call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call>) &gt;= 5</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>c</name> = <name><name>self</name>-&gt;<name>ob_bytes</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
<if>if <condition>(<expr><name>c</name> == '\'' || <name>c</name> == '\\'</expr>)</condition><then>
<expr_stmt><expr>*<name>p</name>++ = '\\'</expr>, <expr>*<name>p</name>++ = <name>c</name></expr>;</expr_stmt></then>
<else>else <if>if <condition>(<expr><name>c</name> == '\t'</expr>)</condition><then>
<expr_stmt><expr>*<name>p</name>++ = '\\'</expr>, <expr>*<name>p</name>++ = 't'</expr>;</expr_stmt></then>
<else>else <if>if <condition>(<expr><name>c</name> == '\n'</expr>)</condition><then>
<expr_stmt><expr>*<name>p</name>++ = '\\'</expr>, <expr>*<name>p</name>++ = 'n'</expr>;</expr_stmt></then>
<else>else <if>if <condition>(<expr><name>c</name> == '\r'</expr>)</condition><then>
<expr_stmt><expr>*<name>p</name>++ = '\\'</expr>, <expr>*<name>p</name>++ = 'r'</expr>;</expr_stmt></then>
<else>else <if>if <condition>(<expr><name>c</name> == 0</expr>)</condition><then>
<expr_stmt><expr>*<name>p</name>++ = '\\'</expr>, <expr>*<name>p</name>++ = 'x'</expr>, <expr>*<name>p</name>++ = '0'</expr>, <expr>*<name>p</name>++ = '0'</expr>;</expr_stmt></then>
<else>else <if>if <condition>(<expr><name>c</name> &lt; ' ' || <name>c</name> &gt;= 0x7f</expr>)</condition><then> <block>{
<expr_stmt><expr>*<name>p</name>++ = '\\'</expr>;</expr_stmt>
<expr_stmt><expr>*<name>p</name>++ = 'x'</expr>;</expr_stmt>
<expr_stmt><expr>*<name>p</name>++ = <name><name>hexdigits</name><index>[<expr>(<name>c</name> &amp; 0xf0) &gt;&gt; 4</expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr>*<name>p</name>++ = <name><name>hexdigits</name><index>[<expr><name>c</name> &amp; 0xf</expr>]</index></name></expr>;</expr_stmt>
}</block></then> <else>else
<expr_stmt><expr>*<name>p</name>++ = <name>c</name></expr>;</expr_stmt></else></if></else></if></else></if></else></if></else></if></else></if>
}</block></for>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>newsize</name> - (<name>p</name> - <call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call>) &gt;= 1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr>*<name>p</name>++ = <name>quote</name></expr>;</expr_stmt>
<while>while <condition>(<expr>*<name>quote_postfix</name></expr>)</condition> <block>{
<expr_stmt><expr>*<name>p</name>++ = *<name>quote_postfix</name>++</expr>;</expr_stmt>
}</block></while>
<expr_stmt><expr>*<name>p</name> = '\0'</expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>PyUnicode_Resize</name><argument_list>(<argument><expr>&amp;<name>v</name></expr></argument>, <argument><expr>(<name>p</name> - <call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call>)</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<return>return <expr><name>v</name></expr>;</return>
}</block></else></if>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>bytes_str</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>op</name></decl></param>)</parameter_list> <block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>0</expr></cpp:if>
if (Py_BytesWarningFlag) {
if (PyErr_WarnEx(PyExc_BytesWarning,
"str() on a bytearray instance", 1))
return NULL;
}
return bytes_repr((PyByteArrayObject*)op);
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<return>return <expr><call><name>PyBytes_FromStringAndSize</name><argument_list>(<argument><expr>((<name>PyByteArrayObject</name>*)<name>op</name>)-&gt;<name>ob_bytes</name></expr></argument>, <argument><expr><call><name>Py_SIZE</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>bytes_richcompare</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>other</name></decl></param>, <param><decl><type><name>int</name></type> <name>op</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>self_size</name></decl>, <decl><type ref="prev"/><name>other_size</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_buffer</name></type> <name>self_bytes</name></decl>, <decl><type ref="prev"/><name>other_bytes</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>res</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>minsize</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>cmp</name></decl>;</decl_stmt>
<if>if <condition>(<expr><call><name>PyObject_IsInstance</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr>(<name>PyObject</name>*)&amp;<name>PyUnicode_Type</name></expr></argument>)</argument_list></call> ||
<call><name>PyObject_IsInstance</name><argument_list>(<argument><expr><name>other</name></expr></argument>, <argument><expr>(<name>PyObject</name>*)&amp;<name>PyUnicode_Type</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<if>if <condition>(<expr><name>Py_BytesWarningFlag</name> &amp;&amp; <name>op</name> == <name>Py_EQ</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr><call><name>PyErr_WarnEx</name><argument_list>(<argument><expr><name>PyExc_BytesWarning</name></expr></argument>,
<argument><expr>"Comparsion between bytearray and string"</expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
}</block></then></if>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_NotImplemented</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>Py_NotImplemented</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>self_size</name> = <call><name>_getbuffer</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr>&amp;<name>self_bytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>self_size</name> &lt; 0</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_Clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_NotImplemented</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>Py_NotImplemented</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>other_size</name> = <call><name>_getbuffer</name><argument_list>(<argument><expr><name>other</name></expr></argument>, <argument><expr>&amp;<name>other_bytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>other_size</name> &lt; 0</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_Clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyBuffer_Release</name><argument_list>(<argument><expr>&amp;<name>self_bytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_NotImplemented</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>Py_NotImplemented</name></expr>;</return>
}</block></then></if>
<if>if <condition>(<expr><name>self_size</name> != <name>other_size</name> &amp;&amp; (<name>op</name> == <name>Py_EQ</name> || <name>op</name> == <name>Py_NE</name>)</expr>)</condition><then> <block>{
<expr_stmt><expr><name>cmp</name> = (<name>op</name> == <name>Py_NE</name>)</expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr><name>minsize</name> = <name>self_size</name></expr>;</expr_stmt>
<if>if <condition>(<expr><name>other_size</name> &lt; <name>minsize</name></expr>)</condition><then>
<expr_stmt><expr><name>minsize</name> = <name>other_size</name></expr>;</expr_stmt></then></if>
<expr_stmt><expr><name>cmp</name> = <call><name>memcmp</name><argument_list>(<argument><expr><name><name>self_bytes</name>.<name>buf</name></name></expr></argument>, <argument><expr><name><name>other_bytes</name>.<name>buf</name></name></expr></argument>, <argument><expr><name>minsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>cmp</name> == 0</expr>)</condition><then> <block>{
<if>if <condition>(<expr><name>self_size</name> &lt; <name>other_size</name></expr>)</condition><then>
<expr_stmt><expr><name>cmp</name> = -1</expr>;</expr_stmt></then>
<else>else <if>if <condition>(<expr><name>self_size</name> &gt; <name>other_size</name></expr>)</condition><then>
<expr_stmt><expr><name>cmp</name> = 1</expr>;</expr_stmt></then></if></else></if>
}</block></then></if>
<switch>switch <condition>(<expr><name>op</name></expr>)</condition> <block>{
<case>case <expr><name>Py_LT</name></expr>:
<expr_stmt><expr><name>cmp</name> = <name>cmp</name> &lt; 0</expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr><name>Py_LE</name></expr>:
<expr_stmt><expr><name>cmp</name> = <name>cmp</name> &lt;= 0</expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr><name>Py_EQ</name></expr>:
<expr_stmt><expr><name>cmp</name> = <name>cmp</name> == 0</expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr><name>Py_NE</name></expr>:
<expr_stmt><expr><name>cmp</name> = <name>cmp</name> != 0</expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr><name>Py_GT</name></expr>:
<expr_stmt><expr><name>cmp</name> = <name>cmp</name> &gt; 0</expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr><name>Py_GE</name></expr>:
<expr_stmt><expr><name>cmp</name> = <name>cmp</name> &gt;= 0</expr>;</expr_stmt>
<break>break;</break>
</case>}</block></switch>
}</block></else></if>
<expr_stmt><expr><name>res</name> = <name>cmp</name> ? <name>Py_True</name> : <name>Py_False</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyBuffer_Release</name><argument_list>(<argument><expr>&amp;<name>self_bytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyBuffer_Release</name><argument_list>(<argument><expr>&amp;<name>other_bytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>res</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>bytes_dealloc</name><parameter_list>(<param><decl><type><name>PyByteArrayObject</name> *</type><name>self</name></decl></param>)</parameter_list> <block>{
<if>if <condition>(<expr><name><name>self</name>-&gt;<name>ob_exports</name></name> &gt; 0</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_SystemError</name></expr></argument>,
<argument><expr>"deallocated bytearray object has exported buffers"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyErr_Print</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<if>if <condition>(<expr><name><name>self</name>-&gt;<name>ob_bytes</name></name> != 0</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyMem_Free</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>ob_bytes</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><call><name>Py_TYPE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call>-&gt;<call><name>tp_free</name><argument_list>(<argument><expr>(<name>PyObject</name> *)<name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>STRINGLIB_CHAR</name></cpp:macro> <cpp:value>char</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>STRINGLIB_CMP</name></cpp:macro> <cpp:value>memcmp</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>STRINGLIB_LEN</name></cpp:macro> <cpp:value>PyByteArray_GET_SIZE</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>STRINGLIB_STR</name></cpp:macro> <cpp:value>PyByteArray_AS_STRING</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>STRINGLIB_NEW</name></cpp:macro> <cpp:value>PyByteArray_FromStringAndSize</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>STRINGLIB_EMPTY</name></cpp:macro> <cpp:value>nullbytes</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>STRINGLIB_CHECK_EXACT</name></cpp:macro> <cpp:value>PyByteArray_CheckExact</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>STRINGLIB_MUTABLE</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FROM_BYTEARRAY</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"stringlib/fastsearch.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"stringlib/count.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"stringlib/find.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"stringlib/partition.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"stringlib/ctype.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"stringlib/transmogrify.h"</cpp:file></cpp:include>
<macro><name>Py_LOCAL_INLINE</name><argument_list>(<argument>void</argument>)</argument_list></macro>
<macro><name>_adjust_indices</name><argument_list>(<argument>Py_ssize_t *start</argument>, <argument>Py_ssize_t *end</argument>, <argument>Py_ssize_t len</argument>)</argument_list></macro> <block>{
<if>if <condition>(<expr>*<name>end</name> &gt; <name>len</name></expr>)</condition><then>
<expr_stmt><expr>*<name>end</name> = <name>len</name></expr>;</expr_stmt></then>
<else>else <if>if <condition>(<expr>*<name>end</name> &lt; 0</expr>)</condition><then>
<expr_stmt><expr>*<name>end</name> += <name>len</name></expr>;</expr_stmt></then></if></else></if>
<if>if <condition>(<expr>*<name>end</name> &lt; 0</expr>)</condition><then>
<expr_stmt><expr>*<name>end</name> = 0</expr>;</expr_stmt></then></if>
<if>if <condition>(<expr>*<name>start</name> &lt; 0</expr>)</condition><then>
<expr_stmt><expr>*<name>start</name> += <name>len</name></expr>;</expr_stmt></then></if>
<if>if <condition>(<expr>*<name>start</name> &lt; 0</expr>)</condition><then>
<expr_stmt><expr>*<name>start</name> = 0</expr>;</expr_stmt></then></if>
}</block>
<macro><name>Py_LOCAL_INLINE</name><argument_list>(<argument>Py_ssize_t</argument>)</argument_list></macro>
<macro><name>bytes_find_internal</name><argument_list>(<argument>PyByteArrayObject *self</argument>, <argument>PyObject *args</argument>, <argument>int dir</argument>)</argument_list></macro> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>subobj</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_buffer</name></type> <name>subbuf</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>start</name><init>=<expr>0</expr></init>, <name>end</name><init>=<expr><name>PY_SSIZE_T_MAX</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>res</name></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"O|O&amp;O&amp;:find/rfind/index/rindex"</expr></argument>, <argument><expr>&amp;<name>subobj</name></expr></argument>,
<argument><expr><name>_PyEval_SliceIndex</name></expr></argument>, <argument><expr>&amp;<name>start</name></expr></argument>, <argument><expr><name>_PyEval_SliceIndex</name></expr></argument>, <argument><expr>&amp;<name>end</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr>-2</expr>;</return></then></if>
<if>if <condition>(<expr><call><name>_getbuffer</name><argument_list>(<argument><expr><name>subobj</name></expr></argument>, <argument><expr>&amp;<name>subbuf</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
<return>return <expr>-2</expr>;</return></then></if>
<if>if <condition>(<expr><name>dir</name> &gt; 0</expr>)</condition><then>
<expr_stmt><expr><name>res</name> = <call><name>stringlib_find_slice</name><argument_list>(
<argument><expr><call><name>PyByteArray_AS_STRING</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>PyByteArray_GET_SIZE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name><name>subbuf</name>.<name>buf</name></name></expr></argument>, <argument><expr><name><name>subbuf</name>.<name>len</name></name></expr></argument>, <argument><expr><name>start</name></expr></argument>, <argument><expr><name>end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
<else>else
<expr_stmt><expr><name>res</name> = <call><name>stringlib_rfind_slice</name><argument_list>(
<argument><expr><call><name>PyByteArray_AS_STRING</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>PyByteArray_GET_SIZE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name><name>subbuf</name>.<name>buf</name></name></expr></argument>, <argument><expr><name><name>subbuf</name>.<name>len</name></name></expr></argument>, <argument><expr><name>start</name></expr></argument>, <argument><expr><name>end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
<expr_stmt><expr><call><name>PyBuffer_Release</name><argument_list>(<argument><expr>&amp;<name>subbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>res</name></expr>;</return>
}</block>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>find__doc__</name></expr></argument>,
<argument><expr>"B.find(sub [,start [,end]]) -&gt; int\n\
\n\
Return the lowest index in B where subsection sub is found,\n\
such that sub is contained within s[start,end]. Optional\n\
arguments start and end are interpreted as in slice notation.\n\
\n\
Return -1 on failure."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>bytes_find</name><parameter_list>(<param><decl><type><name>PyByteArrayObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>result</name> <init>= <expr><call><name>bytes_find_internal</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>args</name></expr></argument>, <argument><expr>+1</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>result</name> == -2</expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<return>return <expr><call><name>PyInt_FromSsize_t</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>count__doc__</name></expr></argument>,
<argument><expr>"B.count(sub [,start [,end]]) -&gt; int\n\
\n\
Return the number of non-overlapping occurrences of subsection sub in\n\
bytes B[start:end]. Optional arguments start and end are interpreted\n\
as in slice notation."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>bytes_count</name><parameter_list>(<param><decl><type><name>PyByteArrayObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>sub_obj</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>str</name> <init>= <expr><call><name>PyByteArray_AS_STRING</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>start</name> <init>= <expr>0</expr></init>, <name>end</name> <init>= <expr><name>PY_SSIZE_T_MAX</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_buffer</name></type> <name>vsub</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>count_obj</name></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"O|O&amp;O&amp;:count"</expr></argument>, <argument><expr>&amp;<name>sub_obj</name></expr></argument>,
<argument><expr><name>_PyEval_SliceIndex</name></expr></argument>, <argument><expr>&amp;<name>start</name></expr></argument>, <argument><expr><name>_PyEval_SliceIndex</name></expr></argument>, <argument><expr>&amp;<name>end</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<if>if <condition>(<expr><call><name>_getbuffer</name><argument_list>(<argument><expr><name>sub_obj</name></expr></argument>, <argument><expr>&amp;<name>vsub</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><call><name>_adjust_indices</name><argument_list>(<argument><expr>&amp;<name>start</name></expr></argument>, <argument><expr>&amp;<name>end</name></expr></argument>, <argument><expr><call><name>PyByteArray_GET_SIZE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>count_obj</name> = <call><name>PyInt_FromSsize_t</name><argument_list>(
<argument><expr><call><name>stringlib_count</name><argument_list>(<argument><expr><name>str</name> + <name>start</name></expr></argument>, <argument><expr><name>end</name> - <name>start</name></expr></argument>, <argument><expr><name><name>vsub</name>.<name>buf</name></name></expr></argument>, <argument><expr><name><name>vsub</name>.<name>len</name></name></expr></argument>)</argument_list></call></expr></argument>
)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyBuffer_Release</name><argument_list>(<argument><expr>&amp;<name>vsub</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>count_obj</name></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>index__doc__</name></expr></argument>,
<argument><expr>"B.index(sub [,start [,end]]) -&gt; int\n\
\n\
Like B.find() but raise ValueError when the subsection is not found."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>bytes_index</name><parameter_list>(<param><decl><type><name>PyByteArrayObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>result</name> <init>= <expr><call><name>bytes_find_internal</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>args</name></expr></argument>, <argument><expr>+1</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>result</name> == -2</expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<if>if <condition>(<expr><name>result</name> == -1</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>,
<argument><expr>"subsection not found"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<return>return <expr><call><name>PyInt_FromSsize_t</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>rfind__doc__</name></expr></argument>,
<argument><expr>"B.rfind(sub [,start [,end]]) -&gt; int\n\
\n\
Return the highest index in B where subsection sub is found,\n\
such that sub is contained within s[start,end]. Optional\n\
arguments start and end are interpreted as in slice notation.\n\
\n\
Return -1 on failure."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>bytes_rfind</name><parameter_list>(<param><decl><type><name>PyByteArrayObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>result</name> <init>= <expr><call><name>bytes_find_internal</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>args</name></expr></argument>, <argument><expr>-1</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>result</name> == -2</expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<return>return <expr><call><name>PyInt_FromSsize_t</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>rindex__doc__</name></expr></argument>,
<argument><expr>"B.rindex(sub [,start [,end]]) -&gt; int\n\
\n\
Like B.rfind() but raise ValueError when the subsection is not found."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>bytes_rindex</name><parameter_list>(<param><decl><type><name>PyByteArrayObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>result</name> <init>= <expr><call><name>bytes_find_internal</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>args</name></expr></argument>, <argument><expr>-1</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>result</name> == -2</expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<if>if <condition>(<expr><name>result</name> == -1</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>,
<argument><expr>"subsection not found"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<return>return <expr><call><name>PyInt_FromSsize_t</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>bytes_contains</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>arg</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>ival</name> <init>= <expr><call><name>PyNumber_AsSsize_t</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><name>PyExc_ValueError</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>ival</name> == -1 &amp;&amp; <call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>Py_buffer</name></type> <name>varg</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>pos</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>PyErr_Clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>_getbuffer</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr>&amp;<name>varg</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
<return>return <expr>-1</expr>;</return></then></if>
<expr_stmt><expr><name>pos</name> = <call><name>stringlib_find</name><argument_list>(<argument><expr><call><name>PyByteArray_AS_STRING</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>Py_SIZE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name><name>varg</name>.<name>buf</name></name></expr></argument>, <argument><expr><name><name>varg</name>.<name>len</name></name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyBuffer_Release</name><argument_list>(<argument><expr>&amp;<name>varg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>pos</name> &gt;= 0</expr>;</return>
}</block></then></if>
<if>if <condition>(<expr><name>ival</name> &lt; 0 || <name>ival</name> &gt;= 256</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>, <argument><expr>"byte must be in range(0, 256)"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>-1</expr>;</return>
}</block></then></if>
<return>return <expr><call><name>memchr</name><argument_list>(<argument><expr><call><name>PyByteArray_AS_STRING</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>ival</name></expr></argument>, <argument><expr><call><name>Py_SIZE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> != <name>NULL</name></expr>;</return>
}</block></function>
<macro><name>Py_LOCAL</name><argument_list>(<argument>int</argument>)</argument_list></macro>
<macro><name>_bytes_tailmatch</name><argument_list>(<argument>PyByteArrayObject *self</argument>, <argument>PyObject *substr</argument>, <argument>Py_ssize_t start</argument>,
<argument>Py_ssize_t end</argument>, <argument>int direction</argument>)</argument_list></macro> <block>{
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>len</name> <init>= <expr><call><name>PyByteArray_GET_SIZE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name>*</type> <name>str</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_buffer</name></type> <name>vsubstr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>rv</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>str</name> = <call><name>PyByteArray_AS_STRING</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>_getbuffer</name><argument_list>(<argument><expr><name>substr</name></expr></argument>, <argument><expr>&amp;<name>vsubstr</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
<return>return <expr>-1</expr>;</return></then></if>
<expr_stmt><expr><call><name>_adjust_indices</name><argument_list>(<argument><expr>&amp;<name>start</name></expr></argument>, <argument><expr>&amp;<name>end</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>direction</name> &lt; 0</expr>)</condition><then> <block>{
<if>if <condition>(<expr><name>start</name>+<name><name>vsubstr</name>.<name>len</name></name> &gt; <name>len</name></expr>)</condition><then> <block>{
<goto>goto <name>done</name>;</goto>
}</block></then></if>
}</block></then> <else>else <block>{
<if>if <condition>(<expr><name>end</name>-<name>start</name> &lt; <name><name>vsubstr</name>.<name>len</name></name> || <name>start</name> &gt; <name>len</name></expr>)</condition><then> <block>{
<goto>goto <name>done</name>;</goto>
}</block></then></if>
<if>if <condition>(<expr><name>end</name>-<name><name>vsubstr</name>.<name>len</name></name> &gt; <name>start</name></expr>)</condition><then>
<expr_stmt><expr><name>start</name> = <name>end</name> - <name><name>vsubstr</name>.<name>len</name></name></expr>;</expr_stmt></then></if>
}</block></else></if>
<if>if <condition>(<expr><name>end</name>-<name>start</name> &gt;= <name><name>vsubstr</name>.<name>len</name></name></expr>)</condition><then>
<expr_stmt><expr><name>rv</name> = ! <call><name>memcmp</name><argument_list>(<argument><expr><name>str</name>+<name>start</name></expr></argument>, <argument><expr><name><name>vsubstr</name>.<name>buf</name></name></expr></argument>, <argument><expr><name><name>vsubstr</name>.<name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<label><name>done</name>:</label>
<expr_stmt><expr><call><name>PyBuffer_Release</name><argument_list>(<argument><expr>&amp;<name>vsubstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>rv</name></expr>;</return>
}</block>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>startswith__doc__</name></expr></argument>,
<argument><expr>"B.startswith(prefix [,start [,end]]) -&gt; bool\n\
\n\
Return True if B starts with the specified prefix, False otherwise.\n\
With optional start, test B beginning at that position.\n\
With optional end, stop comparing B at that position.\n\
prefix can also be a tuple of strings to try."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>bytes_startswith</name><parameter_list>(<param><decl><type><name>PyByteArrayObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>start</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>end</name> <init>= <expr><name>PY_SSIZE_T_MAX</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>subobj</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>result</name></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"O|O&amp;O&amp;:startswith"</expr></argument>, <argument><expr>&amp;<name>subobj</name></expr></argument>,
<argument><expr><name>_PyEval_SliceIndex</name></expr></argument>, <argument><expr>&amp;<name>start</name></expr></argument>, <argument><expr><name>_PyEval_SliceIndex</name></expr></argument>, <argument><expr>&amp;<name>end</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<if>if <condition>(<expr><call><name>PyTuple_Check</name><argument_list>(<argument><expr><name>subobj</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>i</name></decl>;</decl_stmt>
<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <call><name>PyTuple_GET_SIZE</name><argument_list>(<argument><expr><name>subobj</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
<expr_stmt><expr><name>result</name> = <call><name>_bytes_tailmatch</name><argument_list>(<argument><expr><name>self</name></expr></argument>,
<argument><expr><call><name>PyTuple_GET_ITEM</name><argument_list>(<argument><expr><name>subobj</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>start</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr>-1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>result</name> == -1</expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then>
<else>else <if>if <condition>(<expr><name>result</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>Py_RETURN_TRUE</name></expr>;</expr_stmt>
}</block></then></if></else></if>
}</block></for>
<expr_stmt><expr><name>Py_RETURN_FALSE</name></expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><name>result</name> = <call><name>_bytes_tailmatch</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>subobj</name></expr></argument>, <argument><expr><name>start</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr>-1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>result</name> == -1</expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then>
<else>else
<return>return <expr><call><name>PyBool_FromLong</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</return></else></if>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>endswith__doc__</name></expr></argument>,
<argument><expr>"B.endswith(suffix [,start [,end]]) -&gt; bool\n\
\n\
Return True if B ends with the specified suffix, False otherwise.\n\
With optional start, test B beginning at that position.\n\
With optional end, stop comparing B at that position.\n\
suffix can also be a tuple of strings to try."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>bytes_endswith</name><parameter_list>(<param><decl><type><name>PyByteArrayObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>start</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>end</name> <init>= <expr><name>PY_SSIZE_T_MAX</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>subobj</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>result</name></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"O|O&amp;O&amp;:endswith"</expr></argument>, <argument><expr>&amp;<name>subobj</name></expr></argument>,
<argument><expr><name>_PyEval_SliceIndex</name></expr></argument>, <argument><expr>&amp;<name>start</name></expr></argument>, <argument><expr><name>_PyEval_SliceIndex</name></expr></argument>, <argument><expr>&amp;<name>end</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<if>if <condition>(<expr><call><name>PyTuple_Check</name><argument_list>(<argument><expr><name>subobj</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>i</name></decl>;</decl_stmt>
<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <call><name>PyTuple_GET_SIZE</name><argument_list>(<argument><expr><name>subobj</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
<expr_stmt><expr><name>result</name> = <call><name>_bytes_tailmatch</name><argument_list>(<argument><expr><name>self</name></expr></argument>,
<argument><expr><call><name>PyTuple_GET_ITEM</name><argument_list>(<argument><expr><name>subobj</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>start</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr>+1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>result</name> == -1</expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then>
<else>else <if>if <condition>(<expr><name>result</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>Py_RETURN_TRUE</name></expr>;</expr_stmt>
}</block></then></if></else></if>
}</block></for>
<expr_stmt><expr><name>Py_RETURN_FALSE</name></expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><name>result</name> = <call><name>_bytes_tailmatch</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>subobj</name></expr></argument>, <argument><expr><name>start</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr>+1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>result</name> == -1</expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then>
<else>else
<return>return <expr><call><name>PyBool_FromLong</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</return></else></if>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>translate__doc__</name></expr></argument>,
<argument><expr>"B.translate(table[, deletechars]) -&gt; bytearray\n\
\n\
Return a copy of B, where all characters occurring in the\n\
optional argument deletechars are removed, and the remaining\n\
characters have been mapped through the given translation\n\
table, which must be a bytes object of length 256."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>bytes_translate</name><parameter_list>(<param><decl><type><name>PyByteArrayObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>register</name> <name>char</name> *</type><name>input</name></decl>, *<decl><type ref="prev"/><name>output</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>register</name> <specifier>const</specifier> <name>char</name> *</type><name>table</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>register</name> <name>Py_ssize_t</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>c</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>input_obj</name> <init>= <expr>(<name>PyObject</name>*)<name>self</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>output_start</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>inlen</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>result</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name><name>trans_table</name><index>[<expr>256</expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>tableobj</name></decl>, *<decl><type ref="prev"/><name>delobj</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_buffer</name></type> <name>vtable</name></decl>, <decl><type ref="prev"/><name>vdel</name></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>PyArg_UnpackTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"translate"</expr></argument>, <argument><expr>1</expr></argument>, <argument><expr>2</expr></argument>,
<argument><expr>&amp;<name>tableobj</name></expr></argument>, <argument><expr>&amp;<name>delobj</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<if>if <condition>(<expr><call><name>_getbuffer</name><argument_list>(<argument><expr><name>tableobj</name></expr></argument>, <argument><expr>&amp;<name>vtable</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<if>if <condition>(<expr><name><name>vtable</name>.<name>len</name></name> != 256</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>,
<argument><expr>"translation table must be 256 characters long"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>result</name> = <name>NULL</name></expr>;</expr_stmt>
<goto>goto <name>done</name>;</goto>
}</block></then></if>
<if>if <condition>(<expr><name>delobj</name> != <name>NULL</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr><call><name>_getbuffer</name><argument_list>(<argument><expr><name>delobj</name></expr></argument>, <argument><expr>&amp;<name>vdel</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then> <block>{
<expr_stmt><expr><name>result</name> = <name>NULL</name></expr>;</expr_stmt>
<goto>goto <name>done</name>;</goto>
}</block></then></if>
}</block></then> <else>else <block>{
<expr_stmt><expr><name><name>vdel</name>.<name>buf</name></name> = <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>vdel</name>.<name>len</name></name> = 0</expr>;</expr_stmt>
}</block></else></if>
<expr_stmt><expr><name>table</name> = (const <name>char</name> *)<name><name>vtable</name>.<name>buf</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>inlen</name> = <call><name>PyByteArray_GET_SIZE</name><argument_list>(<argument><expr><name>input_obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>result</name> = <call><name>PyByteArray_FromStringAndSize</name><argument_list>(<argument><expr>(<name>char</name> *)<name>NULL</name></expr></argument>, <argument><expr><name>inlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>result</name> == <name>NULL</name></expr>)</condition><then>
<goto>goto <name>done</name>;</goto></then></if>
<expr_stmt><expr><name>output_start</name> = <name>output</name> = <call><name>PyByteArray_AsString</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>input</name> = <call><name>PyByteArray_AS_STRING</name><argument_list>(<argument><expr><name>input_obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>vdel</name>.<name>len</name></name> == 0</expr>)</condition><then> <block>{
<for>for (<init><expr><name>i</name> = <name>inlen</name></expr>;</init> <condition><expr>--<name>i</name> &gt;= 0</expr>;</condition> <incr/>) <block>{
<expr_stmt><expr><name>c</name> = <call><name>Py_CHARMASK</name><argument_list>(<argument><expr>*<name>input</name>++</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr>*<name>output</name>++ = <name><name>table</name><index>[<expr><name>c</name></expr>]</index></name></expr>;</expr_stmt>
}</block></for>
<goto>goto <name>done</name>;</goto>
}</block></then></if>
<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; 256</expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
<expr_stmt><expr><name><name>trans_table</name><index>[<expr><name>i</name></expr>]</index></name> = <call><name>Py_CHARMASK</name><argument_list>(<argument><expr><name><name>table</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></for>
<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name><name>vdel</name>.<name>len</name></name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
<expr_stmt><expr><name><name>trans_table</name><index>[<expr>(<name>int</name>) <call><name>Py_CHARMASK</name><argument_list>( <argument><expr>((<name>unsigned</name> <name>char</name>*)<name><name>vdel</name>.<name>buf</name></name>)<index>[<expr><name>i</name></expr>]</index></expr></argument> )</argument_list></call></expr>]</index></name> = -1</expr>;</expr_stmt></for>
<for>for (<init><expr><name>i</name> = <name>inlen</name></expr>;</init> <condition><expr>--<name>i</name> &gt;= 0</expr>;</condition> <incr/>) <block>{
<expr_stmt><expr><name>c</name> = <call><name>Py_CHARMASK</name><argument_list>(<argument><expr>*<name>input</name>++</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>trans_table</name><index>[<expr><name>c</name></expr>]</index></name> != -1</expr>)</condition><then>
<if>if <condition>(<expr><call><name>Py_CHARMASK</name><argument_list>(<argument><expr>*<name>output</name>++ = (<name>char</name>)<name><name>trans_table</name><index>[<expr><name>c</name></expr>]</index></name></expr></argument>)</argument_list></call> == <name>c</name></expr>)</condition><then>
<continue>continue;</continue></then></if></then></if>
}</block></for>
<if>if <condition>(<expr><name>inlen</name> &gt; 0</expr>)</condition><then>
<expr_stmt><expr><call><name>PyByteArray_Resize</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>output</name> - <name>output_start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<label><name>done</name>:</label>
<expr_stmt><expr><call><name>PyBuffer_Release</name><argument_list>(<argument><expr>&amp;<name>vtable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>delobj</name> != <name>NULL</name></expr>)</condition><then>
<expr_stmt><expr><call><name>PyBuffer_Release</name><argument_list>(<argument><expr>&amp;<name>vdel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<return>return <expr><name>result</name></expr>;</return>
}</block></function>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FORWARD</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>REVERSE</name></cpp:macro> <cpp:value>-1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>findchar</name><parameter_list>(<param><type><name>target</name></type></param>, <param><type><name>target_len</name></type></param>, <param><type><name>c</name></type></param>)</parameter_list></cpp:macro> <cpp:value>((char *)memchr((const void *)(target), c, target_len))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Py_STRING_MATCH</name><parameter_list>(<param><type><name>target</name></type></param>, <param><type><name>offset</name></type></param>, <param><type><name>pattern</name></type></param>, <param><type><name>length</name></type></param>)</parameter_list></cpp:macro> <cpp:value>(target[offset] == pattern[0] &amp;&amp; target[offset+length-1] == pattern[length-1] &amp;&amp; !memcmp(target+offset+1, pattern+1, length-2) )</cpp:value></cpp:define>
<macro><name>Py_LOCAL</name><argument_list>(<argument>PyByteArrayObject *</argument>)</argument_list></macro>
<macro><name>return_self</name><argument_list>(<argument>PyByteArrayObject *self</argument>)</argument_list></macro> <block>{
<return>return <expr>(<name>PyByteArrayObject</name> *)<call><name>PyByteArray_FromStringAndSize</name><argument_list>(
<argument><expr><call><name>PyByteArray_AS_STRING</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name>PyByteArray_GET_SIZE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<macro><name>Py_LOCAL_INLINE</name><argument_list>(<argument>Py_ssize_t</argument>)</argument_list></macro>
<macro><name>countchar</name><argument_list>(<argument>const char *target</argument>, <argument>Py_ssize_t target_len</argument>, <argument>char c</argument>, <argument>Py_ssize_t maxcount</argument>)</argument_list></macro> <block>{
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>count</name><init>=<expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>start</name><init>=<expr><name>target</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>end</name><init>=<expr><name>target</name>+<name>target_len</name></expr></init></decl>;</decl_stmt>
<while>while <condition>( <expr>(<name>start</name>=<call><name>findchar</name><argument_list>(<argument><expr><name>start</name></expr></argument>, <argument><expr><name>end</name>-<name>start</name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call>) != <name>NULL</name></expr> )</condition> <block>{
<expr_stmt><expr><name>count</name>++</expr>;</expr_stmt>
<if>if <condition>(<expr><name>count</name> &gt;= <name>maxcount</name></expr>)</condition><then>
<break>break;</break></then></if>
<expr_stmt><expr><name>start</name> += 1</expr>;</expr_stmt>
}</block></while>
<return>return <expr><name>count</name></expr>;</return>
}</block>
<macro><name>Py_LOCAL</name><argument_list>(<argument>Py_ssize_t</argument>)</argument_list></macro>
<macro><name>findstring</name><argument_list>(<argument>const char *target</argument>, <argument>Py_ssize_t target_len</argument>,
<argument>const char *pattern</argument>, <argument>Py_ssize_t pattern_len</argument>,
<argument>Py_ssize_t start</argument>,
<argument>Py_ssize_t end</argument>,
<argument>int direction</argument>)</argument_list></macro> <block>{
<if>if <condition>(<expr><name>start</name> &lt; 0</expr>)</condition><then> <block>{
<expr_stmt><expr><name>start</name> += <name>target_len</name></expr>;</expr_stmt>
<if>if <condition>(<expr><name>start</name> &lt; 0</expr>)</condition><then>
<expr_stmt><expr><name>start</name> = 0</expr>;</expr_stmt></then></if>
}</block></then></if>
<if>if <condition>(<expr><name>end</name> &gt; <name>target_len</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>end</name> = <name>target_len</name></expr>;</expr_stmt>
}</block></then> <else>else <if>if <condition>(<expr><name>end</name> &lt; 0</expr>)</condition><then> <block>{
<expr_stmt><expr><name>end</name> += <name>target_len</name></expr>;</expr_stmt>
<if>if <condition>(<expr><name>end</name> &lt; 0</expr>)</condition><then>
<expr_stmt><expr><name>end</name> = 0</expr>;</expr_stmt></then></if>
}</block></then></if></else></if>
<if>if <condition>(<expr><name>pattern_len</name> == 0</expr>)</condition><then>
<return>return <expr>(<name>direction</name> &gt; 0) ? <name>start</name> : <name>end</name></expr>;</return></then></if>
<expr_stmt><expr><name>end</name> -= <name>pattern_len</name></expr>;</expr_stmt>
<if>if <condition>(<expr><name>direction</name> &lt; 0</expr>)</condition><then> <block>{
<for>for (<init>;</init> <condition><expr><name>end</name> &gt;= <name>start</name></expr>;</condition> <incr><expr><name>end</name>--</expr></incr>)
<if>if <condition>(<expr><call><name>Py_STRING_MATCH</name><argument_list>(<argument><expr><name>target</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><name>pattern</name></expr></argument>, <argument><expr><name>pattern_len</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>end</name></expr>;</return></then></if></for>
}</block></then> <else>else <block>{
<for>for (<init>;</init> <condition><expr><name>start</name> &lt;= <name>end</name></expr>;</condition> <incr><expr><name>start</name>++</expr></incr>)
<if>if <condition>(<expr><call><name>Py_STRING_MATCH</name><argument_list>(<argument><expr><name>target</name></expr></argument>, <argument><expr><name>start</name></expr></argument>, <argument><expr><name>pattern</name></expr></argument>, <argument><expr><name>pattern_len</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>start</name></expr>;</return></then></if></for>
}</block></else></if>
<return>return <expr>-1</expr>;</return>
}</block>
<macro><name>Py_LOCAL_INLINE</name><argument_list>(<argument>Py_ssize_t</argument>)</argument_list></macro>
<macro><name>countstring</name><argument_list>(<argument>const char *target</argument>, <argument>Py_ssize_t target_len</argument>,
<argument>const char *pattern</argument>, <argument>Py_ssize_t pattern_len</argument>,
<argument>Py_ssize_t start</argument>,
<argument>Py_ssize_t end</argument>,
<argument>int direction</argument>, <argument>Py_ssize_t maxcount</argument>)</argument_list></macro> <block>{
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>count</name><init>=<expr>0</expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>start</name> &lt; 0</expr>)</condition><then> <block>{
<expr_stmt><expr><name>start</name> += <name>target_len</name></expr>;</expr_stmt>
<if>if <condition>(<expr><name>start</name> &lt; 0</expr>)</condition><then>
<expr_stmt><expr><name>start</name> = 0</expr>;</expr_stmt></then></if>
}</block></then></if>
<if>if <condition>(<expr><name>end</name> &gt; <name>target_len</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>end</name> = <name>target_len</name></expr>;</expr_stmt>
}</block></then> <else>else <if>if <condition>(<expr><name>end</name> &lt; 0</expr>)</condition><then> <block>{
<expr_stmt><expr><name>end</name> += <name>target_len</name></expr>;</expr_stmt>
<if>if <condition>(<expr><name>end</name> &lt; 0</expr>)</condition><then>
<expr_stmt><expr><name>end</name> = 0</expr>;</expr_stmt></then></if>
}</block></then></if></else></if>
<if>if <condition>(<expr><name>pattern_len</name> == 0 || <name>maxcount</name> == 0</expr>)</condition><then> <block>{
<if>if <condition>(<expr><name>target_len</name>+1 &lt; <name>maxcount</name></expr>)</condition><then>
<return>return <expr><name>target_len</name>+1</expr>;</return></then></if>
<return>return <expr><name>maxcount</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>end</name> -= <name>pattern_len</name></expr>;</expr_stmt>
<if>if <condition>(<expr><name>direction</name> &lt; 0</expr>)</condition><then> <block>{
<for>for (<init>;</init> <condition><expr>(<name>end</name> &gt;= <name>start</name>)</expr>;</condition> <incr><expr><name>end</name>--</expr></incr>)
<if>if <condition>(<expr><call><name>Py_STRING_MATCH</name><argument_list>(<argument><expr><name>target</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><name>pattern</name></expr></argument>, <argument><expr><name>pattern_len</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><name>count</name>++</expr>;</expr_stmt>
<if>if <condition>(<expr>--<name>maxcount</name> &lt;= 0</expr>)</condition><then> <break>break;</break></then></if>
<expr_stmt><expr><name>end</name> -= <name>pattern_len</name>-1</expr>;</expr_stmt>
}</block></then></if></for>
}</block></then> <else>else <block>{
<for>for (<init>;</init> <condition><expr>(<name>start</name> &lt;= <name>end</name>)</expr>;</condition> <incr><expr><name>start</name>++</expr></incr>)
<if>if <condition>(<expr><call><name>Py_STRING_MATCH</name><argument_list>(<argument><expr><name>target</name></expr></argument>, <argument><expr><name>start</name></expr></argument>, <argument><expr><name>pattern</name></expr></argument>, <argument><expr><name>pattern_len</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><name>count</name>++</expr>;</expr_stmt>
<if>if <condition>(<expr>--<name>maxcount</name> &lt;= 0</expr>)</condition><then>
<break>break;</break></then></if>
<expr_stmt><expr><name>start</name> += <name>pattern_len</name>-1</expr>;</expr_stmt>
}</block></then></if></for>
}</block></else></if>
<return>return <expr><name>count</name></expr>;</return>
}</block>
<macro><name>Py_LOCAL</name><argument_list>(<argument>PyByteArrayObject *</argument>)</argument_list></macro>
<macro><name>replace_interleave</name><argument_list>(<argument>PyByteArrayObject *self</argument>,
<argument>const char *to_s</argument>, <argument>Py_ssize_t to_len</argument>,
<argument>Py_ssize_t maxcount</argument>)</argument_list></macro> <block>{
<decl_stmt><decl><type><name>char</name> *</type><name>self_s</name></decl>, *<decl><type ref="prev"/><name>result_s</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>self_len</name></decl>, <decl><type ref="prev"/><name>result_len</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>count</name></decl>, <decl><type ref="prev"/><name>i</name></decl>, <decl><type ref="prev"/><name>product</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyByteArrayObject</name> *</type><name>result</name></decl>;</decl_stmt>
<expr_stmt><expr><name>self_len</name> = <call><name>PyByteArray_GET_SIZE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>count</name> = <name>self_len</name>+1</expr>;</expr_stmt>
<if>if <condition>(<expr><name>maxcount</name> &lt; <name>count</name></expr>)</condition><then>
<expr_stmt><expr><name>count</name> = <name>maxcount</name></expr>;</expr_stmt></then></if>
<expr_stmt><expr><name>product</name> = <name>count</name> * <name>to_len</name></expr>;</expr_stmt>
<if>if <condition>(<expr><name>product</name> / <name>to_len</name> != <name>count</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_OverflowError</name></expr></argument>,
<argument><expr>"replace string is too long"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>result_len</name> = <name>product</name> + <name>self_len</name></expr>;</expr_stmt>
<if>if <condition>(<expr><name>result_len</name> &lt; 0</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_OverflowError</name></expr></argument>,
<argument><expr>"replace string is too long"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<if>if <condition>(<expr>! (<name>result</name> = (<name>PyByteArrayObject</name> *)
<call><name>PyByteArray_FromStringAndSize</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>result_len</name></expr></argument>)</argument_list></call>)</expr> )</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>self_s</name> = <call><name>PyByteArray_AS_STRING</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>result_s</name> = <call><name>PyByteArray_AS_STRING</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_MEMCPY</name><argument_list>(<argument><expr><name>result_s</name></expr></argument>, <argument><expr><name>to_s</name></expr></argument>, <argument><expr><name>to_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>result_s</name> += <name>to_len</name></expr>;</expr_stmt>
<expr_stmt><expr><name>count</name> -= 1</expr>;</expr_stmt>
<for>for (<init><expr><name>i</name>=0</expr>;</init> <condition><expr><name>i</name>&lt;<name>count</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
<expr_stmt><expr>*<name>result_s</name>++ = *<name>self_s</name>++</expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_MEMCPY</name><argument_list>(<argument><expr><name>result_s</name></expr></argument>, <argument><expr><name>to_s</name></expr></argument>, <argument><expr><name>to_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>result_s</name> += <name>to_len</name></expr>;</expr_stmt>
}</block></for>
<expr_stmt><expr><call><name>Py_MEMCPY</name><argument_list>(<argument><expr><name>result_s</name></expr></argument>, <argument><expr><name>self_s</name></expr></argument>, <argument><expr><name>self_len</name>-<name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>result</name></expr>;</return>
}</block>
<macro><name>Py_LOCAL</name><argument_list>(<argument>PyByteArrayObject *</argument>)</argument_list></macro>
<macro><name>replace_delete_single_character</name><argument_list>(<argument>PyByteArrayObject *self</argument>,
<argument>char from_c</argument>, <argument>Py_ssize_t maxcount</argument>)</argument_list></macro> <block>{
<decl_stmt><decl><type><name>char</name> *</type><name>self_s</name></decl>, *<decl><type ref="prev"/><name>result_s</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>start</name></decl>, *<decl><type ref="prev"/><name>next</name></decl>, *<decl><type ref="prev"/><name>end</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>self_len</name></decl>, <decl><type ref="prev"/><name>result_len</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>count</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyByteArrayObject</name> *</type><name>result</name></decl>;</decl_stmt>
<expr_stmt><expr><name>self_len</name> = <call><name>PyByteArray_GET_SIZE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>self_s</name> = <call><name>PyByteArray_AS_STRING</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>count</name> = <call><name>countchar</name><argument_list>(<argument><expr><name>self_s</name></expr></argument>, <argument><expr><name>self_len</name></expr></argument>, <argument><expr><name>from_c</name></expr></argument>, <argument><expr><name>maxcount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>count</name> == 0</expr>)</condition><then> <block>{
<return>return <expr><call><name>return_self</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>result_len</name> = <name>self_len</name> - <name>count</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>result_len</name>&gt;=0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>( <expr>(<name>result</name> = (<name>PyByteArrayObject</name> *)
<call><name>PyByteArray_FromStringAndSize</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>result_len</name></expr></argument>)</argument_list></call>) == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>result_s</name> = <call><name>PyByteArray_AS_STRING</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>start</name> = <name>self_s</name></expr>;</expr_stmt>
<expr_stmt><expr><name>end</name> = <name>self_s</name> + <name>self_len</name></expr>;</expr_stmt>
<while>while <condition>(<expr><name>count</name>-- &gt; 0</expr>)</condition> <block>{
<expr_stmt><expr><name>next</name> = <call><name>findchar</name><argument_list>(<argument><expr><name>start</name></expr></argument>, <argument><expr><name>end</name>-<name>start</name></expr></argument>, <argument><expr><name>from_c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>next</name> == <name>NULL</name></expr>)</condition><then>
<break>break;</break></then></if>
<expr_stmt><expr><call><name>Py_MEMCPY</name><argument_list>(<argument><expr><name>result_s</name></expr></argument>, <argument><expr><name>start</name></expr></argument>, <argument><expr><name>next</name>-<name>start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>result_s</name> += (<name>next</name>-<name>start</name>)</expr>;</expr_stmt>
<expr_stmt><expr><name>start</name> = <name>next</name>+1</expr>;</expr_stmt>
}</block></while>
<expr_stmt><expr><call><name>Py_MEMCPY</name><argument_list>(<argument><expr><name>result_s</name></expr></argument>, <argument><expr><name>start</name></expr></argument>, <argument><expr><name>end</name>-<name>start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>result</name></expr>;</return>
}</block>
<macro><name>Py_LOCAL</name><argument_list>(<argument>PyByteArrayObject *</argument>)</argument_list></macro>
<macro><name>replace_delete_substring</name><argument_list>(<argument>PyByteArrayObject *self</argument>,
<argument>const char *from_s</argument>, <argument>Py_ssize_t from_len</argument>,
<argument>Py_ssize_t maxcount</argument>)</argument_list></macro> <block>{
<decl_stmt><decl><type><name>char</name> *</type><name>self_s</name></decl>, *<decl><type ref="prev"/><name>result_s</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>start</name></decl>, *<decl><type ref="prev"/><name>next</name></decl>, *<decl><type ref="prev"/><name>end</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>self_len</name></decl>, <decl><type ref="prev"/><name>result_len</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>count</name></decl>, <decl><type ref="prev"/><name>offset</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyByteArrayObject</name> *</type><name>result</name></decl>;</decl_stmt>
<expr_stmt><expr><name>self_len</name> = <call><name>PyByteArray_GET_SIZE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>self_s</name> = <call><name>PyByteArray_AS_STRING</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>count</name> = <call><name>countstring</name><argument_list>(<argument><expr><name>self_s</name></expr></argument>, <argument><expr><name>self_len</name></expr></argument>,
<argument><expr><name>from_s</name></expr></argument>, <argument><expr><name>from_len</name></expr></argument>,
<argument><expr>0</expr></argument>, <argument><expr><name>self_len</name></expr></argument>, <argument><expr>1</expr></argument>,
<argument><expr><name>maxcount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>count</name> == 0</expr>)</condition><then> <block>{
<return>return <expr><call><name>return_self</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>result_len</name> = <name>self_len</name> - (<name>count</name> * <name>from_len</name>)</expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name> <argument_list>(<argument><expr><name>result_len</name>&gt;=0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>( <expr>(<name>result</name> = (<name>PyByteArrayObject</name> *)
<call><name>PyByteArray_FromStringAndSize</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>result_len</name></expr></argument>)</argument_list></call>) == <name>NULL</name></expr> )</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>result_s</name> = <call><name>PyByteArray_AS_STRING</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>start</name> = <name>self_s</name></expr>;</expr_stmt>
<expr_stmt><expr><name>end</name> = <name>self_s</name> + <name>self_len</name></expr>;</expr_stmt>
<while>while <condition>(<expr><name>count</name>-- &gt; 0</expr>)</condition> <block>{
<expr_stmt><expr><name>offset</name> = <call><name>findstring</name><argument_list>(<argument><expr><name>start</name></expr></argument>, <argument><expr><name>end</name>-<name>start</name></expr></argument>,
<argument><expr><name>from_s</name></expr></argument>, <argument><expr><name>from_len</name></expr></argument>,
<argument><expr>0</expr></argument>, <argument><expr><name>end</name>-<name>start</name></expr></argument>, <argument><expr><name>FORWARD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>offset</name> == -1</expr>)</condition><then>
<break>break;</break></then></if>
<expr_stmt><expr><name>next</name> = <name>start</name> + <name>offset</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_MEMCPY</name><argument_list>(<argument><expr><name>result_s</name></expr></argument>, <argument><expr><name>start</name></expr></argument>, <argument><expr><name>next</name>-<name>start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>result_s</name> += (<name>next</name>-<name>start</name>)</expr>;</expr_stmt>
<expr_stmt><expr><name>start</name> = <name>next</name>+<name>from_len</name></expr>;</expr_stmt>
}</block></while>
<expr_stmt><expr><call><name>Py_MEMCPY</name><argument_list>(<argument><expr><name>result_s</name></expr></argument>, <argument><expr><name>start</name></expr></argument>, <argument><expr><name>end</name>-<name>start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>result</name></expr>;</return>
}</block>
<macro><name>Py_LOCAL</name><argument_list>(<argument>PyByteArrayObject *</argument>)</argument_list></macro>
<macro><name>replace_single_character_in_place</name><argument_list>(<argument>PyByteArrayObject *self</argument>,
<argument>char from_c</argument>, <argument>char to_c</argument>,
<argument>Py_ssize_t maxcount</argument>)</argument_list></macro> <block>{
<decl_stmt><decl><type><name>char</name> *</type><name>self_s</name></decl>, *<decl><type ref="prev"/><name>result_s</name></decl>, *<decl><type ref="prev"/><name>start</name></decl>, *<decl><type ref="prev"/><name>end</name></decl>, *<decl><type ref="prev"/><name>next</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>self_len</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyByteArrayObject</name> *</type><name>result</name></decl>;</decl_stmt>
<expr_stmt><expr><name>self_s</name> = <call><name>PyByteArray_AS_STRING</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>self_len</name> = <call><name>PyByteArray_GET_SIZE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>next</name> = <call><name>findchar</name><argument_list>(<argument><expr><name>self_s</name></expr></argument>, <argument><expr><name>self_len</name></expr></argument>, <argument><expr><name>from_c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>next</name> == <name>NULL</name></expr>)</condition><then> <block>{
<return>return <expr><call><name>return_self</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>result</name> = (<name>PyByteArrayObject</name> *) <call><name>PyByteArray_FromStringAndSize</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>self_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>result</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>result_s</name> = <call><name>PyByteArray_AS_STRING</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_MEMCPY</name><argument_list>(<argument><expr><name>result_s</name></expr></argument>, <argument><expr><name>self_s</name></expr></argument>, <argument><expr><name>self_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>start</name> = <name>result_s</name> + (<name>next</name>-<name>self_s</name>)</expr>;</expr_stmt>
<expr_stmt><expr>*<name>start</name> = <name>to_c</name></expr>;</expr_stmt>
<expr_stmt><expr><name>start</name>++</expr>;</expr_stmt>
<expr_stmt><expr><name>end</name> = <name>result_s</name> + <name>self_len</name></expr>;</expr_stmt>
<while>while <condition>(<expr>--<name>maxcount</name> &gt; 0</expr>)</condition> <block>{
<expr_stmt><expr><name>next</name> = <call><name>findchar</name><argument_list>(<argument><expr><name>start</name></expr></argument>, <argument><expr><name>end</name>-<name>start</name></expr></argument>, <argument><expr><name>from_c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>next</name> == <name>NULL</name></expr>)</condition><then>
<break>break;</break></then></if>
<expr_stmt><expr>*<name>next</name> = <name>to_c</name></expr>;</expr_stmt>
<expr_stmt><expr><name>start</name> = <name>next</name>+1</expr>;</expr_stmt>
}</block></while>
<return>return <expr><name>result</name></expr>;</return>
}</block>
<macro><name>Py_LOCAL</name><argument_list>(<argument>PyByteArrayObject *</argument>)</argument_list></macro>
<macro><name>replace_substring_in_place</name><argument_list>(<argument>PyByteArrayObject *self</argument>,
<argument>const char *from_s</argument>, <argument>Py_ssize_t from_len</argument>,
<argument>const char *to_s</argument>, <argument>Py_ssize_t to_len</argument>,
<argument>Py_ssize_t maxcount</argument>)</argument_list></macro> <block>{
<decl_stmt><decl><type><name>char</name> *</type><name>result_s</name></decl>, *<decl><type ref="prev"/><name>start</name></decl>, *<decl><type ref="prev"/><name>end</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>self_s</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>self_len</name></decl>, <decl><type ref="prev"/><name>offset</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyByteArrayObject</name> *</type><name>result</name></decl>;</decl_stmt>
<expr_stmt><expr><name>self_s</name> = <call><name>PyByteArray_AS_STRING</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>self_len</name> = <call><name>PyByteArray_GET_SIZE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>offset</name> = <call><name>findstring</name><argument_list>(<argument><expr><name>self_s</name></expr></argument>, <argument><expr><name>self_len</name></expr></argument>,
<argument><expr><name>from_s</name></expr></argument>, <argument><expr><name>from_len</name></expr></argument>,
<argument><expr>0</expr></argument>, <argument><expr><name>self_len</name></expr></argument>, <argument><expr><name>FORWARD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>offset</name> == -1</expr>)</condition><then> <block>{
<return>return <expr><call><name>return_self</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>result</name> = (<name>PyByteArrayObject</name> *) <call><name>PyByteArray_FromStringAndSize</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>self_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>result</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>result_s</name> = <call><name>PyByteArray_AS_STRING</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_MEMCPY</name><argument_list>(<argument><expr><name>result_s</name></expr></argument>, <argument><expr><name>self_s</name></expr></argument>, <argument><expr><name>self_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>start</name> = <name>result_s</name> + <name>offset</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_MEMCPY</name><argument_list>(<argument><expr><name>start</name></expr></argument>, <argument><expr><name>to_s</name></expr></argument>, <argument><expr><name>from_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>start</name> += <name>from_len</name></expr>;</expr_stmt>
<expr_stmt><expr><name>end</name> = <name>result_s</name> + <name>self_len</name></expr>;</expr_stmt>
<while>while <condition>( <expr>--<name>maxcount</name> &gt; 0</expr>)</condition> <block>{
<expr_stmt><expr><name>offset</name> = <call><name>findstring</name><argument_list>(<argument><expr><name>start</name></expr></argument>, <argument><expr><name>end</name>-<name>start</name></expr></argument>,
<argument><expr><name>from_s</name></expr></argument>, <argument><expr><name>from_len</name></expr></argument>,
<argument><expr>0</expr></argument>, <argument><expr><name>end</name>-<name>start</name></expr></argument>, <argument><expr><name>FORWARD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>offset</name>==-1</expr>)</condition><then>
<break>break;</break></then></if>
<expr_stmt><expr><call><name>Py_MEMCPY</name><argument_list>(<argument><expr><name>start</name>+<name>offset</name></expr></argument>, <argument><expr><name>to_s</name></expr></argument>, <argument><expr><name>from_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>start</name> += <name>offset</name>+<name>from_len</name></expr>;</expr_stmt>
}</block></while>
<return>return <expr><name>result</name></expr>;</return>
}</block>
<macro><name>Py_LOCAL</name><argument_list>(<argument>PyByteArrayObject *</argument>)</argument_list></macro>
<macro><name>replace_single_character</name><argument_list>(<argument>PyByteArrayObject *self</argument>,
<argument>char from_c</argument>,
<argument>const char *to_s</argument>, <argument>Py_ssize_t to_len</argument>,
<argument>Py_ssize_t maxcount</argument>)</argument_list></macro> <block>{
<decl_stmt><decl><type><name>char</name> *</type><name>self_s</name></decl>, *<decl><type ref="prev"/><name>result_s</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>start</name></decl>, *<decl><type ref="prev"/><name>next</name></decl>, *<decl><type ref="prev"/><name>end</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>self_len</name></decl>, <decl><type ref="prev"/><name>result_len</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>count</name></decl>, <decl><type ref="prev"/><name>product</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyByteArrayObject</name> *</type><name>result</name></decl>;</decl_stmt>
<expr_stmt><expr><name>self_s</name> = <call><name>PyByteArray_AS_STRING</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>self_len</name> = <call><name>PyByteArray_GET_SIZE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>count</name> = <call><name>countchar</name><argument_list>(<argument><expr><name>self_s</name></expr></argument>, <argument><expr><name>self_len</name></expr></argument>, <argument><expr><name>from_c</name></expr></argument>, <argument><expr><name>maxcount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>count</name> == 0</expr>)</condition><then> <block>{
<return>return <expr><call><name>return_self</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>product</name> = <call><name>count</name> * <argument_list>(<argument><expr><name>to_len</name>-1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>product</name> / (<name>to_len</name>-1) != <name>count</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_OverflowError</name></expr></argument>, <argument><expr>"replace bytes is too long"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>result_len</name> = <name>self_len</name> + <name>product</name></expr>;</expr_stmt>
<if>if <condition>(<expr><name>result_len</name> &lt; 0</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_OverflowError</name></expr></argument>, <argument><expr>"replace bytes is too long"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<if>if <condition>( <expr>(<name>result</name> = (<name>PyByteArrayObject</name> *)
<call><name>PyByteArray_FromStringAndSize</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>result_len</name></expr></argument>)</argument_list></call>) == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>result_s</name> = <call><name>PyByteArray_AS_STRING</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>start</name> = <name>self_s</name></expr>;</expr_stmt>
<expr_stmt><expr><name>end</name> = <name>self_s</name> + <name>self_len</name></expr>;</expr_stmt>
<while>while <condition>(<expr><name>count</name>-- &gt; 0</expr>)</condition> <block>{
<expr_stmt><expr><name>next</name> = <call><name>findchar</name><argument_list>(<argument><expr><name>start</name></expr></argument>, <argument><expr><name>end</name>-<name>start</name></expr></argument>, <argument><expr><name>from_c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>next</name> == <name>NULL</name></expr>)</condition><then>
<break>break;</break></then></if>
<if>if <condition>(<expr><name>next</name> == <name>start</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_MEMCPY</name><argument_list>(<argument><expr><name>result_s</name></expr></argument>, <argument><expr><name>to_s</name></expr></argument>, <argument><expr><name>to_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>result_s</name> += <name>to_len</name></expr>;</expr_stmt>
<expr_stmt><expr><name>start</name> += 1</expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr><call><name>Py_MEMCPY</name><argument_list>(<argument><expr><name>result_s</name></expr></argument>, <argument><expr><name>start</name></expr></argument>, <argument><expr><name>next</name>-<name>start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>result_s</name> += (<name>next</name>-<name>start</name>)</expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_MEMCPY</name><argument_list>(<argument><expr><name>result_s</name></expr></argument>, <argument><expr><name>to_s</name></expr></argument>, <argument><expr><name>to_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>result_s</name> += <name>to_len</name></expr>;</expr_stmt>
<expr_stmt><expr><name>start</name> = <name>next</name>+1</expr>;</expr_stmt>
}</block></else></if>
}</block></while>
<expr_stmt><expr><call><name>Py_MEMCPY</name><argument_list>(<argument><expr><name>result_s</name></expr></argument>, <argument><expr><name>start</name></expr></argument>, <argument><expr><name>end</name>-<name>start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>result</name></expr>;</return>
}</block>
<macro><name>Py_LOCAL</name><argument_list>(<argument>PyByteArrayObject *</argument>)</argument_list></macro>
<macro><name>replace_substring</name><argument_list>(<argument>PyByteArrayObject *self</argument>,
<argument>const char *from_s</argument>, <argument>Py_ssize_t from_len</argument>,
<argument>const char *to_s</argument>, <argument>Py_ssize_t to_len</argument>,
<argument>Py_ssize_t maxcount</argument>)</argument_list></macro> <block>{
<decl_stmt><decl><type><name>char</name> *</type><name>self_s</name></decl>, *<decl><type ref="prev"/><name>result_s</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>start</name></decl>, *<decl><type ref="prev"/><name>next</name></decl>, *<decl><type ref="prev"/><name>end</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>self_len</name></decl>, <decl><type ref="prev"/><name>result_len</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>count</name></decl>, <decl><type ref="prev"/><name>offset</name></decl>, <decl><type ref="prev"/><name>product</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyByteArrayObject</name> *</type><name>result</name></decl>;</decl_stmt>
<expr_stmt><expr><name>self_s</name> = <call><name>PyByteArray_AS_STRING</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>self_len</name> = <call><name>PyByteArray_GET_SIZE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>count</name> = <call><name>countstring</name><argument_list>(<argument><expr><name>self_s</name></expr></argument>, <argument><expr><name>self_len</name></expr></argument>,
<argument><expr><name>from_s</name></expr></argument>, <argument><expr><name>from_len</name></expr></argument>,
<argument><expr>0</expr></argument>, <argument><expr><name>self_len</name></expr></argument>, <argument><expr><name>FORWARD</name></expr></argument>, <argument><expr><name>maxcount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>count</name> == 0</expr>)</condition><then> <block>{
<return>return <expr><call><name>return_self</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>product</name> = <call><name>count</name> * <argument_list>(<argument><expr><name>to_len</name>-<name>from_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>product</name> / (<name>to_len</name>-<name>from_len</name>) != <name>count</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_OverflowError</name></expr></argument>, <argument><expr>"replace bytes is too long"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>result_len</name> = <name>self_len</name> + <name>product</name></expr>;</expr_stmt>
<if>if <condition>(<expr><name>result_len</name> &lt; 0</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_OverflowError</name></expr></argument>, <argument><expr>"replace bytes is too long"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<if>if <condition>( <expr>(<name>result</name> = (<name>PyByteArrayObject</name> *)
<call><name>PyByteArray_FromStringAndSize</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>result_len</name></expr></argument>)</argument_list></call>) == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>result_s</name> = <call><name>PyByteArray_AS_STRING</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>start</name> = <name>self_s</name></expr>;</expr_stmt>
<expr_stmt><expr><name>end</name> = <name>self_s</name> + <name>self_len</name></expr>;</expr_stmt>
<while>while <condition>(<expr><name>count</name>-- &gt; 0</expr>)</condition> <block>{
<expr_stmt><expr><name>offset</name> = <call><name>findstring</name><argument_list>(<argument><expr><name>start</name></expr></argument>, <argument><expr><name>end</name>-<name>start</name></expr></argument>,
<argument><expr><name>from_s</name></expr></argument>, <argument><expr><name>from_len</name></expr></argument>,
<argument><expr>0</expr></argument>, <argument><expr><name>end</name>-<name>start</name></expr></argument>, <argument><expr><name>FORWARD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>offset</name> == -1</expr>)</condition><then>
<break>break;</break></then></if>
<expr_stmt><expr><name>next</name> = <name>start</name>+<name>offset</name></expr>;</expr_stmt>
<if>if <condition>(<expr><name>next</name> == <name>start</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_MEMCPY</name><argument_list>(<argument><expr><name>result_s</name></expr></argument>, <argument><expr><name>to_s</name></expr></argument>, <argument><expr><name>to_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>result_s</name> += <name>to_len</name></expr>;</expr_stmt>
<expr_stmt><expr><name>start</name> += <name>from_len</name></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr><call><name>Py_MEMCPY</name><argument_list>(<argument><expr><name>result_s</name></expr></argument>, <argument><expr><name>start</name></expr></argument>, <argument><expr><name>next</name>-<name>start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>result_s</name> += (<name>next</name>-<name>start</name>)</expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_MEMCPY</name><argument_list>(<argument><expr><name>result_s</name></expr></argument>, <argument><expr><name>to_s</name></expr></argument>, <argument><expr><name>to_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>result_s</name> += <name>to_len</name></expr>;</expr_stmt>
<expr_stmt><expr><name>start</name> = <name>next</name>+<name>from_len</name></expr>;</expr_stmt>
}</block></else></if>
}</block></while>
<expr_stmt><expr><call><name>Py_MEMCPY</name><argument_list>(<argument><expr><name>result_s</name></expr></argument>, <argument><expr><name>start</name></expr></argument>, <argument><expr><name>end</name>-<name>start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>result</name></expr>;</return>
}</block>
<macro><name>Py_LOCAL</name><argument_list>(<argument>PyByteArrayObject *</argument>)</argument_list></macro>
<macro><name>replace</name><argument_list>(<argument>PyByteArrayObject *self</argument>,
<argument>const char *from_s</argument>, <argument>Py_ssize_t from_len</argument>,
<argument>const char *to_s</argument>, <argument>Py_ssize_t to_len</argument>,
<argument>Py_ssize_t maxcount</argument>)</argument_list></macro> <block>{
<if>if <condition>(<expr><name>maxcount</name> &lt; 0</expr>)</condition><then> <block>{
<expr_stmt><expr><name>maxcount</name> = <name>PY_SSIZE_T_MAX</name></expr>;</expr_stmt>
}</block></then> <else>else <if>if <condition>(<expr><name>maxcount</name> == 0 || <call><name>PyByteArray_GET_SIZE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call> == 0</expr>)</condition><then> <block>{
<return>return <expr><call><name>return_self</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></then></if></else></if>
<if>if <condition>(<expr><name>maxcount</name> == 0 ||
(<name>from_len</name> == 0 &amp;&amp; <name>to_len</name> == 0)</expr>)</condition><then> <block>{
<return>return <expr><call><name>return_self</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></then></if>
<if>if <condition>(<expr><name>from_len</name> == 0</expr>)</condition><then> <block>{
<return>return <expr><call><name>replace_interleave</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>to_s</name></expr></argument>, <argument><expr><name>to_len</name></expr></argument>, <argument><expr><name>maxcount</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></then></if>
<if>if <condition>(<expr><call><name>PyByteArray_GET_SIZE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call> == 0</expr>)</condition><then> <block>{
<return>return <expr><call><name>return_self</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></then></if>
<if>if <condition>(<expr><name>to_len</name> == 0</expr>)</condition><then> <block>{
<if>if <condition>(<expr><name>from_len</name> == 1</expr>)</condition><then> <block>{
<return>return <expr><call><name>replace_delete_single_character</name><argument_list>(
<argument><expr><name>self</name></expr></argument>, <argument><expr><name><name>from_s</name><index>[<expr>0</expr>]</index></name></expr></argument>, <argument><expr><name>maxcount</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></then> <else>else <block>{
<return>return <expr><call><name>replace_delete_substring</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>from_s</name></expr></argument>, <argument><expr><name>from_len</name></expr></argument>, <argument><expr><name>maxcount</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></else></if>
}</block></then></if>
<if>if <condition>(<expr><name>from_len</name> == <name>to_len</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr><name>from_len</name> == 1</expr>)</condition><then> <block>{
<return>return <expr><call><name>replace_single_character_in_place</name><argument_list>(
<argument><expr><name>self</name></expr></argument>,
<argument><expr><name><name>from_s</name><index>[<expr>0</expr>]</index></name></expr></argument>,
<argument><expr><name><name>to_s</name><index>[<expr>0</expr>]</index></name></expr></argument>,
<argument><expr><name>maxcount</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></then> <else>else <block>{
<return>return <expr><call><name>replace_substring_in_place</name><argument_list>(
<argument><expr><name>self</name></expr></argument>, <argument><expr><name>from_s</name></expr></argument>, <argument><expr><name>from_len</name></expr></argument>, <argument><expr><name>to_s</name></expr></argument>, <argument><expr><name>to_len</name></expr></argument>, <argument><expr><name>maxcount</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></else></if>
}</block></then></if>
<if>if <condition>(<expr><name>from_len</name> == 1</expr>)</condition><then> <block>{
<return>return <expr><call><name>replace_single_character</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name><name>from_s</name><index>[<expr>0</expr>]</index></name></expr></argument>,
<argument><expr><name>to_s</name></expr></argument>, <argument><expr><name>to_len</name></expr></argument>, <argument><expr><name>maxcount</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></then> <else>else <block>{
<return>return <expr><call><name>replace_substring</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>from_s</name></expr></argument>, <argument><expr><name>from_len</name></expr></argument>, <argument><expr><name>to_s</name></expr></argument>, <argument><expr><name>to_len</name></expr></argument>, <argument><expr><name>maxcount</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></else></if>
}</block>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>replace__doc__</name></expr></argument>,
<argument><expr>"B.replace(old, new[, count]) -&gt; bytes\n\
\n\
Return a copy of B with all occurrences of subsection\n\
old replaced by new. If the optional argument count is\n\
given, only the first count occurrences are replaced."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>bytes_replace</name><parameter_list>(<param><decl><type><name>PyByteArrayObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>count</name> <init>= <expr>-1</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>from</name></decl>, *<decl><type ref="prev"/><name>to</name></decl>, *<decl><type ref="prev"/><name>res</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_buffer</name></type> <name>vfrom</name></decl>, <decl><type ref="prev"/><name>vto</name></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"OO|n:replace"</expr></argument>, <argument><expr>&amp;<name>from</name></expr></argument>, <argument><expr>&amp;<name>to</name></expr></argument>, <argument><expr>&amp;<name>count</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<if>if <condition>(<expr><call><name>_getbuffer</name><argument_list>(<argument><expr><name>from</name></expr></argument>, <argument><expr>&amp;<name>vfrom</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<if>if <condition>(<expr><call><name>_getbuffer</name><argument_list>(<argument><expr><name>to</name></expr></argument>, <argument><expr>&amp;<name>vto</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyBuffer_Release</name><argument_list>(<argument><expr>&amp;<name>vfrom</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>res</name> = (<name>PyObject</name> *)<call><name>replace</name><argument_list>(<argument><expr>(<name>PyByteArrayObject</name> *) <name>self</name></expr></argument>,
<argument><expr><name><name>vfrom</name>.<name>buf</name></name></expr></argument>, <argument><expr><name><name>vfrom</name>.<name>len</name></name></expr></argument>,
<argument><expr><name><name>vto</name>.<name>buf</name></name></expr></argument>, <argument><expr><name><name>vto</name>.<name>len</name></name></expr></argument>, <argument><expr><name>count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyBuffer_Release</name><argument_list>(<argument><expr>&amp;<name>vfrom</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyBuffer_Release</name><argument_list>(<argument><expr>&amp;<name>vto</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>res</name></expr>;</return>
}</block></function>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAX_PREALLOC</name></cpp:macro> <cpp:value>12</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PREALLOC_SIZE</name><parameter_list>(<param><type><name>maxsplit</name></type></param>)</parameter_list></cpp:macro> <cpp:value>(maxsplit &gt;= MAX_PREALLOC ? MAX_PREALLOC : maxsplit+1)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SPLIT_APPEND</name><parameter_list>(<param><type><name>data</name></type></param>, <param><type><name>left</name></type></param>, <param><type><name>right</name></type></param>)</parameter_list></cpp:macro> <cpp:value>str = PyByteArray_FromStringAndSize((data) + (left), (right) - (left)); if (str == NULL) goto onError; if (PyList_Append(list, str)) { Py_DECREF(str); goto onError; } else Py_DECREF(str);</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SPLIT_ADD</name><parameter_list>(<param><type><name>data</name></type></param>, <param><type><name>left</name></type></param>, <param><type><name>right</name></type></param>)</parameter_list></cpp:macro> <cpp:value>{ str = PyByteArray_FromStringAndSize((data) + (left), (right) - (left)); if (str == NULL) goto onError; if (count &lt; MAX_PREALLOC) { PyList_SET_ITEM(list, count, str); } else { if (PyList_Append(list, str)) { Py_DECREF(str); goto onError; } else Py_DECREF(str); } count++; }</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FIX_PREALLOC_SIZE</name><parameter_list>(<param><type><name>list</name></type></param>)</parameter_list></cpp:macro> <cpp:value>Py_SIZE(list) = count</cpp:value></cpp:define>
<macro><name>Py_LOCAL_INLINE</name><argument_list>(<argument>PyObject *</argument>)</argument_list></macro>
<macro><name>split_char</name><argument_list>(<argument>const char *s</argument>, <argument>Py_ssize_t len</argument>, <argument>char ch</argument>, <argument>Py_ssize_t maxcount</argument>)</argument_list></macro> <block>{
<decl_stmt><decl><type><name>register</name> <name>Py_ssize_t</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>, <decl><type ref="prev"/><name>count</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>str</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>list</name> <init>= <expr><call><name>PyList_New</name><argument_list>(<argument><expr><call><name>PREALLOC_SIZE</name><argument_list>(<argument><expr><name>maxcount</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>list</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>i</name> = <name>j</name> = 0</expr>;</expr_stmt>
<while>while <condition>(<expr>(<name>j</name> &lt; <name>len</name>) &amp;&amp; (<name>maxcount</name>-- &gt; 0)</expr>)</condition> <block>{
<for>for(<init>;</init> <condition><expr><name>j</name> &lt; <name>len</name></expr>;</condition> <incr><expr><name>j</name>++</expr></incr>) <block>{
<if>if <condition>(<expr><name><name>s</name><index>[<expr><name>j</name></expr>]</index></name> == <name>ch</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>SPLIT_ADD</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>i</name> = <name>j</name> = <name>j</name> + 1</expr>;</expr_stmt>
<break>break;</break>
}</block></then></if>
}</block></for>
}</block></while>
<if>if <condition>(<expr><name>i</name> &lt;= <name>len</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>SPLIT_ADD</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><call><name>FIX_PREALLOC_SIZE</name><argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>list</name></expr>;</return>
<label><name>onError</name>:</label>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block>
<macro><name>Py_LOCAL_INLINE</name><argument_list>(<argument>PyObject *</argument>)</argument_list></macro>
<macro><name>split_whitespace</name><argument_list>(<argument>const char *s</argument>, <argument>Py_ssize_t len</argument>, <argument>Py_ssize_t maxcount</argument>)</argument_list></macro> <block>{
<decl_stmt><decl><type><name>register</name> <name>Py_ssize_t</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>, <decl><type ref="prev"/><name>count</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>str</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>list</name> <init>= <expr><call><name>PyList_New</name><argument_list>(<argument><expr><call><name>PREALLOC_SIZE</name><argument_list>(<argument><expr><name>maxcount</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>list</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<for>for (<init><expr><name>i</name> = <name>j</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>len</name></expr>;</condition> <incr/>) <block>{
<while>while <condition>(<expr><name>i</name> &lt; <name>len</name> &amp;&amp; <call><name>ISSPACE</name><argument_list>(<argument><expr><name><name>s</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition>
<expr_stmt><expr><name>i</name>++</expr>;</expr_stmt></while>
<expr_stmt><expr><name>j</name> = <name>i</name></expr>;</expr_stmt>
<while>while <condition>(<expr><name>i</name> &lt; <name>len</name> &amp;&amp; !<call><name>ISSPACE</name><argument_list>(<argument><expr><name><name>s</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition>
<expr_stmt><expr><name>i</name>++</expr>;</expr_stmt></while>
<if>if <condition>(<expr><name>j</name> &lt; <name>i</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr><name>maxcount</name>-- &lt;= 0</expr>)</condition><then>
<break>break;</break></then></if>
<expr_stmt><expr><call><name>SPLIT_ADD</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<while>while <condition>(<expr><name>i</name> &lt; <name>len</name> &amp;&amp; <call><name>ISSPACE</name><argument_list>(<argument><expr><name><name>s</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition>
<expr_stmt><expr><name>i</name>++</expr>;</expr_stmt></while>
<expr_stmt><expr><name>j</name> = <name>i</name></expr>;</expr_stmt>
}</block></then></if>
}</block></for>
<if>if <condition>(<expr><name>j</name> &lt; <name>len</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>SPLIT_ADD</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><call><name>FIX_PREALLOC_SIZE</name><argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>list</name></expr>;</return>
<label><name>onError</name>:</label>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>split__doc__</name></expr></argument>,
<argument><expr>"B.split([sep[, maxsplit]]) -&gt; list of bytearray\n\
\n\
Return a list of the sections in B, using sep as the delimiter.\n\
If sep is not given, B is split on ASCII whitespace characters\n\
(space, tab, return, newline, formfeed, vertical tab).\n\
If maxsplit is given, at most maxsplit splits are done."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>bytes_split</name><parameter_list>(<param><decl><type><name>PyByteArrayObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>len</name> <init>= <expr><call><name>PyByteArray_GET_SIZE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></init>, <name>n</name></decl>, <decl><type ref="prev"/><name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>maxsplit</name> <init>= <expr>-1</expr></init>, <name>count</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>s</name> <init>= <expr><call><name>PyByteArray_AS_STRING</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></init>, *<name>sub</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>list</name></decl>, *<decl><type ref="prev"/><name>str</name></decl>, *<decl><type ref="prev"/><name>subobj</name> <init>= <expr><name>Py_None</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_buffer</name></type> <name>vsub</name></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>USE_FAST</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>pos</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"|On:split"</expr></argument>, <argument><expr>&amp;<name>subobj</name></expr></argument>, <argument><expr>&amp;<name>maxsplit</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<if>if <condition>(<expr><name>maxsplit</name> &lt; 0</expr>)</condition><then>
<expr_stmt><expr><name>maxsplit</name> = <name>PY_SSIZE_T_MAX</name></expr>;</expr_stmt></then></if>
<if>if <condition>(<expr><name>subobj</name> == <name>Py_None</name></expr>)</condition><then>
<return>return <expr><call><name>split_whitespace</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>maxsplit</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
<if>if <condition>(<expr><call><name>_getbuffer</name><argument_list>(<argument><expr><name>subobj</name></expr></argument>, <argument><expr>&amp;<name>vsub</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>sub</name> = <name><name>vsub</name>.<name>buf</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>n</name> = <name><name>vsub</name>.<name>len</name></name></expr>;</expr_stmt>
<if>if <condition>(<expr><name>n</name> == 0</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>, <argument><expr>"empty separator"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyBuffer_Release</name><argument_list>(<argument><expr>&amp;<name>vsub</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<if>if <condition>(<expr><name>n</name> == 1</expr>)</condition><then> <block>{
<expr_stmt><expr><name>list</name> = <call><name>split_char</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name><name>sub</name><index>[<expr>0</expr>]</index></name></expr></argument>, <argument><expr><name>maxsplit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyBuffer_Release</name><argument_list>(<argument><expr>&amp;<name>vsub</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>list</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>list</name> = <call><name>PyList_New</name><argument_list>(<argument><expr><call><name>PREALLOC_SIZE</name><argument_list>(<argument><expr><name>maxsplit</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>list</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyBuffer_Release</name><argument_list>(<argument><expr>&amp;<name>vsub</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>USE_FAST</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><name>i</name> = <name>j</name> = 0</expr>;</expr_stmt>
<while>while <condition>(<expr><name>maxsplit</name>-- &gt; 0</expr>)</condition> <block>{
<expr_stmt><expr><name>pos</name> = <call><name>fastsearch</name><argument_list>(<argument><expr><name>s</name>+<name>i</name></expr></argument>, <argument><expr><name>len</name>-<name>i</name></expr></argument>, <argument><expr><name>sub</name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><name>FAST_SEARCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>pos</name> &lt; 0</expr>)</condition><then>
<break>break;</break></then></if>
<expr_stmt><expr><name>j</name> = <name>i</name>+<name>pos</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SPLIT_ADD</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>i</name> = <name>j</name> + <name>n</name></expr>;</expr_stmt>
}</block></while>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<expr_stmt><expr><name>i</name> = <name>j</name> = 0</expr>;</expr_stmt>
<while>while <condition>(<expr>(<name>j</name>+<name>n</name> &lt;= <name>len</name>) &amp;&amp; (<name>maxsplit</name>-- &gt; 0)</expr>)</condition> <block>{
<for>for (<init>;</init> <condition><expr><name>j</name>+<name>n</name> &lt;= <name>len</name></expr>;</condition> <incr><expr><name>j</name>++</expr></incr>) <block>{
<if>if <condition>(<expr><call><name>Py_STRING_MATCH</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><name>sub</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>SPLIT_ADD</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>i</name> = <name>j</name> = <name>j</name> + <name>n</name></expr>;</expr_stmt>
<break>break;</break>
}</block></then></if>
}</block></for>
}</block></while>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><call><name>SPLIT_ADD</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>FIX_PREALLOC_SIZE</name><argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyBuffer_Release</name><argument_list>(<argument><expr>&amp;<name>vsub</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>list</name></expr>;</return>
<label><name>onError</name>:</label>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyBuffer_Release</name><argument_list>(<argument><expr>&amp;<name>vsub</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>make_nullbytes_unique</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>result</name></decl></param>)</parameter_list> <block>{
<if>if <condition>(<expr><name>result</name> != <name>NULL</name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>PyTuple_Check</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>PyTuple_GET_SIZE</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call> == 3</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; 3</expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
<if>if <condition>(<expr><call><name>PyTuple_GET_ITEM</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call> == (<name>PyObject</name> *)<name>nullbytes</name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>new</name> <init>= <expr><call><name>PyByteArray_FromStringAndSize</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>new</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>result</name> = <name>NULL</name></expr>;</expr_stmt>
<break>break;</break>
}</block></then></if>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>nullbytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyTuple_SET_ITEM</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>new</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
}</block></for>
}</block></then></if>
<return>return <expr><name>result</name></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>partition__doc__</name></expr></argument>,
<argument><expr>"B.partition(sep) -&gt; (head, sep, tail)\n\
\n\
Searches for the separator sep in B, and returns the part before it,\n\
the separator itself, and the part after it. If the separator is not\n\
found, returns B and two empty bytearray objects."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>bytes_partition</name><parameter_list>(<param><decl><type><name>PyByteArrayObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>sep_obj</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>bytesep</name></decl>, *<decl><type ref="prev"/><name>result</name></decl>;</decl_stmt>
<expr_stmt><expr><name>bytesep</name> = <call><name>PyByteArray_FromObject</name><argument_list>(<argument><expr><name>sep_obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>! <name>bytesep</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>result</name> = <call><name>stringlib_partition</name><argument_list>(
<argument><expr>(<name>PyObject</name>*) <name>self</name></expr></argument>,
<argument><expr><call><name>PyByteArray_AS_STRING</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>PyByteArray_GET_SIZE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>bytesep</name></expr></argument>,
<argument><expr><call><name>PyByteArray_AS_STRING</name><argument_list>(<argument><expr><name>bytesep</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>PyByteArray_GET_SIZE</name><argument_list>(<argument><expr><name>bytesep</name></expr></argument>)</argument_list></call></expr></argument>
)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>bytesep</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>make_nullbytes_unique</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>rpartition__doc__</name></expr></argument>,
<argument><expr>"B.rpartition(sep) -&gt; (tail, sep, head)\n\
\n\
Searches for the separator sep in B, starting at the end of B,\n\
and returns the part before it, the separator itself, and the\n\
part after it. If the separator is not found, returns two empty\n\
bytearray objects and B."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>bytes_rpartition</name><parameter_list>(<param><decl><type><name>PyByteArrayObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>sep_obj</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>bytesep</name></decl>, *<decl><type ref="prev"/><name>result</name></decl>;</decl_stmt>
<expr_stmt><expr><name>bytesep</name> = <call><name>PyByteArray_FromObject</name><argument_list>(<argument><expr><name>sep_obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>! <name>bytesep</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>result</name> = <call><name>stringlib_rpartition</name><argument_list>(
<argument><expr>(<name>PyObject</name>*) <name>self</name></expr></argument>,
<argument><expr><call><name>PyByteArray_AS_STRING</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>PyByteArray_GET_SIZE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>bytesep</name></expr></argument>,
<argument><expr><call><name>PyByteArray_AS_STRING</name><argument_list>(<argument><expr><name>bytesep</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>PyByteArray_GET_SIZE</name><argument_list>(<argument><expr><name>bytesep</name></expr></argument>)</argument_list></call></expr></argument>
)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>bytesep</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>make_nullbytes_unique</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<macro><name>Py_LOCAL_INLINE</name><argument_list>(<argument>PyObject *</argument>)</argument_list></macro>
<macro><name>rsplit_char</name><argument_list>(<argument>const char *s</argument>, <argument>Py_ssize_t len</argument>, <argument>char ch</argument>, <argument>Py_ssize_t maxcount</argument>)</argument_list></macro> <block>{
<decl_stmt><decl><type><name>register</name> <name>Py_ssize_t</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>, <decl><type ref="prev"/><name>count</name><init>=<expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>str</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>list</name> <init>= <expr><call><name>PyList_New</name><argument_list>(<argument><expr><call><name>PREALLOC_SIZE</name><argument_list>(<argument><expr><name>maxcount</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>list</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>i</name> = <name>j</name> = <name>len</name> - 1</expr>;</expr_stmt>
<while>while <condition>(<expr>(<name>i</name> &gt;= 0) &amp;&amp; (<name>maxcount</name>-- &gt; 0)</expr>)</condition> <block>{
<for>for (<init>;</init> <condition><expr><name>i</name> &gt;= 0</expr>;</condition> <incr><expr><name>i</name>--</expr></incr>) <block>{
<if>if <condition>(<expr><name><name>s</name><index>[<expr><name>i</name></expr>]</index></name> == <name>ch</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>SPLIT_ADD</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>i</name> + 1</expr></argument>, <argument><expr><name>j</name> + 1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>j</name> = <name>i</name> = <name>i</name> - 1</expr>;</expr_stmt>
<break>break;</break>
}</block></then></if>
}</block></for>
}</block></while>
<if>if <condition>(<expr><name>j</name> &gt;= -1</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>SPLIT_ADD</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>j</name> + 1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><call><name>FIX_PREALLOC_SIZE</name><argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>PyList_Reverse</name><argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
<goto>goto <name>onError</name>;</goto></then></if>
<return>return <expr><name>list</name></expr>;</return>
<label><name>onError</name>:</label>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block>
<macro><name>Py_LOCAL_INLINE</name><argument_list>(<argument>PyObject *</argument>)</argument_list></macro>
<macro><name>rsplit_whitespace</name><argument_list>(<argument>const char *s</argument>, <argument>Py_ssize_t len</argument>, <argument>Py_ssize_t maxcount</argument>)</argument_list></macro> <block>{
<decl_stmt><decl><type><name>register</name> <name>Py_ssize_t</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>, <decl><type ref="prev"/><name>count</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>str</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>list</name> <init>= <expr><call><name>PyList_New</name><argument_list>(<argument><expr><call><name>PREALLOC_SIZE</name><argument_list>(<argument><expr><name>maxcount</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>list</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<for>for (<init><expr><name>i</name> = <name>j</name> = <name>len</name> - 1</expr>;</init> <condition><expr><name>i</name> &gt;= 0</expr>;</condition> <incr/>) <block>{
<while>while <condition>(<expr><name>i</name> &gt;= 0 &amp;&amp; <call><name>ISSPACE</name><argument_list>(<argument><expr><name><name>s</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition>
<expr_stmt><expr><name>i</name>--</expr>;</expr_stmt></while>
<expr_stmt><expr><name>j</name> = <name>i</name></expr>;</expr_stmt>
<while>while <condition>(<expr><name>i</name> &gt;= 0 &amp;&amp; !<call><name>ISSPACE</name><argument_list>(<argument><expr><name><name>s</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition>
<expr_stmt><expr><name>i</name>--</expr>;</expr_stmt></while>
<if>if <condition>(<expr><name>j</name> &gt; <name>i</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr><name>maxcount</name>-- &lt;= 0</expr>)</condition><then>
<break>break;</break></then></if>
<expr_stmt><expr><call><name>SPLIT_ADD</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>i</name> + 1</expr></argument>, <argument><expr><name>j</name> + 1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<while>while <condition>(<expr><name>i</name> &gt;= 0 &amp;&amp; <call><name>ISSPACE</name><argument_list>(<argument><expr><name><name>s</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition>
<expr_stmt><expr><name>i</name>--</expr>;</expr_stmt></while>
<expr_stmt><expr><name>j</name> = <name>i</name></expr>;</expr_stmt>
}</block></then></if>
}</block></for>
<if>if <condition>(<expr><name>j</name> &gt;= 0</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>SPLIT_ADD</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>j</name> + 1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><call><name>FIX_PREALLOC_SIZE</name><argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>PyList_Reverse</name><argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
<goto>goto <name>onError</name>;</goto></then></if>
<return>return <expr><name>list</name></expr>;</return>
<label><name>onError</name>:</label>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>rsplit__doc__</name></expr></argument>,
<argument><expr>"B.rsplit(sep[, maxsplit]) -&gt; list of bytearray\n\
\n\
Return a list of the sections in B, using sep as the delimiter,\n\
starting at the end of B and working to the front.\n\
If sep is not given, B is split on ASCII whitespace characters\n\
(space, tab, return, newline, formfeed, vertical tab).\n\
If maxsplit is given, at most maxsplit splits are done."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>bytes_rsplit</name><parameter_list>(<param><decl><type><name>PyByteArrayObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>len</name> <init>= <expr><call><name>PyByteArray_GET_SIZE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></init>, <name>n</name></decl>, <decl><type ref="prev"/><name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>maxsplit</name> <init>= <expr>-1</expr></init>, <name>count</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>s</name> <init>= <expr><call><name>PyByteArray_AS_STRING</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></init>, *<name>sub</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>list</name></decl>, *<decl><type ref="prev"/><name>str</name></decl>, *<decl><type ref="prev"/><name>subobj</name> <init>= <expr><name>Py_None</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_buffer</name></type> <name>vsub</name></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"|On:rsplit"</expr></argument>, <argument><expr>&amp;<name>subobj</name></expr></argument>, <argument><expr>&amp;<name>maxsplit</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<if>if <condition>(<expr><name>maxsplit</name> &lt; 0</expr>)</condition><then>
<expr_stmt><expr><name>maxsplit</name> = <name>PY_SSIZE_T_MAX</name></expr>;</expr_stmt></then></if>
<if>if <condition>(<expr><name>subobj</name> == <name>Py_None</name></expr>)</condition><then>
<return>return <expr><call><name>rsplit_whitespace</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>maxsplit</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
<if>if <condition>(<expr><call><name>_getbuffer</name><argument_list>(<argument><expr><name>subobj</name></expr></argument>, <argument><expr>&amp;<name>vsub</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>sub</name> = <name><name>vsub</name>.<name>buf</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>n</name> = <name><name>vsub</name>.<name>len</name></name></expr>;</expr_stmt>
<if>if <condition>(<expr><name>n</name> == 0</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>, <argument><expr>"empty separator"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyBuffer_Release</name><argument_list>(<argument><expr>&amp;<name>vsub</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then> <else>else <if>if <condition>(<expr><name>n</name> == 1</expr>)</condition><then> <block>{
<expr_stmt><expr><name>list</name> = <call><name>rsplit_char</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name><name>sub</name><index>[<expr>0</expr>]</index></name></expr></argument>, <argument><expr><name>maxsplit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyBuffer_Release</name><argument_list>(<argument><expr>&amp;<name>vsub</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>list</name></expr>;</return>
}</block></then></if></else></if>
<expr_stmt><expr><name>list</name> = <call><name>PyList_New</name><argument_list>(<argument><expr><call><name>PREALLOC_SIZE</name><argument_list>(<argument><expr><name>maxsplit</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>list</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyBuffer_Release</name><argument_list>(<argument><expr>&amp;<name>vsub</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>j</name> = <name>len</name></expr>;</expr_stmt>
<expr_stmt><expr><name>i</name> = <name>j</name> - <name>n</name></expr>;</expr_stmt>
<while>while <condition>( <expr>(<name>i</name> &gt;= 0) &amp;&amp; (<name>maxsplit</name>-- &gt; 0)</expr> )</condition> <block>{
<for>for (<init>;</init> <condition><expr><name>i</name>&gt;=0</expr>;</condition> <incr><expr><name>i</name>--</expr></incr>) <block>{
<if>if <condition>(<expr><call><name>Py_STRING_MATCH</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>sub</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>SPLIT_ADD</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>i</name> + <name>n</name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>j</name> = <name>i</name></expr>;</expr_stmt>
<expr_stmt><expr><name>i</name> -= <name>n</name></expr>;</expr_stmt>
<break>break;</break>
}</block></then></if>
}</block></for>
}</block></while>
<expr_stmt><expr><call><name>SPLIT_ADD</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>FIX_PREALLOC_SIZE</name><argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>PyList_Reverse</name><argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
<goto>goto <name>onError</name>;</goto></then></if>
<expr_stmt><expr><call><name>PyBuffer_Release</name><argument_list>(<argument><expr>&amp;<name>vsub</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>list</name></expr>;</return>
<label><name>onError</name>:</label>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyBuffer_Release</name><argument_list>(<argument><expr>&amp;<name>vsub</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>reverse__doc__</name></expr></argument>,
<argument><expr>"B.reverse() -&gt; None\n\
\n\
Reverse the order of the values in B in place."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>bytes_reverse</name><parameter_list>(<param><decl><type><name>PyByteArrayObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>unused</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>char</name></type> <name>swap</name></decl>, *<decl><type ref="prev"/><name>head</name></decl>, *<decl><type ref="prev"/><name>tail</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>, <decl><type ref="prev"/><name>n</name> <init>= <expr><call><name>Py_SIZE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>j</name> = <name>n</name> / 2</expr>;</expr_stmt>
<expr_stmt><expr><name>head</name> = <name><name>self</name>-&gt;<name>ob_bytes</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>tail</name> = <name>head</name> + <name>n</name> - 1</expr>;</expr_stmt>
<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>j</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
<expr_stmt><expr><name>swap</name> = *<name>head</name></expr>;</expr_stmt>
<expr_stmt><expr>*<name>head</name>++ = *<name>tail</name></expr>;</expr_stmt>
<expr_stmt><expr>*<name>tail</name>-- = <name>swap</name></expr>;</expr_stmt>
}</block></for>
<expr_stmt><expr><name>Py_RETURN_NONE</name></expr>;</expr_stmt>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>insert__doc__</name></expr></argument>,
<argument><expr>"B.insert(index, int) -&gt; None\n\
\n\
Insert a single item into the bytearray before the given index."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>bytes_insert</name><parameter_list>(<param><decl><type><name>PyByteArrayObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>value</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>ival</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>where</name></decl>, <decl><type ref="prev"/><name>n</name> <init>= <expr><call><name>Py_SIZE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"nO:insert"</expr></argument>, <argument><expr>&amp;<name>where</name></expr></argument>, <argument><expr>&amp;<name>value</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<if>if <condition>(<expr><name>n</name> == <name>PY_SSIZE_T_MAX</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_OverflowError</name></expr></argument>,
<argument><expr>"cannot add more objects to bytes"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<if>if <condition>(<expr>!<call><name>_getbytevalue</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr>&amp;<name>ival</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<if>if <condition>(<expr><call><name>PyByteArray_Resize</name><argument_list>(<argument><expr>(<name>PyObject</name> *)<name>self</name></expr></argument>, <argument><expr><name>n</name> + 1</expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<if>if <condition>(<expr><name>where</name> &lt; 0</expr>)</condition><then> <block>{
<expr_stmt><expr><name>where</name> += <name>n</name></expr>;</expr_stmt>
<if>if <condition>(<expr><name>where</name> &lt; 0</expr>)</condition><then>
<expr_stmt><expr><name>where</name> = 0</expr>;</expr_stmt></then></if>
}</block></then></if>
<if>if <condition>(<expr><name>where</name> &gt; <name>n</name></expr>)</condition><then>
<expr_stmt><expr><name>where</name> = <name>n</name></expr>;</expr_stmt></then></if>
<expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>ob_bytes</name></name> + <name>where</name> + 1</expr></argument>, <argument><expr><name><name>self</name>-&gt;<name>ob_bytes</name></name> + <name>where</name></expr></argument>, <argument><expr><name>n</name> - <name>where</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>self</name>-&gt;<name>ob_bytes</name><index>[<expr><name>where</name></expr>]</index></name> = <name>ival</name></expr>;</expr_stmt>
<expr_stmt><expr><name>Py_RETURN_NONE</name></expr>;</expr_stmt>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>append__doc__</name></expr></argument>,
<argument><expr>"B.append(int) -&gt; None\n\
\n\
Append a single item to the end of B."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>bytes_append</name><parameter_list>(<param><decl><type><name>PyByteArrayObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>arg</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>value</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>n</name> <init>= <expr><call><name>Py_SIZE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr>! <call><name>_getbytevalue</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr>&amp;<name>value</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<if>if <condition>(<expr><name>n</name> == <name>PY_SSIZE_T_MAX</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_OverflowError</name></expr></argument>,
<argument><expr>"cannot add more objects to bytes"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<if>if <condition>(<expr><call><name>PyByteArray_Resize</name><argument_list>(<argument><expr>(<name>PyObject</name> *)<name>self</name></expr></argument>, <argument><expr><name>n</name> + 1</expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name><name>self</name>-&gt;<name>ob_bytes</name><index>[<expr><name>n</name></expr>]</index></name> = <name>value</name></expr>;</expr_stmt>
<expr_stmt><expr><name>Py_RETURN_NONE</name></expr>;</expr_stmt>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>extend__doc__</name></expr></argument>,
<argument><expr>"B.extend(iterable int) -&gt; None\n\
\n\
Append all the elements from the iterator or sequence to the\n\
end of B."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>bytes_extend</name><parameter_list>(<param><decl><type><name>PyByteArrayObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>arg</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>it</name></decl>, *<decl><type ref="prev"/><name>item</name></decl>, *<decl><type ref="prev"/><name>bytes_obj</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>buf_size</name> <init>= <expr>0</expr></init>, <name>len</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>value</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>buf</name></decl>;</decl_stmt>
<if>if <condition>(<expr><call><name>PyObject_CheckBuffer</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<if>if <condition>(<expr><call><name>bytes_setslice</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><call><name>Py_SIZE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>Py_SIZE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call> == -1</expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>Py_RETURN_NONE</name></expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><name>it</name> = <call><name>PyObject_GetIter</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>it</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>buf_size</name> = <call><name>_PyObject_LengthHint</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr>32</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>bytes_obj</name> = <call><name>PyByteArray_FromStringAndSize</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>buf_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>bytes_obj</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>buf</name> = <call><name>PyByteArray_AS_STRING</name><argument_list>(<argument><expr><name>bytes_obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<while>while <condition>(<expr>(<name>item</name> = <call><name>PyIter_Next</name><argument_list>(<argument><expr><name>it</name></expr></argument>)</argument_list></call>) != <name>NULL</name></expr>)</condition> <block>{
<if>if <condition>(<expr>! <call><name>_getbytevalue</name><argument_list>(<argument><expr><name>item</name></expr></argument>, <argument><expr>&amp;<name>value</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>it</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>bytes_obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name><name>buf</name><index>[<expr><name>len</name>++</expr>]</index></name> = <name>value</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>len</name> &gt;= <name>buf_size</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>buf_size</name> = <name>len</name> + (<name>len</name> &gt;&gt; 1) + 1</expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>PyByteArray_Resize</name><argument_list>(<argument><expr>(<name>PyObject</name> *)<name>bytes_obj</name></expr></argument>, <argument><expr><name>buf_size</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>it</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>bytes_obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>buf</name> = <call><name>PyByteArray_AS_STRING</name><argument_list>(<argument><expr><name>bytes_obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
}</block></while>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>it</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>PyByteArray_Resize</name><argument_list>(<argument><expr>(<name>PyObject</name> *)<name>bytes_obj</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>bytes_obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<if>if <condition>(<expr><call><name>bytes_setslice</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><call><name>Py_SIZE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>Py_SIZE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>bytes_obj</name></expr></argument>)</argument_list></call> == -1</expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>bytes_obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>Py_RETURN_NONE</name></expr>;</expr_stmt>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>pop__doc__</name></expr></argument>,
<argument><expr>"B.pop([index]) -&gt; int\n\
\n\
Remove and return a single item from B. If no index\n\
argument is given, will pop the last value."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>bytes_pop</name><parameter_list>(<param><decl><type><name>PyByteArrayObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>value</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>where</name> <init>= <expr>-1</expr></init>, <name>n</name> <init>= <expr><call><name>Py_SIZE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"|n:pop"</expr></argument>, <argument><expr>&amp;<name>where</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<if>if <condition>(<expr><name>n</name> == 0</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_OverflowError</name></expr></argument>,
<argument><expr>"cannot pop an empty bytes"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<if>if <condition>(<expr><name>where</name> &lt; 0</expr>)</condition><then>
<expr_stmt><expr><name>where</name> += <call><name>Py_SIZE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<if>if <condition>(<expr><name>where</name> &lt; 0 || <name>where</name> &gt;= <call><name>Py_SIZE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_IndexError</name></expr></argument>, <argument><expr>"pop index out of range"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>value</name> = <name><name>self</name>-&gt;<name>ob_bytes</name><index>[<expr><name>where</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>ob_bytes</name></name> + <name>where</name></expr></argument>, <argument><expr><name><name>self</name>-&gt;<name>ob_bytes</name></name> + <name>where</name> + 1</expr></argument>, <argument><expr><name>n</name> - <name>where</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>PyByteArray_Resize</name><argument_list>(<argument><expr>(<name>PyObject</name> *)<name>self</name></expr></argument>, <argument><expr><name>n</name> - 1</expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<return>return <expr><call><name>PyInt_FromLong</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>remove__doc__</name></expr></argument>,
<argument><expr>"B.remove(int) -&gt; None\n\
\n\
Remove the first occurance of a value in B."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>bytes_remove</name><parameter_list>(<param><decl><type><name>PyByteArrayObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>arg</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>value</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>where</name></decl>, <decl><type ref="prev"/><name>n</name> <init>= <expr><call><name>Py_SIZE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr>! <call><name>_getbytevalue</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr>&amp;<name>value</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<for>for (<init><expr><name>where</name> = 0</expr>;</init> <condition><expr><name>where</name> &lt; <name>n</name></expr>;</condition> <incr><expr><name>where</name>++</expr></incr>) <block>{
<if>if <condition>(<expr><name><name>self</name>-&gt;<name>ob_bytes</name><index>[<expr><name>where</name></expr>]</index></name> == <name>value</name></expr>)</condition><then>
<break>break;</break></then></if>
}</block></for>
<if>if <condition>(<expr><name>where</name> == <name>n</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>, <argument><expr>"value not found in bytes"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>ob_bytes</name></name> + <name>where</name></expr></argument>, <argument><expr><name><name>self</name>-&gt;<name>ob_bytes</name></name> + <name>where</name> + 1</expr></argument>, <argument><expr><name>n</name> - <name>where</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>PyByteArray_Resize</name><argument_list>(<argument><expr>(<name>PyObject</name> *)<name>self</name></expr></argument>, <argument><expr><name>n</name> - 1</expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>Py_RETURN_NONE</name></expr>;</expr_stmt>
}</block></function>
<function><type><specifier>static</specifier> <name>Py_ssize_t</name></type>
<name>lstrip_helper</name><parameter_list>(<param><decl><type><name>unsigned</name> <name>char</name> *</type><name>myptr</name></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>mysize</name></decl></param>,
<param><decl><type><name>void</name> *</type><name>argptr</name></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>argsize</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>i</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<while>while <condition>(<expr><name>i</name> &lt; <name>mysize</name> &amp;&amp; <call><name>memchr</name><argument_list>(<argument><expr><name>argptr</name></expr></argument>, <argument><expr><name><name>myptr</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>argsize</name></expr></argument>)</argument_list></call></expr>)</condition>
<expr_stmt><expr><name>i</name>++</expr>;</expr_stmt></while>
<return>return <expr><name>i</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>Py_ssize_t</name></type>
<name>rstrip_helper</name><parameter_list>(<param><decl><type><name>unsigned</name> <name>char</name> *</type><name>myptr</name></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>mysize</name></decl></param>,
<param><decl><type><name>void</name> *</type><name>argptr</name></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>argsize</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>i</name> <init>= <expr><name>mysize</name> - 1</expr></init></decl>;</decl_stmt>
<while>while <condition>(<expr><name>i</name> &gt;= 0 &amp;&amp; <call><name>memchr</name><argument_list>(<argument><expr><name>argptr</name></expr></argument>, <argument><expr><name><name>myptr</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>argsize</name></expr></argument>)</argument_list></call></expr>)</condition>
<expr_stmt><expr><name>i</name>--</expr>;</expr_stmt></while>
<return>return <expr><name>i</name> + 1</expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>strip__doc__</name></expr></argument>,
<argument><expr>"B.strip([bytes]) -&gt; bytearray\n\
\n\
Strip leading and trailing bytes contained in the argument.\n\
If the argument is omitted, strip ASCII whitespace."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>bytes_strip</name><parameter_list>(<param><decl><type><name>PyByteArrayObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>left</name></decl>, <decl><type ref="prev"/><name>right</name></decl>, <decl><type ref="prev"/><name>mysize</name></decl>, <decl><type ref="prev"/><name>argsize</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>void</name> *</type><name>myptr</name></decl>, *<decl><type ref="prev"/><name>argptr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>arg</name> <init>= <expr><name>Py_None</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_buffer</name></type> <name>varg</name></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"|O:strip"</expr></argument>, <argument><expr>&amp;<name>arg</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<if>if <condition>(<expr><name>arg</name> == <name>Py_None</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>argptr</name> = "\t\n\r\f\v "</expr>;</expr_stmt>
<expr_stmt><expr><name>argsize</name> = 6</expr>;</expr_stmt>
}</block></then> <else>else <block>{
<if>if <condition>(<expr><call><name>_getbuffer</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr>&amp;<name>varg</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>argptr</name> = <name><name>varg</name>.<name>buf</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>argsize</name> = <name><name>varg</name>.<name>len</name></name></expr>;</expr_stmt>
}</block></else></if>
<expr_stmt><expr><name>myptr</name> = <name><name>self</name>-&gt;<name>ob_bytes</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>mysize</name> = <call><name>Py_SIZE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>left</name> = <call><name>lstrip_helper</name><argument_list>(<argument><expr><name>myptr</name></expr></argument>, <argument><expr><name>mysize</name></expr></argument>, <argument><expr><name>argptr</name></expr></argument>, <argument><expr><name>argsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>left</name> == <name>mysize</name></expr>)</condition><then>
<expr_stmt><expr><name>right</name> = <name>left</name></expr>;</expr_stmt></then>
<else>else
<expr_stmt><expr><name>right</name> = <call><name>rstrip_helper</name><argument_list>(<argument><expr><name>myptr</name></expr></argument>, <argument><expr><name>mysize</name></expr></argument>, <argument><expr><name>argptr</name></expr></argument>, <argument><expr><name>argsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
<if>if <condition>(<expr><name>arg</name> != <name>Py_None</name></expr>)</condition><then>
<expr_stmt><expr><call><name>PyBuffer_Release</name><argument_list>(<argument><expr>&amp;<name>varg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<return>return <expr><call><name>PyByteArray_FromStringAndSize</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>ob_bytes</name></name> + <name>left</name></expr></argument>, <argument><expr><name>right</name> - <name>left</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>lstrip__doc__</name></expr></argument>,
<argument><expr>"B.lstrip([bytes]) -&gt; bytearray\n\
\n\
Strip leading bytes contained in the argument.\n\
If the argument is omitted, strip leading ASCII whitespace."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>bytes_lstrip</name><parameter_list>(<param><decl><type><name>PyByteArrayObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>left</name></decl>, <decl><type ref="prev"/><name>right</name></decl>, <decl><type ref="prev"/><name>mysize</name></decl>, <decl><type ref="prev"/><name>argsize</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>void</name> *</type><name>myptr</name></decl>, *<decl><type ref="prev"/><name>argptr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>arg</name> <init>= <expr><name>Py_None</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_buffer</name></type> <name>varg</name></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"|O:lstrip"</expr></argument>, <argument><expr>&amp;<name>arg</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<if>if <condition>(<expr><name>arg</name> == <name>Py_None</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>argptr</name> = "\t\n\r\f\v "</expr>;</expr_stmt>
<expr_stmt><expr><name>argsize</name> = 6</expr>;</expr_stmt>
}</block></then> <else>else <block>{
<if>if <condition>(<expr><call><name>_getbuffer</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr>&amp;<name>varg</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>argptr</name> = <name><name>varg</name>.<name>buf</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>argsize</name> = <name><name>varg</name>.<name>len</name></name></expr>;</expr_stmt>
}</block></else></if>
<expr_stmt><expr><name>myptr</name> = <name><name>self</name>-&gt;<name>ob_bytes</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>mysize</name> = <call><name>Py_SIZE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>left</name> = <call><name>lstrip_helper</name><argument_list>(<argument><expr><name>myptr</name></expr></argument>, <argument><expr><name>mysize</name></expr></argument>, <argument><expr><name>argptr</name></expr></argument>, <argument><expr><name>argsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>right</name> = <name>mysize</name></expr>;</expr_stmt>
<if>if <condition>(<expr><name>arg</name> != <name>Py_None</name></expr>)</condition><then>
<expr_stmt><expr><call><name>PyBuffer_Release</name><argument_list>(<argument><expr>&amp;<name>varg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<return>return <expr><call><name>PyByteArray_FromStringAndSize</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>ob_bytes</name></name> + <name>left</name></expr></argument>, <argument><expr><name>right</name> - <name>left</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>rstrip__doc__</name></expr></argument>,
<argument><expr>"B.rstrip([bytes]) -&gt; bytearray\n\
\n\
Strip trailing bytes contained in the argument.\n\
If the argument is omitted, strip trailing ASCII whitespace."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>bytes_rstrip</name><parameter_list>(<param><decl><type><name>PyByteArrayObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>left</name></decl>, <decl><type ref="prev"/><name>right</name></decl>, <decl><type ref="prev"/><name>mysize</name></decl>, <decl><type ref="prev"/><name>argsize</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>void</name> *</type><name>myptr</name></decl>, *<decl><type ref="prev"/><name>argptr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>arg</name> <init>= <expr><name>Py_None</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_buffer</name></type> <name>varg</name></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"|O:rstrip"</expr></argument>, <argument><expr>&amp;<name>arg</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<if>if <condition>(<expr><name>arg</name> == <name>Py_None</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>argptr</name> = "\t\n\r\f\v "</expr>;</expr_stmt>
<expr_stmt><expr><name>argsize</name> = 6</expr>;</expr_stmt>
}</block></then> <else>else <block>{
<if>if <condition>(<expr><call><name>_getbuffer</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr>&amp;<name>varg</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>argptr</name> = <name><name>varg</name>.<name>buf</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>argsize</name> = <name><name>varg</name>.<name>len</name></name></expr>;</expr_stmt>
}</block></else></if>
<expr_stmt><expr><name>myptr</name> = <name><name>self</name>-&gt;<name>ob_bytes</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>mysize</name> = <call><name>Py_SIZE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>left</name> = 0</expr>;</expr_stmt>
<expr_stmt><expr><name>right</name> = <call><name>rstrip_helper</name><argument_list>(<argument><expr><name>myptr</name></expr></argument>, <argument><expr><name>mysize</name></expr></argument>, <argument><expr><name>argptr</name></expr></argument>, <argument><expr><name>argsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>arg</name> != <name>Py_None</name></expr>)</condition><then>
<expr_stmt><expr><call><name>PyBuffer_Release</name><argument_list>(<argument><expr>&amp;<name>varg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<return>return <expr><call><name>PyByteArray_FromStringAndSize</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>ob_bytes</name></name> + <name>left</name></expr></argument>, <argument><expr><name>right</name> - <name>left</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>decode_doc</name></expr></argument>,
<argument><expr>"B.decode([encoding[, errors]]) -&gt; unicode object.\n\
\n\
Decodes B using the codec registered for encoding. encoding defaults\n\
to the default encoding. errors may be given to set a different error\n\
handling scheme. Default is 'strict' meaning that encoding errors raise\n\
a UnicodeDecodeError. Other possible values are 'ignore' and 'replace'\n\
as well as any other name registered with codecs.register_error that is\n\
able to handle UnicodeDecodeErrors."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>bytes_decode</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>encoding</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>errors</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"|ss:decode"</expr></argument>, <argument><expr>&amp;<name>encoding</name></expr></argument>, <argument><expr>&amp;<name>errors</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<if>if <condition>(<expr><name>encoding</name> == <name>NULL</name></expr>)</condition><then>
<expr_stmt><expr><name>encoding</name> = <call><name>PyUnicode_GetDefaultEncoding</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>
<return>return <expr><call><name>PyCodec_Decode</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>encoding</name></expr></argument>, <argument><expr><name>errors</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>alloc_doc</name></expr></argument>,
<argument><expr>"B.__alloc__() -&gt; int\n\
\n\
Returns the number of bytes actually allocated."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>bytes_alloc</name><parameter_list>(<param><decl><type><name>PyByteArrayObject</name> *</type><name>self</name></decl></param>)</parameter_list> <block>{
<return>return <expr><call><name>PyInt_FromSsize_t</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>ob_alloc</name></name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>join_doc</name></expr></argument>,
<argument><expr>"B.join(iterable_of_bytes) -&gt; bytes\n\
\n\
Concatenates any number of bytearray objects, with B in between each pair."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>bytes_join</name><parameter_list>(<param><decl><type><name>PyByteArrayObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>it</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>seq</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>mysize</name> <init>= <expr><call><name>Py_SIZE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>n</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> **</type><name>items</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>totalsize</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>result</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>dest</name></decl>;</decl_stmt>
<expr_stmt><expr><name>seq</name> = <call><name>PySequence_Fast</name><argument_list>(<argument><expr><name>it</name></expr></argument>, <argument><expr>"can only join an iterable"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>seq</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>n</name> = <call><name>PySequence_Fast_GET_SIZE</name><argument_list>(<argument><expr><name>seq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>items</name> = <call><name>PySequence_Fast_ITEMS</name><argument_list>(<argument><expr><name>seq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>n</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>obj</name> <init>= <expr><name><name>items</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>PyByteArray_Check</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call> &amp;&amp; !<call><name>PyBytes_Check</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
<argument><expr>"can only join an iterable of bytes "
"(item %ld has type '%.100s')"</expr></argument>,
<argument><expr>(<name>long</name>)<name>i</name></expr></argument>, <argument><expr><call><name>Py_TYPE</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call>-&gt;<name>tp_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>error</name>;</goto>
}</block></then></if>
<if>if <condition>(<expr><name>i</name> &gt; 0</expr>)</condition><then>
<expr_stmt><expr><name>totalsize</name> += <name>mysize</name></expr>;</expr_stmt></then></if>
<expr_stmt><expr><name>totalsize</name> += <call><name>Py_SIZE</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>totalsize</name> &lt; 0</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_NoMemory</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>error</name>;</goto>
}</block></then></if>
}</block></for>
<expr_stmt><expr><name>result</name> = <call><name>PyByteArray_FromStringAndSize</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>totalsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>result</name> == <name>NULL</name></expr>)</condition><then>
<goto>goto <name>error</name>;</goto></then></if>
<expr_stmt><expr><name>dest</name> = <call><name>PyByteArray_AS_STRING</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>n</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>obj</name> <init>= <expr><name><name>items</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>size</name> <init>= <expr><call><name>Py_SIZE</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>buf</name></decl>;</decl_stmt>
<if>if <condition>(<expr><call><name>PyByteArray_Check</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<expr_stmt><expr><name>buf</name> = <call><name>PyByteArray_AS_STRING</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
<else>else
<expr_stmt><expr><name>buf</name> = <call><name>PyBytes_AS_STRING</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
<if>if <condition>(<expr><name>i</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>dest</name></expr></argument>, <argument><expr><name><name>self</name>-&gt;<name>ob_bytes</name></name></expr></argument>, <argument><expr><name>mysize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>dest</name> += <name>mysize</name></expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>dest</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>dest</name> += <name>size</name></expr>;</expr_stmt>
}</block></for>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>seq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>result</name></expr>;</return>
<label><name>error</name>:</label>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>seq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>fromhex_doc</name></expr></argument>,
<argument><expr>"bytearray.fromhex(string) -&gt; bytearray\n\
\n\
Create a bytearray object from a string of hexadecimal numbers.\n\
Spaces between two numbers are accepted.\n\
Example: bytearray.fromhex('B9 01EF') -&gt; bytearray(b'\\xb9\\x01\\xef')."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>hex_digit_to_int</name><parameter_list>(<param><decl><type><name>Py_UNICODE</name></type> <name>c</name></decl></param>)</parameter_list> <block>{
<if>if <condition>(<expr><name>c</name> &gt;= 128</expr>)</condition><then>
<return>return <expr>-1</expr>;</return></then></if>
<if>if <condition>(<expr><call><name>ISDIGIT</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>c</name> - '0'</expr>;</return></then>
<else>else <block>{
<if>if <condition>(<expr><call><name>ISUPPER</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<expr_stmt><expr><name>c</name> = <call><name>TOLOWER</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<if>if <condition>(<expr><name>c</name> &gt;= 'a' &amp;&amp; <name>c</name> &lt;= 'f'</expr>)</condition><then>
<return>return <expr><name>c</name> - 'a' + 10</expr>;</return></then></if>
}</block></else></if>
<return>return <expr>-1</expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>bytes_fromhex</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>cls</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>newbytes</name></decl>, *<decl><type ref="prev"/><name>hexobj</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>buf</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_UNICODE</name> *</type><name>hex</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>hexlen</name></decl>, <decl><type ref="prev"/><name>byteslen</name></decl>, <decl><type ref="prev"/><name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>top</name></decl>, <decl><type ref="prev"/><name>bot</name></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"U:fromhex"</expr></argument>, <argument><expr>&amp;<name>hexobj</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>PyUnicode_Check</name><argument_list>(<argument><expr><name>hexobj</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>hexlen</name> = <call><name>PyUnicode_GET_SIZE</name><argument_list>(<argument><expr><name>hexobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>hex</name> = <call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr><name>hexobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>byteslen</name> = <name>hexlen</name>/2</expr>;</expr_stmt>
<expr_stmt><expr><name>newbytes</name> = <call><name>PyByteArray_FromStringAndSize</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>byteslen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>newbytes</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>buf</name> = <call><name>PyByteArray_AS_STRING</name><argument_list>(<argument><expr><name>newbytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for (<init><expr><name>i</name> = <name>j</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>hexlen</name></expr>;</condition> <incr><expr><name>i</name> += 2</expr></incr>) <block>{
<while>while <condition>(<expr><name><name>hex</name><index>[<expr><name>i</name></expr>]</index></name> == ' '</expr>)</condition>
<expr_stmt><expr><name>i</name>++</expr>;</expr_stmt></while>
<if>if <condition>(<expr><name>i</name> &gt;= <name>hexlen</name></expr>)</condition><then>
<break>break;</break></then></if>
<expr_stmt><expr><name>top</name> = <call><name>hex_digit_to_int</name><argument_list>(<argument><expr><name><name>hex</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>bot</name> = <call><name>hex_digit_to_int</name><argument_list>(<argument><expr><name><name>hex</name><index>[<expr><name>i</name>+1</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>top</name> == -1 || <name>bot</name> == -1</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>,
<argument><expr>"non-hexadecimal number found in "
"fromhex() arg at position %zd"</expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>error</name>;</goto>
}</block></then></if>
<expr_stmt><expr><name><name>buf</name><index>[<expr><name>j</name>++</expr>]</index></name> = (<name>top</name> &lt;&lt; 4) + <name>bot</name></expr>;</expr_stmt>
}</block></for>
<if>if <condition>(<expr><call><name>PyByteArray_Resize</name><argument_list>(<argument><expr><name>newbytes</name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
<goto>goto <name>error</name>;</goto></then></if>
<return>return <expr><name>newbytes</name></expr>;</return>
<label><name>error</name>:</label>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>newbytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>reduce_doc</name></expr></argument>, <argument><expr>"Return state information for pickling."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>bytes_reduce</name><parameter_list>(<param><decl><type><name>PyByteArrayObject</name> *</type><name>self</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>latin1</name></decl>, *<decl><type ref="prev"/><name>dict</name></decl>;</decl_stmt>
<if>if <condition>(<expr><name><name>self</name>-&gt;<name>ob_bytes</name></name></expr>)</condition><then>
<expr_stmt><expr><name>latin1</name> = <call><name>PyUnicode_DecodeLatin1</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>ob_bytes</name></name></expr></argument>,
<argument><expr><call><name>Py_SIZE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
<else>else
<expr_stmt><expr><name>latin1</name> = <call><name>PyUnicode_FromString</name><argument_list>(<argument><expr>""</expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
<expr_stmt><expr><name>dict</name> = <call><name>PyObject_GetAttrString</name><argument_list>(<argument><expr>(<name>PyObject</name> *)<name>self</name></expr></argument>, <argument><expr>"__dict__"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>dict</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_Clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>dict</name> = <name>Py_None</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>dict</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<return>return <expr><call><name>Py_BuildValue</name><argument_list>(<argument><expr>"(O(Ns)N)"</expr></argument>, <argument><expr><call><name>Py_TYPE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>latin1</name></expr></argument>, <argument><expr>"latin-1"</expr></argument>, <argument><expr><name>dict</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>sizeof_doc</name></expr></argument>,
<argument><expr>"B.__sizeof__() -&gt; int\n\
\n\
Returns the size of B in memory, in bytes"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>bytes_sizeof</name><parameter_list>(<param><decl><type><name>PyByteArrayObject</name> *</type><name>self</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>res</name></decl>;</decl_stmt>
<expr_stmt><expr><name>res</name> = <sizeof>sizeof<argument_list>(<argument><expr><name>PyByteArrayObject</name></expr></argument>)</argument_list></sizeof> + <name><name>self</name>-&gt;<name>ob_alloc</name></name> * <sizeof>sizeof<argument_list>(<argument><expr><name>char</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
<return>return <expr><call><name>PyInt_FromSsize_t</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<decl_stmt><decl><type><specifier>static</specifier> <name>PySequenceMethods</name></type> <name>bytes_as_sequence</name> <init>= <expr><block>{
<expr>(<name>lenfunc</name>)<name>bytes_length</name></expr>,
<expr>(<name>binaryfunc</name>)<name>PyByteArray_Concat</name></expr>,
<expr>(<name>ssizeargfunc</name>)<name>bytes_repeat</name></expr>,
<expr>(<name>ssizeargfunc</name>)<name>bytes_getitem</name></expr>,
<expr>0</expr>,
<expr>(<name>ssizeobjargproc</name>)<name>bytes_setitem</name></expr>,
<expr>0</expr>,
<expr>(<name>objobjproc</name>)<name>bytes_contains</name></expr>,
<expr>(<name>binaryfunc</name>)<name>bytes_iconcat</name></expr>,
<expr>(<name>ssizeargfunc</name>)<name>bytes_irepeat</name></expr>,
}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>PyMappingMethods</name></type> <name>bytes_as_mapping</name> <init>= <expr><block>{
<expr>(<name>lenfunc</name>)<name>bytes_length</name></expr>,
<expr>(<name>binaryfunc</name>)<name>bytes_subscript</name></expr>,
<expr>(<name>objobjargproc</name>)<name>bytes_ass_subscript</name></expr>,
}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>PyBufferProcs</name></type> <name>bytes_as_buffer</name> <init>= <expr><block>{
<expr>(<name>readbufferproc</name>)<name>bytes_buffer_getreadbuf</name></expr>,
<expr>(<name>writebufferproc</name>)<name>bytes_buffer_getwritebuf</name></expr>,
<expr>(<name>segcountproc</name>)<name>bytes_buffer_getsegcount</name></expr>,
<expr>(<name>charbufferproc</name>)<name>bytes_buffer_getcharbuf</name></expr>,
<expr>(<name>getbufferproc</name>)<name>bytes_getbuffer</name></expr>,
<expr>(<name>releasebufferproc</name>)<name>bytes_releasebuffer</name></expr>,
}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>PyMethodDef</name></type>
<name><name>bytes_methods</name><index>[]</index></name> <init>= <expr><block>{
<expr><block>{<expr>"__alloc__"</expr>, <expr>(<name>PyCFunction</name>)<name>bytes_alloc</name></expr>, <expr><name>METH_NOARGS</name></expr>, <expr><name>alloc_doc</name></expr>}</block></expr>,
<expr><block>{<expr>"__reduce__"</expr>, <expr>(<name>PyCFunction</name>)<name>bytes_reduce</name></expr>, <expr><name>METH_NOARGS</name></expr>, <expr><name>reduce_doc</name></expr>}</block></expr>,
<expr><block>{<expr>"__sizeof__"</expr>, <expr>(<name>PyCFunction</name>)<name>bytes_sizeof</name></expr>, <expr><name>METH_NOARGS</name></expr>, <expr><name>sizeof_doc</name></expr>}</block></expr>,
<expr><block>{<expr>"append"</expr>, <expr>(<name>PyCFunction</name>)<name>bytes_append</name></expr>, <expr><name>METH_O</name></expr>, <expr><name>append__doc__</name></expr>}</block></expr>,
<expr><block>{
<expr>"capitalize"</expr>, <expr>(<name>PyCFunction</name>)<name>stringlib_capitalize</name></expr>, <expr><name>METH_NOARGS</name></expr>,
<expr><name>_Py_capitalize__doc__</name></expr>
}</block></expr>,
<expr><block>{<expr>"center"</expr>, <expr>(<name>PyCFunction</name>)<name>stringlib_center</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>center__doc__</name></expr>}</block></expr>,
<expr><block>{<expr>"count"</expr>, <expr>(<name>PyCFunction</name>)<name>bytes_count</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>count__doc__</name></expr>}</block></expr>,
<expr><block>{<expr>"decode"</expr>, <expr>(<name>PyCFunction</name>)<name>bytes_decode</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>decode_doc</name></expr>}</block></expr>,
<expr><block>{<expr>"endswith"</expr>, <expr>(<name>PyCFunction</name>)<name>bytes_endswith</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>endswith__doc__</name></expr>}</block></expr>,
<expr><block>{
<expr>"expandtabs"</expr>, <expr>(<name>PyCFunction</name>)<name>stringlib_expandtabs</name></expr>, <expr><name>METH_VARARGS</name></expr>,
<expr><name>expandtabs__doc__</name></expr>
}</block></expr>,
<expr><block>{<expr>"extend"</expr>, <expr>(<name>PyCFunction</name>)<name>bytes_extend</name></expr>, <expr><name>METH_O</name></expr>, <expr><name>extend__doc__</name></expr>}</block></expr>,
<expr><block>{<expr>"find"</expr>, <expr>(<name>PyCFunction</name>)<name>bytes_find</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>find__doc__</name></expr>}</block></expr>,
<expr><block>{
<expr>"fromhex"</expr>, <expr>(<name>PyCFunction</name>)<name>bytes_fromhex</name></expr>, <expr><name>METH_VARARGS</name>|<name>METH_CLASS</name></expr>,
<expr><name>fromhex_doc</name></expr>
}</block></expr>,
<expr><block>{<expr>"index"</expr>, <expr>(<name>PyCFunction</name>)<name>bytes_index</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>index__doc__</name></expr>}</block></expr>,
<expr><block>{<expr>"insert"</expr>, <expr>(<name>PyCFunction</name>)<name>bytes_insert</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>insert__doc__</name></expr>}</block></expr>,
<expr><block>{
<expr>"isalnum"</expr>, <expr>(<name>PyCFunction</name>)<name>stringlib_isalnum</name></expr>, <expr><name>METH_NOARGS</name></expr>,
<expr><name>_Py_isalnum__doc__</name></expr>
}</block></expr>,
<expr><block>{
<expr>"isalpha"</expr>, <expr>(<name>PyCFunction</name>)<name>stringlib_isalpha</name></expr>, <expr><name>METH_NOARGS</name></expr>,
<expr><name>_Py_isalpha__doc__</name></expr>
}</block></expr>,
<expr><block>{
<expr>"isdigit"</expr>, <expr>(<name>PyCFunction</name>)<name>stringlib_isdigit</name></expr>, <expr><name>METH_NOARGS</name></expr>,
<expr><name>_Py_isdigit__doc__</name></expr>
}</block></expr>,
<expr><block>{
<expr>"islower"</expr>, <expr>(<name>PyCFunction</name>)<name>stringlib_islower</name></expr>, <expr><name>METH_NOARGS</name></expr>,
<expr><name>_Py_islower__doc__</name></expr>
}</block></expr>,
<expr><block>{
<expr>"isspace"</expr>, <expr>(<name>PyCFunction</name>)<name>stringlib_isspace</name></expr>, <expr><name>METH_NOARGS</name></expr>,
<expr><name>_Py_isspace__doc__</name></expr>
}</block></expr>,
<expr><block>{
<expr>"istitle"</expr>, <expr>(<name>PyCFunction</name>)<name>stringlib_istitle</name></expr>, <expr><name>METH_NOARGS</name></expr>,
<expr><name>_Py_istitle__doc__</name></expr>
}</block></expr>,
<expr><block>{
<expr>"isupper"</expr>, <expr>(<name>PyCFunction</name>)<name>stringlib_isupper</name></expr>, <expr><name>METH_NOARGS</name></expr>,
<expr><name>_Py_isupper__doc__</name></expr>
}</block></expr>,
<expr><block>{<expr>"join"</expr>, <expr>(<name>PyCFunction</name>)<name>bytes_join</name></expr>, <expr><name>METH_O</name></expr>, <expr><name>join_doc</name></expr>}</block></expr>,
<expr><block>{<expr>"ljust"</expr>, <expr>(<name>PyCFunction</name>)<name>stringlib_ljust</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>ljust__doc__</name></expr>}</block></expr>,
<expr><block>{<expr>"lower"</expr>, <expr>(<name>PyCFunction</name>)<name>stringlib_lower</name></expr>, <expr><name>METH_NOARGS</name></expr>, <expr><name>_Py_lower__doc__</name></expr>}</block></expr>,
<expr><block>{<expr>"lstrip"</expr>, <expr>(<name>PyCFunction</name>)<name>bytes_lstrip</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>lstrip__doc__</name></expr>}</block></expr>,
<expr><block>{<expr>"partition"</expr>, <expr>(<name>PyCFunction</name>)<name>bytes_partition</name></expr>, <expr><name>METH_O</name></expr>, <expr><name>partition__doc__</name></expr>}</block></expr>,
<expr><block>{<expr>"pop"</expr>, <expr>(<name>PyCFunction</name>)<name>bytes_pop</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>pop__doc__</name></expr>}</block></expr>,
<expr><block>{<expr>"remove"</expr>, <expr>(<name>PyCFunction</name>)<name>bytes_remove</name></expr>, <expr><name>METH_O</name></expr>, <expr><name>remove__doc__</name></expr>}</block></expr>,
<expr><block>{<expr>"replace"</expr>, <expr>(<name>PyCFunction</name>)<name>bytes_replace</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>replace__doc__</name></expr>}</block></expr>,
<expr><block>{<expr>"reverse"</expr>, <expr>(<name>PyCFunction</name>)<name>bytes_reverse</name></expr>, <expr><name>METH_NOARGS</name></expr>, <expr><name>reverse__doc__</name></expr>}</block></expr>,
<expr><block>{<expr>"rfind"</expr>, <expr>(<name>PyCFunction</name>)<name>bytes_rfind</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>rfind__doc__</name></expr>}</block></expr>,
<expr><block>{<expr>"rindex"</expr>, <expr>(<name>PyCFunction</name>)<name>bytes_rindex</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>rindex__doc__</name></expr>}</block></expr>,
<expr><block>{<expr>"rjust"</expr>, <expr>(<name>PyCFunction</name>)<name>stringlib_rjust</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>rjust__doc__</name></expr>}</block></expr>,
<expr><block>{<expr>"rpartition"</expr>, <expr>(<name>PyCFunction</name>)<name>bytes_rpartition</name></expr>, <expr><name>METH_O</name></expr>, <expr><name>rpartition__doc__</name></expr>}</block></expr>,
<expr><block>{<expr>"rsplit"</expr>, <expr>(<name>PyCFunction</name>)<name>bytes_rsplit</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>rsplit__doc__</name></expr>}</block></expr>,
<expr><block>{<expr>"rstrip"</expr>, <expr>(<name>PyCFunction</name>)<name>bytes_rstrip</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>rstrip__doc__</name></expr>}</block></expr>,
<expr><block>{<expr>"split"</expr>, <expr>(<name>PyCFunction</name>)<name>bytes_split</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>split__doc__</name></expr>}</block></expr>,
<expr><block>{
<expr>"splitlines"</expr>, <expr>(<name>PyCFunction</name>)<name>stringlib_splitlines</name></expr>, <expr><name>METH_VARARGS</name></expr>,
<expr><name>splitlines__doc__</name></expr>
}</block></expr>,
<expr><block>{
<expr>"startswith"</expr>, <expr>(<name>PyCFunction</name>)<name>bytes_startswith</name></expr>, <expr><name>METH_VARARGS</name></expr> ,
<expr><name>startswith__doc__</name></expr>
}</block></expr>,
<expr><block>{<expr>"strip"</expr>, <expr>(<name>PyCFunction</name>)<name>bytes_strip</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>strip__doc__</name></expr>}</block></expr>,
<expr><block>{
<expr>"swapcase"</expr>, <expr>(<name>PyCFunction</name>)<name>stringlib_swapcase</name></expr>, <expr><name>METH_NOARGS</name></expr>,
<expr><name>_Py_swapcase__doc__</name></expr>
}</block></expr>,
<expr><block>{<expr>"title"</expr>, <expr>(<name>PyCFunction</name>)<name>stringlib_title</name></expr>, <expr><name>METH_NOARGS</name></expr>, <expr><name>_Py_title__doc__</name></expr>}</block></expr>,
<expr><block>{
<expr>"translate"</expr>, <expr>(<name>PyCFunction</name>)<name>bytes_translate</name></expr>, <expr><name>METH_VARARGS</name></expr>,
<expr><name>translate__doc__</name></expr>
}</block></expr>,
<expr><block>{<expr>"upper"</expr>, <expr>(<name>PyCFunction</name>)<name>stringlib_upper</name></expr>, <expr><name>METH_NOARGS</name></expr>, <expr><name>_Py_upper__doc__</name></expr>}</block></expr>,
<expr><block>{<expr>"zfill"</expr>, <expr>(<name>PyCFunction</name>)<name>stringlib_zfill</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>zfill__doc__</name></expr>}</block></expr>,
<expr><block>{<expr><name>NULL</name></expr>}</block></expr>
}</block></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>bytes_doc</name></expr></argument>,
<argument><expr>"bytearray(iterable_of_ints) -&gt; bytearray.\n\
bytearray(string, encoding[, errors]) -&gt; bytearray.\n\
bytearray(bytes_or_bytearray) -&gt; mutable copy of bytes_or_bytearray.\n\
bytearray(memory_view) -&gt; bytearray.\n\
\n\
Construct an mutable bytearray object from:\n\
- an iterable yielding integers in range(256)\n\
- a text string encoded using the specified encoding\n\
- a bytes or a bytearray object\n\
- any object implementing the buffer API.\n\
\n\
bytearray(int) -&gt; bytearray.\n\
\n\
Construct a zero-initialized bytearray of the given length."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function_decl><type><specifier>static</specifier> <name>PyObject</name> *</type><name>bytes_iter</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>seq</name></decl></param>)</parameter_list>;</function_decl>
<decl_stmt><decl><type><name>PyTypeObject</name></type> <name>PyByteArray_Type</name> <init>= <expr><block>{
<expr><call><name>PyVarObject_HEAD_INIT</name><argument_list>(<argument><expr>&amp;<name>PyType_Type</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call>
"bytearray"</expr>,
<expr><sizeof>sizeof<argument_list>(<argument><expr><name>PyByteArrayObject</name></expr></argument>)</argument_list></sizeof></expr>,
<expr>0</expr>,
<expr>(<name>destructor</name>)<name>bytes_dealloc</name></expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>(<name>reprfunc</name>)<name>bytes_repr</name></expr>,
<expr>0</expr>,
<expr>&amp;<name>bytes_as_sequence</name></expr>,
<expr>&amp;<name>bytes_as_mapping</name></expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr><name>bytes_str</name></expr>,
<expr><name>PyObject_GenericGetAttr</name></expr>,
<expr>0</expr>,
<expr>&amp;<name>bytes_as_buffer</name></expr>,
<expr><name>Py_TPFLAGS_DEFAULT</name> | <name>Py_TPFLAGS_BASETYPE</name> |
<name>Py_TPFLAGS_HAVE_NEWBUFFER</name></expr>,
<expr><name>bytes_doc</name></expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>(<name>richcmpfunc</name>)<name>bytes_richcompare</name></expr>,
<expr>0</expr>,
<expr><name>bytes_iter</name></expr>,
<expr>0</expr>,
<expr><name>bytes_methods</name></expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>(<name>initproc</name>)<name>bytes_init</name></expr>,
<expr><name>PyType_GenericAlloc</name></expr>,
<expr><name>PyType_GenericNew</name></expr>,
<expr><name>PyObject_Del</name></expr>,
}</block></expr></init></decl>;</decl_stmt>
<typedef>typedef <type><struct>struct <block>{
<decl_stmt><decl><type><name>PyObject_HEAD</name>
<name>Py_ssize_t</name></type> <name>it_index</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyByteArrayObject</name> *</type><name>it_seq</name></decl>;</decl_stmt>
}</block></struct></type> <name>bytesiterobject</name>;</typedef>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>bytesiter_dealloc</name><parameter_list>(<param><decl><type><name>bytesiterobject</name> *</type><name>it</name></decl></param>)</parameter_list> <block>{
<expr_stmt><expr><call><name>_PyObject_GC_UNTRACK</name><argument_list>(<argument><expr><name>it</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name><name>it</name>-&gt;<name>it_seq</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyObject_GC_Del</name><argument_list>(<argument><expr><name>it</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>bytesiter_traverse</name><parameter_list>(<param><decl><type><name>bytesiterobject</name> *</type><name>it</name></decl></param>, <param><decl><type><name>visitproc</name></type> <name>visit</name></decl></param>, <param><decl><type><name>void</name> *</type><name>arg</name></decl></param>)</parameter_list> <block>{
<expr_stmt><expr><call><name>Py_VISIT</name><argument_list>(<argument><expr><name><name>it</name>-&gt;<name>it_seq</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>0</expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>bytesiter_next</name><parameter_list>(<param><decl><type><name>bytesiterobject</name> *</type><name>it</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyByteArrayObject</name> *</type><name>seq</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>item</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>it</name> != <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>seq</name> = <name><name>it</name>-&gt;<name>it_seq</name></name></expr>;</expr_stmt>
<if>if <condition>(<expr><name>seq</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>PyByteArray_Check</name><argument_list>(<argument><expr><name>seq</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>it</name>-&gt;<name>it_index</name></name> &lt; <call><name>PyByteArray_GET_SIZE</name><argument_list>(<argument><expr><name>seq</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><name>item</name> = <call><name>PyInt_FromLong</name><argument_list>(
<argument><expr>(<name>unsigned</name> <name>char</name>)<name><name>seq</name>-&gt;<name>ob_bytes</name><index>[<expr><name><name>it</name>-&gt;<name>it_index</name></name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>item</name> != <name>NULL</name></expr>)</condition><then>
<expr_stmt><expr>++<name><name>it</name>-&gt;<name>it_index</name></name></expr>;</expr_stmt></then></if>
<return>return <expr><name>item</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>seq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>it</name>-&gt;<name>it_seq</name></name> = <name>NULL</name></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>bytesiter_length_hint</name><parameter_list>(<param><decl><type><name>bytesiterobject</name> *</type><name>it</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>len</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name><name>it</name>-&gt;<name>it_seq</name></name></expr>)</condition><then>
<expr_stmt><expr><name>len</name> = <call><name>PyByteArray_GET_SIZE</name><argument_list>(<argument><expr><name><name>it</name>-&gt;<name>it_seq</name></name></expr></argument>)</argument_list></call> - <name><name>it</name>-&gt;<name>it_index</name></name></expr>;</expr_stmt></then></if>
<return>return <expr><call><name>PyInt_FromSsize_t</name><argument_list>(<argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>length_hint_doc</name></expr></argument>,
<argument><expr>"Private method returning an estimate of len(list(it))."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>PyMethodDef</name></type> <name><name>bytesiter_methods</name><index>[]</index></name> <init>= <expr><block>{
<expr><block>{
<expr>"__length_hint__"</expr>, <expr>(<name>PyCFunction</name>)<name>bytesiter_length_hint</name></expr>, <expr><name>METH_NOARGS</name></expr>,
<expr><name>length_hint_doc</name></expr>
}</block></expr>,
<expr><block>{<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>}</block></expr>
}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyTypeObject</name></type> <name>PyByteArrayIter_Type</name> <init>= <expr><block>{
<expr><call><name>PyVarObject_HEAD_INIT</name><argument_list>(<argument><expr>&amp;<name>PyType_Type</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call>
"bytearray_iterator"</expr>,
<expr><sizeof>sizeof<argument_list>(<argument><expr><name>bytesiterobject</name></expr></argument>)</argument_list></sizeof></expr>,
<expr>0</expr>,
<expr>(<name>destructor</name>)<name>bytesiter_dealloc</name></expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr><name>PyObject_GenericGetAttr</name></expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr><name>Py_TPFLAGS_DEFAULT</name> | <name>Py_TPFLAGS_HAVE_GC</name></expr>,
<expr>0</expr>,
<expr>(<name>traverseproc</name>)<name>bytesiter_traverse</name></expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr><name>PyObject_SelfIter</name></expr>,
<expr>(<name>iternextfunc</name>)<name>bytesiter_next</name></expr>,
<expr><name>bytesiter_methods</name></expr>,
<expr>0</expr>,
}</block></expr></init></decl>;</decl_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>bytes_iter</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>seq</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>bytesiterobject</name> *</type><name>it</name></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>PyByteArray_Check</name><argument_list>(<argument><expr><name>seq</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_BadInternalCall</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>it</name> = <call><name>PyObject_GC_New</name><argument_list>(<argument><expr><name>bytesiterobject</name></expr></argument>, <argument><expr>&amp;<name>PyByteArrayIter_Type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>it</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name><name>it</name>-&gt;<name>it_index</name></name> = 0</expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>seq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>it</name>-&gt;<name>it_seq</name></name> = (<name>PyByteArrayObject</name> *)<name>seq</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>_PyObject_GC_TRACK</name><argument_list>(<argument><expr><name>it</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>(<name>PyObject</name> *)<name>it</name></expr>;</return>
}</block></function>
</unit>
