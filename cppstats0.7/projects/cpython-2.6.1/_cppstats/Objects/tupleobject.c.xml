<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C" filename="projects/cpython-2.6.1/_cppstats/Objects/tupleobject.c"><cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"Python.h"</cpp:file></cpp:include>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>PyTuple_MAXSAVESIZE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PyTuple_MAXSAVESIZE</name></cpp:macro> <cpp:value>20</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>PyTuple_MAXFREELIST</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PyTuple_MAXFREELIST</name></cpp:macro> <cpp:value>2000</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PyTuple_MAXSAVESIZE</name> &gt; 0</expr></cpp:if>
<decl_stmt><decl><type><specifier>static</specifier> <name>PyTupleObject</name> *</type><name><name>free_list</name><index>[<expr><name>PyTuple_MAXSAVESIZE</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name><name>numfree</name><index>[<expr><name>PyTuple_MAXSAVESIZE</name></expr>]</index></name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>COUNT_ALLOCS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>int</name></type> <name>fast_tuple_allocs</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>tuple_zero_allocs</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<function><type><name>PyObject</name> *</type>
<name>PyTuple_New</name><parameter_list>(<param><decl><type><name>register</name> <name>Py_ssize_t</name></type> <name>size</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>register</name> <name>PyTupleObject</name> *</type><name>op</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>i</name></decl>;</decl_stmt>
<if>if <condition>(<expr><name>size</name> &lt; 0</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_BadInternalCall</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PyTuple_MAXSAVESIZE</name> &gt; 0</expr></cpp:if>
<if>if <condition>(<expr><name>size</name> == 0 &amp;&amp; <name><name>free_list</name><index>[<expr>0</expr>]</index></name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>op</name> = <name><name>free_list</name><index>[<expr>0</expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>COUNT_ALLOCS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><name>tuple_zero_allocs</name>++</expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<return>return <expr>(<name>PyObject</name> *) <name>op</name></expr>;</return>
}</block></then></if>
<if>if <condition>(<expr><name>size</name> &lt; <name>PyTuple_MAXSAVESIZE</name> &amp;&amp; (<name>op</name> = <name><name>free_list</name><index>[<expr><name>size</name></expr>]</index></name>) != <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>free_list</name><index>[<expr><name>size</name></expr>]</index></name> = (<name>PyTupleObject</name> *) <name><name>op</name>-&gt;<name>ob_item</name><index>[<expr>0</expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>numfree</name><index>[<expr><name>size</name></expr>]</index></name>--</expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>COUNT_ALLOCS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><name>fast_tuple_allocs</name>++</expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>Py_TRACE_REFS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>Py_SIZE</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call> = <name>size</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_TYPE</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call> = &amp;<name>PyTuple_Type</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><call><name>_Py_NewReference</name><argument_list>(<argument><expr>(<name>PyObject</name> *)<name>op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<block>{
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>nbytes</name> <init>= <expr><name>size</name> * <sizeof>sizeof<argument_list>(<argument><expr><name>PyObject</name> *</expr></argument>)</argument_list></sizeof></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>nbytes</name> / <sizeof>sizeof<argument_list>(<argument><expr><name>PyObject</name> *</expr></argument>)</argument_list></sizeof> != (<name>size_t</name>)<name>size</name> ||
(<name>nbytes</name> &gt; <name>PY_SSIZE_T_MAX</name> - <sizeof>sizeof<argument_list>(<argument><expr><name>PyTupleObject</name></expr></argument>)</argument_list></sizeof> - <sizeof>sizeof<argument_list>(<argument><expr><name>PyObject</name> *</expr></argument>)</argument_list></sizeof>)</expr>)</condition><then> <block>{
<return>return <expr><call><name>PyErr_NoMemory</name><argument_list>()</argument_list></call></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>nbytes</name> += <sizeof>sizeof<argument_list>(<argument><expr><name>PyTupleObject</name></expr></argument>)</argument_list></sizeof> - <sizeof>sizeof<argument_list>(<argument><expr><name>PyObject</name> *</expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
<expr_stmt><expr><name>op</name> = <call><name>PyObject_GC_NewVar</name><argument_list>(<argument><expr><name>PyTupleObject</name></expr></argument>, <argument><expr>&amp;<name>PyTuple_Type</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>op</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
}</block></else></if>
<for>for (<init><expr><name>i</name>=0</expr>;</init> <condition><expr><name>i</name> &lt; <name>size</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
<expr_stmt><expr><name><name>op</name>-&gt;<name>ob_item</name><index>[<expr><name>i</name></expr>]</index></name> = <name>NULL</name></expr>;</expr_stmt></for>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PyTuple_MAXSAVESIZE</name> &gt; 0</expr></cpp:if>
<if>if <condition>(<expr><name>size</name> == 0</expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>free_list</name><index>[<expr>0</expr>]</index></name> = <name>op</name></expr>;</expr_stmt>
<expr_stmt><expr>++<name><name>numfree</name><index>[<expr>0</expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><call><name>_PyObject_GC_TRACK</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>(<name>PyObject</name> *) <name>op</name></expr>;</return>
}</block></function>
<function><type><name>Py_ssize_t</name></type>
<name>PyTuple_Size</name><parameter_list>(<param><decl><type><name>register</name> <name>PyObject</name> *</type><name>op</name></decl></param>)</parameter_list> <block>{
<if>if <condition>(<expr>!<call><name>PyTuple_Check</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_BadInternalCall</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<return>return <expr>-1</expr>;</return>
}</block></then> <else>else
<return>return <expr><call><name>Py_SIZE</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>;</return></else></if>
}</block></function>
<function><type><name>PyObject</name> *</type>
<name>PyTuple_GetItem</name><parameter_list>(<param><decl><type><name>register</name> <name>PyObject</name> *</type><name>op</name></decl></param>, <param><decl><type><name>register</name> <name>Py_ssize_t</name></type> <name>i</name></decl></param>)</parameter_list> <block>{
<if>if <condition>(<expr>!<call><name>PyTuple_Check</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_BadInternalCall</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<if>if <condition>(<expr><name>i</name> &lt; 0 || <name>i</name> &gt;= <call><name>Py_SIZE</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_IndexError</name></expr></argument>, <argument><expr>"tuple index out of range"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<return>return <expr>((<name>PyTupleObject</name> *)<name>op</name>) -&gt; <name><name>ob_item</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</return>
}</block></function>
<function><type><name>int</name></type>
<name>PyTuple_SetItem</name><parameter_list>(<param><decl><type><name>register</name> <name>PyObject</name> *</type><name>op</name></decl></param>, <param><decl><type><name>register</name> <name>Py_ssize_t</name></type> <name>i</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>newitem</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>register</name> <name>PyObject</name> *</type><name>olditem</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>register</name> <name>PyObject</name> **</type><name>p</name></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>PyTuple_Check</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call> || <name><name>op</name>-&gt;<name>ob_refcnt</name></name> != 1</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>newitem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyErr_BadInternalCall</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<return>return <expr>-1</expr>;</return>
}</block></then></if>
<if>if <condition>(<expr><name>i</name> &lt; 0 || <name>i</name> &gt;= <call><name>Py_SIZE</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>newitem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_IndexError</name></expr></argument>,
<argument><expr>"tuple assignment index out of range"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>-1</expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>p</name> = ((<name>PyTupleObject</name> *)<name>op</name>) -&gt; <name>ob_item</name> + <name>i</name></expr>;</expr_stmt>
<expr_stmt><expr><name>olditem</name> = *<name>p</name></expr>;</expr_stmt>
<expr_stmt><expr>*<name>p</name> = <name>newitem</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>olditem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>0</expr>;</return>
}</block></function>
<function><type><name>PyObject</name> *</type>
<name>PyTuple_Pack</name><parameter_list>(<param><decl><type><name>Py_ssize_t</name></type> <name>n</name></decl></param>, <param><decl><type>...</type></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>o</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>result</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> **</type><name>items</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>va_list</name></type> <name>vargs</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>vargs</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>result</name> = <call><name>PyTuple_New</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>result</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>items</name> = ((<name>PyTupleObject</name> *)<name>result</name>)-&gt;<name>ob_item</name></expr>;</expr_stmt>
<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>n</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
<expr_stmt><expr><name>o</name> = <call><name>va_arg</name><argument_list>(<argument><expr><name>vargs</name></expr></argument>, <argument><expr><name>PyObject</name> *</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>items</name><index>[<expr><name>i</name></expr>]</index></name> = <name>o</name></expr>;</expr_stmt>
}</block></for>
<expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>vargs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>result</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>tupledealloc</name><parameter_list>(<param><decl><type><name>register</name> <name>PyTupleObject</name> *</type><name>op</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>register</name> <name>Py_ssize_t</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>register</name> <name>Py_ssize_t</name></type> <name>len</name> <init>= <expr><call><name>Py_SIZE</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>PyObject_GC_UnTrack</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<macro><name>Py_TRASHCAN_SAFE_BEGIN</name><argument_list>(<argument>op</argument>)</argument_list></macro>
<if>if <condition>(<expr><name>len</name> &gt; 0</expr>)</condition><then> <block>{
<expr_stmt><expr><name>i</name> = <name>len</name></expr>;</expr_stmt>
<while>while <condition>(<expr>--<name>i</name> &gt;= 0</expr>)</condition>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name><name>op</name>-&gt;<name>ob_item</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></while>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PyTuple_MAXSAVESIZE</name> &gt; 0</expr></cpp:if>
<if>if <condition>(<expr><name>len</name> &lt; <name>PyTuple_MAXSAVESIZE</name> &amp;&amp;
<name><name>numfree</name><index>[<expr><name>len</name></expr>]</index></name> &lt; <name>PyTuple_MAXFREELIST</name> &amp;&amp;
<call><name>Py_TYPE</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call> == &amp;<name>PyTuple_Type</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>op</name>-&gt;<name>ob_item</name><index>[<expr>0</expr>]</index></name> = (<name>PyObject</name> *) <name><name>free_list</name><index>[<expr><name>len</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>numfree</name><index>[<expr><name>len</name></expr>]</index></name>++</expr>;</expr_stmt>
<expr_stmt><expr><name><name>free_list</name><index>[<expr><name>len</name></expr>]</index></name> = <name>op</name></expr>;</expr_stmt>
<goto>goto <name>done</name>;</goto>
}</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></then></if>
<expr_stmt><expr><call><name>Py_TYPE</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call>-&gt;<call><name>tp_free</name><argument_list>(<argument><expr>(<name>PyObject</name> *)<name>op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<label><name>done</name>:</label>
<macro><name>Py_TRASHCAN_SAFE_END</name><argument_list>(<argument>op</argument>)</argument_list></macro>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>tupleprint</name><parameter_list>(<param><decl><type><name>PyTupleObject</name> *</type><name>op</name></decl></param>, <param><decl><type><name>FILE</name> *</type><name>fp</name></decl></param>, <param><decl><type><name>int</name></type> <name>flags</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_BEGIN_ALLOW_THREADS</name></type>
<name>fprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr>"("</expr></argument>)</argument_list></decl>;</decl_stmt>
<macro><name>Py_END_ALLOW_THREADS</name></macro>
<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <call><name>Py_SIZE</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
<if>if <condition>(<expr><name>i</name> &gt; 0</expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>Py_BEGIN_ALLOW_THREADS</name></type>
<name>fprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr>", "</expr></argument>)</argument_list></decl>;</decl_stmt>
<expr_stmt><expr><name>Py_END_ALLOW_THREADS</name></expr></expr_stmt>
}</block></then></if>
<if>if <condition>(<expr><call><name>PyObject_Print</name><argument_list>(<argument><expr><name><name>op</name>-&gt;<name>ob_item</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>fp</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call> != 0</expr>)</condition><then>
<return>return <expr>-1</expr>;</return></then></if>
}</block></for>
<expr_stmt><expr><name>i</name> = <call><name>Py_SIZE</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<macro><name>Py_BEGIN_ALLOW_THREADS</name></macro>
<if>if <condition>(<expr><name>i</name> == 1</expr>)</condition><then>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr>","</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr>")"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<macro><name>Py_END_ALLOW_THREADS</name></macro>
<return>return <expr>0</expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>tuplerepr</name><parameter_list>(<param><decl><type><name>PyTupleObject</name> *</type><name>v</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>n</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>s</name></decl>, *<decl><type ref="prev"/><name>temp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>pieces</name></decl>, *<decl><type ref="prev"/><name>result</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>n</name> = <call><name>Py_SIZE</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>n</name> == 0</expr>)</condition><then>
<return>return <expr><call><name>PyString_FromString</name><argument_list>(<argument><expr>"()"</expr></argument>)</argument_list></call></expr>;</return></then></if>
<expr_stmt><expr><name>i</name> = <call><name>Py_ReprEnter</name><argument_list>(<argument><expr>(<name>PyObject</name> *)<name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>i</name> != 0</expr>)</condition><then> <block>{
<return>return <expr><name>i</name> &gt; 0 ? <call><name>PyString_FromString</name><argument_list>(<argument><expr>"(...)"</expr></argument>)</argument_list></call> : <name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>pieces</name> = <call><name>PyTuple_New</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>pieces</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>n</name></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>) <block>{
<if>if <condition>(<expr><call><name>Py_EnterRecursiveCall</name><argument_list>(<argument><expr>" while getting the repr of a tuple"</expr></argument>)</argument_list></call></expr>)</condition><then>
<goto>goto <name>Done</name>;</goto></then></if>
<expr_stmt><expr><name>s</name> = <call><name>PyObject_Repr</name><argument_list>(<argument><expr><name><name>v</name>-&gt;<name>ob_item</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_LeaveRecursiveCall</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>s</name> == <name>NULL</name></expr>)</condition><then>
<goto>goto <name>Done</name>;</goto></then></if>
<expr_stmt><expr><call><name>PyTuple_SET_ITEM</name><argument_list>(<argument><expr><name>pieces</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></for>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>n</name> &gt; 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>s</name> = <call><name>PyString_FromString</name><argument_list>(<argument><expr>"("</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>s</name> == <name>NULL</name></expr>)</condition><then>
<goto>goto <name>Done</name>;</goto></then></if>
<expr_stmt><expr><name>temp</name> = <call><name>PyTuple_GET_ITEM</name><argument_list>(<argument><expr><name>pieces</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyString_ConcatAndDel</name><argument_list>(<argument><expr>&amp;<name>s</name></expr></argument>, <argument><expr><name>temp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyTuple_SET_ITEM</name><argument_list>(<argument><expr><name>pieces</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>s</name> == <name>NULL</name></expr>)</condition><then>
<goto>goto <name>Done</name>;</goto></then></if>
<expr_stmt><expr><name>s</name> = <call><name>PyString_FromString</name><argument_list>(<argument><expr><name>n</name> == 1 ? ",)" : ")"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>s</name> == <name>NULL</name></expr>)</condition><then>
<goto>goto <name>Done</name>;</goto></then></if>
<expr_stmt><expr><name>temp</name> = <call><name>PyTuple_GET_ITEM</name><argument_list>(<argument><expr><name>pieces</name></expr></argument>, <argument><expr><name>n</name>-1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyString_ConcatAndDel</name><argument_list>(<argument><expr>&amp;<name>temp</name></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyTuple_SET_ITEM</name><argument_list>(<argument><expr><name>pieces</name></expr></argument>, <argument><expr><name>n</name>-1</expr></argument>, <argument><expr><name>temp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>temp</name> == <name>NULL</name></expr>)</condition><then>
<goto>goto <name>Done</name>;</goto></then></if>
<expr_stmt><expr><name>s</name> = <call><name>PyString_FromString</name><argument_list>(<argument><expr>", "</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>s</name> == <name>NULL</name></expr>)</condition><then>
<goto>goto <name>Done</name>;</goto></then></if>
<expr_stmt><expr><name>result</name> = <call><name>_PyString_Join</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>pieces</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<label><name>Done</name>:</label>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>pieces</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_ReprLeave</name><argument_list>(<argument><expr>(<name>PyObject</name> *)<name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>result</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>long</name></type>
<name>tuplehash</name><parameter_list>(<param><decl><type><name>PyTupleObject</name> *</type><name>v</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>register</name> <name>long</name></type> <name>x</name></decl>, <decl><type ref="prev"/><name>y</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>register</name> <name>Py_ssize_t</name></type> <name>len</name> <init>= <expr><call><name>Py_SIZE</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>register</name> <name>PyObject</name> **</type><name>p</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>long</name></type> <name>mult</name> <init>= <expr>1000003L</expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>x</name> = 0x345678L</expr>;</expr_stmt>
<expr_stmt><expr><name>p</name> = <name><name>v</name>-&gt;<name>ob_item</name></name></expr>;</expr_stmt>
<while>while <condition>(<expr>--<name>len</name> &gt;= 0</expr>)</condition> <block>{
<expr_stmt><expr><name>y</name> = <call><name>PyObject_Hash</name><argument_list>(<argument><expr>*<name>p</name>++</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>y</name> == -1</expr>)</condition><then>
<return>return <expr>-1</expr>;</return></then></if>
<expr_stmt><expr><name>x</name> = (<name>x</name> ^ <name>y</name>) * <name>mult</name></expr>;</expr_stmt>
<expr_stmt><expr><name>mult</name> += <call>(<name>long</name>)<argument_list>(<argument><expr>82520L + <name>len</name> + <name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></while>
<expr_stmt><expr><name>x</name> += 97531L</expr>;</expr_stmt>
<if>if <condition>(<expr><name>x</name> == -1</expr>)</condition><then>
<expr_stmt><expr><name>x</name> = -2</expr>;</expr_stmt></then></if>
<return>return <expr><name>x</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>Py_ssize_t</name></type>
<name>tuplelength</name><parameter_list>(<param><decl><type><name>PyTupleObject</name> *</type><name>a</name></decl></param>)</parameter_list> <block>{
<return>return <expr><call><name>Py_SIZE</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>tuplecontains</name><parameter_list>(<param><decl><type><name>PyTupleObject</name> *</type><name>a</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>el</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>cmp</name></decl>;</decl_stmt>
<for>for (<init><expr><name>i</name> = 0</expr>, <expr><name>cmp</name> = 0</expr> ;</init> <condition><expr><name>cmp</name> == 0 &amp;&amp; <name>i</name> &lt; <call><name>Py_SIZE</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>)
<expr_stmt><expr><name>cmp</name> = <call><name>PyObject_RichCompareBool</name><argument_list>(<argument><expr><name>el</name></expr></argument>, <argument><expr><call><name>PyTuple_GET_ITEM</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>Py_EQ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></for>
<return>return <expr><name>cmp</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>tupleitem</name><parameter_list>(<param><decl><type><name>register</name> <name>PyTupleObject</name> *</type><name>a</name></decl></param>, <param><decl><type><name>register</name> <name>Py_ssize_t</name></type> <name>i</name></decl></param>)</parameter_list> <block>{
<if>if <condition>(<expr><name>i</name> &lt; 0 || <name>i</name> &gt;= <call><name>Py_SIZE</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_IndexError</name></expr></argument>, <argument><expr>"tuple index out of range"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name><name>a</name>-&gt;<name>ob_item</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name><name>a</name>-&gt;<name>ob_item</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>tupleslice</name><parameter_list>(<param><decl><type><name>register</name> <name>PyTupleObject</name> *</type><name>a</name></decl></param>, <param><decl><type><name>register</name> <name>Py_ssize_t</name></type> <name>ilow</name></decl></param>,
<param><decl><type><name>register</name> <name>Py_ssize_t</name></type> <name>ihigh</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>register</name> <name>PyTupleObject</name> *</type><name>np</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> **</type><name>src</name></decl>, **<decl><type ref="prev"/><name>dest</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>register</name> <name>Py_ssize_t</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>len</name></decl>;</decl_stmt>
<if>if <condition>(<expr><name>ilow</name> &lt; 0</expr>)</condition><then>
<expr_stmt><expr><name>ilow</name> = 0</expr>;</expr_stmt></then></if>
<if>if <condition>(<expr><name>ihigh</name> &gt; <call><name>Py_SIZE</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<expr_stmt><expr><name>ihigh</name> = <call><name>Py_SIZE</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<if>if <condition>(<expr><name>ihigh</name> &lt; <name>ilow</name></expr>)</condition><then>
<expr_stmt><expr><name>ihigh</name> = <name>ilow</name></expr>;</expr_stmt></then></if>
<if>if <condition>(<expr><name>ilow</name> == 0 &amp;&amp; <name>ihigh</name> == <call><name>Py_SIZE</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call> &amp;&amp; <call><name>PyTuple_CheckExact</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>(<name>PyObject</name> *)<name>a</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>len</name> = <name>ihigh</name> - <name>ilow</name></expr>;</expr_stmt>
<expr_stmt><expr><name>np</name> = (<name>PyTupleObject</name> *)<call><name>PyTuple_New</name><argument_list>(<argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>np</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>src</name> = <name><name>a</name>-&gt;<name>ob_item</name></name> + <name>ilow</name></expr>;</expr_stmt>
<expr_stmt><expr><name>dest</name> = <name><name>np</name>-&gt;<name>ob_item</name></name></expr>;</expr_stmt>
<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>len</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>v</name> <init>= <expr><name><name>src</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>dest</name><index>[<expr><name>i</name></expr>]</index></name> = <name>v</name></expr>;</expr_stmt>
}</block></for>
<return>return <expr>(<name>PyObject</name> *)<name>np</name></expr>;</return>
}</block></function>
<function><type><name>PyObject</name> *</type>
<name>PyTuple_GetSlice</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>op</name></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>i</name></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>j</name></decl></param>)</parameter_list> <block>{
<if>if <condition>(<expr><name>op</name> == <name>NULL</name> || !<call><name>PyTuple_Check</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_BadInternalCall</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<return>return <expr><call><name>tupleslice</name><argument_list>(<argument><expr>(<name>PyTupleObject</name> *)<name>op</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>tupleconcat</name><parameter_list>(<param><decl><type><name>register</name> <name>PyTupleObject</name> *</type><name>a</name></decl></param>, <param><decl><type><name>register</name> <name>PyObject</name> *</type><name>bb</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>register</name> <name>Py_ssize_t</name></type> <name>size</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>register</name> <name>Py_ssize_t</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> **</type><name>src</name></decl>, **<decl><type ref="prev"/><name>dest</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyTupleObject</name> *</type><name>np</name></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>PyTuple_Check</name><argument_list>(<argument><expr><name>bb</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
<argument><expr>"can only concatenate tuple (not \"%.200s\") to tuple"</expr></argument>,
<argument><expr><call><name>Py_TYPE</name><argument_list>(<argument><expr><name>bb</name></expr></argument>)</argument_list></call>-&gt;<name>tp_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>b</name></cpp:macro> <cpp:value>((PyTupleObject *)bb)</cpp:value></cpp:define>
<expr_stmt><expr><name>size</name> = <call><name>Py_SIZE</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call> + <call><name>Py_SIZE</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>size</name> &lt; 0</expr>)</condition><then>
<return>return <expr><call><name>PyErr_NoMemory</name><argument_list>()</argument_list></call></expr>;</return></then></if>
<expr_stmt><expr><name>np</name> = (<name>PyTupleObject</name> *) <call><name>PyTuple_New</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>np</name> == <name>NULL</name></expr>)</condition><then> <block>{
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>src</name> = <name><name>a</name>-&gt;<name>ob_item</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>dest</name> = <name><name>np</name>-&gt;<name>ob_item</name></name></expr>;</expr_stmt>
<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <call><name>Py_SIZE</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>v</name> <init>= <expr><name><name>src</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>dest</name><index>[<expr><name>i</name></expr>]</index></name> = <name>v</name></expr>;</expr_stmt>
}</block></for>
<expr_stmt><expr><name>src</name> = <name><name>b</name>-&gt;<name>ob_item</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>dest</name> = <name><name>np</name>-&gt;<name>ob_item</name></name> + <call><name>Py_SIZE</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <call><name>Py_SIZE</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>v</name> <init>= <expr><name><name>src</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>dest</name><index>[<expr><name>i</name></expr>]</index></name> = <name>v</name></expr>;</expr_stmt>
}</block></for>
<return>return <expr>(<name>PyObject</name> *)<name>np</name></expr>;</return>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>b</name></cpp:undef>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>tuplerepeat</name><parameter_list>(<param><decl><type><name>PyTupleObject</name> *</type><name>a</name></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>n</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>size</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyTupleObject</name> *</type><name>np</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> **</type><name>p</name></decl>, **<decl><type ref="prev"/><name>items</name></decl>;</decl_stmt>
<if>if <condition>(<expr><name>n</name> &lt; 0</expr>)</condition><then>
<expr_stmt><expr><name>n</name> = 0</expr>;</expr_stmt></then></if>
<if>if <condition>(<expr><call><name>Py_SIZE</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call> == 0 || <name>n</name> == 1</expr>)</condition><then> <block>{
<if>if <condition>(<expr><call><name>PyTuple_CheckExact</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>(<name>PyObject</name> *)<name>a</name></expr>;</return>
}</block></then></if>
<if>if <condition>(<expr><call><name>Py_SIZE</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call> == 0</expr>)</condition><then>
<return>return <expr><call><name>PyTuple_New</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</return></then></if>
}</block></then></if>
<expr_stmt><expr><name>size</name> = <call><name>Py_SIZE</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call> * <name>n</name></expr>;</expr_stmt>
<if>if <condition>(<expr><name>size</name>/<call><name>Py_SIZE</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call> != <name>n</name></expr>)</condition><then>
<return>return <expr><call><name>PyErr_NoMemory</name><argument_list>()</argument_list></call></expr>;</return></then></if>
<expr_stmt><expr><name>np</name> = (<name>PyTupleObject</name> *) <call><name>PyTuple_New</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>np</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>p</name> = <name><name>np</name>-&gt;<name>ob_item</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>items</name> = <name><name>a</name>-&gt;<name>ob_item</name></name></expr>;</expr_stmt>
<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>n</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
<for>for (<init><expr><name>j</name> = 0</expr>;</init> <condition><expr><name>j</name> &lt; <call><name>Py_SIZE</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>j</name>++</expr></incr>) <block>{
<expr_stmt><expr>*<name>p</name> = <name><name>items</name><index>[<expr><name>j</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr>*<name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>p</name>++</expr>;</expr_stmt>
}</block></for>
}</block></for>
<return>return <expr>(<name>PyObject</name> *) <name>np</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>tupleindex</name><parameter_list>(<param><decl><type><name>PyTupleObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>start</name><init>=<expr>0</expr></init>, <name>stop</name><init>=<expr><call><name>Py_SIZE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>v</name></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"O|O&amp;O&amp;:index"</expr></argument>, <argument><expr>&amp;<name>v</name></expr></argument>,
<argument><expr><name>_PyEval_SliceIndex</name></expr></argument>, <argument><expr>&amp;<name>start</name></expr></argument>,
<argument><expr><name>_PyEval_SliceIndex</name></expr></argument>, <argument><expr>&amp;<name>stop</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<if>if <condition>(<expr><name>start</name> &lt; 0</expr>)</condition><then> <block>{
<expr_stmt><expr><name>start</name> += <call><name>Py_SIZE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>start</name> &lt; 0</expr>)</condition><then>
<expr_stmt><expr><name>start</name> = 0</expr>;</expr_stmt></then></if>
}</block></then></if>
<if>if <condition>(<expr><name>stop</name> &lt; 0</expr>)</condition><then> <block>{
<expr_stmt><expr><name>stop</name> += <call><name>Py_SIZE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>stop</name> &lt; 0</expr>)</condition><then>
<expr_stmt><expr><name>stop</name> = 0</expr>;</expr_stmt></then></if>
}</block></then></if>
<for>for (<init><expr><name>i</name> = <name>start</name></expr>;</init> <condition><expr><name>i</name> &lt; <name>stop</name> &amp;&amp; <name>i</name> &lt; <call><name>Py_SIZE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
<decl_stmt><decl><type><name>int</name></type> <name>cmp</name> <init>= <expr><call><name>PyObject_RichCompareBool</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>ob_item</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>v</name></expr></argument>, <argument><expr><name>Py_EQ</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>cmp</name> &gt; 0</expr>)</condition><then>
<return>return <expr><call><name>PyInt_FromSsize_t</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</return></then>
<else>else <if>if <condition>(<expr><name>cmp</name> &lt; 0</expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if></else></if>
}</block></for>
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>, <argument><expr>"tuple.index(x): x not in list"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>tuplecount</name><parameter_list>(<param><decl><type><name>PyTupleObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>v</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>count</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>i</name></decl>;</decl_stmt>
<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <call><name>Py_SIZE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
<decl_stmt><decl><type><name>int</name></type> <name>cmp</name> <init>= <expr><call><name>PyObject_RichCompareBool</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>ob_item</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>v</name></expr></argument>, <argument><expr><name>Py_EQ</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>cmp</name> &gt; 0</expr>)</condition><then>
<expr_stmt><expr><name>count</name>++</expr>;</expr_stmt></then>
<else>else <if>if <condition>(<expr><name>cmp</name> &lt; 0</expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if></else></if>
}</block></for>
<return>return <expr><call><name>PyInt_FromSsize_t</name><argument_list>(<argument><expr><name>count</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>tupletraverse</name><parameter_list>(<param><decl><type><name>PyTupleObject</name> *</type><name>o</name></decl></param>, <param><decl><type><name>visitproc</name></type> <name>visit</name></decl></param>, <param><decl><type><name>void</name> *</type><name>arg</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>i</name></decl>;</decl_stmt>
<for>for (<init><expr><name>i</name> = <call><name>Py_SIZE</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>;</init> <condition><expr>--<name>i</name> &gt;= 0</expr>;</condition> <incr/>)
<expr_stmt><expr><call><name>Py_VISIT</name><argument_list>(<argument><expr><name><name>o</name>-&gt;<name>ob_item</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></for>
<return>return <expr>0</expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>tuplerichcompare</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>v</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>w</name></decl></param>, <param><decl><type><name>int</name></type> <name>op</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyTupleObject</name> *</type><name>vt</name></decl>, *<decl><type ref="prev"/><name>wt</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>vlen</name></decl>, <decl><type ref="prev"/><name>wlen</name></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>PyTuple_Check</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call> || !<call><name>PyTuple_Check</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_NotImplemented</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>Py_NotImplemented</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>vt</name> = (<name>PyTupleObject</name> *)<name>v</name></expr>;</expr_stmt>
<expr_stmt><expr><name>wt</name> = (<name>PyTupleObject</name> *)<name>w</name></expr>;</expr_stmt>
<expr_stmt><expr><name>vlen</name> = <call><name>Py_SIZE</name><argument_list>(<argument><expr><name>vt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>wlen</name> = <call><name>Py_SIZE</name><argument_list>(<argument><expr><name>wt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>vlen</name> &amp;&amp; <name>i</name> &lt; <name>wlen</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
<decl_stmt><decl><type><name>int</name></type> <name>k</name> <init>= <expr><call><name>PyObject_RichCompareBool</name><argument_list>(<argument><expr><name><name>vt</name>-&gt;<name>ob_item</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
<argument><expr><name><name>wt</name>-&gt;<name>ob_item</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>Py_EQ</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>k</name> &lt; 0</expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<if>if <condition>(<expr>!<name>k</name></expr>)</condition><then>
<break>break;</break></then></if>
}</block></for>
<if>if <condition>(<expr><name>i</name> &gt;= <name>vlen</name> || <name>i</name> &gt;= <name>wlen</name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>cmp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>res</name></decl>;</decl_stmt>
<switch>switch <condition>(<expr><name>op</name></expr>)</condition> <block>{
<case>case <expr><name>Py_LT</name></expr>:
<expr_stmt><expr><name>cmp</name> = <name>vlen</name> &lt; <name>wlen</name></expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr><name>Py_LE</name></expr>:
<expr_stmt><expr><name>cmp</name> = <name>vlen</name> &lt;= <name>wlen</name></expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr><name>Py_EQ</name></expr>:
<expr_stmt><expr><name>cmp</name> = <name>vlen</name> == <name>wlen</name></expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr><name>Py_NE</name></expr>:
<expr_stmt><expr><name>cmp</name> = <name>vlen</name> != <name>wlen</name></expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr><name>Py_GT</name></expr>:
<expr_stmt><expr><name>cmp</name> = <name>vlen</name> &gt; <name>wlen</name></expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr><name>Py_GE</name></expr>:
<expr_stmt><expr><name>cmp</name> = <name>vlen</name> &gt;= <name>wlen</name></expr>;</expr_stmt>
<break>break;</break>
</case><default>default:
<return>return <expr><name>NULL</name></expr>;</return>
</default>}</block></switch>
<if>if <condition>(<expr><name>cmp</name></expr>)</condition><then>
<expr_stmt><expr><name>res</name> = <name>Py_True</name></expr>;</expr_stmt></then>
<else>else
<expr_stmt><expr><name>res</name> = <name>Py_False</name></expr>;</expr_stmt></else></if>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>res</name></expr>;</return>
}</block></then></if>
<if>if <condition>(<expr><name>op</name> == <name>Py_EQ</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_False</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>Py_False</name></expr>;</return>
}</block></then></if>
<if>if <condition>(<expr><name>op</name> == <name>Py_NE</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_True</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>Py_True</name></expr>;</return>
}</block></then></if>
<return>return <expr><call><name>PyObject_RichCompare</name><argument_list>(<argument><expr><name><name>vt</name>-&gt;<name>ob_item</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>wt</name>-&gt;<name>ob_item</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function_decl><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>tuple_subtype_new</name><parameter_list>(<param><decl><type><name>PyTypeObject</name> *</type><name>type</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>kwds</name></decl></param>)</parameter_list>;</function_decl>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>tuple_new</name><parameter_list>(<param><decl><type><name>PyTypeObject</name> *</type><name>type</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>kwds</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>arg</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> *</type><name><name>kwlist</name><index>[]</index></name> <init>= <expr><block>{<expr>"sequence"</expr>, <expr>0</expr>}</block></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>type</name> != &amp;<name>PyTuple_Type</name></expr>)</condition><then>
<return>return <expr><call><name>tuple_subtype_new</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><name>args</name></expr></argument>, <argument><expr><name>kwds</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTupleAndKeywords</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>kwds</name></expr></argument>, <argument><expr>"|O:tuple"</expr></argument>, <argument><expr><name>kwlist</name></expr></argument>, <argument><expr>&amp;<name>arg</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<if>if <condition>(<expr><name>arg</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><call><name>PyTuple_New</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</return></then>
<else>else
<return>return <expr><call><name>PySequence_Tuple</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</return></else></if>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>tuple_subtype_new</name><parameter_list>(<param><decl><type><name>PyTypeObject</name> *</type><name>type</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>kwds</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>tmp</name></decl>, *<decl><type ref="prev"/><name>newobj</name></decl>, *<decl><type ref="prev"/><name>item</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>n</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>PyType_IsSubtype</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr>&amp;<name>PyTuple_Type</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>tmp</name> = <call><name>tuple_new</name><argument_list>(<argument><expr>&amp;<name>PyTuple_Type</name></expr></argument>, <argument><expr><name>args</name></expr></argument>, <argument><expr><name>kwds</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>tmp</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>PyTuple_Check</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>newobj</name> = <call><name><name>type</name>-&gt;<name>tp_alloc</name></name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><name>n</name> = <call><name>PyTuple_GET_SIZE</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>newobj</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>n</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
<expr_stmt><expr><name>item</name> = <call><name>PyTuple_GET_ITEM</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyTuple_SET_ITEM</name><argument_list>(<argument><expr><name>newobj</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></for>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>newobj</name></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>tuple_doc</name></expr></argument>,
<argument><expr>"tuple() -&gt; an empty tuple\n"
"tuple(sequence) -&gt; tuple initialized from sequence's items\n"
"\n"
"If the argument is a tuple, the return value is the same object."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>PySequenceMethods</name></type> <name>tuple_as_sequence</name> <init>= <expr><block>{
<expr>(<name>lenfunc</name>)<name>tuplelength</name></expr>,
<expr>(<name>binaryfunc</name>)<name>tupleconcat</name></expr>,
<expr>(<name>ssizeargfunc</name>)<name>tuplerepeat</name></expr>,
<expr>(<name>ssizeargfunc</name>)<name>tupleitem</name></expr>,
<expr>(<name>ssizessizeargfunc</name>)<name>tupleslice</name></expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>(<name>objobjproc</name>)<name>tuplecontains</name></expr>,
}</block></expr></init></decl>;</decl_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name>*</type>
<name>tuplesubscript</name><parameter_list>(<param><decl><type><name>PyTupleObject</name>*</type> <name>self</name></decl></param>, <param><decl><type><name>PyObject</name>*</type> <name>item</name></decl></param>)</parameter_list> <block>{
<if>if <condition>(<expr><call><name>PyIndex_Check</name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>i</name> <init>= <expr><call><name>PyNumber_AsSsize_t</name><argument_list>(<argument><expr><name>item</name></expr></argument>, <argument><expr><name>PyExc_IndexError</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>i</name> == -1 &amp;&amp; <call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<if>if <condition>(<expr><name>i</name> &lt; 0</expr>)</condition><then>
<expr_stmt><expr><name>i</name> += <call><name>PyTuple_GET_SIZE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<return>return <expr><call><name>tupleitem</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></then> <else>else <if>if <condition>(<expr><call><name>PySlice_Check</name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>start</name></decl>, <decl><type ref="prev"/><name>stop</name></decl>, <decl><type ref="prev"/><name>step</name></decl>, <decl><type ref="prev"/><name>slicelength</name></decl>, <decl><type ref="prev"/><name>cur</name></decl>, <decl><type ref="prev"/><name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name>*</type> <name>result</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name>*</type> <name>it</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> **</type><name>src</name></decl>, **<decl><type ref="prev"/><name>dest</name></decl>;</decl_stmt>
<if>if <condition>(<expr><call><name>PySlice_GetIndicesEx</name><argument_list>(<argument><expr>(<name>PySliceObject</name>*)<name>item</name></expr></argument>,
<argument><expr><call><name>PyTuple_GET_SIZE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr>&amp;<name>start</name></expr></argument>, <argument><expr>&amp;<name>stop</name></expr></argument>, <argument><expr>&amp;<name>step</name></expr></argument>, <argument><expr>&amp;<name>slicelength</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then> <block>{
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<if>if <condition>(<expr><name>slicelength</name> &lt;= 0</expr>)</condition><then> <block>{
<return>return <expr><call><name>PyTuple_New</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</return>
}</block></then> <else>else <if>if <condition>(<expr><name>start</name> == 0 &amp;&amp; <name>step</name> == 1 &amp;&amp;
<name>slicelength</name> == <call><name>PyTuple_GET_SIZE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call> &amp;&amp;
<call><name>PyTuple_CheckExact</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>(<name>PyObject</name> *)<name>self</name></expr>;</return>
}</block></then> <else>else <block>{
<expr_stmt><expr><name>result</name> = <call><name>PyTuple_New</name><argument_list>(<argument><expr><name>slicelength</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>result</name></expr>)</condition><then> <return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>src</name> = <name><name>self</name>-&gt;<name>ob_item</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>dest</name> = ((<name>PyTupleObject</name> *)<name>result</name>)-&gt;<name>ob_item</name></expr>;</expr_stmt>
<for>for (<init><expr><name>cur</name> = <name>start</name></expr>, <expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>slicelength</name></expr>;</condition>
<incr><expr><name>cur</name> += <name>step</name></expr>, <expr><name>i</name>++</expr></incr>) <block>{
<expr_stmt><expr><name>it</name> = <name><name>src</name><index>[<expr><name>cur</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>it</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>dest</name><index>[<expr><name>i</name></expr>]</index></name> = <name>it</name></expr>;</expr_stmt>
}</block></for>
<return>return <expr><name>result</name></expr>;</return>
}</block></else></if></else></if>
}</block></then> <else>else <block>{
<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
<argument><expr>"tuple indices must be integers, not %.200s"</expr></argument>,
<argument><expr><call><name>Py_TYPE</name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call>-&gt;<name>tp_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></else></if></else></if>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>tuple_getnewargs</name><parameter_list>(<param><decl><type><name>PyTupleObject</name> *</type><name>v</name></decl></param>)</parameter_list> <block>{
<return>return <expr><call><name>Py_BuildValue</name><argument_list>(<argument><expr>"(N)"</expr></argument>, <argument><expr><call><name>tupleslice</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><call><name>Py_SIZE</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>tuple_sizeof</name><parameter_list>(<param><decl><type><name>PyTupleObject</name> *</type><name>self</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>res</name></decl>;</decl_stmt>
<expr_stmt><expr><name>res</name> = <name><name>PyTuple_Type</name>.<name>tp_basicsize</name></name> + <call><name>Py_SIZE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call> * <sizeof>sizeof<argument_list>(<argument><expr><name>PyObject</name> *</expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
<return>return <expr><call><name>PyInt_FromSsize_t</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>index_doc</name></expr></argument>,
<argument><expr>"T.index(value, [start, [stop]]) -&gt; integer -- return first index of value.\n"
"Raises ValueError if the value is not present."</expr></argument>
)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>count_doc</name></expr></argument>,
<argument><expr>"T.count(value) -&gt; integer -- return number of occurrences of value"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>sizeof_doc</name></expr></argument>,
<argument><expr>"T.__sizeof__() -- size of T in memory, in bytes"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>PyMethodDef</name></type> <name><name>tuple_methods</name><index>[]</index></name> <init>= <expr><block>{
<expr><block>{<expr>"__getnewargs__"</expr>, <expr>(<name>PyCFunction</name>)<name>tuple_getnewargs</name></expr>, <expr><name>METH_NOARGS</name></expr>}</block></expr>,
<expr><block>{<expr>"__sizeof__"</expr>, <expr>(<name>PyCFunction</name>)<name>tuple_sizeof</name></expr>, <expr><name>METH_NOARGS</name></expr>, <expr><name>sizeof_doc</name></expr>}</block></expr>,
<expr><block>{<expr>"index"</expr>, <expr>(<name>PyCFunction</name>)<name>tupleindex</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>index_doc</name></expr>}</block></expr>,
<expr><block>{<expr>"count"</expr>, <expr>(<name>PyCFunction</name>)<name>tuplecount</name></expr>, <expr><name>METH_O</name></expr>, <expr><name>count_doc</name></expr>}</block></expr>,
<expr><block>{<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>}</block></expr>
}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>PyMappingMethods</name></type> <name>tuple_as_mapping</name> <init>= <expr><block>{
<expr>(<name>lenfunc</name>)<name>tuplelength</name></expr>,
<expr>(<name>binaryfunc</name>)<name>tuplesubscript</name></expr>,
<expr>0</expr>
}</block></expr></init></decl>;</decl_stmt>
<function_decl><type><specifier>static</specifier> <name>PyObject</name> *</type><name>tuple_iter</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>seq</name></decl></param>)</parameter_list>;</function_decl>
<decl_stmt><decl><type><name>PyTypeObject</name></type> <name>PyTuple_Type</name> <init>= <expr><block>{
<expr><call><name>PyVarObject_HEAD_INIT</name><argument_list>(<argument><expr>&amp;<name>PyType_Type</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call>
"tuple"</expr>,
<expr><sizeof>sizeof<argument_list>(<argument><expr><name>PyTupleObject</name></expr></argument>)</argument_list></sizeof> - <sizeof>sizeof<argument_list>(<argument><expr><name>PyObject</name> *</expr></argument>)</argument_list></sizeof></expr>,
<expr><sizeof>sizeof<argument_list>(<argument><expr><name>PyObject</name> *</expr></argument>)</argument_list></sizeof></expr>,
<expr>(<name>destructor</name>)<name>tupledealloc</name></expr>,
<expr>(<name>printfunc</name>)<name>tupleprint</name></expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>(<name>reprfunc</name>)<name>tuplerepr</name></expr>,
<expr>0</expr>,
<expr>&amp;<name>tuple_as_sequence</name></expr>,
<expr>&amp;<name>tuple_as_mapping</name></expr>,
<expr>(<name>hashfunc</name>)<name>tuplehash</name></expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr><name>PyObject_GenericGetAttr</name></expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr><name>Py_TPFLAGS_DEFAULT</name> | <name>Py_TPFLAGS_HAVE_GC</name> |
<name>Py_TPFLAGS_BASETYPE</name> | <name>Py_TPFLAGS_TUPLE_SUBCLASS</name></expr>,
<expr><name>tuple_doc</name></expr>,
<expr>(<name>traverseproc</name>)<name>tupletraverse</name></expr>,
<expr>0</expr>,
<expr><name>tuplerichcompare</name></expr>,
<expr>0</expr>,
<expr><name>tuple_iter</name></expr>,
<expr>0</expr>,
<expr><name>tuple_methods</name></expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr><name>tuple_new</name></expr>,
<expr><name>PyObject_GC_Del</name></expr>,
}</block></expr></init></decl>;</decl_stmt>
<function><type><name>int</name></type>
<name>_PyTuple_Resize</name><parameter_list>(<param><decl><type><name>PyObject</name> **</type><name>pv</name></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>newsize</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>register</name> <name>PyTupleObject</name> *</type><name>v</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>register</name> <name>PyTupleObject</name> *</type><name>sv</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>oldsize</name></decl>;</decl_stmt>
<expr_stmt><expr><name>v</name> = (<name>PyTupleObject</name> *) *<name>pv</name></expr>;</expr_stmt>
<if>if <condition>(<expr><name>v</name> == <name>NULL</name> || <call><name>Py_TYPE</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call> != &amp;<name>PyTuple_Type</name> ||
(<call><name>Py_SIZE</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call> != 0 &amp;&amp; <call><name>Py_REFCNT</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call> != 1)</expr>)</condition><then> <block>{
<expr_stmt><expr>*<name>pv</name> = 0</expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyErr_BadInternalCall</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<return>return <expr>-1</expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>oldsize</name> = <call><name>Py_SIZE</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>oldsize</name> == <name>newsize</name></expr>)</condition><then>
<return>return <expr>0</expr>;</return></then></if>
<if>if <condition>(<expr><name>oldsize</name> == 0</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr>*<name>pv</name> = <call><name>PyTuple_New</name><argument_list>(<argument><expr><name>newsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>*<name>pv</name> == <name>NULL</name> ? -1 : 0</expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>_Py_DEC_REFTOTAL</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>_PyObject_GC_UNTRACK</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>_Py_ForgetReference</name><argument_list>(<argument><expr>(<name>PyObject</name> *) <name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for (<init><expr><name>i</name> = <name>newsize</name></expr>;</init> <condition><expr><name>i</name> &lt; <name>oldsize</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name><name>v</name>-&gt;<name>ob_item</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>v</name>-&gt;<name>ob_item</name><index>[<expr><name>i</name></expr>]</index></name> = <name>NULL</name></expr>;</expr_stmt>
}</block></for>
<expr_stmt><expr><name>sv</name> = <call><name>PyObject_GC_Resize</name><argument_list>(<argument><expr><name>PyTupleObject</name></expr></argument>, <argument><expr><name>v</name></expr></argument>, <argument><expr><name>newsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>sv</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr>*<name>pv</name> = <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyObject_GC_Del</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>-1</expr>;</return>
}</block></then></if>
<expr_stmt><expr><call><name>_Py_NewReference</name><argument_list>(<argument><expr>(<name>PyObject</name> *) <name>sv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>newsize</name> &gt; <name>oldsize</name></expr>)</condition><then>
<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr>&amp;<name><name>sv</name>-&gt;<name>ob_item</name><index>[<expr><name>oldsize</name></expr>]</index></name></expr></argument>, <argument><expr>0</expr></argument>,
<argument><expr><sizeof>sizeof<argument_list>(<argument><expr>*<name><name>sv</name>-&gt;<name>ob_item</name></name></expr></argument>)</argument_list></sizeof> * (<name>newsize</name> - <name>oldsize</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<expr_stmt><expr>*<name>pv</name> = (<name>PyObject</name> *) <name>sv</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>_PyObject_GC_TRACK</name><argument_list>(<argument><expr><name>sv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>0</expr>;</return>
}</block></function>
<function><type><name>int</name></type>
<name>PyTuple_ClearFreeList</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>freelist_size</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PyTuple_MAXSAVESIZE</name> &gt; 0</expr></cpp:if>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<for>for (<init><expr><name>i</name> = 1</expr>;</init> <condition><expr><name>i</name> &lt; <name>PyTuple_MAXSAVESIZE</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
<decl_stmt><decl><type><name>PyTupleObject</name> *</type><name>p</name></decl>, *<decl><type ref="prev"/><name>q</name></decl>;</decl_stmt>
<expr_stmt><expr><name>p</name> = <name><name>free_list</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name>freelist_size</name> += <name><name>numfree</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>free_list</name><index>[<expr><name>i</name></expr>]</index></name> = <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>numfree</name><index>[<expr><name>i</name></expr>]</index></name> = 0</expr>;</expr_stmt>
<while>while <condition>(<expr><name>p</name></expr>)</condition> <block>{
<expr_stmt><expr><name>q</name> = <name>p</name></expr>;</expr_stmt>
<expr_stmt><expr><name>p</name> = <call>(<name>PyTupleObject</name> *)<argument_list>(<argument><expr><name><name>p</name>-&gt;<name>ob_item</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyObject_GC_Del</name><argument_list>(<argument><expr><name>q</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></while>
}</block></for>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<return>return <expr><name>freelist_size</name></expr>;</return>
}</block></function>
<function><type><name>void</name></type>
<name>PyTuple_Fini</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list> <block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PyTuple_MAXSAVESIZE</name> &gt; 0</expr></cpp:if>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name><name>free_list</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>free_list</name><index>[<expr>0</expr>]</index></name> = <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr>(<name>void</name>)<call><name>PyTuple_ClearFreeList</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></function>
<typedef>typedef <type><struct>struct <block>{
<decl_stmt><decl><type><name>PyObject_HEAD</name>
<name>long</name></type> <name>it_index</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyTupleObject</name> *</type><name>it_seq</name></decl>;</decl_stmt>
}</block></struct></type> <name>tupleiterobject</name>;</typedef>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>tupleiter_dealloc</name><parameter_list>(<param><decl><type><name>tupleiterobject</name> *</type><name>it</name></decl></param>)</parameter_list> <block>{
<expr_stmt><expr><call><name>_PyObject_GC_UNTRACK</name><argument_list>(<argument><expr><name>it</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name><name>it</name>-&gt;<name>it_seq</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyObject_GC_Del</name><argument_list>(<argument><expr><name>it</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>tupleiter_traverse</name><parameter_list>(<param><decl><type><name>tupleiterobject</name> *</type><name>it</name></decl></param>, <param><decl><type><name>visitproc</name></type> <name>visit</name></decl></param>, <param><decl><type><name>void</name> *</type><name>arg</name></decl></param>)</parameter_list> <block>{
<expr_stmt><expr><call><name>Py_VISIT</name><argument_list>(<argument><expr><name><name>it</name>-&gt;<name>it_seq</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>0</expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>tupleiter_next</name><parameter_list>(<param><decl><type><name>tupleiterobject</name> *</type><name>it</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyTupleObject</name> *</type><name>seq</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>item</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>it</name> != <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>seq</name> = <name><name>it</name>-&gt;<name>it_seq</name></name></expr>;</expr_stmt>
<if>if <condition>(<expr><name>seq</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>PyTuple_Check</name><argument_list>(<argument><expr><name>seq</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>it</name>-&gt;<name>it_index</name></name> &lt; <call><name>PyTuple_GET_SIZE</name><argument_list>(<argument><expr><name>seq</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><name>item</name> = <call><name>PyTuple_GET_ITEM</name><argument_list>(<argument><expr><name>seq</name></expr></argument>, <argument><expr><name><name>it</name>-&gt;<name>it_index</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr>++<name><name>it</name>-&gt;<name>it_index</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>item</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>seq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>it</name>-&gt;<name>it_seq</name></name> = <name>NULL</name></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>tupleiter_len</name><parameter_list>(<param><decl><type><name>tupleiterobject</name> *</type><name>it</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>len</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name><name>it</name>-&gt;<name>it_seq</name></name></expr>)</condition><then>
<expr_stmt><expr><name>len</name> = <call><name>PyTuple_GET_SIZE</name><argument_list>(<argument><expr><name><name>it</name>-&gt;<name>it_seq</name></name></expr></argument>)</argument_list></call> - <name><name>it</name>-&gt;<name>it_index</name></name></expr>;</expr_stmt></then></if>
<return>return <expr><call><name>PyInt_FromSsize_t</name><argument_list>(<argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>length_hint_doc</name></expr></argument>, <argument><expr>"Private method returning an estimate of len(list(it))."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>PyMethodDef</name></type> <name><name>tupleiter_methods</name><index>[]</index></name> <init>= <expr><block>{
<expr><block>{<expr>"__length_hint__"</expr>, <expr>(<name>PyCFunction</name>)<name>tupleiter_len</name></expr>, <expr><name>METH_NOARGS</name></expr>, <expr><name>length_hint_doc</name></expr>}</block></expr>,
<expr><block>{<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>}</block></expr>
}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyTypeObject</name></type> <name>PyTupleIter_Type</name> <init>= <expr><block>{
<expr><call><name>PyVarObject_HEAD_INIT</name><argument_list>(<argument><expr>&amp;<name>PyType_Type</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call>
"tupleiterator"</expr>,
<expr><sizeof>sizeof<argument_list>(<argument><expr><name>tupleiterobject</name></expr></argument>)</argument_list></sizeof></expr>,
<expr>0</expr>,
<expr>(<name>destructor</name>)<name>tupleiter_dealloc</name></expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr><name>PyObject_GenericGetAttr</name></expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr><name>Py_TPFLAGS_DEFAULT</name> | <name>Py_TPFLAGS_HAVE_GC</name></expr>,
<expr>0</expr>,
<expr>(<name>traverseproc</name>)<name>tupleiter_traverse</name></expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr><name>PyObject_SelfIter</name></expr>,
<expr>(<name>iternextfunc</name>)<name>tupleiter_next</name></expr>,
<expr><name>tupleiter_methods</name></expr>,
<expr>0</expr>,
}</block></expr></init></decl>;</decl_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>tuple_iter</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>seq</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>tupleiterobject</name> *</type><name>it</name></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>PyTuple_Check</name><argument_list>(<argument><expr><name>seq</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_BadInternalCall</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>it</name> = <call><name>PyObject_GC_New</name><argument_list>(<argument><expr><name>tupleiterobject</name></expr></argument>, <argument><expr>&amp;<name>PyTupleIter_Type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>it</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name><name>it</name>-&gt;<name>it_index</name></name> = 0</expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>seq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>it</name>-&gt;<name>it_seq</name></name> = (<name>PyTupleObject</name> *)<name>seq</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>_PyObject_GC_TRACK</name><argument_list>(<argument><expr><name>it</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>(<name>PyObject</name> *)<name>it</name></expr>;</return>
}</block></function>
</unit>
