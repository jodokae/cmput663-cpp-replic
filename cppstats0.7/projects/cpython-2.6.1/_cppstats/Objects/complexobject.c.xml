<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C" filename="projects/cpython-2.6.1/_cppstats/Objects/complexobject.c"><cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"Python.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"structmember.h"</cpp:file></cpp:include>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_IEEEFP_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;ieeefp.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>WITHOUT_COMPLEX</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PREC_REPR</name></cpp:macro> <cpp:value>17</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PREC_STR</name></cpp:macro> <cpp:value>12</cpp:value></cpp:define>
<decl_stmt><decl><type><specifier>static</specifier> <name>Py_complex</name></type> <name>c_1</name> <init>= <expr><block>{<expr>1.</expr>, <expr>0.</expr>}</block></expr></init></decl>;</decl_stmt>
<function><type><name>Py_complex</name></type>
<name>c_sum</name><parameter_list>(<param><decl><type><name>Py_complex</name></type> <name>a</name></decl></param>, <param><decl><type><name>Py_complex</name></type> <name>b</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>Py_complex</name></type> <name>r</name></decl>;</decl_stmt>
<expr_stmt><expr><name><name>r</name>.<name>real</name></name> = <name><name>a</name>.<name>real</name></name> + <name><name>b</name>.<name>real</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>r</name>.<name>imag</name></name> = <name><name>a</name>.<name>imag</name></name> + <name><name>b</name>.<name>imag</name></name></expr>;</expr_stmt>
<return>return <expr><name>r</name></expr>;</return>
}</block></function>
<function><type><name>Py_complex</name></type>
<name>c_diff</name><parameter_list>(<param><decl><type><name>Py_complex</name></type> <name>a</name></decl></param>, <param><decl><type><name>Py_complex</name></type> <name>b</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>Py_complex</name></type> <name>r</name></decl>;</decl_stmt>
<expr_stmt><expr><name><name>r</name>.<name>real</name></name> = <name><name>a</name>.<name>real</name></name> - <name><name>b</name>.<name>real</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>r</name>.<name>imag</name></name> = <name><name>a</name>.<name>imag</name></name> - <name><name>b</name>.<name>imag</name></name></expr>;</expr_stmt>
<return>return <expr><name>r</name></expr>;</return>
}</block></function>
<function><type><name>Py_complex</name></type>
<name>c_neg</name><parameter_list>(<param><decl><type><name>Py_complex</name></type> <name>a</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>Py_complex</name></type> <name>r</name></decl>;</decl_stmt>
<expr_stmt><expr><name><name>r</name>.<name>real</name></name> = -<name><name>a</name>.<name>real</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>r</name>.<name>imag</name></name> = -<name><name>a</name>.<name>imag</name></name></expr>;</expr_stmt>
<return>return <expr><name>r</name></expr>;</return>
}</block></function>
<function><type><name>Py_complex</name></type>
<name>c_prod</name><parameter_list>(<param><decl><type><name>Py_complex</name></type> <name>a</name></decl></param>, <param><decl><type><name>Py_complex</name></type> <name>b</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>Py_complex</name></type> <name>r</name></decl>;</decl_stmt>
<expr_stmt><expr><name><name>r</name>.<name>real</name></name> = <name><name>a</name>.<name>real</name></name>*<name><name>b</name>.<name>real</name></name> - <name><name>a</name>.<name>imag</name></name>*<name><name>b</name>.<name>imag</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>r</name>.<name>imag</name></name> = <name><name>a</name>.<name>real</name></name>*<name><name>b</name>.<name>imag</name></name> + <name><name>a</name>.<name>imag</name></name>*<name><name>b</name>.<name>real</name></name></expr>;</expr_stmt>
<return>return <expr><name>r</name></expr>;</return>
}</block></function>
<function><type><name>Py_complex</name></type>
<name>c_quot</name><parameter_list>(<param><decl><type><name>Py_complex</name></type> <name>a</name></decl></param>, <param><decl><type><name>Py_complex</name></type> <name>b</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>Py_complex</name></type> <name>r</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>double</name></type> <name>abs_breal</name> <init>= <expr><name><name>b</name>.<name>real</name></name> &lt; 0 ? -<name><name>b</name>.<name>real</name></name> : <name><name>b</name>.<name>real</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>double</name></type> <name>abs_bimag</name> <init>= <expr><name><name>b</name>.<name>imag</name></name> &lt; 0 ? -<name><name>b</name>.<name>imag</name></name> : <name><name>b</name>.<name>imag</name></name></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>abs_breal</name> &gt;= <name>abs_bimag</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr><name>abs_breal</name> == 0.0</expr>)</condition><then> <block>{
<expr_stmt><expr><name>errno</name> = <name>EDOM</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>r</name>.<name>real</name></name> = <name><name>r</name>.<name>imag</name></name> = 0.0</expr>;</expr_stmt>
}</block></then> <else>else <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>double</name></type> <name>ratio</name> <init>= <expr><name><name>b</name>.<name>imag</name></name> / <name><name>b</name>.<name>real</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>double</name></type> <name>denom</name> <init>= <expr><name><name>b</name>.<name>real</name></name> + <name><name>b</name>.<name>imag</name></name> * <name>ratio</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>r</name>.<name>real</name></name> = (<name><name>a</name>.<name>real</name></name> + <name><name>a</name>.<name>imag</name></name> * <name>ratio</name>) / <name>denom</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>r</name>.<name>imag</name></name> = (<name><name>a</name>.<name>imag</name></name> - <name><name>a</name>.<name>real</name></name> * <name>ratio</name>) / <name>denom</name></expr>;</expr_stmt>
}</block></else></if>
}</block></then> <else>else <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>double</name></type> <name>ratio</name> <init>= <expr><name><name>b</name>.<name>real</name></name> / <name><name>b</name>.<name>imag</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>double</name></type> <name>denom</name> <init>= <expr><name><name>b</name>.<name>real</name></name> * <name>ratio</name> + <name><name>b</name>.<name>imag</name></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>b</name>.<name>imag</name></name> != 0.0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>r</name>.<name>real</name></name> = (<name><name>a</name>.<name>real</name></name> * <name>ratio</name> + <name><name>a</name>.<name>imag</name></name>) / <name>denom</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>r</name>.<name>imag</name></name> = (<name><name>a</name>.<name>imag</name></name> * <name>ratio</name> - <name><name>a</name>.<name>real</name></name>) / <name>denom</name></expr>;</expr_stmt>
}</block></else></if>
<return>return <expr><name>r</name></expr>;</return>
}</block></function>
<function><type><name>Py_complex</name></type>
<name>c_pow</name><parameter_list>(<param><decl><type><name>Py_complex</name></type> <name>a</name></decl></param>, <param><decl><type><name>Py_complex</name></type> <name>b</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>Py_complex</name></type> <name>r</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>double</name></type> <name>vabs</name></decl>,<decl><type ref="prev"/><name>len</name></decl>,<decl><type ref="prev"/><name>at</name></decl>,<decl><type ref="prev"/><name>phase</name></decl>;</decl_stmt>
<if>if <condition>(<expr><name><name>b</name>.<name>real</name></name> == 0. &amp;&amp; <name><name>b</name>.<name>imag</name></name> == 0.</expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>r</name>.<name>real</name></name> = 1.</expr>;</expr_stmt>
<expr_stmt><expr><name><name>r</name>.<name>imag</name></name> = 0.</expr>;</expr_stmt>
}</block></then> <else>else <if>if <condition>(<expr><name><name>a</name>.<name>real</name></name> == 0. &amp;&amp; <name><name>a</name>.<name>imag</name></name> == 0.</expr>)</condition><then> <block>{
<if>if <condition>(<expr><name><name>b</name>.<name>imag</name></name> != 0. || <name><name>b</name>.<name>real</name></name> &lt; 0.</expr>)</condition><then>
<expr_stmt><expr><name>errno</name> = <name>EDOM</name></expr>;</expr_stmt></then></if>
<expr_stmt><expr><name><name>r</name>.<name>real</name></name> = 0.</expr>;</expr_stmt>
<expr_stmt><expr><name><name>r</name>.<name>imag</name></name> = 0.</expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr><name>vabs</name> = <call><name>hypot</name><argument_list>(<argument><expr><name><name>a</name>.<name>real</name></name></expr></argument>,<argument><expr><name><name>a</name>.<name>imag</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>len</name> = <call><name>pow</name><argument_list>(<argument><expr><name>vabs</name></expr></argument>,<argument><expr><name><name>b</name>.<name>real</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>at</name> = <call><name>atan2</name><argument_list>(<argument><expr><name><name>a</name>.<name>imag</name></name></expr></argument>, <argument><expr><name><name>a</name>.<name>real</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>phase</name> = <name>at</name>*<name><name>b</name>.<name>real</name></name></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>b</name>.<name>imag</name></name> != 0.0</expr>)</condition><then> <block>{
<expr_stmt><expr><name>len</name> /= <call><name>exp</name><argument_list>(<argument><expr><name>at</name>*<name><name>b</name>.<name>imag</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>phase</name> += <name><name>b</name>.<name>imag</name></name>*<call><name>log</name><argument_list>(<argument><expr><name>vabs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><name><name>r</name>.<name>real</name></name> = <name>len</name>*<call><name>cos</name><argument_list>(<argument><expr><name>phase</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>r</name>.<name>imag</name></name> = <name>len</name>*<call><name>sin</name><argument_list>(<argument><expr><name>phase</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></else></if></else></if>
<return>return <expr><name>r</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>Py_complex</name></type>
<name>c_powu</name><parameter_list>(<param><decl><type><name>Py_complex</name></type> <name>x</name></decl></param>, <param><decl><type><name>long</name></type> <name>n</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>Py_complex</name></type> <name>r</name></decl>, <decl><type ref="prev"/><name>p</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>long</name></type> <name>mask</name> <init>= <expr>1</expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>r</name> = <name>c_1</name></expr>;</expr_stmt>
<expr_stmt><expr><name>p</name> = <name>x</name></expr>;</expr_stmt>
<while>while <condition>(<expr><name>mask</name> &gt; 0 &amp;&amp; <name>n</name> &gt;= <name>mask</name></expr>)</condition> <block>{
<if>if <condition>(<expr><name>n</name> &amp; <name>mask</name></expr>)</condition><then>
<expr_stmt><expr><name>r</name> = <call><name>c_prod</name><argument_list>(<argument><expr><name>r</name></expr></argument>,<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<expr_stmt><expr><name>mask</name> &lt;&lt;= 1</expr>;</expr_stmt>
<expr_stmt><expr><name>p</name> = <call><name>c_prod</name><argument_list>(<argument><expr><name>p</name></expr></argument>,<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></while>
<return>return <expr><name>r</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>Py_complex</name></type>
<name>c_powi</name><parameter_list>(<param><decl><type><name>Py_complex</name></type> <name>x</name></decl></param>, <param><decl><type><name>long</name></type> <name>n</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>Py_complex</name></type> <name>cn</name></decl>;</decl_stmt>
<if>if <condition>(<expr><name>n</name> &gt; 100 || <name>n</name> &lt; -100</expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>cn</name>.<name>real</name></name> = (<name>double</name>) <name>n</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cn</name>.<name>imag</name></name> = 0.</expr>;</expr_stmt>
<return>return <expr><call><name>c_pow</name><argument_list>(<argument><expr><name>x</name></expr></argument>,<argument><expr><name>cn</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></then> <else>else <if>if <condition>(<expr><name>n</name> &gt; 0</expr>)</condition><then>
<return>return <expr><call><name>c_powu</name><argument_list>(<argument><expr><name>x</name></expr></argument>,<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</return></then>
<else>else
<return>return <expr><call><name>c_quot</name><argument_list>(<argument><expr><name>c_1</name></expr></argument>,<argument><expr><call><name>c_powu</name><argument_list>(<argument><expr><name>x</name></expr></argument>,<argument><expr>-<name>n</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></else></if></else></if>
}</block></function>
<function><type><name>double</name></type>
<name>c_abs</name><parameter_list>(<param><decl><type><name>Py_complex</name></type> <name>z</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>double</name></type> <name>result</name></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>Py_IS_FINITE</name><argument_list>(<argument><expr><name><name>z</name>.<name>real</name></name></expr></argument>)</argument_list></call> || !<call><name>Py_IS_FINITE</name><argument_list>(<argument><expr><name><name>z</name>.<name>imag</name></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<if>if <condition>(<expr><call><name>Py_IS_INFINITY</name><argument_list>(<argument><expr><name><name>z</name>.<name>real</name></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><name>result</name> = <call><name>fabs</name><argument_list>(<argument><expr><name><name>z</name>.<name>real</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>errno</name> = 0</expr>;</expr_stmt>
<return>return <expr><name>result</name></expr>;</return>
}</block></then></if>
<if>if <condition>(<expr><call><name>Py_IS_INFINITY</name><argument_list>(<argument><expr><name><name>z</name>.<name>imag</name></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><name>result</name> = <call><name>fabs</name><argument_list>(<argument><expr><name><name>z</name>.<name>imag</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>errno</name> = 0</expr>;</expr_stmt>
<return>return <expr><name>result</name></expr>;</return>
}</block></then></if>
<return>return <expr><name>Py_NAN</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>result</name> = <call><name>hypot</name><argument_list>(<argument><expr><name><name>z</name>.<name>real</name></name></expr></argument>, <argument><expr><name><name>z</name>.<name>imag</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<call><name>Py_IS_FINITE</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<expr_stmt><expr><name>errno</name> = <name>ERANGE</name></expr>;</expr_stmt></then>
<else>else
<expr_stmt><expr><name>errno</name> = 0</expr>;</expr_stmt></else></if>
<return>return <expr><name>result</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>complex_subtype_from_c_complex</name><parameter_list>(<param><decl><type><name>PyTypeObject</name> *</type><name>type</name></decl></param>, <param><decl><type><name>Py_complex</name></type> <name>cval</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>op</name></decl>;</decl_stmt>
<expr_stmt><expr><name>op</name> = <call><name><name>type</name>-&gt;<name>tp_alloc</name></name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>op</name> != <name>NULL</name></expr>)</condition><then>
<expr_stmt><expr>((<name>PyComplexObject</name> *)<name>op</name>)-&gt;<name>cval</name> = <name>cval</name></expr>;</expr_stmt></then></if>
<return>return <expr><name>op</name></expr>;</return>
}</block></function>
<function><type><name>PyObject</name> *</type>
<name>PyComplex_FromCComplex</name><parameter_list>(<param><decl><type><name>Py_complex</name></type> <name>cval</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>register</name> <name>PyComplexObject</name> *</type><name>op</name></decl>;</decl_stmt>
<expr_stmt><expr><name>op</name> = (<name>PyComplexObject</name> *) <call><name>PyObject_MALLOC</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PyComplexObject</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>op</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><call><name>PyErr_NoMemory</name><argument_list>()</argument_list></call></expr>;</return></then></if>
<expr_stmt><expr><call><name>PyObject_INIT</name><argument_list>(<argument><expr><name>op</name></expr></argument>, <argument><expr>&amp;<name>PyComplex_Type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>op</name>-&gt;<name>cval</name></name> = <name>cval</name></expr>;</expr_stmt>
<return>return <expr>(<name>PyObject</name> *) <name>op</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>complex_subtype_from_doubles</name><parameter_list>(<param><decl><type><name>PyTypeObject</name> *</type><name>type</name></decl></param>, <param><decl><type><name>double</name></type> <name>real</name></decl></param>, <param><decl><type><name>double</name></type> <name>imag</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>Py_complex</name></type> <name>c</name></decl>;</decl_stmt>
<expr_stmt><expr><name><name>c</name>.<name>real</name></name> = <name>real</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>c</name>.<name>imag</name></name> = <name>imag</name></expr>;</expr_stmt>
<return>return <expr><call><name>complex_subtype_from_c_complex</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><name>PyObject</name> *</type>
<name>PyComplex_FromDoubles</name><parameter_list>(<param><decl><type><name>double</name></type> <name>real</name></decl></param>, <param><decl><type><name>double</name></type> <name>imag</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>Py_complex</name></type> <name>c</name></decl>;</decl_stmt>
<expr_stmt><expr><name><name>c</name>.<name>real</name></name> = <name>real</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>c</name>.<name>imag</name></name> = <name>imag</name></expr>;</expr_stmt>
<return>return <expr><call><name>PyComplex_FromCComplex</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><name>double</name></type>
<name>PyComplex_RealAsDouble</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>op</name></decl></param>)</parameter_list> <block>{
<if>if <condition>(<expr><call><name>PyComplex_Check</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<return>return <expr>((<name>PyComplexObject</name> *)<name>op</name>)-&gt;<name><name>cval</name>.<name>real</name></name></expr>;</return>
}</block></then> <else>else <block>{
<return>return <expr><call><name>PyFloat_AsDouble</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></else></if>
}</block></function>
<function><type><name>double</name></type>
<name>PyComplex_ImagAsDouble</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>op</name></decl></param>)</parameter_list> <block>{
<if>if <condition>(<expr><call><name>PyComplex_Check</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<return>return <expr>((<name>PyComplexObject</name> *)<name>op</name>)-&gt;<name><name>cval</name>.<name>imag</name></name></expr>;</return>
}</block></then> <else>else <block>{
<return>return <expr>0.0</expr>;</return>
}</block></else></if>
}</block></function>
<function><type><name>Py_complex</name></type>
<name>PyComplex_AsCComplex</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>op</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>Py_complex</name></type> <name>cv</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>newop</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>PyObject</name> *</type><name>complex_str</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>PyComplex_Check</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<return>return <expr>((<name>PyComplexObject</name> *)<name>op</name>)-&gt;<name>cval</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name><name>cv</name>.<name>real</name></name> = -1.</expr>;</expr_stmt>
<expr_stmt><expr><name><name>cv</name>.<name>imag</name></name> = 0.</expr>;</expr_stmt>
<if>if <condition>(<expr><name>complex_str</name> == <name>NULL</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr>!(<name>complex_str</name> = <call><name>PyString_InternFromString</name><argument_list>(<argument><expr>"__complex__"</expr></argument>)</argument_list></call>)</expr>)</condition><then>
<return>return <expr><name>cv</name></expr>;</return></then></if>
}</block></then></if>
<if>if <condition>(<expr><call><name>PyInstance_Check</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<if>if <condition>(<expr><call><name>PyObject_HasAttr</name><argument_list>(<argument><expr><name>op</name></expr></argument>, <argument><expr><name>complex_str</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><name>newop</name> = <call><name>PyObject_CallMethod</name><argument_list>(<argument><expr><name>op</name></expr></argument>, <argument><expr>"__complex__"</expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>newop</name></expr>)</condition><then>
<return>return <expr><name>cv</name></expr>;</return></then></if>
}</block></then></if>
}</block></then> <else>else <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>complexfunc</name></decl>;</decl_stmt>
<expr_stmt><expr><name>complexfunc</name> = <call><name>_PyType_Lookup</name><argument_list>(<argument><expr><name><name>op</name>-&gt;<name>ob_type</name></name></expr></argument>, <argument><expr><name>complex_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>complexfunc</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>newop</name> = <call><name>PyObject_CallFunctionObjArgs</name><argument_list>(<argument><expr><name>complexfunc</name></expr></argument>, <argument><expr><name>op</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>newop</name></expr>)</condition><then>
<return>return <expr><name>cv</name></expr>;</return></then></if>
}</block></then></if>
}</block></else></if>
<if>if <condition>(<expr><name>newop</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr>!<call><name>PyComplex_Check</name><argument_list>(<argument><expr><name>newop</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
<argument><expr>"__complex__ should return a complex object"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>newop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>cv</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>cv</name> = ((<name>PyComplexObject</name> *)<name>newop</name>)-&gt;<name>cval</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>newop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>cv</name></expr>;</return>
}</block></then>
<else>else <block>{
<expr_stmt><expr><name><name>cv</name>.<name>real</name></name> = <call><name>PyFloat_AsDouble</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>cv</name></expr>;</return>
}</block></else></if>
}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>complex_dealloc</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>op</name></decl></param>)</parameter_list> <block>{
<expr_stmt><expr><call><name><name>op</name>-&gt;<name>ob_type</name>-&gt;<name>tp_free</name></name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>complex_to_buf</name><parameter_list>(<param><decl><type><name>char</name> *</type><name>buf</name></decl></param>, <param><decl><type><name>int</name></type> <name>bufsz</name></decl></param>, <param><decl><type><name>PyComplexObject</name> *</type><name>v</name></decl></param>, <param><decl><type><name>int</name></type> <name>precision</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>char</name></type> <name><name>format</name><index>[<expr>32</expr>]</index></name></decl>;</decl_stmt>
<if>if <condition>(<expr><name><name>v</name>-&gt;<name>cval</name>.<name>real</name></name> == 0.</expr>)</condition><then> <block>{
<if>if <condition>(<expr>!<call><name>Py_IS_FINITE</name><argument_list>(<argument><expr><name><name>v</name>-&gt;<name>cval</name>.<name>imag</name></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<if>if <condition>(<expr><call><name>Py_IS_NAN</name><argument_list>(<argument><expr><name><name>v</name>-&gt;<name>cval</name>.<name>imag</name></name></expr></argument>)</argument_list></call></expr>)</condition><then>
<expr_stmt><expr><call><name>strncpy</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr>"nan*j"</expr></argument>, <argument><expr>6</expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
<else>else <if>if <condition>(<expr><call><name>copysign</name><argument_list>(<argument><expr>1</expr></argument>, <argument><expr><name><name>v</name>-&gt;<name>cval</name>.<name>imag</name></name></expr></argument>)</argument_list></call> == 1</expr>)</condition><then>
<expr_stmt><expr><call><name>strncpy</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr>"inf*j"</expr></argument>, <argument><expr>6</expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
<else>else
<expr_stmt><expr><call><name>strncpy</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr>"-inf*j"</expr></argument>, <argument><expr>7</expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if></else></if>
}</block></then> <else>else <block>{
<expr_stmt><expr><call><name>PyOS_snprintf</name><argument_list>(<argument><expr><name>format</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>format</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr>"%%.%ig"</expr></argument>, <argument><expr><name>precision</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyOS_ascii_formatd</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>bufsz</name> - 1</expr></argument>, <argument><expr><name>format</name></expr></argument>, <argument><expr><name><name>v</name>-&gt;<name>cval</name>.<name>imag</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>strncat</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr>"j"</expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></else></if>
}</block></then> <else>else <block>{
<decl_stmt><decl><type><name>char</name></type> <name><name>re</name><index>[<expr>64</expr>]</index></name></decl>, <decl><type ref="prev"/><name><name>im</name><index>[<expr>64</expr>]</index></name></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>Py_IS_FINITE</name><argument_list>(<argument><expr><name><name>v</name>-&gt;<name>cval</name>.<name>real</name></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<if>if <condition>(<expr><call><name>Py_IS_NAN</name><argument_list>(<argument><expr><name><name>v</name>-&gt;<name>cval</name>.<name>real</name></name></expr></argument>)</argument_list></call></expr>)</condition><then>
<expr_stmt><expr><call><name>strncpy</name><argument_list>(<argument><expr><name>re</name></expr></argument>, <argument><expr>"nan"</expr></argument>, <argument><expr>4</expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
<else>else <if>if <condition>(<expr><name><name>v</name>-&gt;<name>cval</name>.<name>real</name></name> &gt; 0</expr>)</condition><then>
<expr_stmt><expr><call><name>strncpy</name><argument_list>(<argument><expr><name>re</name></expr></argument>, <argument><expr>"inf"</expr></argument>, <argument><expr>4</expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
<else>else
<expr_stmt><expr><call><name>strncpy</name><argument_list>(<argument><expr><name>re</name></expr></argument>, <argument><expr>"-inf"</expr></argument>, <argument><expr>5</expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if></else></if>
}</block></then> <else>else <block>{
<expr_stmt><expr><call><name>PyOS_snprintf</name><argument_list>(<argument><expr><name>format</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>format</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr>"%%.%ig"</expr></argument>, <argument><expr><name>precision</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyOS_ascii_formatd</name><argument_list>(<argument><expr><name>re</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>re</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>format</name></expr></argument>, <argument><expr><name><name>v</name>-&gt;<name>cval</name>.<name>real</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></else></if>
<if>if <condition>(<expr>!<call><name>Py_IS_FINITE</name><argument_list>(<argument><expr><name><name>v</name>-&gt;<name>cval</name>.<name>imag</name></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<if>if <condition>(<expr><call><name>Py_IS_NAN</name><argument_list>(<argument><expr><name><name>v</name>-&gt;<name>cval</name>.<name>imag</name></name></expr></argument>)</argument_list></call></expr>)</condition><then>
<expr_stmt><expr><call><name>strncpy</name><argument_list>(<argument><expr><name>im</name></expr></argument>, <argument><expr>"+nan*"</expr></argument>, <argument><expr>6</expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
<else>else <if>if <condition>(<expr><name><name>v</name>-&gt;<name>cval</name>.<name>imag</name></name> &gt; 0</expr>)</condition><then>
<expr_stmt><expr><call><name>strncpy</name><argument_list>(<argument><expr><name>im</name></expr></argument>, <argument><expr>"+inf*"</expr></argument>, <argument><expr>6</expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
<else>else
<expr_stmt><expr><call><name>strncpy</name><argument_list>(<argument><expr><name>im</name></expr></argument>, <argument><expr>"-inf*"</expr></argument>, <argument><expr>6</expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if></else></if>
}</block></then> <else>else <block>{
<expr_stmt><expr><call><name>PyOS_snprintf</name><argument_list>(<argument><expr><name>format</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>format</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr>"%%+.%ig"</expr></argument>, <argument><expr><name>precision</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyOS_ascii_formatd</name><argument_list>(<argument><expr><name>im</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>im</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>format</name></expr></argument>, <argument><expr><name><name>v</name>-&gt;<name>cval</name>.<name>imag</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></else></if>
<expr_stmt><expr><call><name>PyOS_snprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>bufsz</name></expr></argument>, <argument><expr>"(%s%sj)"</expr></argument>, <argument><expr><name>re</name></expr></argument>, <argument><expr><name>im</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></else></if>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>complex_print</name><parameter_list>(<param><decl><type><name>PyComplexObject</name> *</type><name>v</name></decl></param>, <param><decl><type><name>FILE</name> *</type><name>fp</name></decl></param>, <param><decl><type><name>int</name></type> <name>flags</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>char</name></type> <name><name>buf</name><index>[<expr>100</expr>]</index></name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>complex_to_buf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>v</name></expr></argument>,
<argument><expr>(<name>flags</name> &amp; <name>Py_PRINT_RAW</name>) ? <name>PREC_STR</name> : <name>PREC_REPR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function_decl><type><name>Py_BEGIN_ALLOW_THREADS</name></type>
<name>fputs</name><parameter_list>(<param><decl><type><name>buf</name></type></decl></param>, <param><decl><type><name>fp</name></type></decl></param>)</parameter_list>;</function_decl>
<macro><name>Py_END_ALLOW_THREADS</name></macro>
<return>return <expr>0</expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>complex_repr</name><parameter_list>(<param><decl><type><name>PyComplexObject</name> *</type><name>v</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>char</name></type> <name><name>buf</name><index>[<expr>100</expr>]</index></name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>complex_to_buf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>v</name></expr></argument>, <argument><expr><name>PREC_REPR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>PyString_FromString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>complex_str</name><parameter_list>(<param><decl><type><name>PyComplexObject</name> *</type><name>v</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>char</name></type> <name><name>buf</name><index>[<expr>100</expr>]</index></name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>complex_to_buf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>v</name></expr></argument>, <argument><expr><name>PREC_STR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>PyString_FromString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>long</name></type>
<name>complex_hash</name><parameter_list>(<param><decl><type><name>PyComplexObject</name> *</type><name>v</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>long</name></type> <name>hashreal</name></decl>, <decl><type ref="prev"/><name>hashimag</name></decl>, <decl><type ref="prev"/><name>combined</name></decl>;</decl_stmt>
<expr_stmt><expr><name>hashreal</name> = <call><name>_Py_HashDouble</name><argument_list>(<argument><expr><name><name>v</name>-&gt;<name>cval</name>.<name>real</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>hashreal</name> == -1</expr>)</condition><then>
<return>return <expr>-1</expr>;</return></then></if>
<expr_stmt><expr><name>hashimag</name> = <call><name>_Py_HashDouble</name><argument_list>(<argument><expr><name><name>v</name>-&gt;<name>cval</name>.<name>imag</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>hashimag</name> == -1</expr>)</condition><then>
<return>return <expr>-1</expr>;</return></then></if>
<expr_stmt><expr><name>combined</name> = <name>hashreal</name> + 1000003 * <name>hashimag</name></expr>;</expr_stmt>
<if>if <condition>(<expr><name>combined</name> == -1</expr>)</condition><then>
<expr_stmt><expr><name>combined</name> = -2</expr>;</expr_stmt></then></if>
<return>return <expr><name>combined</name></expr>;</return>
}</block></function>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TO_COMPLEX</name><parameter_list>(<param><type><name>obj</name></type></param>, <param><type><name>c</name></type></param>)</parameter_list></cpp:macro> <cpp:value>if (PyComplex_Check(obj)) c = ((PyComplexObject *)(obj))-&gt;cval; else if (to_complex(&amp;(obj), &amp;(c)) &lt; 0) return (obj)</cpp:value></cpp:define>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>to_complex</name><parameter_list>(<param><decl><type><name>PyObject</name> **</type><name>pobj</name></decl></param>, <param><decl><type><name>Py_complex</name> *</type><name>pc</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>obj</name> <init>= <expr>*<name>pobj</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>pc</name>-&gt;<name>real</name></name> = <name><name>pc</name>-&gt;<name>imag</name></name> = 0.0</expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>PyInt_Check</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>pc</name>-&gt;<name>real</name></name> = <call><name>PyInt_AS_LONG</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>0</expr>;</return>
}</block></then></if>
<if>if <condition>(<expr><call><name>PyLong_Check</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>pc</name>-&gt;<name>real</name></name> = <call><name>PyLong_AsDouble</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>pc</name>-&gt;<name>real</name></name> == -1.0 &amp;&amp; <call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr>*<name>pobj</name> = <name>NULL</name></expr>;</expr_stmt>
<return>return <expr>-1</expr>;</return>
}</block></then></if>
<return>return <expr>0</expr>;</return>
}</block></then></if>
<if>if <condition>(<expr><call><name>PyFloat_Check</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>pc</name>-&gt;<name>real</name></name> = <call><name>PyFloat_AsDouble</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>0</expr>;</return>
}</block></then></if>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_NotImplemented</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr>*<name>pobj</name> = <name>Py_NotImplemented</name></expr>;</expr_stmt>
<return>return <expr>-1</expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>complex_add</name><parameter_list>(<param><decl><type><name>PyComplexObject</name> *</type><name>v</name></decl></param>, <param><decl><type><name>PyComplexObject</name> *</type><name>w</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>Py_complex</name></type> <name>result</name></decl>;</decl_stmt>
<macro><name>PyFPE_START_PROTECT</name><argument_list>(<argument>"complex_add"</argument>, <argument>return 0</argument>)</argument_list></macro>
<expr_stmt><expr><name>result</name> = <call><name>c_sum</name><argument_list>(<argument><expr><name><name>v</name>-&gt;<name>cval</name></name></expr></argument>,<argument><expr><name><name>w</name>-&gt;<name>cval</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<macro><name>PyFPE_END_PROTECT</name><argument_list>(<argument>result</argument>)</argument_list></macro>
<return>return <expr><call><name>PyComplex_FromCComplex</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>complex_sub</name><parameter_list>(<param><decl><type><name>PyComplexObject</name> *</type><name>v</name></decl></param>, <param><decl><type><name>PyComplexObject</name> *</type><name>w</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>Py_complex</name></type> <name>result</name></decl>;</decl_stmt>
<macro><name>PyFPE_START_PROTECT</name><argument_list>(<argument>"complex_sub"</argument>, <argument>return 0</argument>)</argument_list></macro>
<expr_stmt><expr><name>result</name> = <call><name>c_diff</name><argument_list>(<argument><expr><name><name>v</name>-&gt;<name>cval</name></name></expr></argument>,<argument><expr><name><name>w</name>-&gt;<name>cval</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<macro><name>PyFPE_END_PROTECT</name><argument_list>(<argument>result</argument>)</argument_list></macro>
<return>return <expr><call><name>PyComplex_FromCComplex</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>complex_mul</name><parameter_list>(<param><decl><type><name>PyComplexObject</name> *</type><name>v</name></decl></param>, <param><decl><type><name>PyComplexObject</name> *</type><name>w</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>Py_complex</name></type> <name>result</name></decl>;</decl_stmt>
<macro><name>PyFPE_START_PROTECT</name><argument_list>(<argument>"complex_mul"</argument>, <argument>return 0</argument>)</argument_list></macro>
<expr_stmt><expr><name>result</name> = <call><name>c_prod</name><argument_list>(<argument><expr><name><name>v</name>-&gt;<name>cval</name></name></expr></argument>,<argument><expr><name><name>w</name>-&gt;<name>cval</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<macro><name>PyFPE_END_PROTECT</name><argument_list>(<argument>result</argument>)</argument_list></macro>
<return>return <expr><call><name>PyComplex_FromCComplex</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>complex_div</name><parameter_list>(<param><decl><type><name>PyComplexObject</name> *</type><name>v</name></decl></param>, <param><decl><type><name>PyComplexObject</name> *</type><name>w</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>Py_complex</name></type> <name>quot</name></decl>;</decl_stmt>
<macro><name>PyFPE_START_PROTECT</name><argument_list>(<argument>"complex_div"</argument>, <argument>return 0</argument>)</argument_list></macro>
<expr_stmt><expr><name>errno</name> = 0</expr>;</expr_stmt>
<expr_stmt><expr><name>quot</name> = <call><name>c_quot</name><argument_list>(<argument><expr><name><name>v</name>-&gt;<name>cval</name></name></expr></argument>,<argument><expr><name><name>w</name>-&gt;<name>cval</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<macro><name>PyFPE_END_PROTECT</name><argument_list>(<argument>quot</argument>)</argument_list></macro>
<if>if <condition>(<expr><name>errno</name> == <name>EDOM</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ZeroDivisionError</name></expr></argument>, <argument><expr>"complex division"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<return>return <expr><call><name>PyComplex_FromCComplex</name><argument_list>(<argument><expr><name>quot</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>complex_classic_div</name><parameter_list>(<param><decl><type><name>PyComplexObject</name> *</type><name>v</name></decl></param>, <param><decl><type><name>PyComplexObject</name> *</type><name>w</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>Py_complex</name></type> <name>quot</name></decl>;</decl_stmt>
<if>if <condition>(<expr><name>Py_DivisionWarningFlag</name> &gt;= 2 &amp;&amp;
<call><name>PyErr_Warn</name><argument_list>(<argument><expr><name>PyExc_DeprecationWarning</name></expr></argument>,
<argument><expr>"classic complex division"</expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<macro><name>PyFPE_START_PROTECT</name><argument_list>(<argument>"complex_classic_div"</argument>, <argument>return 0</argument>)</argument_list></macro>
<expr_stmt><expr><name>errno</name> = 0</expr>;</expr_stmt>
<expr_stmt><expr><name>quot</name> = <call><name>c_quot</name><argument_list>(<argument><expr><name><name>v</name>-&gt;<name>cval</name></name></expr></argument>,<argument><expr><name><name>w</name>-&gt;<name>cval</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<macro><name>PyFPE_END_PROTECT</name><argument_list>(<argument>quot</argument>)</argument_list></macro>
<if>if <condition>(<expr><name>errno</name> == <name>EDOM</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ZeroDivisionError</name></expr></argument>, <argument><expr>"complex division"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<return>return <expr><call><name>PyComplex_FromCComplex</name><argument_list>(<argument><expr><name>quot</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>complex_remainder</name><parameter_list>(<param><decl><type><name>PyComplexObject</name> *</type><name>v</name></decl></param>, <param><decl><type><name>PyComplexObject</name> *</type><name>w</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>Py_complex</name></type> <name>div</name></decl>, <decl><type ref="prev"/><name>mod</name></decl>;</decl_stmt>
<if>if <condition>(<expr><call><name>PyErr_Warn</name><argument_list>(<argument><expr><name>PyExc_DeprecationWarning</name></expr></argument>,
<argument><expr>"complex divmod(), // and % are deprecated"</expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>errno</name> = 0</expr>;</expr_stmt>
<expr_stmt><expr><name>div</name> = <call><name>c_quot</name><argument_list>(<argument><expr><name><name>v</name>-&gt;<name>cval</name></name></expr></argument>,<argument><expr><name><name>w</name>-&gt;<name>cval</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>errno</name> == <name>EDOM</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ZeroDivisionError</name></expr></argument>, <argument><expr>"complex remainder"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name><name>div</name>.<name>real</name></name> = <call><name>floor</name><argument_list>(<argument><expr><name><name>div</name>.<name>real</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>div</name>.<name>imag</name></name> = 0.0</expr>;</expr_stmt>
<expr_stmt><expr><name>mod</name> = <call><name>c_diff</name><argument_list>(<argument><expr><name><name>v</name>-&gt;<name>cval</name></name></expr></argument>, <argument><expr><call><name>c_prod</name><argument_list>(<argument><expr><name><name>w</name>-&gt;<name>cval</name></name></expr></argument>, <argument><expr><name>div</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>PyComplex_FromCComplex</name><argument_list>(<argument><expr><name>mod</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>complex_divmod</name><parameter_list>(<param><decl><type><name>PyComplexObject</name> *</type><name>v</name></decl></param>, <param><decl><type><name>PyComplexObject</name> *</type><name>w</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>Py_complex</name></type> <name>div</name></decl>, <decl><type ref="prev"/><name>mod</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>d</name></decl>, *<decl><type ref="prev"/><name>m</name></decl>, *<decl><type ref="prev"/><name>z</name></decl>;</decl_stmt>
<if>if <condition>(<expr><call><name>PyErr_Warn</name><argument_list>(<argument><expr><name>PyExc_DeprecationWarning</name></expr></argument>,
<argument><expr>"complex divmod(), // and % are deprecated"</expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>errno</name> = 0</expr>;</expr_stmt>
<expr_stmt><expr><name>div</name> = <call><name>c_quot</name><argument_list>(<argument><expr><name><name>v</name>-&gt;<name>cval</name></name></expr></argument>,<argument><expr><name><name>w</name>-&gt;<name>cval</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>errno</name> == <name>EDOM</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ZeroDivisionError</name></expr></argument>, <argument><expr>"complex divmod()"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name><name>div</name>.<name>real</name></name> = <call><name>floor</name><argument_list>(<argument><expr><name><name>div</name>.<name>real</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>div</name>.<name>imag</name></name> = 0.0</expr>;</expr_stmt>
<expr_stmt><expr><name>mod</name> = <call><name>c_diff</name><argument_list>(<argument><expr><name><name>v</name>-&gt;<name>cval</name></name></expr></argument>, <argument><expr><call><name>c_prod</name><argument_list>(<argument><expr><name><name>w</name>-&gt;<name>cval</name></name></expr></argument>, <argument><expr><name>div</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>d</name> = <call><name>PyComplex_FromCComplex</name><argument_list>(<argument><expr><name>div</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>m</name> = <call><name>PyComplex_FromCComplex</name><argument_list>(<argument><expr><name>mod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>z</name> = <call><name>PyTuple_Pack</name><argument_list>(<argument><expr>2</expr></argument>, <argument><expr><name>d</name></expr></argument>, <argument><expr><name>m</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>m</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>z</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>complex_pow</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>v</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>w</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>z</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>Py_complex</name></type> <name>p</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_complex</name></type> <name>exponent</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>long</name></type> <name>int_exponent</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_complex</name></type> <name>a</name></decl>, <decl><type ref="prev"/><name>b</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>TO_COMPLEX</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>TO_COMPLEX</name><argument_list>(<argument><expr><name>w</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>z</name>!=<name>Py_None</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>, <argument><expr>"complex modulo"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<macro><name>PyFPE_START_PROTECT</name><argument_list>(<argument>"complex_pow"</argument>, <argument>return 0</argument>)</argument_list></macro>
<expr_stmt><expr><name>errno</name> = 0</expr>;</expr_stmt>
<expr_stmt><expr><name>exponent</name> = <name>b</name></expr>;</expr_stmt>
<expr_stmt><expr><name>int_exponent</name> = (<name>long</name>)<name><name>exponent</name>.<name>real</name></name></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>exponent</name>.<name>imag</name></name> == 0. &amp;&amp; <name><name>exponent</name>.<name>real</name></name> == <name>int_exponent</name></expr>)</condition><then>
<expr_stmt><expr><name>p</name> = <call><name>c_powi</name><argument_list>(<argument><expr><name>a</name></expr></argument>,<argument><expr><name>int_exponent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
<else>else
<expr_stmt><expr><name>p</name> = <call><name>c_pow</name><argument_list>(<argument><expr><name>a</name></expr></argument>,<argument><expr><name>exponent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
<macro><name>PyFPE_END_PROTECT</name><argument_list>(<argument>p</argument>)</argument_list></macro>
<expr_stmt><expr><call><name>Py_ADJUST_ERANGE2</name><argument_list>(<argument><expr><name><name>p</name>.<name>real</name></name></expr></argument>, <argument><expr><name><name>p</name>.<name>imag</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>errno</name> == <name>EDOM</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ZeroDivisionError</name></expr></argument>,
<argument><expr>"0.0 to a negative or complex power"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then> <else>else <if>if <condition>(<expr><name>errno</name> == <name>ERANGE</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_OverflowError</name></expr></argument>,
<argument><expr>"complex exponentiation"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if></else></if>
<return>return <expr><call><name>PyComplex_FromCComplex</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>complex_int_div</name><parameter_list>(<param><decl><type><name>PyComplexObject</name> *</type><name>v</name></decl></param>, <param><decl><type><name>PyComplexObject</name> *</type><name>w</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>t</name></decl>, *<decl><type ref="prev"/><name>r</name></decl>;</decl_stmt>
<if>if <condition>(<expr><call><name>PyErr_Warn</name><argument_list>(<argument><expr><name>PyExc_DeprecationWarning</name></expr></argument>,
<argument><expr>"complex divmod(), // and % are deprecated"</expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>t</name> = <call><name>complex_divmod</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>t</name> != <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>r</name> = <call><name>PyTuple_GET_ITEM</name><argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>r</name></expr>;</return>
}</block></then></if>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>complex_neg</name><parameter_list>(<param><decl><type><name>PyComplexObject</name> *</type><name>v</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>Py_complex</name></type> <name>neg</name></decl>;</decl_stmt>
<expr_stmt><expr><name><name>neg</name>.<name>real</name></name> = -<name><name>v</name>-&gt;<name>cval</name>.<name>real</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>neg</name>.<name>imag</name></name> = -<name><name>v</name>-&gt;<name>cval</name>.<name>imag</name></name></expr>;</expr_stmt>
<return>return <expr><call><name>PyComplex_FromCComplex</name><argument_list>(<argument><expr><name>neg</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>complex_pos</name><parameter_list>(<param><decl><type><name>PyComplexObject</name> *</type><name>v</name></decl></param>)</parameter_list> <block>{
<if>if <condition>(<expr><call><name>PyComplex_CheckExact</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>(<name>PyObject</name> *)<name>v</name></expr>;</return>
}</block></then> <else>else
<return>return <expr><call><name>PyComplex_FromCComplex</name><argument_list>(<argument><expr><name><name>v</name>-&gt;<name>cval</name></name></expr></argument>)</argument_list></call></expr>;</return></else></if>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>complex_abs</name><parameter_list>(<param><decl><type><name>PyComplexObject</name> *</type><name>v</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>double</name></type> <name>result</name></decl>;</decl_stmt>
<macro><name>PyFPE_START_PROTECT</name><argument_list>(<argument>"complex_abs"</argument>, <argument>return 0</argument>)</argument_list></macro>
<expr_stmt><expr><name>result</name> = <call><name>c_abs</name><argument_list>(<argument><expr><name><name>v</name>-&gt;<name>cval</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<macro><name>PyFPE_END_PROTECT</name><argument_list>(<argument>result</argument>)</argument_list></macro>
<if>if <condition>(<expr><name>errno</name> == <name>ERANGE</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_OverflowError</name></expr></argument>,
<argument><expr>"absolute value too large"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<return>return <expr><call><name>PyFloat_FromDouble</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>complex_nonzero</name><parameter_list>(<param><decl><type><name>PyComplexObject</name> *</type><name>v</name></decl></param>)</parameter_list> <block>{
<return>return <expr><name><name>v</name>-&gt;<name>cval</name>.<name>real</name></name> != 0.0 || <name><name>v</name>-&gt;<name>cval</name>.<name>imag</name></name> != 0.0</expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>complex_coerce</name><parameter_list>(<param><decl><type><name>PyObject</name> **</type><name>pv</name></decl></param>, <param><decl><type><name>PyObject</name> **</type><name>pw</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>Py_complex</name></type> <name>cval</name></decl>;</decl_stmt>
<expr_stmt><expr><name><name>cval</name>.<name>imag</name></name> = 0.</expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>PyInt_Check</name><argument_list>(<argument><expr>*<name>pw</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>cval</name>.<name>real</name></name> = (<name>double</name>)<call><name>PyInt_AsLong</name><argument_list>(<argument><expr>*<name>pw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr>*<name>pw</name> = <call><name>PyComplex_FromCComplex</name><argument_list>(<argument><expr><name>cval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr>*<name>pv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>0</expr>;</return>
}</block></then> <else>else <if>if <condition>(<expr><call><name>PyLong_Check</name><argument_list>(<argument><expr>*<name>pw</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>cval</name>.<name>real</name></name> = <call><name>PyLong_AsDouble</name><argument_list>(<argument><expr>*<name>pw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>cval</name>.<name>real</name></name> == -1.0 &amp;&amp; <call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then>
<return>return <expr>-1</expr>;</return></then></if>
<expr_stmt><expr>*<name>pw</name> = <call><name>PyComplex_FromCComplex</name><argument_list>(<argument><expr><name>cval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr>*<name>pv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>0</expr>;</return>
}</block></then> <else>else <if>if <condition>(<expr><call><name>PyFloat_Check</name><argument_list>(<argument><expr>*<name>pw</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>cval</name>.<name>real</name></name> = <call><name>PyFloat_AsDouble</name><argument_list>(<argument><expr>*<name>pw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr>*<name>pw</name> = <call><name>PyComplex_FromCComplex</name><argument_list>(<argument><expr><name>cval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr>*<name>pv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>0</expr>;</return>
}</block></then> <else>else <if>if <condition>(<expr><call><name>PyComplex_Check</name><argument_list>(<argument><expr>*<name>pw</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr>*<name>pv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr>*<name>pw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>0</expr>;</return>
}</block></then></if></else></if></else></if></else></if>
<return>return <expr>1</expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>complex_richcompare</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>v</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>w</name></decl></param>, <param><decl><type><name>int</name></type> <name>op</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>c</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_complex</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>res</name></decl>;</decl_stmt>
<expr_stmt><expr><name>c</name> = <call><name>PyNumber_CoerceEx</name><argument_list>(<argument><expr>&amp;<name>v</name></expr></argument>, <argument><expr>&amp;<name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>c</name> &lt; 0</expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<if>if <condition>(<expr><name>c</name> &gt; 0</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_NotImplemented</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>Py_NotImplemented</name></expr>;</return>
}</block></then></if>
<if>if <condition>(<expr>!(<call><name>PyComplex_Check</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call> &amp;&amp; <call><name>PyComplex_Check</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call>)</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_NotImplemented</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>Py_NotImplemented</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>i</name> = ((<name>PyComplexObject</name> *)<name>v</name>)-&gt;<name>cval</name></expr>;</expr_stmt>
<expr_stmt><expr><name>j</name> = ((<name>PyComplexObject</name> *)<name>w</name>)-&gt;<name>cval</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>op</name> != <name>Py_EQ</name> &amp;&amp; <name>op</name> != <name>Py_NE</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
<argument><expr>"no ordering relation is defined for complex numbers"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<if>if <condition>(<expr>(<name><name>i</name>.<name>real</name></name> == <name><name>j</name>.<name>real</name></name> &amp;&amp; <name><name>i</name>.<name>imag</name></name> == <name><name>j</name>.<name>imag</name></name>) == (<name>op</name> == <name>Py_EQ</name>)</expr>)</condition><then>
<expr_stmt><expr><name>res</name> = <name>Py_True</name></expr>;</expr_stmt></then>
<else>else
<expr_stmt><expr><name>res</name> = <name>Py_False</name></expr>;</expr_stmt></else></if>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>res</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>complex_int</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>v</name></decl></param>)</parameter_list> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
<argument><expr>"can't convert complex to int; use int(abs(z))"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>complex_long</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>v</name></decl></param>)</parameter_list> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
<argument><expr>"can't convert complex to long; use long(abs(z))"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>complex_float</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>v</name></decl></param>)</parameter_list> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
<argument><expr>"can't convert complex to float; use abs(z)"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>complex_conjugate</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>Py_complex</name></type> <name>c</name></decl>;</decl_stmt>
<expr_stmt><expr><name>c</name> = ((<name>PyComplexObject</name> *)<name>self</name>)-&gt;<name>cval</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>c</name>.<name>imag</name></name> = -<name><name>c</name>.<name>imag</name></name></expr>;</expr_stmt>
<return>return <expr><call><name>PyComplex_FromCComplex</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>complex_conjugate_doc</name></expr></argument>,
<argument><expr>"complex.conjugate() -&gt; complex\n"
"\n"
"Returns the complex conjugate of its argument. (3-4j).conjugate() == 3+4j."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>complex_getnewargs</name><parameter_list>(<param><decl><type><name>PyComplexObject</name> *</type><name>v</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>Py_complex</name></type> <name>c</name> <init>= <expr><name><name>v</name>-&gt;<name>cval</name></name></expr></init></decl>;</decl_stmt>
<return>return <expr><call><name>Py_BuildValue</name><argument_list>(<argument><expr>"(dd)"</expr></argument>, <argument><expr><name><name>c</name>.<name>real</name></name></expr></argument>, <argument><expr><name><name>c</name>.<name>imag</name></name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>0</expr></cpp:if>
static PyObject *
complex_is_finite(PyObject *self) {
Py_complex c;
c = ((PyComplexObject *)self)-&gt;cval;
return PyBool_FromLong((long)(Py_IS_FINITE(c.real) &amp;&amp;
Py_IS_FINITE(c.imag)));
}
PyDoc_STRVAR(complex_is_finite_doc,
"complex.is_finite() -&gt; bool\n"
"\n"
"Returns True if the real and the imaginary part is finite.");
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<decl_stmt><decl><type><specifier>static</specifier> <name>PyMethodDef</name></type> <name><name>complex_methods</name><index>[]</index></name> <init>= <expr><block>{
<expr><block>{
<expr>"conjugate"</expr>, <expr>(<name>PyCFunction</name>)<name>complex_conjugate</name></expr>, <expr><name>METH_NOARGS</name></expr>,
<expr><name>complex_conjugate_doc</name></expr>
}</block></expr>,
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>0</expr></cpp:if>
{
"is_finite", (PyCFunction)complex_is_finite, METH_NOARGS,
complex_is_finite_doc
},
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr><block>{<expr>"__getnewargs__"</expr>, <expr>(<name>PyCFunction</name>)<name>complex_getnewargs</name></expr>, <expr><name>METH_NOARGS</name></expr>}</block></expr>,
<expr><block>{<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>}</block></expr>
}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>PyMemberDef</name></type> <name><name>complex_members</name><index>[]</index></name> <init>= <expr><block>{
<expr><block>{
<expr>"real"</expr>, <expr><name>T_DOUBLE</name></expr>, <expr><call><name>offsetof</name><argument_list>(<argument><expr><name>PyComplexObject</name></expr></argument>, <argument><expr><name><name>cval</name>.<name>real</name></name></expr></argument>)</argument_list></call></expr>, <expr><name>READONLY</name></expr>,
<expr>"the real part of a complex number"</expr>
}</block></expr>,
<expr><block>{
<expr>"imag"</expr>, <expr><name>T_DOUBLE</name></expr>, <expr><call><name>offsetof</name><argument_list>(<argument><expr><name>PyComplexObject</name></expr></argument>, <argument><expr><name><name>cval</name>.<name>imag</name></name></expr></argument>)</argument_list></call></expr>, <expr><name>READONLY</name></expr>,
<expr>"the imaginary part of a complex number"</expr>
}</block></expr>,
<expr><block>{<expr>0</expr>}</block></expr>,
}</block></expr></init></decl>;</decl_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>complex_subtype_from_string</name><parameter_list>(<param><decl><type><name>PyTypeObject</name> *</type><name>type</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>v</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>s</name></decl>, *<decl><type ref="prev"/><name>start</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>end</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>double</name></type> <name>x</name><init>=<expr>0.0</expr></init>, <name>y</name><init>=<expr>0.0</expr></init>, <name>z</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>got_re</name><init>=<expr>0</expr></init>, <name>got_im</name><init>=<expr>0</expr></init>, <name>got_bracket</name><init>=<expr>0</expr></init>, <name>done</name><init>=<expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>digit_or_dot</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>sw_error</name><init>=<expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>sign</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name><name>buffer</name><index>[<expr>256</expr>]</index></name></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>Py_USING_UNICODE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>char</name></type> <name><name>s_buffer</name><index>[<expr>256</expr>]</index></name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>len</name></decl>;</decl_stmt>
<if>if <condition>(<expr><call><name>PyString_Check</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><name>s</name> = <call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>len</name> = <call><name>PyString_GET_SIZE</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>Py_USING_UNICODE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<else>else <if>if <condition>(<expr><call><name>PyUnicode_Check</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<if>if <condition>(<expr><call><name>PyUnicode_GET_SIZE</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call> &gt;= (<name>Py_ssize_t</name>)<sizeof>sizeof<argument_list>(<argument><expr><name>s_buffer</name></expr></argument>)</argument_list></sizeof></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>,
<argument><expr>"complex() literal too large to convert"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<if>if <condition>(<expr><call><name>PyUnicode_EncodeDecimal</name><argument_list>(<argument><expr><call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name>PyUnicode_GET_SIZE</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>s_buffer</name></expr></argument>,
<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>s</name> = <name>s_buffer</name></expr>;</expr_stmt>
<expr_stmt><expr><name>len</name> = <call><name>strlen</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<else>else <if>if <condition>(<expr><call><name>PyObject_AsCharBuffer</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr>&amp;<name>s</name></expr></argument>, <argument><expr>&amp;<name>len</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
<argument><expr>"complex() arg is not a string"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if></else></if></else></if>
<expr_stmt><expr><name>start</name> = <name>s</name></expr>;</expr_stmt>
<while>while <condition>(<expr>*<name>s</name> &amp;&amp; <call><name>isspace</name><argument_list>(<argument><expr><call><name>Py_CHARMASK</name><argument_list>(<argument><expr>*<name>s</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
<expr_stmt><expr><name>s</name>++</expr>;</expr_stmt></while>
<if>if <condition>(<expr><name><name>s</name><index>[<expr>0</expr>]</index></name> == '\0'</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>,
<argument><expr>"complex() arg is an empty string"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<if>if <condition>(<expr><name><name>s</name><index>[<expr>0</expr>]</index></name> == '('</expr>)</condition><then> <block>{
<expr_stmt><expr><name>got_bracket</name> = 1</expr>;</expr_stmt>
<expr_stmt><expr><name>s</name>++</expr>;</expr_stmt>
<while>while <condition>(<expr>*<name>s</name> &amp;&amp; <call><name>isspace</name><argument_list>(<argument><expr><call><name>Py_CHARMASK</name><argument_list>(<argument><expr>*<name>s</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
<expr_stmt><expr><name>s</name>++</expr>;</expr_stmt></while>
}</block></then></if>
<expr_stmt><expr><name>z</name> = -1.0</expr>;</expr_stmt>
<expr_stmt><expr><name>sign</name> = 1</expr>;</expr_stmt>
<do>do <block>{
<switch>switch <condition>(<expr>*<name>s</name></expr>)</condition> <block>{
<case>case <expr>'\0'</expr>:
<if>if <condition>(<expr><name>s</name>-<name>start</name> != <name>len</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(
<argument><expr><name>PyExc_ValueError</name></expr></argument>,
<argument><expr>"complex() arg contains a null byte"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<if>if<condition>(<expr>!<name>done</name></expr>)</condition><then> <expr_stmt><expr><name>sw_error</name>=1</expr>;</expr_stmt></then></if>
<break>break;</break>
</case><case>case <expr>')'</expr>:
<if>if <condition>(<expr>!<name>got_bracket</name> || !(<name>got_re</name> || <name>got_im</name>)</expr>)</condition><then> <block>{
<expr_stmt><expr><name>sw_error</name>=1</expr>;</expr_stmt>
<break>break;</break>
}</block></then></if>
<expr_stmt><expr><name>got_bracket</name>=0</expr>;</expr_stmt>
<expr_stmt><expr><name>done</name>=1</expr>;</expr_stmt>
<expr_stmt><expr><name>s</name>++</expr>;</expr_stmt>
<while>while <condition>(<expr>*<name>s</name> &amp;&amp; <call><name>isspace</name><argument_list>(<argument><expr><call><name>Py_CHARMASK</name><argument_list>(<argument><expr>*<name>s</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
<expr_stmt><expr><name>s</name>++</expr>;</expr_stmt></while>
<if>if <condition>(<expr>*<name>s</name></expr>)</condition><then> <expr_stmt><expr><name>sw_error</name>=1</expr>;</expr_stmt></then></if>
<break>break;</break>
</case><case>case <expr>'-'</expr>:
<expr_stmt><expr><name>sign</name> = -1</expr>;</expr_stmt>
</case><case>case <expr>'+'</expr>:
<if>if <condition>(<expr><name>done</name></expr>)</condition><then> <expr_stmt><expr><name>sw_error</name>=1</expr>;</expr_stmt></then></if>
<expr_stmt><expr><name>s</name>++</expr>;</expr_stmt>
<if>if <condition>( <expr>*<name>s</name>=='\0'||*<name>s</name>=='+'||*<name>s</name>=='-'||*<name>s</name>==')'||
<call><name>isspace</name><argument_list>(<argument><expr><call><name>Py_CHARMASK</name><argument_list>(<argument><expr>*<name>s</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> )</condition><then> <expr_stmt><expr><name>sw_error</name>=1</expr>;</expr_stmt></then></if>
<break>break;</break>
</case><case>case <expr>'J'</expr>:
</case><case>case <expr>'j'</expr>:
<if>if <condition>(<expr><name>got_im</name> || <name>done</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>sw_error</name> = 1</expr>;</expr_stmt>
<break>break;</break>
}</block></then></if>
<if>if <condition>(<expr><name>z</name>&lt;0.0</expr>)</condition><then> <block>{
<expr_stmt><expr><name>y</name>=<name>sign</name></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr><name>y</name>=<name>sign</name>*<name>z</name></expr>;</expr_stmt>
}</block></else></if>
<expr_stmt><expr><name>got_im</name>=1</expr>;</expr_stmt>
<expr_stmt><expr><name>s</name>++</expr>;</expr_stmt>
<if>if <condition>(<expr>*<name>s</name>!='+' &amp;&amp; *<name>s</name>!='-'</expr> )</condition><then>
<expr_stmt><expr><name>done</name>=1</expr>;</expr_stmt></then></if>
<break>break;</break>
</case><default>default:
<if>if <condition>(<expr><call><name>isspace</name><argument_list>(<argument><expr><call><name>Py_CHARMASK</name><argument_list>(<argument><expr>*<name>s</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<while>while <condition>(<expr>*<name>s</name> &amp;&amp; <call><name>isspace</name><argument_list>(<argument><expr><call><name>Py_CHARMASK</name><argument_list>(<argument><expr>*<name>s</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
<expr_stmt><expr><name>s</name>++</expr>;</expr_stmt></while>
<if>if <condition>(<expr>*<name>s</name> &amp;&amp; *<name>s</name> != ')'</expr>)</condition><then>
<expr_stmt><expr><name>sw_error</name>=1</expr>;</expr_stmt></then>
<else>else
<expr_stmt><expr><name>done</name> = 1</expr>;</expr_stmt></else></if>
<break>break;</break>
}</block></then></if>
<expr_stmt><expr><name>digit_or_dot</name> =
(*<name>s</name>=='.' || <call><name>isdigit</name><argument_list>(<argument><expr><call><name>Py_CHARMASK</name><argument_list>(<argument><expr>*<name>s</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>)</expr>;</expr_stmt>
<if>if <condition>(<expr><name>done</name>||!<name>digit_or_dot</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>sw_error</name>=1</expr>;</expr_stmt>
<break>break;</break>
}</block></then></if>
<expr_stmt><expr><name>errno</name> = 0</expr>;</expr_stmt>
<macro><name>PyFPE_START_PROTECT</name><argument_list>(<argument>"strtod"</argument>, <argument>return 0</argument>)</argument_list></macro>
<expr_stmt><expr><name>z</name> = <call><name>PyOS_ascii_strtod</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr>&amp;<name>end</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
<macro><name>PyFPE_END_PROTECT</name><argument_list>(<argument>z</argument>)</argument_list></macro>
<if>if <condition>(<expr><name>errno</name> != 0</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyOS_snprintf</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></sizeof></expr></argument>,
<argument><expr>"float() out of range: %.150s"</expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(
<argument><expr><name>PyExc_ValueError</name></expr></argument>,
<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>s</name>=<name>end</name></expr>;</expr_stmt>
<if>if <condition>(<expr>*<name>s</name>=='J' || *<name>s</name>=='j'</expr>)</condition><then> <block>{
<break>break;</break>
}</block></then></if>
<if>if <condition>(<expr><name>got_re</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>sw_error</name>=1</expr>;</expr_stmt>
<break>break;</break>
}</block></then></if>
<expr_stmt><expr><name>x</name>=<name>sign</name>*<name>z</name></expr>;</expr_stmt>
<expr_stmt><expr><name>got_re</name>=1</expr>;</expr_stmt>
<if>if <condition>(<expr><name>got_im</name></expr>)</condition><then> <expr_stmt><expr><name>done</name>=1</expr>;</expr_stmt></then></if>
<expr_stmt><expr><name>z</name> = -1.0</expr>;</expr_stmt>
<expr_stmt><expr><name>sign</name> = 1</expr>;</expr_stmt>
<break>break;</break>
</default>}</block></switch>
}</block> while <condition>(<expr><name>s</name> - <name>start</name> &lt; <name>len</name> &amp;&amp; !<name>sw_error</name></expr>)</condition>;</do>
<if>if <condition>(<expr><name>sw_error</name> || <name>got_bracket</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>,
<argument><expr>"complex() arg is a malformed string"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<return>return <expr><call><name>complex_subtype_from_doubles</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><name>x</name></expr></argument>, <argument><expr><name>y</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>complex_new</name><parameter_list>(<param><decl><type><name>PyTypeObject</name> *</type><name>type</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>kwds</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>r</name></decl>, *<decl><type ref="prev"/><name>i</name></decl>, *<decl><type ref="prev"/><name>tmp</name></decl>, *<decl><type ref="prev"/><name>f</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyNumberMethods</name> *</type><name>nbr</name></decl>, *<decl><type ref="prev"/><name>nbi</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_complex</name></type> <name>cr</name></decl>, <decl><type ref="prev"/><name>ci</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>own_r</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>cr_is_complex</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>ci_is_complex</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>PyObject</name> *</type><name>complexstr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> *</type><name><name>kwlist</name><index>[]</index></name> <init>= <expr><block>{<expr>"real"</expr>, <expr>"imag"</expr>, <expr>0</expr>}</block></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>r</name> = <name>Py_False</name></expr>;</expr_stmt>
<expr_stmt><expr><name>i</name> = <name>NULL</name></expr>;</expr_stmt>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTupleAndKeywords</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>kwds</name></expr></argument>, <argument><expr>"|OO:complex"</expr></argument>, <argument><expr><name>kwlist</name></expr></argument>,
<argument><expr>&amp;<name>r</name></expr></argument>, <argument><expr>&amp;<name>i</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<if>if <condition>(<expr><call><name>PyComplex_CheckExact</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call> &amp;&amp; <name>i</name> == <name>NULL</name> &amp;&amp;
<name>type</name> == &amp;<name>PyComplex_Type</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>r</name></expr>;</return>
}</block></then></if>
<if>if <condition>(<expr><call><name>PyString_Check</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call> || <call><name>PyUnicode_Check</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<if>if <condition>(<expr><name>i</name> != <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
<argument><expr>"complex() can't take second arg"
" if first is a string"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<return>return <expr><call><name>complex_subtype_from_string</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></then></if>
<if>if <condition>(<expr><name>i</name> != <name>NULL</name> &amp;&amp; (<call><name>PyString_Check</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call> || <call><name>PyUnicode_Check</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call>)</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
<argument><expr>"complex() second arg can't be a string"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<if>if <condition>(<expr><name>complexstr</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>complexstr</name> = <call><name>PyString_InternFromString</name><argument_list>(<argument><expr>"__complex__"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>complexstr</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
}</block></then></if>
<expr_stmt><expr><name>f</name> = <call><name>PyObject_GetAttr</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>complexstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>f</name> == <name>NULL</name></expr>)</condition><then>
<expr_stmt><expr><call><name>PyErr_Clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then>
<else>else <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>args</name> <init>= <expr><call><name>PyTuple_New</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>args</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>r</name> = <call><name>PyEval_CallObject</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>r</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>own_r</name> = 1</expr>;</expr_stmt>
}</block></else></if>
<expr_stmt><expr><name>nbr</name> = <name><name>r</name>-&gt;<name>ob_type</name>-&gt;<name>tp_as_number</name></name></expr>;</expr_stmt>
<if>if <condition>(<expr><name>i</name> != <name>NULL</name></expr>)</condition><then>
<expr_stmt><expr><name>nbi</name> = <name><name>i</name>-&gt;<name>ob_type</name>-&gt;<name>tp_as_number</name></name></expr>;</expr_stmt></then></if>
<if>if <condition>(<expr><name>nbr</name> == <name>NULL</name> || <name><name>nbr</name>-&gt;<name>nb_float</name></name> == <name>NULL</name> ||
((<name>i</name> != <name>NULL</name>) &amp;&amp; (<name>nbi</name> == <name>NULL</name> || <name><name>nbi</name>-&gt;<name>nb_float</name></name> == <name>NULL</name>))</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
<argument><expr>"complex() argument must be a string or a number"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>own_r</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<if>if <condition>(<expr><call><name>PyComplex_Check</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><name>cr</name> = ((<name>PyComplexObject</name>*)<name>r</name>)-&gt;<name>cval</name></expr>;</expr_stmt>
<expr_stmt><expr><name>cr_is_complex</name> = 1</expr>;</expr_stmt>
<if>if <condition>(<expr><name>own_r</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
}</block></then> <else>else <block>{
<expr_stmt><expr><name>tmp</name> = <call><name>PyNumber_Float</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>own_r</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<if>if <condition>(<expr><name>tmp</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<if>if <condition>(<expr>!<call><name>PyFloat_Check</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
<argument><expr>"float(r) didn't return a float"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name><name>cr</name>.<name>real</name></name> = <call><name>PyFloat_AsDouble</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cr</name>.<name>imag</name></name> = 0.0</expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></else></if>
<if>if <condition>(<expr><name>i</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>ci</name>.<name>real</name></name> = 0.0</expr>;</expr_stmt>
}</block></then> <else>else <if>if <condition>(<expr><call><name>PyComplex_Check</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><name>ci</name> = ((<name>PyComplexObject</name>*)<name>i</name>)-&gt;<name>cval</name></expr>;</expr_stmt>
<expr_stmt><expr><name>ci_is_complex</name> = 1</expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr><name>tmp</name> = <call>(*<name><name>nbi</name>-&gt;<name>nb_float</name></name>)<argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>tmp</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name><name>ci</name>.<name>real</name></name> = <call><name>PyFloat_AsDouble</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></else></if></else></if>
<if>if <condition>(<expr><name>ci_is_complex</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>cr</name>.<name>real</name></name> -= <name><name>ci</name>.<name>imag</name></name></expr>;</expr_stmt>
}</block></then></if>
<if>if <condition>(<expr><name>cr_is_complex</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>ci</name>.<name>real</name></name> += <name><name>cr</name>.<name>imag</name></name></expr>;</expr_stmt>
}</block></then></if>
<return>return <expr><call><name>complex_subtype_from_doubles</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><name><name>cr</name>.<name>real</name></name></expr></argument>, <argument><expr><name><name>ci</name>.<name>real</name></name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>complex_doc</name></expr></argument>,
<argument><expr>"complex(real[, imag]) -&gt; complex number\n"
"\n"
"Create a complex number from a real part and an optional imaginary part.\n"
"This is equivalent to (real + imag*1j) where imag defaults to 0."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>PyNumberMethods</name></type> <name>complex_as_number</name> <init>= <expr><block>{
<expr>(<name>binaryfunc</name>)<name>complex_add</name></expr>,
<expr>(<name>binaryfunc</name>)<name>complex_sub</name></expr>,
<expr>(<name>binaryfunc</name>)<name>complex_mul</name></expr>,
<expr>(<name>binaryfunc</name>)<name>complex_classic_div</name></expr>,
<expr>(<name>binaryfunc</name>)<name>complex_remainder</name></expr>,
<expr>(<name>binaryfunc</name>)<name>complex_divmod</name></expr>,
<expr>(<name>ternaryfunc</name>)<name>complex_pow</name></expr>,
<expr>(<name>unaryfunc</name>)<name>complex_neg</name></expr>,
<expr>(<name>unaryfunc</name>)<name>complex_pos</name></expr>,
<expr>(<name>unaryfunc</name>)<name>complex_abs</name></expr>,
<expr>(<name>inquiry</name>)<name>complex_nonzero</name></expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr><name>complex_coerce</name></expr>,
<expr><name>complex_int</name></expr>,
<expr><name>complex_long</name></expr>,
<expr><name>complex_float</name></expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>(<name>binaryfunc</name>)<name>complex_int_div</name></expr>,
<expr>(<name>binaryfunc</name>)<name>complex_div</name></expr>,
<expr>0</expr>,
<expr>0</expr>,
}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyTypeObject</name></type> <name>PyComplex_Type</name> <init>= <expr><block>{
<expr><call><name>PyVarObject_HEAD_INIT</name><argument_list>(<argument><expr>&amp;<name>PyType_Type</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call>
"complex"</expr>,
<expr><sizeof>sizeof<argument_list>(<argument><expr><name>PyComplexObject</name></expr></argument>)</argument_list></sizeof></expr>,
<expr>0</expr>,
<expr><name>complex_dealloc</name></expr>,
<expr>(<name>printfunc</name>)<name>complex_print</name></expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>(<name>reprfunc</name>)<name>complex_repr</name></expr>,
<expr>&amp;<name>complex_as_number</name></expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>(<name>hashfunc</name>)<name>complex_hash</name></expr>,
<expr>0</expr>,
<expr>(<name>reprfunc</name>)<name>complex_str</name></expr>,
<expr><name>PyObject_GenericGetAttr</name></expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr><name>Py_TPFLAGS_DEFAULT</name> | <name>Py_TPFLAGS_BASETYPE</name></expr>,
<expr><name>complex_doc</name></expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr><name>complex_richcompare</name></expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr><name>complex_methods</name></expr>,
<expr><name>complex_members</name></expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr><name>PyType_GenericAlloc</name></expr>,
<expr><name>complex_new</name></expr>,
<expr><name>PyObject_Del</name></expr>,
}</block></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</unit>
