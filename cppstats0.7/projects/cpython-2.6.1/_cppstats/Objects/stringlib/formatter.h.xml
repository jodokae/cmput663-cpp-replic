<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C" filename="projects/cpython-2.6.1/_cppstats/Objects/stringlib/formatter.h"><cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ALLOW_PARENS_FOR_SIGN</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>get_integer</name><parameter_list>(<param><decl><type><name>STRINGLIB_CHAR</name> **</type><name>ptr</name></decl></param>, <param><decl><type><name>STRINGLIB_CHAR</name> *</type><name>end</name></decl></param>,
<param><decl><type><name>Py_ssize_t</name> *</type><name>result</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>accumulator</name></decl>, <decl><type ref="prev"/><name>digitval</name></decl>, <decl><type ref="prev"/><name>oldaccumulator</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>numdigits</name></decl>;</decl_stmt>
<expr_stmt><expr><name>accumulator</name> = <name>numdigits</name> = 0</expr>;</expr_stmt>
<for>for (<init>;</init><condition>;</condition> <incr><expr>(*<name>ptr</name>)++</expr>, <expr><name>numdigits</name>++</expr></incr>) <block>{
<if>if <condition>(<expr>*<name>ptr</name> &gt;= <name>end</name></expr>)</condition><then>
<break>break;</break></then></if>
<expr_stmt><expr><name>digitval</name> = <call><name>STRINGLIB_TODECIMAL</name><argument_list>(<argument><expr>**<name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>digitval</name> &lt; 0</expr>)</condition><then>
<break>break;</break></then></if>
<expr_stmt><expr><name>oldaccumulator</name> = <name>accumulator</name></expr>;</expr_stmt>
<expr_stmt><expr><name>accumulator</name> *= 10</expr>;</expr_stmt>
<if>if <condition>(<expr>(<name>accumulator</name>+10)/10 != <name>oldaccumulator</name>+1</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>,
<argument><expr>"Too many decimal digits in format string"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>-1</expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>accumulator</name> += <name>digitval</name></expr>;</expr_stmt>
}</block></for>
<expr_stmt><expr>*<name>result</name> = <name>accumulator</name></expr>;</expr_stmt>
<return>return <expr><name>numdigits</name></expr>;</return>
}</block></function>
<macro><name>Py_LOCAL_INLINE</name><argument_list>(<argument>int</argument>)</argument_list></macro>
<macro><name>is_alignment_token</name><argument_list>(<argument>STRINGLIB_CHAR c</argument>)</argument_list></macro> <block>{
<switch>switch <condition>(<expr><name>c</name></expr>)</condition> <block>{
<case>case <expr>'&lt;'</expr>:
</case><case>case <expr>'&gt;'</expr>:
</case><case>case <expr>'='</expr>:
</case><case>case <expr>'^'</expr>:
<return>return <expr>1</expr>;</return>
</case><default>default:
<return>return <expr>0</expr>;</return>
</default>}</block></switch>
}</block>
<macro><name>Py_LOCAL_INLINE</name><argument_list>(<argument>int</argument>)</argument_list></macro>
<macro><name>is_sign_element</name><argument_list>(<argument>STRINGLIB_CHAR c</argument>)</argument_list></macro> <block>{
<switch>switch <condition>(<expr><name>c</name></expr>)</condition> <block>{
<case>case <expr>' '</expr>:
</case><case>case <expr>'+'</expr>:
</case><case>case <expr>'-'</expr>:
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>ALLOW_PARENS_FOR_SIGN</name></expr></cpp:if>
</case><case>case <expr>'('</expr>:
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<return>return <expr>1</expr>;</return>
</case><default>default:
<return>return <expr>0</expr>;</return>
</default>}</block></switch>
}</block>
<typedef>typedef <type><struct>struct <block>{
<decl_stmt><decl><type><name>STRINGLIB_CHAR</name></type> <name>fill_char</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>STRINGLIB_CHAR</name></type> <name>align</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>alternate</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>STRINGLIB_CHAR</name></type> <name>sign</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>width</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>precision</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>STRINGLIB_CHAR</name></type> <name>type</name></decl>;</decl_stmt>
}</block></struct></type> <name>InternalFormatSpec</name>;</typedef>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>parse_internal_render_format_spec</name><parameter_list>(<param><decl><type><name>STRINGLIB_CHAR</name> *</type><name>format_spec</name></decl></param>,
<param><decl><type><name>Py_ssize_t</name></type> <name>format_spec_len</name></decl></param>,
<param><decl><type><name>InternalFormatSpec</name> *</type><name>format</name></decl></param>,
<param><decl><type><name>char</name></type> <name>default_type</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>STRINGLIB_CHAR</name> *</type><name>ptr</name> <init>= <expr><name>format_spec</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>STRINGLIB_CHAR</name> *</type><name>end</name> <init>= <expr><name>format_spec</name> + <name>format_spec_len</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>specified_width</name></decl>;</decl_stmt>
<expr_stmt><expr><name><name>format</name>-&gt;<name>fill_char</name></name> = '\0'</expr>;</expr_stmt>
<expr_stmt><expr><name><name>format</name>-&gt;<name>align</name></name> = '\0'</expr>;</expr_stmt>
<expr_stmt><expr><name><name>format</name>-&gt;<name>alternate</name></name> = 0</expr>;</expr_stmt>
<expr_stmt><expr><name><name>format</name>-&gt;<name>sign</name></name> = '\0'</expr>;</expr_stmt>
<expr_stmt><expr><name><name>format</name>-&gt;<name>width</name></name> = -1</expr>;</expr_stmt>
<expr_stmt><expr><name><name>format</name>-&gt;<name>precision</name></name> = -1</expr>;</expr_stmt>
<expr_stmt><expr><name><name>format</name>-&gt;<name>type</name></name> = <name>default_type</name></expr>;</expr_stmt>
<if>if <condition>(<expr><name>end</name>-<name>ptr</name> &gt;= 2 &amp;&amp; <call><name>is_alignment_token</name><argument_list>(<argument><expr><name><name>ptr</name><index>[<expr>1</expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>format</name>-&gt;<name>align</name></name> = <name><name>ptr</name><index>[<expr>1</expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>format</name>-&gt;<name>fill_char</name></name> = <name><name>ptr</name><index>[<expr>0</expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name>ptr</name> += 2</expr>;</expr_stmt>
}</block></then> <else>else <if>if <condition>(<expr><name>end</name>-<name>ptr</name> &gt;= 1 &amp;&amp; <call><name>is_alignment_token</name><argument_list>(<argument><expr><name><name>ptr</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>format</name>-&gt;<name>align</name></name> = <name><name>ptr</name><index>[<expr>0</expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr>++<name>ptr</name></expr>;</expr_stmt>
}</block></then></if></else></if>
<if>if <condition>(<expr><name>end</name>-<name>ptr</name> &gt;= 1 &amp;&amp; <call><name>is_sign_element</name><argument_list>(<argument><expr><name><name>ptr</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>format</name>-&gt;<name>sign</name></name> = <name><name>ptr</name><index>[<expr>0</expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr>++<name>ptr</name></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>ALLOW_PARENS_FOR_SIGN</name></expr></cpp:if>
<if>if <condition>(<expr><name>end</name>-<name>ptr</name> &gt;= 1 &amp;&amp; <name><name>ptr</name><index>[<expr>0</expr>]</index></name> == ')'</expr>)</condition><then> <block>{
<expr_stmt><expr>++<name>ptr</name></expr>;</expr_stmt>
}</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></then></if>
<if>if <condition>(<expr><name>end</name>-<name>ptr</name> &gt;= 1 &amp;&amp; <name><name>ptr</name><index>[<expr>0</expr>]</index></name> == '#'</expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>format</name>-&gt;<name>alternate</name></name> = 1</expr>;</expr_stmt>
<expr_stmt><expr>++<name>ptr</name></expr>;</expr_stmt>
}</block></then></if>
<if>if <condition>(<expr><name><name>format</name>-&gt;<name>fill_char</name></name> == '\0' &amp;&amp; <name>end</name>-<name>ptr</name> &gt;= 1 &amp;&amp; <name><name>ptr</name><index>[<expr>0</expr>]</index></name> == '0'</expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>format</name>-&gt;<name>fill_char</name></name> = '0'</expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>format</name>-&gt;<name>align</name></name> == '\0'</expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>format</name>-&gt;<name>align</name></name> = '='</expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr>++<name>ptr</name></expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><name>specified_width</name> = <call><name>get_integer</name><argument_list>(<argument><expr>&amp;<name>ptr</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr>&amp;<name><name>format</name>-&gt;<name>width</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>specified_width</name> == 0</expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>format</name>-&gt;<name>width</name></name> = -1</expr>;</expr_stmt>
}</block></then></if>
<if>if <condition>(<expr><name>end</name>-<name>ptr</name> &amp;&amp; <name><name>ptr</name><index>[<expr>0</expr>]</index></name> == '.'</expr>)</condition><then> <block>{
<expr_stmt><expr>++<name>ptr</name></expr>;</expr_stmt>
<expr_stmt><expr><name>specified_width</name> = <call><name>get_integer</name><argument_list>(<argument><expr>&amp;<name>ptr</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr>&amp;<name><name>format</name>-&gt;<name>precision</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>specified_width</name> == 0</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>,
<argument><expr>"Format specifier missing precision"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>0</expr>;</return>
}</block></then></if>
}</block></then></if>
<if>if <condition>(<expr><name>end</name>-<name>ptr</name> &gt; 1</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>, <argument><expr>"Invalid conversion specification"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>0</expr>;</return>
}</block></then></if>
<if>if <condition>(<expr><name>end</name>-<name>ptr</name> == 1</expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>format</name>-&gt;<name>type</name></name> = <name><name>ptr</name><index>[<expr>0</expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr>++<name>ptr</name></expr>;</expr_stmt>
}</block></then></if>
<return>return <expr>1</expr>;</return>
}</block></function>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>defined</name> <name>FORMAT_FLOAT</name> || <name>defined</name> <name>FORMAT_LONG</name></expr></cpp:if>
<typedef>typedef <type><struct>struct <block>{
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>n_lpadding</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>n_prefix</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>n_spadding</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>n_rpadding</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name>lsign</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>n_lsign</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name>rsign</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>n_rsign</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>n_total</name></decl>;</decl_stmt>
}</block></struct></type> <name>NumberFieldWidths</name>;</typedef>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>calc_number_widths</name><parameter_list>(<param><decl><type><name>NumberFieldWidths</name> *</type><name>spec</name></decl></param>, <param><decl><type><name>STRINGLIB_CHAR</name></type> <name>actual_sign</name></decl></param>,
<param><decl><type><name>Py_ssize_t</name></type> <name>n_prefix</name></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>n_digits</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>InternalFormatSpec</name> *</type><name>format</name></decl></param>)</parameter_list> <block>{
<expr_stmt><expr><name><name>spec</name>-&gt;<name>n_lpadding</name></name> = 0</expr>;</expr_stmt>
<expr_stmt><expr><name><name>spec</name>-&gt;<name>n_prefix</name></name> = 0</expr>;</expr_stmt>
<expr_stmt><expr><name><name>spec</name>-&gt;<name>n_spadding</name></name> = 0</expr>;</expr_stmt>
<expr_stmt><expr><name><name>spec</name>-&gt;<name>n_rpadding</name></name> = 0</expr>;</expr_stmt>
<expr_stmt><expr><name><name>spec</name>-&gt;<name>lsign</name></name> = '\0'</expr>;</expr_stmt>
<expr_stmt><expr><name><name>spec</name>-&gt;<name>n_lsign</name></name> = 0</expr>;</expr_stmt>
<expr_stmt><expr><name><name>spec</name>-&gt;<name>rsign</name></name> = '\0'</expr>;</expr_stmt>
<expr_stmt><expr><name><name>spec</name>-&gt;<name>n_rsign</name></name> = 0</expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>format</name>-&gt;<name>sign</name></name> == '+'</expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>spec</name>-&gt;<name>n_lsign</name></name> = 1</expr>;</expr_stmt>
<expr_stmt><expr><name><name>spec</name>-&gt;<name>lsign</name></name> = (<name>actual_sign</name> == '-' ? '-' : '+')</expr>;</expr_stmt>
}</block></then>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>ALLOW_PARENS_FOR_SIGN</name></expr></cpp:if>
<else>else <if>if <condition>(<expr><name><name>format</name>-&gt;<name>sign</name></name> == '('</expr>)</condition><then> <block>{
<if>if <condition>(<expr><name>actual_sign</name> == '-'</expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>spec</name>-&gt;<name>n_lsign</name></name> = 1</expr>;</expr_stmt>
<expr_stmt><expr><name><name>spec</name>-&gt;<name>lsign</name></name> = '('</expr>;</expr_stmt>
<expr_stmt><expr><name><name>spec</name>-&gt;<name>n_rsign</name></name> = 1</expr>;</expr_stmt>
<expr_stmt><expr><name><name>spec</name>-&gt;<name>rsign</name></name> = ')'</expr>;</expr_stmt>
}</block></then></if>
}</block></then>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<else>else <if>if <condition>(<expr><name><name>format</name>-&gt;<name>sign</name></name> == ' '</expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>spec</name>-&gt;<name>n_lsign</name></name> = 1</expr>;</expr_stmt>
<expr_stmt><expr><name><name>spec</name>-&gt;<name>lsign</name></name> = (<name>actual_sign</name> == '-' ? '-' : ' ')</expr>;</expr_stmt>
}</block></then> <else>else <block>{
<if>if <condition>(<expr><name>actual_sign</name> == '-'</expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>spec</name>-&gt;<name>n_lsign</name></name> = 1</expr>;</expr_stmt>
<expr_stmt><expr><name><name>spec</name>-&gt;<name>lsign</name></name> = '-'</expr>;</expr_stmt>
}</block></then></if>
}</block></else></if></else></if></else></if>
<expr_stmt><expr><name><name>spec</name>-&gt;<name>n_prefix</name></name> = <name>n_prefix</name></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>format</name>-&gt;<name>width</name></name> == -1</expr>)</condition><then> <block>{
}</block></then> <else>else <block>{
<if>if <condition>(<expr><name><name>spec</name>-&gt;<name>n_lsign</name></name> + <name>n_digits</name> + <name><name>spec</name>-&gt;<name>n_rsign</name></name> +
<name><name>spec</name>-&gt;<name>n_prefix</name></name> &gt;= <name><name>format</name>-&gt;<name>width</name></name></expr>)</condition><then> <block>{
}</block></then> <else>else <block>{
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>padding</name> <init>= <expr><name><name>format</name>-&gt;<name>width</name></name> -
(<name><name>spec</name>-&gt;<name>n_lsign</name></name> + <name><name>spec</name>-&gt;<name>n_prefix</name></name> +
<name>n_digits</name> + <name><name>spec</name>-&gt;<name>n_rsign</name></name>)</expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name><name>format</name>-&gt;<name>align</name></name> == '&lt;'</expr>)</condition><then>
<expr_stmt><expr><name><name>spec</name>-&gt;<name>n_rpadding</name></name> = <name>padding</name></expr>;</expr_stmt></then>
<else>else <if>if <condition>(<expr><name><name>format</name>-&gt;<name>align</name></name> == '&gt;'</expr>)</condition><then>
<expr_stmt><expr><name><name>spec</name>-&gt;<name>n_lpadding</name></name> = <name>padding</name></expr>;</expr_stmt></then>
<else>else <if>if <condition>(<expr><name><name>format</name>-&gt;<name>align</name></name> == '^'</expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>spec</name>-&gt;<name>n_lpadding</name></name> = <name>padding</name> / 2</expr>;</expr_stmt>
<expr_stmt><expr><name><name>spec</name>-&gt;<name>n_rpadding</name></name> = <name>padding</name> - <name><name>spec</name>-&gt;<name>n_lpadding</name></name></expr>;</expr_stmt>
}</block></then> <else>else <if>if <condition>(<expr><name><name>format</name>-&gt;<name>align</name></name> == '='</expr>)</condition><then>
<expr_stmt><expr><name><name>spec</name>-&gt;<name>n_spadding</name></name> = <name>padding</name></expr>;</expr_stmt></then>
<else>else
<expr_stmt><expr><name><name>spec</name>-&gt;<name>n_lpadding</name></name> = <name>padding</name></expr>;</expr_stmt></else></if></else></if></else></if></else></if>
}</block></else></if>
}</block></else></if>
<expr_stmt><expr><name><name>spec</name>-&gt;<name>n_total</name></name> = <name><name>spec</name>-&gt;<name>n_lpadding</name></name> + <name><name>spec</name>-&gt;<name>n_lsign</name></name> + <name><name>spec</name>-&gt;<name>n_prefix</name></name> +
<name><name>spec</name>-&gt;<name>n_spadding</name></name> + <name>n_digits</name> + <name><name>spec</name>-&gt;<name>n_rsign</name></name> + <name><name>spec</name>-&gt;<name>n_rpadding</name></name></expr>;</expr_stmt>
}</block></function>
<function><type><specifier>static</specifier> <name>STRINGLIB_CHAR</name> *</type>
<name>fill_non_digits</name><parameter_list>(<param><decl><type><name>STRINGLIB_CHAR</name> *</type><name>p_buf</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>NumberFieldWidths</name> *</type><name>spec</name></decl></param>,
<param><decl><type><name>STRINGLIB_CHAR</name> *</type><name>prefix</name></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>n_digits</name></decl></param>,
<param><decl><type><name>STRINGLIB_CHAR</name></type> <name>fill_char</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>STRINGLIB_CHAR</name> *</type><name>p_digits</name></decl>;</decl_stmt>
<if>if <condition>(<expr><name><name>spec</name>-&gt;<name>n_lpadding</name></name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>STRINGLIB_FILL</name><argument_list>(<argument><expr><name>p_buf</name></expr></argument>, <argument><expr><name>fill_char</name></expr></argument>, <argument><expr><name><name>spec</name>-&gt;<name>n_lpadding</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>p_buf</name> += <name><name>spec</name>-&gt;<name>n_lpadding</name></name></expr>;</expr_stmt>
}</block></then></if>
<if>if <condition>(<expr><name><name>spec</name>-&gt;<name>n_lsign</name></name> == 1</expr>)</condition><then> <block>{
<expr_stmt><expr>*<name>p_buf</name>++ = <name><name>spec</name>-&gt;<name>lsign</name></name></expr>;</expr_stmt>
}</block></then></if>
<if>if <condition>(<expr><name><name>spec</name>-&gt;<name>n_prefix</name></name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><name>p_buf</name></expr></argument>,
<argument><expr><name>prefix</name></expr></argument>,
<argument><expr><name><name>spec</name>-&gt;<name>n_prefix</name></name> * <sizeof>sizeof<argument_list>(<argument><expr><name>STRINGLIB_CHAR</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>p_buf</name> += <name><name>spec</name>-&gt;<name>n_prefix</name></name></expr>;</expr_stmt>
}</block></then></if>
<if>if <condition>(<expr><name><name>spec</name>-&gt;<name>n_spadding</name></name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>STRINGLIB_FILL</name><argument_list>(<argument><expr><name>p_buf</name></expr></argument>, <argument><expr><name>fill_char</name></expr></argument>, <argument><expr><name><name>spec</name>-&gt;<name>n_spadding</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>p_buf</name> += <name><name>spec</name>-&gt;<name>n_spadding</name></name></expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><name>p_digits</name> = <name>p_buf</name></expr>;</expr_stmt>
<expr_stmt><expr><name>p_buf</name> += <name>n_digits</name></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>spec</name>-&gt;<name>n_rsign</name></name> == 1</expr>)</condition><then> <block>{
<expr_stmt><expr>*<name>p_buf</name>++ = <name><name>spec</name>-&gt;<name>rsign</name></name></expr>;</expr_stmt>
}</block></then></if>
<if>if <condition>(<expr><name><name>spec</name>-&gt;<name>n_rpadding</name></name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>STRINGLIB_FILL</name><argument_list>(<argument><expr><name>p_buf</name></expr></argument>, <argument><expr><name>fill_char</name></expr></argument>, <argument><expr><name><name>spec</name>-&gt;<name>n_rpadding</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>p_buf</name> += <name><name>spec</name>-&gt;<name>n_rpadding</name></name></expr>;</expr_stmt>
}</block></then></if>
<return>return <expr><name>p_digits</name></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>format_string_internal</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>value</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>InternalFormatSpec</name> *</type><name>format</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>width</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>lpad</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>STRINGLIB_CHAR</name> *</type><name>dst</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>STRINGLIB_CHAR</name> *</type><name>src</name> <init>= <expr><call><name>STRINGLIB_STR</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>len</name> <init>= <expr><call><name>STRINGLIB_LEN</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>result</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name><name>format</name>-&gt;<name>sign</name></name> != '\0'</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>,
<argument><expr>"Sign not allowed in string format specifier"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>done</name>;</goto>
}</block></then></if>
<if>if <condition>(<expr><name><name>format</name>-&gt;<name>alternate</name></name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>,
<argument><expr>"Alternate form (#) not allowed in string format "
"specifier"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>done</name>;</goto>
}</block></then></if>
<if>if <condition>(<expr><name><name>format</name>-&gt;<name>align</name></name> == '='</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>,
<argument><expr>"'=' alignment not allowed "
"in string format specifier"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>done</name>;</goto>
}</block></then></if>
<if>if <condition>(<expr><name><name>format</name>-&gt;<name>precision</name></name> &gt;= 0 &amp;&amp; <name>len</name> &gt;= <name><name>format</name>-&gt;<name>precision</name></name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>len</name> = <name><name>format</name>-&gt;<name>precision</name></name></expr>;</expr_stmt>
}</block></then></if>
<if>if <condition>(<expr><name><name>format</name>-&gt;<name>width</name></name> &gt;= 0</expr>)</condition><then> <block>{
<expr_stmt><expr><name>width</name> = <name><name>format</name>-&gt;<name>width</name></name></expr>;</expr_stmt>
<if>if <condition>(<expr><name>len</name> &gt; <name>width</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>width</name> = <name>len</name></expr>;</expr_stmt>
}</block></then></if>
}</block></then> <else>else <block>{
<expr_stmt><expr><name>width</name> = <name>len</name></expr>;</expr_stmt>
}</block></else></if>
<expr_stmt><expr><name>result</name> = <call><name>STRINGLIB_NEW</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>width</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>result</name> == <name>NULL</name></expr>)</condition><then>
<goto>goto <name>done</name>;</goto></then></if>
<expr_stmt><expr><name>dst</name> = <call><name>STRINGLIB_STR</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>format</name>-&gt;<name>align</name></name> == '&gt;'</expr>)</condition><then>
<expr_stmt><expr><name>lpad</name> = <name>width</name> - <name>len</name></expr>;</expr_stmt></then>
<else>else <if>if <condition>(<expr><name><name>format</name>-&gt;<name>align</name></name> == '^'</expr>)</condition><then>
<expr_stmt><expr><name>lpad</name> = (<name>width</name> - <name>len</name>) / 2</expr>;</expr_stmt></then>
<else>else
<expr_stmt><expr><name>lpad</name> = 0</expr>;</expr_stmt></else></if></else></if>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>dst</name> + <name>lpad</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>len</name> * <sizeof>sizeof<argument_list>(<argument><expr><name>STRINGLIB_CHAR</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>width</name> &gt; <name>len</name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>STRINGLIB_CHAR</name></type> <name>fill_char</name> <init>= <expr><name><name>format</name>-&gt;<name>fill_char</name></name></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>fill_char</name> == '\0'</expr>)</condition><then> <block>{
<expr_stmt><expr><name>fill_char</name> = ' '</expr>;</expr_stmt>
}</block></then></if>
<if>if <condition>(<expr><name>lpad</name></expr>)</condition><then>
<expr_stmt><expr><call><name>STRINGLIB_FILL</name><argument_list>(<argument><expr><name>dst</name></expr></argument>, <argument><expr><name>fill_char</name></expr></argument>, <argument><expr><name>lpad</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<if>if <condition>(<expr><name>width</name> - <name>len</name> - <name>lpad</name></expr>)</condition><then>
<expr_stmt><expr><call><name>STRINGLIB_FILL</name><argument_list>(<argument><expr><name>dst</name> + <name>len</name> + <name>lpad</name></expr></argument>, <argument><expr><name>fill_char</name></expr></argument>, <argument><expr><name>width</name> - <name>len</name> - <name>lpad</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
}</block></then></if>
<label><name>done</name>:</label>
<return>return <expr><name>result</name></expr>;</return>
}</block></function>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>defined</name> <name>FORMAT_LONG</name> || <name>defined</name> <name>FORMAT_INT</name></expr></cpp:if>
<typedef>typedef <function_decl><type><name>PyObject</name>*</type>
(*<name>IntOrLongToString</name>)<parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>value</name></decl></param>, <param><decl><type><name>int</name></type> <name>base</name></decl></param>)</parameter_list>;</function_decl></typedef>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>format_int_or_long_internal</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>value</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>InternalFormatSpec</name> *</type><name>format</name></decl></param>,
<param><decl><type><name>IntOrLongToString</name></type> <name>tostring</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>result</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>tmp</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>STRINGLIB_CHAR</name> *</type><name>pnumeric_chars</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>STRINGLIB_CHAR</name></type> <name>numeric_char</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>STRINGLIB_CHAR</name></type> <name>sign</name> <init>= <expr>'\0'</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>STRINGLIB_CHAR</name> *</type><name>p</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>n_digits</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>n_leading_chars</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>n_grouping_chars</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>n_prefix</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>STRINGLIB_CHAR</name> *</type><name>prefix</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>NumberFieldWidths</name></type> <name>spec</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>long</name></type> <name>x</name></decl>;</decl_stmt>
<if>if <condition>(<expr><name><name>format</name>-&gt;<name>precision</name></name> != -1</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>,
<argument><expr>"Precision not allowed in integer format specifier"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>done</name>;</goto>
}</block></then></if>
<if>if <condition>(<expr><name><name>format</name>-&gt;<name>type</name></name> == 'c'</expr>)</condition><then> <block>{
<if>if <condition>(<expr><name><name>format</name>-&gt;<name>sign</name></name> != '\0'</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>,
<argument><expr>"Sign not allowed with integer"
" format specifier 'c'"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>done</name>;</goto>
}</block></then></if>
<expr_stmt><expr><name>x</name> = <call><name>PyLong_AsLong</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>x</name> == -1 &amp;&amp; <call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then>
<goto>goto <name>done</name>;</goto></then></if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>Py_UNICODE_WIDE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if>if <condition>(<expr><name>x</name> &lt; 0 || <name>x</name> &gt; 0x10ffff</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_OverflowError</name></expr></argument>,
<argument><expr>"%c arg not in range(0x110000) "
"(wide Python build)"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>done</name>;</goto>
}</block></then></if>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<if>if <condition>(<expr><name>x</name> &lt; 0 || <name>x</name> &gt; 0xffff</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_OverflowError</name></expr></argument>,
<argument><expr>"%c arg not in range(0x10000) "
"(narrow Python build)"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>done</name>;</goto>
}</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><name>numeric_char</name> = (<name>STRINGLIB_CHAR</name>)<name>x</name></expr>;</expr_stmt>
<expr_stmt><expr><name>pnumeric_chars</name> = &amp;<name>numeric_char</name></expr>;</expr_stmt>
<expr_stmt><expr><name>n_digits</name> = 1</expr>;</expr_stmt>
}</block></then> <else>else <block>{
<decl_stmt><decl><type><name>int</name></type> <name>base</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>leading_chars_to_skip</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<switch>switch <condition>(<expr><name><name>format</name>-&gt;<name>type</name></name></expr>)</condition> <block>{
<case>case <expr>'b'</expr>:
<expr_stmt><expr><name>base</name> = 2</expr>;</expr_stmt>
<expr_stmt><expr><name>leading_chars_to_skip</name> = 2</expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr>'o'</expr>:
<expr_stmt><expr><name>base</name> = 8</expr>;</expr_stmt>
<expr_stmt><expr><name>leading_chars_to_skip</name> = 2</expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr>'x'</expr>:
</case><case>case <expr>'X'</expr>:
<expr_stmt><expr><name>base</name> = 16</expr>;</expr_stmt>
<expr_stmt><expr><name>leading_chars_to_skip</name> = 2</expr>;</expr_stmt>
<break>break;</break>
</case><default>default:
</default><case>case <expr>'d'</expr>:
</case><case>case <expr>'n'</expr>:
<expr_stmt><expr><name>base</name> = 10</expr>;</expr_stmt>
<break>break;</break>
</case>}</block></switch>
<if>if <condition>(<expr><name><name>format</name>-&gt;<name>alternate</name></name></expr>)</condition><then>
<expr_stmt><expr><name>n_prefix</name> = <name>leading_chars_to_skip</name></expr>;</expr_stmt></then></if>
<expr_stmt><expr><name>tmp</name> = <call><name>tostring</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><name>base</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>tmp</name> == <name>NULL</name></expr>)</condition><then>
<goto>goto <name>done</name>;</goto></then></if>
<expr_stmt><expr><name>pnumeric_chars</name> = <call><name>STRINGLIB_STR</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>n_digits</name> = <call><name>STRINGLIB_LEN</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>prefix</name> = <name>pnumeric_chars</name></expr>;</expr_stmt>
<expr_stmt><expr><name>sign</name> = <name><name>pnumeric_chars</name><index>[<expr>0</expr>]</index></name></expr>;</expr_stmt>
<if>if <condition>(<expr><name>sign</name> == '-'</expr>)</condition><then> <block>{
<expr_stmt><expr>++<name>prefix</name></expr>;</expr_stmt>
<expr_stmt><expr>++<name>leading_chars_to_skip</name></expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><name>n_digits</name> -= <name>leading_chars_to_skip</name></expr>;</expr_stmt>
<expr_stmt><expr><name>pnumeric_chars</name> += <name>leading_chars_to_skip</name></expr>;</expr_stmt>
}</block></else></if>
<if>if <condition>(<expr><name><name>format</name>-&gt;<name>type</name></name> == 'n'</expr>)</condition><then>
<expr_stmt><expr><call><name>STRINGLIB_GROUPING</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>n_digits</name></expr></argument>, <argument><expr><name>n_digits</name></expr></argument>,
<argument><expr>0</expr></argument>, <argument><expr>&amp;<name>n_grouping_chars</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<expr_stmt><expr><call><name>calc_number_widths</name><argument_list>(<argument><expr>&amp;<name>spec</name></expr></argument>, <argument><expr><name>sign</name></expr></argument>, <argument><expr><name>n_prefix</name></expr></argument>, <argument><expr><name>n_digits</name> + <name>n_grouping_chars</name></expr></argument>,
<argument><expr><name>format</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>result</name> = <call><name>STRINGLIB_NEW</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name><name>spec</name>.<name>n_total</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>result</name></expr>)</condition><then>
<goto>goto <name>done</name>;</goto></then></if>
<expr_stmt><expr><name>p</name> = <call><name>STRINGLIB_STR</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>n_leading_chars</name> = <name><name>spec</name>.<name>n_lpadding</name></name> + <name><name>spec</name>.<name>n_lsign</name></name> +
<name><name>spec</name>.<name>n_prefix</name></name> + <name><name>spec</name>.<name>n_spadding</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><name>p</name> + <name>n_leading_chars</name></expr></argument>,
<argument><expr><name>pnumeric_chars</name></expr></argument>,
<argument><expr><name>n_digits</name> * <sizeof>sizeof<argument_list>(<argument><expr><name>STRINGLIB_CHAR</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>format</name>-&gt;<name>type</name></name> == 'X'</expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>t</name></decl>;</decl_stmt>
<for>for (<init><expr><name>t</name> = 0</expr>;</init> <condition><expr><name>t</name> &lt; <name>n_digits</name></expr>;</condition> <incr><expr>++<name>t</name></expr></incr>)
<expr_stmt><expr><name><name>p</name><index>[<expr><name>t</name> + <name>n_leading_chars</name></expr>]</index></name> = <call><name>STRINGLIB_TOUPPER</name><argument_list>(<argument><expr><name><name>p</name><index>[<expr><name>t</name> + <name>n_leading_chars</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></for>
}</block></then></if>
<if>if <condition>(<expr><name>n_grouping_chars</name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>STRINGLIB_CHAR</name> *</type><name>pstart</name> <init>= <expr><name>p</name> + <name>n_leading_chars</name></expr></init></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>NDEBUG</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>int</name></type> <name>r</name> <init>=
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr><call><name>STRINGLIB_GROUPING</name><argument_list>(<argument><expr><name>pstart</name></expr></argument>, <argument><expr><name>n_digits</name></expr></argument>, <argument><expr><name>n_digits</name></expr></argument>,
<argument><expr><name><name>spec</name>.<name>n_total</name></name>+<name>n_grouping_chars</name>-<name>n_leading_chars</name></expr></argument>,
<argument><expr><name>NULL</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><call><name>fill_non_digits</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr>&amp;<name>spec</name></expr></argument>, <argument><expr><name>prefix</name></expr></argument>, <argument><expr><name>n_digits</name> + <name>n_grouping_chars</name></expr></argument>,
<argument><expr><name><name>format</name>-&gt;<name>fill_char</name></name> == '\0' ? ' ' : <name><name>format</name>-&gt;<name>fill_char</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>format</name>-&gt;<name>type</name></name> == 'X'</expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>t</name></decl>;</decl_stmt>
<for>for (<init><expr><name>t</name> = 0</expr>;</init> <condition><expr><name>t</name> &lt; <name>n_prefix</name></expr>;</condition> <incr><expr>++<name>t</name></expr></incr>)
<expr_stmt><expr><name><name>p</name><index>[<expr><name>t</name> + <name><name>spec</name>.<name>n_lpadding</name></name> + <name><name>spec</name>.<name>n_lsign</name></name></expr>]</index></name> =
<call><name>STRINGLIB_TOUPPER</name><argument_list>(<argument><expr><name><name>p</name><index>[<expr><name>t</name> + <name><name>spec</name>.<name>n_lpadding</name></name> + <name><name>spec</name>.<name>n_lsign</name></name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></for>
}</block></then></if>
<label><name>done</name>:</label>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>result</name></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FORMAT_FLOAT</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>STRINGLIB_IS_UNICODE</name></expr></cpp:if>
<function><type><specifier>static</specifier> <name>Py_ssize_t</name></type>
<name>strtounicode</name><parameter_list>(<param><decl><type><name>Py_UNICODE</name> *</type><name>buffer</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>charbuffer</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>register</name> <name>Py_ssize_t</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>len</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name>charbuffer</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<for>for (<init><expr><name>i</name> = <name>len</name> - 1</expr>;</init> <condition><expr><name>i</name> &gt;= 0</expr>;</condition> <incr><expr>--<name>i</name></expr></incr>)
<expr_stmt><expr><name><name>buffer</name><index>[<expr><name>i</name></expr>]</index></name> = (<name>Py_UNICODE</name>) <name><name>charbuffer</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt></for>
<return>return <expr><name>len</name></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FLOAT_FORMATBUFLEN</name></cpp:macro> <cpp:value>120</cpp:value></cpp:define>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>format_float_internal</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>value</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>InternalFormatSpec</name> *</type><name>format</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>char</name></type> <name><name>fmt</name><index>[<expr>20</expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name><name>charbuf</name><index>[<expr><name>FLOAT_FORMATBUFLEN</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>n_digits</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>double</name></type> <name>x</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>precision</name> <init>= <expr><name><name>format</name>-&gt;<name>precision</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>result</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>STRINGLIB_CHAR</name></type> <name>sign</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name>*</type> <name>trailing</name> <init>= <expr>""</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>STRINGLIB_CHAR</name> *</type><name>p</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>NumberFieldWidths</name></type> <name>spec</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>STRINGLIB_CHAR</name></type> <name>type</name> <init>= <expr><name><name>format</name>-&gt;<name>type</name></name></expr></init></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>STRINGLIB_IS_UNICODE</name></expr></cpp:if>
<decl_stmt><decl><type><name>Py_UNICODE</name></type> <name><name>unicodebuf</name><index>[<expr><name>FLOAT_FORMATBUFLEN</name></expr>]</index></name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<if>if <condition>(<expr><name><name>format</name>-&gt;<name>alternate</name></name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>,
<argument><expr>"Alternate form (#) not allowed in float format "
"specifier"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>done</name>;</goto>
}</block></then></if>
<if>if <condition>(<expr><name>type</name> == 'F'</expr>)</condition><then>
<expr_stmt><expr><name>type</name> = 'f'</expr>;</expr_stmt></then></if>
<expr_stmt><expr><name>x</name> = <call><name>PyFloat_AsDouble</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>x</name> == -1.0 &amp;&amp; <call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then>
<goto>goto <name>done</name>;</goto></then></if>
<if>if <condition>(<expr><name>type</name> == '%'</expr>)</condition><then> <block>{
<expr_stmt><expr><name>type</name> = 'f'</expr>;</expr_stmt>
<expr_stmt><expr><name>x</name> *= 100</expr>;</expr_stmt>
<expr_stmt><expr><name>trailing</name> = "%"</expr>;</expr_stmt>
}</block></then></if>
<if>if <condition>(<expr><name>precision</name> &lt; 0</expr>)</condition><then>
<expr_stmt><expr><name>precision</name> = 6</expr>;</expr_stmt></then></if>
<if>if <condition>(<expr><name>type</name> == 'f' &amp;&amp; (<call><name>fabs</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call> / 1e25) &gt;= 1e25</expr>)</condition><then>
<expr_stmt><expr><name>type</name> = 'g'</expr>;</expr_stmt></then></if>
<expr_stmt><expr><call><name>PyOS_snprintf</name><argument_list>(<argument><expr><name>fmt</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>fmt</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr>"%%.%" <name>PY_FORMAT_SIZE_T</name> "d%c"</expr></argument>, <argument><expr><name>precision</name></expr></argument>,
<argument><expr>(<name>char</name>)<name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyOS_ascii_formatd</name><argument_list>(<argument><expr><name>charbuf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>charbuf</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>fmt</name></expr></argument>, <argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>strcat</name><argument_list>(<argument><expr><name>charbuf</name></expr></argument>, <argument><expr><name>trailing</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>STRINGLIB_IS_UNICODE</name></expr></cpp:if>
<expr_stmt><expr><name>n_digits</name> = <call><name>strtounicode</name><argument_list>(<argument><expr><name>unicodebuf</name></expr></argument>, <argument><expr><name>charbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>p</name> = <name>unicodebuf</name></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<expr_stmt><expr><name>n_digits</name> = <call><name>strlen</name><argument_list>(<argument><expr><name>charbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>p</name> = <name>charbuf</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><name>sign</name> = <name><name>p</name><index>[<expr>0</expr>]</index></name></expr>;</expr_stmt>
<if>if <condition>(<expr><name>sign</name> == '-'</expr>)</condition><then> <block>{
<expr_stmt><expr>++<name>p</name></expr>;</expr_stmt>
<expr_stmt><expr>--<name>n_digits</name></expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><call><name>calc_number_widths</name><argument_list>(<argument><expr>&amp;<name>spec</name></expr></argument>, <argument><expr><name>sign</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>n_digits</name></expr></argument>, <argument><expr><name>format</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>result</name> = <call><name>STRINGLIB_NEW</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name><name>spec</name>.<name>n_total</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>result</name> == <name>NULL</name></expr>)</condition><then>
<goto>goto <name>done</name>;</goto></then></if>
<expr_stmt><expr><call><name>fill_non_digits</name><argument_list>(<argument><expr><call><name>STRINGLIB_STR</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>&amp;<name>spec</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>n_digits</name></expr></argument>,
<argument><expr><name><name>format</name>-&gt;<name>fill_char</name></name> == '\0' ? ' ' : <name><name>format</name>-&gt;<name>fill_char</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><call><name>STRINGLIB_STR</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call> +
(<name><name>spec</name>.<name>n_lpadding</name></name> + <name><name>spec</name>.<name>n_lsign</name></name> + <name><name>spec</name>.<name>n_spadding</name></name>)</expr></argument>,
<argument><expr><name>p</name></expr></argument>,
<argument><expr><name>n_digits</name> * <sizeof>sizeof<argument_list>(<argument><expr><name>STRINGLIB_CHAR</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<label><name>done</name>:</label>
<return>return <expr><name>result</name></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<function><type><name>PyObject</name> *</type>
<name>FORMAT_STRING</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>obj</name></decl></param>,
<param><decl><type><name>STRINGLIB_CHAR</name> *</type><name>format_spec</name></decl></param>,
<param><decl><type><name>Py_ssize_t</name></type> <name>format_spec_len</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>InternalFormatSpec</name></type> <name>format</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>result</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>format_spec_len</name> == 0</expr>)</condition><then> <block>{
<expr_stmt><expr><name>result</name> = <call><name>STRINGLIB_TOSTR</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>done</name>;</goto>
}</block></then></if>
<if>if <condition>(<expr>!<call><name>parse_internal_render_format_spec</name><argument_list>(<argument><expr><name>format_spec</name></expr></argument>, <argument><expr><name>format_spec_len</name></expr></argument>,
<argument><expr>&amp;<name>format</name></expr></argument>, <argument><expr>'s'</expr></argument>)</argument_list></call></expr>)</condition><then>
<goto>goto <name>done</name>;</goto></then></if>
<switch>switch <condition>(<expr><name><name>format</name>.<name>type</name></name></expr>)</condition> <block>{
<case>case <expr>'s'</expr>:
<expr_stmt><expr><name>result</name> = <call><name>format_string_internal</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr>&amp;<name>format</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</case><default>default:
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>STRINGLIB_IS_UNICODE</name></expr></cpp:if>
<if>if <condition>(<expr><name><name>format</name>.<name>type</name></name> &gt; 32 &amp;&amp; <name><name>format</name>.<name>type</name></name> &lt;128</expr>)</condition><then>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>, <argument><expr>"Unknown conversion type %c"</expr></argument>,
<argument><expr>(<name>char</name>)<name><name>format</name>.<name>type</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>STRINGLIB_IS_UNICODE</name></expr></cpp:if>
<else>else
<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>, <argument><expr>"Unknown conversion type '\\x%x'"</expr></argument>,
<argument><expr>(<name>unsigned</name> <name>int</name>)<name><name>format</name>.<name>type</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<goto>goto <name>done</name>;</goto>
</default>}</block></switch>
<label><name>done</name>:</label>
<return>return <expr><name>result</name></expr>;</return>
}</block></function>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>defined</name> <name>FORMAT_LONG</name> || <name>defined</name> <name>FORMAT_INT</name></expr></cpp:if>
<function><type><specifier>static</specifier> <name>PyObject</name>*</type>
<name>format_int_or_long</name><parameter_list>(<param><decl><type><name>PyObject</name>*</type> <name>obj</name></decl></param>,
<param><decl><type><name>STRINGLIB_CHAR</name> *</type><name>format_spec</name></decl></param>,
<param><decl><type><name>Py_ssize_t</name></type> <name>format_spec_len</name></decl></param>,
<param><decl><type><name>IntOrLongToString</name></type> <name>tostring</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>result</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>tmp</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>InternalFormatSpec</name></type> <name>format</name></decl>;</decl_stmt>
<if>if <condition>(<expr><name>format_spec_len</name> == 0</expr>)</condition><then> <block>{
<expr_stmt><expr><name>result</name> = <call><name>STRINGLIB_TOSTR</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>done</name>;</goto>
}</block></then></if>
<if>if <condition>(<expr>!<call><name>parse_internal_render_format_spec</name><argument_list>(<argument><expr><name>format_spec</name></expr></argument>,
<argument><expr><name>format_spec_len</name></expr></argument>,
<argument><expr>&amp;<name>format</name></expr></argument>, <argument><expr>'d'</expr></argument>)</argument_list></call></expr>)</condition><then>
<goto>goto <name>done</name>;</goto></then></if>
<switch>switch <condition>(<expr><name><name>format</name>.<name>type</name></name></expr>)</condition> <block>{
<case>case <expr>'b'</expr>:
</case><case>case <expr>'c'</expr>:
</case><case>case <expr>'d'</expr>:
</case><case>case <expr>'o'</expr>:
</case><case>case <expr>'x'</expr>:
</case><case>case <expr>'X'</expr>:
</case><case>case <expr>'n'</expr>:
<expr_stmt><expr><name>result</name> = <call><name>format_int_or_long_internal</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr>&amp;<name>format</name></expr></argument>, <argument><expr><name>tostring</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr>'e'</expr>:
</case><case>case <expr>'E'</expr>:
</case><case>case <expr>'f'</expr>:
</case><case>case <expr>'F'</expr>:
</case><case>case <expr>'g'</expr>:
</case><case>case <expr>'G'</expr>:
</case><case>case <expr>'%'</expr>:
<expr_stmt><expr><name>tmp</name> = <call><name>PyNumber_Float</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>tmp</name> == <name>NULL</name></expr>)</condition><then>
<goto>goto <name>done</name>;</goto></then></if>
<expr_stmt><expr><name>result</name> = <call><name>format_float_internal</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr>&amp;<name>format</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</case><default>default:
<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>, <argument><expr>"Unknown conversion type %c"</expr></argument>,
<argument><expr><name><name>format</name>.<name>type</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>done</name>;</goto>
</default>}</block></switch>
<label><name>done</name>:</label>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>result</name></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FORMAT_LONG</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PY_VERSION_HEX</name> &gt;= 0x03000000</expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>long_format</name></cpp:macro> <cpp:value>_PyLong_Format</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<function><type><specifier>static</specifier> <name>PyObject</name>*</type>
<name>long_format</name><parameter_list>(<param><decl><type><name>PyObject</name>*</type> <name>value</name></decl></param>, <param><decl><type><name>int</name></type> <name>base</name></decl></param>)</parameter_list> <block>{
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>PyLong_Check</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>_PyLong_Format</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><name>base</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<function><type><name>PyObject</name> *</type>
<name>FORMAT_LONG</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>obj</name></decl></param>,
<param><decl><type><name>STRINGLIB_CHAR</name> *</type><name>format_spec</name></decl></param>,
<param><decl><type><name>Py_ssize_t</name></type> <name>format_spec_len</name></decl></param>)</parameter_list> <block>{
<return>return <expr><call><name>format_int_or_long</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>format_spec</name></expr></argument>, <argument><expr><name>format_spec_len</name></expr></argument>,
<argument><expr><name>long_format</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FORMAT_INT</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function><type><specifier>static</specifier> <name>PyObject</name>*</type>
<name>int_format</name><parameter_list>(<param><decl><type><name>PyObject</name>*</type> <name>value</name></decl></param>, <param><decl><type><name>int</name></type> <name>base</name></decl></param>)</parameter_list> <block>{
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>PyInt_Check</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>_PyInt_Format</name><argument_list>(<argument><expr>(<name>PyIntObject</name>*)<name>value</name></expr></argument>, <argument><expr><name>base</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><name>PyObject</name> *</type>
<name>FORMAT_INT</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>obj</name></decl></param>,
<param><decl><type><name>STRINGLIB_CHAR</name> *</type><name>format_spec</name></decl></param>,
<param><decl><type><name>Py_ssize_t</name></type> <name>format_spec_len</name></decl></param>)</parameter_list> <block>{
<return>return <expr><call><name>format_int_or_long</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>format_spec</name></expr></argument>, <argument><expr><name>format_spec_len</name></expr></argument>,
<argument><expr><name>int_format</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FORMAT_FLOAT</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function><type><name>PyObject</name> *</type>
<name>FORMAT_FLOAT</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>obj</name></decl></param>,
<param><decl><type><name>STRINGLIB_CHAR</name> *</type><name>format_spec</name></decl></param>,
<param><decl><type><name>Py_ssize_t</name></type> <name>format_spec_len</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>result</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>InternalFormatSpec</name></type> <name>format</name></decl>;</decl_stmt>
<if>if <condition>(<expr><name>format_spec_len</name> == 0</expr>)</condition><then> <block>{
<expr_stmt><expr><name>result</name> = <call><name>STRINGLIB_TOSTR</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>done</name>;</goto>
}</block></then></if>
<if>if <condition>(<expr>!<call><name>parse_internal_render_format_spec</name><argument_list>(<argument><expr><name>format_spec</name></expr></argument>,
<argument><expr><name>format_spec_len</name></expr></argument>,
<argument><expr>&amp;<name>format</name></expr></argument>, <argument><expr>'\0'</expr></argument>)</argument_list></call></expr>)</condition><then>
<goto>goto <name>done</name>;</goto></then></if>
<switch>switch <condition>(<expr><name><name>format</name>.<name>type</name></name></expr>)</condition> <block>{
<case>case <expr>'\0'</expr>:
<expr_stmt><expr><name><name>format</name>.<name>type</name></name> = 'Z'</expr>;</expr_stmt>
</case><case>case <expr>'e'</expr>:
</case><case>case <expr>'E'</expr>:
</case><case>case <expr>'f'</expr>:
</case><case>case <expr>'F'</expr>:
</case><case>case <expr>'g'</expr>:
</case><case>case <expr>'G'</expr>:
</case><case>case <expr>'n'</expr>:
</case><case>case <expr>'%'</expr>:
<expr_stmt><expr><name>result</name> = <call><name>format_float_internal</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr>&amp;<name>format</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</case><default>default:
<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>, <argument><expr>"Unknown conversion type %c"</expr></argument>,
<argument><expr><name><name>format</name>.<name>type</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>done</name>;</goto>
</default>}</block></switch>
<label><name>done</name>:</label>
<return>return <expr><name>result</name></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</unit>
