<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C" filename="Objects/stringlib/transmogrify.h"><cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"bytes_methods.h"</cpp:file></cpp:include>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>STRINGLIB_MUTABLE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:error>#<cpp:directive>warning</cpp:directive> "STRINGLIB_MUTABLE not defined before #include, assuming 0"</cpp:error>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>STRINGLIB_MUTABLE</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>expandtabs__doc__</name></expr></argument>,
<argument><expr>"B.expandtabs([tabsize]) -&gt; copy of B\n\
\n\
Return a copy of B where all tab characters are expanded using spaces.\n\
If tabsize is not given, a tab size of 8 characters is assumed."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name>*</type>
<name>stringlib_expandtabs</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>e</name></decl>, *<decl><type ref="prev"/><name>p</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>q</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>, <decl><type ref="prev"/><name>old_j</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>u</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>tabsize</name> <init>= <expr>8</expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"|i:expandtabs"</expr></argument>, <argument><expr>&amp;<name>tabsize</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>i</name> = <name>j</name> = <name>old_j</name> = 0</expr>;</expr_stmt>
<expr_stmt><expr><name>e</name> = <call><name>STRINGLIB_STR</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call> + <call><name>STRINGLIB_LEN</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for (<init><expr><name>p</name> = <call><name>STRINGLIB_STR</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</init> <condition><expr><name>p</name> &lt; <name>e</name></expr>;</condition> <incr><expr><name>p</name>++</expr></incr>)
<if>if <condition>(<expr>*<name>p</name> == '\t'</expr>)</condition><then> <block>{
<if>if <condition>(<expr><name>tabsize</name> &gt; 0</expr>)</condition><then> <block>{
<expr_stmt><expr><name>j</name> += <name>tabsize</name> - (<name>j</name> % <name>tabsize</name>)</expr>;</expr_stmt>
<if>if <condition>(<expr><name>old_j</name> &gt; <name>j</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_OverflowError</name></expr></argument>,
<argument><expr>"result is too long"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>old_j</name> = <name>j</name></expr>;</expr_stmt>
}</block></then></if>
}</block></then> <else>else <block>{
<expr_stmt><expr><name>j</name>++</expr>;</expr_stmt>
<if>if <condition>(<expr>*<name>p</name> == '\n' || *<name>p</name> == '\r'</expr>)</condition><then> <block>{
<expr_stmt><expr><name>i</name> += <name>j</name></expr>;</expr_stmt>
<expr_stmt><expr><name>old_j</name> = <name>j</name> = 0</expr>;</expr_stmt>
<if>if <condition>(<expr><name>i</name> &lt; 0</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_OverflowError</name></expr></argument>,
<argument><expr>"result is too long"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
}</block></then></if>
}</block></else></if></for>
<if>if <condition>(<expr>(<name>i</name> + <name>j</name>) &lt; 0</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_OverflowError</name></expr></argument>, <argument><expr>"result is too long"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>u</name> = <call><name>STRINGLIB_NEW</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>i</name> + <name>j</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>u</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>j</name> = 0</expr>;</expr_stmt>
<expr_stmt><expr><name>q</name> = <call><name>STRINGLIB_STR</name><argument_list>(<argument><expr><name>u</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for (<init><expr><name>p</name> = <call><name>STRINGLIB_STR</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</init> <condition><expr><name>p</name> &lt; <name>e</name></expr>;</condition> <incr><expr><name>p</name>++</expr></incr>)
<if>if <condition>(<expr>*<name>p</name> == '\t'</expr>)</condition><then> <block>{
<if>if <condition>(<expr><name>tabsize</name> &gt; 0</expr>)</condition><then> <block>{
<expr_stmt><expr><name>i</name> = <name>tabsize</name> - (<name>j</name> % <name>tabsize</name>)</expr>;</expr_stmt>
<expr_stmt><expr><name>j</name> += <name>i</name></expr>;</expr_stmt>
<while>while <condition>(<expr><name>i</name>--</expr>)</condition>
<expr_stmt><expr>*<name>q</name>++ = ' '</expr>;</expr_stmt></while>
}</block></then></if>
}</block></then> <else>else <block>{
<expr_stmt><expr><name>j</name>++</expr>;</expr_stmt>
<expr_stmt><expr>*<name>q</name>++ = *<name>p</name></expr>;</expr_stmt>
<if>if <condition>(<expr>*<name>p</name> == '\n' || *<name>p</name> == '\r'</expr>)</condition><then>
<expr_stmt><expr><name>j</name> = 0</expr>;</expr_stmt></then></if>
}</block></else></if></for>
<return>return <expr><name>u</name></expr>;</return>
}</block></function>
<macro><name>Py_LOCAL_INLINE</name><argument_list>(<argument>PyObject *</argument>)</argument_list></macro>
<macro><name>pad</name><argument_list>(<argument>PyObject *self</argument>, <argument>Py_ssize_t left</argument>, <argument>Py_ssize_t right</argument>, <argument>char fill</argument>)</argument_list></macro> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>u</name></decl>;</decl_stmt>
<if>if <condition>(<expr><name>left</name> &lt; 0</expr>)</condition><then>
<expr_stmt><expr><name>left</name> = 0</expr>;</expr_stmt></then></if>
<if>if <condition>(<expr><name>right</name> &lt; 0</expr>)</condition><then>
<expr_stmt><expr><name>right</name> = 0</expr>;</expr_stmt></then></if>
<if>if <condition>(<expr><name>left</name> == 0 &amp;&amp; <name>right</name> == 0 &amp;&amp; <call><name>STRINGLIB_CHECK_EXACT</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>STRINGLIB_MUTABLE</name></expr></cpp:if>
<return>return <expr><call><name>STRINGLIB_NEW</name><argument_list>(<argument><expr><call><name>STRINGLIB_STR</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>STRINGLIB_LEN</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>(<name>PyObject</name> *)<name>self</name></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></then></if>
<expr_stmt><expr><name>u</name> = <call><name>STRINGLIB_NEW</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>,
<argument><expr><name>left</name> + <call><name>STRINGLIB_LEN</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call> + <name>right</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>u</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr><name>left</name></expr>)</condition><then>
<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><call><name>STRINGLIB_STR</name><argument_list>(<argument><expr><name>u</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>fill</name></expr></argument>, <argument><expr><name>left</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<expr_stmt><expr><call><name>Py_MEMCPY</name><argument_list>(<argument><expr><call><name>STRINGLIB_STR</name><argument_list>(<argument><expr><name>u</name></expr></argument>)</argument_list></call> + <name>left</name></expr></argument>,
<argument><expr><call><name>STRINGLIB_STR</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name>STRINGLIB_LEN</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>right</name></expr>)</condition><then>
<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><call><name>STRINGLIB_STR</name><argument_list>(<argument><expr><name>u</name></expr></argument>)</argument_list></call> + <name>left</name> + <call><name>STRINGLIB_LEN</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>fill</name></expr></argument>, <argument><expr><name>right</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
}</block></then></if>
<return>return <expr><name>u</name></expr>;</return>
}</block>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>ljust__doc__</name></expr></argument>,
<argument><expr>"B.ljust(width[, fillchar]) -&gt; copy of B\n"
"\n"
"Return B left justified in a string of length width. Padding is\n"
"done using the specified fill character (default is a space)."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>stringlib_ljust</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>width</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name>fillchar</name> <init>= <expr>' '</expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"n|c:ljust"</expr></argument>, <argument><expr>&amp;<name>width</name></expr></argument>, <argument><expr>&amp;<name>fillchar</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<if>if <condition>(<expr><call><name>STRINGLIB_LEN</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call> &gt;= <name>width</name> &amp;&amp; <call><name>STRINGLIB_CHECK_EXACT</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>STRINGLIB_MUTABLE</name></expr></cpp:if>
<return>return <expr><call><name>STRINGLIB_NEW</name><argument_list>(<argument><expr><call><name>STRINGLIB_STR</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>STRINGLIB_LEN</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>(<name>PyObject</name>*) <name>self</name></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></then></if>
<return>return <expr><call><name>pad</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>width</name> - <call><name>STRINGLIB_LEN</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>fillchar</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>rjust__doc__</name></expr></argument>,
<argument><expr>"B.rjust(width[, fillchar]) -&gt; copy of B\n"
"\n"
"Return B right justified in a string of length width. Padding is\n"
"done using the specified fill character (default is a space)"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>stringlib_rjust</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>width</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name>fillchar</name> <init>= <expr>' '</expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"n|c:rjust"</expr></argument>, <argument><expr>&amp;<name>width</name></expr></argument>, <argument><expr>&amp;<name>fillchar</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<if>if <condition>(<expr><call><name>STRINGLIB_LEN</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call> &gt;= <name>width</name> &amp;&amp; <call><name>STRINGLIB_CHECK_EXACT</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>STRINGLIB_MUTABLE</name></expr></cpp:if>
<return>return <expr><call><name>STRINGLIB_NEW</name><argument_list>(<argument><expr><call><name>STRINGLIB_STR</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>STRINGLIB_LEN</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>(<name>PyObject</name>*) <name>self</name></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></then></if>
<return>return <expr><call><name>pad</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>width</name> - <call><name>STRINGLIB_LEN</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>fillchar</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>center__doc__</name></expr></argument>,
<argument><expr>"B.center(width[, fillchar]) -&gt; copy of B\n"
"\n"
"Return B centered in a string of length width. Padding is\n"
"done using the specified fill character (default is a space)."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>stringlib_center</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>marg</name></decl>, <decl><type ref="prev"/><name>left</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>width</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name>fillchar</name> <init>= <expr>' '</expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"n|c:center"</expr></argument>, <argument><expr>&amp;<name>width</name></expr></argument>, <argument><expr>&amp;<name>fillchar</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<if>if <condition>(<expr><call><name>STRINGLIB_LEN</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call> &gt;= <name>width</name> &amp;&amp; <call><name>STRINGLIB_CHECK_EXACT</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>STRINGLIB_MUTABLE</name></expr></cpp:if>
<return>return <expr><call><name>STRINGLIB_NEW</name><argument_list>(<argument><expr><call><name>STRINGLIB_STR</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>STRINGLIB_LEN</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>(<name>PyObject</name>*) <name>self</name></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></then></if>
<expr_stmt><expr><name>marg</name> = <name>width</name> - <call><name>STRINGLIB_LEN</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>left</name> = <name>marg</name> / 2 + (<name>marg</name> &amp; <name>width</name> &amp; 1)</expr>;</expr_stmt>
<return>return <expr><call><name>pad</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>left</name></expr></argument>, <argument><expr><name>marg</name> - <name>left</name></expr></argument>, <argument><expr><name>fillchar</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>zfill__doc__</name></expr></argument>,
<argument><expr>"B.zfill(width) -&gt; copy of B\n"
"\n"
"Pad a numeric string B with zeros on the left, to fill a field\n"
"of the specified width. B is never truncated."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>stringlib_zfill</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>fill</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>s</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>p</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>width</name></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"n:zfill"</expr></argument>, <argument><expr>&amp;<name>width</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<if>if <condition>(<expr><call><name>STRINGLIB_LEN</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call> &gt;= <name>width</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr><call><name>STRINGLIB_CHECK_EXACT</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>STRINGLIB_MUTABLE</name></expr></cpp:if>
<return>return <expr><call><name>STRINGLIB_NEW</name><argument_list>(<argument><expr><call><name>STRINGLIB_STR</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>STRINGLIB_LEN</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>(<name>PyObject</name>*) <name>self</name></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></then> <else>else
<return>return <expr><call><name>STRINGLIB_NEW</name><argument_list>(
<argument><expr><call><name>STRINGLIB_STR</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name>STRINGLIB_LEN</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></argument>
)</argument_list></call></expr>;</return></else></if>
}</block></then></if>
<expr_stmt><expr><name>fill</name> = <name>width</name> - <call><name>STRINGLIB_LEN</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>s</name> = <call><name>pad</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>fill</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>'0'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>s</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>p</name> = <call><name>STRINGLIB_STR</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>p</name><index>[<expr><name>fill</name></expr>]</index></name> == '+' || <name><name>p</name><index>[<expr><name>fill</name></expr>]</index></name> == '-'</expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>p</name><index>[<expr>0</expr>]</index></name> = <name><name>p</name><index>[<expr><name>fill</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>p</name><index>[<expr><name>fill</name></expr>]</index></name> = '0'</expr>;</expr_stmt>
}</block></then></if>
<return>return <expr>(<name>PyObject</name>*) <name>s</name></expr>;</return>
}</block></function>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>_STRINGLIB_SPLIT_APPEND</name><parameter_list>(<param><type><name>data</name></type></param>, <param><type><name>left</name></type></param>, <param><type><name>right</name></type></param>)</parameter_list></cpp:macro> <cpp:value>str = STRINGLIB_NEW((data) + (left), (right) - (left)); if (str == NULL) goto onError; if (PyList_Append(list, str)) { Py_DECREF(str); goto onError; } else Py_DECREF(str);</cpp:value></cpp:define>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>splitlines__doc__</name></expr></argument>,
<argument><expr>"B.splitlines([keepends]) -&gt; list of lines\n\
\n\
Return a list of the lines in B, breaking at line boundaries.\n\
Line breaks are not included in the resulting list unless keepends\n\
is given and true."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name>*</type>
<name>stringlib_splitlines</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>register</name> <name>Py_ssize_t</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>register</name> <name>Py_ssize_t</name></type> <name>j</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>len</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>keepends</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>list</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>str</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>data</name></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"|i:splitlines"</expr></argument>, <argument><expr>&amp;<name>keepends</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>data</name> = <call><name>STRINGLIB_STR</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>len</name> = <call><name>STRINGLIB_LEN</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>list</name> = <call><name>PyList_New</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>list</name></expr>)</condition><then>
<goto>goto <name>onError</name>;</goto></then></if>
<for>for (<init><expr><name>i</name> = <name>j</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>len</name></expr>;</condition> <incr/>) <block>{
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>eol</name></decl>;</decl_stmt>
<while>while <condition>(<expr><name>i</name> &lt; <name>len</name> &amp;&amp; <name><name>data</name><index>[<expr><name>i</name></expr>]</index></name> != '\n' &amp;&amp; <name><name>data</name><index>[<expr><name>i</name></expr>]</index></name> != '\r'</expr>)</condition>
<expr_stmt><expr><name>i</name>++</expr>;</expr_stmt></while>
<expr_stmt><expr><name>eol</name> = <name>i</name></expr>;</expr_stmt>
<if>if <condition>(<expr><name>i</name> &lt; <name>len</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr><name><name>data</name><index>[<expr><name>i</name></expr>]</index></name> == '\r' &amp;&amp; <name>i</name> + 1 &lt; <name>len</name> &amp;&amp;
<name><name>data</name><index>[<expr><name>i</name>+1</expr>]</index></name> == '\n'</expr>)</condition><then>
<expr_stmt><expr><name>i</name> += 2</expr>;</expr_stmt></then>
<else>else
<expr_stmt><expr><name>i</name>++</expr>;</expr_stmt></else></if>
<if>if <condition>(<expr><name>keepends</name></expr>)</condition><then>
<expr_stmt><expr><name>eol</name> = <name>i</name></expr>;</expr_stmt></then></if>
}</block></then></if>
<expr_stmt><expr><call><name>_STRINGLIB_SPLIT_APPEND</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><name>eol</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>j</name> = <name>i</name></expr>;</expr_stmt>
}</block></for>
<if>if <condition>(<expr><name>j</name> &lt; <name>len</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>_STRINGLIB_SPLIT_APPEND</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<return>return <expr><name>list</name></expr>;</return>
<label><name>onError</name>:</label>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></function>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>_STRINGLIB_SPLIT_APPEND</name></cpp:undef>
</unit>
