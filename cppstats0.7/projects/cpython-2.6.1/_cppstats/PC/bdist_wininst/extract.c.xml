<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C" filename="projects/cpython-2.6.1/_cppstats/PC/bdist_wininst/extract.c"><cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;windows.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"zlib.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdio.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdarg.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"archive.h"</cpp:file></cpp:include>
<function><type><specifier>static</specifier> <name>void</name></type> <name>normpath</name><parameter_list>(<param><decl><type><name>char</name> *</type><name>path</name></decl></param>)</parameter_list> <block>{
<while>while <condition>(<expr><name>path</name> &amp;&amp; *<name>path</name></expr>)</condition> <block>{
<if>if <condition>(<expr>*<name>path</name> == '/'</expr>)</condition><then>
<expr_stmt><expr>*<name>path</name> = '\\'</expr>;</expr_stmt></then></if>
<expr_stmt><expr>++<name>path</name></expr>;</expr_stmt>
}</block></while>
}</block></function>
<function><type><name>BOOL</name></type> <name>ensure_directory</name><parameter_list>(<param><decl><type><name>char</name> *</type><name>pathname</name></decl></param>, <param><decl><type><name>char</name> *</type><name>new_part</name></decl></param>, <param><decl><type><name>NOTIFYPROC</name></type> <name>notify</name></decl></param>)</parameter_list> <block>{
<while>while <condition>(<expr><name>new_part</name> &amp;&amp; *<name>new_part</name> &amp;&amp; (<name>new_part</name> = <call><name>strchr</name><argument_list>(<argument><expr><name>new_part</name></expr></argument>, <argument><expr>'\\'</expr></argument>)</argument_list></call>)</expr>)</condition> <block>{
<decl_stmt><decl><type><name>DWORD</name></type> <name>attr</name></decl>;</decl_stmt>
<expr_stmt><expr>*<name>new_part</name> = '\0'</expr>;</expr_stmt>
<expr_stmt><expr><name>attr</name> = <call><name>GetFileAttributes</name><argument_list>(<argument><expr><name>pathname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>attr</name> == -1</expr>)</condition><then> <block>{
<if>if <condition>(<expr>!<call><name>CreateDirectory</name><argument_list>(<argument><expr><name>pathname</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call> &amp;&amp; <name>notify</name></expr>)</condition><then>
<expr_stmt><expr><call><name>notify</name><argument_list>(<argument><expr><name>SYSTEM_ERROR</name></expr></argument>,
<argument><expr>"CreateDirectory (%s)"</expr></argument>, <argument><expr><name>pathname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
<else>else
<expr_stmt><expr><call><name>notify</name><argument_list>(<argument><expr><name>DIR_CREATED</name></expr></argument>, <argument><expr><name>pathname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
}</block></then></if>
<if>if <condition>(<expr><name>attr</name> &amp; <name>FILE_ATTRIBUTE_DIRECTORY</name></expr>)</condition><then> <block>{
<empty_stmt>;</empty_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr><call><name>SetLastError</name><argument_list>(<argument><expr>183</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>notify</name></expr>)</condition><then>
<expr_stmt><expr><call><name>notify</name><argument_list>(<argument><expr><name>SYSTEM_ERROR</name></expr></argument>,
<argument><expr>"CreateDirectory (%s)"</expr></argument>, <argument><expr><name>pathname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
}</block></else></if>
<expr_stmt><expr>*<name>new_part</name> = '\\'</expr>;</expr_stmt>
<expr_stmt><expr>++<name>new_part</name></expr>;</expr_stmt>
}</block></while>
<return>return <expr><name>TRUE</name></expr>;</return>
}</block></function>
<function><type><name>char</name> *</type><name>map_new_file</name><parameter_list>(<param><decl><type><name>DWORD</name></type> <name>flags</name></decl></param>, <param><decl><type><name>char</name> *</type><name>filename</name></decl></param>,
<param><decl><type><name>char</name> *</type><name>pathname_part</name></decl></param>, <param><decl><type><name>int</name></type> <name>size</name></decl></param>,
<param><decl><type><name>WORD</name></type> <name>wFatDate</name></decl></param>, <param><decl><type><name>WORD</name></type> <name>wFatTime</name></decl></param>,
<param><decl><type><name>NOTIFYPROC</name></type> <name>notify</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>HANDLE</name></type> <name>hFile</name></decl>, <decl><type ref="prev"/><name>hFileMapping</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>dst</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>FILETIME</name></type> <name>ft</name></decl>;</decl_stmt>
<label><name>try_again</name>:</label>
<if>if <condition>(<expr>!<name>flags</name></expr>)</condition><then>
<expr_stmt><expr><name>flags</name> = <name>CREATE_NEW</name></expr>;</expr_stmt></then></if>
<expr_stmt><expr><name>hFile</name> = <call><name>CreateFile</name><argument_list>(<argument><expr><name>filename</name></expr></argument>,
<argument><expr><name>GENERIC_WRITE</name> | <name>GENERIC_READ</name></expr></argument>,
<argument><expr>0</expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
<argument><expr><name>flags</name></expr></argument>,
<argument><expr><name>FILE_ATTRIBUTE_NORMAL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>hFile</name> == <name>INVALID_HANDLE_VALUE</name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>DWORD</name></type> <name>x</name> <init>= <expr><call><name>GetLastError</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<switch>switch <condition>(<expr><name>x</name></expr>)</condition> <block>{
<case>case <expr><name>ERROR_FILE_EXISTS</name></expr>:
<if>if <condition>(<expr><name>notify</name> &amp;&amp; <call><name>notify</name><argument_list>(<argument><expr><name>CAN_OVERWRITE</name></expr></argument>, <argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<expr_stmt><expr><name>hFile</name> = <call><name>CreateFile</name><argument_list>(<argument><expr><name>filename</name></expr></argument>,
<argument><expr><name>GENERIC_WRITE</name>|<name>GENERIC_READ</name></expr></argument>,
<argument><expr>0</expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
<argument><expr><name>CREATE_ALWAYS</name></expr></argument>,
<argument><expr><name>FILE_ATTRIBUTE_NORMAL</name></expr></argument>,
<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
<else>else <block>{
<if>if <condition>(<expr><name>notify</name></expr>)</condition><then>
<expr_stmt><expr><call><name>notify</name><argument_list>(<argument><expr><name>FILE_OVERWRITTEN</name></expr></argument>, <argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></else></if>
<break>break;</break>
</case><case>case <expr><name>ERROR_PATH_NOT_FOUND</name></expr>:
<if>if <condition>(<expr><call><name>ensure_directory</name><argument_list>(<argument><expr><name>filename</name></expr></argument>, <argument><expr><name>pathname_part</name></expr></argument>, <argument><expr><name>notify</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<goto>goto <name>try_again</name>;</goto></then>
<else>else
<return>return <expr><name>FALSE</name></expr>;</return></else></if>
<break>break;</break>
</case><default>default:
<expr_stmt><expr><call><name>SetLastError</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</default>}</block></switch>
}</block></then></if>
<if>if <condition>(<expr><name>hFile</name> == <name>INVALID_HANDLE_VALUE</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr><name>notify</name></expr>)</condition><then>
<expr_stmt><expr><call><name>notify</name> <argument_list>(<argument><expr><name>SYSTEM_ERROR</name></expr></argument>, <argument><expr>"CreateFile (%s)"</expr></argument>, <argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<if>if <condition>(<expr><name>notify</name></expr>)</condition><then>
<expr_stmt><expr><call><name>notify</name><argument_list>(<argument><expr><name>FILE_CREATED</name></expr></argument>, <argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<expr_stmt><expr><call><name>DosDateTimeToFileTime</name><argument_list>(<argument><expr><name>wFatDate</name></expr></argument>, <argument><expr><name>wFatTime</name></expr></argument>, <argument><expr>&amp;<name>ft</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SetFileTime</name><argument_list>(<argument><expr><name>hFile</name></expr></argument>, <argument><expr>&amp;<name>ft</name></expr></argument>, <argument><expr>&amp;<name>ft</name></expr></argument>, <argument><expr>&amp;<name>ft</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>size</name> == 0</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>CloseHandle</name><argument_list>(<argument><expr><name>hFile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>hFileMapping</name> = <call><name>CreateFileMapping</name><argument_list>(<argument><expr><name>hFile</name></expr></argument>,
<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>PAGE_READWRITE</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>CloseHandle</name><argument_list>(<argument><expr><name>hFile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>hFileMapping</name> == <name>INVALID_HANDLE_VALUE</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr><name>notify</name></expr>)</condition><then>
<expr_stmt><expr><call><name>notify</name><argument_list>(<argument><expr><name>SYSTEM_ERROR</name></expr></argument>,
<argument><expr>"CreateFileMapping (%s)"</expr></argument>, <argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>dst</name> = <call><name>MapViewOfFile</name><argument_list>(<argument><expr><name>hFileMapping</name></expr></argument>,
<argument><expr><name>FILE_MAP_WRITE</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>CloseHandle</name><argument_list>(<argument><expr><name>hFileMapping</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>dst</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr><name>notify</name></expr>)</condition><then>
<expr_stmt><expr><call><name>notify</name><argument_list>(<argument><expr><name>SYSTEM_ERROR</name></expr></argument>, <argument><expr>"MapViewOfFile (%s)"</expr></argument>, <argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<return>return <expr><name>dst</name></expr>;</return>
}</block></function>
<function><type><name>BOOL</name></type>
<name>extract_file</name><parameter_list>(<param><decl><type><name>char</name> *</type><name>dst</name></decl></param>, <param><decl><type><name>char</name> *</type><name>src</name></decl></param>, <param><decl><type><name>int</name></type> <name>method</name></decl></param>, <param><decl><type><name>int</name></type> <name>comp_size</name></decl></param>,
<param><decl><type><name>int</name></type> <name>uncomp_size</name></decl></param>, <param><decl><type><name>NOTIFYPROC</name></type> <name>notify</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>z_stream</name></type> <name>zstream</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>result</name></decl>;</decl_stmt>
<if>if <condition>(<expr><name>method</name> == <name>Z_DEFLATED</name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>x</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr>&amp;<name>zstream</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>zstream</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>zstream</name>.<name>next_in</name></name> = <name>src</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>zstream</name>.<name>avail_in</name></name> = <name>comp_size</name>+1</expr>;</expr_stmt>
<expr_stmt><expr><name><name>zstream</name>.<name>next_out</name></name> = <name>dst</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>zstream</name>.<name>avail_out</name></name> = <name>uncomp_size</name></expr>;</expr_stmt>
<expr_stmt><expr><name>result</name> = <name>TRUE</name></expr>;</expr_stmt>
<if>if <condition>(<expr><name>Z_OK</name> != (<name>x</name> = <call><name>inflateInit2</name><argument_list>(<argument><expr>&amp;<name>zstream</name></expr></argument>, <argument><expr>-15</expr></argument>)</argument_list></call>)</expr>)</condition><then> <block>{
<if>if <condition>(<expr><name>notify</name></expr>)</condition><then>
<expr_stmt><expr><call><name>notify</name><argument_list>(<argument><expr><name>ZLIB_ERROR</name></expr></argument>,
<argument><expr>"inflateInit2 returns %d"</expr></argument>, <argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<expr_stmt><expr><name>result</name> = <name>FALSE</name></expr>;</expr_stmt>
<goto>goto <name>cleanup</name>;</goto>
}</block></then></if>
<if>if <condition>(<expr><name>Z_STREAM_END</name> != (<name>x</name> = <call><name>inflate</name><argument_list>(<argument><expr>&amp;<name>zstream</name></expr></argument>, <argument><expr><name>Z_FINISH</name></expr></argument>)</argument_list></call>)</expr>)</condition><then> <block>{
<if>if <condition>(<expr><name>notify</name></expr>)</condition><then>
<expr_stmt><expr><call><name>notify</name><argument_list>(<argument><expr><name>ZLIB_ERROR</name></expr></argument>,
<argument><expr>"inflate returns %d"</expr></argument>, <argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<expr_stmt><expr><name>result</name> = <name>FALSE</name></expr>;</expr_stmt>
}</block></then></if>
<label><name>cleanup</name>:</label>
<if>if <condition>(<expr><name>Z_OK</name> != (<name>x</name> = <call><name>inflateEnd</name><argument_list>(<argument><expr>&amp;<name>zstream</name></expr></argument>)</argument_list></call>)</expr>)</condition><then> <block>{
<if>if <condition>(<expr><name>notify</name></expr>)</condition><then>
<expr_stmt><expr><call><name>notify</name> <argument_list>(<argument><expr><name>ZLIB_ERROR</name></expr></argument>,
<argument><expr>"inflateEnd returns %d"</expr></argument>, <argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<expr_stmt><expr><name>result</name> = <name>FALSE</name></expr>;</expr_stmt>
}</block></then></if>
}</block></then> <else>else <if>if <condition>(<expr><name>method</name> == 0</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>dst</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>uncomp_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>result</name> = <name>TRUE</name></expr>;</expr_stmt>
}</block></then> <else>else
<expr_stmt><expr><name>result</name> = <name>FALSE</name></expr>;</expr_stmt></else></if></else></if>
<expr_stmt><expr><call><name>UnmapViewOfFile</name><argument_list>(<argument><expr><name>dst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>result</name></expr>;</return>
}</block></function>
<function><type><name>BOOL</name></type>
<name>unzip_archive</name><parameter_list>(<param><decl><type><name>SCHEME</name> *</type><name>scheme</name></decl></param>, <param><decl><type><name>char</name> *</type><name>dirname</name></decl></param>, <param><decl><type><name>char</name> *</type><name>data</name></decl></param>, <param><decl><type><name>DWORD</name></type> <name>size</name></decl></param>,
<param><decl><type><name>NOTIFYPROC</name></type> <name>notify</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name><name>pathname</name><index>[<expr><name>MAX_PATH</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>new_part</name></decl>;</decl_stmt>
<decl_stmt><decl><type>struct <name>eof_cdir</name> *</type><name>pe</name> <init>= <expr>(struct <name>eof_cdir</name> *)&amp;<name><name>data</name><index>[<expr><name>size</name> - <sizeof>sizeof
<argument_list>(<argument>struct <argument><expr><name>eof_cdir</name></expr></argument></argument>)</argument_list></sizeof></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>arc_start</name> <init>= <expr><name>size</name> - <sizeof>sizeof <argument_list>(<argument>struct <expr><name>eof_cdir</name></expr></argument>)</argument_list></sizeof> - <name><name>pe</name>-&gt;<name>nBytesCDir</name></name> -
<name><name>pe</name>-&gt;<name>ofsCDir</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>pos</name> <init>= <expr><name>arc_start</name> + <name><name>pe</name>-&gt;<name>ofsCDir</name></name></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name><name>pe</name>-&gt;<name>tag</name></name> != 0x06054b50</expr>)</condition><then>
<return>return <expr><name>FALSE</name></expr>;</return></then></if>
<for>for (<init><expr><name>n</name> = 0</expr>;</init> <condition><expr><name>n</name> &lt; <name><name>pe</name>-&gt;<name>nTotalCDir</name></name></expr>;</condition> <incr><expr>++<name>n</name></expr></incr>) <block>{
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>fname</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>pcomp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>dst</name></decl>;</decl_stmt>
<decl_stmt><decl><type>struct <name>cdir</name> *</type><name>pcdir</name></decl>;</decl_stmt>
<decl_stmt><decl><type>struct <name>fhdr</name> *</type><name>pfhdr</name></decl>;</decl_stmt>
<expr_stmt><expr><name>pcdir</name> = (struct <name>cdir</name> *)&amp;<name><name>data</name><index>[<expr><name>pos</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name>pfhdr</name> = (struct <name>fhdr</name> *)&amp;<name><name>data</name><index>[<expr><name><name>pcdir</name>-&gt;<name>ofs_local_header</name></name> +
<name>arc_start</name></expr>]</index></name></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>pcdir</name>-&gt;<name>tag</name></name> != 0x02014b50</expr>)</condition><then>
<return>return <expr><name>FALSE</name></expr>;</return></then></if>
<if>if <condition>(<expr><name><name>pfhdr</name>-&gt;<name>tag</name></name> != 0x04034b50</expr>)</condition><then>
<return>return <expr><name>FALSE</name></expr>;</return></then></if>
<expr_stmt><expr><name>pos</name> += <sizeof>sizeof<argument_list>(<argument>struct <expr><name>cdir</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
<expr_stmt><expr><name>fname</name> = (<name>char</name> *)&amp;<name><name>data</name><index>[<expr><name>pos</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name>pos</name> += <name><name>pcdir</name>-&gt;<name>fname_length</name></name> + <name><name>pcdir</name>-&gt;<name>extra_length</name></name> +
<name><name>pcdir</name>-&gt;<name>comment_length</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>pcomp</name> = &amp;<name><name>data</name><index>[<expr><name><name>pcdir</name>-&gt;<name>ofs_local_header</name></name>
+ <sizeof>sizeof<argument_list>(<argument>struct <argument><expr><name>fhdr</name></expr></argument></argument>)</argument_list></sizeof>
+ <name>arc_start</name>
+ <name><name>pfhdr</name>-&gt;<name>fname_length</name></name>
+ <name><name>pfhdr</name>-&gt;<name>extra_length</name></name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>pathname</name></expr></argument>, <argument><expr><name>dirname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>pathname</name><index>[<expr><call><name>strlen</name><argument_list>(<argument><expr><name>pathname</name></expr></argument>)</argument_list></call>-1</expr>]</index></name> != '\\'</expr>)</condition><then>
<expr_stmt><expr><call><name>strcat</name><argument_list>(<argument><expr><name>pathname</name></expr></argument>, <argument><expr>"\\"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<expr_stmt><expr><name>new_part</name> = &amp;<name><name>pathname</name><index>[<expr><call><name>lstrlen</name><argument_list>(<argument><expr><name>pathname</name></expr></argument>)</argument_list></call></expr>]</index></name></expr>;</expr_stmt>
<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name><name>scheme</name><index>[<expr><name>i</name></expr>]</index></name>.<name>name</name></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>) <block>{
<if>if <condition>(<expr>0 == <call><name>strnicmp</name><argument_list>(<argument><expr><name><name>scheme</name><index>[<expr><name>i</name></expr>]</index></name>.<name>name</name></expr></argument>, <argument><expr><name>fname</name></expr></argument>,
<argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name><name>scheme</name><index>[<expr><name>i</name></expr>]</index></name>.<name>name</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>char</name> *</type><name>rest</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>len</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>namelen</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name><name>scheme</name><index>[<expr><name>i</name></expr>]</index></name>.<name>name</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>strcat</name><argument_list>(<argument><expr><name>pathname</name></expr></argument>, <argument><expr><name><name>scheme</name><index>[<expr><name>i</name></expr>]</index></name>.<name>prefix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>rest</name> = <name>fname</name> + <name>namelen</name></expr>;</expr_stmt>
<expr_stmt><expr><name>len</name> = <name><name>pfhdr</name>-&gt;<name>fname_length</name></name> - <name>namelen</name></expr>;</expr_stmt>
<if>if <condition>(<expr>(<name><name>pathname</name><index>[<expr><call><name>strlen</name><argument_list>(<argument><expr><name>pathname</name></expr></argument>)</argument_list></call>-1</expr>]</index></name> != '\\')
&amp;&amp; (<name><name>pathname</name><index>[<expr><call><name>strlen</name><argument_list>(<argument><expr><name>pathname</name></expr></argument>)</argument_list></call>-1</expr>]</index></name> != '/')</expr>)</condition><then>
<expr_stmt><expr><call><name>strcat</name><argument_list>(<argument><expr><name>pathname</name></expr></argument>, <argument><expr>"\\"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<if>if <condition>(<expr>(<name><name>rest</name><index>[<expr>0</expr>]</index></name> == '\\') || (<name><name>rest</name><index>[<expr>0</expr>]</index></name> == '/')</expr>)</condition><then> <block>{
<expr_stmt><expr>++<name>rest</name></expr>;</expr_stmt>
<expr_stmt><expr>--<name>len</name></expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><call><name>strncat</name><argument_list>(<argument><expr><name>pathname</name></expr></argument>, <argument><expr><name>rest</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>Done</name>;</goto>
}</block></then></if>
}</block></for>
<expr_stmt><expr><call><name>strncat</name><argument_list>(<argument><expr><name>pathname</name></expr></argument>, <argument><expr><name>fname</name></expr></argument>, <argument><expr><name><name>pfhdr</name>-&gt;<name>fname_length</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<label><name>Done</name>:</label>
<expr_stmt><expr><call><name>normpath</name><argument_list>(<argument><expr><name>pathname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>pathname</name><index>[<expr><call><name>strlen</name><argument_list>(<argument><expr><name>pathname</name></expr></argument>)</argument_list></call>-1</expr>]</index></name> != '\\'</expr>)</condition><then> <block>{
<expr_stmt><expr><name>dst</name> = <call><name>map_new_file</name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr><name>pathname</name></expr></argument>, <argument><expr><name>new_part</name></expr></argument>,
<argument><expr><name><name>pcdir</name>-&gt;<name>uncomp_size</name></name></expr></argument>,
<argument><expr><name><name>pcdir</name>-&gt;<name>last_mod_file_date</name></name></expr></argument>,
<argument><expr><name><name>pcdir</name>-&gt;<name>last_mod_file_time</name></name></expr></argument>, <argument><expr><name>notify</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>dst</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr>!<call><name>extract_file</name><argument_list>(<argument><expr><name>dst</name></expr></argument>, <argument><expr><name>pcomp</name></expr></argument>, <argument><expr><name><name>pfhdr</name>-&gt;<name>method</name></name></expr></argument>,
<argument><expr><name><name>pcdir</name>-&gt;<name>comp_size</name></name></expr></argument>,
<argument><expr><name><name>pcdir</name>-&gt;<name>uncomp_size</name></name></expr></argument>,
<argument><expr><name>notify</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>FALSE</name></expr>;</return></then></if>
}</block></then></if>
}</block></then></if>
<if>if <condition>(<expr><name>notify</name></expr>)</condition><then>
<expr_stmt><expr><call><name>notify</name><argument_list>(<argument><expr><name>NUM_FILES</name></expr></argument>, <argument><expr><name>new_part</name></expr></argument>, <argument><expr>(<name>int</name>)<name><name>pe</name>-&gt;<name>nTotalCDir</name></name></expr></argument>,
<argument><expr>(<name>int</name>)<name>n</name>+1</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
}</block></for>
<return>return <expr><name>TRUE</name></expr>;</return>
}</block></function>
</unit>
