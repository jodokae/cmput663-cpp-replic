<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C" filename="projects/cpython-2.6.1/_cppstats/PC/os2emx/getpathp.c"><cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"Python.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"osdefs.h"</cpp:file></cpp:include>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>PYOS_OS2</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:error>#<cpp:directive>error</cpp:directive> This file only compilable on OS/2</cpp:error>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INCL_DOS</name></cpp:macro></cpp:define>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;os2.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/types.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/stat.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string.h&gt;</cpp:file></cpp:include>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>HAVE_UNISTD_H</name></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;unistd.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>LANDMARK</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>PYCC_GCC</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LANDMARK</name></cpp:macro> <cpp:value>"lib/os.py"</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LANDMARK</name></cpp:macro> <cpp:value>"lib\\os.py"</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name><name>prefix</name><index>[<expr><name>MAXPATHLEN</name>+1</expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name><name>progpath</name><index>[<expr><name>MAXPATHLEN</name>+1</expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> *</type><name>module_search_path</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>is_sep</name><parameter_list>(<param><decl><type><name>char</name></type> <name>ch</name></decl></param>)</parameter_list> <block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>ALTSEP</name></expr></argument>)</argument_list></call></expr></cpp:if>
<return>return <expr><name>ch</name> == <name>SEP</name> || <name>ch</name> == <name>ALTSEP</name></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<return>return <expr><name>ch</name> == <name>SEP</name></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>reduce</name><parameter_list>(<param><decl><type><name>char</name> *</type><name>dir</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>size_t</name></type> <name>i</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name>dir</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<while>while <condition>(<expr><name>i</name> &gt; 0 &amp;&amp; !<call><name>is_sep</name><argument_list>(<argument><expr><name><name>dir</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition>
<expr_stmt><expr>--<name>i</name></expr>;</expr_stmt></while>
<expr_stmt><expr><name><name>dir</name><index>[<expr><name>i</name></expr>]</index></name> = '\0'</expr>;</expr_stmt>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>exists</name><parameter_list>(<param><decl><type><name>char</name> *</type><name>filename</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type>struct <name>stat</name></type> <name>buf</name></decl>;</decl_stmt>
<return>return <expr><call><name>stat</name><argument_list>(<argument><expr><name>filename</name></expr></argument>, <argument><expr>&amp;<name>buf</name></expr></argument>)</argument_list></call> == 0</expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>ismodule</name><parameter_list>(<param><decl><type><name>char</name> *</type><name>filename</name></decl></param>)</parameter_list> <block>{
<if>if <condition>(<expr><call><name>exists</name><argument_list>(<argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr>1</expr>;</return></then></if>
<if>if <condition>(<expr><call><name>strlen</name><argument_list>(<argument><expr><name>filename</name></expr></argument>)</argument_list></call> &lt; <name>MAXPATHLEN</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>strcat</name><argument_list>(<argument><expr><name>filename</name></expr></argument>, <argument><expr><name>Py_OptimizeFlag</name> ? "o" : "c"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>exists</name><argument_list>(<argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr>1</expr>;</return></then></if>
}</block></then></if>
<return>return <expr>0</expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>join</name><parameter_list>(<param><decl><type><name>char</name> *</type><name>buffer</name></decl></param>, <param><decl><type><name>char</name> *</type><name>stuff</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>size_t</name></type> <name>n</name></decl>, <decl><type ref="prev"/><name>k</name></decl>;</decl_stmt>
<if>if <condition>(<expr><call><name>is_sep</name><argument_list>(<argument><expr><name><name>stuff</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><then>
<expr_stmt><expr><name>n</name> = 0</expr>;</expr_stmt></then>
<else>else <block>{
<expr_stmt><expr><name>n</name> = <call><name>strlen</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>n</name> &gt; 0 &amp;&amp; !<call><name>is_sep</name><argument_list>(<argument><expr><name><name>buffer</name><index>[<expr><name>n</name>-1</expr>]</index></name></expr></argument>)</argument_list></call> &amp;&amp; <name>n</name> &lt; <name>MAXPATHLEN</name></expr>)</condition><then>
<expr_stmt><expr><name><name>buffer</name><index>[<expr><name>n</name>++</expr>]</index></name> = <name>SEP</name></expr>;</expr_stmt></then></if>
}</block></else></if>
<if>if <condition>(<expr><name>n</name> &gt; <name>MAXPATHLEN</name></expr>)</condition><then>
<expr_stmt><expr><call><name>Py_FatalError</name><argument_list>(<argument><expr>"buffer overflow in getpathp.c's joinpath()"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<expr_stmt><expr><name>k</name> = <call><name>strlen</name><argument_list>(<argument><expr><name>stuff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>n</name> + <name>k</name> &gt; <name>MAXPATHLEN</name></expr>)</condition><then>
<expr_stmt><expr><name>k</name> = <name>MAXPATHLEN</name> - <name>n</name></expr>;</expr_stmt></then></if>
<expr_stmt><expr><call><name>strncpy</name><argument_list>(<argument><expr><name>buffer</name>+<name>n</name></expr></argument>, <argument><expr><name>stuff</name></expr></argument>, <argument><expr><name>k</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>buffer</name><index>[<expr><name>n</name>+<name>k</name></expr>]</index></name> = '\0'</expr>;</expr_stmt>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>gotlandmark</name><parameter_list>(<param><decl><type><name>char</name> *</type><name>landmark</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>, <decl><type ref="prev"/><name>ok</name></decl>;</decl_stmt>
<expr_stmt><expr><name>n</name> = <call><name>strlen</name><argument_list>(<argument><expr><name>prefix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>join</name><argument_list>(<argument><expr><name>prefix</name></expr></argument>, <argument><expr><name>landmark</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ok</name> = <call><name>ismodule</name><argument_list>(<argument><expr><name>prefix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>prefix</name><index>[<expr><name>n</name></expr>]</index></name> = '\0'</expr>;</expr_stmt>
<return>return <expr><name>ok</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>search_for_prefix</name><parameter_list>(<param><decl><type><name>char</name> *</type><name>argv0_path</name></decl></param>, <param><decl><type><name>char</name> *</type><name>landmark</name></decl></param>)</parameter_list> <block>{
<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>prefix</name></expr></argument>, <argument><expr><name>argv0_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<do>do <block>{
<if>if <condition>(<expr><call><name>gotlandmark</name><argument_list>(<argument><expr><name>landmark</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr>1</expr>;</return></then></if>
<expr_stmt><expr><call><name>reduce</name><argument_list>(<argument><expr><name>prefix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block> while <condition>(<expr><name><name>prefix</name><index>[<expr>0</expr>]</index></name></expr>)</condition>;</do>
<return>return <expr>0</expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>get_progpath</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list> <block>{
<function_decl><type><specifier>extern</specifier> <name>char</name> *</type><name>Py_GetProgramName</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list>;</function_decl>
<decl_stmt><decl><type><name>char</name> *</type><name>path</name> <init>= <expr><call><name>getenv</name><argument_list>(<argument><expr>"PATH"</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>prog</name> <init>= <expr><call><name>Py_GetProgramName</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PPIB</name></type> <name>pib</name></decl>;</decl_stmt>
<if>if <condition>(<expr>(<call><name>DosGetInfoBlocks</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr>&amp;<name>pib</name></expr></argument>)</argument_list></call> == 0) &amp;&amp;
(<call><name>DosQueryModuleName</name><argument_list>(<argument><expr><name><name>pib</name>-&gt;<name>pib_hmte</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>progpath</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>progpath</name></expr></argument>)</argument_list></call> == 0)</expr>)</condition><then>
<return>return;</return></then></if>
<if>if <condition>(<expr><name>prog</name> == <name>NULL</name> || *<name>prog</name> == '\0'</expr>)</condition><then>
<expr_stmt><expr><name>prog</name> = "python"</expr>;</expr_stmt></then></if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>ALTSEP</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if>if <condition>(<expr><call><name>strchr</name><argument_list>(<argument><expr><name>prog</name></expr></argument>, <argument><expr><name>SEP</name></expr></argument>)</argument_list></call> || <call><name>strchr</name><argument_list>(<argument><expr><name>prog</name></expr></argument>, <argument><expr><name>ALTSEP</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<if>if <condition>(<expr><call><name>strchr</name><argument_list>(<argument><expr><name>prog</name></expr></argument>, <argument><expr><name>SEP</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><call><name>strncpy</name><argument_list>(<argument><expr><name>progpath</name></expr></argument>, <argument><expr><name>prog</name></expr></argument>, <argument><expr><name>MAXPATHLEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
<else>else <if>if <condition>(<expr><name>path</name></expr>)</condition><then> <block>{
<while>while <condition>(<expr>1</expr>)</condition> <block>{
<decl_stmt><decl><type><name>char</name> *</type><name>delim</name> <init>= <expr><call><name>strchr</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>DELIM</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>delim</name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>size_t</name></type> <name>len</name> <init>= <expr><name>delim</name> - <name>path</name></expr></init></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>PYCC_GCC</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><name>len</name> = <call><name>min</name><argument_list>(<argument><expr><name>MAXPATHLEN</name></expr></argument>,<argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<expr_stmt><expr><name>len</name> = <name>MAXPATHLEN</name> &lt; <name>len</name> ? <name>MAXPATHLEN</name> : <name>len</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><call><name>strncpy</name><argument_list>(<argument><expr><name>progpath</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr>*(<name>progpath</name> + <name>len</name>) = '\0'</expr>;</expr_stmt>
}</block></then> <else>else
<expr_stmt><expr><call><name>strncpy</name><argument_list>(<argument><expr><name>progpath</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>MAXPATHLEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
<expr_stmt><expr><call><name>join</name><argument_list>(<argument><expr><name>progpath</name></expr></argument>, <argument><expr><name>prog</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>exists</name><argument_list>(<argument><expr><name>progpath</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<break>break;</break></then></if>
<if>if <condition>(<expr>!<name>delim</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>progpath</name><index>[<expr>0</expr>]</index></name> = '\0'</expr>;</expr_stmt>
<break>break;</break>
}</block></then></if>
<expr_stmt><expr><name>path</name> = <name>delim</name> + 1</expr>;</expr_stmt>
}</block></while>
}</block></then> <else>else
<expr_stmt><expr><name><name>progpath</name><index>[<expr>0</expr>]</index></name> = '\0'</expr>;</expr_stmt></else></if></else></if></then></if>
}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>calculate_path</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>char</name></type> <name><name>argv0_path</name><index>[<expr><name>MAXPATHLEN</name>+1</expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>buf</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>bufsz</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>pythonhome</name> <init>= <expr><call><name>Py_GetPythonHome</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>envpath</name> <init>= <expr><call><name>getenv</name><argument_list>(<argument><expr>"PYTHONPATH"</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name><name>zip_path</name><index>[<expr><name>MAXPATHLEN</name>+1</expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>len</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>get_progpath</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>argv0_path</name></expr></argument>, <argument><expr><name>progpath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>reduce</name><argument_list>(<argument><expr><name>argv0_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>pythonhome</name> == <name>NULL</name> || *<name>pythonhome</name> == '\0'</expr>)</condition><then> <block>{
<if>if <condition>(<expr><call><name>search_for_prefix</name><argument_list>(<argument><expr><name>argv0_path</name></expr></argument>, <argument><expr><name>LANDMARK</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<expr_stmt><expr><name>pythonhome</name> = <name>prefix</name></expr>;</expr_stmt></then>
<else>else
<expr_stmt><expr><name>pythonhome</name> = <name>NULL</name></expr>;</expr_stmt></else></if>
}</block></then> <else>else
<expr_stmt><expr><call><name>strncpy</name><argument_list>(<argument><expr><name>prefix</name></expr></argument>, <argument><expr><name>pythonhome</name></expr></argument>, <argument><expr><name>MAXPATHLEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
<if>if <condition>(<expr><name>envpath</name> &amp;&amp; *<name>envpath</name> == '\0'</expr>)</condition><then>
<expr_stmt><expr><name>envpath</name> = <name>NULL</name></expr>;</expr_stmt></then></if>
<expr_stmt><expr><call><name>strncpy</name><argument_list>(<argument><expr><name>zip_path</name></expr></argument>, <argument><expr><name>progpath</name></expr></argument>, <argument><expr><name>MAXPATHLEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>zip_path</name><index>[<expr><name>MAXPATHLEN</name></expr>]</index></name> = '\0'</expr>;</expr_stmt>
<expr_stmt><expr><name>len</name> = <call><name>strlen</name><argument_list>(<argument><expr><name>zip_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>len</name> &gt; 4</expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>zip_path</name><index>[<expr><name>len</name>-3</expr>]</index></name> = 'z'</expr>;</expr_stmt>
<expr_stmt><expr><name><name>zip_path</name><index>[<expr><name>len</name>-2</expr>]</index></name> = 'i'</expr>;</expr_stmt>
<expr_stmt><expr><name><name>zip_path</name><index>[<expr><name>len</name>-1</expr>]</index></name> = 'p'</expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr><name><name>zip_path</name><index>[<expr>0</expr>]</index></name> = 0</expr>;</expr_stmt>
}</block></else></if>
<if>if <condition>(<expr><name>pythonhome</name> != <name>NULL</name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>char</name> *</type><name>p</name></decl>;</decl_stmt>
<expr_stmt><expr><name>bufsz</name> = 1</expr>;</expr_stmt>
<for>for (<init><expr><name>p</name> = <name>PYTHONPATH</name></expr>;</init> <condition><expr>*<name>p</name></expr>;</condition> <incr><expr><name>p</name>++</expr></incr>) <block>{
<if>if <condition>(<expr>*<name>p</name> == <name>DELIM</name></expr>)</condition><then>
<expr_stmt><expr><name>bufsz</name>++</expr>;</expr_stmt></then></if>
}</block></for>
<expr_stmt><expr><name>bufsz</name> *= <call><name>strlen</name><argument_list>(<argument><expr><name>pythonhome</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else
<expr_stmt><expr><name>bufsz</name> = 0</expr>;</expr_stmt></else></if>
<expr_stmt><expr><name>bufsz</name> += <call><name>strlen</name><argument_list>(<argument><expr><name>PYTHONPATH</name></expr></argument>)</argument_list></call> + 1</expr>;</expr_stmt>
<expr_stmt><expr><name>bufsz</name> += <call><name>strlen</name><argument_list>(<argument><expr><name>argv0_path</name></expr></argument>)</argument_list></call> + 1</expr>;</expr_stmt>
<expr_stmt><expr><name>bufsz</name> += <call><name>strlen</name><argument_list>(<argument><expr><name>zip_path</name></expr></argument>)</argument_list></call> + 1</expr>;</expr_stmt>
<if>if <condition>(<expr><name>envpath</name> != <name>NULL</name></expr>)</condition><then>
<expr_stmt><expr><name>bufsz</name> += <call><name>strlen</name><argument_list>(<argument><expr><name>envpath</name></expr></argument>)</argument_list></call> + 1</expr>;</expr_stmt></then></if>
<expr_stmt><expr><name>module_search_path</name> = <name>buf</name> = <call><name>malloc</name><argument_list>(<argument><expr><name>bufsz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>buf</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr>"Can't malloc dynamic PYTHONPATH.\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>envpath</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr>"Using environment $PYTHONPATH.\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>module_search_path</name> = <name>envpath</name></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr>"Using default static path.\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>module_search_path</name> = <name>PYTHONPATH</name></expr>;</expr_stmt>
}</block></else></if>
<return>return;</return>
}</block></then></if>
<if>if <condition>(<expr><name>envpath</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>envpath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>buf</name> = <call><name>strchr</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr>'\0'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr>*<name>buf</name>++ = <name>DELIM</name></expr>;</expr_stmt>
}</block></then></if>
<if>if <condition>(<expr><name><name>zip_path</name><index>[<expr>0</expr>]</index></name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>zip_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>buf</name> = <call><name>strchr</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr>'\0'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr>*<name>buf</name>++ = <name>DELIM</name></expr>;</expr_stmt>
}</block></then></if>
<if>if <condition>(<expr><name>pythonhome</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>PYTHONPATH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>buf</name> = <call><name>strchr</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr>'\0'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<decl_stmt><decl><type><name>char</name> *</type><name>p</name> <init>= <expr><name>PYTHONPATH</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>q</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>n</name></decl>;</decl_stmt>
<for>for (<init>;</init><condition>;</condition><incr/>) <block>{
<expr_stmt><expr><name>q</name> = <call><name>strchr</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>DELIM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>q</name> == <name>NULL</name></expr>)</condition><then>
<expr_stmt><expr><name>n</name> = <call><name>strlen</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
<else>else
<expr_stmt><expr><name>n</name> = <name>q</name>-<name>p</name></expr>;</expr_stmt></else></if>
<if>if <condition>(<expr><name><name>p</name><index>[<expr>0</expr>]</index></name> == '.' &amp;&amp; <call><name>is_sep</name><argument_list>(<argument><expr><name><name>p</name><index>[<expr>1</expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>pythonhome</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>buf</name> = <call><name>strchr</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr>'\0'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>p</name>++</expr>;</expr_stmt>
<expr_stmt><expr><name>n</name>--</expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><call><name>strncpy</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>buf</name> += <name>n</name></expr>;</expr_stmt>
<if>if <condition>(<expr><name>q</name> == <name>NULL</name></expr>)</condition><then>
<break>break;</break></then></if>
<expr_stmt><expr>*<name>buf</name>++ = <name>DELIM</name></expr>;</expr_stmt>
<expr_stmt><expr><name>p</name> = <name>q</name>+1</expr>;</expr_stmt>
}</block></for>
}</block></else></if>
<if>if <condition>(<expr><name>argv0_path</name></expr>)</condition><then> <block>{
<expr_stmt><expr>*<name>buf</name>++ = <name>DELIM</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>argv0_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>buf</name> = <call><name>strchr</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr>'\0'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr>*<name>buf</name> = '\0'</expr>;</expr_stmt>
}</block></function>
<function><type><name>char</name> *</type>
<name>Py_GetPath</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list> <block>{
<if>if <condition>(<expr>!<name>module_search_path</name></expr>)</condition><then>
<expr_stmt><expr><call><name>calculate_path</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>
<return>return <expr><name>module_search_path</name></expr>;</return>
}</block></function>
<function><type><name>char</name> *</type>
<name>Py_GetPrefix</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list> <block>{
<if>if <condition>(<expr>!<name>module_search_path</name></expr>)</condition><then>
<expr_stmt><expr><call><name>calculate_path</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>
<return>return <expr><name>prefix</name></expr>;</return>
}</block></function>
<function><type><name>char</name> *</type>
<name>Py_GetExecPrefix</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list> <block>{
<return>return <expr><call><name>Py_GetPrefix</name><argument_list>()</argument_list></call></expr>;</return>
}</block></function>
<function><type><name>char</name> *</type>
<name>Py_GetProgramFullPath</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list> <block>{
<if>if <condition>(<expr>!<name>module_search_path</name></expr>)</condition><then>
<expr_stmt><expr><call><name>calculate_path</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>
<return>return <expr><name>progpath</name></expr>;</return>
}</block></function>
</unit>
