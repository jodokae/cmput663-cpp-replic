<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C" filename="projects/cpython-2.6.1/source/PC/os2vacpp/getpathp.c">
<comment type="block">/* Return the initial module search path. */</comment>
<comment type="block">/* Used by DOS, OS/2, Windows 3.1.  Works on NT too. */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"Python.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"osdefs.h"</cpp:file></cpp:include>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>MS_WIN32</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;windows.h&gt;</cpp:file></cpp:include>
<function_decl><type><specifier>extern</specifier> <name>BOOL</name></type> <name>PyWin_IsWin32s</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/types.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/stat.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string.h&gt;</cpp:file></cpp:include>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>HAVE_UNISTD_H</name></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;unistd.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* HAVE_UNISTD_H */</comment>

<comment type="block">/* Search in some common locations for the associated Python libraries.
 *
 * Two directories must be found, the platform independent directory
 * (prefix), containing the common .py and .pyc files, and the platform
 * dependent directory (exec_prefix), containing the shared library
 * modules.  Note that prefix and exec_prefix can be the same directory,
 * but for some installations, they are different.
 *
 * Py_GetPath() tries to return a sensible Python module search path.
 *
 * First, we look to see if the executable is in a subdirectory of
 * the Python build directory.  We calculate the full path of the
 * directory containing the executable as progpath.  We work backwards
 * along progpath and look for $dir/Modules/Setup.in, a distinctive
 * landmark.  If found, we use $dir/Lib as $root.  The returned
 * Python path is the compiled #define PYTHONPATH with all the initial
 * "./lib" replaced by $root.
 *
 * Otherwise, if there is a PYTHONPATH environment variable, we return that.
 *
 * Otherwise we try to find $progpath/lib/os.py, and if found, then
 * root is $progpath/lib, and we return Python path as compiled PYTHONPATH
 * with all "./lib" replaced by $root (as above).
 *
 */</comment>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>LANDMARK</name></cpp:ifndef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LANDMARK</name></cpp:macro> <cpp:value>"lib\\os.py"</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name><name>prefix</name><index>[<expr><name>MAXPATHLEN</name>+1</expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name><name>exec_prefix</name><index>[<expr><name>MAXPATHLEN</name>+1</expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name><name>progpath</name><index>[<expr><name>MAXPATHLEN</name>+1</expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> *</type><name>module_search_path</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>


<function><type><specifier>static</specifier> <name>int</name></type>
<name>is_sep</name><parameter_list>(<param><decl><type><name>char</name></type> <name>ch</name></decl></param>)</parameter_list>	<comment type="block">/* determine if "ch" is a separator character */</comment>
<block>{
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>ALTSEP</name></cpp:ifdef>
	<return>return <expr><name>ch</name> == <name>SEP</name> || <name>ch</name> == <name>ALTSEP</name></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<return>return <expr><name>ch</name> == <name>SEP</name></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type>
<name>reduce</name><parameter_list>(<param><decl><type><name>char</name> *</type><name>dir</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name>dir</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<while>while <condition>(<expr><name>i</name> &gt; 0 &amp;&amp; !<call><name>is_sep</name><argument_list>(<argument><expr><name><name>dir</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition>
		<expr_stmt><expr>--<name>i</name></expr>;</expr_stmt></while>
	<expr_stmt><expr><name><name>dir</name><index>[<expr><name>i</name></expr>]</index></name> = '\0'</expr>;</expr_stmt>
}</block></function>
	

<function><type><specifier>static</specifier> <name>int</name></type>
<name>exists</name><parameter_list>(<param><decl><type><name>char</name> *</type><name>filename</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type>struct <name>stat</name></type> <name>buf</name></decl>;</decl_stmt>
	<return>return <expr><call><name>stat</name><argument_list>(<argument><expr><name>filename</name></expr></argument>, <argument><expr>&amp;<name>buf</name></expr></argument>)</argument_list></call> == 0</expr>;</return>
}</block></function>


<comment type="block">/* Add a path component, by appending stuff to buffer.
   buffer must have at least MAXPATHLEN + 1 bytes allocated, and contain a
   NUL-terminated string with no more than MAXPATHLEN characters (not counting
   the trailing NUL).  It's a fatal error if it contains a string longer than
   that (callers must be careful!).  If these requirements are met, it's
   guaranteed that buffer will still be a NUL-terminated string with no more
   than MAXPATHLEN characters at exit.  If stuff is too long, only as much of
   stuff as fits will be appended.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>join</name><parameter_list>(<param><decl><type><name>char</name> *</type><name>buffer</name></decl></param>, <param><decl><type><name>char</name> *</type><name>stuff</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>, <decl><type ref="prev"/><name>k</name></decl>;</decl_stmt>
	<if>if <condition>(<expr><call><name>is_sep</name><argument_list>(<argument><expr><name><name>stuff</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<expr_stmt><expr><name>n</name> = 0</expr>;</expr_stmt></then>
	<else>else <block>{
		<expr_stmt><expr><name>n</name> = <call><name>strlen</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>n</name> &gt; 0 &amp;&amp; !<call><name>is_sep</name><argument_list>(<argument><expr><name><name>buffer</name><index>[<expr><name>n</name>-1</expr>]</index></name></expr></argument>)</argument_list></call> &amp;&amp; <name>n</name> &lt; <name>MAXPATHLEN</name></expr>)</condition><then>
			<expr_stmt><expr><name><name>buffer</name><index>[<expr><name>n</name>++</expr>]</index></name> = <name>SEP</name></expr>;</expr_stmt></then></if>
	}</block></else></if>
	<if>if <condition>(<expr><name>n</name> &gt; <name>MAXPATHLEN</name></expr>)</condition><then>
		<expr_stmt><expr><call><name>Py_FatalError</name><argument_list>(<argument><expr>"buffer overflow in getpathp.c's joinpath()"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
	<expr_stmt><expr><name>k</name> = <call><name>strlen</name><argument_list>(<argument><expr><name>stuff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>n</name> + <name>k</name> &gt; <name>MAXPATHLEN</name></expr>)</condition><then>
		<expr_stmt><expr><name>k</name> = <name>MAXPATHLEN</name> - <name>n</name></expr>;</expr_stmt></then></if>
	<expr_stmt><expr><call><name>strncpy</name><argument_list>(<argument><expr><name>buffer</name>+<name>n</name></expr></argument>, <argument><expr><name>stuff</name></expr></argument>, <argument><expr><name>k</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>buffer</name><index>[<expr><name>n</name>+<name>k</name></expr>]</index></name> = '\0'</expr>;</expr_stmt>
}</block></function>


<function><type><specifier>static</specifier> <name>int</name></type>
<name>search_for_prefix</name><parameter_list>(<param><decl><type><name>char</name> *</type><name>argv0_path</name></decl></param>, <param><decl><type><name>char</name> *</type><name>landmark</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>;</decl_stmt>

	<comment type="block">/* Search from argv0_path, until root is found */</comment>
	<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>prefix</name></expr></argument>, <argument><expr><name>argv0_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<do>do <block>{
		<expr_stmt><expr><name>n</name> = <call><name>strlen</name><argument_list>(<argument><expr><name>prefix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>join</name><argument_list>(<argument><expr><name>prefix</name></expr></argument>, <argument><expr><name>landmark</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><call><name>exists</name><argument_list>(<argument><expr><name>prefix</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
			<expr_stmt><expr><name><name>prefix</name><index>[<expr><name>n</name></expr>]</index></name> = '\0'</expr>;</expr_stmt>
			<return>return <expr>1</expr>;</return>
		}</block></then></if>
		<expr_stmt><expr><name><name>prefix</name><index>[<expr><name>n</name></expr>]</index></name> = '\0'</expr>;</expr_stmt>
		<expr_stmt><expr><call><name>reduce</name><argument_list>(<argument><expr><name>prefix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block> while <condition>(<expr><name><name>prefix</name><index>[<expr>0</expr>]</index></name></expr>)</condition>;</do>
	<return>return <expr>0</expr>;</return>
}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>MS_WIN32</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"malloc.h"</cpp:file></cpp:include> <comment type="line">// for alloca - see comments below!</comment>
<decl_stmt><decl><type><specifier>extern</specifier> <specifier>const</specifier> <name>char</name> *</type><name>PyWin_DLLVersionString</name></decl>;</decl_stmt> <comment type="line">// a string loaded from the DLL at startup.</comment>


<comment type="block">/* Load a PYTHONPATH value from the registry.
   Load from either HKEY_LOCAL_MACHINE or HKEY_CURRENT_USER.

   Returns NULL, or a pointer that should be freed.
*/</comment>

<function><type><specifier>static</specifier> <name>char</name> *</type>
<name>getpythonregpath</name><parameter_list>(<param><decl><type><name>HKEY</name></type> <name>keyBase</name></decl></param>, <param><decl><type><name>BOOL</name></type> <name>bWin32s</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>HKEY</name></type> <name>newKey</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>DWORD</name></type> <name>nameSize</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>DWORD</name></type> <name>dataSize</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>DWORD</name></type> <name>numEntries</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LONG</name></type> <name>rc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> *</type><name>retval</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> *</type><name>dataBuf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name></type> <name><name>keyPrefix</name><index>[]</index></name> <init>= <expr>"Software\\Python\\PythonCore\\"</expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name></type> <name><name>keySuffix</name><index>[]</index></name> <init>= <expr>"\\PythonPath"</expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>versionLen</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> *</type><name>keyBuf</name></decl>;</decl_stmt>

	<comment type="line">// Tried to use sysget("winver") but here is too early :-(</comment>
	<expr_stmt><expr><name>versionLen</name> = <call><name>strlen</name><argument_list>(<argument><expr><name>PyWin_DLLVersionString</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="line">// alloca == no free required, but memory only local to fn.</comment>
	<comment type="line">// also no heap fragmentation!  Am I being silly?</comment>
	<expr_stmt><expr><name>keyBuf</name> = <call><name>alloca</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>keyPrefix</name></expr></argument>)</argument_list></sizeof>-1 + <name>versionLen</name> + <sizeof>sizeof<argument_list>(<argument><expr><name>keySuffix</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="line">// chars only, plus 1 NULL.</comment>
	<comment type="line">// lots of constants here for the compiler to optimize away :-)</comment>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>keyBuf</name></expr></argument>, <argument><expr><name>keyPrefix</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>keyPrefix</name></expr></argument>)</argument_list></sizeof>-1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>keyBuf</name>+<sizeof>sizeof<argument_list>(<argument><expr><name>keyPrefix</name></expr></argument>)</argument_list></sizeof>-1</expr></argument>, <argument><expr><name>PyWin_DLLVersionString</name></expr></argument>, <argument><expr><name>versionLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>keyBuf</name>+<sizeof>sizeof<argument_list>(<argument><expr><name>keyPrefix</name></expr></argument>)</argument_list></sizeof>-1+<name>versionLen</name></expr></argument>, <argument><expr><name>keySuffix</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>keySuffix</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="line">// NULL comes with this one!</comment>

	<expr_stmt><expr><name>rc</name>=<call><name>RegOpenKey</name><argument_list>(<argument><expr><name>keyBase</name></expr></argument>,
		      <argument><expr><name>keyBuf</name></expr></argument>,
		      <argument><expr>&amp;<name>newKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>rc</name>==<name>ERROR_SUCCESS</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>RegQueryInfoKey</name><argument_list>(<argument><expr><name>newKey</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, 
		                <argument><expr>&amp;<name>numEntries</name></expr></argument>, <argument><expr>&amp;<name>nameSize</name></expr></argument>, <argument><expr>&amp;<name>dataSize</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>
	<if>if <condition>(<expr><name>bWin32s</name> &amp;&amp; <name>numEntries</name>==0 &amp;&amp; <name>dataSize</name>==0</expr>)</condition><then> <block>{
		<comment type="block">/* must hardcode for Win32s */</comment>
		<expr_stmt><expr><name>numEntries</name> = 1</expr>;</expr_stmt>
		<expr_stmt><expr><name>dataSize</name> = 511</expr>;</expr_stmt>
	}</block></then></if>
	<if>if <condition>(<expr><name>numEntries</name></expr>)</condition><then> <block>{
		<comment type="block">/* Loop over all subkeys. */</comment>
		<comment type="block">/* Win32s doesnt know how many subkeys, so we do
		   it twice */</comment>
		<decl_stmt><decl><type><name>char</name></type> <name><name>keyBuf</name><index>[<expr><name>MAX_PATH</name>+1</expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>index</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>off</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
		<for>for(<init><expr><name>index</name>=0</expr>;</init><condition>;</condition><incr><expr><name>index</name>++</expr></incr>) <block>{
			<decl_stmt><decl><type><name>long</name></type> <name>reqdSize</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>DWORD</name></type> <name>rc</name> <init>= <expr><call><name>RegEnumKey</name><argument_list>(<argument><expr><name>newKey</name></expr></argument>,
					      <argument><expr><name>index</name></expr></argument>, <argument><expr><name>keyBuf</name></expr></argument>, <argument><expr><name>MAX_PATH</name>+1</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<if>if <condition>(<expr><name>rc</name></expr>)</condition><then> <break>break;</break></then></if>
			<expr_stmt><expr><name>rc</name> = <call><name>RegQueryValue</name><argument_list>(<argument><expr><name>newKey</name></expr></argument>, <argument><expr><name>keyBuf</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr>&amp;<name>reqdSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><name>rc</name></expr>)</condition><then> <break>break;</break></then></if>
			<if>if <condition>(<expr><name>bWin32s</name> &amp;&amp; <name>reqdSize</name>==0</expr>)</condition><then> <expr_stmt><expr><name>reqdSize</name> = 512</expr>;</expr_stmt></then></if>
			<expr_stmt><expr><name>dataSize</name> += <name>reqdSize</name> + 1</expr>;</expr_stmt> <comment type="block">/* 1 for the ";" */</comment>
		}</block></for>
		<expr_stmt><expr><name>dataBuf</name> = <call><name>malloc</name><argument_list>(<argument><expr><name>dataSize</name>+1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>dataBuf</name>==<name>NULL</name></expr>)</condition><then>
			<return>return <expr><name>NULL</name></expr>;</return></then></if> <comment type="block">/* pretty serious?  Raise error? */</comment>
		<comment type="block">/* Now loop over, grabbing the paths.
		   Subkeys before main library */</comment>
		<for>for(<init><expr><name>index</name>=0</expr>;</init><condition>;</condition><incr><expr><name>index</name>++</expr></incr>) <block>{
			<decl_stmt><decl><type><name>int</name></type> <name>adjust</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>long</name></type> <name>reqdSize</name> <init>= <expr><name>dataSize</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>DWORD</name></type> <name>rc</name> <init>= <expr><call><name>RegEnumKey</name><argument_list>(<argument><expr><name>newKey</name></expr></argument>,
					      <argument><expr><name>index</name></expr></argument>, <argument><expr><name>keyBuf</name></expr></argument>,<argument><expr><name>MAX_PATH</name>+1</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<if>if <condition>(<expr><name>rc</name></expr>)</condition><then> <break>break;</break></then></if>
			<expr_stmt><expr><name>rc</name> = <call><name>RegQueryValue</name><argument_list>(<argument><expr><name>newKey</name></expr></argument>,
					   <argument><expr><name>keyBuf</name></expr></argument>, <argument><expr><name>dataBuf</name>+<name>off</name></expr></argument>, <argument><expr>&amp;<name>reqdSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><name>rc</name></expr>)</condition><then> <break>break;</break></then></if>
			<if>if <condition>(<expr><name>reqdSize</name>&gt;1</expr>)</condition><then> <block>{
				<comment type="block">/* If Nothing, or only '\0' copied. */</comment>
				<expr_stmt><expr><name>adjust</name> = <call><name>strlen</name><argument_list>(<argument><expr><name>dataBuf</name>+<name>off</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>dataSize</name> -= <name>adjust</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>off</name> += <name>adjust</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>dataBuf</name><index>[<expr><name>off</name>++</expr>]</index></name> = ';'</expr>;</expr_stmt>
				<expr_stmt><expr><name><name>dataBuf</name><index>[<expr><name>off</name></expr>]</index></name> = '\0'</expr>;</expr_stmt>
				<expr_stmt><expr><name>dataSize</name>--</expr>;</expr_stmt>
			}</block></then></if>
		}</block></for>
		<comment type="block">/* Additionally, win32s doesnt work as expected, so
		   the specific strlen() is required for 3.1. */</comment>
		<expr_stmt><expr><name>rc</name> = <call><name>RegQueryValue</name><argument_list>(<argument><expr><name>newKey</name></expr></argument>, <argument><expr>""</expr></argument>, <argument><expr><name>dataBuf</name>+<name>off</name></expr></argument>, <argument><expr>&amp;<name>dataSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>rc</name>==<name>ERROR_SUCCESS</name></expr>)</condition><then> <block>{
			<if>if <condition>(<expr><call><name>strlen</name><argument_list>(<argument><expr><name>dataBuf</name></expr></argument>)</argument_list></call>==0</expr>)</condition><then>
				<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>dataBuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
			<else>else
				<expr_stmt><expr><name>retval</name> = <name>dataBuf</name></expr>;</expr_stmt></else></if> <comment type="block">/* caller will free */</comment>
		}</block></then>
		<else>else
			<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>dataBuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
	}</block></then></if>

	<if>if <condition>(<expr><name>newKey</name></expr>)</condition><then>
		<expr_stmt><expr><call><name>RegCloseKey</name><argument_list>(<argument><expr><name>newKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
	<return>return <expr><name>retval</name></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* MS_WIN32 */</comment>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>get_progpath</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list>
<block>{
	<function_decl><type><specifier>extern</specifier> <name>char</name> *</type><name>Py_GetProgramName</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list>;</function_decl>
	<decl_stmt><decl><type><name>char</name> *</type><name>path</name> <init>= <expr><call><name>getenv</name><argument_list>(<argument><expr>"PATH"</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> *</type><name>prog</name> <init>= <expr><call><name>Py_GetProgramName</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>MS_WIN32</name></cpp:ifdef>
	<if>if <condition>(<expr><call><name>GetModuleFileName</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>progpath</name></expr></argument>, <argument><expr><name>MAXPATHLEN</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return;</return></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<if>if <condition>(<expr><name>prog</name> == <name>NULL</name> || *<name>prog</name> == '\0'</expr>)</condition><then>
		<expr_stmt><expr><name>prog</name> = "python"</expr>;</expr_stmt></then></if>

	<comment type="block">/* If there is no slash in the argv0 path, then we have to
	 * assume python is on the user's $PATH, since there's no
	 * other way to find a directory to start the search from.  If
	 * $PATH isn't exported, you lose.
	 */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>ALTSEP</name></cpp:ifdef>
	<if>if <condition>(<expr><call><name>strchr</name><argument_list>(<argument><expr><name>prog</name></expr></argument>, <argument><expr><name>SEP</name></expr></argument>)</argument_list></call> || <call><name>strchr</name><argument_list>(<argument><expr><name>prog</name></expr></argument>, <argument><expr><name>ALTSEP</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<if>if <condition>(<expr><call><name>strchr</name><argument_list>(<argument><expr><name>prog</name></expr></argument>, <argument><expr><name>SEP</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>progpath</name></expr></argument>, <argument><expr><name>prog</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
	<else>else <if>if <condition>(<expr><name>path</name></expr>)</condition><then> <block>{
		<while>while <condition>(<expr>1</expr>)</condition> <block>{
			<decl_stmt><decl><type><name>char</name> *</type><name>delim</name> <init>= <expr><call><name>strchr</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>DELIM</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if>if <condition>(<expr><name>delim</name></expr>)</condition><then> <block>{
				<decl_stmt><decl><type><name>int</name></type> <name>len</name> <init>= <expr><name>delim</name> - <name>path</name></expr></init></decl>;</decl_stmt>
				<expr_stmt><expr><call><name>strncpy</name><argument_list>(<argument><expr><name>progpath</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr>*(<name>progpath</name> + <name>len</name>) = '\0'</expr>;</expr_stmt>
			}</block></then>
			<else>else
				<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>progpath</name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>

			<expr_stmt><expr><call><name>join</name><argument_list>(<argument><expr><name>progpath</name></expr></argument>, <argument><expr><name>prog</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><call><name>exists</name><argument_list>(<argument><expr><name>progpath</name></expr></argument>)</argument_list></call></expr>)</condition><then>
				<break>break;</break></then></if>

			<if>if <condition>(<expr>!<name>delim</name></expr>)</condition><then> <block>{
				<expr_stmt><expr><name><name>progpath</name><index>[<expr>0</expr>]</index></name> = '\0'</expr>;</expr_stmt>
				<break>break;</break>
			}</block></then></if>
			<expr_stmt><expr><name>path</name> = <name>delim</name> + 1</expr>;</expr_stmt>
		}</block></while>
	}</block></then>
	<else>else
		<expr_stmt><expr><name><name>progpath</name><index>[<expr>0</expr>]</index></name> = '\0'</expr>;</expr_stmt></else></if></else></if></then></if>
}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>calculate_path</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>char</name></type> <name><name>argv0_path</name><index>[<expr><name>MAXPATHLEN</name>+1</expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> *</type><name>buf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>bufsz</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> *</type><name>pythonhome</name> <init>= <expr><call><name>Py_GetPythonHome</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> *</type><name>envpath</name> <init>= <expr><call><name>Py_GETENV</name><argument_list>(<argument><expr>"PYTHONPATH"</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>MS_WIN32</name></cpp:ifdef>
	<decl_stmt><decl><type><name>char</name> *</type><name>machinepath</name></decl>, *<decl><type ref="prev"/><name>userpath</name></decl>;</decl_stmt>

	<comment type="block">/* Are we running under Windows 3.1(1) Win32s? */</comment>
	<if>if <condition>(<expr><call><name>PyWin_IsWin32s</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
		<comment type="block">/* Only CLASSES_ROOT is supported */</comment>
		<expr_stmt><expr><name>machinepath</name> = <call><name>getpythonregpath</name><argument_list>(<argument><expr><name>HKEY_CLASSES_ROOT</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
		<expr_stmt><expr><name>userpath</name> = <name>NULL</name></expr>;</expr_stmt>
	}</block></then> <else>else <block>{
		<expr_stmt><expr><name>machinepath</name> = <call><name>getpythonregpath</name><argument_list>(<argument><expr><name>HKEY_LOCAL_MACHINE</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>userpath</name> = <call><name>getpythonregpath</name><argument_list>(<argument><expr><name>HKEY_CURRENT_USER</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></else></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<expr_stmt><expr><call><name>get_progpath</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>argv0_path</name></expr></argument>, <argument><expr><name>progpath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>reduce</name><argument_list>(<argument><expr><name>argv0_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>pythonhome</name> == <name>NULL</name> || *<name>pythonhome</name> == '\0'</expr>)</condition><then> <block>{
		<if>if <condition>(<expr><call><name>search_for_prefix</name><argument_list>(<argument><expr><name>argv0_path</name></expr></argument>, <argument><expr><name>LANDMARK</name></expr></argument>)</argument_list></call></expr>)</condition><then>
			<expr_stmt><expr><name>pythonhome</name> = <name>prefix</name></expr>;</expr_stmt></then>
		<else>else
			<expr_stmt><expr><name>pythonhome</name> = <name>NULL</name></expr>;</expr_stmt></else></if>
	}</block></then>
	<else>else <block>{
        <decl_stmt><decl><type><name>char</name> *</type><name>delim</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>prefix</name></expr></argument>, <argument><expr><name>pythonhome</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Extract Any Optional Trailing EXEC_PREFIX */</comment>
        <comment type="block">/* e.g. PYTHONHOME=&lt;prefix&gt;:&lt;exec_prefix&gt;   */</comment>
        <expr_stmt><expr><name>delim</name> = <call><name>strchr</name><argument_list>(<argument><expr><name>prefix</name></expr></argument>, <argument><expr><name>DELIM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>delim</name></expr>)</condition><then> <block>{
            <expr_stmt><expr>*<name>delim</name> = '\0'</expr>;</expr_stmt>
            <expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>exec_prefix</name></expr></argument>, <argument><expr><name>delim</name>+1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then> <else>else
            <expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>exec_prefix</name></expr></argument>, <argument><expr><name>EXEC_PREFIX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
    }</block></else></if>

	<if>if <condition>(<expr><name>envpath</name> &amp;&amp; *<name>envpath</name> == '\0'</expr>)</condition><then>
		<expr_stmt><expr><name>envpath</name> = <name>NULL</name></expr>;</expr_stmt></then></if>

	<comment type="block">/* We need to construct a path from the following parts:
	   (1) the PYTHONPATH environment variable, if set;
	   (2) for Win32, the machinepath and userpath, if set;
	   (3) the PYTHONPATH config macro, with the leading "."
	       of each component replaced with pythonhome, if set;
	   (4) the directory containing the executable (argv0_path).
	   The length calculation calculates #3 first.
	*/</comment>

	<comment type="block">/* Calculate size of return buffer */</comment>
	<if>if <condition>(<expr><name>pythonhome</name> != <name>NULL</name></expr>)</condition><then> <block>{
		<decl_stmt><decl><type><name>char</name> *</type><name>p</name></decl>;</decl_stmt>
		<expr_stmt><expr><name>bufsz</name> = 1</expr>;</expr_stmt>	
		<for>for (<init><expr><name>p</name> = <name>PYTHONPATH</name></expr>;</init> <condition><expr>*<name>p</name></expr>;</condition> <incr><expr><name>p</name>++</expr></incr>) <block>{
			<if>if <condition>(<expr>*<name>p</name> == <name>DELIM</name></expr>)</condition><then>
				<expr_stmt><expr><name>bufsz</name>++</expr>;</expr_stmt></then></if> <comment type="block">/* number of DELIM plus one */</comment>
		}</block></for>
		<expr_stmt><expr><name>bufsz</name> *= <call><name>strlen</name><argument_list>(<argument><expr><name>pythonhome</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then>
	<else>else
		<expr_stmt><expr><name>bufsz</name> = 0</expr>;</expr_stmt></else></if>
	<expr_stmt><expr><name>bufsz</name> += <call><name>strlen</name><argument_list>(<argument><expr><name>PYTHONPATH</name></expr></argument>)</argument_list></call> + 1</expr>;</expr_stmt>
	<if>if <condition>(<expr><name>envpath</name> != <name>NULL</name></expr>)</condition><then>
		<expr_stmt><expr><name>bufsz</name> += <call><name>strlen</name><argument_list>(<argument><expr><name>envpath</name></expr></argument>)</argument_list></call> + 1</expr>;</expr_stmt></then></if>
	<expr_stmt><expr><name>bufsz</name> += <call><name>strlen</name><argument_list>(<argument><expr><name>argv0_path</name></expr></argument>)</argument_list></call> + 1</expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>MS_WIN32</name></cpp:ifdef>
	<if>if <condition>(<expr><name>machinepath</name></expr>)</condition><then>
		<expr_stmt><expr><name>bufsz</name> += <call><name>strlen</name><argument_list>(<argument><expr><name>machinepath</name></expr></argument>)</argument_list></call> + 1</expr>;</expr_stmt></then></if>
	<if>if <condition>(<expr><name>userpath</name></expr>)</condition><then>
		<expr_stmt><expr><name>bufsz</name> += <call><name>strlen</name><argument_list>(<argument><expr><name>userpath</name></expr></argument>)</argument_list></call> + 1</expr>;</expr_stmt></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<expr_stmt><expr><name>module_search_path</name> = <name>buf</name> = <call><name>malloc</name><argument_list>(<argument><expr><name>bufsz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>buf</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<comment type="block">/* We can't exit, so print a warning and limp along */</comment>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr>"Can't malloc dynamic PYTHONPATH.\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>envpath</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr>"Using default static $PYTHONPATH.\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>module_search_path</name> = <name>envpath</name></expr>;</expr_stmt>
		}</block></then>
		<else>else <block>{
			<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr>"Using environment $PYTHONPATH.\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>module_search_path</name> = <name>PYTHONPATH</name></expr>;</expr_stmt>
		}</block></else></if>
		<return>return;</return>
	}</block></then></if>

	<if>if <condition>(<expr><name>envpath</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>envpath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>buf</name> = <call><name>strchr</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr>'\0'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr>*<name>buf</name>++ = <name>DELIM</name></expr>;</expr_stmt>
	}</block></then></if>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>MS_WIN32</name></cpp:ifdef>
	<if>if <condition>(<expr><name>machinepath</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>machinepath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>buf</name> = <call><name>strchr</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr>'\0'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr>*<name>buf</name>++ = <name>DELIM</name></expr>;</expr_stmt>
	}</block></then></if>
	<if>if <condition>(<expr><name>userpath</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>userpath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>buf</name> = <call><name>strchr</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr>'\0'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr>*<name>buf</name>++ = <name>DELIM</name></expr>;</expr_stmt>
	}</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<if>if <condition>(<expr><name>pythonhome</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>PYTHONPATH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>buf</name> = <call><name>strchr</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr>'\0'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then>
	<else>else <block>{
		<decl_stmt><decl><type><name>char</name> *</type><name>p</name> <init>= <expr><name>PYTHONPATH</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name> *</type><name>q</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>;</decl_stmt>
		<for>for (<init>;</init><condition>;</condition><incr/>) <block>{
			<expr_stmt><expr><name>q</name> = <call><name>strchr</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>DELIM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><name>q</name> == <name>NULL</name></expr>)</condition><then>
				<expr_stmt><expr><name>n</name> = <call><name>strlen</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
			<else>else
				<expr_stmt><expr><name>n</name> = <name>q</name>-<name>p</name></expr>;</expr_stmt></else></if>
			<if>if <condition>(<expr><name><name>p</name><index>[<expr>0</expr>]</index></name> == '.' &amp;&amp; <call><name>is_sep</name><argument_list>(<argument><expr><name><name>p</name><index>[<expr>1</expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
				<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>pythonhome</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>buf</name> = <call><name>strchr</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr>'\0'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>p</name>++</expr>;</expr_stmt>
				<expr_stmt><expr><name>n</name>--</expr>;</expr_stmt>
			}</block></then></if>
			<expr_stmt><expr><call><name>strncpy</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>buf</name> += <name>n</name></expr>;</expr_stmt>
			<if>if <condition>(<expr><name>q</name> == <name>NULL</name></expr>)</condition><then>
				<break>break;</break></then></if>
			<expr_stmt><expr>*<name>buf</name>++ = <name>DELIM</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>p</name> = <name>q</name>+1</expr>;</expr_stmt>
		}</block></for>
	}</block></else></if>
	<if>if <condition>(<expr><name>argv0_path</name></expr>)</condition><then> <block>{
		<expr_stmt><expr>*<name>buf</name>++ = <name>DELIM</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>argv0_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>buf</name> = <call><name>strchr</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr>'\0'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>
	<expr_stmt><expr>*<name>buf</name> = '\0'</expr>;</expr_stmt>
}</block></function>


<comment type="block">/* External interface */</comment>

<function><type><name>char</name> *</type>
<name>Py_GetPath</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list>
<block>{
	<if>if <condition>(<expr>!<name>module_search_path</name></expr>)</condition><then>
		<expr_stmt><expr><call><name>calculate_path</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>

	<return>return <expr><name>module_search_path</name></expr>;</return>
}</block></function>

<function><type><name>char</name> *</type>
<name>Py_GetPrefix</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list>
<block>{
	<if>if <condition>(<expr>!<name>module_search_path</name></expr>)</condition><then>
		<expr_stmt><expr><call><name>calculate_path</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>

	<return>return <expr><name>prefix</name></expr>;</return>
}</block></function>

<function><type><name>char</name> *</type>
<name>Py_GetExecPrefix</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list>
<block>{
	<if>if <condition>(<expr>!<name>module_search_path</name></expr>)</condition><then>
		<expr_stmt><expr><call><name>calculate_path</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>

	<return>return <expr><name>exec_prefix</name></expr>;</return>
}</block></function>

<function><type><name>char</name> *</type>
<name>Py_GetProgramFullPath</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list>
<block>{
	<if>if <condition>(<expr>!<name>module_search_path</name></expr>)</condition><then>
		<expr_stmt><expr><call><name>calculate_path</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>

	<return>return <expr><name>progpath</name></expr>;</return>
}</block></function>
</unit>
