<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C" filename="projects/cpython-2.6.1/source/PC/getpathp.c">
<comment type="block">/* Return the initial module search path. */</comment>
<comment type="block">/* Used by DOS, OS/2, Windows 3.1, Windows 95/98, Windows NT. */</comment>

<comment type="block">/* ----------------------------------------------------------------
   PATH RULES FOR WINDOWS:
   This describes how sys.path is formed on Windows.  It describes the 
   functionality, not the implementation (ie, the order in which these 
   are actually fetched is different)

   * Python always adds an empty entry at the start, which corresponds
     to the current directory.

   * If the PYTHONPATH env. var. exists, its entries are added next.

   * We look in the registry for "application paths" - that is, sub-keys
     under the main PythonPath registry key.  These are added next (the
     order of sub-key processing is undefined).
     HKEY_CURRENT_USER is searched and added first.
     HKEY_LOCAL_MACHINE is searched and added next.
     (Note that all known installers only use HKLM, so HKCU is typically
     empty)

   * We attempt to locate the "Python Home" - if the PYTHONHOME env var
     is set, we believe it.  Otherwise, we use the path of our host .EXE's
     to try and locate our "landmark" (lib\\os.py) and deduce our home.
     - If we DO have a Python Home: The relevant sub-directories (Lib, 
       plat-win, lib-tk, etc) are based on the Python Home
     - If we DO NOT have a Python Home, the core Python Path is
       loaded from the registry.  This is the main PythonPath key, 
       and both HKLM and HKCU are combined to form the path)

   * Iff - we can not locate the Python Home, have not had a PYTHONPATH
     specified, and can't locate any Registry entries (ie, we have _nothing_
     we can assume is a good path), a default path with relative entries is 
     used (eg. .\Lib;.\plat-win, etc)


  The end result of all this is:
  * When running python.exe, or any other .exe in the main Python directory
    (either an installed version, or directly from the PCbuild directory),
    the core path is deduced, and the core paths in the registry are
    ignored.  Other "application paths" in the registry are always read.

  * When Python is hosted in another exe (different directory, embedded via 
    COM, etc), the Python Home will not be deduced, so the core path from
    the registry is used.  Other "application paths" in the registry are 
    always read.

  * If Python can't find its home and there is no registry (eg, frozen
    exe, some very strange installation setup) you get a path with
    some default, but relative, paths.

   ---------------------------------------------------------------- */</comment>


<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"Python.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"osdefs.h"</cpp:file></cpp:include>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>MS_WINDOWS</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;windows.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;tchar.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_SYS_TYPES_H</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/types.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* HAVE_SYS_TYPES_H */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_SYS_STAT_H</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/stat.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* HAVE_SYS_STAT_H */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string.h&gt;</cpp:file></cpp:include>

<comment type="block">/* Search in some common locations for the associated Python libraries.
 *
 * Py_GetPath() tries to return a sensible Python module search path.
 *
 * The approach is an adaptation for Windows of the strategy used in
 * ../Modules/getpath.c; it uses the Windows Registry as one of its
 * information sources.
 */</comment>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>LANDMARK</name></cpp:ifndef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LANDMARK</name></cpp:macro> <cpp:value>"lib\\os.py"</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name><name>prefix</name><index>[<expr><name>MAXPATHLEN</name>+1</expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name><name>progpath</name><index>[<expr><name>MAXPATHLEN</name>+1</expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name><name>dllpath</name><index>[<expr><name>MAXPATHLEN</name>+1</expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> *</type><name>module_search_path</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>


<function><type><specifier>static</specifier> <name>int</name></type>
<name>is_sep</name><parameter_list>(<param><decl><type><name>char</name></type> <name>ch</name></decl></param>)</parameter_list>	<comment type="block">/* determine if "ch" is a separator character */</comment>
<block>{
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>ALTSEP</name></cpp:ifdef>
	<return>return <expr><name>ch</name> == <name>SEP</name> || <name>ch</name> == <name>ALTSEP</name></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<return>return <expr><name>ch</name> == <name>SEP</name></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></function>

<comment type="block">/* assumes 'dir' null terminated in bounds.  Never writes
   beyond existing terminator.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>reduce</name><parameter_list>(<param><decl><type><name>char</name> *</type><name>dir</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>size_t</name></type> <name>i</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name>dir</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<while>while <condition>(<expr><name>i</name> &gt; 0 &amp;&amp; !<call><name>is_sep</name><argument_list>(<argument><expr><name><name>dir</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition>
		<expr_stmt><expr>--<name>i</name></expr>;</expr_stmt></while>
	<expr_stmt><expr><name><name>dir</name><index>[<expr><name>i</name></expr>]</index></name> = '\0'</expr>;</expr_stmt>
}</block></function>
	

<function><type><specifier>static</specifier> <name>int</name></type>
<name>exists</name><parameter_list>(<param><decl><type><name>char</name> *</type><name>filename</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type>struct <name>stat</name></type> <name>buf</name></decl>;</decl_stmt>
	<return>return <expr><call><name>stat</name><argument_list>(<argument><expr><name>filename</name></expr></argument>, <argument><expr>&amp;<name>buf</name></expr></argument>)</argument_list></call> == 0</expr>;</return>
}</block></function>

<comment type="block">/* Assumes 'filename' MAXPATHLEN+1 bytes long - 
   may extend 'filename' by one character.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>ismodule</name><parameter_list>(<param><decl><type><name>char</name> *</type><name>filename</name></decl></param>)</parameter_list>	<comment type="block">/* Is module -- check for .pyc/.pyo too */</comment>
<block>{
	<if>if <condition>(<expr><call><name>exists</name><argument_list>(<argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr>1</expr>;</return></then></if>

	<comment type="block">/* Check for the compiled version of prefix. */</comment>
	<if>if <condition>(<expr><call><name>strlen</name><argument_list>(<argument><expr><name>filename</name></expr></argument>)</argument_list></call> &lt; <name>MAXPATHLEN</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>strcat</name><argument_list>(<argument><expr><name>filename</name></expr></argument>, <argument><expr><name>Py_OptimizeFlag</name> ? "o" : "c"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><call><name>exists</name><argument_list>(<argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr>)</condition><then>
			<return>return <expr>1</expr>;</return></then></if>
	}</block></then></if>
	<return>return <expr>0</expr>;</return>
}</block></function>

<comment type="block">/* Add a path component, by appending stuff to buffer.
   buffer must have at least MAXPATHLEN + 1 bytes allocated, and contain a
   NUL-terminated string with no more than MAXPATHLEN characters (not counting
   the trailing NUL).  It's a fatal error if it contains a string longer than
   that (callers must be careful!).  If these requirements are met, it's
   guaranteed that buffer will still be a NUL-terminated string with no more
   than MAXPATHLEN characters at exit.  If stuff is too long, only as much of
   stuff as fits will be appended.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>join</name><parameter_list>(<param><decl><type><name>char</name> *</type><name>buffer</name></decl></param>, <param><decl><type><name>char</name> *</type><name>stuff</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>size_t</name></type> <name>n</name></decl>, <decl><type ref="prev"/><name>k</name></decl>;</decl_stmt>
	<if>if <condition>(<expr><call><name>is_sep</name><argument_list>(<argument><expr><name><name>stuff</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<expr_stmt><expr><name>n</name> = 0</expr>;</expr_stmt></then>
	<else>else <block>{
		<expr_stmt><expr><name>n</name> = <call><name>strlen</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>n</name> &gt; 0 &amp;&amp; !<call><name>is_sep</name><argument_list>(<argument><expr><name><name>buffer</name><index>[<expr><name>n</name>-1</expr>]</index></name></expr></argument>)</argument_list></call> &amp;&amp; <name>n</name> &lt; <name>MAXPATHLEN</name></expr>)</condition><then>
			<expr_stmt><expr><name><name>buffer</name><index>[<expr><name>n</name>++</expr>]</index></name> = <name>SEP</name></expr>;</expr_stmt></then></if>
	}</block></else></if>
	<if>if <condition>(<expr><name>n</name> &gt; <name>MAXPATHLEN</name></expr>)</condition><then>
		<expr_stmt><expr><call><name>Py_FatalError</name><argument_list>(<argument><expr>"buffer overflow in getpathp.c's joinpath()"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
	<expr_stmt><expr><name>k</name> = <call><name>strlen</name><argument_list>(<argument><expr><name>stuff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>n</name> + <name>k</name> &gt; <name>MAXPATHLEN</name></expr>)</condition><then>
		<expr_stmt><expr><name>k</name> = <name>MAXPATHLEN</name> - <name>n</name></expr>;</expr_stmt></then></if>
	<expr_stmt><expr><call><name>strncpy</name><argument_list>(<argument><expr><name>buffer</name>+<name>n</name></expr></argument>, <argument><expr><name>stuff</name></expr></argument>, <argument><expr><name>k</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>buffer</name><index>[<expr><name>n</name>+<name>k</name></expr>]</index></name> = '\0'</expr>;</expr_stmt>
}</block></function>

<comment type="block">/* gotlandmark only called by search_for_prefix, which ensures
   'prefix' is null terminated in bounds.  join() ensures
   'landmark' can not overflow prefix if too long.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>gotlandmark</name><parameter_list>(<param><decl><type><name>char</name> *</type><name>landmark</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>int</name></type> <name>ok</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>n</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>n</name> = <call><name>strlen</name><argument_list>(<argument><expr><name>prefix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>join</name><argument_list>(<argument><expr><name>prefix</name></expr></argument>, <argument><expr><name>landmark</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>ok</name> = <call><name>ismodule</name><argument_list>(<argument><expr><name>prefix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>prefix</name><index>[<expr><name>n</name></expr>]</index></name> = '\0'</expr>;</expr_stmt>
	<return>return <expr><name>ok</name></expr>;</return>
}</block></function>

<comment type="block">/* assumes argv0_path is MAXPATHLEN+1 bytes long, already \0 term'd. 
   assumption provided by only caller, calculate_path() */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>search_for_prefix</name><parameter_list>(<param><decl><type><name>char</name> *</type><name>argv0_path</name></decl></param>, <param><decl><type><name>char</name> *</type><name>landmark</name></decl></param>)</parameter_list>
<block>{
	<comment type="block">/* Search from argv0_path, until landmark is found */</comment>
	<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>prefix</name></expr></argument>, <argument><expr><name>argv0_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<do>do <block>{
		<if>if <condition>(<expr><call><name>gotlandmark</name><argument_list>(<argument><expr><name>landmark</name></expr></argument>)</argument_list></call></expr>)</condition><then>
			<return>return <expr>1</expr>;</return></then></if>
		<expr_stmt><expr><call><name>reduce</name><argument_list>(<argument><expr><name>prefix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block> while <condition>(<expr><name><name>prefix</name><index>[<expr>0</expr>]</index></name></expr>)</condition>;</do>
	<return>return <expr>0</expr>;</return>
}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>MS_WINDOWS</name></cpp:ifdef>

<comment type="block">/* a string loaded from the DLL at startup.*/</comment>
<decl_stmt><decl><type><specifier>extern</specifier> <specifier>const</specifier> <name>char</name> *</type><name>PyWin_DLLVersionString</name></decl>;</decl_stmt>


<comment type="block">/* Load a PYTHONPATH value from the registry.
   Load from either HKEY_LOCAL_MACHINE or HKEY_CURRENT_USER.

   Works in both Unicode and 8bit environments.  Only uses the
   Ex family of functions so it also works with Windows CE.

   Returns NULL, or a pointer that should be freed.

   XXX - this code is pretty strange, as it used to also
   work on Win16, where the buffer sizes werent available
   in advance.  It could be simplied now Win16/Win32s is dead!
*/</comment>

<function><type><specifier>static</specifier> <name>char</name> *</type>
<name>getpythonregpath</name><parameter_list>(<param><decl><type><name>HKEY</name></type> <name>keyBase</name></decl></param>, <param><decl><type><name>int</name></type> <name>skipcore</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>HKEY</name></type> <name>newKey</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>DWORD</name></type> <name>dataSize</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>DWORD</name></type> <name>numKeys</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LONG</name></type> <name>rc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> *</type><name>retval</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TCHAR</name> *</type><name>dataBuf</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>TCHAR</name></type> <name><name>keyPrefix</name><index>[]</index></name> <init>= <expr><call><name>_T</name><argument_list>(<argument><expr>"Software\\Python\\PythonCore\\"</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>TCHAR</name></type> <name><name>keySuffix</name><index>[]</index></name> <init>= <expr><call><name>_T</name><argument_list>(<argument><expr>"\\PythonPath"</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>size_t</name></type> <name>versionLen</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>DWORD</name></type> <name>index</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TCHAR</name> *</type><name>keyBuf</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TCHAR</name> *</type><name>keyBufPtr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TCHAR</name> **</type><name>ppPaths</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Tried to use sysget("winver") but here is too early :-( */</comment>
	<expr_stmt><expr><name>versionLen</name> = <call><name>_tcslen</name><argument_list>(<argument><expr><name>PyWin_DLLVersionString</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Space for all the chars, plus one \0 */</comment>
	<expr_stmt><expr><name>keyBuf</name> = <name>keyBufPtr</name> = <call><name>malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>keyPrefix</name></expr></argument>)</argument_list></sizeof> + 
		                    <sizeof>sizeof<argument_list>(<argument><expr><name>TCHAR</name></expr></argument>)</argument_list></sizeof>*(<name>versionLen</name>-1) + 
				    <sizeof>sizeof<argument_list>(<argument><expr><name>keySuffix</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>keyBuf</name>==<name>NULL</name></expr>)</condition><then> <goto>goto <name>done</name>;</goto></then></if>

	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>keyBufPtr</name></expr></argument>, <argument><expr><name>keyPrefix</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>keyPrefix</name></expr></argument>)</argument_list></sizeof>-<sizeof>sizeof<argument_list>(<argument><expr><name>TCHAR</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>keyBufPtr</name> += <sizeof>sizeof<argument_list>(<argument><expr><name>keyPrefix</name></expr></argument>)</argument_list></sizeof>/<sizeof>sizeof<argument_list>(<argument><expr><name>TCHAR</name></expr></argument>)</argument_list></sizeof> - 1</expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>keyBufPtr</name></expr></argument>, <argument><expr><name>PyWin_DLLVersionString</name></expr></argument>, <argument><expr><name>versionLen</name> * <sizeof>sizeof<argument_list>(<argument><expr><name>TCHAR</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>keyBufPtr</name> += <name>versionLen</name></expr>;</expr_stmt>
	<comment type="block">/* NULL comes with this one! */</comment>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>keyBufPtr</name></expr></argument>, <argument><expr><name>keySuffix</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>keySuffix</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Open the root Python key */</comment>
	<expr_stmt><expr><name>rc</name>=<call><name>RegOpenKeyEx</name><argument_list>(<argument><expr><name>keyBase</name></expr></argument>,
	                <argument><expr><name>keyBuf</name></expr></argument>, <comment type="block">/* subkey */</comment>
	                <argument><expr>0</expr></argument>, <comment type="block">/* reserved */</comment>
	                <argument><expr><name>KEY_READ</name></expr></argument>,
	                <argument><expr>&amp;<name>newKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>rc</name>!=<name>ERROR_SUCCESS</name></expr>)</condition><then> <goto>goto <name>done</name>;</goto></then></if>
	<comment type="block">/* Find out how big our core buffer is, and how many subkeys we have */</comment>
	<expr_stmt><expr><name>rc</name> = <call><name>RegQueryInfoKey</name><argument_list>(<argument><expr><name>newKey</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr>&amp;<name>numKeys</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, 
	                <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr>&amp;<name>dataSize</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>rc</name>!=<name>ERROR_SUCCESS</name></expr>)</condition><then> <goto>goto <name>done</name>;</goto></then></if>
	<if>if <condition>(<expr><name>skipcore</name></expr>)</condition><then> <expr_stmt><expr><name>dataSize</name> = 0</expr>;</expr_stmt></then></if> <comment type="block">/* Only count core ones if we want them! */</comment>
	<comment type="block">/* Allocate a temp array of char buffers, so we only need to loop 
	   reading the registry once
	*/</comment>
	<expr_stmt><expr><name>ppPaths</name> = <call><name>malloc</name><argument_list>( <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>TCHAR</name> *</expr></argument>)</argument_list></sizeof> * <name>numKeys</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>ppPaths</name>==<name>NULL</name></expr>)</condition><then> <goto>goto <name>done</name>;</goto></then></if>
	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>ppPaths</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>TCHAR</name> *</expr></argument>)</argument_list></sizeof> * <name>numKeys</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Loop over all subkeys, allocating a temp sub-buffer. */</comment>
	<for>for(<init><expr><name>index</name>=0</expr>;</init><condition><expr><name>index</name>&lt;<name>numKeys</name></expr>;</condition><incr><expr><name>index</name>++</expr></incr>) <block>{
		<decl_stmt><decl><type><name>TCHAR</name></type> <name><name>keyBuf</name><index>[<expr><name>MAX_PATH</name>+1</expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>HKEY</name></type> <name>subKey</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>DWORD</name></type> <name>reqdSize</name> <init>= <expr><name>MAX_PATH</name>+1</expr></init></decl>;</decl_stmt>
		<comment type="block">/* Get the sub-key name */</comment>
		<decl_stmt><decl><type><name>DWORD</name></type> <name>rc</name> <init>= <expr><call><name>RegEnumKeyEx</name><argument_list>(<argument><expr><name>newKey</name></expr></argument>, <argument><expr><name>index</name></expr></argument>, <argument><expr><name>keyBuf</name></expr></argument>, <argument><expr>&amp;<name>reqdSize</name></expr></argument>,
		                        <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument> )</argument_list></call></expr></init></decl>;</decl_stmt>
		<if>if <condition>(<expr><name>rc</name>!=<name>ERROR_SUCCESS</name></expr>)</condition><then> <goto>goto <name>done</name>;</goto></then></if>
		<comment type="block">/* Open the sub-key */</comment>
		<expr_stmt><expr><name>rc</name>=<call><name>RegOpenKeyEx</name><argument_list>(<argument><expr><name>newKey</name></expr></argument>,
						<argument><expr><name>keyBuf</name></expr></argument>, <comment type="block">/* subkey */</comment>
						<argument><expr>0</expr></argument>, <comment type="block">/* reserved */</comment>
						<argument><expr><name>KEY_READ</name></expr></argument>,
						<argument><expr>&amp;<name>subKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>rc</name>!=<name>ERROR_SUCCESS</name></expr>)</condition><then> <goto>goto <name>done</name>;</goto></then></if>
		<comment type="block">/* Find the value of the buffer size, malloc, then read it */</comment>
		<expr_stmt><expr><call><name>RegQueryValueEx</name><argument_list>(<argument><expr><name>subKey</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr>&amp;<name>reqdSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>reqdSize</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><name><name>ppPaths</name><index>[<expr><name>index</name></expr>]</index></name> = <call><name>malloc</name><argument_list>(<argument><expr><name>reqdSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><name><name>ppPaths</name><index>[<expr><name>index</name></expr>]</index></name></expr>)</condition><then> <block>{
				<expr_stmt><expr><call><name>RegQueryValueEx</name><argument_list>(<argument><expr><name>subKey</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>NULL</name></expr></argument>, 
				                <argument><expr>(<name>LPBYTE</name>)<name><name>ppPaths</name><index>[<expr><name>index</name></expr>]</index></name></expr></argument>, 
				                <argument><expr>&amp;<name>reqdSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>dataSize</name> += <name>reqdSize</name> + 1</expr>;</expr_stmt> <comment type="block">/* 1 for the ";" */</comment>
			}</block></then></if>
		}</block></then></if>
		<expr_stmt><expr><call><name>RegCloseKey</name><argument_list>(<argument><expr><name>subKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></for>

	<comment type="block">/* return null if no path to return */</comment>
	<if>if <condition>(<expr><name>dataSize</name> == 0</expr>)</condition><then> <goto>goto <name>done</name>;</goto></then></if>

	<comment type="block">/* original datasize from RegQueryInfo doesn't include the \0 */</comment>
	<expr_stmt><expr><name>dataBuf</name> = <call><name>malloc</name><argument_list>(<argument><expr>(<name>dataSize</name>+1) * <sizeof>sizeof<argument_list>(<argument><expr><name>TCHAR</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>dataBuf</name></expr>)</condition><then> <block>{
		<decl_stmt><decl><type><name>TCHAR</name> *</type><name>szCur</name> <init>= <expr><name>dataBuf</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>DWORD</name></type> <name>reqdSize</name> <init>= <expr><name>dataSize</name></expr></init></decl>;</decl_stmt>
		<comment type="block">/* Copy our collected strings */</comment>
		<for>for (<init><expr><name>index</name>=0</expr>;</init><condition><expr><name>index</name>&lt;<name>numKeys</name></expr>;</condition><incr><expr><name>index</name>++</expr></incr>) <block>{
			<if>if <condition>(<expr><name>index</name> &gt; 0</expr>)</condition><then> <block>{
				<expr_stmt><expr>*(<name>szCur</name>++) = <call><name>_T</name><argument_list>(<argument><expr>';'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>dataSize</name>--</expr>;</expr_stmt>
			}</block></then></if>
			<if>if <condition>(<expr><name><name>ppPaths</name><index>[<expr><name>index</name></expr>]</index></name></expr>)</condition><then> <block>{
				<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>len</name> <init>= <expr><call><name>_tcslen</name><argument_list>(<argument><expr><name><name>ppPaths</name><index>[<expr><name>index</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<expr_stmt><expr><call><name>_tcsncpy</name><argument_list>(<argument><expr><name>szCur</name></expr></argument>, <argument><expr><name><name>ppPaths</name><index>[<expr><name>index</name></expr>]</index></name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>szCur</name> += <name>len</name></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>dataSize</name> &gt; (<name>DWORD</name>)<name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>dataSize</name> -= (<name>DWORD</name>)<name>len</name></expr>;</expr_stmt>
			}</block></then></if>
		}</block></for>
		<if>if <condition>(<expr><name>skipcore</name></expr>)</condition><then>
			<expr_stmt><expr>*<name>szCur</name> = '\0'</expr>;</expr_stmt></then>
		<else>else <block>{
			<comment type="block">/* If we have no values, we dont need a ';' */</comment>
			<if>if <condition>(<expr><name>numKeys</name></expr>)</condition><then> <block>{
				<expr_stmt><expr>*(<name>szCur</name>++) = <call><name>_T</name><argument_list>(<argument><expr>';'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>dataSize</name>--</expr>;</expr_stmt>
			}</block></then></if>
			<comment type="block">/* Now append the core path entries - 
			   this will include the NULL 
			*/</comment>
			<expr_stmt><expr><name>rc</name> = <call><name>RegQueryValueEx</name><argument_list>(<argument><expr><name>newKey</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>NULL</name></expr></argument>, 
			                     <argument><expr>(<name>LPBYTE</name>)<name>szCur</name></expr></argument>, <argument><expr>&amp;<name>dataSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></else></if>
		<comment type="block">/* And set the result - caller must free 
		   If MBCS, it is fine as is.  If Unicode, allocate new
		   buffer and convert.
		*/</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>UNICODE</name></cpp:ifdef>
		<expr_stmt><expr><name>retval</name> = (<name>char</name> *)<call><name>malloc</name><argument_list>(<argument><expr><name>reqdSize</name>+1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>retval</name></expr>)</condition><then>
			<expr_stmt><expr><call><name>WideCharToMultiByte</name><argument_list>(<argument><expr><name>CP_ACP</name></expr></argument>, <argument><expr>0</expr></argument>, 
					<argument><expr><name>dataBuf</name></expr></argument>, <argument><expr>-1</expr></argument>, <comment type="block">/* source */</comment> 
					<argument><expr><name>retval</name></expr></argument>, <argument><expr><name>reqdSize</name>+1</expr></argument>, <comment type="block">/* dest */</comment>
					<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>dataBuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
		<expr_stmt><expr><name>retval</name> = <name>dataBuf</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	}</block></then></if>
<label><name>done</name>:</label>
	<comment type="block">/* Loop freeing my temp buffers */</comment>
	<if>if <condition>(<expr><name>ppPaths</name></expr>)</condition><then> <block>{
		<for>for(<init><expr><name>index</name>=0</expr>;</init><condition><expr><name>index</name>&lt;<name>numKeys</name></expr>;</condition><incr><expr><name>index</name>++</expr></incr>)
			<if>if <condition>(<expr><name><name>ppPaths</name><index>[<expr><name>index</name></expr>]</index></name></expr>)</condition><then> <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>ppPaths</name><index>[<expr><name>index</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if></for>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>ppPaths</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>
	<if>if <condition>(<expr><name>newKey</name></expr>)</condition><then>
		<expr_stmt><expr><call><name>RegCloseKey</name><argument_list>(<argument><expr><name>newKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
	<if>if <condition>(<expr><name>keyBuf</name></expr>)</condition><then>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>keyBuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
	<return>return <expr><name>retval</name></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* MS_WINDOWS */</comment>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>get_progpath</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list>
<block>{
	<function_decl><type><specifier>extern</specifier> <name>char</name> *</type><name>Py_GetProgramName</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list>;</function_decl>
	<decl_stmt><decl><type><name>char</name> *</type><name>path</name> <init>= <expr><call><name>getenv</name><argument_list>(<argument><expr>"PATH"</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> *</type><name>prog</name> <init>= <expr><call><name>Py_GetProgramName</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>MS_WINDOWS</name></cpp:ifdef>
	<decl_stmt><decl><type><specifier>extern</specifier> <name>HANDLE</name></type> <name>PyWin_DLLhModule</name></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>UNICODE</name></cpp:ifdef>
	<decl_stmt><decl><type><name>WCHAR</name></type> <name><name>wprogpath</name><index>[<expr><name>MAXPATHLEN</name>+1</expr>]</index></name></decl>;</decl_stmt>
	<comment type="block">/* Windows documents that GetModuleFileName() will "truncate",
	   but makes no mention of the null terminator.  Play it safe.
	   PLUS Windows itself defines MAX_PATH as the same, but anyway...
	*/</comment>
	<expr_stmt><expr><name><name>wprogpath</name><index>[<expr><name>MAXPATHLEN</name></expr>]</index></name>=<call><name>_T</name><argument_list>(<argument><expr>'\0'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>PyWin_DLLhModule</name> &amp;&amp;
	    <call><name>GetModuleFileName</name><argument_list>(<argument><expr><name>PyWin_DLLhModule</name></expr></argument>, <argument><expr><name>wprogpath</name></expr></argument>, <argument><expr><name>MAXPATHLEN</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>WideCharToMultiByte</name><argument_list>(<argument><expr><name>CP_ACP</name></expr></argument>, <argument><expr>0</expr></argument>, 
		                    <argument><expr><name>wprogpath</name></expr></argument>, <argument><expr>-1</expr></argument>, 
		                    <argument><expr><name>dllpath</name></expr></argument>, <argument><expr><name>MAXPATHLEN</name>+1</expr></argument>, 
		                    <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>
	<expr_stmt><expr><name><name>wprogpath</name><index>[<expr><name>MAXPATHLEN</name></expr>]</index></name>=<call><name>_T</name><argument_list>(<argument><expr>'\0'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><call><name>GetModuleFileName</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>wprogpath</name></expr></argument>, <argument><expr><name>MAXPATHLEN</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>WideCharToMultiByte</name><argument_list>(<argument><expr><name>CP_ACP</name></expr></argument>, <argument><expr>0</expr></argument>, 
		                    <argument><expr><name>wprogpath</name></expr></argument>, <argument><expr>-1</expr></argument>, 
		                    <argument><expr><name>progpath</name></expr></argument>, <argument><expr><name>MAXPATHLEN</name>+1</expr></argument>, 
		                    <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	}</block></then></if>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<comment type="block">/* static init of progpath ensures final char remains \0 */</comment>
	<if>if <condition>(<expr><name>PyWin_DLLhModule</name></expr>)</condition><then>
		<if>if <condition>(<expr>!<call><name>GetModuleFileName</name><argument_list>(<argument><expr><name>PyWin_DLLhModule</name></expr></argument>, <argument><expr><name>dllpath</name></expr></argument>, <argument><expr><name>MAXPATHLEN</name></expr></argument>)</argument_list></call></expr>)</condition><then>
			<expr_stmt><expr><name><name>dllpath</name><index>[<expr>0</expr>]</index></name> = 0</expr>;</expr_stmt></then></if></then></if>
	<if>if <condition>(<expr><call><name>GetModuleFileName</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>progpath</name></expr></argument>, <argument><expr><name>MAXPATHLEN</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return;</return></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<if>if <condition>(<expr><name>prog</name> == <name>NULL</name> || *<name>prog</name> == '\0'</expr>)</condition><then>
		<expr_stmt><expr><name>prog</name> = "python"</expr>;</expr_stmt></then></if>

	<comment type="block">/* If there is no slash in the argv0 path, then we have to
	 * assume python is on the user's $PATH, since there's no
	 * other way to find a directory to start the search from.  If
	 * $PATH isn't exported, you lose.
	 */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>ALTSEP</name></cpp:ifdef>
	<if>if <condition>(<expr><call><name>strchr</name><argument_list>(<argument><expr><name>prog</name></expr></argument>, <argument><expr><name>SEP</name></expr></argument>)</argument_list></call> || <call><name>strchr</name><argument_list>(<argument><expr><name>prog</name></expr></argument>, <argument><expr><name>ALTSEP</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<if>if <condition>(<expr><call><name>strchr</name><argument_list>(<argument><expr><name>prog</name></expr></argument>, <argument><expr><name>SEP</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		<expr_stmt><expr><call><name>strncpy</name><argument_list>(<argument><expr><name>progpath</name></expr></argument>, <argument><expr><name>prog</name></expr></argument>, <argument><expr><name>MAXPATHLEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
	<else>else <if>if <condition>(<expr><name>path</name></expr>)</condition><then> <block>{
		<while>while <condition>(<expr>1</expr>)</condition> <block>{
			<decl_stmt><decl><type><name>char</name> *</type><name>delim</name> <init>= <expr><call><name>strchr</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>DELIM</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if>if <condition>(<expr><name>delim</name></expr>)</condition><then> <block>{
				<decl_stmt><decl><type><name>size_t</name></type> <name>len</name> <init>= <expr><name>delim</name> - <name>path</name></expr></init></decl>;</decl_stmt>
				<comment type="block">/* ensure we can't overwrite buffer */</comment>
				<expr_stmt><expr><name>len</name> = <call><name>min</name><argument_list>(<argument><expr><name>MAXPATHLEN</name></expr></argument>,<argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>strncpy</name><argument_list>(<argument><expr><name>progpath</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr>*(<name>progpath</name> + <name>len</name>) = '\0'</expr>;</expr_stmt>
			}</block></then>
			<else>else
				<expr_stmt><expr><call><name>strncpy</name><argument_list>(<argument><expr><name>progpath</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>MAXPATHLEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>

			<comment type="block">/* join() is safe for MAXPATHLEN+1 size buffer */</comment>
			<expr_stmt><expr><call><name>join</name><argument_list>(<argument><expr><name>progpath</name></expr></argument>, <argument><expr><name>prog</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><call><name>exists</name><argument_list>(<argument><expr><name>progpath</name></expr></argument>)</argument_list></call></expr>)</condition><then>
				<break>break;</break></then></if>

			<if>if <condition>(<expr>!<name>delim</name></expr>)</condition><then> <block>{
				<expr_stmt><expr><name><name>progpath</name><index>[<expr>0</expr>]</index></name> = '\0'</expr>;</expr_stmt>
				<break>break;</break>
			}</block></then></if>
			<expr_stmt><expr><name>path</name> = <name>delim</name> + 1</expr>;</expr_stmt>
		}</block></while>
	}</block></then>
	<else>else
		<expr_stmt><expr><name><name>progpath</name><index>[<expr>0</expr>]</index></name> = '\0'</expr>;</expr_stmt></else></if></else></if></then></if>
}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>calculate_path</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>char</name></type> <name><name>argv0_path</name><index>[<expr><name>MAXPATHLEN</name>+1</expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> *</type><name>buf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>size_t</name></type> <name>bufsz</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> *</type><name>pythonhome</name> <init>= <expr><call><name>Py_GetPythonHome</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> *</type><name>envpath</name> <init>= <expr><call><name>Py_GETENV</name><argument_list>(<argument><expr>"PYTHONPATH"</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>MS_WINDOWS</name></cpp:ifdef>
	<decl_stmt><decl><type><name>int</name></type> <name>skiphome</name></decl>, <decl><type ref="prev"/><name>skipdefault</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> *</type><name>machinepath</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> *</type><name>userpath</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type> <name><name>zip_path</name><index>[<expr><name>MAXPATHLEN</name>+1</expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>size_t</name></type> <name>len</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<expr_stmt><expr><call><name>get_progpath</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* progpath guaranteed \0 terminated in MAXPATH+1 bytes. */</comment>
	<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>argv0_path</name></expr></argument>, <argument><expr><name>progpath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>reduce</name><argument_list>(<argument><expr><name>argv0_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>pythonhome</name> == <name>NULL</name> || *<name>pythonhome</name> == '\0'</expr>)</condition><then> <block>{
		<if>if <condition>(<expr><call><name>search_for_prefix</name><argument_list>(<argument><expr><name>argv0_path</name></expr></argument>, <argument><expr><name>LANDMARK</name></expr></argument>)</argument_list></call></expr>)</condition><then>
			<expr_stmt><expr><name>pythonhome</name> = <name>prefix</name></expr>;</expr_stmt></then>
		<else>else
			<expr_stmt><expr><name>pythonhome</name> = <name>NULL</name></expr>;</expr_stmt></else></if>
	}</block></then>
	<else>else
		<expr_stmt><expr><call><name>strncpy</name><argument_list>(<argument><expr><name>prefix</name></expr></argument>, <argument><expr><name>pythonhome</name></expr></argument>, <argument><expr><name>MAXPATHLEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>

	<if>if <condition>(<expr><name>envpath</name> &amp;&amp; *<name>envpath</name> == '\0'</expr>)</condition><then>
		<expr_stmt><expr><name>envpath</name> = <name>NULL</name></expr>;</expr_stmt></then></if>


<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>MS_WINDOWS</name></cpp:ifdef>
	<comment type="block">/* Calculate zip archive path */</comment>
	<if>if <condition>(<expr><name><name>dllpath</name><index>[<expr>0</expr>]</index></name></expr>)</condition><then>		<comment type="block">/* use name of python DLL */</comment>
		<expr_stmt><expr><call><name>strncpy</name><argument_list>(<argument><expr><name>zip_path</name></expr></argument>, <argument><expr><name>dllpath</name></expr></argument>, <argument><expr><name>MAXPATHLEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
	<else>else			<comment type="block">/* use name of executable program */</comment>
		<expr_stmt><expr><call><name>strncpy</name><argument_list>(<argument><expr><name>zip_path</name></expr></argument>, <argument><expr><name>progpath</name></expr></argument>, <argument><expr><name>MAXPATHLEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
	<expr_stmt><expr><name><name>zip_path</name><index>[<expr><name>MAXPATHLEN</name></expr>]</index></name> = '\0'</expr>;</expr_stmt>
	<expr_stmt><expr><name>len</name> = <call><name>strlen</name><argument_list>(<argument><expr><name>zip_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>len</name> &gt; 4</expr>)</condition><then> <block>{
		<expr_stmt><expr><name><name>zip_path</name><index>[<expr><name>len</name>-3</expr>]</index></name> = 'z'</expr>;</expr_stmt>	<comment type="block">/* change ending to "zip" */</comment>
		<expr_stmt><expr><name><name>zip_path</name><index>[<expr><name>len</name>-2</expr>]</index></name> = 'i'</expr>;</expr_stmt>
		<expr_stmt><expr><name><name>zip_path</name><index>[<expr><name>len</name>-1</expr>]</index></name> = 'p'</expr>;</expr_stmt>
	}</block></then>
	<else>else <block>{
		<expr_stmt><expr><name><name>zip_path</name><index>[<expr>0</expr>]</index></name> = 0</expr>;</expr_stmt>
	}</block></else></if>
 
	<expr_stmt><expr><name>skiphome</name> = <name>pythonhome</name>==<name>NULL</name> ? 0 : 1</expr>;</expr_stmt>
	<expr_stmt><expr><name>machinepath</name> = <call><name>getpythonregpath</name><argument_list>(<argument><expr><name>HKEY_LOCAL_MACHINE</name></expr></argument>, <argument><expr><name>skiphome</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>userpath</name> = <call><name>getpythonregpath</name><argument_list>(<argument><expr><name>HKEY_CURRENT_USER</name></expr></argument>, <argument><expr><name>skiphome</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* We only use the default relative PYTHONPATH if we havent
	   anything better to use! */</comment>
	<expr_stmt><expr><name>skipdefault</name> = <name>envpath</name>!=<name>NULL</name> || <name>pythonhome</name>!=<name>NULL</name> || \
		      <name>machinepath</name>!=<name>NULL</name> || <name>userpath</name>!=<name>NULL</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<comment type="block">/* We need to construct a path from the following parts.
	   (1) the PYTHONPATH environment variable, if set;
	   (2) for Win32, the zip archive file path;
	   (3) for Win32, the machinepath and userpath, if set;
	   (4) the PYTHONPATH config macro, with the leading "."
	       of each component replaced with pythonhome, if set;
	   (5) the directory containing the executable (argv0_path).
	   The length calculation calculates #4 first.
	   Extra rules:
	   - If PYTHONHOME is set (in any way) item (3) is ignored.
	   - If registry values are used, (4) and (5) are ignored.
	*/</comment>

	<comment type="block">/* Calculate size of return buffer */</comment>
	<if>if <condition>(<expr><name>pythonhome</name> != <name>NULL</name></expr>)</condition><then> <block>{
		<decl_stmt><decl><type><name>char</name> *</type><name>p</name></decl>;</decl_stmt>
		<expr_stmt><expr><name>bufsz</name> = 1</expr>;</expr_stmt>	
		<for>for (<init><expr><name>p</name> = <name>PYTHONPATH</name></expr>;</init> <condition><expr>*<name>p</name></expr>;</condition> <incr><expr><name>p</name>++</expr></incr>) <block>{
			<if>if <condition>(<expr>*<name>p</name> == <name>DELIM</name></expr>)</condition><then>
				<expr_stmt><expr><name>bufsz</name>++</expr>;</expr_stmt></then></if> <comment type="block">/* number of DELIM plus one */</comment>
		}</block></for>
		<expr_stmt><expr><name>bufsz</name> *= <call><name>strlen</name><argument_list>(<argument><expr><name>pythonhome</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then>
	<else>else
		<expr_stmt><expr><name>bufsz</name> = 0</expr>;</expr_stmt></else></if>
	<expr_stmt><expr><name>bufsz</name> += <call><name>strlen</name><argument_list>(<argument><expr><name>PYTHONPATH</name></expr></argument>)</argument_list></call> + 1</expr>;</expr_stmt>
	<expr_stmt><expr><name>bufsz</name> += <call><name>strlen</name><argument_list>(<argument><expr><name>argv0_path</name></expr></argument>)</argument_list></call> + 1</expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>MS_WINDOWS</name></cpp:ifdef>
	<if>if <condition>(<expr><name>userpath</name></expr>)</condition><then>
		<expr_stmt><expr><name>bufsz</name> += <call><name>strlen</name><argument_list>(<argument><expr><name>userpath</name></expr></argument>)</argument_list></call> + 1</expr>;</expr_stmt></then></if>
	<if>if <condition>(<expr><name>machinepath</name></expr>)</condition><then>
		<expr_stmt><expr><name>bufsz</name> += <call><name>strlen</name><argument_list>(<argument><expr><name>machinepath</name></expr></argument>)</argument_list></call> + 1</expr>;</expr_stmt></then></if>
	<expr_stmt><expr><name>bufsz</name> += <call><name>strlen</name><argument_list>(<argument><expr><name>zip_path</name></expr></argument>)</argument_list></call> + 1</expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<if>if <condition>(<expr><name>envpath</name> != <name>NULL</name></expr>)</condition><then>
		<expr_stmt><expr><name>bufsz</name> += <call><name>strlen</name><argument_list>(<argument><expr><name>envpath</name></expr></argument>)</argument_list></call> + 1</expr>;</expr_stmt></then></if>

	<expr_stmt><expr><name>module_search_path</name> = <name>buf</name> = <call><name>malloc</name><argument_list>(<argument><expr><name>bufsz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>buf</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<comment type="block">/* We can't exit, so print a warning and limp along */</comment>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr>"Can't malloc dynamic PYTHONPATH.\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>envpath</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr>"Using environment $PYTHONPATH.\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>module_search_path</name> = <name>envpath</name></expr>;</expr_stmt>
		}</block></then>
		<else>else <block>{
			<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr>"Using default static path.\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>module_search_path</name> = <name>PYTHONPATH</name></expr>;</expr_stmt>
		}</block></else></if>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>MS_WINDOWS</name></cpp:ifdef>
		<if>if <condition>(<expr><name>machinepath</name></expr>)</condition><then>
			<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>machinepath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
		<if>if <condition>(<expr><name>userpath</name></expr>)</condition><then>
			<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>userpath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* MS_WINDOWS */</comment>
		<return>return;</return>
	}</block></then></if>

	<if>if <condition>(<expr><name>envpath</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>envpath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>buf</name> = <call><name>strchr</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr>'\0'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr>*<name>buf</name>++ = <name>DELIM</name></expr>;</expr_stmt>
	}</block></then></if>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>MS_WINDOWS</name></cpp:ifdef>
	<if>if <condition>(<expr><name><name>zip_path</name><index>[<expr>0</expr>]</index></name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>zip_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>buf</name> = <call><name>strchr</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr>'\0'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr>*<name>buf</name>++ = <name>DELIM</name></expr>;</expr_stmt>
	}</block></then></if>
	<if>if <condition>(<expr><name>userpath</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>userpath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>buf</name> = <call><name>strchr</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr>'\0'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr>*<name>buf</name>++ = <name>DELIM</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>userpath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>
	<if>if <condition>(<expr><name>machinepath</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>machinepath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>buf</name> = <call><name>strchr</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr>'\0'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr>*<name>buf</name>++ = <name>DELIM</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>machinepath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>
	<if>if <condition>(<expr><name>pythonhome</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<if>if <condition>(<expr>!<name>skipdefault</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>PYTHONPATH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>buf</name> = <call><name>strchr</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr>'\0'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></then></if>
	}</block></then></if>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<if>if <condition>(<expr><name>pythonhome</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>PYTHONPATH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>buf</name> = <call><name>strchr</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr>'\0'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* MS_WINDOWS */</comment>
	<else>else <block>{
		<decl_stmt><decl><type><name>char</name> *</type><name>p</name> <init>= <expr><name>PYTHONPATH</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name> *</type><name>q</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>size_t</name></type> <name>n</name></decl>;</decl_stmt>
		<for>for (<init>;</init><condition>;</condition><incr/>) <block>{
			<expr_stmt><expr><name>q</name> = <call><name>strchr</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>DELIM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><name>q</name> == <name>NULL</name></expr>)</condition><then>
				<expr_stmt><expr><name>n</name> = <call><name>strlen</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
			<else>else
				<expr_stmt><expr><name>n</name> = <name>q</name>-<name>p</name></expr>;</expr_stmt></else></if>
			<if>if <condition>(<expr><name><name>p</name><index>[<expr>0</expr>]</index></name> == '.' &amp;&amp; <call><name>is_sep</name><argument_list>(<argument><expr><name><name>p</name><index>[<expr>1</expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
				<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>pythonhome</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>buf</name> = <call><name>strchr</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr>'\0'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>p</name>++</expr>;</expr_stmt>
				<expr_stmt><expr><name>n</name>--</expr>;</expr_stmt>
			}</block></then></if>
			<expr_stmt><expr><call><name>strncpy</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>buf</name> += <name>n</name></expr>;</expr_stmt>
			<if>if <condition>(<expr><name>q</name> == <name>NULL</name></expr>)</condition><then>
				<break>break;</break></then></if>
			<expr_stmt><expr>*<name>buf</name>++ = <name>DELIM</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>p</name> = <name>q</name>+1</expr>;</expr_stmt>
		}</block></for>
	}</block></else></if>
	<if>if <condition>(<expr><name>argv0_path</name></expr>)</condition><then> <block>{
		<expr_stmt><expr>*<name>buf</name>++ = <name>DELIM</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>argv0_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>buf</name> = <call><name>strchr</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr>'\0'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>
	<expr_stmt><expr>*<name>buf</name> = '\0'</expr>;</expr_stmt>
	<comment type="block">/* Now to pull one last hack/trick.  If sys.prefix is
	   empty, then try and find it somewhere on the paths
	   we calculated.  We scan backwards, as our general policy
	   is that Python core directories are at the *end* of
	   sys.path.  We assume that our "lib" directory is
	   on the path, and that our 'prefix' directory is
	   the parent of that.
	*/</comment>
	<if>if <condition>(<expr>*<name>prefix</name>=='\0'</expr>)</condition><then> <block>{
		<decl_stmt><decl><type><name>char</name></type> <name><name>lookBuf</name><index>[<expr><name>MAXPATHLEN</name>+1</expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name> *</type><name>look</name> <init>= <expr><name>buf</name> - 1</expr></init></decl>;</decl_stmt> <comment type="block">/* 'buf' is at the end of the buffer */</comment>
		<while>while <condition>(<expr>1</expr>)</condition> <block>{
			<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>nchars</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>char</name> *</type><name>lookEnd</name> <init>= <expr><name>look</name></expr></init></decl>;</decl_stmt>
			<comment type="block">/* 'look' will end up one character before the
			   start of the path in question - even if this
			   is one character before the start of the buffer
			*/</comment>
			<while>while <condition>(<expr><name>look</name> &gt;= <name>module_search_path</name> &amp;&amp; *<name>look</name> != <name>DELIM</name></expr>)</condition>
				<expr_stmt><expr><name>look</name>--</expr>;</expr_stmt></while>
			<expr_stmt><expr><name>nchars</name> = <name>lookEnd</name>-<name>look</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>strncpy</name><argument_list>(<argument><expr><name>lookBuf</name></expr></argument>, <argument><expr><name>look</name>+1</expr></argument>, <argument><expr><name>nchars</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>lookBuf</name><index>[<expr><name>nchars</name></expr>]</index></name> = '\0'</expr>;</expr_stmt>
			<comment type="block">/* Up one level to the parent */</comment>
			<expr_stmt><expr><call><name>reduce</name><argument_list>(<argument><expr><name>lookBuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><call><name>search_for_prefix</name><argument_list>(<argument><expr><name>lookBuf</name></expr></argument>, <argument><expr><name>LANDMARK</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
				<break>break;</break>
			}</block></then></if>
			<comment type="block">/* If we are out of paths to search - give up */</comment>
			<if>if <condition>(<expr><name>look</name> &lt; <name>module_search_path</name></expr>)</condition><then>
				<break>break;</break></then></if>
			<expr_stmt><expr><name>look</name>--</expr>;</expr_stmt>
		}</block></while>
	}</block></then></if>
}</block></function>


<comment type="block">/* External interface */</comment>

<function><type><name>char</name> *</type>
<name>Py_GetPath</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list>
<block>{
	<if>if <condition>(<expr>!<name>module_search_path</name></expr>)</condition><then>
		<expr_stmt><expr><call><name>calculate_path</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>
	<return>return <expr><name>module_search_path</name></expr>;</return>
}</block></function>

<function><type><name>char</name> *</type>
<name>Py_GetPrefix</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list>
<block>{
	<if>if <condition>(<expr>!<name>module_search_path</name></expr>)</condition><then>
		<expr_stmt><expr><call><name>calculate_path</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>
	<return>return <expr><name>prefix</name></expr>;</return>
}</block></function>

<function><type><name>char</name> *</type>
<name>Py_GetExecPrefix</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list>
<block>{
	<return>return <expr><call><name>Py_GetPrefix</name><argument_list>()</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>char</name> *</type>
<name>Py_GetProgramFullPath</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list>
<block>{
	<if>if <condition>(<expr>!<name>module_search_path</name></expr>)</condition><then>
		<expr_stmt><expr><call><name>calculate_path</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>
	<return>return <expr><name>progpath</name></expr>;</return>
}</block></function>
</unit>
