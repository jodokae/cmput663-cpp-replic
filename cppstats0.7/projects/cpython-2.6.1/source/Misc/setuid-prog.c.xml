<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C" filename="projects/cpython-2.6.1/source/Misc/setuid-prog.c"><comment type="block">/*
   Template for a setuid program that calls a script.

   The script should be in an unwritable directory and should itself
   be unwritable.  In fact all parent directories up to the root
   should be unwritable.  The script must not be setuid, that's what
   this program is for.

   This is a template program.  You need to fill in the name of the
   script that must be executed.  This is done by changing the
   definition of FULL_PATH below.

   There are also some rules that should be adhered to when writing
   the script itself.

   The first and most important rule is to never, ever trust that the
   user of the program will behave properly.  Program defensively.
   Check your arguments for reasonableness.  If the user is allowed to
   create files, check the names of the files.  If the program depends
   on argv[0] for the action it should perform, check it.

   Assuming the script is a Bourne shell script, the first line of the
   script should be
	#!/bin/sh -
   The - is important, don't omit it.  If you're using esh, the first
   line should be
	#!/usr/local/bin/esh -f
   and for ksh, the first line should be
	#!/usr/local/bin/ksh -p
   The script should then set the variable IFS to the string
   consisting of &lt;space&gt;, &lt;tab&gt;, and &lt;newline&gt;.  After this (*not*
   before!), the PATH variable should be set to a reasonable value and
   exported.  Do not expect the PATH to have a reasonable value, so do
   not trust the old value of PATH.  You should then set the umask of
   the program by calling
	umask 077 # or 022 if you want the files to be readable
   If you plan to change directories, you should either unset CDPATH
   or set it to a good value.  Setting CDPATH to just ``.'' (dot) is a
   good idea.
   If, for some reason, you want to use csh, the first line should be
	#!/bin/csh -fb
   You should then set the path variable to something reasonable,
   without trusting the inherited path.  Here too, you should set the
   umask using the command
	umask 077 # or 022 if you want the files to be readable
*/</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;unistd.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdlib.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdio.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/types.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/stat.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string.h&gt;</cpp:file></cpp:include>

<comment type="block">/* CONFIGURATION SECTION */</comment>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>FULL_PATH</name></cpp:ifndef>	<comment type="block">/* so that this can be specified from the Makefile */</comment>
<comment type="block">/* Uncomment the following line:
#define FULL_PATH	"/full/path/of/script" 
* Then comment out the #error line. */</comment>
<cpp:error>#<cpp:directive>error</cpp:directive> "You must define FULL_PATH somewhere"</cpp:error>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>UMASK</name></cpp:ifndef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>UMASK</name></cpp:macro>		<cpp:value>077</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* END OF CONFIGURATION SECTION */</comment>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__STDC__</name></expr></argument>)</argument_list></call> &amp;&amp; <call><name>defined</name><argument_list>(<argument><expr><name>__sgi</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>environ</name></cpp:macro> <cpp:value>_environ</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* don't change def_IFS */</comment>
<decl_stmt><decl><type><name>char</name></type> <name><name>def_IFS</name><index>[]</index></name> <init>= <expr>"IFS= \t\n"</expr></init></decl>;</decl_stmt>
<comment type="block">/* you may want to change def_PATH, but you should really change it in */</comment>
<comment type="block">/* your script */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__sgi</name></cpp:ifdef>
<decl_stmt><decl><type><name>char</name></type> <name><name>def_PATH</name><index>[]</index></name> <init>= <expr>"PATH=/usr/bsd:/usr/bin:/bin:/usr/local/bin:/usr/sbin"</expr></init></decl>;</decl_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<decl_stmt><decl><type><name>char</name></type> <name><name>def_PATH</name><index>[]</index></name> <init>= <expr>"PATH=/usr/ucb:/usr/bin:/bin:/usr/local/bin"</expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<comment type="block">/* don't change def_CDPATH */</comment>
<decl_stmt><decl><type><name>char</name></type> <name><name>def_CDPATH</name><index>[]</index></name> <init>= <expr>"CDPATH=."</expr></init></decl>;</decl_stmt>
<comment type="block">/* don't change def_ENV */</comment>
<decl_stmt><decl><type><name>char</name></type> <name><name>def_ENV</name><index>[]</index></name> <init>= <expr>"ENV=:"</expr></init></decl>;</decl_stmt>

<comment type="block">/*
   This function changes all environment variables that start with LD_
   into variables that start with XD_.  This is important since we
   don't want the script that is executed to use any funny shared
   libraries.

   The other changes to the environment are, strictly speaking, not
   needed here.  They can safely be done in the script.  They are done
   here because we don't trust the script writer (just like the script
   writer shouldn't trust the user of the script).
   If IFS is set in the environment, set it to space,tab,newline.
   If CDPATH is set in the environment, set it to ``.''.
   Set PATH to a reasonable default.
*/</comment>
<function><type><name>void</name></type>
<name>clean_environ</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>char</name> **</type><name>p</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>extern</specifier> <name>char</name> **</type><name>environ</name></decl>;</decl_stmt>

	<for>for (<init><expr><name>p</name> = <name>environ</name></expr>;</init> <condition><expr>*<name>p</name></expr>;</condition> <incr><expr><name>p</name>++</expr></incr>) <block>{
		<if>if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr>*<name>p</name></expr></argument>, <argument><expr>"LD_"</expr></argument>, <argument><expr>3</expr></argument>)</argument_list></call> == 0</expr>)</condition><then>
			<expr_stmt><expr>**<name>p</name> = 'X'</expr>;</expr_stmt></then>
		<else>else <if>if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr>*<name>p</name></expr></argument>, <argument><expr>"_RLD"</expr></argument>, <argument><expr>4</expr></argument>)</argument_list></call> == 0</expr>)</condition><then>
			<expr_stmt><expr>**<name>p</name> = 'X'</expr>;</expr_stmt></then>
		<else>else <if>if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr>*<name>p</name></expr></argument>, <argument><expr>"PYTHON"</expr></argument>, <argument><expr>6</expr></argument>)</argument_list></call> == 0</expr>)</condition><then>
			<expr_stmt><expr>**<name>p</name> = 'X'</expr>;</expr_stmt></then>
		<else>else <if>if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr>*<name>p</name></expr></argument>, <argument><expr>"IFS="</expr></argument>, <argument><expr>4</expr></argument>)</argument_list></call> == 0</expr>)</condition><then>
			<expr_stmt><expr>*<name>p</name> = <name>def_IFS</name></expr>;</expr_stmt></then>
		<else>else <if>if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr>*<name>p</name></expr></argument>, <argument><expr>"CDPATH="</expr></argument>, <argument><expr>7</expr></argument>)</argument_list></call> == 0</expr>)</condition><then>
			<expr_stmt><expr>*<name>p</name> = <name>def_CDPATH</name></expr>;</expr_stmt></then>
		<else>else <if>if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr>*<name>p</name></expr></argument>, <argument><expr>"ENV="</expr></argument>, <argument><expr>4</expr></argument>)</argument_list></call> == 0</expr>)</condition><then>
			<expr_stmt><expr>*<name>p</name> = <name>def_ENV</name></expr>;</expr_stmt></then></if></else></if></else></if></else></if></else></if></else></if>
	}</block></for>
	<expr_stmt><expr><call><name>putenv</name><argument_list>(<argument><expr><name>def_PATH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><name>int</name></type>
<name>main</name><parameter_list>(<param><decl><type><name>int</name></type> <name>argc</name></decl></param>, <param><decl><type><name>char</name> **</type><name>argv</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type>struct <name>stat</name></type> <name>statb</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>gid_t</name></type> <name>egid</name> <init>= <expr><call><name>getegid</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uid_t</name></type> <name>euid</name> <init>= <expr><call><name>geteuid</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	   Sanity check #1.
	   This check should be made compile-time, but that's not possible.
	   If you're sure that you specified a full path name for FULL_PATH,
	   you can omit this check.
	*/</comment>
	<if>if <condition>(<expr><name><name>FULL_PATH</name><index>[<expr>0</expr>]</index></name> != '/'</expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr>"%s: %s is not a full path name\n"</expr></argument>, <argument><expr><name><name>argv</name><index>[<expr>0</expr>]</index></name></expr></argument>,
			<argument><expr><name>FULL_PATH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr>"You can only use this wrapper if you\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr>"compile it with an absolute path.\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>

	<comment type="block">/*
	   Sanity check #2.
	   Check that the owner of the script is equal to either the
	   effective uid or the super user.
	*/</comment>
	<if>if <condition>(<expr><call><name>stat</name><argument_list>(<argument><expr><name>FULL_PATH</name></expr></argument>, <argument><expr>&amp;<name>statb</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>perror</name><argument_list>(<argument><expr>"stat"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>
	<if>if <condition>(<expr><name><name>statb</name>.<name>st_uid</name></name> != 0 &amp;&amp; <name><name>statb</name>.<name>st_uid</name></name> != <name>euid</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr>"%s: %s has the wrong owner\n"</expr></argument>, <argument><expr><name><name>argv</name><index>[<expr>0</expr>]</index></name></expr></argument>,
			<argument><expr><name>FULL_PATH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr>"The script should be owned by root,\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr>"and shouldn't be writeable by anyone.\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>

	<if>if <condition>(<expr><call><name>setregid</name><argument_list>(<argument><expr><name>egid</name></expr></argument>, <argument><expr><name>egid</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
		<expr_stmt><expr><call><name>perror</name><argument_list>(<argument><expr>"setregid"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
	<if>if <condition>(<expr><call><name>setreuid</name><argument_list>(<argument><expr><name>euid</name></expr></argument>, <argument><expr><name>euid</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
		<expr_stmt><expr><call><name>perror</name><argument_list>(<argument><expr>"setreuid"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

	<expr_stmt><expr><call><name>clean_environ</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>umask</name><argument_list>(<argument><expr><name>UMASK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<while>while <condition>(<expr>**<name>argv</name> == '-'</expr>)</condition>	<comment type="block">/* don't let argv[0] start with '-' */</comment>
		<expr_stmt><expr>(*<name>argv</name>)++</expr>;</expr_stmt></while>
	<expr_stmt><expr><call><name>execv</name><argument_list>(<argument><expr><name>FULL_PATH</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr>"%s: could not execute the script\n"</expr></argument>, <argument><expr><name><name>argv</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>
</unit>
