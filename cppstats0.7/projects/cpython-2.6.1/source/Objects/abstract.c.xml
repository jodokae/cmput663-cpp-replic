<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C" filename="projects/cpython-2.6.1/source/Objects/abstract.c"><comment type="block">/* Abstract Object Interface (many thanks to Jim Fulton) */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"Python.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;ctype.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"structmember.h"</cpp:file></cpp:include> <comment type="block">/* we need the offsetof() macro from there */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"longintrepr.h"</cpp:file></cpp:include>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NEW_STYLE_NUMBER</name><parameter_list>(<param><type><name>o</name></type></param>)</parameter_list></cpp:macro> <cpp:value>PyType_HasFeature((o)-&gt;ob_type, \
				Py_TPFLAGS_CHECKTYPES)</cpp:value></cpp:define>


<comment type="block">/* Shorthands to return certain errors */</comment>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>type_error</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>msg</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>obj</name></decl></param>)</parameter_list>
<block>{
	<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>, <argument><expr><name>msg</name></expr></argument>, <argument><expr><name><name>obj</name>-&gt;<name>ob_type</name>-&gt;<name>tp_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>NULL</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>null_error</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list>
<block>{
	<if>if <condition>(<expr>!<call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then>
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_SystemError</name></expr></argument>,
				<argument><expr>"null argument to internal routine"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
	<return>return <expr><name>NULL</name></expr>;</return>
}</block></function>

<comment type="block">/* Operations on any object */</comment>

<function><type><name>int</name></type>
<name>PyObject_Cmp</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>o1</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>o2</name></decl></param>, <param><decl><type><name>int</name> *</type><name>result</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>int</name></type> <name>r</name></decl>;</decl_stmt>

	<if>if <condition>(<expr><name>o1</name> == <name>NULL</name> || <name>o2</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>null_error</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>-1</expr>;</return>
	}</block></then></if>
	<expr_stmt><expr><name>r</name> = <call><name>PyObject_Compare</name><argument_list>(<argument><expr><name>o1</name></expr></argument>, <argument><expr><name>o2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then>
		<return>return <expr>-1</expr>;</return></then></if>
	<expr_stmt><expr>*<name>result</name> = <name>r</name></expr>;</expr_stmt>
	<return>return <expr>0</expr>;</return>
}</block></function>

<function><type><name>PyObject</name> *</type>
<name>PyObject_Type</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>o</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>v</name></decl>;</decl_stmt>

	<if>if <condition>(<expr><name>o</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr><call><name>null_error</name><argument_list>()</argument_list></call></expr>;</return></then></if>
	<expr_stmt><expr><name>v</name> = (<name>PyObject</name> *)<name><name>o</name>-&gt;<name>ob_type</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>v</name></expr>;</return>
}</block></function>

<function><type><name>Py_ssize_t</name></type>
<name>PyObject_Size</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>o</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PySequenceMethods</name> *</type><name>m</name></decl>;</decl_stmt>

	<if>if <condition>(<expr><name>o</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>null_error</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>-1</expr>;</return>
	}</block></then></if>

	<expr_stmt><expr><name>m</name> = <name><name>o</name>-&gt;<name>ob_type</name>-&gt;<name>tp_as_sequence</name></name></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>m</name> &amp;&amp; <name><name>m</name>-&gt;<name>sq_length</name></name></expr>)</condition><then>
		<return>return <expr><call><name><name>m</name>-&gt;<name>sq_length</name></name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>;</return></then></if>

	<return>return <expr><call><name>PyMapping_Size</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>PyObject_Length</name></cpp:undef>
<function><type><name>Py_ssize_t</name></type>
<name>PyObject_Length</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>o</name></decl></param>)</parameter_list>
<block>{
	<return>return <expr><call><name>PyObject_Size</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PyObject_Length</name></cpp:macro> <cpp:value>PyObject_Size</cpp:value></cpp:define>


<comment type="block">/* The length hint function returns a non-negative value from o.__len__()
   or o.__length_hint__().  If those methods aren't found or return a negative
   value, then the defaultvalue is returned.  This function never fails. 
   Accordingly, it will mask exceptions raised in either method.
*/</comment>

<function><type><name>Py_ssize_t</name></type>
<name>_PyObject_LengthHint</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>o</name></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>defaultvalue</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><specifier>static</specifier> <name>PyObject</name> *</type><name>hintstrobj</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>ro</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>rv</name></decl>;</decl_stmt>

	<comment type="block">/* try o.__len__() */</comment>
	<expr_stmt><expr><name>rv</name> = <call><name>PyObject_Size</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>rv</name> &gt;= 0</expr>)</condition><then>
		<return>return <expr><name>rv</name></expr>;</return></then></if>
	<if>if <condition>(<expr><call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then>
		<expr_stmt><expr><call><name>PyErr_Clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>

	<comment type="block">/* cache a hashed version of the attribute string */</comment>
	<if>if <condition>(<expr><name>hintstrobj</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>hintstrobj</name> = <call><name>PyString_InternFromString</name><argument_list>(<argument><expr>"__length_hint__"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>hintstrobj</name> == <name>NULL</name></expr>)</condition><then>
			<goto>goto <name>defaultcase</name>;</goto></then></if>
	}</block></then></if>

	<comment type="block">/* try o.__length_hint__() */</comment>
	<expr_stmt><expr><name>ro</name> = <call><name>PyObject_CallMethodObjArgs</name><argument_list>(<argument><expr><name>o</name></expr></argument>, <argument><expr><name>hintstrobj</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>ro</name> == <name>NULL</name></expr>)</condition><then>
		<goto>goto <name>defaultcase</name>;</goto></then></if>
	<expr_stmt><expr><name>rv</name> = <call><name>PyInt_AsLong</name><argument_list>(<argument><expr><name>ro</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>ro</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>rv</name> &gt;= 0</expr>)</condition><then>
		<return>return <expr><name>rv</name></expr>;</return></then></if>

<label><name>defaultcase</name>:</label>
	<if>if <condition>(<expr><call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then>
		<expr_stmt><expr><call><name>PyErr_Clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>
	<return>return <expr><name>defaultvalue</name></expr>;</return>
}</block></function>

<function><type><name>PyObject</name> *</type>
<name>PyObject_GetItem</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>o</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>key</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyMappingMethods</name> *</type><name>m</name></decl>;</decl_stmt>

	<if>if <condition>(<expr><name>o</name> == <name>NULL</name> || <name>key</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr><call><name>null_error</name><argument_list>()</argument_list></call></expr>;</return></then></if>

	<expr_stmt><expr><name>m</name> = <name><name>o</name>-&gt;<name>ob_type</name>-&gt;<name>tp_as_mapping</name></name></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>m</name> &amp;&amp; <name><name>m</name>-&gt;<name>mp_subscript</name></name></expr>)</condition><then>
		<return>return <expr><call><name><name>m</name>-&gt;<name>mp_subscript</name></name><argument_list>(<argument><expr><name>o</name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</return></then></if>

	<if>if <condition>(<expr><name><name>o</name>-&gt;<name>ob_type</name>-&gt;<name>tp_as_sequence</name></name></expr>)</condition><then> <block>{
		<if>if <condition>(<expr><call><name>PyIndex_Check</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
			<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>key_value</name></decl>;</decl_stmt>
			<expr_stmt><expr><name>key_value</name> = <call><name>PyNumber_AsSsize_t</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><name>PyExc_IndexError</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><name>key_value</name> == -1 &amp;&amp; <call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then>
				<return>return <expr><name>NULL</name></expr>;</return></then></if>
			<return>return <expr><call><name>PySequence_GetItem</name><argument_list>(<argument><expr><name>o</name></expr></argument>, <argument><expr><name>key_value</name></expr></argument>)</argument_list></call></expr>;</return>
		}</block></then>
		<else>else <if>if <condition>(<expr><name><name>o</name>-&gt;<name>ob_type</name>-&gt;<name>tp_as_sequence</name>-&gt;<name>sq_item</name></name></expr>)</condition><then>
			<return>return <expr><call><name>type_error</name><argument_list>(<argument><expr>"sequence index must "
					  "be integer, not '%.200s'"</expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</return></then></if></else></if>
	}</block></then></if>

	<return>return <expr><call><name>type_error</name><argument_list>(<argument><expr>"'%.200s' object is unsubscriptable"</expr></argument>, <argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>int</name></type>
<name>PyObject_SetItem</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>o</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>key</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>value</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyMappingMethods</name> *</type><name>m</name></decl>;</decl_stmt>

	<if>if <condition>(<expr><name>o</name> == <name>NULL</name> || <name>key</name> == <name>NULL</name> || <name>value</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>null_error</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>-1</expr>;</return>
	}</block></then></if>
	<expr_stmt><expr><name>m</name> = <name><name>o</name>-&gt;<name>ob_type</name>-&gt;<name>tp_as_mapping</name></name></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>m</name> &amp;&amp; <name><name>m</name>-&gt;<name>mp_ass_subscript</name></name></expr>)</condition><then>
		<return>return <expr><call><name><name>m</name>-&gt;<name>mp_ass_subscript</name></name><argument_list>(<argument><expr><name>o</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</return></then></if>

	<if>if <condition>(<expr><name><name>o</name>-&gt;<name>ob_type</name>-&gt;<name>tp_as_sequence</name></name></expr>)</condition><then> <block>{
		<if>if <condition>(<expr><call><name>PyIndex_Check</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
			<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>key_value</name></decl>;</decl_stmt>
			<expr_stmt><expr><name>key_value</name> = <call><name>PyNumber_AsSsize_t</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><name>PyExc_IndexError</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><name>key_value</name> == -1 &amp;&amp; <call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then>
				<return>return <expr>-1</expr>;</return></then></if>
			<return>return <expr><call><name>PySequence_SetItem</name><argument_list>(<argument><expr><name>o</name></expr></argument>, <argument><expr><name>key_value</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</return>
		}</block></then>
		<else>else <if>if <condition>(<expr><name><name>o</name>-&gt;<name>ob_type</name>-&gt;<name>tp_as_sequence</name>-&gt;<name>sq_ass_item</name></name></expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>type_error</name><argument_list>(<argument><expr>"sequence index must be "
				   "integer, not '%.200s'"</expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr>-1</expr>;</return>
		}</block></then></if></else></if>
	}</block></then></if>

	<expr_stmt><expr><call><name>type_error</name><argument_list>(<argument><expr>"'%.200s' object does not support item assignment"</expr></argument>, <argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr>-1</expr>;</return>
}</block></function>

<function><type><name>int</name></type>
<name>PyObject_DelItem</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>o</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>key</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyMappingMethods</name> *</type><name>m</name></decl>;</decl_stmt>

	<if>if <condition>(<expr><name>o</name> == <name>NULL</name> || <name>key</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>null_error</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>-1</expr>;</return>
	}</block></then></if>
	<expr_stmt><expr><name>m</name> = <name><name>o</name>-&gt;<name>ob_type</name>-&gt;<name>tp_as_mapping</name></name></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>m</name> &amp;&amp; <name><name>m</name>-&gt;<name>mp_ass_subscript</name></name></expr>)</condition><then>
		<return>return <expr><call><name><name>m</name>-&gt;<name>mp_ass_subscript</name></name><argument_list>(<argument><expr><name>o</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr>(<name>PyObject</name>*)<name>NULL</name></expr></argument>)</argument_list></call></expr>;</return></then></if>

	<if>if <condition>(<expr><name><name>o</name>-&gt;<name>ob_type</name>-&gt;<name>tp_as_sequence</name></name></expr>)</condition><then> <block>{
		<if>if <condition>(<expr><call><name>PyIndex_Check</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
			<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>key_value</name></decl>;</decl_stmt>
			<expr_stmt><expr><name>key_value</name> = <call><name>PyNumber_AsSsize_t</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><name>PyExc_IndexError</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><name>key_value</name> == -1 &amp;&amp; <call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then>
				<return>return <expr>-1</expr>;</return></then></if>
			<return>return <expr><call><name>PySequence_DelItem</name><argument_list>(<argument><expr><name>o</name></expr></argument>, <argument><expr><name>key_value</name></expr></argument>)</argument_list></call></expr>;</return>
		}</block></then>
		<else>else <if>if <condition>(<expr><name><name>o</name>-&gt;<name>ob_type</name>-&gt;<name>tp_as_sequence</name>-&gt;<name>sq_ass_item</name></name></expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>type_error</name><argument_list>(<argument><expr>"sequence index must be "
				   "integer, not '%.200s'"</expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr>-1</expr>;</return>
		}</block></then></if></else></if>
	}</block></then></if>

	<expr_stmt><expr><call><name>type_error</name><argument_list>(<argument><expr>"'%.200s' object does not support item deletion"</expr></argument>, <argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr>-1</expr>;</return>
}</block></function>

<function><type><name>int</name></type>
<name>PyObject_DelItemString</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>o</name></decl></param>, <param><decl><type><name>char</name> *</type><name>key</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>okey</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>

	<if>if <condition>(<expr><name>o</name> == <name>NULL</name> || <name>key</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>null_error</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>-1</expr>;</return>
	}</block></then></if>
	<expr_stmt><expr><name>okey</name> = <call><name>PyString_FromString</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>okey</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr>-1</expr>;</return></then></if>
	<expr_stmt><expr><name>ret</name> = <call><name>PyObject_DelItem</name><argument_list>(<argument><expr><name>o</name></expr></argument>, <argument><expr><name>okey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>okey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>ret</name></expr>;</return>
}</block></function>

<function><type><name>int</name></type>
<name>PyObject_AsCharBuffer</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>obj</name></decl></param>,
			  <param><decl><type><specifier>const</specifier> <name>char</name> **</type><name>buffer</name></decl></param>,
			  <param><decl><type><name>Py_ssize_t</name> *</type><name>buffer_len</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyBufferProcs</name> *</type><name>pb</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> *</type><name>pp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>len</name></decl>;</decl_stmt>

	<if>if <condition>(<expr><name>obj</name> == <name>NULL</name> || <name>buffer</name> == <name>NULL</name> || <name>buffer_len</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>null_error</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>-1</expr>;</return>
	}</block></then></if>
	<expr_stmt><expr><name>pb</name> = <name><name>obj</name>-&gt;<name>ob_type</name>-&gt;<name>tp_as_buffer</name></name></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>pb</name> == <name>NULL</name> ||
	     <name><name>pb</name>-&gt;<name>bf_getcharbuffer</name></name> == <name>NULL</name> ||
	     <name><name>pb</name>-&gt;<name>bf_getsegcount</name></name> == <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
				<argument><expr>"expected a character buffer object"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>-1</expr>;</return>
	}</block></then></if>
	<if>if <condition>(<expr><call>(*<name><name>pb</name>-&gt;<name>bf_getsegcount</name></name>)<argument_list>(<argument><expr><name>obj</name></expr></argument>,<argument><expr><name>NULL</name></expr></argument>)</argument_list></call> != 1</expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
				<argument><expr>"expected a single-segment buffer object"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>-1</expr>;</return>
	}</block></then></if>
	<expr_stmt><expr><name>len</name> = <call>(*<name><name>pb</name>-&gt;<name>bf_getcharbuffer</name></name>)<argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>&amp;<name>pp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>len</name> &lt; 0</expr>)</condition><then>
		<return>return <expr>-1</expr>;</return></then></if>
	<expr_stmt><expr>*<name>buffer</name> = <name>pp</name></expr>;</expr_stmt>
	<expr_stmt><expr>*<name>buffer_len</name> = <name>len</name></expr>;</expr_stmt>
	<return>return <expr>0</expr>;</return>
}</block></function>

<function><type><name>int</name></type>
<name>PyObject_CheckReadBuffer</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>obj</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyBufferProcs</name> *</type><name>pb</name> <init>= <expr><name><name>obj</name>-&gt;<name>ob_type</name>-&gt;<name>tp_as_buffer</name></name></expr></init></decl>;</decl_stmt>

	<if>if <condition>(<expr><name>pb</name> == <name>NULL</name> ||
	    <name><name>pb</name>-&gt;<name>bf_getreadbuffer</name></name> == <name>NULL</name> ||
	    <name><name>pb</name>-&gt;<name>bf_getsegcount</name></name> == <name>NULL</name> ||
	    <call>(*<name><name>pb</name>-&gt;<name>bf_getsegcount</name></name>)<argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call> != 1</expr>)</condition><then>
		<return>return <expr>0</expr>;</return></then></if>
	<return>return <expr>1</expr>;</return>
}</block></function>

<function><type><name>int</name></type> <name>PyObject_AsReadBuffer</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>obj</name></decl></param>,
			  <param><decl><type><specifier>const</specifier> <name>void</name> **</type><name>buffer</name></decl></param>,
			  <param><decl><type><name>Py_ssize_t</name> *</type><name>buffer_len</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyBufferProcs</name> *</type><name>pb</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>void</name> *</type><name>pp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>len</name></decl>;</decl_stmt>

	<if>if <condition>(<expr><name>obj</name> == <name>NULL</name> || <name>buffer</name> == <name>NULL</name> || <name>buffer_len</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>null_error</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>-1</expr>;</return>
	}</block></then></if>
	<expr_stmt><expr><name>pb</name> = <name><name>obj</name>-&gt;<name>ob_type</name>-&gt;<name>tp_as_buffer</name></name></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>pb</name> == <name>NULL</name> ||
	     <name><name>pb</name>-&gt;<name>bf_getreadbuffer</name></name> == <name>NULL</name> ||
	     <name><name>pb</name>-&gt;<name>bf_getsegcount</name></name> == <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
				<argument><expr>"expected a readable buffer object"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>-1</expr>;</return>
	}</block></then></if>
	<if>if <condition>(<expr><call>(*<name><name>pb</name>-&gt;<name>bf_getsegcount</name></name>)<argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call> != 1</expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
				<argument><expr>"expected a single-segment buffer object"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>-1</expr>;</return>
	}</block></then></if>
	<expr_stmt><expr><name>len</name> = <call>(*<name><name>pb</name>-&gt;<name>bf_getreadbuffer</name></name>)<argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>&amp;<name>pp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>len</name> &lt; 0</expr>)</condition><then>
		<return>return <expr>-1</expr>;</return></then></if>
	<expr_stmt><expr>*<name>buffer</name> = <name>pp</name></expr>;</expr_stmt>
	<expr_stmt><expr>*<name>buffer_len</name> = <name>len</name></expr>;</expr_stmt>
	<return>return <expr>0</expr>;</return>
}</block></function>

<function><type><name>int</name></type> <name>PyObject_AsWriteBuffer</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>obj</name></decl></param>,
			   <param><decl><type><name>void</name> **</type><name>buffer</name></decl></param>,
			   <param><decl><type><name>Py_ssize_t</name> *</type><name>buffer_len</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyBufferProcs</name> *</type><name>pb</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>void</name>*</type><name>pp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>len</name></decl>;</decl_stmt>

	<if>if <condition>(<expr><name>obj</name> == <name>NULL</name> || <name>buffer</name> == <name>NULL</name> || <name>buffer_len</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>null_error</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>-1</expr>;</return>
	}</block></then></if>
	<expr_stmt><expr><name>pb</name> = <name><name>obj</name>-&gt;<name>ob_type</name>-&gt;<name>tp_as_buffer</name></name></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>pb</name> == <name>NULL</name> ||
	     <name><name>pb</name>-&gt;<name>bf_getwritebuffer</name></name> == <name>NULL</name> ||
	     <name><name>pb</name>-&gt;<name>bf_getsegcount</name></name> == <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
				<argument><expr>"expected a writeable buffer object"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>-1</expr>;</return>
	}</block></then></if>
	<if>if <condition>(<expr><call>(*<name><name>pb</name>-&gt;<name>bf_getsegcount</name></name>)<argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call> != 1</expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
				<argument><expr>"expected a single-segment buffer object"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>-1</expr>;</return>
	}</block></then></if>
	<expr_stmt><expr><name>len</name> = <call>(*<name><name>pb</name>-&gt;<name>bf_getwritebuffer</name></name>)<argument_list>(<argument><expr><name>obj</name></expr></argument>,<argument><expr>0</expr></argument>,<argument><expr>&amp;<name>pp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>len</name> &lt; 0</expr>)</condition><then>
		<return>return <expr>-1</expr>;</return></then></if>
	<expr_stmt><expr>*<name>buffer</name> = <name>pp</name></expr>;</expr_stmt>
	<expr_stmt><expr>*<name>buffer_len</name> = <name>len</name></expr>;</expr_stmt>
	<return>return <expr>0</expr>;</return>
}</block></function>

<comment type="block">/* Buffer C-API for Python 3.0 */</comment>

<function><type><name>int</name></type>
<name>PyObject_GetBuffer</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>obj</name></decl></param>, <param><decl><type><name>Py_buffer</name> *</type><name>view</name></decl></param>, <param><decl><type><name>int</name></type> <name>flags</name></decl></param>)</parameter_list>
<block>{
	<if>if <condition>(<expr>!<call><name>PyObject_CheckBuffer</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
                             <argument><expr>"'%100s' does not have the buffer interface"</expr></argument>,
                             <argument><expr><call><name>Py_TYPE</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call>-&gt;<name>tp_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>-1</expr>;</return>
	}</block></then></if>
	<return>return <expr>(*(<name><name>obj</name>-&gt;<name>ob_type</name>-&gt;<name>tp_as_buffer</name>-&gt;<name>bf_getbuffer</name></name>))(<name>obj</name>, <name>view</name>, <name>flags</name>)</expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>_IsFortranContiguous</name><parameter_list>(<param><decl><type><name>Py_buffer</name> *</type><name>view</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>sd</name></decl>, <decl><type ref="prev"/><name>dim</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

	<if>if <condition>(<expr><name><name>view</name>-&gt;<name>ndim</name></name> == 0</expr>)</condition><then> <return>return <expr>1</expr>;</return></then></if>
	<if>if <condition>(<expr><name><name>view</name>-&gt;<name>strides</name></name> == <name>NULL</name></expr>)</condition><then> <return>return <expr>(<name><name>view</name>-&gt;<name>ndim</name></name> == 1)</expr>;</return></then></if>

	<expr_stmt><expr><name>sd</name> = <name><name>view</name>-&gt;<name>itemsize</name></name></expr>;</expr_stmt>
	<if>if <condition>(<expr><name><name>view</name>-&gt;<name>ndim</name></name> == 1</expr>)</condition><then> <return>return <expr>(<name><name>view</name>-&gt;<name>shape</name><index>[<expr>0</expr>]</index></name> == 1 ||
				   <name>sd</name> == <name><name>view</name>-&gt;<name>strides</name><index>[<expr>0</expr>]</index></name>)</expr>;</return></then></if>
	<for>for (<init><expr><name>i</name>=0</expr>;</init> <condition><expr><name>i</name>&lt;<name><name>view</name>-&gt;<name>ndim</name></name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
		<expr_stmt><expr><name>dim</name> = <name><name>view</name>-&gt;<name>shape</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>dim</name> == 0</expr>)</condition><then> <return>return <expr>1</expr>;</return></then></if>
		<if>if <condition>(<expr><name><name>view</name>-&gt;<name>strides</name><index>[<expr><name>i</name></expr>]</index></name> != <name>sd</name></expr>)</condition><then> <return>return <expr>0</expr>;</return></then></if>
		<expr_stmt><expr><name>sd</name> *= <name>dim</name></expr>;</expr_stmt>
	}</block></for>
	<return>return <expr>1</expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>_IsCContiguous</name><parameter_list>(<param><decl><type><name>Py_buffer</name> *</type><name>view</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>sd</name></decl>, <decl><type ref="prev"/><name>dim</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

	<if>if <condition>(<expr><name><name>view</name>-&gt;<name>ndim</name></name> == 0</expr>)</condition><then> <return>return <expr>1</expr>;</return></then></if>
	<if>if <condition>(<expr><name><name>view</name>-&gt;<name>strides</name></name> == <name>NULL</name></expr>)</condition><then> <return>return <expr>1</expr>;</return></then></if>

	<expr_stmt><expr><name>sd</name> = <name><name>view</name>-&gt;<name>itemsize</name></name></expr>;</expr_stmt>
	<if>if <condition>(<expr><name><name>view</name>-&gt;<name>ndim</name></name> == 1</expr>)</condition><then> <return>return <expr>(<name><name>view</name>-&gt;<name>shape</name><index>[<expr>0</expr>]</index></name> == 1 ||
				   <name>sd</name> == <name><name>view</name>-&gt;<name>strides</name><index>[<expr>0</expr>]</index></name>)</expr>;</return></then></if>
	<for>for (<init><expr><name>i</name>=<name><name>view</name>-&gt;<name>ndim</name></name>-1</expr>;</init> <condition><expr><name>i</name>&gt;=0</expr>;</condition> <incr><expr><name>i</name>--</expr></incr>) <block>{
		<expr_stmt><expr><name>dim</name> = <name><name>view</name>-&gt;<name>shape</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>dim</name> == 0</expr>)</condition><then> <return>return <expr>1</expr>;</return></then></if>
		<if>if <condition>(<expr><name><name>view</name>-&gt;<name>strides</name><index>[<expr><name>i</name></expr>]</index></name> != <name>sd</name></expr>)</condition><then> <return>return <expr>0</expr>;</return></then></if>
		<expr_stmt><expr><name>sd</name> *= <name>dim</name></expr>;</expr_stmt>
	}</block></for>
	<return>return <expr>1</expr>;</return>
}</block></function>

<function><type><name>int</name></type>
<name>PyBuffer_IsContiguous</name><parameter_list>(<param><decl><type><name>Py_buffer</name> *</type><name>view</name></decl></param>, <param><decl><type><name>char</name></type> <name>fort</name></decl></param>)</parameter_list>
<block>{

	<if>if <condition>(<expr><name><name>view</name>-&gt;<name>suboffsets</name></name> != <name>NULL</name></expr>)</condition><then> <return>return <expr>0</expr>;</return></then></if>

	<if>if <condition>(<expr><name>fort</name> == 'C'</expr>)</condition><then>
		<return>return <expr><call><name>_IsCContiguous</name><argument_list>(<argument><expr><name>view</name></expr></argument>)</argument_list></call></expr>;</return></then>
	<else>else <if>if <condition>(<expr><name>fort</name> == 'F'</expr>)</condition><then>
		<return>return <expr><call><name>_IsFortranContiguous</name><argument_list>(<argument><expr><name>view</name></expr></argument>)</argument_list></call></expr>;</return></then>
	<else>else <if>if <condition>(<expr><name>fort</name> == 'A'</expr>)</condition><then>
		<return>return <expr>(<call><name>_IsCContiguous</name><argument_list>(<argument><expr><name>view</name></expr></argument>)</argument_list></call> || <call><name>_IsFortranContiguous</name><argument_list>(<argument><expr><name>view</name></expr></argument>)</argument_list></call>)</expr>;</return></then></if></else></if></else></if>
	<return>return <expr>0</expr>;</return>
}</block></function>


<function><type><name>void</name>*</type>
<name>PyBuffer_GetPointer</name><parameter_list>(<param><decl><type><name>Py_buffer</name> *</type><name>view</name></decl></param>, <param><decl><type><name>Py_ssize_t</name> *</type><name>indices</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>char</name>*</type> <name>pointer</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
	<expr_stmt><expr><name>pointer</name> = (<name>char</name> *)<name><name>view</name>-&gt;<name>buf</name></name></expr>;</expr_stmt>
	<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name><name>view</name>-&gt;<name>ndim</name></name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
		<expr_stmt><expr><name>pointer</name> += <name><name>view</name>-&gt;<name>strides</name><index>[<expr><name>i</name></expr>]</index></name>*<name><name>indices</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
		<if>if <condition>(<expr>(<name><name>view</name>-&gt;<name>suboffsets</name></name> != <name>NULL</name>) &amp;&amp; (<name><name>view</name>-&gt;<name>suboffsets</name><index>[<expr><name>i</name></expr>]</index></name> &gt;= 0)</expr>)</condition><then> <block>{
			<expr_stmt><expr><name>pointer</name> = *((<name>char</name>**)<name>pointer</name>) + <name><name>view</name>-&gt;<name>suboffsets</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
		}</block></then></if>
	}</block></for>
	<return>return <expr>(<name>void</name>*)<name>pointer</name></expr>;</return>
}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type>
<name>_add_one_to_index_F</name><parameter_list>(<param><decl><type><name>int</name></type> <name>nd</name></decl></param>, <param><decl><type><name>Py_ssize_t</name> *</type><name>index</name></decl></param>, <param><decl><type><name>Py_ssize_t</name> *</type><name>shape</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>int</name></type> <name>k</name></decl>;</decl_stmt>

	<for>for (<init><expr><name>k</name>=0</expr>;</init> <condition><expr><name>k</name>&lt;<name>nd</name></expr>;</condition> <incr><expr><name>k</name>++</expr></incr>) <block>{
		<if>if <condition>(<expr><name><name>index</name><index>[<expr><name>k</name></expr>]</index></name> &lt; <name><name>shape</name><index>[<expr><name>k</name></expr>]</index></name>-1</expr>)</condition><then> <block>{
			<expr_stmt><expr><name><name>index</name><index>[<expr><name>k</name></expr>]</index></name>++</expr>;</expr_stmt>
			<break>break;</break>
		}</block></then>
		<else>else <block>{
			<expr_stmt><expr><name><name>index</name><index>[<expr><name>k</name></expr>]</index></name> = 0</expr>;</expr_stmt>
		}</block></else></if>
	}</block></for>
}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_add_one_to_index_C</name><parameter_list>(<param><decl><type><name>int</name></type> <name>nd</name></decl></param>, <param><decl><type><name>Py_ssize_t</name> *</type><name>index</name></decl></param>, <param><decl><type><name>Py_ssize_t</name> *</type><name>shape</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>int</name></type> <name>k</name></decl>;</decl_stmt>

	<for>for (<init><expr><name>k</name>=<name>nd</name>-1</expr>;</init> <condition><expr><name>k</name>&gt;=0</expr>;</condition> <incr><expr><name>k</name>--</expr></incr>) <block>{
		<if>if <condition>(<expr><name><name>index</name><index>[<expr><name>k</name></expr>]</index></name> &lt; <name><name>shape</name><index>[<expr><name>k</name></expr>]</index></name>-1</expr>)</condition><then> <block>{
			<expr_stmt><expr><name><name>index</name><index>[<expr><name>k</name></expr>]</index></name>++</expr>;</expr_stmt>
			<break>break;</break>
		}</block></then>
		<else>else <block>{
			<expr_stmt><expr><name><name>index</name><index>[<expr><name>k</name></expr>]</index></name> = 0</expr>;</expr_stmt>
		}</block></else></if>
	}</block></for>
}</block></function>

  <comment type="block">/* view is not checked for consistency in either of these.  It is
     assumed that the size of the buffer is view-&gt;len in
     view-&gt;len / view-&gt;itemsize elements.
  */</comment>

<function><type><name>int</name></type>
<name>PyBuffer_ToContiguous</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>buf</name></decl></param>, <param><decl><type><name>Py_buffer</name> *</type><name>view</name></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>len</name></decl></param>, <param><decl><type><name>char</name></type> <name>fort</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>int</name></type> <name>k</name></decl>;</decl_stmt>
	<function_decl><type><name>void</name></type> (*<name>addone</name>)<parameter_list>(<param><decl><type><name>int</name></type></decl></param>, <param><decl><type><name>Py_ssize_t</name> *</type></decl></param>, <param><decl><type><name>Py_ssize_t</name> *</type></decl></param>)</parameter_list>;</function_decl>
	<decl_stmt><decl><type><name>Py_ssize_t</name> *</type><name>indices</name></decl>, <decl><type ref="prev"/><name>elements</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> *</type><name>dest</name></decl>, *<decl><type ref="prev"/><name>ptr</name></decl>;</decl_stmt>

	<if>if <condition>(<expr><name>len</name> &gt; <name><name>view</name>-&gt;<name>len</name></name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>len</name> = <name><name>view</name>-&gt;<name>len</name></name></expr>;</expr_stmt>
	}</block></then></if>

	<if>if <condition>(<expr><call><name>PyBuffer_IsContiguous</name><argument_list>(<argument><expr><name>view</name></expr></argument>, <argument><expr><name>fort</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<comment type="block">/* simplest copy is all that is needed */</comment>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name><name>view</name>-&gt;<name>buf</name></name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>0</expr>;</return>
	}</block></then></if>

	<comment type="block">/* Otherwise a more elaborate scheme is needed */</comment>

	<comment type="block">/* XXX(nnorwitz): need to check for overflow! */</comment>
	<expr_stmt><expr><name>indices</name> = (<name>Py_ssize_t</name> *)<call><name>PyMem_Malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Py_ssize_t</name></expr></argument>)</argument_list></sizeof>*(<name><name>view</name>-&gt;<name>ndim</name></name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>indices</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_NoMemory</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>-1</expr>;</return>
	}</block></then></if>
	<for>for (<init><expr><name>k</name>=0</expr>;</init> <condition><expr><name>k</name>&lt;<name><name>view</name>-&gt;<name>ndim</name></name></expr>;</condition><incr><expr><name>k</name>++</expr></incr>) <block>{
		<expr_stmt><expr><name><name>indices</name><index>[<expr><name>k</name></expr>]</index></name> = 0</expr>;</expr_stmt>
	}</block></for>

	<if>if <condition>(<expr><name>fort</name> == 'F'</expr>)</condition><then> <block>{
		<expr_stmt><expr><name>addone</name> = <name>_add_one_to_index_F</name></expr>;</expr_stmt>
	}</block></then>
	<else>else <block>{
		<expr_stmt><expr><name>addone</name> = <name>_add_one_to_index_C</name></expr>;</expr_stmt>
	}</block></else></if>
	<expr_stmt><expr><name>dest</name> = <name>buf</name></expr>;</expr_stmt>
	<comment type="block">/* XXX : This is not going to be the fastest code in the world
		 several optimizations are possible.
	 */</comment>
	<expr_stmt><expr><name>elements</name> = <name>len</name> / <name><name>view</name>-&gt;<name>itemsize</name></name></expr>;</expr_stmt>
	<while>while <condition>(<expr><name>elements</name>--</expr>)</condition> <block>{
		<expr_stmt><expr><call><name>addone</name><argument_list>(<argument><expr><name><name>view</name>-&gt;<name>ndim</name></name></expr></argument>, <argument><expr><name>indices</name></expr></argument>, <argument><expr><name><name>view</name>-&gt;<name>shape</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>ptr</name> = <call><name>PyBuffer_GetPointer</name><argument_list>(<argument><expr><name>view</name></expr></argument>, <argument><expr><name>indices</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>dest</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name><name>view</name>-&gt;<name>itemsize</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>dest</name> += <name><name>view</name>-&gt;<name>itemsize</name></name></expr>;</expr_stmt>
	}</block></while>
	<expr_stmt><expr><call><name>PyMem_Free</name><argument_list>(<argument><expr><name>indices</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr>0</expr>;</return>
}</block></function>

<function><type><name>int</name></type>
<name>PyBuffer_FromContiguous</name><parameter_list>(<param><decl><type><name>Py_buffer</name> *</type><name>view</name></decl></param>, <param><decl><type><name>void</name> *</type><name>buf</name></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>len</name></decl></param>, <param><decl><type><name>char</name></type> <name>fort</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>int</name></type> <name>k</name></decl>;</decl_stmt>
	<function_decl><type><name>void</name></type> (*<name>addone</name>)<parameter_list>(<param><decl><type><name>int</name></type></decl></param>, <param><decl><type><name>Py_ssize_t</name> *</type></decl></param>, <param><decl><type><name>Py_ssize_t</name> *</type></decl></param>)</parameter_list>;</function_decl>
	<decl_stmt><decl><type><name>Py_ssize_t</name> *</type><name>indices</name></decl>, <decl><type ref="prev"/><name>elements</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> *</type><name>src</name></decl>, *<decl><type ref="prev"/><name>ptr</name></decl>;</decl_stmt>

	<if>if <condition>(<expr><name>len</name> &gt; <name><name>view</name>-&gt;<name>len</name></name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>len</name> = <name><name>view</name>-&gt;<name>len</name></name></expr>;</expr_stmt>
	}</block></then></if>

	<if>if <condition>(<expr><call><name>PyBuffer_IsContiguous</name><argument_list>(<argument><expr><name>view</name></expr></argument>, <argument><expr><name>fort</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<comment type="block">/* simplest copy is all that is needed */</comment>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>view</name>-&gt;<name>buf</name></name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>0</expr>;</return>
	}</block></then></if>

	<comment type="block">/* Otherwise a more elaborate scheme is needed */</comment>

	<comment type="block">/* XXX(nnorwitz): need to check for overflow! */</comment>
	<expr_stmt><expr><name>indices</name> = (<name>Py_ssize_t</name> *)<call><name>PyMem_Malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Py_ssize_t</name></expr></argument>)</argument_list></sizeof>*(<name><name>view</name>-&gt;<name>ndim</name></name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>indices</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_NoMemory</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>-1</expr>;</return>
	}</block></then></if>
	<for>for (<init><expr><name>k</name>=0</expr>;</init> <condition><expr><name>k</name>&lt;<name><name>view</name>-&gt;<name>ndim</name></name></expr>;</condition><incr><expr><name>k</name>++</expr></incr>) <block>{
		<expr_stmt><expr><name><name>indices</name><index>[<expr><name>k</name></expr>]</index></name> = 0</expr>;</expr_stmt>
	}</block></for>

	<if>if <condition>(<expr><name>fort</name> == 'F'</expr>)</condition><then> <block>{
		<expr_stmt><expr><name>addone</name> = <name>_add_one_to_index_F</name></expr>;</expr_stmt>
	}</block></then>
	<else>else <block>{
		<expr_stmt><expr><name>addone</name> = <name>_add_one_to_index_C</name></expr>;</expr_stmt>
	}</block></else></if>
	<expr_stmt><expr><name>src</name> = <name>buf</name></expr>;</expr_stmt>
	<comment type="block">/* XXX : This is not going to be the fastest code in the world
		 several optimizations are possible.
	 */</comment>
	<expr_stmt><expr><name>elements</name> = <name>len</name> / <name><name>view</name>-&gt;<name>itemsize</name></name></expr>;</expr_stmt>
	<while>while <condition>(<expr><name>elements</name>--</expr>)</condition> <block>{
		<expr_stmt><expr><call><name>addone</name><argument_list>(<argument><expr><name><name>view</name>-&gt;<name>ndim</name></name></expr></argument>, <argument><expr><name>indices</name></expr></argument>, <argument><expr><name><name>view</name>-&gt;<name>shape</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>ptr</name> = <call><name>PyBuffer_GetPointer</name><argument_list>(<argument><expr><name>view</name></expr></argument>, <argument><expr><name>indices</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name><name>view</name>-&gt;<name>itemsize</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>src</name> += <name><name>view</name>-&gt;<name>itemsize</name></name></expr>;</expr_stmt>
	}</block></while>

	<expr_stmt><expr><call><name>PyMem_Free</name><argument_list>(<argument><expr><name>indices</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr>0</expr>;</return>
}</block></function>

<function><type><name>int</name></type> <name>PyObject_CopyData</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>dest</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>src</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>Py_buffer</name></type> <name>view_dest</name></decl>, <decl><type ref="prev"/><name>view_src</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>k</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Py_ssize_t</name> *</type><name>indices</name></decl>, <decl><type ref="prev"/><name>elements</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> *</type><name>dptr</name></decl>, *<decl><type ref="prev"/><name>sptr</name></decl>;</decl_stmt>

	<if>if <condition>(<expr>!<call><name>PyObject_CheckBuffer</name><argument_list>(<argument><expr><name>dest</name></expr></argument>)</argument_list></call> ||
	    !<call><name>PyObject_CheckBuffer</name><argument_list>(<argument><expr><name>src</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
				<argument><expr>"both destination and source must have the "\
				"buffer interface"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>-1</expr>;</return>
	}</block></then></if>

	<if>if <condition>(<expr><call><name>PyObject_GetBuffer</name><argument_list>(<argument><expr><name>dest</name></expr></argument>, <argument><expr>&amp;<name>view_dest</name></expr></argument>, <argument><expr><name>PyBUF_FULL</name></expr></argument>)</argument_list></call> != 0</expr>)</condition><then> <return>return <expr>-1</expr>;</return></then></if>
	<if>if <condition>(<expr><call><name>PyObject_GetBuffer</name><argument_list>(<argument><expr><name>src</name></expr></argument>, <argument><expr>&amp;<name>view_src</name></expr></argument>, <argument><expr><name>PyBUF_FULL_RO</name></expr></argument>)</argument_list></call> != 0</expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyBuffer_Release</name><argument_list>(<argument><expr>&amp;<name>view_dest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>-1</expr>;</return>
	}</block></then></if>

	<if>if <condition>(<expr><name><name>view_dest</name>.<name>len</name></name> &lt; <name><name>view_src</name>.<name>len</name></name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_BufferError</name></expr></argument>,
				<argument><expr>"destination is too small to receive data from source"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PyBuffer_Release</name><argument_list>(<argument><expr>&amp;<name>view_dest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PyBuffer_Release</name><argument_list>(<argument><expr>&amp;<name>view_src</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>-1</expr>;</return>
	}</block></then></if>

	<if>if <condition>(<expr>(<call><name>PyBuffer_IsContiguous</name><argument_list>(<argument><expr>&amp;<name>view_dest</name></expr></argument>, <argument><expr>'C'</expr></argument>)</argument_list></call> &amp;&amp;
	     <call><name>PyBuffer_IsContiguous</name><argument_list>(<argument><expr>&amp;<name>view_src</name></expr></argument>, <argument><expr>'C'</expr></argument>)</argument_list></call>) ||
	    (<call><name>PyBuffer_IsContiguous</name><argument_list>(<argument><expr>&amp;<name>view_dest</name></expr></argument>, <argument><expr>'F'</expr></argument>)</argument_list></call> &amp;&amp;
	     <call><name>PyBuffer_IsContiguous</name><argument_list>(<argument><expr>&amp;<name>view_src</name></expr></argument>, <argument><expr>'F'</expr></argument>)</argument_list></call>)</expr>)</condition><then> <block>{
		<comment type="block">/* simplest copy is all that is needed */</comment>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>view_dest</name>.<name>buf</name></name></expr></argument>, <argument><expr><name><name>view_src</name>.<name>buf</name></name></expr></argument>, <argument><expr><name><name>view_src</name>.<name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PyBuffer_Release</name><argument_list>(<argument><expr>&amp;<name>view_dest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PyBuffer_Release</name><argument_list>(<argument><expr>&amp;<name>view_src</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>0</expr>;</return>
	}</block></then></if>

	<comment type="block">/* Otherwise a more elaborate copy scheme is needed */</comment>

	<comment type="block">/* XXX(nnorwitz): need to check for overflow! */</comment>
	<expr_stmt><expr><name>indices</name> = (<name>Py_ssize_t</name> *)<call><name>PyMem_Malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Py_ssize_t</name></expr></argument>)</argument_list></sizeof>*<name><name>view_src</name>.<name>ndim</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>indices</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_NoMemory</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PyBuffer_Release</name><argument_list>(<argument><expr>&amp;<name>view_dest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PyBuffer_Release</name><argument_list>(<argument><expr>&amp;<name>view_src</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>-1</expr>;</return>
	}</block></then></if>
	<for>for (<init><expr><name>k</name>=0</expr>;</init> <condition><expr><name>k</name>&lt;<name><name>view_src</name>.<name>ndim</name></name></expr>;</condition><incr><expr><name>k</name>++</expr></incr>) <block>{
		<expr_stmt><expr><name><name>indices</name><index>[<expr><name>k</name></expr>]</index></name> = 0</expr>;</expr_stmt>
	}</block></for>
	<expr_stmt><expr><name>elements</name> = 1</expr>;</expr_stmt>
	<for>for (<init><expr><name>k</name>=0</expr>;</init> <condition><expr><name>k</name>&lt;<name><name>view_src</name>.<name>ndim</name></name></expr>;</condition> <incr><expr><name>k</name>++</expr></incr>) <block>{
		<comment type="block">/* XXX(nnorwitz): can this overflow? */</comment>
		<expr_stmt><expr><name>elements</name> *= <name><name>view_src</name>.<name>shape</name><index>[<expr><name>k</name></expr>]</index></name></expr>;</expr_stmt>
	}</block></for>
	<while>while <condition>(<expr><name>elements</name>--</expr>)</condition> <block>{
		<expr_stmt><expr><call><name>_add_one_to_index_C</name><argument_list>(<argument><expr><name><name>view_src</name>.<name>ndim</name></name></expr></argument>, <argument><expr><name>indices</name></expr></argument>, <argument><expr><name><name>view_src</name>.<name>shape</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>dptr</name> = <call><name>PyBuffer_GetPointer</name><argument_list>(<argument><expr>&amp;<name>view_dest</name></expr></argument>, <argument><expr><name>indices</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>sptr</name> = <call><name>PyBuffer_GetPointer</name><argument_list>(<argument><expr>&amp;<name>view_src</name></expr></argument>, <argument><expr><name>indices</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>dptr</name></expr></argument>, <argument><expr><name>sptr</name></expr></argument>, <argument><expr><name><name>view_src</name>.<name>itemsize</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></while>
	<expr_stmt><expr><call><name>PyMem_Free</name><argument_list>(<argument><expr><name>indices</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PyBuffer_Release</name><argument_list>(<argument><expr>&amp;<name>view_dest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PyBuffer_Release</name><argument_list>(<argument><expr>&amp;<name>view_src</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr>0</expr>;</return>
}</block></function>

<function><type><name>void</name></type>
<name>PyBuffer_FillContiguousStrides</name><parameter_list>(<param><decl><type><name>int</name></type> <name>nd</name></decl></param>, <param><decl><type><name>Py_ssize_t</name> *</type><name>shape</name></decl></param>,
			       <param><decl><type><name>Py_ssize_t</name> *</type><name>strides</name></decl></param>, <param><decl><type><name>int</name></type> <name>itemsize</name></decl></param>,
			       <param><decl><type><name>char</name></type> <name>fort</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>int</name></type> <name>k</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>sd</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>sd</name> = <name>itemsize</name></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>fort</name> == 'F'</expr>)</condition><then> <block>{
		<for>for (<init><expr><name>k</name>=0</expr>;</init> <condition><expr><name>k</name>&lt;<name>nd</name></expr>;</condition> <incr><expr><name>k</name>++</expr></incr>) <block>{
			<expr_stmt><expr><name><name>strides</name><index>[<expr><name>k</name></expr>]</index></name> = <name>sd</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>sd</name> *= <name><name>shape</name><index>[<expr><name>k</name></expr>]</index></name></expr>;</expr_stmt>
		}</block></for>
	}</block></then>
	<else>else <block>{
		<for>for (<init><expr><name>k</name>=<name>nd</name>-1</expr>;</init> <condition><expr><name>k</name>&gt;=0</expr>;</condition> <incr><expr><name>k</name>--</expr></incr>) <block>{
			<expr_stmt><expr><name><name>strides</name><index>[<expr><name>k</name></expr>]</index></name> = <name>sd</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>sd</name> *= <name><name>shape</name><index>[<expr><name>k</name></expr>]</index></name></expr>;</expr_stmt>
		}</block></for>
	}</block></else></if>
	<return>return;</return>
}</block></function>

<function><type><name>int</name></type>
<name>PyBuffer_FillInfo</name><parameter_list>(<param><decl><type><name>Py_buffer</name> *</type><name>view</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>obj</name></decl></param>, <param><decl><type><name>void</name> *</type><name>buf</name></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>len</name></decl></param>,
	      <param><decl><type><name>int</name></type> <name>readonly</name></decl></param>, <param><decl><type><name>int</name></type> <name>flags</name></decl></param>)</parameter_list>
<block>{
	<if>if <condition>(<expr><name>view</name> == <name>NULL</name></expr>)</condition><then> <return>return <expr>0</expr>;</return></then></if>
	<if>if <condition>(<expr>((<name>flags</name> &amp; <name>PyBUF_WRITABLE</name>) == <name>PyBUF_WRITABLE</name>) &amp;&amp;
	    (<name>readonly</name> == 1)</expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_BufferError</name></expr></argument>,
				<argument><expr>"Object is not writable."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>-1</expr>;</return>
	}</block></then></if>

	<expr_stmt><expr><name><name>view</name>-&gt;<name>obj</name></name> = <name>obj</name></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>obj</name></expr>)</condition><then>
		<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
	<expr_stmt><expr><name><name>view</name>-&gt;<name>buf</name></name> = <name>buf</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>view</name>-&gt;<name>len</name></name> = <name>len</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>view</name>-&gt;<name>readonly</name></name> = <name>readonly</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>view</name>-&gt;<name>itemsize</name></name> = 1</expr>;</expr_stmt>
	<expr_stmt><expr><name><name>view</name>-&gt;<name>format</name></name> = <name>NULL</name></expr>;</expr_stmt>
	<if>if <condition>(<expr>(<name>flags</name> &amp; <name>PyBUF_FORMAT</name>) == <name>PyBUF_FORMAT</name></expr>)</condition><then>
		<expr_stmt><expr><name><name>view</name>-&gt;<name>format</name></name> = "B"</expr>;</expr_stmt></then></if>
	<expr_stmt><expr><name><name>view</name>-&gt;<name>ndim</name></name> = 1</expr>;</expr_stmt>
	<expr_stmt><expr><name><name>view</name>-&gt;<name>shape</name></name> = <name>NULL</name></expr>;</expr_stmt>
	<if>if <condition>(<expr>(<name>flags</name> &amp; <name>PyBUF_ND</name>) == <name>PyBUF_ND</name></expr>)</condition><then>
		<expr_stmt><expr><name><name>view</name>-&gt;<name>shape</name></name> = &amp;(<name><name>view</name>-&gt;<name>len</name></name>)</expr>;</expr_stmt></then></if>
	<expr_stmt><expr><name><name>view</name>-&gt;<name>strides</name></name> = <name>NULL</name></expr>;</expr_stmt>
	<if>if <condition>(<expr>(<name>flags</name> &amp; <name>PyBUF_STRIDES</name>) == <name>PyBUF_STRIDES</name></expr>)</condition><then>
		<expr_stmt><expr><name><name>view</name>-&gt;<name>strides</name></name> = &amp;(<name><name>view</name>-&gt;<name>itemsize</name></name>)</expr>;</expr_stmt></then></if>
	<expr_stmt><expr><name><name>view</name>-&gt;<name>suboffsets</name></name> = <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>view</name>-&gt;<name>internal</name></name> = <name>NULL</name></expr>;</expr_stmt>
	<return>return <expr>0</expr>;</return>
}</block></function>

<function><type><name>void</name></type>
<name>PyBuffer_Release</name><parameter_list>(<param><decl><type><name>Py_buffer</name> *</type><name>view</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>obj</name> <init>= <expr><name><name>view</name>-&gt;<name>obj</name></name></expr></init></decl>;</decl_stmt>
	<if>if <condition>(<expr><name>obj</name> &amp;&amp; <call><name>Py_TYPE</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call>-&gt;<name>tp_as_buffer</name> &amp;&amp; <call><name>Py_TYPE</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call>-&gt;<name><name>tp_as_buffer</name>-&gt;<name>bf_releasebuffer</name></name></expr>)</condition><then>
		<expr_stmt><expr><call><name>Py_TYPE</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call>-&gt;<call><name><name>tp_as_buffer</name>-&gt;<name>bf_releasebuffer</name></name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>view</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
	<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>view</name>-&gt;<name>obj</name></name> = <name>NULL</name></expr>;</expr_stmt>
}</block></function>

<function><type><name>PyObject</name> *</type>
<name>PyObject_Format</name><parameter_list>(<param><decl><type><name>PyObject</name>*</type> <name>obj</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>format_spec</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><specifier>static</specifier> <name>PyObject</name> *</type> <name>str__format__</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>empty</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>result</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>spec_is_unicode</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>result_is_unicode</name></decl>;</decl_stmt>

	<comment type="block">/* Initialize cached value */</comment>
	<if>if <condition>(<expr><name>str__format__</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<comment type="block">/* Initialize static variable needed by _PyType_Lookup */</comment>
		<expr_stmt><expr><name>str__format__</name> = <call><name>PyString_InternFromString</name><argument_list>(<argument><expr>"__format__"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>str__format__</name> == <name>NULL</name></expr>)</condition><then>
			<goto>goto <name>done</name>;</goto></then></if>
	}</block></then></if>

	<comment type="block">/* If no format_spec is provided, use an empty string */</comment>
	<if>if <condition>(<expr><name>format_spec</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>empty</name> = <call><name>PyString_FromStringAndSize</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>format_spec</name> = <name>empty</name></expr>;</expr_stmt>
	}</block></then></if>

	<comment type="block">/* Check the format_spec type, and make sure it's str or unicode */</comment>
	<if>if <condition>(<expr><call><name>PyUnicode_Check</name><argument_list>(<argument><expr><name>format_spec</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<expr_stmt><expr><name>spec_is_unicode</name> = 1</expr>;</expr_stmt></then>
	<else>else <if>if <condition>(<expr><call><name>PyString_Check</name><argument_list>(<argument><expr><name>format_spec</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<expr_stmt><expr><name>spec_is_unicode</name> = 0</expr>;</expr_stmt></then>
	<else>else <block>{
		<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
			     <argument><expr>"format expects arg 2 to be string "
			     "or unicode, not %.100s"</expr></argument>, <argument><expr><call><name>Py_TYPE</name><argument_list>(<argument><expr><name>format_spec</name></expr></argument>)</argument_list></call>-&gt;<name>tp_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<goto>goto <name>done</name>;</goto>
	}</block></else></if></else></if>

	<comment type="block">/* Make sure the type is initialized.  float gets initialized late */</comment>
	<if>if <condition>(<expr><call><name>Py_TYPE</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call>-&gt;<name>tp_dict</name> == <name>NULL</name></expr>)</condition><then>
		<if>if <condition>(<expr><call><name>PyType_Ready</name><argument_list>(<argument><expr><call><name>Py_TYPE</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
			<goto>goto <name>done</name>;</goto></then></if></then></if>

	<comment type="block">/* Check for a __format__ method and call it. */</comment>
	<if>if <condition>(<expr><call><name>PyInstance_Check</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<comment type="block">/* We're an instance of a classic class */</comment>
		<decl_stmt><decl><type><name>PyObject</name> *</type><name>bound_method</name> <init>= <expr><call><name>PyObject_GetAttr</name><argument_list>(<argument><expr><name>obj</name></expr></argument>,
							  <argument><expr><name>str__format__</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if>if <condition>(<expr><name>bound_method</name> != <name>NULL</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><name>result</name> = <call><name>PyObject_CallFunctionObjArgs</name><argument_list>(<argument><expr><name>bound_method</name></expr></argument>,
							      <argument><expr><name>format_spec</name></expr></argument>,
							      <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>bound_method</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></then> <else>else <block>{
			<decl_stmt><decl><type><name>PyObject</name> *</type><name>self_as_str</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>PyObject</name> *</type><name>format_method</name></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>PyErr_Clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* Per the PEP, convert to str (or unicode,
			   depending on the type of the format
			   specifier).  For new-style classes, this
			   logic is done by object.__format__(). */</comment>
			<if>if <condition>(<expr><name>spec_is_unicode</name></expr>)</condition><then>
				<expr_stmt><expr><name>self_as_str</name> = <call><name>PyObject_Unicode</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
			<else>else
				<expr_stmt><expr><name>self_as_str</name> = <call><name>PyObject_Str</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
			<if>if <condition>(<expr><name>self_as_str</name> == <name>NULL</name></expr>)</condition><then>
				<goto>goto <name>done</name>;</goto></then></if>

			<comment type="block">/* Then call str.__format__ on that result */</comment>
			<expr_stmt><expr><name>format_method</name> = <call><name>PyObject_GetAttr</name><argument_list>(<argument><expr><name>self_as_str</name></expr></argument>,
							 <argument><expr><name>str__format__</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><name>format_method</name> == <name>NULL</name></expr>)</condition><then> <block>{
				<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>self_as_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<goto>goto <name>done</name>;</goto>
			}</block></then></if>
                        <expr_stmt><expr><name>result</name> = <call><name>PyObject_CallFunctionObjArgs</name><argument_list>(<argument><expr><name>format_method</name></expr></argument>,
							      <argument><expr><name>format_spec</name></expr></argument>,
							      <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>self_as_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>format_method</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><name>result</name> == <name>NULL</name></expr>)</condition><then>
				<goto>goto <name>done</name>;</goto></then></if>
                }</block></else></if>
	}</block></then> <else>else <block>{
		<comment type="block">/* Not an instance of a classic class, use the code
		   from py3k */</comment>

		<comment type="block">/* Find the (unbound!) __format__ method (a borrowed
		   reference) */</comment>
		<decl_stmt><decl><type><name>PyObject</name> *</type><name>method</name> <init>= <expr><call><name>_PyType_Lookup</name><argument_list>(<argument><expr><call><name>Py_TYPE</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></argument>,
						  <argument><expr><name>str__format__</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if>if <condition>(<expr><name>method</name> == <name>NULL</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
				     <argument><expr>"Type %.100s doesn't define __format__"</expr></argument>,
				     <argument><expr><call><name>Py_TYPE</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call>-&gt;<name>tp_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<goto>goto <name>done</name>;</goto>
		}</block></then></if>
		<comment type="block">/* And call it, binding it to the value */</comment>
		<expr_stmt><expr><name>result</name> = <call><name>PyObject_CallFunctionObjArgs</name><argument_list>(<argument><expr><name>method</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>,
						      <argument><expr><name>format_spec</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></else></if>

	<if>if <condition>(<expr><name>result</name> == <name>NULL</name></expr>)</condition><then>
		<goto>goto <name>done</name>;</goto></then></if>

	<comment type="block">/* Check the result type, and make sure it's str or unicode */</comment>
	<if>if <condition>(<expr><call><name>PyUnicode_Check</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<expr_stmt><expr><name>result_is_unicode</name> = 1</expr>;</expr_stmt></then>
	<else>else <if>if <condition>(<expr><call><name>PyString_Check</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<expr_stmt><expr><name>result_is_unicode</name> = 0</expr>;</expr_stmt></then>
	<else>else <block>{
		<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
			     <argument><expr>"%.100s.__format__ must return string or "
			     "unicode, not %.100s"</expr></argument>, <argument><expr><call><name>Py_TYPE</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call>-&gt;<name>tp_name</name></expr></argument>,
			     <argument><expr><call><name>Py_TYPE</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call>-&gt;<name>tp_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>result</name> = <name>NULL</name></expr>;</expr_stmt>
		<goto>goto <name>done</name>;</goto>
	}</block></else></if></else></if>

	<comment type="block">/* Convert to unicode, if needed.  Required if spec is unicode
	   and result is str */</comment>
	<if>if <condition>(<expr><name>spec_is_unicode</name> &amp;&amp; !<name>result_is_unicode</name></expr>)</condition><then> <block>{
		<decl_stmt><decl><type><name>PyObject</name> *</type><name>tmp</name> <init>= <expr><call><name>PyObject_Unicode</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<comment type="block">/* This logic works whether or not tmp is NULL */</comment>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>result</name> = <name>tmp</name></expr>;</expr_stmt>
	}</block></then></if>

<label><name>done</name>:</label>
	<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>empty</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>result</name></expr>;</return>
}</block></function>

<comment type="block">/* Operations on numbers */</comment>

<function><type><name>int</name></type>
<name>PyNumber_Check</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>o</name></decl></param>)</parameter_list>
<block>{
	<return>return <expr><name>o</name> &amp;&amp; <name><name>o</name>-&gt;<name>ob_type</name>-&gt;<name>tp_as_number</name></name> &amp;&amp;
	       (<name><name>o</name>-&gt;<name>ob_type</name>-&gt;<name>tp_as_number</name>-&gt;<name>nb_int</name></name> ||
		<name><name>o</name>-&gt;<name>ob_type</name>-&gt;<name>tp_as_number</name>-&gt;<name>nb_float</name></name>)</expr>;</return>
}</block></function>

<comment type="block">/* Binary operators */</comment>

<comment type="block">/* New style number protocol support */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NB_SLOT</name><parameter_list>(<param><type><name>x</name></type></param>)</parameter_list></cpp:macro> <cpp:value>offsetof(PyNumberMethods, x)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NB_BINOP</name><parameter_list>(<param><type><name>nb_methods</name></type></param>, <param><type><name>slot</name></type></param>)</parameter_list></cpp:macro> \
		<cpp:value>(*(binaryfunc*)(&amp; ((char*)nb_methods)[slot]))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NB_TERNOP</name><parameter_list>(<param><type><name>nb_methods</name></type></param>, <param><type><name>slot</name></type></param>)</parameter_list></cpp:macro> \
		<cpp:value>(*(ternaryfunc*)(&amp; ((char*)nb_methods)[slot]))</cpp:value></cpp:define>

<comment type="block">/*
  Calling scheme used for binary operations:

  v	w	Action
  -------------------------------------------------------------------
  new	new	w.op(v,w)[*], v.op(v,w), w.op(v,w)
  new	old	v.op(v,w), coerce(v,w), v.op(v,w)
  old	new	w.op(v,w), coerce(v,w), v.op(v,w)
  old	old	coerce(v,w), v.op(v,w)

  [*] only when v-&gt;ob_type != w-&gt;ob_type &amp;&amp; w-&gt;ob_type is a subclass of
      v-&gt;ob_type

  Legend:
  -------
  * new == new style number
  * old == old style number
  * Action indicates the order in which operations are tried until either
    a valid result is produced or an error occurs.

 */</comment>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>binary_op1</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>v</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>w</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>int</name></type> <name>op_slot</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>x</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>binaryfunc</name></type> <name>slotv</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>binaryfunc</name></type> <name>slotw</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<if>if <condition>(<expr><name><name>v</name>-&gt;<name>ob_type</name>-&gt;<name>tp_as_number</name></name> != <name>NULL</name> &amp;&amp; <call><name>NEW_STYLE_NUMBER</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<expr_stmt><expr><name>slotv</name> = <call><name>NB_BINOP</name><argument_list>(<argument><expr><name><name>v</name>-&gt;<name>ob_type</name>-&gt;<name>tp_as_number</name></name></expr></argument>, <argument><expr><name>op_slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
	<if>if <condition>(<expr><name><name>w</name>-&gt;<name>ob_type</name></name> != <name><name>v</name>-&gt;<name>ob_type</name></name> &amp;&amp;
	    <name><name>w</name>-&gt;<name>ob_type</name>-&gt;<name>tp_as_number</name></name> != <name>NULL</name> &amp;&amp; <call><name>NEW_STYLE_NUMBER</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>slotw</name> = <call><name>NB_BINOP</name><argument_list>(<argument><expr><name><name>w</name>-&gt;<name>ob_type</name>-&gt;<name>tp_as_number</name></name></expr></argument>, <argument><expr><name>op_slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>slotw</name> == <name>slotv</name></expr>)</condition><then>
			<expr_stmt><expr><name>slotw</name> = <name>NULL</name></expr>;</expr_stmt></then></if>
	}</block></then></if>
	<if>if <condition>(<expr><name>slotv</name></expr>)</condition><then> <block>{
		<if>if <condition>(<expr><name>slotw</name> &amp;&amp; <call><name>PyType_IsSubtype</name><argument_list>(<argument><expr><name><name>w</name>-&gt;<name>ob_type</name></name></expr></argument>, <argument><expr><name><name>v</name>-&gt;<name>ob_type</name></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
			<expr_stmt><expr><name>x</name> = <call><name>slotw</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><name>x</name> != <name>Py_NotImplemented</name></expr>)</condition><then>
				<return>return <expr><name>x</name></expr>;</return></then></if>
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* can't do it */</comment>
			<expr_stmt><expr><name>slotw</name> = <name>NULL</name></expr>;</expr_stmt>
		}</block></then></if>
		<expr_stmt><expr><name>x</name> = <call><name>slotv</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>x</name> != <name>Py_NotImplemented</name></expr>)</condition><then>
			<return>return <expr><name>x</name></expr>;</return></then></if>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* can't do it */</comment>
	}</block></then></if>
	<if>if <condition>(<expr><name>slotw</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>x</name> = <call><name>slotw</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>x</name> != <name>Py_NotImplemented</name></expr>)</condition><then>
			<return>return <expr><name>x</name></expr>;</return></then></if>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* can't do it */</comment>
	}</block></then></if>
	<if>if <condition>(<expr>!<call><name>NEW_STYLE_NUMBER</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call> || !<call><name>NEW_STYLE_NUMBER</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<decl_stmt><decl><type><name>int</name></type> <name>err</name> <init>= <expr><call><name>PyNumber_CoerceEx</name><argument_list>(<argument><expr>&amp;<name>v</name></expr></argument>, <argument><expr>&amp;<name>w</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if>if <condition>(<expr><name>err</name> &lt; 0</expr>)</condition><then> <block>{
			<return>return <expr><name>NULL</name></expr>;</return>
		}</block></then></if>
		<if>if <condition>(<expr><name>err</name> == 0</expr>)</condition><then> <block>{
			<decl_stmt><decl><type><name>PyNumberMethods</name> *</type><name>mv</name> <init>= <expr><name><name>v</name>-&gt;<name>ob_type</name>-&gt;<name>tp_as_number</name></name></expr></init></decl>;</decl_stmt>
			<if>if <condition>(<expr><name>mv</name></expr>)</condition><then> <block>{
				<decl_stmt><decl><type><name>binaryfunc</name></type> <name>slot</name></decl>;</decl_stmt>
				<expr_stmt><expr><name>slot</name> = <call><name>NB_BINOP</name><argument_list>(<argument><expr><name>mv</name></expr></argument>, <argument><expr><name>op_slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if>if <condition>(<expr><name>slot</name></expr>)</condition><then> <block>{
					<expr_stmt><expr><name>x</name> = <call><name>slot</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<return>return <expr><name>x</name></expr>;</return>
				}</block></then></if>
			}</block></then></if>
			<comment type="block">/* CoerceEx incremented the reference counts */</comment>
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></then></if>
	}</block></then></if>
	<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_NotImplemented</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>Py_NotImplemented</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>binop_type_error</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>v</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>w</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>op_name</name></decl></param>)</parameter_list>
<block>{
	<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
		     <argument><expr>"unsupported operand type(s) for %.100s: "
		     "'%.100s' and '%.100s'"</expr></argument>,
		     <argument><expr><name>op_name</name></expr></argument>,
		     <argument><expr><name><name>v</name>-&gt;<name>ob_type</name>-&gt;<name>tp_name</name></name></expr></argument>,
		     <argument><expr><name><name>w</name>-&gt;<name>ob_type</name>-&gt;<name>tp_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>NULL</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>binary_op</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>v</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>w</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>int</name></type> <name>op_slot</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>op_name</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>result</name> <init>= <expr><call><name>binary_op1</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>w</name></expr></argument>, <argument><expr><name>op_slot</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if>if <condition>(<expr><name>result</name> == <name>Py_NotImplemented</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><call><name>binop_type_error</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>w</name></expr></argument>, <argument><expr><name>op_name</name></expr></argument>)</argument_list></call></expr>;</return>
	}</block></then></if>
	<return>return <expr><name>result</name></expr>;</return>
}</block></function>


<comment type="block">/*
  Calling scheme used for ternary operations:

  *** In some cases, w.op is called before v.op; see binary_op1. ***

  v	w	z	Action
  -------------------------------------------------------------------
  new	new	new	v.op(v,w,z), w.op(v,w,z), z.op(v,w,z)
  new	old	new	v.op(v,w,z), z.op(v,w,z), coerce(v,w,z), v.op(v,w,z)
  old	new	new	w.op(v,w,z), z.op(v,w,z), coerce(v,w,z), v.op(v,w,z)
  old	old	new	z.op(v,w,z), coerce(v,w,z), v.op(v,w,z)
  new	new	old	v.op(v,w,z), w.op(v,w,z), coerce(v,w,z), v.op(v,w,z)
  new	old	old	v.op(v,w,z), coerce(v,w,z), v.op(v,w,z)
  old	new	old	w.op(v,w,z), coerce(v,w,z), v.op(v,w,z)
  old	old	old	coerce(v,w,z), v.op(v,w,z)

  Legend:
  -------
  * new == new style number
  * old == old style number
  * Action indicates the order in which operations are tried until either
    a valid result is produced or an error occurs.
  * coerce(v,w,z) actually does: coerce(v,w), coerce(v,z), coerce(w,z) and
    only if z != Py_None; if z == Py_None, then it is treated as absent
    variable and only coerce(v,w) is tried.

 */</comment>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>ternary_op</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>v</name></decl></param>,
	   <param><decl><type><name>PyObject</name> *</type><name>w</name></decl></param>,
	   <param><decl><type><name>PyObject</name> *</type><name>z</name></decl></param>,
	   <param><decl><type><specifier>const</specifier> <name>int</name></type> <name>op_slot</name></decl></param>,
	   <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>op_name</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyNumberMethods</name> *</type><name>mv</name></decl>, *<decl><type ref="prev"/><name>mw</name></decl>, *<decl><type ref="prev"/><name>mz</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>x</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ternaryfunc</name></type> <name>slotv</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ternaryfunc</name></type> <name>slotw</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ternaryfunc</name></type> <name>slotz</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>mv</name> = <name><name>v</name>-&gt;<name>ob_type</name>-&gt;<name>tp_as_number</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>mw</name> = <name><name>w</name>-&gt;<name>ob_type</name>-&gt;<name>tp_as_number</name></name></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>mv</name> != <name>NULL</name> &amp;&amp; <call><name>NEW_STYLE_NUMBER</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<expr_stmt><expr><name>slotv</name> = <call><name>NB_TERNOP</name><argument_list>(<argument><expr><name>mv</name></expr></argument>, <argument><expr><name>op_slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
	<if>if <condition>(<expr><name><name>w</name>-&gt;<name>ob_type</name></name> != <name><name>v</name>-&gt;<name>ob_type</name></name> &amp;&amp;
	    <name>mw</name> != <name>NULL</name> &amp;&amp; <call><name>NEW_STYLE_NUMBER</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>slotw</name> = <call><name>NB_TERNOP</name><argument_list>(<argument><expr><name>mw</name></expr></argument>, <argument><expr><name>op_slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>slotw</name> == <name>slotv</name></expr>)</condition><then>
			<expr_stmt><expr><name>slotw</name> = <name>NULL</name></expr>;</expr_stmt></then></if>
	}</block></then></if>
	<if>if <condition>(<expr><name>slotv</name></expr>)</condition><then> <block>{
		<if>if <condition>(<expr><name>slotw</name> &amp;&amp; <call><name>PyType_IsSubtype</name><argument_list>(<argument><expr><name><name>w</name>-&gt;<name>ob_type</name></name></expr></argument>, <argument><expr><name><name>v</name>-&gt;<name>ob_type</name></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
			<expr_stmt><expr><name>x</name> = <call><name>slotw</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>w</name></expr></argument>, <argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><name>x</name> != <name>Py_NotImplemented</name></expr>)</condition><then>
				<return>return <expr><name>x</name></expr>;</return></then></if>
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* can't do it */</comment>
			<expr_stmt><expr><name>slotw</name> = <name>NULL</name></expr>;</expr_stmt>
		}</block></then></if>
		<expr_stmt><expr><name>x</name> = <call><name>slotv</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>w</name></expr></argument>, <argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>x</name> != <name>Py_NotImplemented</name></expr>)</condition><then>
			<return>return <expr><name>x</name></expr>;</return></then></if>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* can't do it */</comment>
	}</block></then></if>
	<if>if <condition>(<expr><name>slotw</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>x</name> = <call><name>slotw</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>w</name></expr></argument>, <argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>x</name> != <name>Py_NotImplemented</name></expr>)</condition><then>
			<return>return <expr><name>x</name></expr>;</return></then></if>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* can't do it */</comment>
	}</block></then></if>
	<expr_stmt><expr><name>mz</name> = <name><name>z</name>-&gt;<name>ob_type</name>-&gt;<name>tp_as_number</name></name></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>mz</name> != <name>NULL</name> &amp;&amp; <call><name>NEW_STYLE_NUMBER</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>slotz</name> = <call><name>NB_TERNOP</name><argument_list>(<argument><expr><name>mz</name></expr></argument>, <argument><expr><name>op_slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>slotz</name> == <name>slotv</name> || <name>slotz</name> == <name>slotw</name></expr>)</condition><then>
			<expr_stmt><expr><name>slotz</name> = <name>NULL</name></expr>;</expr_stmt></then></if>
		<if>if <condition>(<expr><name>slotz</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><name>x</name> = <call><name>slotz</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>w</name></expr></argument>, <argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><name>x</name> != <name>Py_NotImplemented</name></expr>)</condition><then>
				<return>return <expr><name>x</name></expr>;</return></then></if>
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* can't do it */</comment>
		}</block></then></if>
	}</block></then></if>

	<if>if <condition>(<expr>!<call><name>NEW_STYLE_NUMBER</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call> || !<call><name>NEW_STYLE_NUMBER</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call> ||
			(<name>z</name> != <name>Py_None</name> &amp;&amp; !<call><name>NEW_STYLE_NUMBER</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call>)</expr>)</condition><then> <block>{
		<comment type="block">/* we have an old style operand, coerce */</comment>
		<decl_stmt><decl><type><name>PyObject</name> *</type><name>v1</name></decl>, *<decl><type ref="prev"/><name>z1</name></decl>, *<decl><type ref="prev"/><name>w2</name></decl>, *<decl><type ref="prev"/><name>z2</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>c</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>c</name> = <call><name>PyNumber_Coerce</name><argument_list>(<argument><expr>&amp;<name>v</name></expr></argument>, <argument><expr>&amp;<name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>c</name> != 0</expr>)</condition><then>
			<goto>goto <name>error3</name>;</goto></then></if>

		<comment type="block">/* Special case: if the third argument is None, it is
		   treated as absent argument and not coerced. */</comment>
		<if>if <condition>(<expr><name>z</name> == <name>Py_None</name></expr>)</condition><then> <block>{
			<if>if <condition>(<expr><name><name>v</name>-&gt;<name>ob_type</name>-&gt;<name>tp_as_number</name></name></expr>)</condition><then> <block>{
				<expr_stmt><expr><name>slotz</name> = <call><name>NB_TERNOP</name><argument_list>(<argument><expr><name><name>v</name>-&gt;<name>ob_type</name>-&gt;<name>tp_as_number</name></name></expr></argument>,
						  <argument><expr><name>op_slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if>if <condition>(<expr><name>slotz</name></expr>)</condition><then>
					<expr_stmt><expr><name>x</name> = <call><name>slotz</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>w</name></expr></argument>, <argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
				<else>else
					<expr_stmt><expr><name>c</name> = -1</expr>;</expr_stmt></else></if>
			}</block></then>
			<else>else
				<expr_stmt><expr><name>c</name> = -1</expr>;</expr_stmt></else></if>
			<goto>goto <name>error2</name>;</goto>
		}</block></then></if>
		<expr_stmt><expr><name>v1</name> = <name>v</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>z1</name> = <name>z</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>c</name> = <call><name>PyNumber_Coerce</name><argument_list>(<argument><expr>&amp;<name>v1</name></expr></argument>, <argument><expr>&amp;<name>z1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>c</name> != 0</expr>)</condition><then>
			<goto>goto <name>error2</name>;</goto></then></if>
		<expr_stmt><expr><name>w2</name> = <name>w</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>z2</name> = <name>z1</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>c</name> = <call><name>PyNumber_Coerce</name><argument_list>(<argument><expr>&amp;<name>w2</name></expr></argument>, <argument><expr>&amp;<name>z2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>c</name> != 0</expr>)</condition><then>
			<goto>goto <name>error1</name>;</goto></then></if>

		<if>if <condition>(<expr><name><name>v1</name>-&gt;<name>ob_type</name>-&gt;<name>tp_as_number</name></name> != <name>NULL</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><name>slotv</name> = <call><name>NB_TERNOP</name><argument_list>(<argument><expr><name><name>v1</name>-&gt;<name>ob_type</name>-&gt;<name>tp_as_number</name></name></expr></argument>,
					  <argument><expr><name>op_slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><name>slotv</name></expr>)</condition><then>
				<expr_stmt><expr><name>x</name> = <call><name>slotv</name><argument_list>(<argument><expr><name>v1</name></expr></argument>, <argument><expr><name>w2</name></expr></argument>, <argument><expr><name>z2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
			<else>else
				<expr_stmt><expr><name>c</name> = -1</expr>;</expr_stmt></else></if>
		}</block></then>
		<else>else
			<expr_stmt><expr><name>c</name> = -1</expr>;</expr_stmt></else></if>

		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>w2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>z2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<label><name>error1</name>:</label>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>v1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>z1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<label><name>error2</name>:</label>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<label><name>error3</name>:</label>
		<if>if <condition>(<expr><name>c</name> &gt;= 0</expr>)</condition><then>
			<return>return <expr><name>x</name></expr>;</return></then></if>
	}</block></then></if>

	<if>if <condition>(<expr><name>z</name> == <name>Py_None</name></expr>)</condition><then>
		<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(
			<argument><expr><name>PyExc_TypeError</name></expr></argument>,
			<argument><expr>"unsupported operand type(s) for ** or pow(): "
			"'%.100s' and '%.100s'"</expr></argument>,
			<argument><expr><name><name>v</name>-&gt;<name>ob_type</name>-&gt;<name>tp_name</name></name></expr></argument>,
			<argument><expr><name><name>w</name>-&gt;<name>ob_type</name>-&gt;<name>tp_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
	<else>else
		<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(
			<argument><expr><name>PyExc_TypeError</name></expr></argument>,
			<argument><expr>"unsupported operand type(s) for pow(): "
			"'%.100s', '%.100s', '%.100s'"</expr></argument>,
			<argument><expr><name><name>v</name>-&gt;<name>ob_type</name>-&gt;<name>tp_name</name></name></expr></argument>,
			<argument><expr><name><name>w</name>-&gt;<name>ob_type</name>-&gt;<name>tp_name</name></name></expr></argument>,
			<argument><expr><name><name>z</name>-&gt;<name>ob_type</name>-&gt;<name>tp_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
	<return>return <expr><name>NULL</name></expr>;</return>
}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BINARY_FUNC</name><parameter_list>(<param><type><name>func</name></type></param>, <param><type><name>op</name></type></param>, <param><type><name>op_name</name></type></param>)</parameter_list></cpp:macro> \
    <cpp:value>PyObject * \
    func(PyObject *v, PyObject *w) { \
	    return binary_op(v, w, NB_SLOT(op), op_name); \
    }</cpp:value></cpp:define>

<macro><name>BINARY_FUNC</name><argument_list>(<argument>PyNumber_Or</argument>, <argument>nb_or</argument>, <argument>"|"</argument>)</argument_list></macro>
<macro><name>BINARY_FUNC</name><argument_list>(<argument>PyNumber_Xor</argument>, <argument>nb_xor</argument>, <argument>"^"</argument>)</argument_list></macro>
<macro><name>BINARY_FUNC</name><argument_list>(<argument>PyNumber_And</argument>, <argument>nb_and</argument>, <argument>"&amp;"</argument>)</argument_list></macro>
<macro><name>BINARY_FUNC</name><argument_list>(<argument>PyNumber_Lshift</argument>, <argument>nb_lshift</argument>, <argument>"&lt;&lt;"</argument>)</argument_list></macro>
<macro><name>BINARY_FUNC</name><argument_list>(<argument>PyNumber_Rshift</argument>, <argument>nb_rshift</argument>, <argument>"&gt;&gt;"</argument>)</argument_list></macro>
<macro><name>BINARY_FUNC</name><argument_list>(<argument>PyNumber_Subtract</argument>, <argument>nb_subtract</argument>, <argument>"-"</argument>)</argument_list></macro>
<macro><name>BINARY_FUNC</name><argument_list>(<argument>PyNumber_Divide</argument>, <argument>nb_divide</argument>, <argument>"/"</argument>)</argument_list></macro>
<macro><name>BINARY_FUNC</name><argument_list>(<argument>PyNumber_Divmod</argument>, <argument>nb_divmod</argument>, <argument>"divmod()"</argument>)</argument_list></macro>

<function><type><name>PyObject</name> *</type>
<name>PyNumber_Add</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>v</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>w</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>result</name> <init>= <expr><call><name>binary_op1</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>w</name></expr></argument>, <argument><expr><call><name>NB_SLOT</name><argument_list>(<argument><expr><name>nb_add</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if>if <condition>(<expr><name>result</name> == <name>Py_NotImplemented</name></expr>)</condition><then> <block>{
		<decl_stmt><decl><type><name>PySequenceMethods</name> *</type><name>m</name> <init>= <expr><name><name>v</name>-&gt;<name>ob_type</name>-&gt;<name>tp_as_sequence</name></name></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>m</name> &amp;&amp; <name><name>m</name>-&gt;<name>sq_concat</name></name></expr>)</condition><then> <block>{
			<return>return <expr><call>(*<name><name>m</name>-&gt;<name>sq_concat</name></name>)<argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</return>
		}</block></then></if>
		<expr_stmt><expr><name>result</name> = <call><name>binop_type_error</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>w</name></expr></argument>, <argument><expr>"+"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>
	<return>return <expr><name>result</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>sequence_repeat</name><parameter_list>(<param><decl><type><name>ssizeargfunc</name></type> <name>repeatfunc</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>seq</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>n</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>count</name></decl>;</decl_stmt>
	<if>if <condition>(<expr><call><name>PyIndex_Check</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>count</name> = <call><name>PyNumber_AsSsize_t</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>PyExc_OverflowError</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>count</name> == -1 &amp;&amp; <call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then>
			<return>return <expr><name>NULL</name></expr>;</return></then></if>
	}</block></then>
	<else>else <block>{
		<return>return <expr><call><name>type_error</name><argument_list>(<argument><expr>"can't multiply sequence by "
				  "non-int of type '%.200s'"</expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</return>
	}</block></else></if>
	<return>return <expr><call>(*<name>repeatfunc</name>)<argument_list>(<argument><expr><name>seq</name></expr></argument>, <argument><expr><name>count</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>PyObject</name> *</type>
<name>PyNumber_Multiply</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>v</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>w</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>result</name> <init>= <expr><call><name>binary_op1</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>w</name></expr></argument>, <argument><expr><call><name>NB_SLOT</name><argument_list>(<argument><expr><name>nb_multiply</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if>if <condition>(<expr><name>result</name> == <name>Py_NotImplemented</name></expr>)</condition><then> <block>{
		<decl_stmt><decl><type><name>PySequenceMethods</name> *</type><name>mv</name> <init>= <expr><name><name>v</name>-&gt;<name>ob_type</name>-&gt;<name>tp_as_sequence</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PySequenceMethods</name> *</type><name>mw</name> <init>= <expr><name><name>w</name>-&gt;<name>ob_type</name>-&gt;<name>tp_as_sequence</name></name></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if  <condition>(<expr><name>mv</name> &amp;&amp; <name><name>mv</name>-&gt;<name>sq_repeat</name></name></expr>)</condition><then> <block>{
			<return>return <expr><call><name>sequence_repeat</name><argument_list>(<argument><expr><name><name>mv</name>-&gt;<name>sq_repeat</name></name></expr></argument>, <argument><expr><name>v</name></expr></argument>, <argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</return>
		}</block></then>
		<else>else <if>if <condition>(<expr><name>mw</name> &amp;&amp; <name><name>mw</name>-&gt;<name>sq_repeat</name></name></expr>)</condition><then> <block>{
			<return>return <expr><call><name>sequence_repeat</name><argument_list>(<argument><expr><name><name>mw</name>-&gt;<name>sq_repeat</name></name></expr></argument>, <argument><expr><name>w</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</return>
		}</block></then></if></else></if>
		<expr_stmt><expr><name>result</name> = <call><name>binop_type_error</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>w</name></expr></argument>, <argument><expr>"*"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>
	<return>return <expr><name>result</name></expr>;</return>
}</block></function>

<function><type><name>PyObject</name> *</type>
<name>PyNumber_FloorDivide</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>v</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>w</name></decl></param>)</parameter_list>
<block>{
	<comment type="block">/* XXX tp_flags test */</comment>
	<return>return <expr><call><name>binary_op</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>w</name></expr></argument>, <argument><expr><call><name>NB_SLOT</name><argument_list>(<argument><expr><name>nb_floor_divide</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>"//"</expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>PyObject</name> *</type>
<name>PyNumber_TrueDivide</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>v</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>w</name></decl></param>)</parameter_list>
<block>{
	<comment type="block">/* XXX tp_flags test */</comment>
	<return>return <expr><call><name>binary_op</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>w</name></expr></argument>, <argument><expr><call><name>NB_SLOT</name><argument_list>(<argument><expr><name>nb_true_divide</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>"/"</expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>PyObject</name> *</type>
<name>PyNumber_Remainder</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>v</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>w</name></decl></param>)</parameter_list>
<block>{
	<return>return <expr><call><name>binary_op</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>w</name></expr></argument>, <argument><expr><call><name>NB_SLOT</name><argument_list>(<argument><expr><name>nb_remainder</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>"%"</expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>PyObject</name> *</type>
<name>PyNumber_Power</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>v</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>w</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>z</name></decl></param>)</parameter_list>
<block>{
	<return>return <expr><call><name>ternary_op</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>w</name></expr></argument>, <argument><expr><name>z</name></expr></argument>, <argument><expr><call><name>NB_SLOT</name><argument_list>(<argument><expr><name>nb_power</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>"** or pow()"</expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<comment type="block">/* Binary in-place operators */</comment>

<comment type="block">/* The in-place operators are defined to fall back to the 'normal',
   non in-place operations, if the in-place methods are not in place.

   - If the left hand object has the appropriate struct members, and
     they are filled, call the appropriate function and return the
     result.  No coercion is done on the arguments; the left-hand object
     is the one the operation is performed on, and it's up to the
     function to deal with the right-hand object.

   - Otherwise, in-place modification is not supported. Handle it exactly as
     a non in-place operation of the same kind.

   */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HASINPLACE</name><parameter_list>(<param><type><name>t</name></type></param>)</parameter_list></cpp:macro> \
	<cpp:value>PyType_HasFeature((t)-&gt;ob_type, Py_TPFLAGS_HAVE_INPLACEOPS)</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>binary_iop1</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>v</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>w</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>int</name></type> <name>iop_slot</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>int</name></type> <name>op_slot</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyNumberMethods</name> *</type><name>mv</name> <init>= <expr><name><name>v</name>-&gt;<name>ob_type</name>-&gt;<name>tp_as_number</name></name></expr></init></decl>;</decl_stmt>
	<if>if <condition>(<expr><name>mv</name> != <name>NULL</name> &amp;&amp; <call><name>HASINPLACE</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<decl_stmt><decl><type><name>binaryfunc</name></type> <name>slot</name> <init>= <expr><call><name>NB_BINOP</name><argument_list>(<argument><expr><name>mv</name></expr></argument>, <argument><expr><name>iop_slot</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if>if <condition>(<expr><name>slot</name></expr>)</condition><then> <block>{
			<decl_stmt><decl><type><name>PyObject</name> *</type><name>x</name> <init>= <expr><call>(<name>slot</name>)<argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>w</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<if>if <condition>(<expr><name>x</name> != <name>Py_NotImplemented</name></expr>)</condition><then> <block>{
				<return>return <expr><name>x</name></expr>;</return>
			}</block></then></if>
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></then></if>
	}</block></then></if>
	<return>return <expr><call><name>binary_op1</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>w</name></expr></argument>, <argument><expr><name>op_slot</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>binary_iop</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>v</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>w</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>int</name></type> <name>iop_slot</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>int</name></type> <name>op_slot</name></decl></param>,
		<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>op_name</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>result</name> <init>= <expr><call><name>binary_iop1</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>w</name></expr></argument>, <argument><expr><name>iop_slot</name></expr></argument>, <argument><expr><name>op_slot</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if>if <condition>(<expr><name>result</name> == <name>Py_NotImplemented</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><call><name>binop_type_error</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>w</name></expr></argument>, <argument><expr><name>op_name</name></expr></argument>)</argument_list></call></expr>;</return>
	}</block></then></if>
	<return>return <expr><name>result</name></expr>;</return>
}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INPLACE_BINOP</name><parameter_list>(<param><type><name>func</name></type></param>, <param><type><name>iop</name></type></param>, <param><type><name>op</name></type></param>, <param><type><name>op_name</name></type></param>)</parameter_list></cpp:macro> \
	<cpp:value>PyObject * \
	func(PyObject *v, PyObject *w) { \
		return binary_iop(v, w, NB_SLOT(iop), NB_SLOT(op), op_name); \
	}</cpp:value></cpp:define>

<macro><name>INPLACE_BINOP</name><argument_list>(<argument>PyNumber_InPlaceOr</argument>, <argument>nb_inplace_or</argument>, <argument>nb_or</argument>, <argument>"|="</argument>)</argument_list></macro>
<macro><name>INPLACE_BINOP</name><argument_list>(<argument>PyNumber_InPlaceXor</argument>, <argument>nb_inplace_xor</argument>, <argument>nb_xor</argument>, <argument>"^="</argument>)</argument_list></macro>
<macro><name>INPLACE_BINOP</name><argument_list>(<argument>PyNumber_InPlaceAnd</argument>, <argument>nb_inplace_and</argument>, <argument>nb_and</argument>, <argument>"&amp;="</argument>)</argument_list></macro>
<macro><name>INPLACE_BINOP</name><argument_list>(<argument>PyNumber_InPlaceLshift</argument>, <argument>nb_inplace_lshift</argument>, <argument>nb_lshift</argument>, <argument>"&lt;&lt;="</argument>)</argument_list></macro>
<macro><name>INPLACE_BINOP</name><argument_list>(<argument>PyNumber_InPlaceRshift</argument>, <argument>nb_inplace_rshift</argument>, <argument>nb_rshift</argument>, <argument>"&gt;&gt;="</argument>)</argument_list></macro>
<macro><name>INPLACE_BINOP</name><argument_list>(<argument>PyNumber_InPlaceSubtract</argument>, <argument>nb_inplace_subtract</argument>, <argument>nb_subtract</argument>, <argument>"-="</argument>)</argument_list></macro>
<macro><name>INPLACE_BINOP</name><argument_list>(<argument>PyNumber_InPlaceDivide</argument>, <argument>nb_inplace_divide</argument>, <argument>nb_divide</argument>, <argument>"/="</argument>)</argument_list></macro>

<function><type><name>PyObject</name> *</type>
<name>PyNumber_InPlaceFloorDivide</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>v</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>w</name></decl></param>)</parameter_list>
<block>{
	<comment type="block">/* XXX tp_flags test */</comment>
	<return>return <expr><call><name>binary_iop</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>w</name></expr></argument>, <argument><expr><call><name>NB_SLOT</name><argument_list>(<argument><expr><name>nb_inplace_floor_divide</name></expr></argument>)</argument_list></call></expr></argument>,
			  <argument><expr><call><name>NB_SLOT</name><argument_list>(<argument><expr><name>nb_floor_divide</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>"//="</expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>PyObject</name> *</type>
<name>PyNumber_InPlaceTrueDivide</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>v</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>w</name></decl></param>)</parameter_list>
<block>{
	<comment type="block">/* XXX tp_flags test */</comment>
	<return>return <expr><call><name>binary_iop</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>w</name></expr></argument>, <argument><expr><call><name>NB_SLOT</name><argument_list>(<argument><expr><name>nb_inplace_true_divide</name></expr></argument>)</argument_list></call></expr></argument>,
			  <argument><expr><call><name>NB_SLOT</name><argument_list>(<argument><expr><name>nb_true_divide</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>"/="</expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>PyObject</name> *</type>
<name>PyNumber_InPlaceAdd</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>v</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>w</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>result</name> <init>= <expr><call><name>binary_iop1</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>w</name></expr></argument>, <argument><expr><call><name>NB_SLOT</name><argument_list>(<argument><expr><name>nb_inplace_add</name></expr></argument>)</argument_list></call></expr></argument>,
				       <argument><expr><call><name>NB_SLOT</name><argument_list>(<argument><expr><name>nb_add</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if>if <condition>(<expr><name>result</name> == <name>Py_NotImplemented</name></expr>)</condition><then> <block>{
		<decl_stmt><decl><type><name>PySequenceMethods</name> *</type><name>m</name> <init>= <expr><name><name>v</name>-&gt;<name>ob_type</name>-&gt;<name>tp_as_sequence</name></name></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>m</name> != <name>NULL</name></expr>)</condition><then> <block>{
			<decl_stmt><decl><type><name>binaryfunc</name></type> <name>f</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
			<if>if <condition>(<expr><call><name>HASINPLACE</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>)</condition><then>
				<expr_stmt><expr><name>f</name> = <name><name>m</name>-&gt;<name>sq_inplace_concat</name></name></expr>;</expr_stmt></then></if>
			<if>if <condition>(<expr><name>f</name> == <name>NULL</name></expr>)</condition><then>
				<expr_stmt><expr><name>f</name> = <name><name>m</name>-&gt;<name>sq_concat</name></name></expr>;</expr_stmt></then></if>
			<if>if <condition>(<expr><name>f</name> != <name>NULL</name></expr>)</condition><then>
				<return>return <expr><call>(*<name>f</name>)<argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
		}</block></then></if>
		<expr_stmt><expr><name>result</name> = <call><name>binop_type_error</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>w</name></expr></argument>, <argument><expr>"+="</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>
	<return>return <expr><name>result</name></expr>;</return>
}</block></function>

<function><type><name>PyObject</name> *</type>
<name>PyNumber_InPlaceMultiply</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>v</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>w</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>result</name> <init>= <expr><call><name>binary_iop1</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>w</name></expr></argument>, <argument><expr><call><name>NB_SLOT</name><argument_list>(<argument><expr><name>nb_inplace_multiply</name></expr></argument>)</argument_list></call></expr></argument>,
				       <argument><expr><call><name>NB_SLOT</name><argument_list>(<argument><expr><name>nb_multiply</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if>if <condition>(<expr><name>result</name> == <name>Py_NotImplemented</name></expr>)</condition><then> <block>{
		<decl_stmt><decl><type><name>ssizeargfunc</name></type> <name>f</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PySequenceMethods</name> *</type><name>mv</name> <init>= <expr><name><name>v</name>-&gt;<name>ob_type</name>-&gt;<name>tp_as_sequence</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PySequenceMethods</name> *</type><name>mw</name> <init>= <expr><name><name>w</name>-&gt;<name>ob_type</name>-&gt;<name>tp_as_sequence</name></name></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>mv</name> != <name>NULL</name></expr>)</condition><then> <block>{
			<if>if <condition>(<expr><call><name>HASINPLACE</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>)</condition><then>
				<expr_stmt><expr><name>f</name> = <name><name>mv</name>-&gt;<name>sq_inplace_repeat</name></name></expr>;</expr_stmt></then></if>
			<if>if <condition>(<expr><name>f</name> == <name>NULL</name></expr>)</condition><then>
				<expr_stmt><expr><name>f</name> = <name><name>mv</name>-&gt;<name>sq_repeat</name></name></expr>;</expr_stmt></then></if>
			<if>if <condition>(<expr><name>f</name> != <name>NULL</name></expr>)</condition><then>
				<return>return <expr><call><name>sequence_repeat</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><name>v</name></expr></argument>, <argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
		}</block></then>
		<else>else <if>if <condition>(<expr><name>mw</name> != <name>NULL</name></expr>)</condition><then> <block>{
			<comment type="block">/* Note that the right hand operand should not be
			 * mutated in this case so sq_inplace_repeat is not
			 * used. */</comment>
			<if>if <condition>(<expr><name><name>mw</name>-&gt;<name>sq_repeat</name></name></expr>)</condition><then>
				<return>return <expr><call><name>sequence_repeat</name><argument_list>(<argument><expr><name><name>mw</name>-&gt;<name>sq_repeat</name></name></expr></argument>, <argument><expr><name>w</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
		}</block></then></if></else></if>
		<expr_stmt><expr><name>result</name> = <call><name>binop_type_error</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>w</name></expr></argument>, <argument><expr>"*="</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>
	<return>return <expr><name>result</name></expr>;</return>
}</block></function>

<function><type><name>PyObject</name> *</type>
<name>PyNumber_InPlaceRemainder</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>v</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>w</name></decl></param>)</parameter_list>
<block>{
	<return>return <expr><call><name>binary_iop</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>w</name></expr></argument>, <argument><expr><call><name>NB_SLOT</name><argument_list>(<argument><expr><name>nb_inplace_remainder</name></expr></argument>)</argument_list></call></expr></argument>,
				<argument><expr><call><name>NB_SLOT</name><argument_list>(<argument><expr><name>nb_remainder</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>"%="</expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>PyObject</name> *</type>
<name>PyNumber_InPlacePower</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>v</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>w</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>z</name></decl></param>)</parameter_list>
<block>{
	<if>if <condition>(<expr><call><name>HASINPLACE</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call> &amp;&amp; <name><name>v</name>-&gt;<name>ob_type</name>-&gt;<name>tp_as_number</name></name> &amp;&amp;
	    <name><name>v</name>-&gt;<name>ob_type</name>-&gt;<name>tp_as_number</name>-&gt;<name>nb_inplace_power</name></name> != <name>NULL</name></expr>)</condition><then> <block>{
		<return>return <expr><call><name>ternary_op</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>w</name></expr></argument>, <argument><expr><name>z</name></expr></argument>, <argument><expr><call><name>NB_SLOT</name><argument_list>(<argument><expr><name>nb_inplace_power</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>"**="</expr></argument>)</argument_list></call></expr>;</return>
	}</block></then>
	<else>else <block>{
		<return>return <expr><call><name>ternary_op</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>w</name></expr></argument>, <argument><expr><name>z</name></expr></argument>, <argument><expr><call><name>NB_SLOT</name><argument_list>(<argument><expr><name>nb_power</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>"**="</expr></argument>)</argument_list></call></expr>;</return>
	}</block></else></if>
}</block></function>


<comment type="block">/* Unary operators and functions */</comment>

<function><type><name>PyObject</name> *</type>
<name>PyNumber_Negative</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>o</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyNumberMethods</name> *</type><name>m</name></decl>;</decl_stmt>

	<if>if <condition>(<expr><name>o</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr><call><name>null_error</name><argument_list>()</argument_list></call></expr>;</return></then></if>
	<expr_stmt><expr><name>m</name> = <name><name>o</name>-&gt;<name>ob_type</name>-&gt;<name>tp_as_number</name></name></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>m</name> &amp;&amp; <name><name>m</name>-&gt;<name>nb_negative</name></name></expr>)</condition><then>
		<return>return <expr><call>(*<name><name>m</name>-&gt;<name>nb_negative</name></name>)<argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>;</return></then></if>

	<return>return <expr><call><name>type_error</name><argument_list>(<argument><expr>"bad operand type for unary -: '%.200s'"</expr></argument>, <argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>PyObject</name> *</type>
<name>PyNumber_Positive</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>o</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyNumberMethods</name> *</type><name>m</name></decl>;</decl_stmt>

	<if>if <condition>(<expr><name>o</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr><call><name>null_error</name><argument_list>()</argument_list></call></expr>;</return></then></if>
	<expr_stmt><expr><name>m</name> = <name><name>o</name>-&gt;<name>ob_type</name>-&gt;<name>tp_as_number</name></name></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>m</name> &amp;&amp; <name><name>m</name>-&gt;<name>nb_positive</name></name></expr>)</condition><then>
		<return>return <expr><call>(*<name><name>m</name>-&gt;<name>nb_positive</name></name>)<argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>;</return></then></if>

	<return>return <expr><call><name>type_error</name><argument_list>(<argument><expr>"bad operand type for unary +: '%.200s'"</expr></argument>, <argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>PyObject</name> *</type>
<name>PyNumber_Invert</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>o</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyNumberMethods</name> *</type><name>m</name></decl>;</decl_stmt>

	<if>if <condition>(<expr><name>o</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr><call><name>null_error</name><argument_list>()</argument_list></call></expr>;</return></then></if>
	<expr_stmt><expr><name>m</name> = <name><name>o</name>-&gt;<name>ob_type</name>-&gt;<name>tp_as_number</name></name></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>m</name> &amp;&amp; <name><name>m</name>-&gt;<name>nb_invert</name></name></expr>)</condition><then>
		<return>return <expr><call>(*<name><name>m</name>-&gt;<name>nb_invert</name></name>)<argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>;</return></then></if>

	<return>return <expr><call><name>type_error</name><argument_list>(<argument><expr>"bad operand type for unary ~: '%.200s'"</expr></argument>, <argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>PyObject</name> *</type>
<name>PyNumber_Absolute</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>o</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyNumberMethods</name> *</type><name>m</name></decl>;</decl_stmt>

	<if>if <condition>(<expr><name>o</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr><call><name>null_error</name><argument_list>()</argument_list></call></expr>;</return></then></if>
	<expr_stmt><expr><name>m</name> = <name><name>o</name>-&gt;<name>ob_type</name>-&gt;<name>tp_as_number</name></name></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>m</name> &amp;&amp; <name><name>m</name>-&gt;<name>nb_absolute</name></name></expr>)</condition><then>
		<return>return <expr><call><name><name>m</name>-&gt;<name>nb_absolute</name></name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>;</return></then></if>

	<return>return <expr><call><name>type_error</name><argument_list>(<argument><expr>"bad operand type for abs(): '%.200s'"</expr></argument>, <argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<comment type="block">/* Add a check for embedded NULL-bytes in the argument. */</comment>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>int_from_string</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>s</name></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>len</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>char</name> *</type><name>end</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>x</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>x</name> = <call><name>PyInt_FromString</name><argument_list>(<argument><expr>(<name>char</name>*)<name>s</name></expr></argument>, <argument><expr>&amp;<name>end</name></expr></argument>, <argument><expr>10</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>x</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<if>if <condition>(<expr><name>end</name> != <name>s</name> + <name>len</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>,
				<argument><expr>"null byte in argument for int()"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>
	<return>return <expr><name>x</name></expr>;</return>
}</block></function>

<comment type="block">/* Return a Python Int or Long from the object item 
   Raise TypeError if the result is not an int-or-long
   or if the object cannot be interpreted as an index. 
*/</comment>
<function><type><name>PyObject</name> *</type>
<name>PyNumber_Index</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>item</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>result</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<if>if <condition>(<expr><name>item</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr><call><name>null_error</name><argument_list>()</argument_list></call></expr>;</return></then></if>
	<if>if <condition>(<expr><call><name>PyInt_Check</name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call> || <call><name>PyLong_Check</name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>item</name></expr>;</return>
	}</block></then></if>
	<if>if <condition>(<expr><call><name>PyIndex_Check</name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>result</name> = <call><name><name>item</name>-&gt;<name>ob_type</name>-&gt;<name>tp_as_number</name>-&gt;<name>nb_index</name></name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>result</name> &amp;&amp;
		    !<call><name>PyInt_Check</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call> &amp;&amp; !<call><name>PyLong_Check</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
				     <argument><expr>"__index__ returned non-(int,long) " \
				     "(type %.200s)"</expr></argument>,
				     <argument><expr><name><name>result</name>-&gt;<name>ob_type</name>-&gt;<name>tp_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>NULL</name></expr>;</return>
		}</block></then></if>
	}</block></then>
	<else>else <block>{
		<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
			     <argument><expr>"'%.200s' object cannot be interpreted "
			     "as an index"</expr></argument>, <argument><expr><name><name>item</name>-&gt;<name>ob_type</name>-&gt;<name>tp_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></else></if>
	<return>return <expr><name>result</name></expr>;</return>
}</block></function>

<comment type="block">/* Return an error on Overflow only if err is not NULL*/</comment>

<function><type><name>Py_ssize_t</name></type>
<name>PyNumber_AsSsize_t</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>item</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>err</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>runerr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>value</name> <init>= <expr><call><name>PyNumber_Index</name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if>if <condition>(<expr><name>value</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr>-1</expr>;</return></then></if>

	<comment type="block">/* We're done if PyInt_AsSsize_t() returns without error. */</comment>
	<expr_stmt><expr><name>result</name> = <call><name>PyInt_AsSsize_t</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>result</name> != -1 || !(<name>runerr</name> = <call><name>PyErr_Occurred</name><argument_list>()</argument_list></call>)</expr>)</condition><then>
		<goto>goto <name>finish</name>;</goto></then></if>

	<comment type="block">/* Error handling code -- only manage OverflowError differently */</comment>
	<if>if <condition>(<expr>!<call><name>PyErr_GivenExceptionMatches</name><argument_list>(<argument><expr><name>runerr</name></expr></argument>, <argument><expr><name>PyExc_OverflowError</name></expr></argument>)</argument_list></call></expr>)</condition><then> 
		<goto>goto <name>finish</name>;</goto></then></if>

	<expr_stmt><expr><call><name>PyErr_Clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* If no error-handling desired then the default clipping 
	   is sufficient.
	 */</comment>
	<if>if <condition>(<expr>!<name>err</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>PyLong_Check</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* Whether or not it is less than or equal to 
		   zero is determined by the sign of ob_size
		*/</comment>
		<if>if <condition>(<expr><call><name>_PyLong_Sign</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then> 
			<expr_stmt><expr><name>result</name> = <name>PY_SSIZE_T_MIN</name></expr>;</expr_stmt></then>
		<else>else
			<expr_stmt><expr><name>result</name> = <name>PY_SSIZE_T_MAX</name></expr>;</expr_stmt></else></if>
	}</block></then>
	<else>else <block>{
		<comment type="block">/* Otherwise replace the error with caller's error object. */</comment>
		<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>err</name></expr></argument>,
			     <argument><expr>"cannot fit '%.200s' into an index-sized integer"</expr></argument>, 
			     <argument><expr><name><name>item</name>-&gt;<name>ob_type</name>-&gt;<name>tp_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
	}</block></else></if>
	
 <label><name>finish</name>:</label>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>result</name></expr>;</return>
}</block></function>


<function><type><name>PyObject</name> *</type>
<name>_PyNumber_ConvertIntegralToInt</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>integral</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name>*</type> <name>error_format</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>type_name</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>static</specifier> <name>PyObject</name> *</type><name>int_name</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<if>if <condition>(<expr><name>int_name</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>int_name</name> = <call><name>PyString_InternFromString</name><argument_list>(<argument><expr>"__int__"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>int_name</name> == <name>NULL</name></expr>)</condition><then>
			<return>return <expr><name>NULL</name></expr>;</return></then></if>
	}</block></then></if>

	<if>if <condition>(<expr><name>integral</name> &amp;&amp; (!<call><name>PyInt_Check</name><argument_list>(<argument><expr><name>integral</name></expr></argument>)</argument_list></call> &amp;&amp;
			 !<call><name>PyLong_Check</name><argument_list>(<argument><expr><name>integral</name></expr></argument>)</argument_list></call>)</expr>)</condition><then> <block>{
		<comment type="block">/* Don't go through tp_as_number-&gt;nb_int to avoid
		   hitting the classic class fallback to __trunc__. */</comment>
		<decl_stmt><decl><type><name>PyObject</name> *</type><name>int_func</name> <init>= <expr><call><name>PyObject_GetAttr</name><argument_list>(<argument><expr><name>integral</name></expr></argument>, <argument><expr><name>int_name</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if>if <condition>(<expr><name>int_func</name> == <name>NULL</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>PyErr_Clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt> <comment type="block">/* Raise a different error. */</comment>
			<goto>goto <name>non_integral_error</name>;</goto>
		}</block></then></if>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>integral</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>integral</name> = <call><name>PyEval_CallObject</name><argument_list>(<argument><expr><name>int_func</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>int_func</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>integral</name> &amp;&amp; (!<call><name>PyInt_Check</name><argument_list>(<argument><expr><name>integral</name></expr></argument>)</argument_list></call> &amp;&amp;
				  !<call><name>PyLong_Check</name><argument_list>(<argument><expr><name>integral</name></expr></argument>)</argument_list></call>)</expr>)</condition><then> <block>{
			<goto>goto <name>non_integral_error</name>;</goto>
		}</block></then></if>
	}</block></then></if>
	<return>return <expr><name>integral</name></expr>;</return>

<label><name>non_integral_error</name>:</label>
	<if>if <condition>(<expr><call><name>PyInstance_Check</name><argument_list>(<argument><expr><name>integral</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>type_name</name> = <call><name>PyString_AS_STRING</name><argument_list>(<argument><expr>((<name>PyInstanceObject</name> *)<name>integral</name>)
					       -&gt;<name><name>in_class</name>-&gt;<name>cl_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then>
	<else>else <block>{
		<expr_stmt><expr><name>type_name</name> = <name><name>integral</name>-&gt;<name>ob_type</name>-&gt;<name>tp_name</name></name></expr>;</expr_stmt>
	}</block></else></if>
	<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>, <argument><expr><name>error_format</name></expr></argument>, <argument><expr><name>type_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>integral</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>NULL</name></expr>;</return>
}</block></function>


<function><type><name>PyObject</name> *</type>
<name>PyNumber_Int</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>o</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyNumberMethods</name> *</type><name>m</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>static</specifier> <name>PyObject</name> *</type><name>trunc_name</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>trunc_func</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>buffer</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>buffer_len</name></decl>;</decl_stmt>

	<if>if <condition>(<expr><name>trunc_name</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>trunc_name</name> = <call><name>PyString_InternFromString</name><argument_list>(<argument><expr>"__trunc__"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>trunc_name</name> == <name>NULL</name></expr>)</condition><then>
			<return>return <expr><name>NULL</name></expr>;</return></then></if>
	}</block></then></if>

	<if>if <condition>(<expr><name>o</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr><call><name>null_error</name><argument_list>()</argument_list></call></expr>;</return></then></if>
	<if>if <condition>(<expr><call><name>PyInt_CheckExact</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>o</name></expr>;</return>
	}</block></then></if>
	<expr_stmt><expr><name>m</name> = <name><name>o</name>-&gt;<name>ob_type</name>-&gt;<name>tp_as_number</name></name></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>m</name> &amp;&amp; <name><name>m</name>-&gt;<name>nb_int</name></name></expr>)</condition><then> <block>{ <comment type="block">/* This should include subclasses of int */</comment>
		<comment type="block">/* Classic classes always take this branch. */</comment>
		<decl_stmt><decl><type><name>PyObject</name> *</type><name>res</name> <init>= <expr><call><name><name>m</name>-&gt;<name>nb_int</name></name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if>if <condition>(<expr><name>res</name> &amp;&amp; (!<call><name>PyInt_Check</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call> &amp;&amp; !<call><name>PyLong_Check</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call>)</expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
				     <argument><expr>"__int__ returned non-int (type %.200s)"</expr></argument>,
				     <argument><expr><name><name>res</name>-&gt;<name>ob_type</name>-&gt;<name>tp_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>NULL</name></expr>;</return>
		}</block></then></if>
		<return>return <expr><name>res</name></expr>;</return>
	}</block></then></if>
	<if>if <condition>(<expr><call><name>PyInt_Check</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{ <comment type="block">/* A int subclass without nb_int */</comment>
		<decl_stmt><decl><type><name>PyIntObject</name> *</type><name>io</name> <init>= <expr>(<name>PyIntObject</name>*)<name>o</name></expr></init></decl>;</decl_stmt>
		<return>return <expr><call><name>PyInt_FromLong</name><argument_list>(<argument><expr><name><name>io</name>-&gt;<name>ob_ival</name></name></expr></argument>)</argument_list></call></expr>;</return>
	}</block></then></if>
	<expr_stmt><expr><name>trunc_func</name> = <call><name>PyObject_GetAttr</name><argument_list>(<argument><expr><name>o</name></expr></argument>, <argument><expr><name>trunc_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>trunc_func</name></expr>)</condition><then> <block>{
		<decl_stmt><decl><type><name>PyObject</name> *</type><name>truncated</name> <init>= <expr><call><name>PyEval_CallObject</name><argument_list>(<argument><expr><name>trunc_func</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>trunc_func</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* __trunc__ is specified to return an Integral type, but
		   int() needs to return an int. */</comment>
		<return>return <expr><call><name>_PyNumber_ConvertIntegralToInt</name><argument_list>(
			<argument><expr><name>truncated</name></expr></argument>,
			<argument><expr>"__trunc__ returned non-Integral (type %.200s)"</expr></argument>)</argument_list></call></expr>;</return>
	}</block></then></if>
	<expr_stmt><expr><call><name>PyErr_Clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* It's not an error if  o.__trunc__ doesn't exist. */</comment>

	<if>if <condition>(<expr><call><name>PyString_Check</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><call><name>int_from_string</name><argument_list>(<argument><expr><call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr></argument>,
				       <argument><expr><call><name>PyString_GET_SIZE</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></then></if>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>Py_USING_UNICODE</name></cpp:ifdef>
	<if>if <condition>(<expr><call><name>PyUnicode_Check</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><call><name>PyInt_FromUnicode</name><argument_list>(<argument><expr><call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr></argument>,
					 <argument><expr><call><name>PyUnicode_GET_SIZE</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr></argument>,
					 <argument><expr>10</expr></argument>)</argument_list></call></expr>;</return></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<if>if <condition>(<expr>!<call><name>PyObject_AsCharBuffer</name><argument_list>(<argument><expr><name>o</name></expr></argument>, <argument><expr>&amp;<name>buffer</name></expr></argument>, <argument><expr>&amp;<name>buffer_len</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><call><name>int_from_string</name><argument_list>(<argument><expr>(<name>char</name>*)<name>buffer</name></expr></argument>, <argument><expr><name>buffer_len</name></expr></argument>)</argument_list></call></expr>;</return></then></if>

	<return>return <expr><call><name>type_error</name><argument_list>(<argument><expr>"int() argument must be a string or a "
			  "number, not '%.200s'"</expr></argument>, <argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<comment type="block">/* Add a check for embedded NULL-bytes in the argument. */</comment>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>long_from_string</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>s</name></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>len</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>char</name> *</type><name>end</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>x</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>x</name> = <call><name>PyLong_FromString</name><argument_list>(<argument><expr>(<name>char</name>*)<name>s</name></expr></argument>, <argument><expr>&amp;<name>end</name></expr></argument>, <argument><expr>10</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>x</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<if>if <condition>(<expr><name>end</name> != <name>s</name> + <name>len</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>,
				<argument><expr>"null byte in argument for long()"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>
	<return>return <expr><name>x</name></expr>;</return>
}</block></function>

<function><type><name>PyObject</name> *</type>
<name>PyNumber_Long</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>o</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyNumberMethods</name> *</type><name>m</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>static</specifier> <name>PyObject</name> *</type><name>trunc_name</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>trunc_func</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>buffer</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>buffer_len</name></decl>;</decl_stmt>

	<if>if <condition>(<expr><name>trunc_name</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>trunc_name</name> = <call><name>PyString_InternFromString</name><argument_list>(<argument><expr>"__trunc__"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>trunc_name</name> == <name>NULL</name></expr>)</condition><then>
			<return>return <expr><name>NULL</name></expr>;</return></then></if>
	}</block></then></if>

	<if>if <condition>(<expr><name>o</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr><call><name>null_error</name><argument_list>()</argument_list></call></expr>;</return></then></if>
	<expr_stmt><expr><name>m</name> = <name><name>o</name>-&gt;<name>ob_type</name>-&gt;<name>tp_as_number</name></name></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>m</name> &amp;&amp; <name><name>m</name>-&gt;<name>nb_long</name></name></expr>)</condition><then> <block>{ <comment type="block">/* This should include subclasses of long */</comment>
		<comment type="block">/* Classic classes always take this branch. */</comment>
		<decl_stmt><decl><type><name>PyObject</name> *</type><name>res</name> <init>= <expr><call><name><name>m</name>-&gt;<name>nb_long</name></name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if>if <condition>(<expr><name>res</name> &amp;&amp; (!<call><name>PyInt_Check</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call> &amp;&amp; !<call><name>PyLong_Check</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call>)</expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
				     <argument><expr>"__long__ returned non-long (type %.200s)"</expr></argument>,
				     <argument><expr><name><name>res</name>-&gt;<name>ob_type</name>-&gt;<name>tp_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>NULL</name></expr>;</return>
		}</block></then></if>
		<return>return <expr><name>res</name></expr>;</return>
	}</block></then></if>
	<if>if <condition>(<expr><call><name>PyLong_Check</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>)</condition><then> <comment type="block">/* A long subclass without nb_long */</comment>
		<return>return <expr><call><name>_PyLong_Copy</name><argument_list>(<argument><expr>(<name>PyLongObject</name> *)<name>o</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
	<expr_stmt><expr><name>trunc_func</name> = <call><name>PyObject_GetAttr</name><argument_list>(<argument><expr><name>o</name></expr></argument>, <argument><expr><name>trunc_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>trunc_func</name></expr>)</condition><then> <block>{
		<decl_stmt><decl><type><name>PyObject</name> *</type><name>truncated</name> <init>= <expr><call><name>PyEval_CallObject</name><argument_list>(<argument><expr><name>trunc_func</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PyObject</name> *</type><name>int_instance</name></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>trunc_func</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* __trunc__ is specified to return an Integral type,
		   but long() needs to return a long. */</comment>
		<expr_stmt><expr><name>int_instance</name> = <call><name>_PyNumber_ConvertIntegralToInt</name><argument_list>(
			<argument><expr><name>truncated</name></expr></argument>,
			<argument><expr>"__trunc__ returned non-Integral (type %.200s)"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>int_instance</name> &amp;&amp; <call><name>PyInt_Check</name><argument_list>(<argument><expr><name>int_instance</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
			<comment type="block">/* Make sure that long() returns a long instance. */</comment>
			<decl_stmt><decl><type><name>long</name></type> <name>value</name> <init>= <expr><call><name>PyInt_AS_LONG</name><argument_list>(<argument><expr><name>int_instance</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>int_instance</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><call><name>PyLong_FromLong</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</return>
		}</block></then></if>
		<return>return <expr><name>int_instance</name></expr>;</return>
	}</block></then></if>
	<expr_stmt><expr><call><name>PyErr_Clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* It's not an error if  o.__trunc__ doesn't exist. */</comment>

	<if>if <condition>(<expr><call><name>PyString_Check</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<comment type="block">/* need to do extra error checking that PyLong_FromString()
		 * doesn't do.  In particular long('9.5') must raise an
		 * exception, not truncate the float.
		 */</comment>
		<return>return <expr><call><name>long_from_string</name><argument_list>(<argument><expr><call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr></argument>,
					<argument><expr><call><name>PyString_GET_SIZE</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></then></if>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>Py_USING_UNICODE</name></cpp:ifdef>
	<if>if <condition>(<expr><call><name>PyUnicode_Check</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<comment type="block">/* The above check is done in PyLong_FromUnicode(). */</comment>
		<return>return <expr><call><name>PyLong_FromUnicode</name><argument_list>(<argument><expr><call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr></argument>,
					  <argument><expr><call><name>PyUnicode_GET_SIZE</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr></argument>,
					  <argument><expr>10</expr></argument>)</argument_list></call></expr>;</return></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<if>if <condition>(<expr>!<call><name>PyObject_AsCharBuffer</name><argument_list>(<argument><expr><name>o</name></expr></argument>, <argument><expr>&amp;<name>buffer</name></expr></argument>, <argument><expr>&amp;<name>buffer_len</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><call><name>long_from_string</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>buffer_len</name></expr></argument>)</argument_list></call></expr>;</return></then></if>

	<return>return <expr><call><name>type_error</name><argument_list>(<argument><expr>"long() argument must be a string or a "
			  "number, not '%.200s'"</expr></argument>, <argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>PyObject</name> *</type>
<name>PyNumber_Float</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>o</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyNumberMethods</name> *</type><name>m</name></decl>;</decl_stmt>

	<if>if <condition>(<expr><name>o</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr><call><name>null_error</name><argument_list>()</argument_list></call></expr>;</return></then></if>
	<expr_stmt><expr><name>m</name> = <name><name>o</name>-&gt;<name>ob_type</name>-&gt;<name>tp_as_number</name></name></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>m</name> &amp;&amp; <name><name>m</name>-&gt;<name>nb_float</name></name></expr>)</condition><then> <block>{ <comment type="block">/* This should include subclasses of float */</comment>
		<decl_stmt><decl><type><name>PyObject</name> *</type><name>res</name> <init>= <expr><call><name><name>m</name>-&gt;<name>nb_float</name></name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if>if <condition>(<expr><name>res</name> &amp;&amp; !<call><name>PyFloat_Check</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
		          <argument><expr>"__float__ returned non-float (type %.200s)"</expr></argument>,
		          <argument><expr><name><name>res</name>-&gt;<name>ob_type</name>-&gt;<name>tp_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>NULL</name></expr>;</return>
		}</block></then></if>
		<return>return <expr><name>res</name></expr>;</return>
	}</block></then></if>
	<if>if <condition>(<expr><call><name>PyFloat_Check</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{ <comment type="block">/* A float subclass with nb_float == NULL */</comment>
		<decl_stmt><decl><type><name>PyFloatObject</name> *</type><name>po</name> <init>= <expr>(<name>PyFloatObject</name> *)<name>o</name></expr></init></decl>;</decl_stmt>
		<return>return <expr><call><name>PyFloat_FromDouble</name><argument_list>(<argument><expr><name><name>po</name>-&gt;<name>ob_fval</name></name></expr></argument>)</argument_list></call></expr>;</return>
	}</block></then></if>
	<return>return <expr><call><name>PyFloat_FromString</name><argument_list>(<argument><expr><name>o</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>PyObject</name> *</type>
<name>PyNumber_ToBase</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>n</name></decl></param>, <param><decl><type><name>int</name></type> <name>base</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>res</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>index</name> <init>= <expr><call><name>PyNumber_Index</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if>if <condition>(<expr>!<name>index</name></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<if>if <condition>(<expr><call><name>PyLong_Check</name><argument_list>(<argument><expr><name>index</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<expr_stmt><expr><name>res</name> = <call><name>_PyLong_Format</name><argument_list>(<argument><expr><name>index</name></expr></argument>, <argument><expr><name>base</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
	<else>else <if>if <condition>(<expr><call><name>PyInt_Check</name><argument_list>(<argument><expr><name>index</name></expr></argument>)</argument_list></call></expr>)</condition><then>
	  	<expr_stmt><expr><name>res</name> = <call><name>_PyInt_Format</name><argument_list>(<argument><expr>(<name>PyIntObject</name>*)<name>index</name></expr></argument>, <argument><expr><name>base</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
	<else>else
		<comment type="block">/* It should not be possible to get here, as
		   PyNumber_Index already has a check for the same
		   condition */</comment>
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>, <argument><expr>"PyNumber_ToBase: index not "
				"int or long"</expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if></else></if>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>res</name></expr>;</return>
}</block></function>


<comment type="block">/* Operations on sequences */</comment>

<function><type><name>int</name></type>
<name>PySequence_Check</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>s</name></decl></param>)</parameter_list>
<block>{
	<if>if <condition>(<expr><name>s</name> &amp;&amp; <call><name>PyInstance_Check</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><call><name>PyObject_HasAttrString</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr>"__getitem__"</expr></argument>)</argument_list></call></expr>;</return></then></if>
	<if>if <condition>(<expr><call><name>PyObject_IsInstance</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr>(<name>PyObject</name> *)&amp;<name>PyDict_Type</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr>0</expr>;</return></then></if>
	<return>return <expr><name>s</name> != <name>NULL</name> &amp;&amp; <name><name>s</name>-&gt;<name>ob_type</name>-&gt;<name>tp_as_sequence</name></name> &amp;&amp;
		<name><name>s</name>-&gt;<name>ob_type</name>-&gt;<name>tp_as_sequence</name>-&gt;<name>sq_item</name></name> != <name>NULL</name></expr>;</return>
}</block></function>

<function><type><name>Py_ssize_t</name></type>
<name>PySequence_Size</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>s</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PySequenceMethods</name> *</type><name>m</name></decl>;</decl_stmt>

	<if>if <condition>(<expr><name>s</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>null_error</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>-1</expr>;</return>
	}</block></then></if>

	<expr_stmt><expr><name>m</name> = <name><name>s</name>-&gt;<name>ob_type</name>-&gt;<name>tp_as_sequence</name></name></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>m</name> &amp;&amp; <name><name>m</name>-&gt;<name>sq_length</name></name></expr>)</condition><then>
		<return>return <expr><call><name><name>m</name>-&gt;<name>sq_length</name></name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</return></then></if>

	<expr_stmt><expr><call><name>type_error</name><argument_list>(<argument><expr>"object of type '%.200s' has no len()"</expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr>-1</expr>;</return>
}</block></function>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>PySequence_Length</name></cpp:undef>
<function><type><name>Py_ssize_t</name></type>
<name>PySequence_Length</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>s</name></decl></param>)</parameter_list>
<block>{
	<return>return <expr><call><name>PySequence_Size</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PySequence_Length</name></cpp:macro> <cpp:value>PySequence_Size</cpp:value></cpp:define>

<function><type><name>PyObject</name> *</type>
<name>PySequence_Concat</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>s</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>o</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PySequenceMethods</name> *</type><name>m</name></decl>;</decl_stmt>

	<if>if <condition>(<expr><name>s</name> == <name>NULL</name> || <name>o</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr><call><name>null_error</name><argument_list>()</argument_list></call></expr>;</return></then></if>

	<expr_stmt><expr><name>m</name> = <name><name>s</name>-&gt;<name>ob_type</name>-&gt;<name>tp_as_sequence</name></name></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>m</name> &amp;&amp; <name><name>m</name>-&gt;<name>sq_concat</name></name></expr>)</condition><then>
		<return>return <expr><call><name><name>m</name>-&gt;<name>sq_concat</name></name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>;</return></then></if>

	<comment type="block">/* Instances of user classes defining an __add__() method only
	   have an nb_add slot, not an sq_concat slot.  So we fall back
	   to nb_add if both arguments appear to be sequences. */</comment>
	<if>if <condition>(<expr><call><name>PySequence_Check</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call> &amp;&amp; <call><name>PySequence_Check</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<decl_stmt><decl><type><name>PyObject</name> *</type><name>result</name> <init>= <expr><call><name>binary_op1</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>o</name></expr></argument>, <argument><expr><call><name>NB_SLOT</name><argument_list>(<argument><expr><name>nb_add</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if>if <condition>(<expr><name>result</name> != <name>Py_NotImplemented</name></expr>)</condition><then>
			<return>return <expr><name>result</name></expr>;</return></then></if>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>
	<return>return <expr><call><name>type_error</name><argument_list>(<argument><expr>"'%.200s' object can't be concatenated"</expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>PyObject</name> *</type>
<name>PySequence_Repeat</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>o</name></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>count</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PySequenceMethods</name> *</type><name>m</name></decl>;</decl_stmt>

	<if>if <condition>(<expr><name>o</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr><call><name>null_error</name><argument_list>()</argument_list></call></expr>;</return></then></if>

	<expr_stmt><expr><name>m</name> = <name><name>o</name>-&gt;<name>ob_type</name>-&gt;<name>tp_as_sequence</name></name></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>m</name> &amp;&amp; <name><name>m</name>-&gt;<name>sq_repeat</name></name></expr>)</condition><then>
		<return>return <expr><call><name><name>m</name>-&gt;<name>sq_repeat</name></name><argument_list>(<argument><expr><name>o</name></expr></argument>, <argument><expr><name>count</name></expr></argument>)</argument_list></call></expr>;</return></then></if>

	<comment type="block">/* Instances of user classes defining a __mul__() method only
	   have an nb_multiply slot, not an sq_repeat slot. so we fall back
	   to nb_multiply if o appears to be a sequence. */</comment>
	<if>if <condition>(<expr><call><name>PySequence_Check</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<decl_stmt><decl><type><name>PyObject</name> *</type><name>n</name></decl>, *<decl><type ref="prev"/><name>result</name></decl>;</decl_stmt>
		<expr_stmt><expr><name>n</name> = <call><name>PyInt_FromSsize_t</name><argument_list>(<argument><expr><name>count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>n</name> == <name>NULL</name></expr>)</condition><then>
			<return>return <expr><name>NULL</name></expr>;</return></then></if>
		<expr_stmt><expr><name>result</name> = <call><name>binary_op1</name><argument_list>(<argument><expr><name>o</name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><call><name>NB_SLOT</name><argument_list>(<argument><expr><name>nb_multiply</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>result</name> != <name>Py_NotImplemented</name></expr>)</condition><then>
			<return>return <expr><name>result</name></expr>;</return></then></if>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>
	<return>return <expr><call><name>type_error</name><argument_list>(<argument><expr>"'%.200s' object can't be repeated"</expr></argument>, <argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>PyObject</name> *</type>
<name>PySequence_InPlaceConcat</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>s</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>o</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PySequenceMethods</name> *</type><name>m</name></decl>;</decl_stmt>

	<if>if <condition>(<expr><name>s</name> == <name>NULL</name> || <name>o</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr><call><name>null_error</name><argument_list>()</argument_list></call></expr>;</return></then></if>

	<expr_stmt><expr><name>m</name> = <name><name>s</name>-&gt;<name>ob_type</name>-&gt;<name>tp_as_sequence</name></name></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>m</name> &amp;&amp; <call><name>HASINPLACE</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call> &amp;&amp; <name><name>m</name>-&gt;<name>sq_inplace_concat</name></name></expr>)</condition><then>
		<return>return <expr><call><name><name>m</name>-&gt;<name>sq_inplace_concat</name></name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
	<if>if <condition>(<expr><name>m</name> &amp;&amp; <name><name>m</name>-&gt;<name>sq_concat</name></name></expr>)</condition><then>
		<return>return <expr><call><name><name>m</name>-&gt;<name>sq_concat</name></name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>;</return></then></if>

	<if>if <condition>(<expr><call><name>PySequence_Check</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call> &amp;&amp; <call><name>PySequence_Check</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<decl_stmt><decl><type><name>PyObject</name> *</type><name>result</name> <init>= <expr><call><name>binary_iop1</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>o</name></expr></argument>, <argument><expr><call><name>NB_SLOT</name><argument_list>(<argument><expr><name>nb_inplace_add</name></expr></argument>)</argument_list></call></expr></argument>,
					       <argument><expr><call><name>NB_SLOT</name><argument_list>(<argument><expr><name>nb_add</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if>if <condition>(<expr><name>result</name> != <name>Py_NotImplemented</name></expr>)</condition><then>
			<return>return <expr><name>result</name></expr>;</return></then></if>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>
	<return>return <expr><call><name>type_error</name><argument_list>(<argument><expr>"'%.200s' object can't be concatenated"</expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>PyObject</name> *</type>
<name>PySequence_InPlaceRepeat</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>o</name></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>count</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PySequenceMethods</name> *</type><name>m</name></decl>;</decl_stmt>

	<if>if <condition>(<expr><name>o</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr><call><name>null_error</name><argument_list>()</argument_list></call></expr>;</return></then></if>

	<expr_stmt><expr><name>m</name> = <name><name>o</name>-&gt;<name>ob_type</name>-&gt;<name>tp_as_sequence</name></name></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>m</name> &amp;&amp; <call><name>HASINPLACE</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call> &amp;&amp; <name><name>m</name>-&gt;<name>sq_inplace_repeat</name></name></expr>)</condition><then>
		<return>return <expr><call><name><name>m</name>-&gt;<name>sq_inplace_repeat</name></name><argument_list>(<argument><expr><name>o</name></expr></argument>, <argument><expr><name>count</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
	<if>if <condition>(<expr><name>m</name> &amp;&amp; <name><name>m</name>-&gt;<name>sq_repeat</name></name></expr>)</condition><then>
		<return>return <expr><call><name><name>m</name>-&gt;<name>sq_repeat</name></name><argument_list>(<argument><expr><name>o</name></expr></argument>, <argument><expr><name>count</name></expr></argument>)</argument_list></call></expr>;</return></then></if>

	<if>if <condition>(<expr><call><name>PySequence_Check</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<decl_stmt><decl><type><name>PyObject</name> *</type><name>n</name></decl>, *<decl><type ref="prev"/><name>result</name></decl>;</decl_stmt>
		<expr_stmt><expr><name>n</name> = <call><name>PyInt_FromSsize_t</name><argument_list>(<argument><expr><name>count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>n</name> == <name>NULL</name></expr>)</condition><then>
			<return>return <expr><name>NULL</name></expr>;</return></then></if>
		<expr_stmt><expr><name>result</name> = <call><name>binary_iop1</name><argument_list>(<argument><expr><name>o</name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><call><name>NB_SLOT</name><argument_list>(<argument><expr><name>nb_inplace_multiply</name></expr></argument>)</argument_list></call></expr></argument>,
				     <argument><expr><call><name>NB_SLOT</name><argument_list>(<argument><expr><name>nb_multiply</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>result</name> != <name>Py_NotImplemented</name></expr>)</condition><then>
			<return>return <expr><name>result</name></expr>;</return></then></if>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>
	<return>return <expr><call><name>type_error</name><argument_list>(<argument><expr>"'%.200s' object can't be repeated"</expr></argument>, <argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>PyObject</name> *</type>
<name>PySequence_GetItem</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>s</name></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>i</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PySequenceMethods</name> *</type><name>m</name></decl>;</decl_stmt>

	<if>if <condition>(<expr><name>s</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr><call><name>null_error</name><argument_list>()</argument_list></call></expr>;</return></then></if>

	<expr_stmt><expr><name>m</name> = <name><name>s</name>-&gt;<name>ob_type</name>-&gt;<name>tp_as_sequence</name></name></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>m</name> &amp;&amp; <name><name>m</name>-&gt;<name>sq_item</name></name></expr>)</condition><then> <block>{
		<if>if <condition>(<expr><name>i</name> &lt; 0</expr>)</condition><then> <block>{
			<if>if <condition>(<expr><name><name>m</name>-&gt;<name>sq_length</name></name></expr>)</condition><then> <block>{
				<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>l</name> <init>= <expr><call>(*<name><name>m</name>-&gt;<name>sq_length</name></name>)<argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<if>if <condition>(<expr><name>l</name> &lt; 0</expr>)</condition><then>
					<return>return <expr><name>NULL</name></expr>;</return></then></if>
				<expr_stmt><expr><name>i</name> += <name>l</name></expr>;</expr_stmt>
			}</block></then></if>
		}</block></then></if>
		<return>return <expr><call><name><name>m</name>-&gt;<name>sq_item</name></name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</return>
	}</block></then></if>

	<return>return <expr><call><name>type_error</name><argument_list>(<argument><expr>"'%.200s' object does not support indexing"</expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>PyObject</name> *</type>
<name>PySequence_GetSlice</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>s</name></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>i1</name></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>i2</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PySequenceMethods</name> *</type><name>m</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyMappingMethods</name> *</type><name>mp</name></decl>;</decl_stmt>

	<if>if <condition>(<expr>!<name>s</name></expr>)</condition><then> <return>return <expr><call><name>null_error</name><argument_list>()</argument_list></call></expr>;</return></then></if>

	<expr_stmt><expr><name>m</name> = <name><name>s</name>-&gt;<name>ob_type</name>-&gt;<name>tp_as_sequence</name></name></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>m</name> &amp;&amp; <name><name>m</name>-&gt;<name>sq_slice</name></name></expr>)</condition><then> <block>{
		<if>if <condition>(<expr><name>i1</name> &lt; 0 || <name>i2</name> &lt; 0</expr>)</condition><then> <block>{
			<if>if <condition>(<expr><name><name>m</name>-&gt;<name>sq_length</name></name></expr>)</condition><then> <block>{
				<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>l</name> <init>= <expr><call>(*<name><name>m</name>-&gt;<name>sq_length</name></name>)<argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<if>if <condition>(<expr><name>l</name> &lt; 0</expr>)</condition><then>
					<return>return <expr><name>NULL</name></expr>;</return></then></if>
				<if>if <condition>(<expr><name>i1</name> &lt; 0</expr>)</condition><then>
					<expr_stmt><expr><name>i1</name> += <name>l</name></expr>;</expr_stmt></then></if>
				<if>if <condition>(<expr><name>i2</name> &lt; 0</expr>)</condition><then>
					<expr_stmt><expr><name>i2</name> += <name>l</name></expr>;</expr_stmt></then></if>
			}</block></then></if>
		}</block></then></if>
		<return>return <expr><call><name><name>m</name>-&gt;<name>sq_slice</name></name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>i1</name></expr></argument>, <argument><expr><name>i2</name></expr></argument>)</argument_list></call></expr>;</return>
	}</block></then> <else>else <if>if <condition>(<expr>(<name>mp</name> = <name><name>s</name>-&gt;<name>ob_type</name>-&gt;<name>tp_as_mapping</name></name>) &amp;&amp; <name><name>mp</name>-&gt;<name>mp_subscript</name></name></expr>)</condition><then> <block>{
		<decl_stmt><decl><type><name>PyObject</name> *</type><name>res</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PyObject</name> *</type><name>slice</name> <init>= <expr><call><name>_PySlice_FromIndices</name><argument_list>(<argument><expr><name>i1</name></expr></argument>, <argument><expr><name>i2</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if>if <condition>(<expr>!<name>slice</name></expr>)</condition><then>
			<return>return <expr><name>NULL</name></expr>;</return></then></if>
		<expr_stmt><expr><name>res</name> = <call><name><name>mp</name>-&gt;<name>mp_subscript</name></name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>slice</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>slice</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>res</name></expr>;</return>
	}</block></then></if></else></if>

	<return>return <expr><call><name>type_error</name><argument_list>(<argument><expr>"'%.200s' object is unsliceable"</expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>int</name></type>
<name>PySequence_SetItem</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>s</name></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>i</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>o</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PySequenceMethods</name> *</type><name>m</name></decl>;</decl_stmt>

	<if>if <condition>(<expr><name>s</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>null_error</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>-1</expr>;</return>
	}</block></then></if>

	<expr_stmt><expr><name>m</name> = <name><name>s</name>-&gt;<name>ob_type</name>-&gt;<name>tp_as_sequence</name></name></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>m</name> &amp;&amp; <name><name>m</name>-&gt;<name>sq_ass_item</name></name></expr>)</condition><then> <block>{
		<if>if <condition>(<expr><name>i</name> &lt; 0</expr>)</condition><then> <block>{
			<if>if <condition>(<expr><name><name>m</name>-&gt;<name>sq_length</name></name></expr>)</condition><then> <block>{
				<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>l</name> <init>= <expr><call>(*<name><name>m</name>-&gt;<name>sq_length</name></name>)<argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<if>if <condition>(<expr><name>l</name> &lt; 0</expr>)</condition><then>
					<return>return <expr>-1</expr>;</return></then></if>
				<expr_stmt><expr><name>i</name> += <name>l</name></expr>;</expr_stmt>
			}</block></then></if>
		}</block></then></if>
		<return>return <expr><call><name><name>m</name>-&gt;<name>sq_ass_item</name></name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>;</return>
	}</block></then></if>

	<expr_stmt><expr><call><name>type_error</name><argument_list>(<argument><expr>"'%.200s' object does not support item assignment"</expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr>-1</expr>;</return>
}</block></function>

<function><type><name>int</name></type>
<name>PySequence_DelItem</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>s</name></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>i</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PySequenceMethods</name> *</type><name>m</name></decl>;</decl_stmt>

	<if>if <condition>(<expr><name>s</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>null_error</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>-1</expr>;</return>
	}</block></then></if>

	<expr_stmt><expr><name>m</name> = <name><name>s</name>-&gt;<name>ob_type</name>-&gt;<name>tp_as_sequence</name></name></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>m</name> &amp;&amp; <name><name>m</name>-&gt;<name>sq_ass_item</name></name></expr>)</condition><then> <block>{
		<if>if <condition>(<expr><name>i</name> &lt; 0</expr>)</condition><then> <block>{
			<if>if <condition>(<expr><name><name>m</name>-&gt;<name>sq_length</name></name></expr>)</condition><then> <block>{
				<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>l</name> <init>= <expr><call>(*<name><name>m</name>-&gt;<name>sq_length</name></name>)<argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<if>if <condition>(<expr><name>l</name> &lt; 0</expr>)</condition><then>
					<return>return <expr>-1</expr>;</return></then></if>
				<expr_stmt><expr><name>i</name> += <name>l</name></expr>;</expr_stmt>
			}</block></then></if>
		}</block></then></if>
		<return>return <expr><call><name><name>m</name>-&gt;<name>sq_ass_item</name></name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr>(<name>PyObject</name> *)<name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
	}</block></then></if>

	<expr_stmt><expr><call><name>type_error</name><argument_list>(<argument><expr>"'%.200s' object doesn't support item deletion"</expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr>-1</expr>;</return>
}</block></function>

<function><type><name>int</name></type>
<name>PySequence_SetSlice</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>s</name></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>i1</name></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>i2</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>o</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PySequenceMethods</name> *</type><name>m</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyMappingMethods</name> *</type><name>mp</name></decl>;</decl_stmt>

	<if>if <condition>(<expr><name>s</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>null_error</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>-1</expr>;</return>
	}</block></then></if>

	<expr_stmt><expr><name>m</name> = <name><name>s</name>-&gt;<name>ob_type</name>-&gt;<name>tp_as_sequence</name></name></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>m</name> &amp;&amp; <name><name>m</name>-&gt;<name>sq_ass_slice</name></name></expr>)</condition><then> <block>{
		<if>if <condition>(<expr><name>i1</name> &lt; 0 || <name>i2</name> &lt; 0</expr>)</condition><then> <block>{
			<if>if <condition>(<expr><name><name>m</name>-&gt;<name>sq_length</name></name></expr>)</condition><then> <block>{
				<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>l</name> <init>= <expr><call>(*<name><name>m</name>-&gt;<name>sq_length</name></name>)<argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<if>if <condition>(<expr><name>l</name> &lt; 0</expr>)</condition><then>
					<return>return <expr>-1</expr>;</return></then></if>
				<if>if <condition>(<expr><name>i1</name> &lt; 0</expr>)</condition><then>
					<expr_stmt><expr><name>i1</name> += <name>l</name></expr>;</expr_stmt></then></if>
				<if>if <condition>(<expr><name>i2</name> &lt; 0</expr>)</condition><then>
					<expr_stmt><expr><name>i2</name> += <name>l</name></expr>;</expr_stmt></then></if>
			}</block></then></if>
		}</block></then></if>
		<return>return <expr><call><name><name>m</name>-&gt;<name>sq_ass_slice</name></name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>i1</name></expr></argument>, <argument><expr><name>i2</name></expr></argument>, <argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>;</return>
	}</block></then> <else>else <if>if <condition>(<expr>(<name>mp</name> = <name><name>s</name>-&gt;<name>ob_type</name>-&gt;<name>tp_as_mapping</name></name>) &amp;&amp; <name><name>mp</name>-&gt;<name>mp_ass_subscript</name></name></expr>)</condition><then> <block>{
		<decl_stmt><decl><type><name>int</name></type> <name>res</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PyObject</name> *</type><name>slice</name> <init>= <expr><call><name>_PySlice_FromIndices</name><argument_list>(<argument><expr><name>i1</name></expr></argument>, <argument><expr><name>i2</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if>if <condition>(<expr>!<name>slice</name></expr>)</condition><then>
			<return>return <expr>-1</expr>;</return></then></if>
		<expr_stmt><expr><name>res</name> = <call><name><name>mp</name>-&gt;<name>mp_ass_subscript</name></name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>slice</name></expr></argument>, <argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>slice</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>res</name></expr>;</return>
	}</block></then></if></else></if>

	<expr_stmt><expr><call><name>type_error</name><argument_list>(<argument><expr>"'%.200s' object doesn't support slice assignment"</expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr>-1</expr>;</return>
}</block></function>

<function><type><name>int</name></type>
<name>PySequence_DelSlice</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>s</name></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>i1</name></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>i2</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PySequenceMethods</name> *</type><name>m</name></decl>;</decl_stmt>

	<if>if <condition>(<expr><name>s</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>null_error</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>-1</expr>;</return>
	}</block></then></if>

	<expr_stmt><expr><name>m</name> = <name><name>s</name>-&gt;<name>ob_type</name>-&gt;<name>tp_as_sequence</name></name></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>m</name> &amp;&amp; <name><name>m</name>-&gt;<name>sq_ass_slice</name></name></expr>)</condition><then> <block>{
		<if>if <condition>(<expr><name>i1</name> &lt; 0 || <name>i2</name> &lt; 0</expr>)</condition><then> <block>{
			<if>if <condition>(<expr><name><name>m</name>-&gt;<name>sq_length</name></name></expr>)</condition><then> <block>{
				<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>l</name> <init>= <expr><call>(*<name><name>m</name>-&gt;<name>sq_length</name></name>)<argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<if>if <condition>(<expr><name>l</name> &lt; 0</expr>)</condition><then>
					<return>return <expr>-1</expr>;</return></then></if>
				<if>if <condition>(<expr><name>i1</name> &lt; 0</expr>)</condition><then>
					<expr_stmt><expr><name>i1</name> += <name>l</name></expr>;</expr_stmt></then></if>
				<if>if <condition>(<expr><name>i2</name> &lt; 0</expr>)</condition><then>
					<expr_stmt><expr><name>i2</name> += <name>l</name></expr>;</expr_stmt></then></if>
			}</block></then></if>
		}</block></then></if>
		<return>return <expr><call><name><name>m</name>-&gt;<name>sq_ass_slice</name></name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>i1</name></expr></argument>, <argument><expr><name>i2</name></expr></argument>, <argument><expr>(<name>PyObject</name> *)<name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
	}</block></then></if>
	<expr_stmt><expr><call><name>type_error</name><argument_list>(<argument><expr>"'%.200s' object doesn't support slice deletion"</expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr>-1</expr>;</return>
}</block></function>

<function><type><name>PyObject</name> *</type>
<name>PySequence_Tuple</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>v</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>it</name></decl>;</decl_stmt>  <comment type="block">/* iter(v) */</comment>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>n</name></decl>;</decl_stmt>         <comment type="block">/* guess for result tuple size */</comment>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>j</name></decl>;</decl_stmt>

	<if>if <condition>(<expr><name>v</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr><call><name>null_error</name><argument_list>()</argument_list></call></expr>;</return></then></if>

	<comment type="block">/* Special-case the common tuple and list cases, for efficiency. */</comment>
	<if>if <condition>(<expr><call><name>PyTuple_CheckExact</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<comment type="block">/* Note that we can't know whether it's safe to return
		   a tuple *subclass* instance as-is, hence the restriction
		   to exact tuples here.  In contrast, lists always make
		   a copy, so there's no need for exactness below. */</comment>
		<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>v</name></expr>;</return>
	}</block></then></if>
	<if>if <condition>(<expr><call><name>PyList_Check</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><call><name>PyList_AsTuple</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</return></then></if>

	<comment type="block">/* Get iterator. */</comment>
	<expr_stmt><expr><name>it</name> = <call><name>PyObject_GetIter</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>it</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>

	<comment type="block">/* Guess result size and allocate space. */</comment>
	<expr_stmt><expr><name>n</name> = <call><name>_PyObject_LengthHint</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr>10</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>result</name> = <call><name>PyTuple_New</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>result</name> == <name>NULL</name></expr>)</condition><then>
		<goto>goto <name>Fail</name>;</goto></then></if>

	<comment type="block">/* Fill the tuple. */</comment>
	<for>for (<init><expr><name>j</name> = 0</expr>;</init> <condition>;</condition> <incr><expr>++<name>j</name></expr></incr>) <block>{
		<decl_stmt><decl><type><name>PyObject</name> *</type><name>item</name> <init>= <expr><call><name>PyIter_Next</name><argument_list>(<argument><expr><name>it</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if>if <condition>(<expr><name>item</name> == <name>NULL</name></expr>)</condition><then> <block>{
			<if>if <condition>(<expr><call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then>
				<goto>goto <name>Fail</name>;</goto></then></if>
			<break>break;</break>
		}</block></then></if>
		<if>if <condition>(<expr><name>j</name> &gt;= <name>n</name></expr>)</condition><then> <block>{
			<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>oldn</name> <init>= <expr><name>n</name></expr></init></decl>;</decl_stmt>
			<comment type="block">/* The over-allocation strategy can grow a bit faster
			   than for lists because unlike lists the 
			   over-allocation isn't permanent -- we reclaim
			   the excess before the end of this routine.
			   So, grow by ten and then add 25%.
			*/</comment>
			<expr_stmt><expr><name>n</name> += 10</expr>;</expr_stmt>
			<expr_stmt><expr><name>n</name> += <name>n</name> &gt;&gt; 2</expr>;</expr_stmt>
			<if>if <condition>(<expr><name>n</name> &lt; <name>oldn</name></expr>)</condition><then> <block>{
				<comment type="block">/* Check for overflow */</comment>
				<expr_stmt><expr><call><name>PyErr_NoMemory</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<goto>goto <name>Fail</name>;</goto> 
			}</block></then></if>
			<if>if <condition>(<expr><call><name>_PyTuple_Resize</name><argument_list>(<argument><expr>&amp;<name>result</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call> != 0</expr>)</condition><then> <block>{
				<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<goto>goto <name>Fail</name>;</goto>
			}</block></then></if>
		}</block></then></if>
		<expr_stmt><expr><call><name>PyTuple_SET_ITEM</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></for>

	<comment type="block">/* Cut tuple back if guess was too large. */</comment>
	<if>if <condition>(<expr><name>j</name> &lt; <name>n</name> &amp;&amp;
	    <call><name>_PyTuple_Resize</name><argument_list>(<argument><expr>&amp;<name>result</name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call> != 0</expr>)</condition><then>
		<goto>goto <name>Fail</name>;</goto></then></if>

	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>it</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>result</name></expr>;</return>

<label><name>Fail</name>:</label>
	<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>it</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>NULL</name></expr>;</return>
}</block></function>

<function><type><name>PyObject</name> *</type>
<name>PySequence_List</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>v</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>result</name></decl>;</decl_stmt>  <comment type="block">/* result list */</comment>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>rv</name></decl>;</decl_stmt>      <comment type="block">/* return value from PyList_Extend */</comment>

	<if>if <condition>(<expr><name>v</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr><call><name>null_error</name><argument_list>()</argument_list></call></expr>;</return></then></if>

	<expr_stmt><expr><name>result</name> = <call><name>PyList_New</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>result</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>

	<expr_stmt><expr><name>rv</name> = <call><name>_PyList_Extend</name><argument_list>(<argument><expr>(<name>PyListObject</name> *)<name>result</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>rv</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>result</name></expr>;</return>
}</block></function>

<function><type><name>PyObject</name> *</type>
<name>PySequence_Fast</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>v</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>m</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>it</name></decl>;</decl_stmt>

	<if>if <condition>(<expr><name>v</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr><call><name>null_error</name><argument_list>()</argument_list></call></expr>;</return></then></if>

	<if>if <condition>(<expr><call><name>PyList_CheckExact</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call> || <call><name>PyTuple_CheckExact</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>v</name></expr>;</return>
	}</block></then></if>

 	<expr_stmt><expr><name>it</name> = <call><name>PyObject_GetIter</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>it</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<if>if <condition>(<expr><call><name>PyErr_ExceptionMatches</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>)</argument_list></call></expr>)</condition><then>
			<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>, <argument><expr><name>m</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>

	<expr_stmt><expr><name>v</name> = <call><name>PySequence_List</name><argument_list>(<argument><expr><name>it</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>it</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>v</name></expr>;</return>
}</block></function>

<comment type="block">/* Iterate over seq.  Result depends on the operation:
   PY_ITERSEARCH_COUNT:  -1 if error, else # of times obj appears in seq.
   PY_ITERSEARCH_INDEX:  0-based index of first occurence of obj in seq;
   	set ValueError and return -1 if none found; also return -1 on error.
   Py_ITERSEARCH_CONTAINS:  return 1 if obj in seq, else 0; -1 on error.
*/</comment>
<function><type><name>Py_ssize_t</name></type>
<name>_PySequence_IterSearch</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>seq</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>obj</name></decl></param>, <param><decl><type><name>int</name></type> <name>operation</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>n</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>wrapped</name></decl>;</decl_stmt>  <comment type="block">/* for PY_ITERSEARCH_INDEX, true iff n wrapped around */</comment>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>it</name></decl>;</decl_stmt>  <comment type="block">/* iter(seq) */</comment>

	<if>if <condition>(<expr><name>seq</name> == <name>NULL</name> || <name>obj</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>null_error</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>-1</expr>;</return>
	}</block></then></if>

	<expr_stmt><expr><name>it</name> = <call><name>PyObject_GetIter</name><argument_list>(<argument><expr><name>seq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>it</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>type_error</name><argument_list>(<argument><expr>"argument of type '%.200s' is not iterable"</expr></argument>, <argument><expr><name>seq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>-1</expr>;</return>
	}</block></then></if>

	<expr_stmt><expr><name>n</name> = <name>wrapped</name> = 0</expr>;</expr_stmt>
	<for>for (<init>;</init><condition>;</condition><incr/>) <block>{
		<decl_stmt><decl><type><name>int</name></type> <name>cmp</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PyObject</name> *</type><name>item</name> <init>= <expr><call><name>PyIter_Next</name><argument_list>(<argument><expr><name>it</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if>if <condition>(<expr><name>item</name> == <name>NULL</name></expr>)</condition><then> <block>{
			<if>if <condition>(<expr><call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then>
				<goto>goto <name>Fail</name>;</goto></then></if>
			<break>break;</break>
		}</block></then></if>

		<expr_stmt><expr><name>cmp</name> = <call><name>PyObject_RichCompareBool</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>item</name></expr></argument>, <argument><expr><name>Py_EQ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>cmp</name> &lt; 0</expr>)</condition><then>
			<goto>goto <name>Fail</name>;</goto></then></if>
		<if>if <condition>(<expr><name>cmp</name> &gt; 0</expr>)</condition><then> <block>{
			<switch>switch <condition>(<expr><name>operation</name></expr>)</condition> <block>{
			<case>case <expr><name>PY_ITERSEARCH_COUNT</name></expr>:
				<if>if <condition>(<expr><name>n</name> == <name>PY_SSIZE_T_MAX</name></expr>)</condition><then> <block>{
					<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_OverflowError</name></expr></argument>,
					       <argument><expr>"count exceeds C integer size"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<goto>goto <name>Fail</name>;</goto>
				}</block></then></if>
				<expr_stmt><expr>++<name>n</name></expr>;</expr_stmt>
				<break>break;</break>

			</case><case>case <expr><name>PY_ITERSEARCH_INDEX</name></expr>:
				<if>if <condition>(<expr><name>wrapped</name></expr>)</condition><then> <block>{
					<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_OverflowError</name></expr></argument>,
					       <argument><expr>"index exceeds C integer size"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<goto>goto <name>Fail</name>;</goto>
				}</block></then></if>
				<goto>goto <name>Done</name>;</goto>

			</case><case>case <expr><name>PY_ITERSEARCH_CONTAINS</name></expr>:
				<expr_stmt><expr><name>n</name> = 1</expr>;</expr_stmt>
				<goto>goto <name>Done</name>;</goto>

			</case><default>default:
				<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr>!"unknown operation"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</default>}</block></switch>
		}</block></then></if>

		<if>if <condition>(<expr><name>operation</name> == <name>PY_ITERSEARCH_INDEX</name></expr>)</condition><then> <block>{
			<if>if <condition>(<expr><name>n</name> == <name>PY_SSIZE_T_MAX</name></expr>)</condition><then>
				<expr_stmt><expr><name>wrapped</name> = 1</expr>;</expr_stmt></then></if>
			<expr_stmt><expr>++<name>n</name></expr>;</expr_stmt>
		}</block></then></if>
	}</block></for>

	<if>if <condition>(<expr><name>operation</name> != <name>PY_ITERSEARCH_INDEX</name></expr>)</condition><then>
		<goto>goto <name>Done</name>;</goto></then></if>

	<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>,
		        <argument><expr>"sequence.index(x): x not in sequence"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* fall into failure code */</comment>
<label><name>Fail</name>:</label>
	<expr_stmt><expr><name>n</name> = -1</expr>;</expr_stmt>
	<comment type="block">/* fall through */</comment>
<label><name>Done</name>:</label>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>it</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>n</name></expr>;</return>

}</block></function>

<comment type="block">/* Return # of times o appears in s. */</comment>
<function><type><name>Py_ssize_t</name></type>
<name>PySequence_Count</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>s</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>o</name></decl></param>)</parameter_list>
<block>{
	<return>return <expr><call><name>_PySequence_IterSearch</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>o</name></expr></argument>, <argument><expr><name>PY_ITERSEARCH_COUNT</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<comment type="block">/* Return -1 if error; 1 if ob in seq; 0 if ob not in seq.
 * Use sq_contains if possible, else defer to _PySequence_IterSearch().
 */</comment>
<function><type><name>int</name></type>
<name>PySequence_Contains</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>seq</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>ob</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>result</name></decl>;</decl_stmt>
	<if>if <condition>(<expr><call><name>PyType_HasFeature</name><argument_list>(<argument><expr><name><name>seq</name>-&gt;<name>ob_type</name></name></expr></argument>, <argument><expr><name>Py_TPFLAGS_HAVE_SEQUENCE_IN</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<decl_stmt><decl><type><name>PySequenceMethods</name> *</type><name>sqm</name> <init>= <expr><name><name>seq</name>-&gt;<name>ob_type</name>-&gt;<name>tp_as_sequence</name></name></expr></init></decl>;</decl_stmt>
	        <if>if <condition>(<expr><name>sqm</name> != <name>NULL</name> &amp;&amp; <name><name>sqm</name>-&gt;<name>sq_contains</name></name> != <name>NULL</name></expr>)</condition><then>
			<return>return <expr><call>(*<name><name>sqm</name>-&gt;<name>sq_contains</name></name>)<argument_list>(<argument><expr><name>seq</name></expr></argument>, <argument><expr><name>ob</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
	}</block></then></if>
	<expr_stmt><expr><name>result</name> = <call><name>_PySequence_IterSearch</name><argument_list>(<argument><expr><name>seq</name></expr></argument>, <argument><expr><name>ob</name></expr></argument>, <argument><expr><name>PY_ITERSEARCH_CONTAINS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><call><name>Py_SAFE_DOWNCAST</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>Py_ssize_t</name></expr></argument>, <argument><expr><name>int</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<comment type="block">/* Backwards compatibility */</comment>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>PySequence_In</name></cpp:undef>
<function><type><name>int</name></type>
<name>PySequence_In</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>w</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>v</name></decl></param>)</parameter_list>
<block>{
	<return>return <expr><call><name>PySequence_Contains</name><argument_list>(<argument><expr><name>w</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>Py_ssize_t</name></type>
<name>PySequence_Index</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>s</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>o</name></decl></param>)</parameter_list>
<block>{
	<return>return <expr><call><name>_PySequence_IterSearch</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>o</name></expr></argument>, <argument><expr><name>PY_ITERSEARCH_INDEX</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<comment type="block">/* Operations on mappings */</comment>

<function><type><name>int</name></type>
<name>PyMapping_Check</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>o</name></decl></param>)</parameter_list>
<block>{
	<if>if <condition>(<expr><name>o</name> &amp;&amp; <call><name>PyInstance_Check</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><call><name>PyObject_HasAttrString</name><argument_list>(<argument><expr><name>o</name></expr></argument>, <argument><expr>"__getitem__"</expr></argument>)</argument_list></call></expr>;</return></then></if>

	<return>return  <expr><name>o</name> &amp;&amp; <name><name>o</name>-&gt;<name>ob_type</name>-&gt;<name>tp_as_mapping</name></name> &amp;&amp;
		<name><name>o</name>-&gt;<name>ob_type</name>-&gt;<name>tp_as_mapping</name>-&gt;<name>mp_subscript</name></name> &amp;&amp;
		!(<name><name>o</name>-&gt;<name>ob_type</name>-&gt;<name>tp_as_sequence</name></name> &amp;&amp; 
		  <name><name>o</name>-&gt;<name>ob_type</name>-&gt;<name>tp_as_sequence</name>-&gt;<name>sq_slice</name></name>)</expr>;</return>
}</block></function>

<function><type><name>Py_ssize_t</name></type>
<name>PyMapping_Size</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>o</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyMappingMethods</name> *</type><name>m</name></decl>;</decl_stmt>

	<if>if <condition>(<expr><name>o</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>null_error</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>-1</expr>;</return>
	}</block></then></if>

	<expr_stmt><expr><name>m</name> = <name><name>o</name>-&gt;<name>ob_type</name>-&gt;<name>tp_as_mapping</name></name></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>m</name> &amp;&amp; <name><name>m</name>-&gt;<name>mp_length</name></name></expr>)</condition><then>
		<return>return <expr><call><name><name>m</name>-&gt;<name>mp_length</name></name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>;</return></then></if>

	<expr_stmt><expr><call><name>type_error</name><argument_list>(<argument><expr>"object of type '%.200s' has no len()"</expr></argument>, <argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr>-1</expr>;</return>
}</block></function>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>PyMapping_Length</name></cpp:undef>
<function><type><name>Py_ssize_t</name></type>
<name>PyMapping_Length</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>o</name></decl></param>)</parameter_list>
<block>{
	<return>return <expr><call><name>PyMapping_Size</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PyMapping_Length</name></cpp:macro> <cpp:value>PyMapping_Size</cpp:value></cpp:define>

<function><type><name>PyObject</name> *</type>
<name>PyMapping_GetItemString</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>o</name></decl></param>, <param><decl><type><name>char</name> *</type><name>key</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>okey</name></decl>, *<decl><type ref="prev"/><name>r</name></decl>;</decl_stmt>

	<if>if <condition>(<expr><name>key</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr><call><name>null_error</name><argument_list>()</argument_list></call></expr>;</return></then></if>

	<expr_stmt><expr><name>okey</name> = <call><name>PyString_FromString</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>okey</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<expr_stmt><expr><name>r</name> = <call><name>PyObject_GetItem</name><argument_list>(<argument><expr><name>o</name></expr></argument>, <argument><expr><name>okey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>okey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>r</name></expr>;</return>
}</block></function>

<function><type><name>int</name></type>
<name>PyMapping_SetItemString</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>o</name></decl></param>, <param><decl><type><name>char</name> *</type><name>key</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>value</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>okey</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>r</name></decl>;</decl_stmt>

	<if>if <condition>(<expr><name>key</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>null_error</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>-1</expr>;</return>
	}</block></then></if>

	<expr_stmt><expr><name>okey</name> = <call><name>PyString_FromString</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>okey</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr>-1</expr>;</return></then></if>
	<expr_stmt><expr><name>r</name> = <call><name>PyObject_SetItem</name><argument_list>(<argument><expr><name>o</name></expr></argument>, <argument><expr><name>okey</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>okey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>r</name></expr>;</return>
}</block></function>

<function><type><name>int</name></type>
<name>PyMapping_HasKeyString</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>o</name></decl></param>, <param><decl><type><name>char</name> *</type><name>key</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>v</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>v</name> = <call><name>PyMapping_GetItemString</name><argument_list>(<argument><expr><name>o</name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>v</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>1</expr>;</return>
	}</block></then></if>
	<expr_stmt><expr><call><name>PyErr_Clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<return>return <expr>0</expr>;</return>
}</block></function>

<function><type><name>int</name></type>
<name>PyMapping_HasKey</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>o</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>key</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>v</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>v</name> = <call><name>PyObject_GetItem</name><argument_list>(<argument><expr><name>o</name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>v</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>1</expr>;</return>
	}</block></then></if>
	<expr_stmt><expr><call><name>PyErr_Clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<return>return <expr>0</expr>;</return>
}</block></function>

<comment type="block">/* Operations on callable objects */</comment>

<comment type="block">/* XXX PyCallable_Check() is in object.c */</comment>

<function><type><name>PyObject</name> *</type>
<name>PyObject_CallObject</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>o</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>a</name></decl></param>)</parameter_list>
<block>{
	<return>return <expr><call><name>PyEval_CallObjectWithKeywords</name><argument_list>(<argument><expr><name>o</name></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>PyObject</name> *</type>
<name>PyObject_Call</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>func</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>arg</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>kw</name></decl></param>)</parameter_list>
<block>{
        <decl_stmt><decl><type><name>ternaryfunc</name></type> <name>call</name></decl>;</decl_stmt>

	<if>if <condition>(<expr>(<name>call</name> = <name><name>func</name>-&gt;<name>ob_type</name>-&gt;<name>tp_call</name></name>) != <name>NULL</name></expr>)</condition><then> <block>{
		<decl_stmt><decl><type><name>PyObject</name> *</type><name>result</name></decl>;</decl_stmt>
		<if>if <condition>(<expr><call><name>Py_EnterRecursiveCall</name><argument_list>(<argument><expr>" while calling a Python object"</expr></argument>)</argument_list></call></expr>)</condition><then>
		    <return>return <expr><name>NULL</name></expr>;</return></then></if>
		<expr_stmt><expr><name>result</name> = <call>(*<name>call</name>)<argument_list>(<argument><expr><name>func</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>, <argument><expr><name>kw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_LeaveRecursiveCall</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>result</name> == <name>NULL</name> &amp;&amp; !<call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then>
			<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(
				<argument><expr><name>PyExc_SystemError</name></expr></argument>,
				<argument><expr>"NULL result without error in PyObject_Call"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
		<return>return <expr><name>result</name></expr>;</return>
	}</block></then></if>
	<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>, <argument><expr>"'%.200s' object is not callable"</expr></argument>,
		     <argument><expr><name><name>func</name>-&gt;<name>ob_type</name>-&gt;<name>tp_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>NULL</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name>*</type>
<name>call_function_tail</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>callable</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>retval</name></decl>;</decl_stmt>

	<if>if <condition>(<expr><name>args</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>

	<if>if <condition>(<expr>!<call><name>PyTuple_Check</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<decl_stmt><decl><type><name>PyObject</name> *</type><name>a</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>a</name> = <call><name>PyTuple_New</name><argument_list>(<argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>a</name> == <name>NULL</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>NULL</name></expr>;</return>
		}</block></then></if>
		<expr_stmt><expr><call><name>PyTuple_SET_ITEM</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>args</name> = <name>a</name></expr>;</expr_stmt>
	}</block></then></if>
	<expr_stmt><expr><name>retval</name> = <call><name>PyObject_Call</name><argument_list>(<argument><expr><name>callable</name></expr></argument>, <argument><expr><name>args</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>retval</name></expr>;</return>
}</block></function>

<function><type><name>PyObject</name> *</type>
<name>PyObject_CallFunction</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>callable</name></decl></param>, <param><decl><type><name>char</name> *</type><name>format</name></decl></param>, <param><decl><type>...</type></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>va_list</name></type> <name>va</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>args</name></decl>;</decl_stmt>

	<if>if <condition>(<expr><name>callable</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr><call><name>null_error</name><argument_list>()</argument_list></call></expr>;</return></then></if>

	<if>if <condition>(<expr><name>format</name> &amp;&amp; *<name>format</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>va</name></expr></argument>, <argument><expr><name>format</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>args</name> = <call><name>Py_VaBuildValue</name><argument_list>(<argument><expr><name>format</name></expr></argument>, <argument><expr><name>va</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>va</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then>
	<else>else
		<expr_stmt><expr><name>args</name> = <call><name>PyTuple_New</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>

	<return>return <expr><call><name>call_function_tail</name><argument_list>(<argument><expr><name>callable</name></expr></argument>, <argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>PyObject</name> *</type>
<name>_PyObject_CallFunction_SizeT</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>callable</name></decl></param>, <param><decl><type><name>char</name> *</type><name>format</name></decl></param>, <param><decl><type>...</type></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>va_list</name></type> <name>va</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>args</name></decl>;</decl_stmt>

	<if>if <condition>(<expr><name>callable</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr><call><name>null_error</name><argument_list>()</argument_list></call></expr>;</return></then></if>

	<if>if <condition>(<expr><name>format</name> &amp;&amp; *<name>format</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>va</name></expr></argument>, <argument><expr><name>format</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>args</name> = <call><name>_Py_VaBuildValue_SizeT</name><argument_list>(<argument><expr><name>format</name></expr></argument>, <argument><expr><name>va</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>va</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then>
	<else>else
		<expr_stmt><expr><name>args</name> = <call><name>PyTuple_New</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>

	<return>return <expr><call><name>call_function_tail</name><argument_list>(<argument><expr><name>callable</name></expr></argument>, <argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>PyObject</name> *</type>
<name>PyObject_CallMethod</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>o</name></decl></param>, <param><decl><type><name>char</name> *</type><name>name</name></decl></param>, <param><decl><type><name>char</name> *</type><name>format</name></decl></param>, <param><decl><type>...</type></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>va_list</name></type> <name>va</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>args</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>func</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>retval</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<if>if <condition>(<expr><name>o</name> == <name>NULL</name> || <name>name</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr><call><name>null_error</name><argument_list>()</argument_list></call></expr>;</return></then></if>

	<expr_stmt><expr><name>func</name> = <call><name>PyObject_GetAttrString</name><argument_list>(<argument><expr><name>o</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>func</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_AttributeError</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>0</expr>;</return>
	}</block></then></if>

	<if>if <condition>(<expr>!<call><name>PyCallable_Check</name><argument_list>(<argument><expr><name>func</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>type_error</name><argument_list>(<argument><expr>"attribute of type '%.200s' is not callable"</expr></argument>, <argument><expr><name>func</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
		<goto>goto <name>exit</name>;</goto>
	}</block></then></if>

	<if>if <condition>(<expr><name>format</name> &amp;&amp; *<name>format</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>va</name></expr></argument>, <argument><expr><name>format</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>args</name> = <call><name>Py_VaBuildValue</name><argument_list>(<argument><expr><name>format</name></expr></argument>, <argument><expr><name>va</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>va</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then>
	<else>else
		<expr_stmt><expr><name>args</name> = <call><name>PyTuple_New</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>

	<expr_stmt><expr><name>retval</name> = <call><name>call_function_tail</name><argument_list>(<argument><expr><name>func</name></expr></argument>, <argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <label><name>exit</name>:</label>
	<comment type="block">/* args gets consumed in call_function_tail */</comment>
	<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>func</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>retval</name></expr>;</return>
}</block></function>

<function><type><name>PyObject</name> *</type>
<name>_PyObject_CallMethod_SizeT</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>o</name></decl></param>, <param><decl><type><name>char</name> *</type><name>name</name></decl></param>, <param><decl><type><name>char</name> *</type><name>format</name></decl></param>, <param><decl><type>...</type></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>va_list</name></type> <name>va</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>args</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>func</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>retval</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<if>if <condition>(<expr><name>o</name> == <name>NULL</name> || <name>name</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr><call><name>null_error</name><argument_list>()</argument_list></call></expr>;</return></then></if>

	<expr_stmt><expr><name>func</name> = <call><name>PyObject_GetAttrString</name><argument_list>(<argument><expr><name>o</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>func</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_AttributeError</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>0</expr>;</return>
	}</block></then></if>

	<if>if <condition>(<expr>!<call><name>PyCallable_Check</name><argument_list>(<argument><expr><name>func</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>type_error</name><argument_list>(<argument><expr>"attribute of type '%.200s' is not callable"</expr></argument>, <argument><expr><name>func</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
		<goto>goto <name>exit</name>;</goto>
	}</block></then></if>

	<if>if <condition>(<expr><name>format</name> &amp;&amp; *<name>format</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>va</name></expr></argument>, <argument><expr><name>format</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>args</name> = <call><name>_Py_VaBuildValue_SizeT</name><argument_list>(<argument><expr><name>format</name></expr></argument>, <argument><expr><name>va</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>va</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then>
	<else>else
		<expr_stmt><expr><name>args</name> = <call><name>PyTuple_New</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>

	<expr_stmt><expr><name>retval</name> = <call><name>call_function_tail</name><argument_list>(<argument><expr><name>func</name></expr></argument>, <argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <label><name>exit</name>:</label>
	<comment type="block">/* args gets consumed in call_function_tail */</comment>
	<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>func</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>retval</name></expr>;</return>
}</block></function>


<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>objargs_mktuple</name><parameter_list>(<param><decl><type><name>va_list</name></type> <name>va</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>n</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>va_list</name></type> <name>countva</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>result</name></decl>, *<decl><type ref="prev"/><name>tmp</name></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>VA_LIST_IS_ARRAY</name></cpp:ifdef>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>countva</name></expr></argument>, <argument><expr><name>va</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>va_list</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__va_copy</name></cpp:ifdef>
	<expr_stmt><expr><call><name>__va_copy</name><argument_list>(<argument><expr><name>countva</name></expr></argument>, <argument><expr><name>va</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<expr_stmt><expr><name>countva</name> = <name>va</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<while>while <condition>(<expr>((<name>PyObject</name> *)<call><name>va_arg</name><argument_list>(<argument><expr><name>countva</name></expr></argument>, <argument><expr><name>PyObject</name> *</expr></argument>)</argument_list></call>) != <name>NULL</name></expr>)</condition>
		<expr_stmt><expr>++<name>n</name></expr>;</expr_stmt></while>
	<expr_stmt><expr><name>result</name> = <call><name>PyTuple_New</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>result</name> != <name>NULL</name> &amp;&amp; <name>n</name> &gt; 0</expr>)</condition><then> <block>{
		<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>n</name></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>) <block>{
			<expr_stmt><expr><name>tmp</name> = (<name>PyObject</name> *)<call><name>va_arg</name><argument_list>(<argument><expr><name>va</name></expr></argument>, <argument><expr><name>PyObject</name> *</expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>PyTuple_SET_ITEM</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></for>
	}</block></then></if>
	<return>return <expr><name>result</name></expr>;</return>
}</block></function>

<function><type><name>PyObject</name> *</type>
<name>PyObject_CallMethodObjArgs</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>callable</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>name</name></decl></param>, <param><decl><type>...</type></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>args</name></decl>, *<decl><type ref="prev"/><name>tmp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>va_list</name></type> <name>vargs</name></decl>;</decl_stmt>

	<if>if <condition>(<expr><name>callable</name> == <name>NULL</name> || <name>name</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr><call><name>null_error</name><argument_list>()</argument_list></call></expr>;</return></then></if>

	<expr_stmt><expr><name>callable</name> = <call><name>PyObject_GetAttr</name><argument_list>(<argument><expr><name>callable</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>callable</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>

	<comment type="block">/* count the args */</comment>
	<expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>vargs</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>args</name> = <call><name>objargs_mktuple</name><argument_list>(<argument><expr><name>vargs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>vargs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>args</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>callable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>
	<expr_stmt><expr><name>tmp</name> = <call><name>PyObject_Call</name><argument_list>(<argument><expr><name>callable</name></expr></argument>, <argument><expr><name>args</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>callable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>tmp</name></expr>;</return>
}</block></function>

<function><type><name>PyObject</name> *</type>
<name>PyObject_CallFunctionObjArgs</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>callable</name></decl></param>, <param><decl><type>...</type></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>args</name></decl>, *<decl><type ref="prev"/><name>tmp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>va_list</name></type> <name>vargs</name></decl>;</decl_stmt>

	<if>if <condition>(<expr><name>callable</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr><call><name>null_error</name><argument_list>()</argument_list></call></expr>;</return></then></if>

	<comment type="block">/* count the args */</comment>
	<expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>vargs</name></expr></argument>, <argument><expr><name>callable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>args</name> = <call><name>objargs_mktuple</name><argument_list>(<argument><expr><name>vargs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>vargs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>args</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<expr_stmt><expr><name>tmp</name> = <call><name>PyObject_Call</name><argument_list>(<argument><expr><name>callable</name></expr></argument>, <argument><expr><name>args</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>tmp</name></expr>;</return>
}</block></function>


<comment type="block">/* isinstance(), issubclass() */</comment>

<comment type="block">/* abstract_get_bases() has logically 4 return states, with a sort of 0th
 * state that will almost never happen.
 *
 * 0. creating the __bases__ static string could get a MemoryError
 * 1. getattr(cls, '__bases__') could raise an AttributeError
 * 2. getattr(cls, '__bases__') could raise some other exception
 * 3. getattr(cls, '__bases__') could return a tuple
 * 4. getattr(cls, '__bases__') could return something other than a tuple
 *
 * Only state #3 is a non-error state and only it returns a non-NULL object
 * (it returns the retrieved tuple).
 *
 * Any raised AttributeErrors are masked by clearing the exception and
 * returning NULL.  If an object other than a tuple comes out of __bases__,
 * then again, the return value is NULL.  So yes, these two situations
 * produce exactly the same results: NULL is returned and no error is set.
 *
 * If some exception other than AttributeError is raised, then NULL is also
 * returned, but the exception is not cleared.  That's because we want the
 * exception to be propagated along.
 *
 * Callers are expected to test for PyErr_Occurred() when the return value
 * is NULL to decide whether a valid exception should be propagated or not.
 * When there's no exception to propagate, it's customary for the caller to
 * set a TypeError.
 */</comment>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>abstract_get_bases</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>cls</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><specifier>static</specifier> <name>PyObject</name> *</type><name>__bases__</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>bases</name></decl>;</decl_stmt>

	<if>if <condition>(<expr><name>__bases__</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>__bases__</name> = <call><name>PyString_InternFromString</name><argument_list>(<argument><expr>"__bases__"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>__bases__</name> == <name>NULL</name></expr>)</condition><then>
			<return>return <expr><name>NULL</name></expr>;</return></then></if>
	}</block></then></if>
	<expr_stmt><expr><name>bases</name> = <call><name>PyObject_GetAttr</name><argument_list>(<argument><expr><name>cls</name></expr></argument>, <argument><expr><name>__bases__</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>bases</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<if>if <condition>(<expr><call><name>PyErr_ExceptionMatches</name><argument_list>(<argument><expr><name>PyExc_AttributeError</name></expr></argument>)</argument_list></call></expr>)</condition><then>
			<expr_stmt><expr><call><name>PyErr_Clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>
	<if>if <condition>(<expr>!<call><name>PyTuple_Check</name><argument_list>(<argument><expr><name>bases</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
	        <expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>bases</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>
	<return>return <expr><name>bases</name></expr>;</return>
}</block></function>


<function><type><specifier>static</specifier> <name>int</name></type>
<name>abstract_issubclass</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>derived</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>cls</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>bases</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>n</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>r</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>

	<while>while <condition>(<expr>1</expr>)</condition> <block>{
		<if>if <condition>(<expr><name>derived</name> == <name>cls</name></expr>)</condition><then>
			<return>return <expr>1</expr>;</return></then></if>
		<expr_stmt><expr><name>bases</name> = <call><name>abstract_get_bases</name><argument_list>(<argument><expr><name>derived</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>bases</name> == <name>NULL</name></expr>)</condition><then> <block>{
			<if>if <condition>(<expr><call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then>
				<return>return <expr>-1</expr>;</return></then></if>
			<return>return <expr>0</expr>;</return>
		}</block></then></if>
		<expr_stmt><expr><name>n</name> = <call><name>PyTuple_GET_SIZE</name><argument_list>(<argument><expr><name>bases</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>n</name> == 0</expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>bases</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr>0</expr>;</return>
		}</block></then></if>
		<comment type="block">/* Avoid recursivity in the single inheritance case */</comment>
		<if>if <condition>(<expr><name>n</name> == 1</expr>)</condition><then> <block>{
			<expr_stmt><expr><name>derived</name> = <call><name>PyTuple_GET_ITEM</name><argument_list>(<argument><expr><name>bases</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>bases</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<continue>continue;</continue>
		}</block></then></if>
		<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>n</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
			<expr_stmt><expr><name>r</name> = <call><name>abstract_issubclass</name><argument_list>(<argument><expr><call><name>PyTuple_GET_ITEM</name><argument_list>(<argument><expr><name>bases</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>cls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><name>r</name> != 0</expr>)</condition><then>
				<break>break;</break></then></if>
		}</block></for>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>bases</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>r</name></expr>;</return>
	}</block></while>
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>check_class</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>cls</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>error</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>bases</name> <init>= <expr><call><name>abstract_get_bases</name><argument_list>(<argument><expr><name>cls</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if>if <condition>(<expr><name>bases</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<comment type="block">/* Do not mask errors. */</comment>
		<if>if <condition>(<expr>!<call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then>
			<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>, <argument><expr><name>error</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
		<return>return <expr>0</expr>;</return>
	}</block></then></if>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>bases</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr>-1</expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>recursive_isinstance</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>inst</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>cls</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>icls</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>static</specifier> <name>PyObject</name> *</type><name>__class__</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>retval</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>

	<if>if <condition>(<expr><name>__class__</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>__class__</name> = <call><name>PyString_InternFromString</name><argument_list>(<argument><expr>"__class__"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>__class__</name> == <name>NULL</name></expr>)</condition><then>
			<return>return <expr>-1</expr>;</return></then></if>
	}</block></then></if>

	<if>if <condition>(<expr><call><name>PyClass_Check</name><argument_list>(<argument><expr><name>cls</name></expr></argument>)</argument_list></call> &amp;&amp; <call><name>PyInstance_Check</name><argument_list>(<argument><expr><name>inst</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<decl_stmt><decl><type><name>PyObject</name> *</type><name>inclass</name> <init>=
			<expr><call>(<name>PyObject</name>*)<argument_list>(<argument><expr>(<name>PyInstanceObject</name>*)<name>inst</name></expr></argument>)</argument_list></call>-&gt;<name>in_class</name></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name>retval</name> = <call><name>PyClass_IsSubclass</name><argument_list>(<argument><expr><name>inclass</name></expr></argument>, <argument><expr><name>cls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then>
	<else>else <if>if <condition>(<expr><call><name>PyType_Check</name><argument_list>(<argument><expr><name>cls</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>retval</name> = <call><name>PyObject_TypeCheck</name><argument_list>(<argument><expr><name>inst</name></expr></argument>, <argument><expr>(<name>PyTypeObject</name> *)<name>cls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>retval</name> == 0</expr>)</condition><then> <block>{
			<decl_stmt><decl><type><name>PyObject</name> *</type><name>c</name> <init>= <expr><call><name>PyObject_GetAttr</name><argument_list>(<argument><expr><name>inst</name></expr></argument>, <argument><expr><name>__class__</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<if>if <condition>(<expr><name>c</name> == <name>NULL</name></expr>)</condition><then> <block>{
				<expr_stmt><expr><call><name>PyErr_Clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			}</block></then>
			<else>else <block>{
				<if>if <condition>(<expr><name>c</name> != <call>(<name>PyObject</name> *)<argument_list>(<argument><expr><name><name>inst</name>-&gt;<name>ob_type</name></name></expr></argument>)</argument_list></call> &amp;&amp;
				    <call><name>PyType_Check</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>)</condition><then>
					<expr_stmt><expr><name>retval</name> = <call><name>PyType_IsSubtype</name><argument_list>(
						<argument><expr>(<name>PyTypeObject</name> *)<name>c</name></expr></argument>,
						<argument><expr>(<name>PyTypeObject</name> *)<name>cls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
				<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			}</block></else></if>
		}</block></then></if>
	}</block></then>
	<else>else <block>{
		<if>if <condition>(<expr>!<call><name>check_class</name><argument_list>(<argument><expr><name>cls</name></expr></argument>,
			<argument><expr>"isinstance() arg 2 must be a class, type,"
			" or tuple of classes and types"</expr></argument>)</argument_list></call></expr>)</condition><then>
			<return>return <expr>-1</expr>;</return></then></if>
		<expr_stmt><expr><name>icls</name> = <call><name>PyObject_GetAttr</name><argument_list>(<argument><expr><name>inst</name></expr></argument>, <argument><expr><name>__class__</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>icls</name> == <name>NULL</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>PyErr_Clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>retval</name> = 0</expr>;</expr_stmt>
		}</block></then>
		<else>else <block>{
			<expr_stmt><expr><name>retval</name> = <call><name>abstract_issubclass</name><argument_list>(<argument><expr><name>icls</name></expr></argument>, <argument><expr><name>cls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>icls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></else></if>
	}</block></else></if></else></if>

	<return>return <expr><name>retval</name></expr>;</return>
}</block></function>

<function><type><name>int</name></type>
<name>PyObject_IsInstance</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>inst</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>cls</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><specifier>static</specifier> <name>PyObject</name> *</type><name>name</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>checker</name></decl>;</decl_stmt>

	<comment type="block">/* Quick test for an exact match */</comment>
	<if>if <condition>(<expr><call><name>Py_TYPE</name><argument_list>(<argument><expr><name>inst</name></expr></argument>)</argument_list></call> == (<name>PyTypeObject</name> *)<name>cls</name></expr>)</condition><then>
		<return>return <expr>1</expr>;</return></then></if>

	<if>if <condition>(<expr><call><name>PyTuple_Check</name><argument_list>(<argument><expr><name>cls</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>i</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>n</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>r</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>

		<if>if <condition>(<expr><call><name>Py_EnterRecursiveCall</name><argument_list>(<argument><expr>" in __instancecheck__"</expr></argument>)</argument_list></call></expr>)</condition><then>
			<return>return <expr>-1</expr>;</return></then></if>
		<expr_stmt><expr><name>n</name> = <call><name>PyTuple_GET_SIZE</name><argument_list>(<argument><expr><name>cls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>n</name></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>) <block>{
			<decl_stmt><decl><type><name>PyObject</name> *</type><name>item</name> <init>= <expr><call><name>PyTuple_GET_ITEM</name><argument_list>(<argument><expr><name>cls</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><name>r</name> = <call><name>PyObject_IsInstance</name><argument_list>(<argument><expr><name>inst</name></expr></argument>, <argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><name>r</name> != 0</expr>)</condition><then>
				<comment type="block">/* either found it, or got an error */</comment>
				<break>break;</break></then></if>
		}</block></for>
		<expr_stmt><expr><call><name>Py_LeaveRecursiveCall</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>r</name></expr>;</return>
	}</block></then></if>
	<if>if <condition>(<expr><name>name</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>name</name> = <call><name>PyString_InternFromString</name><argument_list>(<argument><expr>"__instancecheck__"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>name</name> == <name>NULL</name></expr>)</condition><then>
			<return>return <expr>-1</expr>;</return></then></if>
	}</block></then></if>
	<expr_stmt><expr><name>checker</name> = <call><name>PyObject_GetAttr</name><argument_list>(<argument><expr><name>cls</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>checker</name> == <name>NULL</name> &amp;&amp; <call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then>
		<expr_stmt><expr><call><name>PyErr_Clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>
	<if>if <condition>(<expr><name>checker</name> != <name>NULL</name></expr>)</condition><then> <block>{
		<decl_stmt><decl><type><name>PyObject</name> *</type><name>res</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>ok</name> <init>= <expr>-1</expr></init></decl>;</decl_stmt>
		<if>if <condition>(<expr><call><name>Py_EnterRecursiveCall</name><argument_list>(<argument><expr>" in __instancecheck__"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>checker</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>ok</name></expr>;</return>
		}</block></then></if>
		<expr_stmt><expr><name>res</name> = <call><name>PyObject_CallFunctionObjArgs</name><argument_list>(<argument><expr><name>checker</name></expr></argument>, <argument><expr><name>inst</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_LeaveRecursiveCall</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>checker</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>res</name> != <name>NULL</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><name>ok</name> = <call><name>PyObject_IsTrue</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></then></if>
		<return>return <expr><name>ok</name></expr>;</return>
	}</block></then></if>
	<return>return <expr><call><name>recursive_isinstance</name><argument_list>(<argument><expr><name>inst</name></expr></argument>, <argument><expr><name>cls</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier>  <name>int</name></type>
<name>recursive_issubclass</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>derived</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>cls</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>int</name></type> <name>retval</name></decl>;</decl_stmt>

 	<if>if <condition>(<expr><call><name>PyType_Check</name><argument_list>(<argument><expr><name>cls</name></expr></argument>)</argument_list></call> &amp;&amp; <call><name>PyType_Check</name><argument_list>(<argument><expr><name>derived</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
 		<comment type="block">/* Fast path (non-recursive) */</comment>
 		<return>return <expr><call><name>PyType_IsSubtype</name><argument_list>(
			<argument><expr>(<name>PyTypeObject</name> *)<name>derived</name></expr></argument>, <argument><expr>(<name>PyTypeObject</name> *)<name>cls</name></expr></argument>)</argument_list></call></expr>;</return>
 	}</block></then></if>
	<if>if <condition>(<expr>!<call><name>PyClass_Check</name><argument_list>(<argument><expr><name>derived</name></expr></argument>)</argument_list></call> || !<call><name>PyClass_Check</name><argument_list>(<argument><expr><name>cls</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<if>if <condition>(<expr>!<call><name>check_class</name><argument_list>(<argument><expr><name>derived</name></expr></argument>,
				 <argument><expr>"issubclass() arg 1 must be a class"</expr></argument>)</argument_list></call></expr>)</condition><then>
			<return>return <expr>-1</expr>;</return></then></if>

		<if>if <condition>(<expr>!<call><name>check_class</name><argument_list>(<argument><expr><name>cls</name></expr></argument>,
				<argument><expr>"issubclass() arg 2 must be a class"
				" or tuple of classes"</expr></argument>)</argument_list></call></expr>)</condition><then>
			<return>return <expr>-1</expr>;</return></then></if>
		<expr_stmt><expr><name>retval</name> = <call><name>abstract_issubclass</name><argument_list>(<argument><expr><name>derived</name></expr></argument>, <argument><expr><name>cls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then>
	<else>else <block>{
		<comment type="block">/* shortcut */</comment>
	  	<if>if <condition>(<expr>!(<name>retval</name> = (<name>derived</name> == <name>cls</name>))</expr>)</condition><then>
			<expr_stmt><expr><name>retval</name> = <call><name>PyClass_IsSubclass</name><argument_list>(<argument><expr><name>derived</name></expr></argument>, <argument><expr><name>cls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
	}</block></else></if>

	<return>return <expr><name>retval</name></expr>;</return>
}</block></function>

<function><type><name>int</name></type>
<name>PyObject_IsSubclass</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>derived</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>cls</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><specifier>static</specifier> <name>PyObject</name> *</type><name>name</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>t</name></decl>, *<decl><type ref="prev"/><name>v</name></decl>, *<decl><type ref="prev"/><name>tb</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>checker</name></decl>;</decl_stmt>
	
 	<if>if <condition>(<expr><call><name>PyTuple_Check</name><argument_list>(<argument><expr><name>cls</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
 		<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>i</name></decl>;</decl_stmt>
 		<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>n</name></decl>;</decl_stmt>
 		<decl_stmt><decl><type><name>int</name></type> <name>r</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
 
 		<if>if <condition>(<expr><call><name>Py_EnterRecursiveCall</name><argument_list>(<argument><expr>" in __subclasscheck__"</expr></argument>)</argument_list></call></expr>)</condition><then>
 			<return>return <expr>-1</expr>;</return></then></if>
 		<expr_stmt><expr><name>n</name> = <call><name>PyTuple_GET_SIZE</name><argument_list>(<argument><expr><name>cls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
 		<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>n</name></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>) <block>{
 			<decl_stmt><decl><type><name>PyObject</name> *</type><name>item</name> <init>= <expr><call><name>PyTuple_GET_ITEM</name><argument_list>(<argument><expr><name>cls</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
 			<expr_stmt><expr><name>r</name> = <call><name>PyObject_IsSubclass</name><argument_list>(<argument><expr><name>derived</name></expr></argument>, <argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
 			<if>if <condition>(<expr><name>r</name> != 0</expr>)</condition><then>
 				<comment type="block">/* either found it, or got an error */</comment>
 				<break>break;</break></then></if>
 		}</block></for>
 		<expr_stmt><expr><call><name>Py_LeaveRecursiveCall</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
 		<return>return <expr><name>r</name></expr>;</return>
 	}</block></then></if>
	<if>if <condition>(<expr><name>name</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>name</name> = <call><name>PyString_InternFromString</name><argument_list>(<argument><expr>"__subclasscheck__"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>name</name> == <name>NULL</name></expr>)</condition><then>
			<return>return <expr>-1</expr>;</return></then></if>
	}</block></then></if>
	<expr_stmt><expr><call><name>PyErr_Fetch</name><argument_list>(<argument><expr>&amp;<name>t</name></expr></argument>, <argument><expr>&amp;<name>v</name></expr></argument>, <argument><expr>&amp;<name>tb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>checker</name> = <call><name>PyObject_GetAttr</name><argument_list>(<argument><expr><name>cls</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PyErr_Restore</name><argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><name>v</name></expr></argument>, <argument><expr><name>tb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>checker</name> != <name>NULL</name></expr>)</condition><then> <block>{
		<decl_stmt><decl><type><name>PyObject</name> *</type><name>res</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>ok</name> <init>= <expr>-1</expr></init></decl>;</decl_stmt>
		<if>if <condition>(<expr><call><name>Py_EnterRecursiveCall</name><argument_list>(<argument><expr>" in __subclasscheck__"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>checker</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>ok</name></expr>;</return>
		}</block></then></if>
		<expr_stmt><expr><name>res</name> = <call><name>PyObject_CallFunctionObjArgs</name><argument_list>(<argument><expr><name>checker</name></expr></argument>, <argument><expr><name>derived</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_LeaveRecursiveCall</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>checker</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>res</name> != <name>NULL</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><name>ok</name> = <call><name>PyObject_IsTrue</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></then></if>
		<return>return <expr><name>ok</name></expr>;</return>
	}</block></then></if>
	<return>return <expr><call><name>recursive_issubclass</name><argument_list>(<argument><expr><name>derived</name></expr></argument>, <argument><expr><name>cls</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>int</name></type>
<name>_PyObject_RealIsInstance</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>inst</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>cls</name></decl></param>)</parameter_list>
<block>{
	<return>return <expr><call><name>recursive_isinstance</name><argument_list>(<argument><expr><name>inst</name></expr></argument>, <argument><expr><name>cls</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>int</name></type>
<name>_PyObject_RealIsSubclass</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>derived</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>cls</name></decl></param>)</parameter_list>
<block>{
	<return>return <expr><call><name>recursive_issubclass</name><argument_list>(<argument><expr><name>derived</name></expr></argument>, <argument><expr><name>cls</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>


<function><type><name>PyObject</name> *</type>
<name>PyObject_GetIter</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>o</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyTypeObject</name> *</type><name>t</name> <init>= <expr><name><name>o</name>-&gt;<name>ob_type</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>getiterfunc</name></type> <name>f</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<if>if <condition>(<expr><call><name>PyType_HasFeature</name><argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><name>Py_TPFLAGS_HAVE_ITER</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<expr_stmt><expr><name>f</name> = <name><name>t</name>-&gt;<name>tp_iter</name></name></expr>;</expr_stmt></then></if>
	<if>if <condition>(<expr><name>f</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<if>if <condition>(<expr><call><name>PySequence_Check</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>)</condition><then>
			<return>return <expr><call><name>PySeqIter_New</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
		<return>return <expr><call><name>type_error</name><argument_list>(<argument><expr>"'%.200s' object is not iterable"</expr></argument>, <argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>;</return>
	}</block></then>
	<else>else <block>{
		<decl_stmt><decl><type><name>PyObject</name> *</type><name>res</name> <init>= <expr><call>(*<name>f</name>)<argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if>if <condition>(<expr><name>res</name> != <name>NULL</name> &amp;&amp; !<call><name>PyIter_Check</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
				     <argument><expr>"iter() returned non-iterator "
				     "of type '%.100s'"</expr></argument>,
				     <argument><expr><name><name>res</name>-&gt;<name>ob_type</name>-&gt;<name>tp_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>res</name> = <name>NULL</name></expr>;</expr_stmt>
		}</block></then></if>
		<return>return <expr><name>res</name></expr>;</return>
	}</block></else></if>
}</block></function>

<comment type="block">/* Return next item.
 * If an error occurs, return NULL.  PyErr_Occurred() will be true.
 * If the iteration terminates normally, return NULL and clear the
 * PyExc_StopIteration exception (if it was set).  PyErr_Occurred()
 * will be false.
 * Else return the next object.  PyErr_Occurred() will be false.
 */</comment>
<function><type><name>PyObject</name> *</type>
<name>PyIter_Next</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>iter</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>result</name></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>PyIter_Check</name><argument_list>(<argument><expr><name>iter</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>result</name> = <call>(*<name><name>iter</name>-&gt;<name>ob_type</name>-&gt;<name>tp_iternext</name></name>)<argument_list>(<argument><expr><name>iter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>result</name> == <name>NULL</name> &amp;&amp;
	    <call><name>PyErr_Occurred</name><argument_list>()</argument_list></call> &amp;&amp;
	    <call><name>PyErr_ExceptionMatches</name><argument_list>(<argument><expr><name>PyExc_StopIteration</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<expr_stmt><expr><call><name>PyErr_Clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>
	<return>return <expr><name>result</name></expr>;</return>
}</block></function>
</unit>
