<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C" filename="projects/cpython-2.6.1/source/Objects/stringobject.c"><comment type="block">/* String (str/bytes) object implementation */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PY_SSIZE_T_CLEAN</name></cpp:macro></cpp:define>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"Python.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;ctype.h&gt;</cpp:file></cpp:include>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>COUNT_ALLOCS</name></cpp:ifdef>
<decl_stmt><decl><type><name>int</name></type> <name>null_strings</name></decl>, <decl><type ref="prev"/><name>one_strings</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<decl_stmt><decl><type><specifier>static</specifier> <name>PyStringObject</name> *</type><name><name>characters</name><index>[<expr><name>UCHAR_MAX</name> + 1</expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>PyStringObject</name> *</type><name>nullstring</name></decl>;</decl_stmt>

<comment type="block">/* This dictionary holds all interned strings.  Note that references to
   strings in this dictionary are *not* counted in the string's ob_refcnt.
   When the interned string reaches a refcnt of 0 the string deallocation
   function will delete the reference from this dictionary.

   Another way to look at this is that to say that the actual reference
   count of a string is:  s-&gt;ob_refcnt + (s-&gt;ob_sstate?2:0)
*/</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>PyObject</name> *</type><name>interned</name></decl>;</decl_stmt>

<comment type="block">/*
   For both PyString_FromString() and PyString_FromStringAndSize(), the
   parameter `size' denotes number of characters to allocate, not counting any
   null terminating character.

   For PyString_FromString(), the parameter `str' points to a null-terminated
   string containing exactly `size' bytes.

   For PyString_FromStringAndSize(), the parameter the parameter `str' is
   either NULL or else points to a string containing at least `size' bytes.
   For PyString_FromStringAndSize(), the string in the `str' parameter does
   not have to be null-terminated.  (Therefore it is safe to construct a
   substring by calling `PyString_FromStringAndSize(origstring, substrlen)'.)
   If `str' is NULL then PyString_FromStringAndSize() will allocate `size+1'
   bytes (setting the last byte to the null terminating character) and you can
   fill in the data yourself.  If `str' is non-NULL then the resulting
   PyString object must be treated as immutable and you must not fill in nor
   alter the data yourself, since the strings may be shared.

   The PyObject member `op-&gt;ob_size', which denotes the number of "extra
   items" in a variable-size object, will contain the number of bytes
   allocated for string data, not counting the null terminating character.  It
   is therefore equal to the equal to the `size' parameter (for
   PyString_FromStringAndSize()) or the length of the string in the `str'
   parameter (for PyString_FromString()).
*/</comment>
<function><type><name>PyObject</name> *</type>
<name>PyString_FromStringAndSize</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>str</name></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>size</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>register</name> <name>PyStringObject</name> *</type><name>op</name></decl>;</decl_stmt>
	<if>if <condition>(<expr><name>size</name> &lt; 0</expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_SystemError</name></expr></argument>,
		    <argument><expr>"Negative size passed to PyString_FromStringAndSize"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>
	<if>if <condition>(<expr><name>size</name> == 0 &amp;&amp; (<name>op</name> = <name>nullstring</name>) != <name>NULL</name></expr>)</condition><then> <block>{
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>COUNT_ALLOCS</name></cpp:ifdef>
		<expr_stmt><expr><name>null_strings</name>++</expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>(<name>PyObject</name> *)<name>op</name></expr>;</return>
	}</block></then></if>
	<if>if <condition>(<expr><name>size</name> == 1 &amp;&amp; <name>str</name> != <name>NULL</name> &amp;&amp;
	    (<name>op</name> = <name><name>characters</name><index>[<expr>*<name>str</name> &amp; <name>UCHAR_MAX</name></expr>]</index></name>) != <name>NULL</name></expr>)</condition><then>
	<block>{
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>COUNT_ALLOCS</name></cpp:ifdef>
		<expr_stmt><expr><name>one_strings</name>++</expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>(<name>PyObject</name> *)<name>op</name></expr>;</return>
	}</block></then></if>

	<if>if <condition>(<expr><name>size</name> &gt; <name>PY_SSIZE_T_MAX</name> - <sizeof>sizeof<argument_list>(<argument><expr><name>PyStringObject</name></expr></argument>)</argument_list></sizeof></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_OverflowError</name></expr></argument>, <argument><expr>"string is too large"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>

	<comment type="block">/* Inline PyObject_NewVar */</comment>
	<expr_stmt><expr><name>op</name> = (<name>PyStringObject</name> *)<call><name>PyObject_MALLOC</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PyStringObject</name></expr></argument>)</argument_list></sizeof> + <name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>op</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr><call><name>PyErr_NoMemory</name><argument_list>()</argument_list></call></expr>;</return></then></if>
	<expr_stmt><expr><call><name>PyObject_INIT_VAR</name><argument_list>(<argument><expr><name>op</name></expr></argument>, <argument><expr>&amp;<name>PyString_Type</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>op</name>-&gt;<name>ob_shash</name></name> = -1</expr>;</expr_stmt>
	<expr_stmt><expr><name><name>op</name>-&gt;<name>ob_sstate</name></name> = <name>SSTATE_NOT_INTERNED</name></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>str</name> != <name>NULL</name></expr>)</condition><then>
		<expr_stmt><expr><call><name>Py_MEMCPY</name><argument_list>(<argument><expr><name><name>op</name>-&gt;<name>ob_sval</name></name></expr></argument>, <argument><expr><name>str</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
	<expr_stmt><expr><name><name>op</name>-&gt;<name>ob_sval</name><index>[<expr><name>size</name></expr>]</index></name> = '\0'</expr>;</expr_stmt>
	<comment type="block">/* share short strings */</comment>
	<if>if <condition>(<expr><name>size</name> == 0</expr>)</condition><then> <block>{
		<decl_stmt><decl><type><name>PyObject</name> *</type><name>t</name> <init>= <expr>(<name>PyObject</name> *)<name>op</name></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>PyString_InternInPlace</name><argument_list>(<argument><expr>&amp;<name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>op</name> = (<name>PyStringObject</name> *)<name>t</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>nullstring</name> = <name>op</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then> <else>else <if>if <condition>(<expr><name>size</name> == 1 &amp;&amp; <name>str</name> != <name>NULL</name></expr>)</condition><then> <block>{
		<decl_stmt><decl><type><name>PyObject</name> *</type><name>t</name> <init>= <expr>(<name>PyObject</name> *)<name>op</name></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>PyString_InternInPlace</name><argument_list>(<argument><expr>&amp;<name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>op</name> = (<name>PyStringObject</name> *)<name>t</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>characters</name><index>[<expr>*<name>str</name> &amp; <name>UCHAR_MAX</name></expr>]</index></name> = <name>op</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if></else></if>
	<return>return <expr>(<name>PyObject</name> *) <name>op</name></expr>;</return>
}</block></function>

<function><type><name>PyObject</name> *</type>
<name>PyString_FromString</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>str</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>register</name> <name>size_t</name></type> <name>size</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>register</name> <name>PyStringObject</name> *</type><name>op</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>str</name> != <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>size</name> = <call><name>strlen</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>size</name> &gt; <name>PY_SSIZE_T_MAX</name> - <sizeof>sizeof<argument_list>(<argument><expr><name>PyStringObject</name></expr></argument>)</argument_list></sizeof></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_OverflowError</name></expr></argument>,
			<argument><expr>"string is too long for a Python string"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>
	<if>if <condition>(<expr><name>size</name> == 0 &amp;&amp; (<name>op</name> = <name>nullstring</name>) != <name>NULL</name></expr>)</condition><then> <block>{
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>COUNT_ALLOCS</name></cpp:ifdef>
		<expr_stmt><expr><name>null_strings</name>++</expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>(<name>PyObject</name> *)<name>op</name></expr>;</return>
	}</block></then></if>
	<if>if <condition>(<expr><name>size</name> == 1 &amp;&amp; (<name>op</name> = <name><name>characters</name><index>[<expr>*<name>str</name> &amp; <name>UCHAR_MAX</name></expr>]</index></name>) != <name>NULL</name></expr>)</condition><then> <block>{
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>COUNT_ALLOCS</name></cpp:ifdef>
		<expr_stmt><expr><name>one_strings</name>++</expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>(<name>PyObject</name> *)<name>op</name></expr>;</return>
	}</block></then></if>

	<comment type="block">/* Inline PyObject_NewVar */</comment>
	<expr_stmt><expr><name>op</name> = (<name>PyStringObject</name> *)<call><name>PyObject_MALLOC</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PyStringObject</name></expr></argument>)</argument_list></sizeof> + <name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>op</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr><call><name>PyErr_NoMemory</name><argument_list>()</argument_list></call></expr>;</return></then></if>
	<expr_stmt><expr><call><name>PyObject_INIT_VAR</name><argument_list>(<argument><expr><name>op</name></expr></argument>, <argument><expr>&amp;<name>PyString_Type</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>op</name>-&gt;<name>ob_shash</name></name> = -1</expr>;</expr_stmt>
	<expr_stmt><expr><name><name>op</name>-&gt;<name>ob_sstate</name></name> = <name>SSTATE_NOT_INTERNED</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_MEMCPY</name><argument_list>(<argument><expr><name><name>op</name>-&gt;<name>ob_sval</name></name></expr></argument>, <argument><expr><name>str</name></expr></argument>, <argument><expr><name>size</name>+1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* share short strings */</comment>
	<if>if <condition>(<expr><name>size</name> == 0</expr>)</condition><then> <block>{
		<decl_stmt><decl><type><name>PyObject</name> *</type><name>t</name> <init>= <expr>(<name>PyObject</name> *)<name>op</name></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>PyString_InternInPlace</name><argument_list>(<argument><expr>&amp;<name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>op</name> = (<name>PyStringObject</name> *)<name>t</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>nullstring</name> = <name>op</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then> <else>else <if>if <condition>(<expr><name>size</name> == 1</expr>)</condition><then> <block>{
		<decl_stmt><decl><type><name>PyObject</name> *</type><name>t</name> <init>= <expr>(<name>PyObject</name> *)<name>op</name></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>PyString_InternInPlace</name><argument_list>(<argument><expr>&amp;<name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>op</name> = (<name>PyStringObject</name> *)<name>t</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>characters</name><index>[<expr>*<name>str</name> &amp; <name>UCHAR_MAX</name></expr>]</index></name> = <name>op</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if></else></if>
	<return>return <expr>(<name>PyObject</name> *) <name>op</name></expr>;</return>
}</block></function>

<function><type><name>PyObject</name> *</type>
<name>PyString_FromFormatV</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>format</name></decl></param>, <param><decl><type><name>va_list</name></type> <name>vargs</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>va_list</name></type> <name>count</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>n</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name>*</type> <name>f</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> *</type><name>s</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name>*</type> <name>string</name></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>VA_LIST_IS_ARRAY</name></cpp:ifdef>
	<expr_stmt><expr><call><name>Py_MEMCPY</name><argument_list>(<argument><expr><name>count</name></expr></argument>, <argument><expr><name>vargs</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>va_list</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive>  <name>__va_copy</name></cpp:ifdef>
	<expr_stmt><expr><call><name>__va_copy</name><argument_list>(<argument><expr><name>count</name></expr></argument>, <argument><expr><name>vargs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<expr_stmt><expr><name>count</name> = <name>vargs</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<comment type="block">/* step 1: figure out how large a buffer we need */</comment>
	<for>for (<init><expr><name>f</name> = <name>format</name></expr>;</init> <condition><expr>*<name>f</name></expr>;</condition> <incr><expr><name>f</name>++</expr></incr>) <block>{
		<if>if <condition>(<expr>*<name>f</name> == '%'</expr>)</condition><then> <block>{
			<decl_stmt><decl><type><specifier>const</specifier> <name>char</name>*</type> <name>p</name> <init>= <expr><name>f</name></expr></init></decl>;</decl_stmt>
			<while>while <condition>(<expr>*++<name>f</name> &amp;&amp; *<name>f</name> != '%' &amp;&amp; !<call><name>isalpha</name><argument_list>(<argument><expr><call><name>Py_CHARMASK</name><argument_list>(<argument><expr>*<name>f</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
				<empty_stmt>;</empty_stmt></while>

			<comment type="block">/* skip the 'l' or 'z' in {%ld, %zd, %lu, %zu} since
			 * they don't affect the amount of space we reserve.
			 */</comment>
			<if>if <condition>(<expr>(*<name>f</name> == 'l' || *<name>f</name> == 'z') &amp;&amp;
					(<name><name>f</name><index>[<expr>1</expr>]</index></name> == 'd' || <name><name>f</name><index>[<expr>1</expr>]</index></name> == 'u')</expr>)</condition><then>
				<expr_stmt><expr>++<name>f</name></expr>;</expr_stmt></then></if>

			<switch>switch <condition>(<expr>*<name>f</name></expr>)</condition> <block>{
			<case>case <expr>'c'</expr>:
				<expr_stmt><expr>(<name>void</name>)<call><name>va_arg</name><argument_list>(<argument><expr><name>count</name></expr></argument>, <argument><expr><name>int</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<comment type="block">/* fall through... */</comment>
			</case><case>case <expr>'%'</expr>:
				<expr_stmt><expr><name>n</name>++</expr>;</expr_stmt>
				<break>break;</break>
			</case><case>case <expr>'d'</expr>: </case><case>case <expr>'u'</expr>: </case><case>case <expr>'i'</expr>: </case><case>case <expr>'x'</expr>:
				<expr_stmt><expr>(<name>void</name>) <call><name>va_arg</name><argument_list>(<argument><expr><name>count</name></expr></argument>, <argument><expr><name>int</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<comment type="block">/* 20 bytes is enough to hold a 64-bit
				   integer.  Decimal takes the most space.
				   This isn't enough for octal. */</comment>
				<expr_stmt><expr><name>n</name> += 20</expr>;</expr_stmt>
				<break>break;</break>
			</case><case>case <expr>'s'</expr>:
				<expr_stmt><expr><name>s</name> = <call><name>va_arg</name><argument_list>(<argument><expr><name>count</name></expr></argument>, <argument><expr><name>char</name>*</expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>n</name> += <call><name>strlen</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			</case><case>case <expr>'p'</expr>:
				<expr_stmt><expr>(<name>void</name>) <call><name>va_arg</name><argument_list>(<argument><expr><name>count</name></expr></argument>, <argument><expr><name>int</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<comment type="block">/* maximum 64-bit pointer representation:
				 * 0xffffffffffffffff
				 * so 19 characters is enough.
				 * XXX I count 18 -- what's the extra for?
				 */</comment>
				<expr_stmt><expr><name>n</name> += 19</expr>;</expr_stmt>
				<break>break;</break>
			</case><default>default:
				<comment type="block">/* if we stumble upon an unknown
				   formatting code, copy the rest of
				   the format string to the output
				   string. (we cannot just skip the
				   code, since there's no way to know
				   what's in the argument list) */</comment>
				<expr_stmt><expr><name>n</name> += <call><name>strlen</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<goto>goto <name>expand</name>;</goto>
			</default>}</block></switch>
		}</block></then> <else>else
			<expr_stmt><expr><name>n</name>++</expr>;</expr_stmt></else></if>
	}</block></for>
 <label><name>expand</name>:</label>
	<comment type="block">/* step 2: fill the buffer */</comment>
	<comment type="block">/* Since we've analyzed how much space we need for the worst case,
	   use sprintf directly instead of the slower PyOS_snprintf. */</comment>
	<expr_stmt><expr><name>string</name> = <call><name>PyString_FromStringAndSize</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr>!<name>string</name></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>

	<expr_stmt><expr><name>s</name> = <call><name>PyString_AsString</name><argument_list>(<argument><expr><name>string</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for (<init><expr><name>f</name> = <name>format</name></expr>;</init> <condition><expr>*<name>f</name></expr>;</condition> <incr><expr><name>f</name>++</expr></incr>) <block>{
		<if>if <condition>(<expr>*<name>f</name> == '%'</expr>)</condition><then> <block>{
			<decl_stmt><decl><type><specifier>const</specifier> <name>char</name>*</type> <name>p</name> <init>= <expr><name>f</name>++</expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>i</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type> <name>longflag</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type> <name>size_tflag</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
			<comment type="block">/* parse the width.precision part (we're only
			   interested in the precision value, if any) */</comment>
			<expr_stmt><expr><name>n</name> = 0</expr>;</expr_stmt>
			<while>while <condition>(<expr><call><name>isdigit</name><argument_list>(<argument><expr><call><name>Py_CHARMASK</name><argument_list>(<argument><expr>*<name>f</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
				<expr_stmt><expr><name>n</name> = (<name>n</name>*10) + *<name>f</name>++ - '0'</expr>;</expr_stmt></while>
			<if>if <condition>(<expr>*<name>f</name> == '.'</expr>)</condition><then> <block>{
				<expr_stmt><expr><name>f</name>++</expr>;</expr_stmt>
				<expr_stmt><expr><name>n</name> = 0</expr>;</expr_stmt>
				<while>while <condition>(<expr><call><name>isdigit</name><argument_list>(<argument><expr><call><name>Py_CHARMASK</name><argument_list>(<argument><expr>*<name>f</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
					<expr_stmt><expr><name>n</name> = (<name>n</name>*10) + *<name>f</name>++ - '0'</expr>;</expr_stmt></while>
			}</block></then></if>
			<while>while <condition>(<expr>*<name>f</name> &amp;&amp; *<name>f</name> != '%' &amp;&amp; !<call><name>isalpha</name><argument_list>(<argument><expr><call><name>Py_CHARMASK</name><argument_list>(<argument><expr>*<name>f</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
				<expr_stmt><expr><name>f</name>++</expr>;</expr_stmt></while>
			<comment type="block">/* handle the long flag, but only for %ld and %lu.
			   others can be added when necessary. */</comment>
			<if>if <condition>(<expr>*<name>f</name> == 'l' &amp;&amp; (<name><name>f</name><index>[<expr>1</expr>]</index></name> == 'd' || <name><name>f</name><index>[<expr>1</expr>]</index></name> == 'u')</expr>)</condition><then> <block>{
				<expr_stmt><expr><name>longflag</name> = 1</expr>;</expr_stmt>
				<expr_stmt><expr>++<name>f</name></expr>;</expr_stmt>
			}</block></then></if>
			<comment type="block">/* handle the size_t flag. */</comment>
			<if>if <condition>(<expr>*<name>f</name> == 'z' &amp;&amp; (<name><name>f</name><index>[<expr>1</expr>]</index></name> == 'd' || <name><name>f</name><index>[<expr>1</expr>]</index></name> == 'u')</expr>)</condition><then> <block>{
				<expr_stmt><expr><name>size_tflag</name> = 1</expr>;</expr_stmt>
				<expr_stmt><expr>++<name>f</name></expr>;</expr_stmt>
			}</block></then></if>

			<switch>switch <condition>(<expr>*<name>f</name></expr>)</condition> <block>{
			<case>case <expr>'c'</expr>:
				<expr_stmt><expr>*<name>s</name>++ = <call><name>va_arg</name><argument_list>(<argument><expr><name>vargs</name></expr></argument>, <argument><expr><name>int</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			</case><case>case <expr>'d'</expr>:
				<if>if <condition>(<expr><name>longflag</name></expr>)</condition><then>
					<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr>"%ld"</expr></argument>, <argument><expr><call><name>va_arg</name><argument_list>(<argument><expr><name>vargs</name></expr></argument>, <argument><expr><name>long</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
				<else>else <if>if <condition>(<expr><name>size_tflag</name></expr>)</condition><then>
					<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr>"%" <name>PY_FORMAT_SIZE_T</name> "d"</expr></argument>,
					        <argument><expr><call><name>va_arg</name><argument_list>(<argument><expr><name>vargs</name></expr></argument>, <argument><expr><name>Py_ssize_t</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
				<else>else
					<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr>"%d"</expr></argument>, <argument><expr><call><name>va_arg</name><argument_list>(<argument><expr><name>vargs</name></expr></argument>, <argument><expr><name>int</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if></else></if>
				<expr_stmt><expr><name>s</name> += <call><name>strlen</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			</case><case>case <expr>'u'</expr>:
				<if>if <condition>(<expr><name>longflag</name></expr>)</condition><then>
					<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr>"%lu"</expr></argument>,
						<argument><expr><macro><name>va_arg</name><argument_list>(<argument>vargs</argument>, <argument>unsigned long</argument>)</argument_list></macro></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
				<else>else <if>if <condition>(<expr><name>size_tflag</name></expr>)</condition><then>
					<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr>"%" <name>PY_FORMAT_SIZE_T</name> "u"</expr></argument>,
					        <argument><expr><call><name>va_arg</name><argument_list>(<argument><expr><name>vargs</name></expr></argument>, <argument><expr><name>size_t</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
				<else>else
					<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr>"%u"</expr></argument>,
						<argument><expr><macro><name>va_arg</name><argument_list>(<argument>vargs</argument>, <argument>unsigned int</argument>)</argument_list></macro></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if></else></if>
				<expr_stmt><expr><name>s</name> += <call><name>strlen</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			</case><case>case <expr>'i'</expr>:
				<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr>"%i"</expr></argument>, <argument><expr><call><name>va_arg</name><argument_list>(<argument><expr><name>vargs</name></expr></argument>, <argument><expr><name>int</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>s</name> += <call><name>strlen</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			</case><case>case <expr>'x'</expr>:
				<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr>"%x"</expr></argument>, <argument><expr><call><name>va_arg</name><argument_list>(<argument><expr><name>vargs</name></expr></argument>, <argument><expr><name>int</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>s</name> += <call><name>strlen</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			</case><case>case <expr>'s'</expr>:
				<expr_stmt><expr><name>p</name> = <call><name>va_arg</name><argument_list>(<argument><expr><name>vargs</name></expr></argument>, <argument><expr><name>char</name>*</expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>i</name> = <call><name>strlen</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if>if <condition>(<expr><name>n</name> &gt; 0 &amp;&amp; <name>i</name> &gt; <name>n</name></expr>)</condition><then>
					<expr_stmt><expr><name>i</name> = <name>n</name></expr>;</expr_stmt></then></if>
				<expr_stmt><expr><call><name>Py_MEMCPY</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>s</name> += <name>i</name></expr>;</expr_stmt>
				<break>break;</break>
			</case><case>case <expr>'p'</expr>:
				<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr>"%p"</expr></argument>, <argument><expr><call><name>va_arg</name><argument_list>(<argument><expr><name>vargs</name></expr></argument>, <argument><expr><name>void</name>*</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<comment type="block">/* %p is ill-defined:  ensure leading 0x. */</comment>
				<if>if <condition>(<expr><name><name>s</name><index>[<expr>1</expr>]</index></name> == 'X'</expr>)</condition><then>
					<expr_stmt><expr><name><name>s</name><index>[<expr>1</expr>]</index></name> = 'x'</expr>;</expr_stmt></then>
				<else>else <if>if <condition>(<expr><name><name>s</name><index>[<expr>1</expr>]</index></name> != 'x'</expr>)</condition><then> <block>{
					<expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><name>s</name>+2</expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call>+1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>s</name><index>[<expr>0</expr>]</index></name> = '0'</expr>;</expr_stmt>
					<expr_stmt><expr><name><name>s</name><index>[<expr>1</expr>]</index></name> = 'x'</expr>;</expr_stmt>
				}</block></then></if></else></if>
				<expr_stmt><expr><name>s</name> += <call><name>strlen</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			</case><case>case <expr>'%'</expr>:
				<expr_stmt><expr>*<name>s</name>++ = '%'</expr>;</expr_stmt>
				<break>break;</break>
			</case><default>default:
				<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>s</name> += <call><name>strlen</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<goto>goto <name>end</name>;</goto>
			</default>}</block></switch>
		}</block></then> <else>else
			<expr_stmt><expr>*<name>s</name>++ = *<name>f</name></expr>;</expr_stmt></else></if>
	}</block></for>

 <label><name>end</name>:</label>
	<expr_stmt><expr><call><name>_PyString_Resize</name><argument_list>(<argument><expr>&amp;<name>string</name></expr></argument>, <argument><expr><name>s</name> - <call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>string</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>string</name></expr>;</return>
}</block></function>

<function><type><name>PyObject</name> *</type>
<name>PyString_FromFormat</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>format</name></decl></param>, <param><decl><type>...</type></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name>*</type> <name>ret</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>va_list</name></type> <name>vargs</name></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_STDARG_PROTOTYPES</name></cpp:ifdef>
	<expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>vargs</name></expr></argument>, <argument><expr><name>format</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>vargs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<expr_stmt><expr><name>ret</name> = <call><name>PyString_FromFormatV</name><argument_list>(<argument><expr><name>format</name></expr></argument>, <argument><expr><name>vargs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>vargs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>ret</name></expr>;</return>
}</block></function>


<function><type><name>PyObject</name> *</type><name>PyString_Decode</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>s</name></decl></param>,
			  <param><decl><type><name>Py_ssize_t</name></type> <name>size</name></decl></param>,
			  <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>encoding</name></decl></param>,
			  <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>errors</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>PyObject</name> *</type><name>v</name></decl>, *<decl><type ref="prev"/><name>str</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>str</name> = <call><name>PyString_FromStringAndSize</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>str</name> == <name>NULL</name></expr>)</condition><then>
	<return>return <expr><name>NULL</name></expr>;</return></then></if>
    <expr_stmt><expr><name>v</name> = <call><name>PyString_AsDecodedString</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>encoding</name></expr></argument>, <argument><expr><name>errors</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>v</name></expr>;</return>
}</block></function>

<function><type><name>PyObject</name> *</type><name>PyString_AsDecodedObject</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>str</name></decl></param>,
				   <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>encoding</name></decl></param>,
				   <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>errors</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>PyObject</name> *</type><name>v</name></decl>;</decl_stmt>

    <if>if <condition>(<expr>!<call><name>PyString_Check</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>PyErr_BadArgument</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <goto>goto <name>onError</name>;</goto>
    }</block></then></if>

    <if>if <condition>(<expr><name>encoding</name> == <name>NULL</name></expr>)</condition><then> <block>{
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>Py_USING_UNICODE</name></cpp:ifdef>
	<expr_stmt><expr><name>encoding</name> = <call><name>PyUnicode_GetDefaultEncoding</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>, <argument><expr>"no encoding specified"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<goto>goto <name>onError</name>;</goto>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    }</block></then></if>

    <comment type="block">/* Decode via the codec registry */</comment>
    <expr_stmt><expr><name>v</name> = <call><name>PyCodec_Decode</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>encoding</name></expr></argument>, <argument><expr><name>errors</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>v</name> == <name>NULL</name></expr>)</condition><then>
        <goto>goto <name>onError</name>;</goto></then></if>

    <return>return <expr><name>v</name></expr>;</return>

 <label><name>onError</name>:</label>
    <return>return <expr><name>NULL</name></expr>;</return>
}</block></function>

<function><type><name>PyObject</name> *</type><name>PyString_AsDecodedString</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>str</name></decl></param>,
				   <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>encoding</name></decl></param>,
				   <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>errors</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>PyObject</name> *</type><name>v</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>v</name> = <call><name>PyString_AsDecodedObject</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>encoding</name></expr></argument>, <argument><expr><name>errors</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>v</name> == <name>NULL</name></expr>)</condition><then>
        <goto>goto <name>onError</name>;</goto></then></if>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>Py_USING_UNICODE</name></cpp:ifdef>
    <comment type="block">/* Convert Unicode to a string using the default encoding */</comment>
    <if>if <condition>(<expr><call><name>PyUnicode_Check</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>temp</name> <init>= <expr><name>v</name></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name>v</name> = <call><name>PyUnicode_AsEncodedString</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>temp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>v</name> == <name>NULL</name></expr>)</condition><then>
	    <goto>goto <name>onError</name>;</goto></then></if>
    }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <if>if <condition>(<expr>!<call><name>PyString_Check</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
                     <argument><expr>"decoder did not return a string object (type=%.400s)"</expr></argument>,
                     <argument><expr><call><name>Py_TYPE</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call>-&gt;<name>tp_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <goto>goto <name>onError</name>;</goto>
    }</block></then></if>

    <return>return <expr><name>v</name></expr>;</return>

 <label><name>onError</name>:</label>
    <return>return <expr><name>NULL</name></expr>;</return>
}</block></function>

<function><type><name>PyObject</name> *</type><name>PyString_Encode</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>s</name></decl></param>,
			  <param><decl><type><name>Py_ssize_t</name></type> <name>size</name></decl></param>,
			  <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>encoding</name></decl></param>,
			  <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>errors</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>PyObject</name> *</type><name>v</name></decl>, *<decl><type ref="prev"/><name>str</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>str</name> = <call><name>PyString_FromStringAndSize</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>str</name> == <name>NULL</name></expr>)</condition><then>
	<return>return <expr><name>NULL</name></expr>;</return></then></if>
    <expr_stmt><expr><name>v</name> = <call><name>PyString_AsEncodedString</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>encoding</name></expr></argument>, <argument><expr><name>errors</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>v</name></expr>;</return>
}</block></function>

<function><type><name>PyObject</name> *</type><name>PyString_AsEncodedObject</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>str</name></decl></param>,
				   <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>encoding</name></decl></param>,
				   <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>errors</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>PyObject</name> *</type><name>v</name></decl>;</decl_stmt>

    <if>if <condition>(<expr>!<call><name>PyString_Check</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>PyErr_BadArgument</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <goto>goto <name>onError</name>;</goto>
    }</block></then></if>

    <if>if <condition>(<expr><name>encoding</name> == <name>NULL</name></expr>)</condition><then> <block>{
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>Py_USING_UNICODE</name></cpp:ifdef>
	<expr_stmt><expr><name>encoding</name> = <call><name>PyUnicode_GetDefaultEncoding</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>, <argument><expr>"no encoding specified"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<goto>goto <name>onError</name>;</goto>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    }</block></then></if>

    <comment type="block">/* Encode via the codec registry */</comment>
    <expr_stmt><expr><name>v</name> = <call><name>PyCodec_Encode</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>encoding</name></expr></argument>, <argument><expr><name>errors</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>v</name> == <name>NULL</name></expr>)</condition><then>
        <goto>goto <name>onError</name>;</goto></then></if>

    <return>return <expr><name>v</name></expr>;</return>

 <label><name>onError</name>:</label>
    <return>return <expr><name>NULL</name></expr>;</return>
}</block></function>

<function><type><name>PyObject</name> *</type><name>PyString_AsEncodedString</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>str</name></decl></param>,
				   <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>encoding</name></decl></param>,
				   <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>errors</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>PyObject</name> *</type><name>v</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>v</name> = <call><name>PyString_AsEncodedObject</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>encoding</name></expr></argument>, <argument><expr><name>errors</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>v</name> == <name>NULL</name></expr>)</condition><then>
        <goto>goto <name>onError</name>;</goto></then></if>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>Py_USING_UNICODE</name></cpp:ifdef>
    <comment type="block">/* Convert Unicode to a string using the default encoding */</comment>
    <if>if <condition>(<expr><call><name>PyUnicode_Check</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>temp</name> <init>= <expr><name>v</name></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name>v</name> = <call><name>PyUnicode_AsEncodedString</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>temp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>v</name> == <name>NULL</name></expr>)</condition><then>
	    <goto>goto <name>onError</name>;</goto></then></if>
    }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <if>if <condition>(<expr>!<call><name>PyString_Check</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
                     <argument><expr>"encoder did not return a string object (type=%.400s)"</expr></argument>,
                     <argument><expr><call><name>Py_TYPE</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call>-&gt;<name>tp_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <goto>goto <name>onError</name>;</goto>
    }</block></then></if>

    <return>return <expr><name>v</name></expr>;</return>

 <label><name>onError</name>:</label>
    <return>return <expr><name>NULL</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>string_dealloc</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>op</name></decl></param>)</parameter_list>
<block>{
	<switch>switch <condition>(<expr><call><name>PyString_CHECK_INTERNED</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{
		<case>case <expr><name>SSTATE_NOT_INTERNED</name></expr>:
			<break>break;</break>

		</case><case>case <expr><name>SSTATE_INTERNED_MORTAL</name></expr>:
			<comment type="block">/* revive dead object temporarily for DelItem */</comment>
			<expr_stmt><expr><call><name>Py_REFCNT</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call> = 3</expr>;</expr_stmt>
			<if>if <condition>(<expr><call><name>PyDict_DelItem</name><argument_list>(<argument><expr><name>interned</name></expr></argument>, <argument><expr><name>op</name></expr></argument>)</argument_list></call> != 0</expr>)</condition><then>
				<expr_stmt><expr><call><name>Py_FatalError</name><argument_list>(
					<argument><expr>"deletion of interned string failed"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
			<break>break;</break>

		</case><case>case <expr><name>SSTATE_INTERNED_IMMORTAL</name></expr>:
			<expr_stmt><expr><call><name>Py_FatalError</name><argument_list>(<argument><expr>"Immortal interned string died."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

		</case><default>default:
			<expr_stmt><expr><call><name>Py_FatalError</name><argument_list>(<argument><expr>"Inconsistent interned string state."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</default>}</block></switch>
	<expr_stmt><expr><call><name>Py_TYPE</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call>-&gt;<call><name>tp_free</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<comment type="block">/* Unescape a backslash-escaped string. If unicode is non-zero,
   the string is a u-literal. If recode_encoding is non-zero,
   the string is UTF-8 encoded and should be re-encoded in the
   specified encoding.  */</comment>

<function><type><name>PyObject</name> *</type><name>PyString_DecodeEscape</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>s</name></decl></param>,
				<param><decl><type><name>Py_ssize_t</name></type> <name>len</name></decl></param>,
				<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>errors</name></decl></param>,
				<param><decl><type><name>Py_ssize_t</name></type> <name>unicode</name></decl></param>,
				<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>recode_encoding</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>int</name></type> <name>c</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> *</type><name>p</name></decl>, *<decl><type ref="prev"/><name>buf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>end</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>v</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>newlen</name> <init>= <expr><name>recode_encoding</name> ? 4*<name>len</name>:<name>len</name></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name>v</name> = <call><name>PyString_FromStringAndSize</name><argument_list>(<argument><expr>(<name>char</name> *)<name>NULL</name></expr></argument>, <argument><expr><name>newlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>v</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<expr_stmt><expr><name>p</name> = <name>buf</name> = <call><name>PyString_AsString</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>end</name> = <name>s</name> + <name>len</name></expr>;</expr_stmt>
	<while>while <condition>(<expr><name>s</name> &lt; <name>end</name></expr>)</condition> <block>{
		<if>if <condition>(<expr>*<name>s</name> != '\\'</expr>)</condition><then> <block>{
		  <label><name>non_esc</name>:</label>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>Py_USING_UNICODE</name></cpp:ifdef>
			<if>if <condition>(<expr><name>recode_encoding</name> &amp;&amp; (*<name>s</name> &amp; 0x80)</expr>)</condition><then> <block>{
				<decl_stmt><decl><type><name>PyObject</name> *</type><name>u</name></decl>, *<decl><type ref="prev"/><name>w</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>char</name> *</type><name>r</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><specifier>const</specifier> <name>char</name>*</type> <name>t</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>rn</name></decl>;</decl_stmt>
				<expr_stmt><expr><name>t</name> = <name>s</name></expr>;</expr_stmt>
				<comment type="block">/* Decode non-ASCII bytes as UTF-8. */</comment>
				<while>while <condition>(<expr><name>t</name> &lt; <name>end</name> &amp;&amp; (*<name>t</name> &amp; 0x80)</expr>)</condition> <expr_stmt><expr><name>t</name>++</expr>;</expr_stmt></while>
				<expr_stmt><expr><name>u</name> = <call><name>PyUnicode_DecodeUTF8</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>t</name> - <name>s</name></expr></argument>, <argument><expr><name>errors</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if>if<condition>(<expr>!<name>u</name></expr>)</condition><then> <goto>goto <name>failed</name>;</goto></then></if>

				<comment type="block">/* Recode them in target encoding. */</comment>
				<expr_stmt><expr><name>w</name> = <call><name>PyUnicode_AsEncodedString</name><argument_list>(
					<argument><expr><name>u</name></expr></argument>, <argument><expr><name>recode_encoding</name></expr></argument>, <argument><expr><name>errors</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>u</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if>if <condition>(<expr>!<name>w</name></expr>)</condition><then>	<goto>goto <name>failed</name>;</goto></then></if>

				<comment type="block">/* Append bytes to output buffer. */</comment>
				<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>PyString_Check</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>r</name> = <call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>rn</name> = <call><name>PyString_GET_SIZE</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>Py_MEMCPY</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><name>rn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>p</name> += <name>rn</name></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>s</name> = <name>t</name></expr>;</expr_stmt>
			}</block></then> <else>else <block>{
				<expr_stmt><expr>*<name>p</name>++ = *<name>s</name>++</expr>;</expr_stmt>
			}</block></else></if>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
			<expr_stmt><expr>*<name>p</name>++ = *<name>s</name>++</expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
			<continue>continue;</continue>
		}</block></then></if>
		<expr_stmt><expr><name>s</name>++</expr>;</expr_stmt>
                <if>if <condition>(<expr><name>s</name>==<name>end</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>,
					<argument><expr>"Trailing \\ in string"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<goto>goto <name>failed</name>;</goto>
		}</block></then></if>
		<switch>switch <condition>(<expr>*<name>s</name>++</expr>)</condition> <block>{
		<comment type="block">/* XXX This assumes ASCII! */</comment>
		<case>case <expr>'\n'</expr>: <break>break;</break>
		</case><case>case <expr>'\\'</expr>: <expr_stmt><expr>*<name>p</name>++ = '\\'</expr>;</expr_stmt> <break>break;</break>
		</case><case>case <expr>'\''</expr>: <expr_stmt><expr>*<name>p</name>++ = '\''</expr>;</expr_stmt> <break>break;</break>
		</case><case>case <expr>'\"'</expr>: <expr_stmt><expr>*<name>p</name>++ = '\"'</expr>;</expr_stmt> <break>break;</break>
		</case><case>case <expr>'b'</expr>: <expr_stmt><expr>*<name>p</name>++ = '\b'</expr>;</expr_stmt> <break>break;</break>
		</case><case>case <expr>'f'</expr>: <expr_stmt><expr>*<name>p</name>++ = '\014'</expr>;</expr_stmt> <break>break;</break> <comment type="block">/* FF */</comment>
		</case><case>case <expr>'t'</expr>: <expr_stmt><expr>*<name>p</name>++ = '\t'</expr>;</expr_stmt> <break>break;</break>
		</case><case>case <expr>'n'</expr>: <expr_stmt><expr>*<name>p</name>++ = '\n'</expr>;</expr_stmt> <break>break;</break>
		</case><case>case <expr>'r'</expr>: <expr_stmt><expr>*<name>p</name>++ = '\r'</expr>;</expr_stmt> <break>break;</break>
		</case><case>case <expr>'v'</expr>: <expr_stmt><expr>*<name>p</name>++ = '\013'</expr>;</expr_stmt> <break>break;</break> <comment type="block">/* VT */</comment>
		</case><case>case <expr>'a'</expr>: <expr_stmt><expr>*<name>p</name>++ = '\007'</expr>;</expr_stmt> <break>break;</break> <comment type="block">/* BEL, not classic C */</comment>
		</case><case>case <expr>'0'</expr>: </case><case>case <expr>'1'</expr>: </case><case>case <expr>'2'</expr>: </case><case>case <expr>'3'</expr>:
		</case><case>case <expr>'4'</expr>: </case><case>case <expr>'5'</expr>: </case><case>case <expr>'6'</expr>: </case><case>case <expr>'7'</expr>:
			<expr_stmt><expr><name>c</name> = <name><name>s</name><index>[<expr>-1</expr>]</index></name> - '0'</expr>;</expr_stmt>
			<if>if <condition>(<expr><name>s</name> &lt; <name>end</name> &amp;&amp; '0' &lt;= *<name>s</name> &amp;&amp; *<name>s</name> &lt;= '7'</expr>)</condition><then> <block>{
				<expr_stmt><expr><name>c</name> = (<name>c</name>&lt;&lt;3) + *<name>s</name>++ - '0'</expr>;</expr_stmt>
				<if>if <condition>(<expr><name>s</name> &lt; <name>end</name> &amp;&amp; '0' &lt;= *<name>s</name> &amp;&amp; *<name>s</name> &lt;= '7'</expr>)</condition><then>
					<expr_stmt><expr><name>c</name> = (<name>c</name>&lt;&lt;3) + *<name>s</name>++ - '0'</expr>;</expr_stmt></then></if>
			}</block></then></if>
			<expr_stmt><expr>*<name>p</name>++ = <name>c</name></expr>;</expr_stmt>
			<break>break;</break>
		</case><case>case <expr>'x'</expr>:
			<if>if <condition>(<expr><name>s</name>+1 &lt; <name>end</name> &amp;&amp;
                            <call><name>isxdigit</name><argument_list>(<argument><expr><call><name>Py_CHARMASK</name><argument_list>(<argument><expr><name><name>s</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> &amp;&amp;
			    <call><name>isxdigit</name><argument_list>(<argument><expr><call><name>Py_CHARMASK</name><argument_list>(<argument><expr><name><name>s</name><index>[<expr>1</expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then>
                        <block>{
				<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>x</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
				<expr_stmt><expr><name>c</name> = <call><name>Py_CHARMASK</name><argument_list>(<argument><expr>*<name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>s</name>++</expr>;</expr_stmt>
				<if>if <condition>(<expr><call><name>isdigit</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>)</condition><then>
					<expr_stmt><expr><name>x</name> = <name>c</name> - '0'</expr>;</expr_stmt></then>
				<else>else <if>if <condition>(<expr><call><name>islower</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>)</condition><then>
					<expr_stmt><expr><name>x</name> = 10 + <name>c</name> - 'a'</expr>;</expr_stmt></then>
				<else>else
					<expr_stmt><expr><name>x</name> = 10 + <name>c</name> - 'A'</expr>;</expr_stmt></else></if></else></if>
				<expr_stmt><expr><name>x</name> = <name>x</name> &lt;&lt; 4</expr>;</expr_stmt>
				<expr_stmt><expr><name>c</name> = <call><name>Py_CHARMASK</name><argument_list>(<argument><expr>*<name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>s</name>++</expr>;</expr_stmt>
				<if>if <condition>(<expr><call><name>isdigit</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>)</condition><then>
					<expr_stmt><expr><name>x</name> += <name>c</name> - '0'</expr>;</expr_stmt></then>
				<else>else <if>if <condition>(<expr><call><name>islower</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>)</condition><then>
					<expr_stmt><expr><name>x</name> += 10 + <name>c</name> - 'a'</expr>;</expr_stmt></then>
				<else>else
					<expr_stmt><expr><name>x</name> += 10 + <name>c</name> - 'A'</expr>;</expr_stmt></else></if></else></if>
				<expr_stmt><expr>*<name>p</name>++ = <name>x</name></expr>;</expr_stmt>
				<break>break;</break>
			}</block></then></if>
			<if>if <condition>(<expr>!<name>errors</name> || <call><name>strcmp</name><argument_list>(<argument><expr><name>errors</name></expr></argument>, <argument><expr>"strict"</expr></argument>)</argument_list></call> == 0</expr>)</condition><then> <block>{
				<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>,
						<argument><expr>"invalid \\x escape"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<goto>goto <name>failed</name>;</goto>
			}</block></then></if>
			<if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>errors</name></expr></argument>, <argument><expr>"replace"</expr></argument>)</argument_list></call> == 0</expr>)</condition><then> <block>{
				<expr_stmt><expr>*<name>p</name>++ = '?'</expr>;</expr_stmt>
			}</block></then> <else>else <if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>errors</name></expr></argument>, <argument><expr>"ignore"</expr></argument>)</argument_list></call> == 0</expr>)</condition><then>
				<comment type="block">/* do nothing */</comment><empty_stmt>;</empty_stmt></then>
			<else>else <block>{
				<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>,
					     <argument><expr>"decoding error; "
					     "unknown error handling code: %.400s"</expr></argument>,
					     <argument><expr><name>errors</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<goto>goto <name>failed</name>;</goto>
			}</block></else></if></else></if>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>Py_USING_UNICODE</name></cpp:ifndef>
		</case><case>case <expr>'u'</expr>:
		</case><case>case <expr>'U'</expr>:
		</case><case>case <expr>'N'</expr>:
			<if>if <condition>(<expr><name>unicode</name></expr>)</condition><then> <block>{
				<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>,
					  <argument><expr>"Unicode escapes not legal "
					  "when Unicode disabled"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<goto>goto <name>failed</name>;</goto>
			}</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		</case><default>default:
			<expr_stmt><expr>*<name>p</name>++ = '\\'</expr>;</expr_stmt>
			<expr_stmt><expr><name>s</name>--</expr>;</expr_stmt>
			<goto>goto <name>non_esc</name>;</goto> <comment type="block">/* an arbitry number of unescaped
					 UTF-8 bytes may follow. */</comment>
		</default>}</block></switch>
	}</block></while>
	<if>if <condition>(<expr><name>p</name>-<name>buf</name> &lt; <name>newlen</name></expr>)</condition><then>
		<expr_stmt><expr><call><name>_PyString_Resize</name><argument_list>(<argument><expr>&amp;<name>v</name></expr></argument>, <argument><expr><name>p</name> - <name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
	<return>return <expr><name>v</name></expr>;</return>
  <label><name>failed</name>:</label>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>NULL</name></expr>;</return>
}</block></function>

<comment type="block">/* -------------------------------------------------------------------- */</comment>
<comment type="block">/* object api */</comment>

<function><type><specifier>static</specifier> <name>Py_ssize_t</name></type>
<name>string_getsize</name><parameter_list>(<param><decl><type><name>register</name> <name>PyObject</name> *</type><name>op</name></decl></param>)</parameter_list>
<block>{
    	<decl_stmt><decl><type><name>char</name> *</type><name>s</name></decl>;</decl_stmt>
    	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>len</name></decl>;</decl_stmt>
	<if>if <condition>(<expr><call><name>PyString_AsStringAndSize</name><argument_list>(<argument><expr><name>op</name></expr></argument>, <argument><expr>&amp;<name>s</name></expr></argument>, <argument><expr>&amp;<name>len</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr>-1</expr>;</return></then></if>
	<return>return <expr><name>len</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <comment type="block">/*const*/</comment> <name>char</name> *</type>
<name>string_getbuffer</name><parameter_list>(<param><decl><type><name>register</name> <name>PyObject</name> *</type><name>op</name></decl></param>)</parameter_list>
<block>{
    	<decl_stmt><decl><type><name>char</name> *</type><name>s</name></decl>;</decl_stmt>
    	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>len</name></decl>;</decl_stmt>
	<if>if <condition>(<expr><call><name>PyString_AsStringAndSize</name><argument_list>(<argument><expr><name>op</name></expr></argument>, <argument><expr>&amp;<name>s</name></expr></argument>, <argument><expr>&amp;<name>len</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<return>return <expr><name>s</name></expr>;</return>
}</block></function>

<function><type><name>Py_ssize_t</name></type>
<name>PyString_Size</name><parameter_list>(<param><decl><type><name>register</name> <name>PyObject</name> *</type><name>op</name></decl></param>)</parameter_list>
<block>{
	<if>if <condition>(<expr>!<call><name>PyString_Check</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><call><name>string_getsize</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
	<return>return <expr><call><name>Py_SIZE</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<comment type="block">/*const*/</comment> <function><type><name>char</name> *</type>
<name>PyString_AsString</name><parameter_list>(<param><decl><type><name>register</name> <name>PyObject</name> *</type><name>op</name></decl></param>)</parameter_list>
<block>{
	<if>if <condition>(<expr>!<call><name>PyString_Check</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><call><name>string_getbuffer</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
	<return>return <expr>((<name>PyStringObject</name> *)<name>op</name>) -&gt; <name>ob_sval</name></expr>;</return>
}</block></function>

<function><type><name>int</name></type>
<name>PyString_AsStringAndSize</name><parameter_list>(<param><decl><type><name>register</name> <name>PyObject</name> *</type><name>obj</name></decl></param>,
			 <param><decl><type><name>register</name> <name>char</name> **</type><name>s</name></decl></param>,
			 <param><decl><type><name>register</name> <name>Py_ssize_t</name> *</type><name>len</name></decl></param>)</parameter_list>
<block>{
	<if>if <condition>(<expr><name>s</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_BadInternalCall</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>-1</expr>;</return>
	}</block></then></if>

	<if>if <condition>(<expr>!<call><name>PyString_Check</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>Py_USING_UNICODE</name></cpp:ifdef>
		<if>if <condition>(<expr><call><name>PyUnicode_Check</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
			<expr_stmt><expr><name>obj</name> = <call><name>_PyUnicode_AsDefaultEncodedString</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><name>obj</name> == <name>NULL</name></expr>)</condition><then>
				<return>return <expr>-1</expr>;</return></then></if>
		}</block></then>
		<else>else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		<block>{
			<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
				     <argument><expr>"expected string or Unicode object, "
				     "%.200s found"</expr></argument>, <argument><expr><call><name>Py_TYPE</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call>-&gt;<name>tp_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr>-1</expr>;</return>
		}</block></else></if>
	}</block></then></if>

	<expr_stmt><expr>*<name>s</name> = <call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>len</name> != <name>NULL</name></expr>)</condition><then>
		<expr_stmt><expr>*<name>len</name> = <call><name>PyString_GET_SIZE</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
	<else>else <if>if <condition>(<expr><call><name>strlen</name><argument_list>(<argument><expr>*<name>s</name></expr></argument>)</argument_list></call> != (<name>size_t</name>)<call><name>PyString_GET_SIZE</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
				<argument><expr>"expected string without null bytes"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>-1</expr>;</return>
	}</block></then></if></else></if>
	<return>return <expr>0</expr>;</return>
}</block></function>

<comment type="block">/* -------------------------------------------------------------------- */</comment>
<comment type="block">/* Methods */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"stringlib/stringdefs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"stringlib/fastsearch.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"stringlib/count.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"stringlib/find.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"stringlib/partition.h"</cpp:file></cpp:include>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>_Py_InsertThousandsGrouping</name></cpp:macro> <cpp:value>_PyString_InsertThousandsGrouping</cpp:value></cpp:define>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"stringlib/localeutil.h"</cpp:file></cpp:include>



<function><type><specifier>static</specifier> <name>int</name></type>
<name>string_print</name><parameter_list>(<param><decl><type><name>PyStringObject</name> *</type><name>op</name></decl></param>, <param><decl><type><name>FILE</name> *</type><name>fp</name></decl></param>, <param><decl><type><name>int</name></type> <name>flags</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>str_len</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type> <name>c</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>quote</name></decl>;</decl_stmt>

	<comment type="block">/* XXX Ought to check for interrupts when writing long strings */</comment>
	<if>if <condition>(<expr>! <call><name>PyString_CheckExact</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>
		<comment type="block">/* A str subclass may have its own __str__ method. */</comment>
		<expr_stmt><expr><name>op</name> = (<name>PyStringObject</name> *) <call><name>PyObject_Str</name><argument_list>(<argument><expr>(<name>PyObject</name> *)<name>op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>op</name> == <name>NULL</name></expr>)</condition><then>
			<return>return <expr>-1</expr>;</return></then></if>
		<expr_stmt><expr><name>ret</name> = <call><name>string_print</name><argument_list>(<argument><expr><name>op</name></expr></argument>, <argument><expr><name>fp</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>ret</name></expr>;</return>
	}</block></then></if>
	<if>if <condition>(<expr><name>flags</name> &amp; <name>Py_PRINT_RAW</name></expr>)</condition><then> <block>{
		<decl_stmt><decl><type><name>char</name> *</type><name>data</name> <init>= <expr><name><name>op</name>-&gt;<name>ob_sval</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>size</name> <init>= <expr><call><name>Py_SIZE</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<macro><name>Py_BEGIN_ALLOW_THREADS</name></macro>
		<while>while <condition>(<expr><name>size</name> &gt; <name>INT_MAX</name></expr>)</condition> <block>{
			<comment type="block">/* Very long strings cannot be written atomically.
			 * But don't write exactly INT_MAX bytes at a time
			 * to avoid memory aligment issues.
			 */</comment>
			<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>chunk_size</name> <init>= <expr><name>INT_MAX</name> &amp; ~0x3FFF</expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><call><name>fwrite</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr>1</expr></argument>, <argument><expr><name>chunk_size</name></expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>data</name> += <name>chunk_size</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>size</name> -= <name>chunk_size</name></expr>;</expr_stmt>
		}</block></while>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__VMS</name></cpp:ifdef>
                <if>if <condition>(<expr><name>size</name></expr>)</condition><then> <expr_stmt><expr><call><name>fwrite</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr>(<name>int</name>)<name>size</name></expr></argument>, <argument><expr>1</expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
                <expr_stmt><expr><call><name>fwrite</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr>1</expr></argument>, <argument><expr>(<name>int</name>)<name>size</name></expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		<macro><name>Py_END_ALLOW_THREADS</name></macro>
		<return>return <expr>0</expr>;</return>
	}</block></then></if>

	<comment type="block">/* figure out which quote to use; single is preferred */</comment>
	<expr_stmt><expr><name>quote</name> = '\''</expr>;</expr_stmt>
	<if>if <condition>(<expr><call><name>memchr</name><argument_list>(<argument><expr><name><name>op</name>-&gt;<name>ob_sval</name></name></expr></argument>, <argument><expr>'\''</expr></argument>, <argument><expr><call><name>Py_SIZE</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> &amp;&amp;
	    !<call><name>memchr</name><argument_list>(<argument><expr><name><name>op</name>-&gt;<name>ob_sval</name></name></expr></argument>, <argument><expr>'"'</expr></argument>, <argument><expr><call><name>Py_SIZE</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then>
		<expr_stmt><expr><name>quote</name> = '"'</expr>;</expr_stmt></then></if>

	<expr_stmt><expr><name>str_len</name> = <call><name>Py_SIZE</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<function_decl><type><name>Py_BEGIN_ALLOW_THREADS</name></type>
	<name>fputc</name><parameter_list>(<param><decl><type><name>quote</name></type></decl></param>, <param><decl><type><name>fp</name></type></decl></param>)</parameter_list>;</function_decl>
	<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>str_len</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
		<comment type="block">/* Since strings are immutable and the caller should have a
		reference, accessing the interal buffer should not be an issue
		with the GIL released. */</comment>
		<expr_stmt><expr><name>c</name> = <name><name>op</name>-&gt;<name>ob_sval</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>c</name> == <name>quote</name> || <name>c</name> == '\\'</expr>)</condition><then>
			<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr>"\\%c"</expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
                <else>else <if>if <condition>(<expr><name>c</name> == '\t'</expr>)</condition><then>
                        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr>"\\t"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
                <else>else <if>if <condition>(<expr><name>c</name> == '\n'</expr>)</condition><then>
                        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr>"\\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
                <else>else <if>if <condition>(<expr><name>c</name> == '\r'</expr>)</condition><then>
                        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr>"\\r"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
		<else>else <if>if <condition>(<expr><name>c</name> &lt; ' ' || <name>c</name> &gt;= 0x7f</expr>)</condition><then>
			<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr>"\\x%02x"</expr></argument>, <argument><expr><name>c</name> &amp; 0xff</expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
		<else>else
			<expr_stmt><expr><call><name>fputc</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if></else></if></else></if></else></if></else></if>
	}</block></for>
	<expr_stmt><expr><call><name>fputc</name><argument_list>(<argument><expr><name>quote</name></expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<macro><name>Py_END_ALLOW_THREADS</name></macro>
	<return>return <expr>0</expr>;</return>
}</block></function>

<function><type><name>PyObject</name> *</type>
<name>PyString_Repr</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>obj</name></decl></param>, <param><decl><type><name>int</name></type> <name>smartquotes</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>register</name> <name>PyStringObject</name>*</type> <name>op</name> <init>= <expr>(<name>PyStringObject</name>*) <name>obj</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>size_t</name></type> <name>newsize</name> <init>= <expr>2 + 4 * <call><name>Py_SIZE</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>v</name></decl>;</decl_stmt>
	<if>if <condition>(<expr><name>newsize</name> &gt; <name>PY_SSIZE_T_MAX</name> || <name>newsize</name> / 4 != <call><name>Py_SIZE</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_OverflowError</name></expr></argument>,
			<argument><expr>"string is too large to make repr"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>
	<expr_stmt><expr><name>v</name> = <call><name>PyString_FromStringAndSize</name><argument_list>(<argument><expr>(<name>char</name> *)<name>NULL</name></expr></argument>, <argument><expr><name>newsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>v</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then>
	<else>else <block>{
		<decl_stmt><decl><type><name>register</name> <name>Py_ssize_t</name></type> <name>i</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>register</name> <name>char</name></type> <name>c</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>register</name> <name>char</name> *</type><name>p</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>quote</name></decl>;</decl_stmt>

		<comment type="block">/* figure out which quote to use; single is preferred */</comment>
		<expr_stmt><expr><name>quote</name> = '\''</expr>;</expr_stmt>
		<if>if <condition>(<expr><name>smartquotes</name> &amp;&amp;
		    <call><name>memchr</name><argument_list>(<argument><expr><name><name>op</name>-&gt;<name>ob_sval</name></name></expr></argument>, <argument><expr>'\''</expr></argument>, <argument><expr><call><name>Py_SIZE</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> &amp;&amp;
		    !<call><name>memchr</name><argument_list>(<argument><expr><name><name>op</name>-&gt;<name>ob_sval</name></name></expr></argument>, <argument><expr>'"'</expr></argument>, <argument><expr><call><name>Py_SIZE</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then>
			<expr_stmt><expr><name>quote</name> = '"'</expr>;</expr_stmt></then></if>

		<expr_stmt><expr><name>p</name> = <call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr>*<name>p</name>++ = <name>quote</name></expr>;</expr_stmt>
		<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <call><name>Py_SIZE</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
			<comment type="block">/* There's at least enough room for a hex escape
			   and a closing quote. */</comment>
			<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>newsize</name> - (<name>p</name> - <call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call>) &gt;= 5</expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>c</name> = <name><name>op</name>-&gt;<name>ob_sval</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
			<if>if <condition>(<expr><name>c</name> == <name>quote</name> || <name>c</name> == '\\'</expr>)</condition><then>
				<expr_stmt><expr>*<name>p</name>++ = '\\'</expr>, <expr>*<name>p</name>++ = <name>c</name></expr>;</expr_stmt></then>
			<else>else <if>if <condition>(<expr><name>c</name> == '\t'</expr>)</condition><then>
				<expr_stmt><expr>*<name>p</name>++ = '\\'</expr>, <expr>*<name>p</name>++ = 't'</expr>;</expr_stmt></then>
			<else>else <if>if <condition>(<expr><name>c</name> == '\n'</expr>)</condition><then>
				<expr_stmt><expr>*<name>p</name>++ = '\\'</expr>, <expr>*<name>p</name>++ = 'n'</expr>;</expr_stmt></then>
			<else>else <if>if <condition>(<expr><name>c</name> == '\r'</expr>)</condition><then>
				<expr_stmt><expr>*<name>p</name>++ = '\\'</expr>, <expr>*<name>p</name>++ = 'r'</expr>;</expr_stmt></then>
			<else>else <if>if <condition>(<expr><name>c</name> &lt; ' ' || <name>c</name> &gt;= 0x7f</expr>)</condition><then> <block>{
				<comment type="block">/* For performance, we don't want to call
				   PyOS_snprintf here (extra layers of
				   function call). */</comment>
				<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr>"\\x%02x"</expr></argument>, <argument><expr><name>c</name> &amp; 0xff</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                <expr_stmt><expr><name>p</name> += 4</expr>;</expr_stmt>
			}</block></then>
			<else>else
				<expr_stmt><expr>*<name>p</name>++ = <name>c</name></expr>;</expr_stmt></else></if></else></if></else></if></else></if></else></if>
		}</block></for>
		<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>newsize</name> - (<name>p</name> - <call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call>) &gt;= 1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr>*<name>p</name>++ = <name>quote</name></expr>;</expr_stmt>
		<expr_stmt><expr>*<name>p</name> = '\0'</expr>;</expr_stmt>
		<expr_stmt><expr><call><name>_PyString_Resize</name><argument_list>(
			<argument><expr>&amp;<name>v</name></expr></argument>, <argument><expr>(<name>p</name> - <call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>v</name></expr>;</return>
	}</block></else></if>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>string_repr</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>op</name></decl></param>)</parameter_list>
<block>{
	<return>return <expr><call><name>PyString_Repr</name><argument_list>(<argument><expr><name>op</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>string_str</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>s</name></decl></param>)</parameter_list>
<block>{
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>PyString_Check</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><call><name>PyString_CheckExact</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>s</name></expr>;</return>
	}</block></then>
	<else>else <block>{
		<comment type="block">/* Subtype -- return genuine string with the same value. */</comment>
		<decl_stmt><decl><type><name>PyStringObject</name> *</type><name>t</name> <init>= <expr>(<name>PyStringObject</name> *) <name>s</name></expr></init></decl>;</decl_stmt>
		<return>return <expr><call><name>PyString_FromStringAndSize</name><argument_list>(<argument><expr><name><name>t</name>-&gt;<name>ob_sval</name></name></expr></argument>, <argument><expr><call><name>Py_SIZE</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
	}</block></else></if>
}</block></function>

<function><type><specifier>static</specifier> <name>Py_ssize_t</name></type>
<name>string_length</name><parameter_list>(<param><decl><type><name>PyStringObject</name> *</type><name>a</name></decl></param>)</parameter_list>
<block>{
	<return>return <expr><call><name>Py_SIZE</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>string_concat</name><parameter_list>(<param><decl><type><name>register</name> <name>PyStringObject</name> *</type><name>a</name></decl></param>, <param><decl><type><name>register</name> <name>PyObject</name> *</type><name>bb</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>register</name> <name>Py_ssize_t</name></type> <name>size</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>register</name> <name>PyStringObject</name> *</type><name>op</name></decl>;</decl_stmt>
	<if>if <condition>(<expr>!<call><name>PyString_Check</name><argument_list>(<argument><expr><name>bb</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>Py_USING_UNICODE</name></cpp:ifdef>
		<if>if <condition>(<expr><call><name>PyUnicode_Check</name><argument_list>(<argument><expr><name>bb</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		    <return>return <expr><call><name>PyUnicode_Concat</name><argument_list>(<argument><expr>(<name>PyObject</name> *)<name>a</name></expr></argument>, <argument><expr><name>bb</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		<if>if <condition>(<expr><call><name>PyByteArray_Check</name><argument_list>(<argument><expr><name>bb</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		    <return>return <expr><call><name>PyByteArray_Concat</name><argument_list>(<argument><expr>(<name>PyObject</name> *)<name>a</name></expr></argument>, <argument><expr><name>bb</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
		<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
			     <argument><expr>"cannot concatenate 'str' and '%.200s' objects"</expr></argument>,
			     <argument><expr><call><name>Py_TYPE</name><argument_list>(<argument><expr><name>bb</name></expr></argument>)</argument_list></call>-&gt;<name>tp_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>b</name></cpp:macro> <cpp:value>((PyStringObject *)bb)</cpp:value></cpp:define>
	<comment type="block">/* Optimize cases with empty left or right operand */</comment>
	<if>if <condition>(<expr>(<call><name>Py_SIZE</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call> == 0 || <call><name>Py_SIZE</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call> == 0) &amp;&amp;
	    <call><name>PyString_CheckExact</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call> &amp;&amp; <call><name>PyString_CheckExact</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<if>if <condition>(<expr><call><name>Py_SIZE</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call> == 0</expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>bb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>bb</name></expr>;</return>
		}</block></then></if>
		<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>(<name>PyObject</name> *)<name>a</name></expr>;</return>
	}</block></then></if>
	<expr_stmt><expr><name>size</name> = <call><name>Py_SIZE</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call> + <call><name>Py_SIZE</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Check that string sizes are not negative, to prevent an
	   overflow in cases where we are passed incorrectly-created
	   strings with negative lengths (due to a bug in other code).
        */</comment>
	<if>if <condition>(<expr><call><name>Py_SIZE</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call> &lt; 0 || <call><name>Py_SIZE</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call> &lt; 0 ||
	    <call><name>Py_SIZE</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call> &gt; <name>PY_SSIZE_T_MAX</name> - <call><name>Py_SIZE</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_OverflowError</name></expr></argument>,
				<argument><expr>"strings are too large to concat"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>
	  
	<comment type="block">/* Inline PyObject_NewVar */</comment>
	<if>if <condition>(<expr><name>size</name> &gt; <name>PY_SSIZE_T_MAX</name> - <sizeof>sizeof<argument_list>(<argument><expr><name>PyStringObject</name></expr></argument>)</argument_list></sizeof></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_OverflowError</name></expr></argument>,
				<argument><expr>"strings are too large to concat"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>
	<expr_stmt><expr><name>op</name> = (<name>PyStringObject</name> *)<call><name>PyObject_MALLOC</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PyStringObject</name></expr></argument>)</argument_list></sizeof> + <name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>op</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr><call><name>PyErr_NoMemory</name><argument_list>()</argument_list></call></expr>;</return></then></if>
	<expr_stmt><expr><call><name>PyObject_INIT_VAR</name><argument_list>(<argument><expr><name>op</name></expr></argument>, <argument><expr>&amp;<name>PyString_Type</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>op</name>-&gt;<name>ob_shash</name></name> = -1</expr>;</expr_stmt>
	<expr_stmt><expr><name><name>op</name>-&gt;<name>ob_sstate</name></name> = <name>SSTATE_NOT_INTERNED</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_MEMCPY</name><argument_list>(<argument><expr><name><name>op</name>-&gt;<name>ob_sval</name></name></expr></argument>, <argument><expr><name><name>a</name>-&gt;<name>ob_sval</name></name></expr></argument>, <argument><expr><call><name>Py_SIZE</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_MEMCPY</name><argument_list>(<argument><expr><name><name>op</name>-&gt;<name>ob_sval</name></name> + <call><name>Py_SIZE</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>b</name>-&gt;<name>ob_sval</name></name></expr></argument>, <argument><expr><call><name>Py_SIZE</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>op</name>-&gt;<name>ob_sval</name><index>[<expr><name>size</name></expr>]</index></name> = '\0'</expr>;</expr_stmt>
	<return>return <expr>(<name>PyObject</name> *) <name>op</name></expr>;</return>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>b</name></cpp:undef>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>string_repeat</name><parameter_list>(<param><decl><type><name>register</name> <name>PyStringObject</name> *</type><name>a</name></decl></param>, <param><decl><type><name>register</name> <name>Py_ssize_t</name></type> <name>n</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>register</name> <name>Py_ssize_t</name></type> <name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>register</name> <name>Py_ssize_t</name></type> <name>j</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>register</name> <name>Py_ssize_t</name></type> <name>size</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>register</name> <name>PyStringObject</name> *</type><name>op</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>size_t</name></type> <name>nbytes</name></decl>;</decl_stmt>
	<if>if <condition>(<expr><name>n</name> &lt; 0</expr>)</condition><then>
		<expr_stmt><expr><name>n</name> = 0</expr>;</expr_stmt></then></if>
	<comment type="block">/* watch out for overflows:  the size can overflow int,
	 * and the # of bytes needed can overflow size_t
	 */</comment>
	<expr_stmt><expr><name>size</name> = <call><name>Py_SIZE</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call> * <name>n</name></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>n</name> &amp;&amp; <name>size</name> / <name>n</name> != <call><name>Py_SIZE</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_OverflowError</name></expr></argument>,
			<argument><expr>"repeated string is too long"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>
	<if>if <condition>(<expr><name>size</name> == <call><name>Py_SIZE</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call> &amp;&amp; <call><name>PyString_CheckExact</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>(<name>PyObject</name> *)<name>a</name></expr>;</return>
	}</block></then></if>
	<expr_stmt><expr><name>nbytes</name> = (<name>size_t</name>)<name>size</name></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>nbytes</name> + <sizeof>sizeof<argument_list>(<argument><expr><name>PyStringObject</name></expr></argument>)</argument_list></sizeof> &lt;= <name>nbytes</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_OverflowError</name></expr></argument>,
			<argument><expr>"repeated string is too long"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>
	<expr_stmt><expr><name>op</name> = (<name>PyStringObject</name> *)
		<call><name>PyObject_MALLOC</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PyStringObject</name></expr></argument>)</argument_list></sizeof> + <name>nbytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>op</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr><call><name>PyErr_NoMemory</name><argument_list>()</argument_list></call></expr>;</return></then></if>
	<expr_stmt><expr><call><name>PyObject_INIT_VAR</name><argument_list>(<argument><expr><name>op</name></expr></argument>, <argument><expr>&amp;<name>PyString_Type</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>op</name>-&gt;<name>ob_shash</name></name> = -1</expr>;</expr_stmt>
	<expr_stmt><expr><name><name>op</name>-&gt;<name>ob_sstate</name></name> = <name>SSTATE_NOT_INTERNED</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>op</name>-&gt;<name>ob_sval</name><index>[<expr><name>size</name></expr>]</index></name> = '\0'</expr>;</expr_stmt>
	<if>if <condition>(<expr><call><name>Py_SIZE</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call> == 1 &amp;&amp; <name>n</name> &gt; 0</expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>op</name>-&gt;<name>ob_sval</name></name></expr></argument>, <argument><expr><name><name>a</name>-&gt;<name>ob_sval</name><index>[<expr>0</expr>]</index></name></expr></argument> , <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>(<name>PyObject</name> *) <name>op</name></expr>;</return>
	}</block></then></if>
	<expr_stmt><expr><name>i</name> = 0</expr>;</expr_stmt>
	<if>if <condition>(<expr><name>i</name> &lt; <name>size</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>Py_MEMCPY</name><argument_list>(<argument><expr><name><name>op</name>-&gt;<name>ob_sval</name></name></expr></argument>, <argument><expr><name><name>a</name>-&gt;<name>ob_sval</name></name></expr></argument>, <argument><expr><call><name>Py_SIZE</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>i</name> = <call><name>Py_SIZE</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>
	<while>while <condition>(<expr><name>i</name> &lt; <name>size</name></expr>)</condition> <block>{
		<expr_stmt><expr><name>j</name> = (<name>i</name> &lt;= <name>size</name>-<name>i</name>)  ?  <name>i</name>  :  <name>size</name>-<name>i</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_MEMCPY</name><argument_list>(<argument><expr><name><name>op</name>-&gt;<name>ob_sval</name></name>+<name>i</name></expr></argument>, <argument><expr><name><name>op</name>-&gt;<name>ob_sval</name></name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>i</name> += <name>j</name></expr>;</expr_stmt>
	}</block></while>
	<return>return <expr>(<name>PyObject</name> *) <name>op</name></expr>;</return>
}</block></function>

<comment type="block">/* String slice a[i:j] consists of characters a[i] ... a[j-1] */</comment>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>string_slice</name><parameter_list>(<param><decl><type><name>register</name> <name>PyStringObject</name> *</type><name>a</name></decl></param>, <param><decl><type><name>register</name> <name>Py_ssize_t</name></type> <name>i</name></decl></param>,
	     <param><decl><type><name>register</name> <name>Py_ssize_t</name></type> <name>j</name></decl></param>)</parameter_list>
     <comment type="block">/* j -- may be negative! */</comment>
<block>{
	<if>if <condition>(<expr><name>i</name> &lt; 0</expr>)</condition><then>
		<expr_stmt><expr><name>i</name> = 0</expr>;</expr_stmt></then></if>
	<if>if <condition>(<expr><name>j</name> &lt; 0</expr>)</condition><then>
		<expr_stmt><expr><name>j</name> = 0</expr>;</expr_stmt></then></if> <comment type="block">/* Avoid signed/unsigned bug in next line */</comment>
	<if>if <condition>(<expr><name>j</name> &gt; <call><name>Py_SIZE</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<expr_stmt><expr><name>j</name> = <call><name>Py_SIZE</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
	<if>if <condition>(<expr><name>i</name> == 0 &amp;&amp; <name>j</name> == <call><name>Py_SIZE</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call> &amp;&amp; <call><name>PyString_CheckExact</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<comment type="block">/* It's the same as a */</comment>
		<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>(<name>PyObject</name> *)<name>a</name></expr>;</return>
	}</block></then></if>
	<if>if <condition>(<expr><name>j</name> &lt; <name>i</name></expr>)</condition><then>
		<expr_stmt><expr><name>j</name> = <name>i</name></expr>;</expr_stmt></then></if>
	<return>return <expr><call><name>PyString_FromStringAndSize</name><argument_list>(<argument><expr><name><name>a</name>-&gt;<name>ob_sval</name></name> + <name>i</name></expr></argument>, <argument><expr><name>j</name>-<name>i</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>string_contains</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>str_obj</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>sub_obj</name></decl></param>)</parameter_list>
<block>{
	<if>if <condition>(<expr>!<call><name>PyString_CheckExact</name><argument_list>(<argument><expr><name>sub_obj</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>Py_USING_UNICODE</name></cpp:ifdef>
		<if>if <condition>(<expr><call><name>PyUnicode_Check</name><argument_list>(<argument><expr><name>sub_obj</name></expr></argument>)</argument_list></call></expr>)</condition><then>
			<return>return <expr><call><name>PyUnicode_Contains</name><argument_list>(<argument><expr><name>str_obj</name></expr></argument>, <argument><expr><name>sub_obj</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		<if>if <condition>(<expr>!<call><name>PyString_Check</name><argument_list>(<argument><expr><name>sub_obj</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
			    <argument><expr>"'in &lt;string&gt;' requires string as left operand, "
			    "not %.200s"</expr></argument>, <argument><expr><call><name>Py_TYPE</name><argument_list>(<argument><expr><name>sub_obj</name></expr></argument>)</argument_list></call>-&gt;<name>tp_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr>-1</expr>;</return>
		}</block></then></if>
	}</block></then></if>

	<return>return <expr><call><name>stringlib_contains_obj</name><argument_list>(<argument><expr><name>str_obj</name></expr></argument>, <argument><expr><name>sub_obj</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>string_item</name><parameter_list>(<param><decl><type><name>PyStringObject</name> *</type><name>a</name></decl></param>, <param><decl><type><name>register</name> <name>Py_ssize_t</name></type> <name>i</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>char</name></type> <name>pchar</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>v</name></decl>;</decl_stmt>
	<if>if <condition>(<expr><name>i</name> &lt; 0 || <name>i</name> &gt;= <call><name>Py_SIZE</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_IndexError</name></expr></argument>, <argument><expr>"string index out of range"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>
	<expr_stmt><expr><name>pchar</name> = <name><name>a</name>-&gt;<name>ob_sval</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>v</name> = (<name>PyObject</name> *)<name><name>characters</name><index>[<expr><name>pchar</name> &amp; <name>UCHAR_MAX</name></expr>]</index></name></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>v</name> == <name>NULL</name></expr>)</condition><then>
		<expr_stmt><expr><name>v</name> = <call><name>PyString_FromStringAndSize</name><argument_list>(<argument><expr>&amp;<name>pchar</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
	<else>else <block>{
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>COUNT_ALLOCS</name></cpp:ifdef>
		<expr_stmt><expr><name>one_strings</name>++</expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></else></if>
	<return>return <expr><name>v</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name>*</type>
<name>string_richcompare</name><parameter_list>(<param><decl><type><name>PyStringObject</name> *</type><name>a</name></decl></param>, <param><decl><type><name>PyStringObject</name> *</type><name>b</name></decl></param>, <param><decl><type><name>int</name></type> <name>op</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>int</name></type> <name>c</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>len_a</name></decl>, <decl><type ref="prev"/><name>len_b</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>min_len</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>result</name></decl>;</decl_stmt>

	<comment type="block">/* Make sure both arguments are strings. */</comment>
	<if>if <condition>(<expr>!(<call><name>PyString_Check</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call> &amp;&amp; <call><name>PyString_Check</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call>)</expr>)</condition><then> <block>{
		<expr_stmt><expr><name>result</name> = <name>Py_NotImplemented</name></expr>;</expr_stmt>
		<goto>goto <name>out</name>;</goto>
	}</block></then></if>
	<if>if <condition>(<expr><name>a</name> == <name>b</name></expr>)</condition><then> <block>{
		<switch>switch <condition>(<expr><name>op</name></expr>)</condition> <block>{
		<case>case <expr><name>Py_EQ</name></expr>:</case><case>case <expr><name>Py_LE</name></expr>:</case><case>case <expr><name>Py_GE</name></expr>:
			<expr_stmt><expr><name>result</name> = <name>Py_True</name></expr>;</expr_stmt>
			<goto>goto <name>out</name>;</goto>
		</case><case>case <expr><name>Py_NE</name></expr>:</case><case>case <expr><name>Py_LT</name></expr>:</case><case>case <expr><name>Py_GT</name></expr>:
			<expr_stmt><expr><name>result</name> = <name>Py_False</name></expr>;</expr_stmt>
			<goto>goto <name>out</name>;</goto>
		</case>}</block></switch>
	}</block></then></if>
	<if>if <condition>(<expr><name>op</name> == <name>Py_EQ</name></expr>)</condition><then> <block>{
		<comment type="block">/* Supporting Py_NE here as well does not save
		   much time, since Py_NE is rarely used.  */</comment>
		<if>if <condition>(<expr><call><name>Py_SIZE</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call> == <call><name>Py_SIZE</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call>
		    &amp;&amp; (<name><name>a</name>-&gt;<name>ob_sval</name><index>[<expr>0</expr>]</index></name> == <name><name>b</name>-&gt;<name>ob_sval</name><index>[<expr>0</expr>]</index></name>
			&amp;&amp; <call><name>memcmp</name><argument_list>(<argument><expr><name><name>a</name>-&gt;<name>ob_sval</name></name></expr></argument>, <argument><expr><name><name>b</name>-&gt;<name>ob_sval</name></name></expr></argument>, <argument><expr><call><name>Py_SIZE</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> == 0)</expr>)</condition><then> <block>{
			<expr_stmt><expr><name>result</name> = <name>Py_True</name></expr>;</expr_stmt>
		}</block></then> <else>else <block>{
			<expr_stmt><expr><name>result</name> = <name>Py_False</name></expr>;</expr_stmt>
		}</block></else></if>
		<goto>goto <name>out</name>;</goto>
	}</block></then></if>
	<expr_stmt><expr><name>len_a</name> = <call><name>Py_SIZE</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><name>len_b</name> = <call><name>Py_SIZE</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>min_len</name> = (<name>len_a</name> &lt; <name>len_b</name>) ? <name>len_a</name> : <name>len_b</name></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>min_len</name> &gt; 0</expr>)</condition><then> <block>{
		<expr_stmt><expr><name>c</name> = <call><name>Py_CHARMASK</name><argument_list>(<argument><expr>*<name><name>a</name>-&gt;<name>ob_sval</name></name></expr></argument>)</argument_list></call> - <call><name>Py_CHARMASK</name><argument_list>(<argument><expr>*<name><name>b</name>-&gt;<name>ob_sval</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>c</name>==0</expr>)</condition><then>
			<expr_stmt><expr><name>c</name> = <call><name>memcmp</name><argument_list>(<argument><expr><name><name>a</name>-&gt;<name>ob_sval</name></name></expr></argument>, <argument><expr><name><name>b</name>-&gt;<name>ob_sval</name></name></expr></argument>, <argument><expr><name>min_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
	}</block></then> <else>else
		<expr_stmt><expr><name>c</name> = 0</expr>;</expr_stmt></else></if>
	<if>if <condition>(<expr><name>c</name> == 0</expr>)</condition><then>
		<expr_stmt><expr><name>c</name> = (<name>len_a</name> &lt; <name>len_b</name>) ? -1 : (<name>len_a</name> &gt; <name>len_b</name>) ? 1 : 0</expr>;</expr_stmt></then></if>
	<switch>switch <condition>(<expr><name>op</name></expr>)</condition> <block>{
	<case>case <expr><name>Py_LT</name></expr>: <expr_stmt><expr><name>c</name> = <name>c</name> &lt;  0</expr>;</expr_stmt> <break>break;</break>
	</case><case>case <expr><name>Py_LE</name></expr>: <expr_stmt><expr><name>c</name> = <name>c</name> &lt;= 0</expr>;</expr_stmt> <break>break;</break>
	</case><case>case <expr><name>Py_EQ</name></expr>: <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>  <break>break;</break> <comment type="block">/* unreachable */</comment>
	</case><case>case <expr><name>Py_NE</name></expr>: <expr_stmt><expr><name>c</name> = <name>c</name> != 0</expr>;</expr_stmt> <break>break;</break>
	</case><case>case <expr><name>Py_GT</name></expr>: <expr_stmt><expr><name>c</name> = <name>c</name> &gt;  0</expr>;</expr_stmt> <break>break;</break>
	</case><case>case <expr><name>Py_GE</name></expr>: <expr_stmt><expr><name>c</name> = <name>c</name> &gt;= 0</expr>;</expr_stmt> <break>break;</break>
	</case><default>default:
		<expr_stmt><expr><name>result</name> = <name>Py_NotImplemented</name></expr>;</expr_stmt>
		<goto>goto <name>out</name>;</goto>
	</default>}</block></switch>
	<expr_stmt><expr><name>result</name> = <name>c</name> ? <name>Py_True</name> : <name>Py_False</name></expr>;</expr_stmt>
  <label><name>out</name>:</label>
	<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>result</name></expr>;</return>
}</block></function>

<function><type><name>int</name></type>
<name>_PyString_Eq</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>o1</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>o2</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyStringObject</name> *</type><name>a</name> <init>= <expr>(<name>PyStringObject</name>*) <name>o1</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyStringObject</name> *</type><name>b</name> <init>= <expr>(<name>PyStringObject</name>*) <name>o2</name></expr></init></decl>;</decl_stmt>
        <return>return <expr><call><name>Py_SIZE</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call> == <call><name>Py_SIZE</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call>
          &amp;&amp; *<name><name>a</name>-&gt;<name>ob_sval</name></name> == *<name><name>b</name>-&gt;<name>ob_sval</name></name>
          &amp;&amp; <call><name>memcmp</name><argument_list>(<argument><expr><name><name>a</name>-&gt;<name>ob_sval</name></name></expr></argument>, <argument><expr><name><name>b</name>-&gt;<name>ob_sval</name></name></expr></argument>, <argument><expr><call><name>Py_SIZE</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> == 0</expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>long</name></type>
<name>string_hash</name><parameter_list>(<param><decl><type><name>PyStringObject</name> *</type><name>a</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>register</name> <name>Py_ssize_t</name></type> <name>len</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>register</name> <name>unsigned</name> <name>char</name> *</type><name>p</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>register</name> <name>long</name></type> <name>x</name></decl>;</decl_stmt>

	<if>if <condition>(<expr><name><name>a</name>-&gt;<name>ob_shash</name></name> != -1</expr>)</condition><then>
		<return>return <expr><name><name>a</name>-&gt;<name>ob_shash</name></name></expr>;</return></then></if>
	<expr_stmt><expr><name>len</name> = <call><name>Py_SIZE</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>p</name> = (<name>unsigned</name> <name>char</name> *) <name><name>a</name>-&gt;<name>ob_sval</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>x</name> = *<name>p</name> &lt;&lt; 7</expr>;</expr_stmt>
	<while>while <condition>(<expr>--<name>len</name> &gt;= 0</expr>)</condition>
		<expr_stmt><expr><name>x</name> = (1000003*<name>x</name>) ^ *<name>p</name>++</expr>;</expr_stmt></while>
	<expr_stmt><expr><name>x</name> ^= <call><name>Py_SIZE</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>x</name> == -1</expr>)</condition><then>
		<expr_stmt><expr><name>x</name> = -2</expr>;</expr_stmt></then></if>
	<expr_stmt><expr><name><name>a</name>-&gt;<name>ob_shash</name></name> = <name>x</name></expr>;</expr_stmt>
	<return>return <expr><name>x</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name>*</type>
<name>string_subscript</name><parameter_list>(<param><decl><type><name>PyStringObject</name>*</type> <name>self</name></decl></param>, <param><decl><type><name>PyObject</name>*</type> <name>item</name></decl></param>)</parameter_list>
<block>{
	<if>if <condition>(<expr><call><name>PyIndex_Check</name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>i</name> <init>= <expr><call><name>PyNumber_AsSsize_t</name><argument_list>(<argument><expr><name>item</name></expr></argument>, <argument><expr><name>PyExc_IndexError</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if>if <condition>(<expr><name>i</name> == -1 &amp;&amp; <call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then>
			<return>return <expr><name>NULL</name></expr>;</return></then></if>
		<if>if <condition>(<expr><name>i</name> &lt; 0</expr>)</condition><then>
			<expr_stmt><expr><name>i</name> += <call><name>PyString_GET_SIZE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
		<return>return <expr><call><name>string_item</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</return>
	}</block></then>
	<else>else <if>if <condition>(<expr><call><name>PySlice_Check</name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>start</name></decl>, <decl><type ref="prev"/><name>stop</name></decl>, <decl><type ref="prev"/><name>step</name></decl>, <decl><type ref="prev"/><name>slicelength</name></decl>, <decl><type ref="prev"/><name>cur</name></decl>, <decl><type ref="prev"/><name>i</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>*</type> <name>source_buf</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>*</type> <name>result_buf</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PyObject</name>*</type> <name>result</name></decl>;</decl_stmt>

		<if>if <condition>(<expr><call><name>PySlice_GetIndicesEx</name><argument_list>(<argument><expr>(<name>PySliceObject</name>*)<name>item</name></expr></argument>,
				 <argument><expr><call><name>PyString_GET_SIZE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></argument>,
				 <argument><expr>&amp;<name>start</name></expr></argument>, <argument><expr>&amp;<name>stop</name></expr></argument>, <argument><expr>&amp;<name>step</name></expr></argument>, <argument><expr>&amp;<name>slicelength</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then> <block>{
			<return>return <expr><name>NULL</name></expr>;</return>
		}</block></then></if>

		<if>if <condition>(<expr><name>slicelength</name> &lt;= 0</expr>)</condition><then> <block>{
			<return>return <expr><call><name>PyString_FromStringAndSize</name><argument_list>(<argument><expr>""</expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</return>
		}</block></then>
		<else>else <if>if <condition>(<expr><name>start</name> == 0 &amp;&amp; <name>step</name> == 1 &amp;&amp;
			 <name>slicelength</name> == <call><name>PyString_GET_SIZE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call> &amp;&amp;
			 <call><name>PyString_CheckExact</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr>(<name>PyObject</name> *)<name>self</name></expr>;</return>
		}</block></then>
		<else>else <if>if <condition>(<expr><name>step</name> == 1</expr>)</condition><then> <block>{
			<return>return <expr><call><name>PyString_FromStringAndSize</name><argument_list>(
				<argument><expr><call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call> + <name>start</name></expr></argument>,
				<argument><expr><name>slicelength</name></expr></argument>)</argument_list></call></expr>;</return>
		}</block></then>
		<else>else <block>{
			<expr_stmt><expr><name>source_buf</name> = <call><name>PyString_AsString</name><argument_list>(<argument><expr>(<name>PyObject</name>*)<name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>result_buf</name> = (<name>char</name> *)<call><name>PyMem_Malloc</name><argument_list>(<argument><expr><name>slicelength</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><name>result_buf</name> == <name>NULL</name></expr>)</condition><then>
				<return>return <expr><call><name>PyErr_NoMemory</name><argument_list>()</argument_list></call></expr>;</return></then></if>

			<for>for (<init><expr><name>cur</name> = <name>start</name></expr>, <expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>slicelength</name></expr>;</condition>
			     <incr><expr><name>cur</name> += <name>step</name></expr>, <expr><name>i</name>++</expr></incr>) <block>{
				<expr_stmt><expr><name><name>result_buf</name><index>[<expr><name>i</name></expr>]</index></name> = <name><name>source_buf</name><index>[<expr><name>cur</name></expr>]</index></name></expr>;</expr_stmt>
			}</block></for>

			<expr_stmt><expr><name>result</name> = <call><name>PyString_FromStringAndSize</name><argument_list>(<argument><expr><name>result_buf</name></expr></argument>,
							    <argument><expr><name>slicelength</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>PyMem_Free</name><argument_list>(<argument><expr><name>result_buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>result</name></expr>;</return>
		}</block></else></if></else></if></else></if>
	}</block></then>
	<else>else <block>{
		<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
			     <argument><expr>"string indices must be integers, not %.200s"</expr></argument>,
			     <argument><expr><call><name>Py_TYPE</name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call>-&gt;<name>tp_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></else></if></else></if>
}</block></function>

<function><type><specifier>static</specifier> <name>Py_ssize_t</name></type>
<name>string_buffer_getreadbuf</name><parameter_list>(<param><decl><type><name>PyStringObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>index</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>void</name> **</type><name>ptr</name></decl></param>)</parameter_list>
<block>{
	<if>if <condition>( <expr><name>index</name> != 0</expr> )</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_SystemError</name></expr></argument>,
				<argument><expr>"accessing non-existent string segment"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>-1</expr>;</return>
	}</block></then></if>
	<expr_stmt><expr>*<name>ptr</name> = (<name>void</name> *)<name><name>self</name>-&gt;<name>ob_sval</name></name></expr>;</expr_stmt>
	<return>return <expr><call><name>Py_SIZE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>Py_ssize_t</name></type>
<name>string_buffer_getwritebuf</name><parameter_list>(<param><decl><type><name>PyStringObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>index</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>void</name> **</type><name>ptr</name></decl></param>)</parameter_list>
<block>{
	<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
			<argument><expr>"Cannot use string as modifiable buffer"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr>-1</expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>Py_ssize_t</name></type>
<name>string_buffer_getsegcount</name><parameter_list>(<param><decl><type><name>PyStringObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>Py_ssize_t</name> *</type><name>lenp</name></decl></param>)</parameter_list>
<block>{
	<if>if <condition>( <expr><name>lenp</name></expr> )</condition><then>
		<expr_stmt><expr>*<name>lenp</name> = <call><name>Py_SIZE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
	<return>return <expr>1</expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>Py_ssize_t</name></type>
<name>string_buffer_getcharbuf</name><parameter_list>(<param><decl><type><name>PyStringObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>index</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> **</type><name>ptr</name></decl></param>)</parameter_list>
<block>{
	<if>if <condition>( <expr><name>index</name> != 0</expr> )</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_SystemError</name></expr></argument>,
				<argument><expr>"accessing non-existent string segment"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>-1</expr>;</return>
	}</block></then></if>
	<expr_stmt><expr>*<name>ptr</name> = <name><name>self</name>-&gt;<name>ob_sval</name></name></expr>;</expr_stmt>
	<return>return <expr><call><name>Py_SIZE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>string_buffer_getbuffer</name><parameter_list>(<param><decl><type><name>PyStringObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>Py_buffer</name> *</type><name>view</name></decl></param>, <param><decl><type><name>int</name></type> <name>flags</name></decl></param>)</parameter_list>
<block>{
	<return>return <expr><call><name>PyBuffer_FillInfo</name><argument_list>(<argument><expr><name>view</name></expr></argument>, <argument><expr>(<name>PyObject</name>*)<name>self</name></expr></argument>,
				 <argument><expr>(<name>void</name> *)<name><name>self</name>-&gt;<name>ob_sval</name></name></expr></argument>, <argument><expr><call><name>Py_SIZE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></argument>,
				 <argument><expr>1</expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <name>PySequenceMethods</name></type> <name>string_as_sequence</name> <init>= <expr><block>{
	<expr>(<name>lenfunc</name>)<name>string_length</name></expr>, <comment type="block">/*sq_length*/</comment>
	<expr>(<name>binaryfunc</name>)<name>string_concat</name></expr>, <comment type="block">/*sq_concat*/</comment>
	<expr>(<name>ssizeargfunc</name>)<name>string_repeat</name></expr>, <comment type="block">/*sq_repeat*/</comment>
	<expr>(<name>ssizeargfunc</name>)<name>string_item</name></expr>, <comment type="block">/*sq_item*/</comment>
	<expr>(<name>ssizessizeargfunc</name>)<name>string_slice</name></expr>, <comment type="block">/*sq_slice*/</comment>
	<expr>0</expr>,		<comment type="block">/*sq_ass_item*/</comment>
	<expr>0</expr>,		<comment type="block">/*sq_ass_slice*/</comment>
	<expr>(<name>objobjproc</name>)<name>string_contains</name></expr> <comment type="block">/*sq_contains*/</comment>
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>PyMappingMethods</name></type> <name>string_as_mapping</name> <init>= <expr><block>{
	<expr>(<name>lenfunc</name>)<name>string_length</name></expr>,
	<expr>(<name>binaryfunc</name>)<name>string_subscript</name></expr>,
	<expr>0</expr>,
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>PyBufferProcs</name></type> <name>string_as_buffer</name> <init>= <expr><block>{
	<expr>(<name>readbufferproc</name>)<name>string_buffer_getreadbuf</name></expr>,
	<expr>(<name>writebufferproc</name>)<name>string_buffer_getwritebuf</name></expr>,
	<expr>(<name>segcountproc</name>)<name>string_buffer_getsegcount</name></expr>,
	<expr>(<name>charbufferproc</name>)<name>string_buffer_getcharbuf</name></expr>,
	<expr>(<name>getbufferproc</name>)<name>string_buffer_getbuffer</name></expr>,
	<expr>0</expr>, <comment type="block">/* XXX */</comment>
}</block></expr></init></decl>;</decl_stmt>



<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LEFTSTRIP</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RIGHTSTRIP</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BOTHSTRIP</name></cpp:macro> <cpp:value>2</cpp:value></cpp:define>

<comment type="block">/* Arrays indexed by above */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> *</type><name><name>stripformat</name><index>[]</index></name> <init>= <expr><block>{<expr>"|O:lstrip"</expr>, <expr>"|O:rstrip"</expr>, <expr>"|O:strip"</expr>}</block></expr></init></decl>;</decl_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>STRIPNAME</name><parameter_list>(<param><type><name>i</name></type></param>)</parameter_list></cpp:macro> <cpp:value>(stripformat[i]+3)</cpp:value></cpp:define>


<comment type="block">/* Don't call if length &lt; 2 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Py_STRING_MATCH</name><parameter_list>(<param><type><name>target</name></type></param>, <param><type><name>offset</name></type></param>, <param><type><name>pattern</name></type></param>, <param><type><name>length</name></type></param>)</parameter_list></cpp:macro>	\
  <cpp:value>(target[offset] == pattern[0] &amp;&amp;				\
   target[offset+length-1] == pattern[length-1] &amp;&amp;		\
   !memcmp(target+offset+1, pattern+1, length-2) )</cpp:value></cpp:define>


<comment type="block">/* Overallocate the initial list to reduce the number of reallocs for small
   split sizes.  Eg, "A A A A A A A A A A".split() (10 elements) has three
   resizes, to sizes 4, 8, then 16.  Most observed string splits are for human
   text (roughly 11 words per line) and field delimited data (usually 1-10
   fields).  For large strings the split algorithms are bandwidth limited
   so increasing the preallocation likely will not improve things.*/</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAX_PREALLOC</name></cpp:macro> <cpp:value>12</cpp:value></cpp:define>

<comment type="block">/* 5 splits gives 6 elements */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PREALLOC_SIZE</name><parameter_list>(<param><type><name>maxsplit</name></type></param>)</parameter_list></cpp:macro> \
	<cpp:value>(maxsplit &gt;= MAX_PREALLOC ? MAX_PREALLOC : maxsplit+1)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SPLIT_APPEND</name><parameter_list>(<param><type><name>data</name></type></param>, <param><type><name>left</name></type></param>, <param><type><name>right</name></type></param>)</parameter_list></cpp:macro>				\
	<cpp:value>str = PyString_FromStringAndSize((data) + (left),	\
					 (right) - (left));	\
	if (str == NULL)					\
		goto onError;					\
	if (PyList_Append(list, str)) {				\
		Py_DECREF(str);					\
		goto onError;					\
	}							\
	else							\
		Py_DECREF(str);</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SPLIT_ADD</name><parameter_list>(<param><type><name>data</name></type></param>, <param><type><name>left</name></type></param>, <param><type><name>right</name></type></param>)</parameter_list></cpp:macro> <cpp:value>{				\
	str = PyString_FromStringAndSize((data) + (left),	\
					 (right) - (left));	\
	if (str == NULL)					\
		goto onError;					\
	if (count &lt; MAX_PREALLOC) {				\
		PyList_SET_ITEM(list, count, str);		\
	} else {						\
		if (PyList_Append(list, str)) {			\
			Py_DECREF(str);				\
			goto onError;				\
		}						\
		else						\
			Py_DECREF(str);				\
	}							\
	count++; }</cpp:value></cpp:define>

<comment type="block">/* Always force the list to the expected size. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FIX_PREALLOC_SIZE</name><parameter_list>(<param><type><name>list</name></type></param>)</parameter_list></cpp:macro> <cpp:value>Py_SIZE(list) = count</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SKIP_SPACE</name><parameter_list>(<param><type><name>s</name></type></param>, <param><type><name>i</name></type></param>, <param><type><name>len</name></type></param>)</parameter_list></cpp:macro>    <cpp:value>{ while (i&lt;len &amp;&amp;  isspace(Py_CHARMASK(s[i]))) i++; }</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SKIP_NONSPACE</name><parameter_list>(<param><type><name>s</name></type></param>, <param><type><name>i</name></type></param>, <param><type><name>len</name></type></param>)</parameter_list></cpp:macro> <cpp:value>{ while (i&lt;len &amp;&amp; !isspace(Py_CHARMASK(s[i]))) i++; }</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RSKIP_SPACE</name><parameter_list>(<param><type><name>s</name></type></param>, <param><type><name>i</name></type></param>)</parameter_list></cpp:macro>        <cpp:value>{ while (i&gt;=0  &amp;&amp;  isspace(Py_CHARMASK(s[i]))) i--; }</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RSKIP_NONSPACE</name><parameter_list>(<param><type><name>s</name></type></param>, <param><type><name>i</name></type></param>)</parameter_list></cpp:macro>     <cpp:value>{ while (i&gt;=0  &amp;&amp; !isspace(Py_CHARMASK(s[i]))) i--; }</cpp:value></cpp:define>

<macro><name>Py_LOCAL_INLINE</name><argument_list>(<argument>PyObject *</argument>)</argument_list></macro>
<macro><name>split_whitespace</name><argument_list>(<argument>PyStringObject *self</argument>, <argument>Py_ssize_t len</argument>, <argument>Py_ssize_t maxsplit</argument>)</argument_list></macro>
<block>{
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>s</name> <init>= <expr><call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>, <decl><type ref="prev"/><name>count</name><init>=<expr>0</expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>str</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>list</name> <init>= <expr><call><name>PyList_New</name><argument_list>(<argument><expr><call><name>PREALLOC_SIZE</name><argument_list>(<argument><expr><name>maxsplit</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if>if <condition>(<expr><name>list</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>

	<expr_stmt><expr><name>i</name> = <name>j</name> = 0</expr>;</expr_stmt>

	<while>while <condition>(<expr><name>maxsplit</name>-- &gt; 0</expr>)</condition> <block>{
		<expr_stmt><expr><call><name>SKIP_SPACE</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>i</name>==<name>len</name></expr>)</condition><then> <break>break;</break></then></if>
		<expr_stmt><expr><name>j</name> = <name>i</name></expr>;</expr_stmt> <expr_stmt><expr><name>i</name>++</expr>;</expr_stmt>
		<expr_stmt><expr><call><name>SKIP_NONSPACE</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>j</name> == 0 &amp;&amp; <name>i</name> == <name>len</name> &amp;&amp; <call><name>PyString_CheckExact</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
			<comment type="block">/* No whitespace in self, so just use it as list[0] */</comment>
			<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>PyList_SET_ITEM</name><argument_list>(<argument><expr><name>list</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>(<name>PyObject</name> *)<name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>count</name>++</expr>;</expr_stmt>
			<break>break;</break>
		}</block></then></if>
		<expr_stmt><expr><call><name>SPLIT_ADD</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></while>

	<if>if <condition>(<expr><name>i</name> &lt; <name>len</name></expr>)</condition><then> <block>{
		<comment type="block">/* Only occurs when maxsplit was reached */</comment>
		<comment type="block">/* Skip any remaining whitespace and copy to end of string */</comment>
		<expr_stmt><expr><call><name>SKIP_SPACE</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>i</name> != <name>len</name></expr>)</condition><then>
			<expr_stmt><expr><call><name>SPLIT_ADD</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
	}</block></then></if>
	<expr_stmt><expr><call><name>FIX_PREALLOC_SIZE</name><argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>list</name></expr>;</return>
  <label><name>onError</name>:</label>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>NULL</name></expr>;</return>
}</block>

<macro><name>Py_LOCAL_INLINE</name><argument_list>(<argument>PyObject *</argument>)</argument_list></macro>
<macro><name>split_char</name><argument_list>(<argument>PyStringObject *self</argument>, <argument>Py_ssize_t len</argument>, <argument>char ch</argument>, <argument>Py_ssize_t maxcount</argument>)</argument_list></macro>
<block>{
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>s</name> <init>= <expr><call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>register</name> <name>Py_ssize_t</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>, <decl><type ref="prev"/><name>count</name><init>=<expr>0</expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>str</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>list</name> <init>= <expr><call><name>PyList_New</name><argument_list>(<argument><expr><call><name>PREALLOC_SIZE</name><argument_list>(<argument><expr><name>maxcount</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if>if <condition>(<expr><name>list</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>

	<expr_stmt><expr><name>i</name> = <name>j</name> = 0</expr>;</expr_stmt>
	<while>while <condition>(<expr>(<name>j</name> &lt; <name>len</name>) &amp;&amp; (<name>maxcount</name>-- &gt; 0)</expr>)</condition> <block>{
		<for>for(<init>;</init> <condition><expr><name>j</name>&lt;<name>len</name></expr>;</condition> <incr><expr><name>j</name>++</expr></incr>) <block>{
			<comment type="block">/* I found that using memchr makes no difference */</comment>
			<if>if <condition>(<expr><name><name>s</name><index>[<expr><name>j</name></expr>]</index></name> == <name>ch</name></expr>)</condition><then> <block>{
				<expr_stmt><expr><call><name>SPLIT_ADD</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>i</name> = <name>j</name> = <name>j</name> + 1</expr>;</expr_stmt>
				<break>break;</break>
			}</block></then></if>
		}</block></for>
	}</block></while>
	<if>if <condition>(<expr><name>i</name> == 0 &amp;&amp; <name>count</name> == 0 &amp;&amp; <call><name>PyString_CheckExact</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<comment type="block">/* ch not in self, so just use self as list[0] */</comment>
		<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PyList_SET_ITEM</name><argument_list>(<argument><expr><name>list</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>(<name>PyObject</name> *)<name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>count</name>++</expr>;</expr_stmt>
	}</block></then>
	<else>else <if>if <condition>(<expr><name>i</name> &lt;= <name>len</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>SPLIT_ADD</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if></else></if>
	<expr_stmt><expr><call><name>FIX_PREALLOC_SIZE</name><argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>list</name></expr>;</return>

  <label><name>onError</name>:</label>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>NULL</name></expr>;</return>
}</block>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>split__doc__</name></expr></argument>,
<argument><expr>"S.split([sep [,maxsplit]]) -&gt; list of strings\n\
\n\
Return a list of the words in the string S, using sep as the\n\
delimiter string.  If maxsplit is given, at most maxsplit\n\
splits are done. If sep is not specified or is None, any\n\
whitespace string is a separator and empty strings are removed\n\
from the result."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>string_split</name><parameter_list>(<param><decl><type><name>PyStringObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>len</name> <init>= <expr><call><name>PyString_GET_SIZE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></init>, <name>n</name></decl>, <decl><type ref="prev"/><name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>maxsplit</name> <init>= <expr>-1</expr></init>, <name>count</name><init>=<expr>0</expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>s</name> <init>= <expr><call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></init>, *<name>sub</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>list</name></decl>, *<decl><type ref="prev"/><name>str</name></decl>, *<decl><type ref="prev"/><name>subobj</name> <init>= <expr><name>Py_None</name></expr></init></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_FAST</name></cpp:ifdef>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>pos</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"|On:split"</expr></argument>, <argument><expr>&amp;<name>subobj</name></expr></argument>, <argument><expr>&amp;<name>maxsplit</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<if>if <condition>(<expr><name>maxsplit</name> &lt; 0</expr>)</condition><then>
		<expr_stmt><expr><name>maxsplit</name> = <name>PY_SSIZE_T_MAX</name></expr>;</expr_stmt></then></if>
	<if>if <condition>(<expr><name>subobj</name> == <name>Py_None</name></expr>)</condition><then>
		<return>return <expr><call><name>split_whitespace</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>maxsplit</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
	<if>if <condition>(<expr><call><name>PyString_Check</name><argument_list>(<argument><expr><name>subobj</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>sub</name> = <call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>subobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>n</name> = <call><name>PyString_GET_SIZE</name><argument_list>(<argument><expr><name>subobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>Py_USING_UNICODE</name></cpp:ifdef>
	<else>else <if>if <condition>(<expr><call><name>PyUnicode_Check</name><argument_list>(<argument><expr><name>subobj</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><call><name>PyUnicode_Split</name><argument_list>(<argument><expr>(<name>PyObject</name> *)<name>self</name></expr></argument>, <argument><expr><name>subobj</name></expr></argument>, <argument><expr><name>maxsplit</name></expr></argument>)</argument_list></call></expr>;</return></then>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<else>else <if>if <condition>(<expr><call><name>PyObject_AsCharBuffer</name><argument_list>(<argument><expr><name>subobj</name></expr></argument>, <argument><expr>&amp;<name>sub</name></expr></argument>, <argument><expr>&amp;<name>n</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if></else></if></else></if>

	<if>if <condition>(<expr><name>n</name> == 0</expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>, <argument><expr>"empty separator"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then>
	<else>else <if>if <condition>(<expr><name>n</name> == 1</expr>)</condition><then>
		<return>return <expr><call><name>split_char</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name><name>sub</name><index>[<expr>0</expr>]</index></name></expr></argument>, <argument><expr><name>maxsplit</name></expr></argument>)</argument_list></call></expr>;</return></then></if></else></if>

	<expr_stmt><expr><name>list</name> = <call><name>PyList_New</name><argument_list>(<argument><expr><call><name>PREALLOC_SIZE</name><argument_list>(<argument><expr><name>maxsplit</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>list</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_FAST</name></cpp:ifdef>
	<expr_stmt><expr><name>i</name> = <name>j</name> = 0</expr>;</expr_stmt>
	<while>while <condition>(<expr><name>maxsplit</name>-- &gt; 0</expr>)</condition> <block>{
		<expr_stmt><expr><name>pos</name> = <call><name>fastsearch</name><argument_list>(<argument><expr><name>s</name>+<name>i</name></expr></argument>, <argument><expr><name>len</name>-<name>i</name></expr></argument>, <argument><expr><name>sub</name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><name>FAST_SEARCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>pos</name> &lt; 0</expr>)</condition><then>
			<break>break;</break></then></if>
		<expr_stmt><expr><name>j</name> = <name>i</name>+<name>pos</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>SPLIT_ADD</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>i</name> = <name>j</name> + <name>n</name></expr>;</expr_stmt>
	}</block></while>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<expr_stmt><expr><name>i</name> = <name>j</name> = 0</expr>;</expr_stmt>
	<while>while <condition>(<expr>(<name>j</name>+<name>n</name> &lt;= <name>len</name>) &amp;&amp; (<name>maxsplit</name>-- &gt; 0)</expr>)</condition> <block>{
		<for>for (<init>;</init> <condition><expr><name>j</name>+<name>n</name> &lt;= <name>len</name></expr>;</condition> <incr><expr><name>j</name>++</expr></incr>) <block>{
			<if>if <condition>(<expr><call><name>Py_STRING_MATCH</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><name>sub</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
				<expr_stmt><expr><call><name>SPLIT_ADD</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>i</name> = <name>j</name> = <name>j</name> + <name>n</name></expr>;</expr_stmt>
				<break>break;</break>
			}</block></then></if>
		}</block></for>
	}</block></while>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<expr_stmt><expr><call><name>SPLIT_ADD</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>FIX_PREALLOC_SIZE</name><argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>list</name></expr>;</return>

 <label><name>onError</name>:</label>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>NULL</name></expr>;</return>
}</block></function>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>partition__doc__</name></expr></argument>,
<argument><expr>"S.partition(sep) -&gt; (head, sep, tail)\n\
\n\
Search for the separator sep in S, and return the part before it,\n\
the separator itself, and the part after it.  If the separator is not\n\
found, return S and two empty strings."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>string_partition</name><parameter_list>(<param><decl><type><name>PyStringObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>sep_obj</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>sep</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>sep_len</name></decl>;</decl_stmt>

	<if>if <condition>(<expr><call><name>PyString_Check</name><argument_list>(<argument><expr><name>sep_obj</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>sep</name> = <call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>sep_obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>sep_len</name> = <call><name>PyString_GET_SIZE</name><argument_list>(<argument><expr><name>sep_obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>Py_USING_UNICODE</name></cpp:ifdef>
	<else>else <if>if <condition>(<expr><call><name>PyUnicode_Check</name><argument_list>(<argument><expr><name>sep_obj</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><call><name>PyUnicode_Partition</name><argument_list>(<argument><expr>(<name>PyObject</name> *) <name>self</name></expr></argument>, <argument><expr><name>sep_obj</name></expr></argument>)</argument_list></call></expr>;</return></then>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<else>else <if>if <condition>(<expr><call><name>PyObject_AsCharBuffer</name><argument_list>(<argument><expr><name>sep_obj</name></expr></argument>, <argument><expr>&amp;<name>sep</name></expr></argument>, <argument><expr>&amp;<name>sep_len</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if></else></if></else></if>

	<return>return <expr><call><name>stringlib_partition</name><argument_list>(
		<argument><expr>(<name>PyObject</name>*) <name>self</name></expr></argument>,
		<argument><expr><call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>PyString_GET_SIZE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></argument>,
		<argument><expr><name>sep_obj</name></expr></argument>, <argument><expr><name>sep</name></expr></argument>, <argument><expr><name>sep_len</name></expr></argument>
		)</argument_list></call></expr>;</return>
}</block></function>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>rpartition__doc__</name></expr></argument>,
<argument><expr>"S.rpartition(sep) -&gt; (tail, sep, head)\n\
\n\
Search for the separator sep in S, starting at the end of S, and return\n\
the part before it, the separator itself, and the part after it.  If the\n\
separator is not found, return two empty strings and S."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>string_rpartition</name><parameter_list>(<param><decl><type><name>PyStringObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>sep_obj</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>sep</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>sep_len</name></decl>;</decl_stmt>

	<if>if <condition>(<expr><call><name>PyString_Check</name><argument_list>(<argument><expr><name>sep_obj</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>sep</name> = <call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>sep_obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>sep_len</name> = <call><name>PyString_GET_SIZE</name><argument_list>(<argument><expr><name>sep_obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>Py_USING_UNICODE</name></cpp:ifdef>
	<else>else <if>if <condition>(<expr><call><name>PyUnicode_Check</name><argument_list>(<argument><expr><name>sep_obj</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><call><name>PyUnicode_RPartition</name><argument_list>(<argument><expr>(<name>PyObject</name> *) <name>self</name></expr></argument>, <argument><expr><name>sep_obj</name></expr></argument>)</argument_list></call></expr>;</return></then>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<else>else <if>if <condition>(<expr><call><name>PyObject_AsCharBuffer</name><argument_list>(<argument><expr><name>sep_obj</name></expr></argument>, <argument><expr>&amp;<name>sep</name></expr></argument>, <argument><expr>&amp;<name>sep_len</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if></else></if></else></if>

	<return>return <expr><call><name>stringlib_rpartition</name><argument_list>(
		<argument><expr>(<name>PyObject</name>*) <name>self</name></expr></argument>,
		<argument><expr><call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>PyString_GET_SIZE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></argument>,
		<argument><expr><name>sep_obj</name></expr></argument>, <argument><expr><name>sep</name></expr></argument>, <argument><expr><name>sep_len</name></expr></argument>
		)</argument_list></call></expr>;</return>
}</block></function>

<macro><name>Py_LOCAL_INLINE</name><argument_list>(<argument>PyObject *</argument>)</argument_list></macro>
<macro><name>rsplit_whitespace</name><argument_list>(<argument>PyStringObject *self</argument>, <argument>Py_ssize_t len</argument>, <argument>Py_ssize_t maxsplit</argument>)</argument_list></macro>
<block>{
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>s</name> <init>= <expr><call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>, <decl><type ref="prev"/><name>count</name><init>=<expr>0</expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>str</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>list</name> <init>= <expr><call><name>PyList_New</name><argument_list>(<argument><expr><call><name>PREALLOC_SIZE</name><argument_list>(<argument><expr><name>maxsplit</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if>if <condition>(<expr><name>list</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>

	<expr_stmt><expr><name>i</name> = <name>j</name> = <name>len</name>-1</expr>;</expr_stmt>

	<while>while <condition>(<expr><name>maxsplit</name>-- &gt; 0</expr>)</condition> <block>{
		<expr_stmt><expr><call><name>RSKIP_SPACE</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>i</name>&lt;0</expr>)</condition><then> <break>break;</break></then></if>
		<expr_stmt><expr><name>j</name> = <name>i</name></expr>;</expr_stmt> <expr_stmt><expr><name>i</name>--</expr>;</expr_stmt>
		<expr_stmt><expr><call><name>RSKIP_NONSPACE</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>j</name> == <name>len</name>-1 &amp;&amp; <name>i</name> &lt; 0 &amp;&amp; <call><name>PyString_CheckExact</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
			<comment type="block">/* No whitespace in self, so just use it as list[0] */</comment>
			<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>PyList_SET_ITEM</name><argument_list>(<argument><expr><name>list</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>(<name>PyObject</name> *)<name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>count</name>++</expr>;</expr_stmt>
			<break>break;</break>
		}</block></then></if>
		<expr_stmt><expr><call><name>SPLIT_ADD</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>i</name> + 1</expr></argument>, <argument><expr><name>j</name> + 1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></while>
	<if>if <condition>(<expr><name>i</name> &gt;= 0</expr>)</condition><then> <block>{
		<comment type="block">/* Only occurs when maxsplit was reached */</comment>
		<comment type="block">/* Skip any remaining whitespace and copy to beginning of string */</comment>
		<expr_stmt><expr><call><name>RSKIP_SPACE</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>i</name> &gt;= 0</expr>)</condition><then>
			<expr_stmt><expr><call><name>SPLIT_ADD</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>i</name> + 1</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

	}</block></then></if>
	<expr_stmt><expr><call><name>FIX_PREALLOC_SIZE</name><argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><call><name>PyList_Reverse</name><argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
		<goto>goto <name>onError</name>;</goto></then></if>
	<return>return <expr><name>list</name></expr>;</return>
  <label><name>onError</name>:</label>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>NULL</name></expr>;</return>
}</block>

<macro><name>Py_LOCAL_INLINE</name><argument_list>(<argument>PyObject *</argument>)</argument_list></macro>
<macro><name>rsplit_char</name><argument_list>(<argument>PyStringObject *self</argument>, <argument>Py_ssize_t len</argument>, <argument>char ch</argument>, <argument>Py_ssize_t maxcount</argument>)</argument_list></macro>
<block>{
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>s</name> <init>= <expr><call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>register</name> <name>Py_ssize_t</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>, <decl><type ref="prev"/><name>count</name><init>=<expr>0</expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>str</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>list</name> <init>= <expr><call><name>PyList_New</name><argument_list>(<argument><expr><call><name>PREALLOC_SIZE</name><argument_list>(<argument><expr><name>maxcount</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if>if <condition>(<expr><name>list</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>

	<expr_stmt><expr><name>i</name> = <name>j</name> = <name>len</name> - 1</expr>;</expr_stmt>
	<while>while <condition>(<expr>(<name>i</name> &gt;= 0) &amp;&amp; (<name>maxcount</name>-- &gt; 0)</expr>)</condition> <block>{
		<for>for (<init>;</init> <condition><expr><name>i</name> &gt;= 0</expr>;</condition> <incr><expr><name>i</name>--</expr></incr>) <block>{
			<if>if <condition>(<expr><name><name>s</name><index>[<expr><name>i</name></expr>]</index></name> == <name>ch</name></expr>)</condition><then> <block>{
				<expr_stmt><expr><call><name>SPLIT_ADD</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>i</name> + 1</expr></argument>, <argument><expr><name>j</name> + 1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>j</name> = <name>i</name> = <name>i</name> - 1</expr>;</expr_stmt>
				<break>break;</break>
			}</block></then></if>
		}</block></for>
	}</block></while>
	<if>if <condition>(<expr><name>i</name> &lt; 0 &amp;&amp; <name>count</name> == 0 &amp;&amp; <call><name>PyString_CheckExact</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<comment type="block">/* ch not in self, so just use self as list[0] */</comment>
		<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PyList_SET_ITEM</name><argument_list>(<argument><expr><name>list</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>(<name>PyObject</name> *)<name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>count</name>++</expr>;</expr_stmt>
	}</block></then>
	<else>else <if>if <condition>(<expr><name>j</name> &gt;= -1</expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>SPLIT_ADD</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>j</name> + 1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if></else></if>
	<expr_stmt><expr><call><name>FIX_PREALLOC_SIZE</name><argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><call><name>PyList_Reverse</name><argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
		<goto>goto <name>onError</name>;</goto></then></if>
	<return>return <expr><name>list</name></expr>;</return>

 <label><name>onError</name>:</label>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>NULL</name></expr>;</return>
}</block>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>rsplit__doc__</name></expr></argument>,
<argument><expr>"S.rsplit([sep [,maxsplit]]) -&gt; list of strings\n\
\n\
Return a list of the words in the string S, using sep as the\n\
delimiter string, starting at the end of the string and working\n\
to the front.  If maxsplit is given, at most maxsplit splits are\n\
done. If sep is not specified or is None, any whitespace string\n\
is a separator."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>string_rsplit</name><parameter_list>(<param><decl><type><name>PyStringObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>len</name> <init>= <expr><call><name>PyString_GET_SIZE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></init>, <name>n</name></decl>, <decl><type ref="prev"/><name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>maxsplit</name> <init>= <expr>-1</expr></init>, <name>count</name><init>=<expr>0</expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>s</name></decl>, *<decl><type ref="prev"/><name>sub</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>list</name></decl>, *<decl><type ref="prev"/><name>str</name></decl>, *<decl><type ref="prev"/><name>subobj</name> <init>= <expr><name>Py_None</name></expr></init></decl>;</decl_stmt>

	<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"|On:rsplit"</expr></argument>, <argument><expr>&amp;<name>subobj</name></expr></argument>, <argument><expr>&amp;<name>maxsplit</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<if>if <condition>(<expr><name>maxsplit</name> &lt; 0</expr>)</condition><then>
		<expr_stmt><expr><name>maxsplit</name> = <name>PY_SSIZE_T_MAX</name></expr>;</expr_stmt></then></if>
	<if>if <condition>(<expr><name>subobj</name> == <name>Py_None</name></expr>)</condition><then>
		<return>return <expr><call><name>rsplit_whitespace</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>maxsplit</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
	<if>if <condition>(<expr><call><name>PyString_Check</name><argument_list>(<argument><expr><name>subobj</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>sub</name> = <call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>subobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>n</name> = <call><name>PyString_GET_SIZE</name><argument_list>(<argument><expr><name>subobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>Py_USING_UNICODE</name></cpp:ifdef>
	<else>else <if>if <condition>(<expr><call><name>PyUnicode_Check</name><argument_list>(<argument><expr><name>subobj</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><call><name>PyUnicode_RSplit</name><argument_list>(<argument><expr>(<name>PyObject</name> *)<name>self</name></expr></argument>, <argument><expr><name>subobj</name></expr></argument>, <argument><expr><name>maxsplit</name></expr></argument>)</argument_list></call></expr>;</return></then>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<else>else <if>if <condition>(<expr><call><name>PyObject_AsCharBuffer</name><argument_list>(<argument><expr><name>subobj</name></expr></argument>, <argument><expr>&amp;<name>sub</name></expr></argument>, <argument><expr>&amp;<name>n</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if></else></if></else></if>

	<if>if <condition>(<expr><name>n</name> == 0</expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>, <argument><expr>"empty separator"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then>
	<else>else <if>if <condition>(<expr><name>n</name> == 1</expr>)</condition><then>
		<return>return <expr><call><name>rsplit_char</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name><name>sub</name><index>[<expr>0</expr>]</index></name></expr></argument>, <argument><expr><name>maxsplit</name></expr></argument>)</argument_list></call></expr>;</return></then></if></else></if>

	<expr_stmt><expr><name>list</name> = <call><name>PyList_New</name><argument_list>(<argument><expr><call><name>PREALLOC_SIZE</name><argument_list>(<argument><expr><name>maxsplit</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>list</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>

	<expr_stmt><expr><name>j</name> = <name>len</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>i</name> = <name>j</name> - <name>n</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>s</name> = <call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<while>while <condition>( <expr>(<name>i</name> &gt;= 0) &amp;&amp; (<name>maxsplit</name>-- &gt; 0)</expr> )</condition> <block>{
		<for>for (<init>;</init> <condition><expr><name>i</name>&gt;=0</expr>;</condition> <incr><expr><name>i</name>--</expr></incr>) <block>{
			<if>if <condition>(<expr><call><name>Py_STRING_MATCH</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>sub</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
				<expr_stmt><expr><call><name>SPLIT_ADD</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>i</name> + <name>n</name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>j</name> = <name>i</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>i</name> -= <name>n</name></expr>;</expr_stmt>
				<break>break;</break>
			}</block></then></if>
		}</block></for>
	}</block></while>
	<expr_stmt><expr><call><name>SPLIT_ADD</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>FIX_PREALLOC_SIZE</name><argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><call><name>PyList_Reverse</name><argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
		<goto>goto <name>onError</name>;</goto></then></if>
	<return>return <expr><name>list</name></expr>;</return>

<label><name>onError</name>:</label>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>NULL</name></expr>;</return>
}</block></function>


<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>join__doc__</name></expr></argument>,
<argument><expr>"S.join(sequence) -&gt; string\n\
\n\
Return a string which is the concatenation of the strings in the\n\
sequence.  The separator between elements is S."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>string_join</name><parameter_list>(<param><decl><type><name>PyStringObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>orig</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>char</name> *</type><name>sep</name> <init>= <expr><call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>Py_ssize_t</name></type> <name>seplen</name> <init>= <expr><call><name>PyString_GET_SIZE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>res</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> *</type><name>p</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>seqlen</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>size_t</name></type> <name>sz</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>seq</name></decl>, *<decl><type ref="prev"/><name>item</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>seq</name> = <call><name>PySequence_Fast</name><argument_list>(<argument><expr><name>orig</name></expr></argument>, <argument><expr>""</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>seq</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>

	<expr_stmt><expr><name>seqlen</name> = <call><name>PySequence_Size</name><argument_list>(<argument><expr><name>seq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>seqlen</name> == 0</expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>seq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><call><name>PyString_FromString</name><argument_list>(<argument><expr>""</expr></argument>)</argument_list></call></expr>;</return>
	}</block></then></if>
	<if>if <condition>(<expr><name>seqlen</name> == 1</expr>)</condition><then> <block>{
		<expr_stmt><expr><name>item</name> = <call><name>PySequence_Fast_GET_ITEM</name><argument_list>(<argument><expr><name>seq</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><call><name>PyString_CheckExact</name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call> || <call><name>PyUnicode_CheckExact</name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>seq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>item</name></expr>;</return>
		}</block></then></if>
	}</block></then></if>

	<comment type="block">/* There are at least two things to join, or else we have a subclass
	 * of the builtin types in the sequence.
	 * Do a pre-pass to figure out the total amount of space we'll
	 * need (sz), see whether any argument is absurd, and defer to
	 * the Unicode join if appropriate.
	 */</comment>
	<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>seqlen</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
		<decl_stmt><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>old_sz</name> <init>= <expr><name>sz</name></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name>item</name> = <call><name>PySequence_Fast_GET_ITEM</name><argument_list>(<argument><expr><name>seq</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr>!<call><name>PyString_Check</name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>)</condition><then><block>{
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>Py_USING_UNICODE</name></cpp:ifdef>
			<if>if <condition>(<expr><call><name>PyUnicode_Check</name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
				<comment type="block">/* Defer to Unicode join.
				 * CAUTION:  There's no gurantee that the
				 * original sequence can be iterated over
				 * again, so we must pass seq here.
				 */</comment>
				<decl_stmt><decl><type><name>PyObject</name> *</type><name>result</name></decl>;</decl_stmt>
				<expr_stmt><expr><name>result</name> = <call><name>PyUnicode_Join</name><argument_list>(<argument><expr>(<name>PyObject</name> *)<name>self</name></expr></argument>, <argument><expr><name>seq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>seq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><name>result</name></expr>;</return>
			}</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
			<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
				     <argument><expr>"sequence item %zd: expected string,"
				     " %.80s found"</expr></argument>,
				     <argument><expr><name>i</name></expr></argument>, <argument><expr><call><name>Py_TYPE</name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call>-&gt;<name>tp_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>seq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>NULL</name></expr>;</return>
		}</block></then></if>
		<expr_stmt><expr><name>sz</name> += <call><name>PyString_GET_SIZE</name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>i</name> != 0</expr>)</condition><then>
			<expr_stmt><expr><name>sz</name> += <name>seplen</name></expr>;</expr_stmt></then></if>
		<if>if <condition>(<expr><name>sz</name> &lt; <name>old_sz</name> || <name>sz</name> &gt; <name>PY_SSIZE_T_MAX</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_OverflowError</name></expr></argument>,
				<argument><expr>"join() result is too long for a Python string"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>seq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>NULL</name></expr>;</return>
		}</block></then></if>
	}</block></for>

	<comment type="block">/* Allocate result space. */</comment>
	<expr_stmt><expr><name>res</name> = <call><name>PyString_FromStringAndSize</name><argument_list>(<argument><expr>(<name>char</name>*)<name>NULL</name></expr></argument>, <argument><expr><name>sz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>res</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>seq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>

	<comment type="block">/* Catenate everything. */</comment>
	<expr_stmt><expr><name>p</name> = <call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>seqlen</name></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>) <block>{
		<decl_stmt><decl><type><name>size_t</name></type> <name>n</name></decl>;</decl_stmt>
		<expr_stmt><expr><name>item</name> = <call><name>PySequence_Fast_GET_ITEM</name><argument_list>(<argument><expr><name>seq</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>n</name> = <call><name>PyString_GET_SIZE</name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_MEMCPY</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>p</name> += <name>n</name></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>i</name> &lt; <name>seqlen</name> - 1</expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>Py_MEMCPY</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>sep</name></expr></argument>, <argument><expr><name>seplen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>p</name> += <name>seplen</name></expr>;</expr_stmt>
		}</block></then></if>
	}</block></for>

	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>seq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>res</name></expr>;</return>
}</block></function>

<function><type><name>PyObject</name> *</type>
<name>_PyString_Join</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>sep</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>x</name></decl></param>)</parameter_list>
<block>{
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>sep</name> != <name>NULL</name> &amp;&amp; <call><name>PyString_Check</name><argument_list>(<argument><expr><name>sep</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>x</name> != <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><call><name>string_join</name><argument_list>(<argument><expr>(<name>PyStringObject</name> *)<name>sep</name></expr></argument>, <argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<macro><name>Py_LOCAL_INLINE</name><argument_list>(<argument>void</argument>)</argument_list></macro>
<macro><name>string_adjust_indices</name><argument_list>(<argument>Py_ssize_t *start</argument>, <argument>Py_ssize_t *end</argument>, <argument>Py_ssize_t len</argument>)</argument_list></macro>
<block>{
	<if>if <condition>(<expr>*<name>end</name> &gt; <name>len</name></expr>)</condition><then>
		<expr_stmt><expr>*<name>end</name> = <name>len</name></expr>;</expr_stmt></then>
	<else>else <if>if <condition>(<expr>*<name>end</name> &lt; 0</expr>)</condition><then>
		<expr_stmt><expr>*<name>end</name> += <name>len</name></expr>;</expr_stmt></then></if></else></if>
	<if>if <condition>(<expr>*<name>end</name> &lt; 0</expr>)</condition><then>
		<expr_stmt><expr>*<name>end</name> = 0</expr>;</expr_stmt></then></if>
	<if>if <condition>(<expr>*<name>start</name> &lt; 0</expr>)</condition><then>
		<expr_stmt><expr>*<name>start</name> += <name>len</name></expr>;</expr_stmt></then></if>
	<if>if <condition>(<expr>*<name>start</name> &lt; 0</expr>)</condition><then>
		<expr_stmt><expr>*<name>start</name> = 0</expr>;</expr_stmt></then></if>
}</block>

<macro><name>Py_LOCAL_INLINE</name><argument_list>(<argument>Py_ssize_t</argument>)</argument_list></macro>
<macro><name>string_find_internal</name><argument_list>(<argument>PyStringObject *self</argument>, <argument>PyObject *args</argument>, <argument>int dir</argument>)</argument_list></macro>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>subobj</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>sub</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>sub_len</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>start</name><init>=<expr>0</expr></init>, <name>end</name><init>=<expr><name>PY_SSIZE_T_MAX</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>obj_start</name><init>=<expr><name>Py_None</name></expr></init>, *<name>obj_end</name><init>=<expr><name>Py_None</name></expr></init></decl>;</decl_stmt>

	<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"O|OO:find/rfind/index/rindex"</expr></argument>, <argument><expr>&amp;<name>subobj</name></expr></argument>,
		<argument><expr>&amp;<name>obj_start</name></expr></argument>, <argument><expr>&amp;<name>obj_end</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr>-2</expr>;</return></then></if>
	<comment type="block">/* To support None in "start" and "end" arguments, meaning
	   the same as if they were not passed.
	*/</comment>
	<if>if <condition>(<expr><name>obj_start</name> != <name>Py_None</name></expr>)</condition><then>
		<if>if <condition>(<expr>!<call><name>_PyEval_SliceIndex</name><argument_list>(<argument><expr><name>obj_start</name></expr></argument>, <argument><expr>&amp;<name>start</name></expr></argument>)</argument_list></call></expr>)</condition><then>
	        <return>return <expr>-2</expr>;</return></then></if></then></if>
	<if>if <condition>(<expr><name>obj_end</name> != <name>Py_None</name></expr>)</condition><then>
		<if>if <condition>(<expr>!<call><name>_PyEval_SliceIndex</name><argument_list>(<argument><expr><name>obj_end</name></expr></argument>, <argument><expr>&amp;<name>end</name></expr></argument>)</argument_list></call></expr>)</condition><then>
	        <return>return <expr>-2</expr>;</return></then></if></then></if>

	<if>if <condition>(<expr><call><name>PyString_Check</name><argument_list>(<argument><expr><name>subobj</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>sub</name> = <call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>subobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>sub_len</name> = <call><name>PyString_GET_SIZE</name><argument_list>(<argument><expr><name>subobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>Py_USING_UNICODE</name></cpp:ifdef>
	<else>else <if>if <condition>(<expr><call><name>PyUnicode_Check</name><argument_list>(<argument><expr><name>subobj</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><call><name>PyUnicode_Find</name><argument_list>(
			<argument><expr>(<name>PyObject</name> *)<name>self</name></expr></argument>, <argument><expr><name>subobj</name></expr></argument>, <argument><expr><name>start</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><name>dir</name></expr></argument>)</argument_list></call></expr>;</return></then>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<else>else <if>if <condition>(<expr><call><name>PyObject_AsCharBuffer</name><argument_list>(<argument><expr><name>subobj</name></expr></argument>, <argument><expr>&amp;<name>sub</name></expr></argument>, <argument><expr>&amp;<name>sub_len</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<comment type="block">/* XXX - the "expected a character buffer object" is pretty
		   confusing for a non-expert.  remap to something else ? */</comment>
		<return>return <expr>-2</expr>;</return></then></if></else></if></else></if>

	<if>if <condition>(<expr><name>dir</name> &gt; 0</expr>)</condition><then>
		<return>return <expr><call><name>stringlib_find_slice</name><argument_list>(
			<argument><expr><call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>PyString_GET_SIZE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></argument>,
			<argument><expr><name>sub</name></expr></argument>, <argument><expr><name>sub_len</name></expr></argument>, <argument><expr><name>start</name></expr></argument>, <argument><expr><name>end</name></expr></argument>)</argument_list></call></expr>;</return></then>
	<else>else
		<return>return <expr><call><name>stringlib_rfind_slice</name><argument_list>(
			<argument><expr><call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>PyString_GET_SIZE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></argument>,
			<argument><expr><name>sub</name></expr></argument>, <argument><expr><name>sub_len</name></expr></argument>, <argument><expr><name>start</name></expr></argument>, <argument><expr><name>end</name></expr></argument>)</argument_list></call></expr>;</return></else></if>
}</block>


<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>find__doc__</name></expr></argument>,
<argument><expr>"S.find(sub [,start [,end]]) -&gt; int\n\
\n\
Return the lowest index in S where substring sub is found,\n\
such that sub is contained within s[start:end].  Optional\n\
arguments start and end are interpreted as in slice notation.\n\
\n\
Return -1 on failure."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>string_find</name><parameter_list>(<param><decl><type><name>PyStringObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>result</name> <init>= <expr><call><name>string_find_internal</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>args</name></expr></argument>, <argument><expr>+1</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if>if <condition>(<expr><name>result</name> == -2</expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<return>return <expr><call><name>PyInt_FromSsize_t</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>


<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>index__doc__</name></expr></argument>,
<argument><expr>"S.index(sub [,start [,end]]) -&gt; int\n\
\n\
Like S.find() but raise ValueError when the substring is not found."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>string_index</name><parameter_list>(<param><decl><type><name>PyStringObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>result</name> <init>= <expr><call><name>string_find_internal</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>args</name></expr></argument>, <argument><expr>+1</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if>if <condition>(<expr><name>result</name> == -2</expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<if>if <condition>(<expr><name>result</name> == -1</expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>,
				<argument><expr>"substring not found"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>
	<return>return <expr><call><name>PyInt_FromSsize_t</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>


<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>rfind__doc__</name></expr></argument>,
<argument><expr>"S.rfind(sub [,start [,end]]) -&gt; int\n\
\n\
Return the highest index in S where substring sub is found,\n\
such that sub is contained within s[start:end].  Optional\n\
arguments start and end are interpreted as in slice notation.\n\
\n\
Return -1 on failure."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>string_rfind</name><parameter_list>(<param><decl><type><name>PyStringObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>result</name> <init>= <expr><call><name>string_find_internal</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>args</name></expr></argument>, <argument><expr>-1</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if>if <condition>(<expr><name>result</name> == -2</expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<return>return <expr><call><name>PyInt_FromSsize_t</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>


<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>rindex__doc__</name></expr></argument>,
<argument><expr>"S.rindex(sub [,start [,end]]) -&gt; int\n\
\n\
Like S.rfind() but raise ValueError when the substring is not found."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>string_rindex</name><parameter_list>(<param><decl><type><name>PyStringObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>result</name> <init>= <expr><call><name>string_find_internal</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>args</name></expr></argument>, <argument><expr>-1</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if>if <condition>(<expr><name>result</name> == -2</expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<if>if <condition>(<expr><name>result</name> == -1</expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>,
				<argument><expr>"substring not found"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>
	<return>return <expr><call><name>PyInt_FromSsize_t</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>


<macro><name>Py_LOCAL_INLINE</name><argument_list>(<argument>PyObject *</argument>)</argument_list></macro>
<macro><name>do_xstrip</name><argument_list>(<argument>PyStringObject *self</argument>, <argument>int striptype</argument>, <argument>PyObject *sepobj</argument>)</argument_list></macro>
<block>{
	<decl_stmt><decl><type><name>char</name> *</type><name>s</name> <init>= <expr><call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>len</name> <init>= <expr><call><name>PyString_GET_SIZE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> *</type><name>sep</name> <init>= <expr><call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>sepobj</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>seplen</name> <init>= <expr><call><name>PyString_GET_SIZE</name><argument_list>(<argument><expr><name>sepobj</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>i</name> = 0</expr>;</expr_stmt>
	<if>if <condition>(<expr><name>striptype</name> != <name>RIGHTSTRIP</name></expr>)</condition><then> <block>{
		<while>while <condition>(<expr><name>i</name> &lt; <name>len</name> &amp;&amp; <call><name>memchr</name><argument_list>(<argument><expr><name>sep</name></expr></argument>, <argument><expr><call><name>Py_CHARMASK</name><argument_list>(<argument><expr><name><name>s</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>seplen</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{
			<expr_stmt><expr><name>i</name>++</expr>;</expr_stmt>
		}</block></while>
	}</block></then></if>

	<expr_stmt><expr><name>j</name> = <name>len</name></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>striptype</name> != <name>LEFTSTRIP</name></expr>)</condition><then> <block>{
		<do>do <block>{
			<expr_stmt><expr><name>j</name>--</expr>;</expr_stmt>
		}</block> while <condition>(<expr><name>j</name> &gt;= <name>i</name> &amp;&amp; <call><name>memchr</name><argument_list>(<argument><expr><name>sep</name></expr></argument>, <argument><expr><call><name>Py_CHARMASK</name><argument_list>(<argument><expr><name><name>s</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>seplen</name></expr></argument>)</argument_list></call></expr>)</condition>;</do>
		<expr_stmt><expr><name>j</name>++</expr>;</expr_stmt>
	}</block></then></if>

	<if>if <condition>(<expr><name>i</name> == 0 &amp;&amp; <name>j</name> == <name>len</name> &amp;&amp; <call><name>PyString_CheckExact</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>(<name>PyObject</name>*)<name>self</name></expr>;</return>
	}</block></then>
	<else>else
		<return>return <expr><call><name>PyString_FromStringAndSize</name><argument_list>(<argument><expr><name>s</name>+<name>i</name></expr></argument>, <argument><expr><name>j</name>-<name>i</name></expr></argument>)</argument_list></call></expr>;</return></else></if>
}</block>


<macro><name>Py_LOCAL_INLINE</name><argument_list>(<argument>PyObject *</argument>)</argument_list></macro>
<macro><name>do_strip</name><argument_list>(<argument>PyStringObject *self</argument>, <argument>int striptype</argument>)</argument_list></macro>
<block>{
	<decl_stmt><decl><type><name>char</name> *</type><name>s</name> <init>= <expr><call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>len</name> <init>= <expr><call><name>PyString_GET_SIZE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></init>, <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>i</name> = 0</expr>;</expr_stmt>
	<if>if <condition>(<expr><name>striptype</name> != <name>RIGHTSTRIP</name></expr>)</condition><then> <block>{
		<while>while <condition>(<expr><name>i</name> &lt; <name>len</name> &amp;&amp; <call><name>isspace</name><argument_list>(<argument><expr><call><name>Py_CHARMASK</name><argument_list>(<argument><expr><name><name>s</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{
			<expr_stmt><expr><name>i</name>++</expr>;</expr_stmt>
		}</block></while>
	}</block></then></if>

	<expr_stmt><expr><name>j</name> = <name>len</name></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>striptype</name> != <name>LEFTSTRIP</name></expr>)</condition><then> <block>{
		<do>do <block>{
			<expr_stmt><expr><name>j</name>--</expr>;</expr_stmt>
		}</block> while <condition>(<expr><name>j</name> &gt;= <name>i</name> &amp;&amp; <call><name>isspace</name><argument_list>(<argument><expr><call><name>Py_CHARMASK</name><argument_list>(<argument><expr><name><name>s</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>;</do>
		<expr_stmt><expr><name>j</name>++</expr>;</expr_stmt>
	}</block></then></if>

	<if>if <condition>(<expr><name>i</name> == 0 &amp;&amp; <name>j</name> == <name>len</name> &amp;&amp; <call><name>PyString_CheckExact</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>(<name>PyObject</name>*)<name>self</name></expr>;</return>
	}</block></then>
	<else>else
		<return>return <expr><call><name>PyString_FromStringAndSize</name><argument_list>(<argument><expr><name>s</name>+<name>i</name></expr></argument>, <argument><expr><name>j</name>-<name>i</name></expr></argument>)</argument_list></call></expr>;</return></else></if>
}</block>


<macro><name>Py_LOCAL_INLINE</name><argument_list>(<argument>PyObject *</argument>)</argument_list></macro>
<macro><name>do_argstrip</name><argument_list>(<argument>PyStringObject *self</argument>, <argument>int striptype</argument>, <argument>PyObject *args</argument>)</argument_list></macro>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>sep</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>(<name>char</name> *)<name><name>stripformat</name><index>[<expr><name>striptype</name></expr>]</index></name></expr></argument>, <argument><expr>&amp;<name>sep</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>

	<if>if <condition>(<expr><name>sep</name> != <name>NULL</name> &amp;&amp; <name>sep</name> != <name>Py_None</name></expr>)</condition><then> <block>{
		<if>if <condition>(<expr><call><name>PyString_Check</name><argument_list>(<argument><expr><name>sep</name></expr></argument>)</argument_list></call></expr>)</condition><then>
			<return>return <expr><call><name>do_xstrip</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>striptype</name></expr></argument>, <argument><expr><name>sep</name></expr></argument>)</argument_list></call></expr>;</return></then>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>Py_USING_UNICODE</name></cpp:ifdef>
		<else>else <if>if <condition>(<expr><call><name>PyUnicode_Check</name><argument_list>(<argument><expr><name>sep</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
			<decl_stmt><decl><type><name>PyObject</name> *</type><name>uniself</name> <init>= <expr><call><name>PyUnicode_FromObject</name><argument_list>(<argument><expr>(<name>PyObject</name> *)<name>self</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>PyObject</name> *</type><name>res</name></decl>;</decl_stmt>
			<if>if <condition>(<expr><name>uniself</name>==<name>NULL</name></expr>)</condition><then>
				<return>return <expr><name>NULL</name></expr>;</return></then></if>
			<expr_stmt><expr><name>res</name> = <call><name>_PyUnicode_XStrip</name><argument_list>(<argument><expr>(<name>PyUnicodeObject</name> *)<name>uniself</name></expr></argument>,
				<argument><expr><name>striptype</name></expr></argument>, <argument><expr><name>sep</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>uniself</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>res</name></expr>;</return>
		}</block></then></if></else></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>Py_USING_UNICODE</name></cpp:ifdef>
			     <argument><expr>"%s arg must be None, str or unicode"</expr></argument>,
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
			     <argument><expr>"%s arg must be None or str"</expr></argument>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
			     <argument><expr><call><name>STRIPNAME</name><argument_list>(<argument><expr><name>striptype</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>

	<return>return <expr><call><name>do_strip</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>striptype</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>


<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>strip__doc__</name></expr></argument>,
<argument><expr>"S.strip([chars]) -&gt; string or unicode\n\
\n\
Return a copy of the string S with leading and trailing\n\
whitespace removed.\n\
If chars is given and not None, remove characters in chars instead.\n\
If chars is unicode, S will be converted to unicode before stripping"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>string_strip</name><parameter_list>(<param><decl><type><name>PyStringObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
	<if>if <condition>(<expr><call><name>PyTuple_GET_SIZE</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call> == 0</expr>)</condition><then>
		<return>return <expr><call><name>do_strip</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>BOTHSTRIP</name></expr></argument>)</argument_list></call></expr>;</return></then> <comment type="block">/* Common case */</comment>
	<else>else
		<return>return <expr><call><name>do_argstrip</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>BOTHSTRIP</name></expr></argument>, <argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</return></else></if>
}</block></function>


<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>lstrip__doc__</name></expr></argument>,
<argument><expr>"S.lstrip([chars]) -&gt; string or unicode\n\
\n\
Return a copy of the string S with leading whitespace removed.\n\
If chars is given and not None, remove characters in chars instead.\n\
If chars is unicode, S will be converted to unicode before stripping"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>string_lstrip</name><parameter_list>(<param><decl><type><name>PyStringObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
	<if>if <condition>(<expr><call><name>PyTuple_GET_SIZE</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call> == 0</expr>)</condition><then>
		<return>return <expr><call><name>do_strip</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>LEFTSTRIP</name></expr></argument>)</argument_list></call></expr>;</return></then> <comment type="block">/* Common case */</comment>
	<else>else
		<return>return <expr><call><name>do_argstrip</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>LEFTSTRIP</name></expr></argument>, <argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</return></else></if>
}</block></function>


<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>rstrip__doc__</name></expr></argument>,
<argument><expr>"S.rstrip([chars]) -&gt; string or unicode\n\
\n\
Return a copy of the string S with trailing whitespace removed.\n\
If chars is given and not None, remove characters in chars instead.\n\
If chars is unicode, S will be converted to unicode before stripping"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>string_rstrip</name><parameter_list>(<param><decl><type><name>PyStringObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
	<if>if <condition>(<expr><call><name>PyTuple_GET_SIZE</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call> == 0</expr>)</condition><then>
		<return>return <expr><call><name>do_strip</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>RIGHTSTRIP</name></expr></argument>)</argument_list></call></expr>;</return></then> <comment type="block">/* Common case */</comment>
	<else>else
		<return>return <expr><call><name>do_argstrip</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>RIGHTSTRIP</name></expr></argument>, <argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</return></else></if>
}</block></function>


<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>lower__doc__</name></expr></argument>,
<argument><expr>"S.lower() -&gt; string\n\
\n\
Return a copy of the string S converted to lowercase."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/* _tolower and _toupper are defined by SUSv2, but they're not ISO C */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>_tolower</name></cpp:ifndef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>_tolower</name></cpp:macro> <cpp:value>tolower</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>string_lower</name><parameter_list>(<param><decl><type><name>PyStringObject</name> *</type><name>self</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>char</name> *</type><name>s</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>n</name> <init>= <expr><call><name>PyString_GET_SIZE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>newobj</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>newobj</name> = <call><name>PyString_FromStringAndSize</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr>!<name>newobj</name></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>

	<expr_stmt><expr><name>s</name> = <call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>newobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Py_MEMCPY</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>n</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
		<decl_stmt><decl><type><name>int</name></type> <name>c</name> <init>= <expr><call><name>Py_CHARMASK</name><argument_list>(<argument><expr><name><name>s</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if>if <condition>(<expr><call><name>isupper</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>)</condition><then>
			<expr_stmt><expr><name><name>s</name><index>[<expr><name>i</name></expr>]</index></name> = <call><name>_tolower</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
	}</block></for>

	<return>return <expr><name>newobj</name></expr>;</return>
}</block></function>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>upper__doc__</name></expr></argument>,
<argument><expr>"S.upper() -&gt; string\n\
\n\
Return a copy of the string S converted to uppercase."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>_toupper</name></cpp:ifndef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>_toupper</name></cpp:macro> <cpp:value>toupper</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>string_upper</name><parameter_list>(<param><decl><type><name>PyStringObject</name> *</type><name>self</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>char</name> *</type><name>s</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>n</name> <init>= <expr><call><name>PyString_GET_SIZE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>newobj</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>newobj</name> = <call><name>PyString_FromStringAndSize</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr>!<name>newobj</name></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>

	<expr_stmt><expr><name>s</name> = <call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>newobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Py_MEMCPY</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>n</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
		<decl_stmt><decl><type><name>int</name></type> <name>c</name> <init>= <expr><call><name>Py_CHARMASK</name><argument_list>(<argument><expr><name><name>s</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if>if <condition>(<expr><call><name>islower</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>)</condition><then>
			<expr_stmt><expr><name><name>s</name><index>[<expr><name>i</name></expr>]</index></name> = <call><name>_toupper</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
	}</block></for>

	<return>return <expr><name>newobj</name></expr>;</return>
}</block></function>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>title__doc__</name></expr></argument>,
<argument><expr>"S.title() -&gt; string\n\
\n\
Return a titlecased version of S, i.e. words start with uppercase\n\
characters, all remaining cased characters have lowercase."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name>*</type>
<name>string_title</name><parameter_list>(<param><decl><type><name>PyStringObject</name> *</type><name>self</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>char</name> *</type><name>s</name> <init>= <expr><call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></init>, *<name>s_new</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>n</name> <init>= <expr><call><name>PyString_GET_SIZE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>previous_is_cased</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>newobj</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>newobj</name> = <call><name>PyString_FromStringAndSize</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>newobj</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<expr_stmt><expr><name>s_new</name> = <call><name>PyString_AsString</name><argument_list>(<argument><expr><name>newobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>n</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
		<decl_stmt><decl><type><name>int</name></type> <name>c</name> <init>= <expr><call><name>Py_CHARMASK</name><argument_list>(<argument><expr>*<name>s</name>++</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if>if <condition>(<expr><call><name>islower</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
			<if>if <condition>(<expr>!<name>previous_is_cased</name></expr>)</condition><then>
			    <expr_stmt><expr><name>c</name> = <call><name>toupper</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
			<expr_stmt><expr><name>previous_is_cased</name> = 1</expr>;</expr_stmt>
		}</block></then> <else>else <if>if <condition>(<expr><call><name>isupper</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
			<if>if <condition>(<expr><name>previous_is_cased</name></expr>)</condition><then>
			    <expr_stmt><expr><name>c</name> = <call><name>tolower</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
			<expr_stmt><expr><name>previous_is_cased</name> = 1</expr>;</expr_stmt>
		}</block></then> <else>else
			<expr_stmt><expr><name>previous_is_cased</name> = 0</expr>;</expr_stmt></else></if></else></if>
		<expr_stmt><expr>*<name>s_new</name>++ = <name>c</name></expr>;</expr_stmt>
	}</block></for>
	<return>return <expr><name>newobj</name></expr>;</return>
}</block></function>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>capitalize__doc__</name></expr></argument>,
<argument><expr>"S.capitalize() -&gt; string\n\
\n\
Return a copy of the string S with only its first character\n\
capitalized."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>string_capitalize</name><parameter_list>(<param><decl><type><name>PyStringObject</name> *</type><name>self</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>char</name> *</type><name>s</name> <init>= <expr><call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></init>, *<name>s_new</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>n</name> <init>= <expr><call><name>PyString_GET_SIZE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>newobj</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>newobj</name> = <call><name>PyString_FromStringAndSize</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>newobj</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<expr_stmt><expr><name>s_new</name> = <call><name>PyString_AsString</name><argument_list>(<argument><expr><name>newobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr>0 &lt; <name>n</name></expr>)</condition><then> <block>{
		<decl_stmt><decl><type><name>int</name></type> <name>c</name> <init>= <expr><call><name>Py_CHARMASK</name><argument_list>(<argument><expr>*<name>s</name>++</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if>if <condition>(<expr><call><name>islower</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>)</condition><then>
			<expr_stmt><expr>*<name>s_new</name> = <call><name>toupper</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
		<else>else
			<expr_stmt><expr>*<name>s_new</name> = <name>c</name></expr>;</expr_stmt></else></if>
		<expr_stmt><expr><name>s_new</name>++</expr>;</expr_stmt>
	}</block></then></if>
	<for>for (<init><expr><name>i</name> = 1</expr>;</init> <condition><expr><name>i</name> &lt; <name>n</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
		<decl_stmt><decl><type><name>int</name></type> <name>c</name> <init>= <expr><call><name>Py_CHARMASK</name><argument_list>(<argument><expr>*<name>s</name>++</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if>if <condition>(<expr><call><name>isupper</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>)</condition><then>
			<expr_stmt><expr>*<name>s_new</name> = <call><name>tolower</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
		<else>else
			<expr_stmt><expr>*<name>s_new</name> = <name>c</name></expr>;</expr_stmt></else></if>
		<expr_stmt><expr><name>s_new</name>++</expr>;</expr_stmt>
	}</block></for>
	<return>return <expr><name>newobj</name></expr>;</return>
}</block></function>


<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>count__doc__</name></expr></argument>,
<argument><expr>"S.count(sub[, start[, end]]) -&gt; int\n\
\n\
Return the number of non-overlapping occurrences of substring sub in\n\
string S[start:end].  Optional arguments start and end are interpreted\n\
as in slice notation."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>string_count</name><parameter_list>(<param><decl><type><name>PyStringObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>sub_obj</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>str</name> <init>= <expr><call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></init>, *<name>sub</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>sub_len</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>start</name> <init>= <expr>0</expr></init>, <name>end</name> <init>= <expr><name>PY_SSIZE_T_MAX</name></expr></init></decl>;</decl_stmt>

	<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"O|O&amp;O&amp;:count"</expr></argument>, <argument><expr>&amp;<name>sub_obj</name></expr></argument>,
		<argument><expr><name>_PyEval_SliceIndex</name></expr></argument>, <argument><expr>&amp;<name>start</name></expr></argument>, <argument><expr><name>_PyEval_SliceIndex</name></expr></argument>, <argument><expr>&amp;<name>end</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>

	<if>if <condition>(<expr><call><name>PyString_Check</name><argument_list>(<argument><expr><name>sub_obj</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>sub</name> = <call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>sub_obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>sub_len</name> = <call><name>PyString_GET_SIZE</name><argument_list>(<argument><expr><name>sub_obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>Py_USING_UNICODE</name></cpp:ifdef>
	<else>else <if>if <condition>(<expr><call><name>PyUnicode_Check</name><argument_list>(<argument><expr><name>sub_obj</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>count</name></decl>;</decl_stmt>
		<expr_stmt><expr><name>count</name> = <call><name>PyUnicode_Count</name><argument_list>(<argument><expr>(<name>PyObject</name> *)<name>self</name></expr></argument>, <argument><expr><name>sub_obj</name></expr></argument>, <argument><expr><name>start</name></expr></argument>, <argument><expr><name>end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>count</name> == -1</expr>)</condition><then>
			<return>return <expr><name>NULL</name></expr>;</return></then>
		<else>else
		    	<return>return <expr><call><name>PyInt_FromSsize_t</name><argument_list>(<argument><expr><name>count</name></expr></argument>)</argument_list></call></expr>;</return></else></if>
	}</block></then>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<else>else <if>if <condition>(<expr><call><name>PyObject_AsCharBuffer</name><argument_list>(<argument><expr><name>sub_obj</name></expr></argument>, <argument><expr>&amp;<name>sub</name></expr></argument>, <argument><expr>&amp;<name>sub_len</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if></else></if></else></if>

	<expr_stmt><expr><call><name>string_adjust_indices</name><argument_list>(<argument><expr>&amp;<name>start</name></expr></argument>, <argument><expr>&amp;<name>end</name></expr></argument>, <argument><expr><call><name>PyString_GET_SIZE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><call><name>PyInt_FromSsize_t</name><argument_list>(
		<argument><expr><call><name>stringlib_count</name><argument_list>(<argument><expr><name>str</name> + <name>start</name></expr></argument>, <argument><expr><name>end</name> - <name>start</name></expr></argument>, <argument><expr><name>sub</name></expr></argument>, <argument><expr><name>sub_len</name></expr></argument>)</argument_list></call></expr></argument>
		)</argument_list></call></expr>;</return>
}</block></function>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>swapcase__doc__</name></expr></argument>,
<argument><expr>"S.swapcase() -&gt; string\n\
\n\
Return a copy of the string S with uppercase characters\n\
converted to lowercase and vice versa."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>string_swapcase</name><parameter_list>(<param><decl><type><name>PyStringObject</name> *</type><name>self</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>char</name> *</type><name>s</name> <init>= <expr><call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></init>, *<name>s_new</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>n</name> <init>= <expr><call><name>PyString_GET_SIZE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>newobj</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>newobj</name> = <call><name>PyString_FromStringAndSize</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>newobj</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<expr_stmt><expr><name>s_new</name> = <call><name>PyString_AsString</name><argument_list>(<argument><expr><name>newobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>n</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
		<decl_stmt><decl><type><name>int</name></type> <name>c</name> <init>= <expr><call><name>Py_CHARMASK</name><argument_list>(<argument><expr>*<name>s</name>++</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if>if <condition>(<expr><call><name>islower</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
			<expr_stmt><expr>*<name>s_new</name> = <call><name>toupper</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></then>
		<else>else <if>if <condition>(<expr><call><name>isupper</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
			<expr_stmt><expr>*<name>s_new</name> = <call><name>tolower</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></then>
		<else>else
			<expr_stmt><expr>*<name>s_new</name> = <name>c</name></expr>;</expr_stmt></else></if></else></if>
		<expr_stmt><expr><name>s_new</name>++</expr>;</expr_stmt>
	}</block></for>
	<return>return <expr><name>newobj</name></expr>;</return>
}</block></function>


<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>translate__doc__</name></expr></argument>,
<argument><expr>"S.translate(table [,deletechars]) -&gt; string\n\
\n\
Return a copy of the string S, where all characters occurring\n\
in the optional argument deletechars are removed, and the\n\
remaining characters have been mapped through the given\n\
translation table, which must be a string of length 256."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>string_translate</name><parameter_list>(<param><decl><type><name>PyStringObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>register</name> <name>char</name> *</type><name>input</name></decl>, *<decl><type ref="prev"/><name>output</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>table</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>register</name> <name>Py_ssize_t</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>c</name></decl>, <decl><type ref="prev"/><name>changed</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>input_obj</name> <init>= <expr>(<name>PyObject</name>*)<name>self</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>output_start</name></decl>, *<decl><type ref="prev"/><name>del_table</name><init>=<expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>inlen</name></decl>, <decl><type ref="prev"/><name>tablen</name></decl>, <decl><type ref="prev"/><name>dellen</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name><name>trans_table</name><index>[<expr>256</expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>tableobj</name></decl>, *<decl><type ref="prev"/><name>delobj</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<if>if <condition>(<expr>!<call><name>PyArg_UnpackTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"translate"</expr></argument>, <argument><expr>1</expr></argument>, <argument><expr>2</expr></argument>,
			      <argument><expr>&amp;<name>tableobj</name></expr></argument>, <argument><expr>&amp;<name>delobj</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>

	<if>if <condition>(<expr><call><name>PyString_Check</name><argument_list>(<argument><expr><name>tableobj</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>table</name> = <call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>tableobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>tablen</name> = <call><name>PyString_GET_SIZE</name><argument_list>(<argument><expr><name>tableobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then>
	<else>else <if>if <condition>(<expr><name>tableobj</name> == <name>Py_None</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>table</name> = <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>tablen</name> = 256</expr>;</expr_stmt>
	}</block></then>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>Py_USING_UNICODE</name></cpp:ifdef>
	<else>else <if>if <condition>(<expr><call><name>PyUnicode_Check</name><argument_list>(<argument><expr><name>tableobj</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<comment type="block">/* Unicode .translate() does not support the deletechars
		   parameter; instead a mapping to None will cause characters
		   to be deleted. */</comment>
		<if>if <condition>(<expr><name>delobj</name> != <name>NULL</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
			<argument><expr>"deletions are implemented differently for unicode"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>NULL</name></expr>;</return>
		}</block></then></if>
		<return>return <expr><call><name>PyUnicode_Translate</name><argument_list>(<argument><expr>(<name>PyObject</name> *)<name>self</name></expr></argument>, <argument><expr><name>tableobj</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
	}</block></then>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<else>else <if>if <condition>(<expr><call><name>PyObject_AsCharBuffer</name><argument_list>(<argument><expr><name>tableobj</name></expr></argument>, <argument><expr>&amp;<name>table</name></expr></argument>, <argument><expr>&amp;<name>tablen</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if></else></if></else></if></else></if>

	<if>if <condition>(<expr><name>tablen</name> != 256</expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>,
		  <argument><expr>"translation table must be 256 characters long"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>

	<if>if <condition>(<expr><name>delobj</name> != <name>NULL</name></expr>)</condition><then> <block>{
		<if>if <condition>(<expr><call><name>PyString_Check</name><argument_list>(<argument><expr><name>delobj</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
			<expr_stmt><expr><name>del_table</name> = <call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>delobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>dellen</name> = <call><name>PyString_GET_SIZE</name><argument_list>(<argument><expr><name>delobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></then>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>Py_USING_UNICODE</name></cpp:ifdef>
		<else>else <if>if <condition>(<expr><call><name>PyUnicode_Check</name><argument_list>(<argument><expr><name>delobj</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
			<argument><expr>"deletions are implemented differently for unicode"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>NULL</name></expr>;</return>
		}</block></then>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		<else>else <if>if <condition>(<expr><call><name>PyObject_AsCharBuffer</name><argument_list>(<argument><expr><name>delobj</name></expr></argument>, <argument><expr>&amp;<name>del_table</name></expr></argument>, <argument><expr>&amp;<name>dellen</name></expr></argument>)</argument_list></call></expr>)</condition><then>
			<return>return <expr><name>NULL</name></expr>;</return></then></if></else></if></else></if>
	}</block></then>
	<else>else <block>{
		<expr_stmt><expr><name>del_table</name> = <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>dellen</name> = 0</expr>;</expr_stmt>
	}</block></else></if>

	<expr_stmt><expr><name>inlen</name> = <call><name>PyString_GET_SIZE</name><argument_list>(<argument><expr><name>input_obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>result</name> = <call><name>PyString_FromStringAndSize</name><argument_list>(<argument><expr>(<name>char</name> *)<name>NULL</name></expr></argument>, <argument><expr><name>inlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>result</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<expr_stmt><expr><name>output_start</name> = <name>output</name> = <call><name>PyString_AsString</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>input</name> = <call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>input_obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if>if <condition>(<expr><name>dellen</name> == 0 &amp;&amp; <name>table</name> != <name>NULL</name></expr>)</condition><then> <block>{
		<comment type="block">/* If no deletions are required, use faster code */</comment>
		<for>for (<init><expr><name>i</name> = <name>inlen</name></expr>;</init> <condition><expr>--<name>i</name> &gt;= 0</expr>;</condition> <incr/>) <block>{
			<expr_stmt><expr><name>c</name> = <call><name>Py_CHARMASK</name><argument_list>(<argument><expr>*<name>input</name>++</expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><call><name>Py_CHARMASK</name><argument_list>(<argument><expr>(*<name>output</name>++ = <name><name>table</name><index>[<expr><name>c</name></expr>]</index></name>)</expr></argument>)</argument_list></call> != <name>c</name></expr>)</condition><then>
				<expr_stmt><expr><name>changed</name> = 1</expr>;</expr_stmt></then></if>
		}</block></for>
		<if>if <condition>(<expr><name>changed</name> || !<call><name>PyString_CheckExact</name><argument_list>(<argument><expr><name>input_obj</name></expr></argument>)</argument_list></call></expr>)</condition><then>
			<return>return <expr><name>result</name></expr>;</return></then></if>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>input_obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>input_obj</name></expr>;</return>
	}</block></then></if>

	<if>if <condition>(<expr><name>table</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; 256</expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
			<expr_stmt><expr><name><name>trans_table</name><index>[<expr><name>i</name></expr>]</index></name> = <call><name>Py_CHARMASK</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></for>
	}</block></then> <else>else <block>{
		<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; 256</expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
			<expr_stmt><expr><name><name>trans_table</name><index>[<expr><name>i</name></expr>]</index></name> = <call><name>Py_CHARMASK</name><argument_list>(<argument><expr><name><name>table</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></for>
	}</block></else></if>

	<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>dellen</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
		<expr_stmt><expr><name><name>trans_table</name><index>[<expr>(<name>int</name>) <call><name>Py_CHARMASK</name><argument_list>(<argument><expr><name><name>del_table</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>]</index></name> = -1</expr>;</expr_stmt></for>

	<for>for (<init><expr><name>i</name> = <name>inlen</name></expr>;</init> <condition><expr>--<name>i</name> &gt;= 0</expr>;</condition> <incr/>) <block>{
		<expr_stmt><expr><name>c</name> = <call><name>Py_CHARMASK</name><argument_list>(<argument><expr>*<name>input</name>++</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name><name>trans_table</name><index>[<expr><name>c</name></expr>]</index></name> != -1</expr>)</condition><then>
			<if>if <condition>(<expr><call><name>Py_CHARMASK</name><argument_list>(<argument><expr>*<name>output</name>++ = (<name>char</name>)<name><name>trans_table</name><index>[<expr><name>c</name></expr>]</index></name></expr></argument>)</argument_list></call> == <name>c</name></expr>)</condition><then>
				<continue>continue;</continue></then></if></then></if>
		<expr_stmt><expr><name>changed</name> = 1</expr>;</expr_stmt>
	}</block></for>
	<if>if <condition>(<expr>!<name>changed</name> &amp;&amp; <call><name>PyString_CheckExact</name><argument_list>(<argument><expr><name>input_obj</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>input_obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>input_obj</name></expr>;</return>
	}</block></then></if>
	<comment type="block">/* Fix the size of the resulting string */</comment>
	<if>if <condition>(<expr><name>inlen</name> &gt; 0</expr>)</condition><then>
		<expr_stmt><expr><call><name>_PyString_Resize</name><argument_list>(<argument><expr>&amp;<name>result</name></expr></argument>, <argument><expr><name>output</name> - <name>output_start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
	<return>return <expr><name>result</name></expr>;</return>
}</block></function>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FORWARD</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>REVERSE</name></cpp:macro> <cpp:value>-1</cpp:value></cpp:define>

<comment type="block">/* find and count characters and substrings */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>findchar</name><parameter_list>(<param><type><name>target</name></type></param>, <param><type><name>target_len</name></type></param>, <param><type><name>c</name></type></param>)</parameter_list></cpp:macro>				\
  <cpp:value>((char *)memchr((const void *)(target), c, target_len))</cpp:value></cpp:define>

<comment type="block">/* String ops must return a string.  */</comment>
<comment type="block">/* If the object is subclass of string, create a copy */</comment>
<macro><name>Py_LOCAL</name><argument_list>(<argument>PyStringObject *</argument>)</argument_list></macro>
<macro><name>return_self</name><argument_list>(<argument>PyStringObject *self</argument>)</argument_list></macro>
<block>{
	<if>if <condition>(<expr><call><name>PyString_CheckExact</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>self</name></expr>;</return>
	}</block></then></if>
	<return>return <expr>(<name>PyStringObject</name> *)<call><name>PyString_FromStringAndSize</name><argument_list>(
		<argument><expr><call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></argument>,
		<argument><expr><call><name>PyString_GET_SIZE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<macro><name>Py_LOCAL_INLINE</name><argument_list>(<argument>Py_ssize_t</argument>)</argument_list></macro>
<macro><name>countchar</name><argument_list>(<argument>const char *target</argument>, <argument>int target_len</argument>, <argument>char c</argument>, <argument>Py_ssize_t maxcount</argument>)</argument_list></macro>
<block>{
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>count</name><init>=<expr>0</expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>start</name><init>=<expr><name>target</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>end</name><init>=<expr><name>target</name>+<name>target_len</name></expr></init></decl>;</decl_stmt>

	<while>while <condition>( <expr>(<name>start</name>=<call><name>findchar</name><argument_list>(<argument><expr><name>start</name></expr></argument>, <argument><expr><name>end</name>-<name>start</name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call>) != <name>NULL</name></expr> )</condition> <block>{
		<expr_stmt><expr><name>count</name>++</expr>;</expr_stmt>
		<if>if <condition>(<expr><name>count</name> &gt;= <name>maxcount</name></expr>)</condition><then>
			<break>break;</break></then></if>
		<expr_stmt><expr><name>start</name> += 1</expr>;</expr_stmt>
	}</block></while>
	<return>return <expr><name>count</name></expr>;</return>
}</block>

<macro><name>Py_LOCAL</name><argument_list>(<argument>Py_ssize_t</argument>)</argument_list></macro>
<macro><name>findstring</name><argument_list>(<argument>const char *target</argument>, <argument>Py_ssize_t target_len</argument>,
	   <argument>const char *pattern</argument>, <argument>Py_ssize_t pattern_len</argument>,
	   <argument>Py_ssize_t start</argument>,
	   <argument>Py_ssize_t end</argument>,
	   <argument>int direction</argument>)</argument_list></macro>
<block>{
	<if>if <condition>(<expr><name>start</name> &lt; 0</expr>)</condition><then> <block>{
		<expr_stmt><expr><name>start</name> += <name>target_len</name></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>start</name> &lt; 0</expr>)</condition><then>
			<expr_stmt><expr><name>start</name> = 0</expr>;</expr_stmt></then></if>
	}</block></then></if>
	<if>if <condition>(<expr><name>end</name> &gt; <name>target_len</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>end</name> = <name>target_len</name></expr>;</expr_stmt>
	}</block></then> <else>else <if>if <condition>(<expr><name>end</name> &lt; 0</expr>)</condition><then> <block>{
		<expr_stmt><expr><name>end</name> += <name>target_len</name></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>end</name> &lt; 0</expr>)</condition><then>
			<expr_stmt><expr><name>end</name> = 0</expr>;</expr_stmt></then></if>
	}</block></then></if></else></if>

	<comment type="block">/* zero-length substrings always match at the first attempt */</comment>
	<if>if <condition>(<expr><name>pattern_len</name> == 0</expr>)</condition><then>
		<return>return <expr>(<name>direction</name> &gt; 0) ? <name>start</name> : <name>end</name></expr>;</return></then></if>

	<expr_stmt><expr><name>end</name> -= <name>pattern_len</name></expr>;</expr_stmt>

	<if>if <condition>(<expr><name>direction</name> &lt; 0</expr>)</condition><then> <block>{
		<for>for (<init>;</init> <condition><expr><name>end</name> &gt;= <name>start</name></expr>;</condition> <incr><expr><name>end</name>--</expr></incr>)
			<if>if <condition>(<expr><call><name>Py_STRING_MATCH</name><argument_list>(<argument><expr><name>target</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><name>pattern</name></expr></argument>, <argument><expr><name>pattern_len</name></expr></argument>)</argument_list></call></expr>)</condition><then>
				<return>return <expr><name>end</name></expr>;</return></then></if></for>
	}</block></then> <else>else <block>{
		<for>for (<init>;</init> <condition><expr><name>start</name> &lt;= <name>end</name></expr>;</condition> <incr><expr><name>start</name>++</expr></incr>)
			<if>if <condition>(<expr><call><name>Py_STRING_MATCH</name><argument_list>(<argument><expr><name>target</name></expr></argument>, <argument><expr><name>start</name></expr></argument>, <argument><expr><name>pattern</name></expr></argument>, <argument><expr><name>pattern_len</name></expr></argument>)</argument_list></call></expr>)</condition><then>
				<return>return <expr><name>start</name></expr>;</return></then></if></for>
	}</block></else></if>
	<return>return <expr>-1</expr>;</return>
}</block>

<macro><name>Py_LOCAL_INLINE</name><argument_list>(<argument>Py_ssize_t</argument>)</argument_list></macro>
<macro><name>countstring</name><argument_list>(<argument>const char *target</argument>, <argument>Py_ssize_t target_len</argument>,
	    <argument>const char *pattern</argument>, <argument>Py_ssize_t pattern_len</argument>,
	    <argument>Py_ssize_t start</argument>,
	    <argument>Py_ssize_t end</argument>,
	    <argument>int direction</argument>, <argument>Py_ssize_t maxcount</argument>)</argument_list></macro>
<block>{
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>count</name><init>=<expr>0</expr></init></decl>;</decl_stmt>

	<if>if <condition>(<expr><name>start</name> &lt; 0</expr>)</condition><then> <block>{
		<expr_stmt><expr><name>start</name> += <name>target_len</name></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>start</name> &lt; 0</expr>)</condition><then>
			<expr_stmt><expr><name>start</name> = 0</expr>;</expr_stmt></then></if>
	}</block></then></if>
	<if>if <condition>(<expr><name>end</name> &gt; <name>target_len</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>end</name> = <name>target_len</name></expr>;</expr_stmt>
	}</block></then> <else>else <if>if <condition>(<expr><name>end</name> &lt; 0</expr>)</condition><then> <block>{
		<expr_stmt><expr><name>end</name> += <name>target_len</name></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>end</name> &lt; 0</expr>)</condition><then>
			<expr_stmt><expr><name>end</name> = 0</expr>;</expr_stmt></then></if>
	}</block></then></if></else></if>

	<comment type="block">/* zero-length substrings match everywhere */</comment>
	<if>if <condition>(<expr><name>pattern_len</name> == 0 || <name>maxcount</name> == 0</expr>)</condition><then> <block>{
		<if>if <condition>(<expr><name>target_len</name>+1 &lt; <name>maxcount</name></expr>)</condition><then>
			<return>return <expr><name>target_len</name>+1</expr>;</return></then></if>
		<return>return <expr><name>maxcount</name></expr>;</return>
	}</block></then></if>

	<expr_stmt><expr><name>end</name> -= <name>pattern_len</name></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>direction</name> &lt; 0</expr>)</condition><then> <block>{
		<for>for (<init>;</init> <condition><expr>(<name>end</name> &gt;= <name>start</name>)</expr>;</condition> <incr><expr><name>end</name>--</expr></incr>)
			<if>if <condition>(<expr><call><name>Py_STRING_MATCH</name><argument_list>(<argument><expr><name>target</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><name>pattern</name></expr></argument>, <argument><expr><name>pattern_len</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
				<expr_stmt><expr><name>count</name>++</expr>;</expr_stmt>
				<if>if <condition>(<expr>--<name>maxcount</name> &lt;= 0</expr>)</condition><then> <break>break;</break></then></if>
				<expr_stmt><expr><name>end</name> -= <name>pattern_len</name>-1</expr>;</expr_stmt>
			}</block></then></if></for>
	}</block></then> <else>else <block>{
		<for>for (<init>;</init> <condition><expr>(<name>start</name> &lt;= <name>end</name>)</expr>;</condition> <incr><expr><name>start</name>++</expr></incr>)
			<if>if <condition>(<expr><call><name>Py_STRING_MATCH</name><argument_list>(<argument><expr><name>target</name></expr></argument>, <argument><expr><name>start</name></expr></argument>, <argument><expr><name>pattern</name></expr></argument>, <argument><expr><name>pattern_len</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
				<expr_stmt><expr><name>count</name>++</expr>;</expr_stmt>
				<if>if <condition>(<expr>--<name>maxcount</name> &lt;= 0</expr>)</condition><then>
					<break>break;</break></then></if>
				<expr_stmt><expr><name>start</name> += <name>pattern_len</name>-1</expr>;</expr_stmt>
			}</block></then></if></for>
	}</block></else></if>
	<return>return <expr><name>count</name></expr>;</return>
}</block>


<comment type="block">/* Algorithms for different cases of string replacement */</comment>

<comment type="block">/* len(self)&gt;=1, from="", len(to)&gt;=1, maxcount&gt;=1 */</comment>
<macro><name>Py_LOCAL</name><argument_list>(<argument>PyStringObject *</argument>)</argument_list></macro>
<macro><name>replace_interleave</name><argument_list>(<argument>PyStringObject *self</argument>,
		   <argument>const char *to_s</argument>, <argument>Py_ssize_t to_len</argument>,
		   <argument>Py_ssize_t maxcount</argument>)</argument_list></macro>
<block>{
	<decl_stmt><decl><type><name>char</name> *</type><name>self_s</name></decl>, *<decl><type ref="prev"/><name>result_s</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>self_len</name></decl>, <decl><type ref="prev"/><name>result_len</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>count</name></decl>, <decl><type ref="prev"/><name>i</name></decl>, <decl><type ref="prev"/><name>product</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyStringObject</name> *</type><name>result</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>self_len</name> = <call><name>PyString_GET_SIZE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* 1 at the end plus 1 after every character */</comment>
	<expr_stmt><expr><name>count</name> = <name>self_len</name>+1</expr>;</expr_stmt>
	<if>if <condition>(<expr><name>maxcount</name> &lt; <name>count</name></expr>)</condition><then> 
		<expr_stmt><expr><name>count</name> = <name>maxcount</name></expr>;</expr_stmt></then></if>

	<comment type="block">/* Check for overflow */</comment>
	<comment type="block">/*   result_len = count * to_len + self_len; */</comment>
	<expr_stmt><expr><name>product</name> = <name>count</name> * <name>to_len</name></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>product</name> / <name>to_len</name> != <name>count</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_OverflowError</name></expr></argument>,
				<argument><expr>"replace string is too long"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>
	<expr_stmt><expr><name>result_len</name> = <name>product</name> + <name>self_len</name></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>result_len</name> &lt; 0</expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_OverflowError</name></expr></argument>,
				<argument><expr>"replace string is too long"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>
  
	<if>if <condition>(<expr>! (<name>result</name> = (<name>PyStringObject</name> *)
	                 <call><name>PyString_FromStringAndSize</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>result_len</name></expr></argument>)</argument_list></call>)</expr> )</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>

	<expr_stmt><expr><name>self_s</name> = <call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>result_s</name> = <call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* TODO: special case single character, which doesn't need memcpy */</comment>

	<comment type="block">/* Lay the first one down (guaranteed this will occur) */</comment>
	<expr_stmt><expr><call><name>Py_MEMCPY</name><argument_list>(<argument><expr><name>result_s</name></expr></argument>, <argument><expr><name>to_s</name></expr></argument>, <argument><expr><name>to_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>result_s</name> += <name>to_len</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>count</name> -= 1</expr>;</expr_stmt>
  
	<for>for (<init><expr><name>i</name>=0</expr>;</init> <condition><expr><name>i</name>&lt;<name>count</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
		<expr_stmt><expr>*<name>result_s</name>++ = *<name>self_s</name>++</expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_MEMCPY</name><argument_list>(<argument><expr><name>result_s</name></expr></argument>, <argument><expr><name>to_s</name></expr></argument>, <argument><expr><name>to_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>result_s</name> += <name>to_len</name></expr>;</expr_stmt>
	}</block></for>

	<comment type="block">/* Copy the rest of the original string */</comment>
	<expr_stmt><expr><call><name>Py_MEMCPY</name><argument_list>(<argument><expr><name>result_s</name></expr></argument>, <argument><expr><name>self_s</name></expr></argument>, <argument><expr><name>self_len</name>-<name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>result</name></expr>;</return>
}</block>

<comment type="block">/* Special case for deleting a single character */</comment>
<comment type="block">/* len(self)&gt;=1, len(from)==1, to="", maxcount&gt;=1 */</comment>
<macro><name>Py_LOCAL</name><argument_list>(<argument>PyStringObject *</argument>)</argument_list></macro>
<macro><name>replace_delete_single_character</name><argument_list>(<argument>PyStringObject *self</argument>,
				<argument>char from_c</argument>, <argument>Py_ssize_t maxcount</argument>)</argument_list></macro>
<block>{
	<decl_stmt><decl><type><name>char</name> *</type><name>self_s</name></decl>, *<decl><type ref="prev"/><name>result_s</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> *</type><name>start</name></decl>, *<decl><type ref="prev"/><name>next</name></decl>, *<decl><type ref="prev"/><name>end</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>self_len</name></decl>, <decl><type ref="prev"/><name>result_len</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>count</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyStringObject</name> *</type><name>result</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>self_len</name> = <call><name>PyString_GET_SIZE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>self_s</name> = <call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>count</name> = <call><name>countchar</name><argument_list>(<argument><expr><name>self_s</name></expr></argument>, <argument><expr><name>self_len</name></expr></argument>, <argument><expr><name>from_c</name></expr></argument>, <argument><expr><name>maxcount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>count</name> == 0</expr>)</condition><then> <block>{
		<return>return <expr><call><name>return_self</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</return>
	}</block></then></if>
  
	<expr_stmt><expr><name>result_len</name> = <name>self_len</name> - <name>count</name></expr>;</expr_stmt>  <comment type="block">/* from_len == 1 */</comment>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>result_len</name>&gt;=0</expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if>if <condition>( <expr>(<name>result</name> = (<name>PyStringObject</name> *)
	                <call><name>PyString_FromStringAndSize</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>result_len</name></expr></argument>)</argument_list></call>) == <name>NULL</name></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<expr_stmt><expr><name>result_s</name> = <call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>start</name> = <name>self_s</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>end</name> = <name>self_s</name> + <name>self_len</name></expr>;</expr_stmt>
	<while>while <condition>(<expr><name>count</name>-- &gt; 0</expr>)</condition> <block>{
		<expr_stmt><expr><name>next</name> = <call><name>findchar</name><argument_list>(<argument><expr><name>start</name></expr></argument>, <argument><expr><name>end</name>-<name>start</name></expr></argument>, <argument><expr><name>from_c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>next</name> == <name>NULL</name></expr>)</condition><then>
			<break>break;</break></then></if>
		<expr_stmt><expr><call><name>Py_MEMCPY</name><argument_list>(<argument><expr><name>result_s</name></expr></argument>, <argument><expr><name>start</name></expr></argument>, <argument><expr><name>next</name>-<name>start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>result_s</name> += (<name>next</name>-<name>start</name>)</expr>;</expr_stmt>
		<expr_stmt><expr><name>start</name> = <name>next</name>+1</expr>;</expr_stmt>
	}</block></while>
	<expr_stmt><expr><call><name>Py_MEMCPY</name><argument_list>(<argument><expr><name>result_s</name></expr></argument>, <argument><expr><name>start</name></expr></argument>, <argument><expr><name>end</name>-<name>start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>result</name></expr>;</return>
}</block>

<comment type="block">/* len(self)&gt;=1, len(from)&gt;=2, to="", maxcount&gt;=1 */</comment>

<macro><name>Py_LOCAL</name><argument_list>(<argument>PyStringObject *</argument>)</argument_list></macro>
<macro><name>replace_delete_substring</name><argument_list>(<argument>PyStringObject *self</argument>,
			 <argument>const char *from_s</argument>, <argument>Py_ssize_t from_len</argument>,
			 <argument>Py_ssize_t maxcount</argument>)</argument_list></macro> <block>{
	<decl_stmt><decl><type><name>char</name> *</type><name>self_s</name></decl>, *<decl><type ref="prev"/><name>result_s</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> *</type><name>start</name></decl>, *<decl><type ref="prev"/><name>next</name></decl>, *<decl><type ref="prev"/><name>end</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>self_len</name></decl>, <decl><type ref="prev"/><name>result_len</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>count</name></decl>, <decl><type ref="prev"/><name>offset</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyStringObject</name> *</type><name>result</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>self_len</name> = <call><name>PyString_GET_SIZE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>self_s</name> = <call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>count</name> = <call><name>countstring</name><argument_list>(<argument><expr><name>self_s</name></expr></argument>, <argument><expr><name>self_len</name></expr></argument>,
			    <argument><expr><name>from_s</name></expr></argument>, <argument><expr><name>from_len</name></expr></argument>,
			    <argument><expr>0</expr></argument>, <argument><expr><name>self_len</name></expr></argument>, <argument><expr>1</expr></argument>,
			    <argument><expr><name>maxcount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if>if <condition>(<expr><name>count</name> == 0</expr>)</condition><then> <block>{
		<comment type="block">/* no matches */</comment>
		<return>return <expr><call><name>return_self</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</return>
	}</block></then></if>

	<expr_stmt><expr><name>result_len</name> = <name>self_len</name> - (<name>count</name> * <name>from_len</name>)</expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name> <argument_list>(<argument><expr><name>result_len</name>&gt;=0</expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if>if <condition>( <expr>(<name>result</name> = (<name>PyStringObject</name> *)
	      <call><name>PyString_FromStringAndSize</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>result_len</name></expr></argument>)</argument_list></call>) == <name>NULL</name></expr> )</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>

	<expr_stmt><expr><name>result_s</name> = <call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>start</name> = <name>self_s</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>end</name> = <name>self_s</name> + <name>self_len</name></expr>;</expr_stmt>
	<while>while <condition>(<expr><name>count</name>-- &gt; 0</expr>)</condition> <block>{
		<expr_stmt><expr><name>offset</name> = <call><name>findstring</name><argument_list>(<argument><expr><name>start</name></expr></argument>, <argument><expr><name>end</name>-<name>start</name></expr></argument>,
				    <argument><expr><name>from_s</name></expr></argument>, <argument><expr><name>from_len</name></expr></argument>,
				    <argument><expr>0</expr></argument>, <argument><expr><name>end</name>-<name>start</name></expr></argument>, <argument><expr><name>FORWARD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>offset</name> == -1</expr>)</condition><then>
			<break>break;</break></then></if>
		<expr_stmt><expr><name>next</name> = <name>start</name> + <name>offset</name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>Py_MEMCPY</name><argument_list>(<argument><expr><name>result_s</name></expr></argument>, <argument><expr><name>start</name></expr></argument>, <argument><expr><name>next</name>-<name>start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>result_s</name> += (<name>next</name>-<name>start</name>)</expr>;</expr_stmt>
		<expr_stmt><expr><name>start</name> = <name>next</name>+<name>from_len</name></expr>;</expr_stmt>
	}</block></while>
	<expr_stmt><expr><call><name>Py_MEMCPY</name><argument_list>(<argument><expr><name>result_s</name></expr></argument>, <argument><expr><name>start</name></expr></argument>, <argument><expr><name>end</name>-<name>start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>result</name></expr>;</return>
}</block>

<comment type="block">/* len(self)&gt;=1, len(from)==len(to)==1, maxcount&gt;=1 */</comment>
<macro><name>Py_LOCAL</name><argument_list>(<argument>PyStringObject *</argument>)</argument_list></macro>
<macro><name>replace_single_character_in_place</name><argument_list>(<argument>PyStringObject *self</argument>,
				  <argument>char from_c</argument>, <argument>char to_c</argument>,
				  <argument>Py_ssize_t maxcount</argument>)</argument_list></macro>
<block>{
	<decl_stmt><decl><type><name>char</name> *</type><name>self_s</name></decl>, *<decl><type ref="prev"/><name>result_s</name></decl>, *<decl><type ref="prev"/><name>start</name></decl>, *<decl><type ref="prev"/><name>end</name></decl>, *<decl><type ref="prev"/><name>next</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>self_len</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyStringObject</name> *</type><name>result</name></decl>;</decl_stmt>

	<comment type="block">/* The result string will be the same size */</comment>
	<expr_stmt><expr><name>self_s</name> = <call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>self_len</name> = <call><name>PyString_GET_SIZE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>next</name> = <call><name>findchar</name><argument_list>(<argument><expr><name>self_s</name></expr></argument>, <argument><expr><name>self_len</name></expr></argument>, <argument><expr><name>from_c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if>if <condition>(<expr><name>next</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<comment type="block">/* No matches; return the original string */</comment>
		<return>return <expr><call><name>return_self</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</return>
	}</block></then></if>

	<comment type="block">/* Need to make a new string */</comment>
	<expr_stmt><expr><name>result</name> = (<name>PyStringObject</name> *) <call><name>PyString_FromStringAndSize</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>self_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>result</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<expr_stmt><expr><name>result_s</name> = <call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_MEMCPY</name><argument_list>(<argument><expr><name>result_s</name></expr></argument>, <argument><expr><name>self_s</name></expr></argument>, <argument><expr><name>self_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* change everything in-place, starting with this one */</comment>
	<expr_stmt><expr><name>start</name> =  <name>result_s</name> + (<name>next</name>-<name>self_s</name>)</expr>;</expr_stmt>
	<expr_stmt><expr>*<name>start</name> = <name>to_c</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>start</name>++</expr>;</expr_stmt>
	<expr_stmt><expr><name>end</name> = <name>result_s</name> + <name>self_len</name></expr>;</expr_stmt>

	<while>while <condition>(<expr>--<name>maxcount</name> &gt; 0</expr>)</condition> <block>{
		<expr_stmt><expr><name>next</name> = <call><name>findchar</name><argument_list>(<argument><expr><name>start</name></expr></argument>, <argument><expr><name>end</name>-<name>start</name></expr></argument>, <argument><expr><name>from_c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>next</name> == <name>NULL</name></expr>)</condition><then>
			<break>break;</break></then></if>
		<expr_stmt><expr>*<name>next</name> = <name>to_c</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>start</name> = <name>next</name>+1</expr>;</expr_stmt>
	}</block></while>

	<return>return <expr><name>result</name></expr>;</return>
}</block>

<comment type="block">/* len(self)&gt;=1, len(from)==len(to)&gt;=2, maxcount&gt;=1 */</comment>
<macro><name>Py_LOCAL</name><argument_list>(<argument>PyStringObject *</argument>)</argument_list></macro>
<macro><name>replace_substring_in_place</name><argument_list>(<argument>PyStringObject *self</argument>,
			   <argument>const char *from_s</argument>, <argument>Py_ssize_t from_len</argument>,
			   <argument>const char *to_s</argument>, <argument>Py_ssize_t to_len</argument>,
			   <argument>Py_ssize_t maxcount</argument>)</argument_list></macro>
<block>{
	<decl_stmt><decl><type><name>char</name> *</type><name>result_s</name></decl>, *<decl><type ref="prev"/><name>start</name></decl>, *<decl><type ref="prev"/><name>end</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> *</type><name>self_s</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>self_len</name></decl>, <decl><type ref="prev"/><name>offset</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyStringObject</name> *</type><name>result</name></decl>;</decl_stmt>

	<comment type="block">/* The result string will be the same size */</comment>

	<expr_stmt><expr><name>self_s</name> = <call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>self_len</name> = <call><name>PyString_GET_SIZE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>offset</name> = <call><name>findstring</name><argument_list>(<argument><expr><name>self_s</name></expr></argument>, <argument><expr><name>self_len</name></expr></argument>,
			    <argument><expr><name>from_s</name></expr></argument>, <argument><expr><name>from_len</name></expr></argument>,
			    <argument><expr>0</expr></argument>, <argument><expr><name>self_len</name></expr></argument>, <argument><expr><name>FORWARD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>offset</name> == -1</expr>)</condition><then> <block>{
		<comment type="block">/* No matches; return the original string */</comment>
		<return>return <expr><call><name>return_self</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</return>
	}</block></then></if>

	<comment type="block">/* Need to make a new string */</comment>
	<expr_stmt><expr><name>result</name> = (<name>PyStringObject</name> *) <call><name>PyString_FromStringAndSize</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>self_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>result</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<expr_stmt><expr><name>result_s</name> = <call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_MEMCPY</name><argument_list>(<argument><expr><name>result_s</name></expr></argument>, <argument><expr><name>self_s</name></expr></argument>, <argument><expr><name>self_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* change everything in-place, starting with this one */</comment>
	<expr_stmt><expr><name>start</name> =  <name>result_s</name> + <name>offset</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_MEMCPY</name><argument_list>(<argument><expr><name>start</name></expr></argument>, <argument><expr><name>to_s</name></expr></argument>, <argument><expr><name>from_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>start</name> += <name>from_len</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>end</name> = <name>result_s</name> + <name>self_len</name></expr>;</expr_stmt>

	<while>while <condition>( <expr>--<name>maxcount</name> &gt; 0</expr>)</condition> <block>{
		<expr_stmt><expr><name>offset</name> = <call><name>findstring</name><argument_list>(<argument><expr><name>start</name></expr></argument>, <argument><expr><name>end</name>-<name>start</name></expr></argument>,
				    <argument><expr><name>from_s</name></expr></argument>, <argument><expr><name>from_len</name></expr></argument>,
				    <argument><expr>0</expr></argument>, <argument><expr><name>end</name>-<name>start</name></expr></argument>, <argument><expr><name>FORWARD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>offset</name>==-1</expr>)</condition><then>
			<break>break;</break></then></if>
		<expr_stmt><expr><call><name>Py_MEMCPY</name><argument_list>(<argument><expr><name>start</name>+<name>offset</name></expr></argument>, <argument><expr><name>to_s</name></expr></argument>, <argument><expr><name>from_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>start</name> += <name>offset</name>+<name>from_len</name></expr>;</expr_stmt>
	}</block></while>

	<return>return <expr><name>result</name></expr>;</return>
}</block>

<comment type="block">/* len(self)&gt;=1, len(from)==1, len(to)&gt;=2, maxcount&gt;=1 */</comment>
<macro><name>Py_LOCAL</name><argument_list>(<argument>PyStringObject *</argument>)</argument_list></macro>
<macro><name>replace_single_character</name><argument_list>(<argument>PyStringObject *self</argument>,
			 <argument>char from_c</argument>,
			 <argument>const char *to_s</argument>, <argument>Py_ssize_t to_len</argument>,
			 <argument>Py_ssize_t maxcount</argument>)</argument_list></macro>
<block>{
	<decl_stmt><decl><type><name>char</name> *</type><name>self_s</name></decl>, *<decl><type ref="prev"/><name>result_s</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> *</type><name>start</name></decl>, *<decl><type ref="prev"/><name>next</name></decl>, *<decl><type ref="prev"/><name>end</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>self_len</name></decl>, <decl><type ref="prev"/><name>result_len</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>count</name></decl>, <decl><type ref="prev"/><name>product</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyStringObject</name> *</type><name>result</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>self_s</name> = <call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>self_len</name> = <call><name>PyString_GET_SIZE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>count</name> = <call><name>countchar</name><argument_list>(<argument><expr><name>self_s</name></expr></argument>, <argument><expr><name>self_len</name></expr></argument>, <argument><expr><name>from_c</name></expr></argument>, <argument><expr><name>maxcount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>count</name> == 0</expr>)</condition><then> <block>{
		<comment type="block">/* no matches, return unchanged */</comment>
		<return>return <expr><call><name>return_self</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</return>
	}</block></then></if>

	<comment type="block">/* use the difference between current and new, hence the "-1" */</comment>
	<comment type="block">/*   result_len = self_len + count * (to_len-1)  */</comment>
	<expr_stmt><expr><name>product</name> = <call><name>count</name> * <argument_list>(<argument><expr><name>to_len</name>-1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>product</name> / (<name>to_len</name>-1) != <name>count</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_OverflowError</name></expr></argument>, <argument><expr>"replace string is too long"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>
	<expr_stmt><expr><name>result_len</name> = <name>self_len</name> + <name>product</name></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>result_len</name> &lt; 0</expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_OverflowError</name></expr></argument>, <argument><expr>"replace string is too long"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>

	<if>if <condition>( <expr>(<name>result</name> = (<name>PyStringObject</name> *)
	      <call><name>PyString_FromStringAndSize</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>result_len</name></expr></argument>)</argument_list></call>) == <name>NULL</name></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<expr_stmt><expr><name>result_s</name> = <call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>start</name> = <name>self_s</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>end</name> = <name>self_s</name> + <name>self_len</name></expr>;</expr_stmt>
	<while>while <condition>(<expr><name>count</name>-- &gt; 0</expr>)</condition> <block>{
		<expr_stmt><expr><name>next</name> = <call><name>findchar</name><argument_list>(<argument><expr><name>start</name></expr></argument>, <argument><expr><name>end</name>-<name>start</name></expr></argument>, <argument><expr><name>from_c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>next</name> == <name>NULL</name></expr>)</condition><then> 
			<break>break;</break></then></if>

		<if>if <condition>(<expr><name>next</name> == <name>start</name></expr>)</condition><then> <block>{
			<comment type="block">/* replace with the 'to' */</comment>
			<expr_stmt><expr><call><name>Py_MEMCPY</name><argument_list>(<argument><expr><name>result_s</name></expr></argument>, <argument><expr><name>to_s</name></expr></argument>, <argument><expr><name>to_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>result_s</name> += <name>to_len</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>start</name> += 1</expr>;</expr_stmt>
		}</block></then> <else>else <block>{
			<comment type="block">/* copy the unchanged old then the 'to' */</comment>
			<expr_stmt><expr><call><name>Py_MEMCPY</name><argument_list>(<argument><expr><name>result_s</name></expr></argument>, <argument><expr><name>start</name></expr></argument>, <argument><expr><name>next</name>-<name>start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>result_s</name> += (<name>next</name>-<name>start</name>)</expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Py_MEMCPY</name><argument_list>(<argument><expr><name>result_s</name></expr></argument>, <argument><expr><name>to_s</name></expr></argument>, <argument><expr><name>to_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>result_s</name> += <name>to_len</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>start</name> = <name>next</name>+1</expr>;</expr_stmt>
		}</block></else></if>
	}</block></while>
	<comment type="block">/* Copy the remainder of the remaining string */</comment>
	<expr_stmt><expr><call><name>Py_MEMCPY</name><argument_list>(<argument><expr><name>result_s</name></expr></argument>, <argument><expr><name>start</name></expr></argument>, <argument><expr><name>end</name>-<name>start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>result</name></expr>;</return>
}</block>

<comment type="block">/* len(self)&gt;=1, len(from)&gt;=2, len(to)&gt;=2, maxcount&gt;=1 */</comment>
<macro><name>Py_LOCAL</name><argument_list>(<argument>PyStringObject *</argument>)</argument_list></macro>
<macro><name>replace_substring</name><argument_list>(<argument>PyStringObject *self</argument>,
		  <argument>const char *from_s</argument>, <argument>Py_ssize_t from_len</argument>,
		  <argument>const char *to_s</argument>, <argument>Py_ssize_t to_len</argument>,
		  <argument>Py_ssize_t maxcount</argument>)</argument_list></macro> <block>{
	<decl_stmt><decl><type><name>char</name> *</type><name>self_s</name></decl>, *<decl><type ref="prev"/><name>result_s</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> *</type><name>start</name></decl>, *<decl><type ref="prev"/><name>next</name></decl>, *<decl><type ref="prev"/><name>end</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>self_len</name></decl>, <decl><type ref="prev"/><name>result_len</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>count</name></decl>, <decl><type ref="prev"/><name>offset</name></decl>, <decl><type ref="prev"/><name>product</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyStringObject</name> *</type><name>result</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>self_s</name> = <call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>self_len</name> = <call><name>PyString_GET_SIZE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>count</name> = <call><name>countstring</name><argument_list>(<argument><expr><name>self_s</name></expr></argument>, <argument><expr><name>self_len</name></expr></argument>,
			    <argument><expr><name>from_s</name></expr></argument>, <argument><expr><name>from_len</name></expr></argument>,
			    <argument><expr>0</expr></argument>, <argument><expr><name>self_len</name></expr></argument>, <argument><expr><name>FORWARD</name></expr></argument>, <argument><expr><name>maxcount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>count</name> == 0</expr>)</condition><then> <block>{
		<comment type="block">/* no matches, return unchanged */</comment>
		<return>return <expr><call><name>return_self</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</return>
	}</block></then></if>

	<comment type="block">/* Check for overflow */</comment>
	<comment type="block">/*    result_len = self_len + count * (to_len-from_len) */</comment>
	<expr_stmt><expr><name>product</name> = <call><name>count</name> * <argument_list>(<argument><expr><name>to_len</name>-<name>from_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>product</name> / (<name>to_len</name>-<name>from_len</name>) != <name>count</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_OverflowError</name></expr></argument>, <argument><expr>"replace string is too long"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>
	<expr_stmt><expr><name>result_len</name> = <name>self_len</name> + <name>product</name></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>result_len</name> &lt; 0</expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_OverflowError</name></expr></argument>, <argument><expr>"replace string is too long"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>

	<if>if <condition>( <expr>(<name>result</name> = (<name>PyStringObject</name> *)
	      <call><name>PyString_FromStringAndSize</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>result_len</name></expr></argument>)</argument_list></call>) == <name>NULL</name></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<expr_stmt><expr><name>result_s</name> = <call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>start</name> = <name>self_s</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>end</name> = <name>self_s</name> + <name>self_len</name></expr>;</expr_stmt>
	<while>while <condition>(<expr><name>count</name>-- &gt; 0</expr>)</condition> <block>{
		<expr_stmt><expr><name>offset</name> = <call><name>findstring</name><argument_list>(<argument><expr><name>start</name></expr></argument>, <argument><expr><name>end</name>-<name>start</name></expr></argument>,
				    <argument><expr><name>from_s</name></expr></argument>, <argument><expr><name>from_len</name></expr></argument>,
				    <argument><expr>0</expr></argument>, <argument><expr><name>end</name>-<name>start</name></expr></argument>, <argument><expr><name>FORWARD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>offset</name> == -1</expr>)</condition><then>
			<break>break;</break></then></if>
		<expr_stmt><expr><name>next</name> = <name>start</name>+<name>offset</name></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>next</name> == <name>start</name></expr>)</condition><then> <block>{
			<comment type="block">/* replace with the 'to' */</comment>
			<expr_stmt><expr><call><name>Py_MEMCPY</name><argument_list>(<argument><expr><name>result_s</name></expr></argument>, <argument><expr><name>to_s</name></expr></argument>, <argument><expr><name>to_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>result_s</name> += <name>to_len</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>start</name> += <name>from_len</name></expr>;</expr_stmt>
		}</block></then> <else>else <block>{
			<comment type="block">/* copy the unchanged old then the 'to' */</comment>
			<expr_stmt><expr><call><name>Py_MEMCPY</name><argument_list>(<argument><expr><name>result_s</name></expr></argument>, <argument><expr><name>start</name></expr></argument>, <argument><expr><name>next</name>-<name>start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>result_s</name> += (<name>next</name>-<name>start</name>)</expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Py_MEMCPY</name><argument_list>(<argument><expr><name>result_s</name></expr></argument>, <argument><expr><name>to_s</name></expr></argument>, <argument><expr><name>to_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>result_s</name> += <name>to_len</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>start</name> = <name>next</name>+<name>from_len</name></expr>;</expr_stmt>
		}</block></else></if>
	}</block></while>
	<comment type="block">/* Copy the remainder of the remaining string */</comment>
	<expr_stmt><expr><call><name>Py_MEMCPY</name><argument_list>(<argument><expr><name>result_s</name></expr></argument>, <argument><expr><name>start</name></expr></argument>, <argument><expr><name>end</name>-<name>start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>result</name></expr>;</return>
}</block>


<macro><name>Py_LOCAL</name><argument_list>(<argument>PyStringObject *</argument>)</argument_list></macro>
<macro><name>replace</name><argument_list>(<argument>PyStringObject *self</argument>,
	<argument>const char *from_s</argument>, <argument>Py_ssize_t from_len</argument>,
	<argument>const char *to_s</argument>, <argument>Py_ssize_t to_len</argument>,
	<argument>Py_ssize_t maxcount</argument>)</argument_list></macro>
<block>{
	<if>if <condition>(<expr><name>maxcount</name> &lt; 0</expr>)</condition><then> <block>{
		<expr_stmt><expr><name>maxcount</name> = <name>PY_SSIZE_T_MAX</name></expr>;</expr_stmt>
	}</block></then> <else>else <if>if <condition>(<expr><name>maxcount</name> == 0 || <call><name>PyString_GET_SIZE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call> == 0</expr>)</condition><then> <block>{
		<comment type="block">/* nothing to do; return the original string */</comment>
		<return>return <expr><call><name>return_self</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</return>
	}</block></then></if></else></if>

	<if>if <condition>(<expr><name>maxcount</name> == 0 ||
	    (<name>from_len</name> == 0 &amp;&amp; <name>to_len</name> == 0)</expr>)</condition><then> <block>{
		<comment type="block">/* nothing to do; return the original string */</comment>
		<return>return <expr><call><name>return_self</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</return>
	}</block></then></if>

	<comment type="block">/* Handle zero-length special cases */</comment>

	<if>if <condition>(<expr><name>from_len</name> == 0</expr>)</condition><then> <block>{
		<comment type="block">/* insert the 'to' string everywhere.   */</comment>
		<comment type="block">/*    &gt;&gt;&gt; "Python".replace("", ".")     */</comment>
		<comment type="block">/*    '.P.y.t.h.o.n.'                   */</comment>
		<return>return <expr><call><name>replace_interleave</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>to_s</name></expr></argument>, <argument><expr><name>to_len</name></expr></argument>, <argument><expr><name>maxcount</name></expr></argument>)</argument_list></call></expr>;</return>
	}</block></then></if>

	<comment type="block">/* Except for "".replace("", "A") == "A" there is no way beyond this */</comment>
	<comment type="block">/* point for an empty self string to generate a non-empty string */</comment>
	<comment type="block">/* Special case so the remaining code always gets a non-empty string */</comment>
	<if>if <condition>(<expr><call><name>PyString_GET_SIZE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call> == 0</expr>)</condition><then> <block>{
		<return>return <expr><call><name>return_self</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</return>
	}</block></then></if>

	<if>if <condition>(<expr><name>to_len</name> == 0</expr>)</condition><then> <block>{
		<comment type="block">/* delete all occurances of 'from' string */</comment>
		<if>if <condition>(<expr><name>from_len</name> == 1</expr>)</condition><then> <block>{
			<return>return <expr><call><name>replace_delete_single_character</name><argument_list>(
				<argument><expr><name>self</name></expr></argument>, <argument><expr><name><name>from_s</name><index>[<expr>0</expr>]</index></name></expr></argument>, <argument><expr><name>maxcount</name></expr></argument>)</argument_list></call></expr>;</return>
		}</block></then> <else>else <block>{
			<return>return <expr><call><name>replace_delete_substring</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>from_s</name></expr></argument>, <argument><expr><name>from_len</name></expr></argument>, <argument><expr><name>maxcount</name></expr></argument>)</argument_list></call></expr>;</return>
		}</block></else></if>
	}</block></then></if>

	<comment type="block">/* Handle special case where both strings have the same length */</comment>

	<if>if <condition>(<expr><name>from_len</name> == <name>to_len</name></expr>)</condition><then> <block>{
		<if>if <condition>(<expr><name>from_len</name> == 1</expr>)</condition><then> <block>{
			<return>return <expr><call><name>replace_single_character_in_place</name><argument_list>(
				<argument><expr><name>self</name></expr></argument>,
				<argument><expr><name><name>from_s</name><index>[<expr>0</expr>]</index></name></expr></argument>,
				<argument><expr><name><name>to_s</name><index>[<expr>0</expr>]</index></name></expr></argument>,
				<argument><expr><name>maxcount</name></expr></argument>)</argument_list></call></expr>;</return>
		}</block></then> <else>else <block>{
			<return>return <expr><call><name>replace_substring_in_place</name><argument_list>(
				<argument><expr><name>self</name></expr></argument>, <argument><expr><name>from_s</name></expr></argument>, <argument><expr><name>from_len</name></expr></argument>, <argument><expr><name>to_s</name></expr></argument>, <argument><expr><name>to_len</name></expr></argument>, <argument><expr><name>maxcount</name></expr></argument>)</argument_list></call></expr>;</return>
		}</block></else></if>
	}</block></then></if>

	<comment type="block">/* Otherwise use the more generic algorithms */</comment>
	<if>if <condition>(<expr><name>from_len</name> == 1</expr>)</condition><then> <block>{
		<return>return <expr><call><name>replace_single_character</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name><name>from_s</name><index>[<expr>0</expr>]</index></name></expr></argument>,
						<argument><expr><name>to_s</name></expr></argument>, <argument><expr><name>to_len</name></expr></argument>, <argument><expr><name>maxcount</name></expr></argument>)</argument_list></call></expr>;</return>
	}</block></then> <else>else <block>{
		<comment type="block">/* len('from')&gt;=2, len('to')&gt;=1 */</comment>
		<return>return <expr><call><name>replace_substring</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>from_s</name></expr></argument>, <argument><expr><name>from_len</name></expr></argument>, <argument><expr><name>to_s</name></expr></argument>, <argument><expr><name>to_len</name></expr></argument>, <argument><expr><name>maxcount</name></expr></argument>)</argument_list></call></expr>;</return>
	}</block></else></if>
}</block>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>replace__doc__</name></expr></argument>,
<argument><expr>"S.replace (old, new[, count]) -&gt; string\n\
\n\
Return a copy of string S with all occurrences of substring\n\
old replaced by new.  If the optional argument count is\n\
given, only the first count occurrences are replaced."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>string_replace</name><parameter_list>(<param><decl><type><name>PyStringObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>count</name> <init>= <expr>-1</expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>from</name></decl>, *<decl><type ref="prev"/><name>to</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>from_s</name></decl>, *<decl><type ref="prev"/><name>to_s</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>from_len</name></decl>, <decl><type ref="prev"/><name>to_len</name></decl>;</decl_stmt>

	<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"OO|n:replace"</expr></argument>, <argument><expr>&amp;<name>from</name></expr></argument>, <argument><expr>&amp;<name>to</name></expr></argument>, <argument><expr>&amp;<name>count</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>

	<if>if <condition>(<expr><call><name>PyString_Check</name><argument_list>(<argument><expr><name>from</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>from_s</name> = <call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>from</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>from_len</name> = <call><name>PyString_GET_SIZE</name><argument_list>(<argument><expr><name>from</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>Py_USING_UNICODE</name></cpp:ifdef>
	<if>if <condition>(<expr><call><name>PyUnicode_Check</name><argument_list>(<argument><expr><name>from</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><call><name>PyUnicode_Replace</name><argument_list>(<argument><expr>(<name>PyObject</name> *)<name>self</name></expr></argument>,
					 <argument><expr><name>from</name></expr></argument>, <argument><expr><name>to</name></expr></argument>, <argument><expr><name>count</name></expr></argument>)</argument_list></call></expr>;</return></then>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<else>else <if>if <condition>(<expr><call><name>PyObject_AsCharBuffer</name><argument_list>(<argument><expr><name>from</name></expr></argument>, <argument><expr>&amp;<name>from_s</name></expr></argument>, <argument><expr>&amp;<name>from_len</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if></else></if>

	<if>if <condition>(<expr><call><name>PyString_Check</name><argument_list>(<argument><expr><name>to</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>to_s</name> = <call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>to</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>to_len</name> = <call><name>PyString_GET_SIZE</name><argument_list>(<argument><expr><name>to</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>Py_USING_UNICODE</name></cpp:ifdef>
	<else>else <if>if <condition>(<expr><call><name>PyUnicode_Check</name><argument_list>(<argument><expr><name>to</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><call><name>PyUnicode_Replace</name><argument_list>(<argument><expr>(<name>PyObject</name> *)<name>self</name></expr></argument>,
					 <argument><expr><name>from</name></expr></argument>, <argument><expr><name>to</name></expr></argument>, <argument><expr><name>count</name></expr></argument>)</argument_list></call></expr>;</return></then>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<else>else <if>if <condition>(<expr><call><name>PyObject_AsCharBuffer</name><argument_list>(<argument><expr><name>to</name></expr></argument>, <argument><expr>&amp;<name>to_s</name></expr></argument>, <argument><expr>&amp;<name>to_len</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if></else></if></else></if>

	<return>return <expr>(<name>PyObject</name> *)<call><name>replace</name><argument_list>(<argument><expr>(<name>PyStringObject</name> *) <name>self</name></expr></argument>,
				   <argument><expr><name>from_s</name></expr></argument>, <argument><expr><name>from_len</name></expr></argument>,
				   <argument><expr><name>to_s</name></expr></argument>, <argument><expr><name>to_len</name></expr></argument>, <argument><expr><name>count</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<comment type="block">/** End DALKE **/</comment>

<comment type="block">/* Matches the end (direction &gt;= 0) or start (direction &lt; 0) of self
 * against substr, using the start and end arguments. Returns
 * -1 on error, 0 if not found and 1 if found.
 */</comment>
<macro><name>Py_LOCAL</name><argument_list>(<argument>int</argument>)</argument_list></macro>
<macro><name>_string_tailmatch</name><argument_list>(<argument>PyStringObject *self</argument>, <argument>PyObject *substr</argument>, <argument>Py_ssize_t start</argument>,
		  <argument>Py_ssize_t end</argument>, <argument>int direction</argument>)</argument_list></macro>
<block>{
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>len</name> <init>= <expr><call><name>PyString_GET_SIZE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>slen</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name>*</type> <name>sub</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name>*</type> <name>str</name></decl>;</decl_stmt>

	<if>if <condition>(<expr><call><name>PyString_Check</name><argument_list>(<argument><expr><name>substr</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>sub</name> = <call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>substr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>slen</name> = <call><name>PyString_GET_SIZE</name><argument_list>(<argument><expr><name>substr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>Py_USING_UNICODE</name></cpp:ifdef>
	<else>else <if>if <condition>(<expr><call><name>PyUnicode_Check</name><argument_list>(<argument><expr><name>substr</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><call><name>PyUnicode_Tailmatch</name><argument_list>(<argument><expr>(<name>PyObject</name> *)<name>self</name></expr></argument>,
					   <argument><expr><name>substr</name></expr></argument>, <argument><expr><name>start</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><name>direction</name></expr></argument>)</argument_list></call></expr>;</return></then>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<else>else <if>if <condition>(<expr><call><name>PyObject_AsCharBuffer</name><argument_list>(<argument><expr><name>substr</name></expr></argument>, <argument><expr>&amp;<name>sub</name></expr></argument>, <argument><expr>&amp;<name>slen</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr>-1</expr>;</return></then></if></else></if></else></if>
	<expr_stmt><expr><name>str</name> = <call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>string_adjust_indices</name><argument_list>(<argument><expr>&amp;<name>start</name></expr></argument>, <argument><expr>&amp;<name>end</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if>if <condition>(<expr><name>direction</name> &lt; 0</expr>)</condition><then> <block>{
		<comment type="block">/* startswith */</comment>
		<if>if <condition>(<expr><name>start</name>+<name>slen</name> &gt; <name>len</name></expr>)</condition><then>
			<return>return <expr>0</expr>;</return></then></if>
	}</block></then> <else>else <block>{
		<comment type="block">/* endswith */</comment>
		<if>if <condition>(<expr><name>end</name>-<name>start</name> &lt; <name>slen</name> || <name>start</name> &gt; <name>len</name></expr>)</condition><then>
			<return>return <expr>0</expr>;</return></then></if>

		<if>if <condition>(<expr><name>end</name>-<name>slen</name> &gt; <name>start</name></expr>)</condition><then>
			<expr_stmt><expr><name>start</name> = <name>end</name> - <name>slen</name></expr>;</expr_stmt></then></if>
	}</block></else></if>
	<if>if <condition>(<expr><name>end</name>-<name>start</name> &gt;= <name>slen</name></expr>)</condition><then>
		<return>return <expr>! <call><name>memcmp</name><argument_list>(<argument><expr><name>str</name>+<name>start</name></expr></argument>, <argument><expr><name>sub</name></expr></argument>, <argument><expr><name>slen</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
	<return>return <expr>0</expr>;</return>
}</block>


<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>startswith__doc__</name></expr></argument>,
<argument><expr>"S.startswith(prefix[, start[, end]]) -&gt; bool\n\
\n\
Return True if S starts with the specified prefix, False otherwise.\n\
With optional start, test S beginning at that position.\n\
With optional end, stop comparing S at that position.\n\
prefix can also be a tuple of strings to try."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>string_startswith</name><parameter_list>(<param><decl><type><name>PyStringObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>start</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>end</name> <init>= <expr><name>PY_SSIZE_T_MAX</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>subobj</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>result</name></decl>;</decl_stmt>

	<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"O|O&amp;O&amp;:startswith"</expr></argument>, <argument><expr>&amp;<name>subobj</name></expr></argument>,
		<argument><expr><name>_PyEval_SliceIndex</name></expr></argument>, <argument><expr>&amp;<name>start</name></expr></argument>, <argument><expr><name>_PyEval_SliceIndex</name></expr></argument>, <argument><expr>&amp;<name>end</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<if>if <condition>(<expr><call><name>PyTuple_Check</name><argument_list>(<argument><expr><name>subobj</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>i</name></decl>;</decl_stmt>
		<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <call><name>PyTuple_GET_SIZE</name><argument_list>(<argument><expr><name>subobj</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
			<expr_stmt><expr><name>result</name> = <call><name>_string_tailmatch</name><argument_list>(<argument><expr><name>self</name></expr></argument>,
					<argument><expr><call><name>PyTuple_GET_ITEM</name><argument_list>(<argument><expr><name>subobj</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>,
					<argument><expr><name>start</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr>-1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><name>result</name> == -1</expr>)</condition><then>
				<return>return <expr><name>NULL</name></expr>;</return></then>
			<else>else <if>if <condition>(<expr><name>result</name></expr>)</condition><then> <block>{
				<expr_stmt><expr><name>Py_RETURN_TRUE</name></expr>;</expr_stmt>
			}</block></then></if></else></if>
		}</block></for>
		<expr_stmt><expr><name>Py_RETURN_FALSE</name></expr>;</expr_stmt>
	}</block></then></if>
	<expr_stmt><expr><name>result</name> = <call><name>_string_tailmatch</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>subobj</name></expr></argument>, <argument><expr><name>start</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr>-1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>result</name> == -1</expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then>
	<else>else
		<return>return <expr><call><name>PyBool_FromLong</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</return></else></if>
}</block></function>


<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>endswith__doc__</name></expr></argument>,
<argument><expr>"S.endswith(suffix[, start[, end]]) -&gt; bool\n\
\n\
Return True if S ends with the specified suffix, False otherwise.\n\
With optional start, test S beginning at that position.\n\
With optional end, stop comparing S at that position.\n\
suffix can also be a tuple of strings to try."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>string_endswith</name><parameter_list>(<param><decl><type><name>PyStringObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>start</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>end</name> <init>= <expr><name>PY_SSIZE_T_MAX</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>subobj</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>result</name></decl>;</decl_stmt>

	<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"O|O&amp;O&amp;:endswith"</expr></argument>, <argument><expr>&amp;<name>subobj</name></expr></argument>,
		<argument><expr><name>_PyEval_SliceIndex</name></expr></argument>, <argument><expr>&amp;<name>start</name></expr></argument>, <argument><expr><name>_PyEval_SliceIndex</name></expr></argument>, <argument><expr>&amp;<name>end</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<if>if <condition>(<expr><call><name>PyTuple_Check</name><argument_list>(<argument><expr><name>subobj</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>i</name></decl>;</decl_stmt>
		<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <call><name>PyTuple_GET_SIZE</name><argument_list>(<argument><expr><name>subobj</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
			<expr_stmt><expr><name>result</name> = <call><name>_string_tailmatch</name><argument_list>(<argument><expr><name>self</name></expr></argument>,
					<argument><expr><call><name>PyTuple_GET_ITEM</name><argument_list>(<argument><expr><name>subobj</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>,
					<argument><expr><name>start</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr>+1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><name>result</name> == -1</expr>)</condition><then>
				<return>return <expr><name>NULL</name></expr>;</return></then>
			<else>else <if>if <condition>(<expr><name>result</name></expr>)</condition><then> <block>{
				<expr_stmt><expr><name>Py_RETURN_TRUE</name></expr>;</expr_stmt>
			}</block></then></if></else></if>
		}</block></for>
		<expr_stmt><expr><name>Py_RETURN_FALSE</name></expr>;</expr_stmt>
	}</block></then></if>
	<expr_stmt><expr><name>result</name> = <call><name>_string_tailmatch</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>subobj</name></expr></argument>, <argument><expr><name>start</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr>+1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>result</name> == -1</expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then>
	<else>else
		<return>return <expr><call><name>PyBool_FromLong</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</return></else></if>
}</block></function>


<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>encode__doc__</name></expr></argument>,
<argument><expr>"S.encode([encoding[,errors]]) -&gt; object\n\
\n\
Encodes S using the codec registered for encoding. encoding defaults\n\
to the default encoding. errors may be given to set a different error\n\
handling scheme. Default is 'strict' meaning that encoding errors raise\n\
a UnicodeEncodeError. Other possible values are 'ignore', 'replace' and\n\
'xmlcharrefreplace' as well as any other name registered with\n\
codecs.register_error that is able to handle UnicodeEncodeErrors."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>string_encode</name><parameter_list>(<param><decl><type><name>PyStringObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>char</name> *</type><name>encoding</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> *</type><name>errors</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PyObject</name> *</type><name>v</name></decl>;</decl_stmt>

    <if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"|ss:encode"</expr></argument>, <argument><expr>&amp;<name>encoding</name></expr></argument>, <argument><expr>&amp;<name>errors</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>NULL</name></expr>;</return></then></if>
    <expr_stmt><expr><name>v</name> = <call><name>PyString_AsEncodedObject</name><argument_list>(<argument><expr>(<name>PyObject</name> *)<name>self</name></expr></argument>, <argument><expr><name>encoding</name></expr></argument>, <argument><expr><name>errors</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>v</name> == <name>NULL</name></expr>)</condition><then>
        <goto>goto <name>onError</name>;</goto></then></if>
    <if>if <condition>(<expr>!<call><name>PyString_Check</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call> &amp;&amp; !<call><name>PyUnicode_Check</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
                     <argument><expr>"encoder did not return a string/unicode object "
                     "(type=%.400s)"</expr></argument>,
                     <argument><expr><call><name>Py_TYPE</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call>-&gt;<name>tp_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>NULL</name></expr>;</return>
    }</block></then></if>
    <return>return <expr><name>v</name></expr>;</return>

 <label><name>onError</name>:</label>
    <return>return <expr><name>NULL</name></expr>;</return>
}</block></function>


<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>decode__doc__</name></expr></argument>,
<argument><expr>"S.decode([encoding[,errors]]) -&gt; object\n\
\n\
Decodes S using the codec registered for encoding. encoding defaults\n\
to the default encoding. errors may be given to set a different error\n\
handling scheme. Default is 'strict' meaning that encoding errors raise\n\
a UnicodeDecodeError. Other possible values are 'ignore' and 'replace'\n\
as well as any other name registered with codecs.register_error that is\n\
able to handle UnicodeDecodeErrors."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>string_decode</name><parameter_list>(<param><decl><type><name>PyStringObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>char</name> *</type><name>encoding</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> *</type><name>errors</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PyObject</name> *</type><name>v</name></decl>;</decl_stmt>

    <if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"|ss:decode"</expr></argument>, <argument><expr>&amp;<name>encoding</name></expr></argument>, <argument><expr>&amp;<name>errors</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>NULL</name></expr>;</return></then></if>
    <expr_stmt><expr><name>v</name> = <call><name>PyString_AsDecodedObject</name><argument_list>(<argument><expr>(<name>PyObject</name> *)<name>self</name></expr></argument>, <argument><expr><name>encoding</name></expr></argument>, <argument><expr><name>errors</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>v</name> == <name>NULL</name></expr>)</condition><then>
        <goto>goto <name>onError</name>;</goto></then></if>
    <if>if <condition>(<expr>!<call><name>PyString_Check</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call> &amp;&amp; !<call><name>PyUnicode_Check</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
                     <argument><expr>"decoder did not return a string/unicode object "
                     "(type=%.400s)"</expr></argument>,
                     <argument><expr><call><name>Py_TYPE</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call>-&gt;<name>tp_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>NULL</name></expr>;</return>
    }</block></then></if>
    <return>return <expr><name>v</name></expr>;</return>

 <label><name>onError</name>:</label>
    <return>return <expr><name>NULL</name></expr>;</return>
}</block></function>


<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>expandtabs__doc__</name></expr></argument>,
<argument><expr>"S.expandtabs([tabsize]) -&gt; string\n\
\n\
Return a copy of S where all tab characters are expanded using spaces.\n\
If tabsize is not given, a tab size of 8 characters is assumed."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name>*</type>
<name>string_expandtabs</name><parameter_list>(<param><decl><type><name>PyStringObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>e</name></decl>, *<decl><type ref="prev"/><name>p</name></decl>, *<decl><type ref="prev"/><name>qe</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> *</type><name>q</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>, <decl><type ref="prev"/><name>incr</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PyObject</name> *</type><name>u</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>tabsize</name> <init>= <expr>8</expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"|i:expandtabs"</expr></argument>, <argument><expr>&amp;<name>tabsize</name></expr></argument>)</argument_list></call></expr>)</condition><then>
	<return>return <expr><name>NULL</name></expr>;</return></then></if>

    <comment type="block">/* First pass: determine size of output string */</comment>
    <expr_stmt><expr><name>i</name> = 0</expr>;</expr_stmt> <comment type="block">/* chars up to and including most recent \n or \r */</comment>
    <expr_stmt><expr><name>j</name> = 0</expr>;</expr_stmt> <comment type="block">/* chars since most recent \n or \r (use in tab calculations) */</comment>
    <expr_stmt><expr><name>e</name> = <call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call> + <call><name>PyString_GET_SIZE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* end of input */</comment>
    <for>for (<init><expr><name>p</name> = <call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</init> <condition><expr><name>p</name> &lt; <name>e</name></expr>;</condition> <incr><expr><name>p</name>++</expr></incr>)
        <if>if <condition>(<expr>*<name>p</name> == '\t'</expr>)</condition><then> <block>{
	    <if>if <condition>(<expr><name>tabsize</name> &gt; 0</expr>)</condition><then> <block>{
		<expr_stmt><expr><name>incr</name> = <name>tabsize</name> - (<name>j</name> % <name>tabsize</name>)</expr>;</expr_stmt>
		<if>if <condition>(<expr><name>j</name> &gt; <name>PY_SSIZE_T_MAX</name> - <name>incr</name></expr>)</condition><then>
		    <goto>goto <name>overflow1</name>;</goto></then></if>
		<expr_stmt><expr><name>j</name> += <name>incr</name></expr>;</expr_stmt>
            }</block></then></if>
	}</block></then>
        <else>else <block>{
	    <if>if <condition>(<expr><name>j</name> &gt; <name>PY_SSIZE_T_MAX</name> - 1</expr>)</condition><then>
		<goto>goto <name>overflow1</name>;</goto></then></if>
            <expr_stmt><expr><name>j</name>++</expr>;</expr_stmt>
            <if>if <condition>(<expr>*<name>p</name> == '\n' || *<name>p</name> == '\r'</expr>)</condition><then> <block>{
		<if>if <condition>(<expr><name>i</name> &gt; <name>PY_SSIZE_T_MAX</name> - <name>j</name></expr>)</condition><then>
		    <goto>goto <name>overflow1</name>;</goto></then></if>
                <expr_stmt><expr><name>i</name> += <name>j</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>j</name> = 0</expr>;</expr_stmt>
            }</block></then></if>
        }</block></else></if></for>

    <if>if <condition>(<expr><name>i</name> &gt; <name>PY_SSIZE_T_MAX</name> - <name>j</name></expr>)</condition><then>
	<goto>goto <name>overflow1</name>;</goto></then></if>

    <comment type="block">/* Second pass: create output string and fill it */</comment>
    <expr_stmt><expr><name>u</name> = <call><name>PyString_FromStringAndSize</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>i</name> + <name>j</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr>!<name>u</name></expr>)</condition><then>
        <return>return <expr><name>NULL</name></expr>;</return></then></if>

    <expr_stmt><expr><name>j</name> = 0</expr>;</expr_stmt> <comment type="block">/* same as in first pass */</comment>
    <expr_stmt><expr><name>q</name> = <call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>u</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* next output char */</comment>
    <expr_stmt><expr><name>qe</name> = <call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>u</name></expr></argument>)</argument_list></call> + <call><name>PyString_GET_SIZE</name><argument_list>(<argument><expr><name>u</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* end of output */</comment>

    <for>for (<init><expr><name>p</name> = <call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</init> <condition><expr><name>p</name> &lt; <name>e</name></expr>;</condition> <incr><expr><name>p</name>++</expr></incr>)
        <if>if <condition>(<expr>*<name>p</name> == '\t'</expr>)</condition><then> <block>{
	    <if>if <condition>(<expr><name>tabsize</name> &gt; 0</expr>)</condition><then> <block>{
		<expr_stmt><expr><name>i</name> = <name>tabsize</name> - (<name>j</name> % <name>tabsize</name>)</expr>;</expr_stmt>
		<expr_stmt><expr><name>j</name> += <name>i</name></expr>;</expr_stmt>
		<while>while <condition>(<expr><name>i</name>--</expr>)</condition> <block>{
		    <if>if <condition>(<expr><name>q</name> &gt;= <name>qe</name></expr>)</condition><then>
			<goto>goto <name>overflow2</name>;</goto></then></if>
		    <expr_stmt><expr>*<name>q</name>++ = ' '</expr>;</expr_stmt>
		}</block></while>
	    }</block></then></if>
	}</block></then>
	<else>else <block>{
	    <if>if <condition>(<expr><name>q</name> &gt;= <name>qe</name></expr>)</condition><then>
		<goto>goto <name>overflow2</name>;</goto></then></if>
	    <expr_stmt><expr>*<name>q</name>++ = *<name>p</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>j</name>++</expr>;</expr_stmt>
            <if>if <condition>(<expr>*<name>p</name> == '\n' || *<name>p</name> == '\r'</expr>)</condition><then>
                <expr_stmt><expr><name>j</name> = 0</expr>;</expr_stmt></then></if>
        }</block></else></if></for>

    <return>return <expr><name>u</name></expr>;</return>

  <label><name>overflow2</name>:</label>
    <expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>u</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <label><name>overflow1</name>:</label>
    <expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_OverflowError</name></expr></argument>, <argument><expr>"new string is too long"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>NULL</name></expr>;</return>
}</block></function>

<macro><name>Py_LOCAL_INLINE</name><argument_list>(<argument>PyObject *</argument>)</argument_list></macro>
<macro><name>pad</name><argument_list>(<argument>PyStringObject *self</argument>, <argument>Py_ssize_t left</argument>, <argument>Py_ssize_t right</argument>, <argument>char fill</argument>)</argument_list></macro>
<block>{
    <decl_stmt><decl><type><name>PyObject</name> *</type><name>u</name></decl>;</decl_stmt>

    <if>if <condition>(<expr><name>left</name> &lt; 0</expr>)</condition><then>
        <expr_stmt><expr><name>left</name> = 0</expr>;</expr_stmt></then></if>
    <if>if <condition>(<expr><name>right</name> &lt; 0</expr>)</condition><then>
        <expr_stmt><expr><name>right</name> = 0</expr>;</expr_stmt></then></if>

    <if>if <condition>(<expr><name>left</name> == 0 &amp;&amp; <name>right</name> == 0 &amp;&amp; <call><name>PyString_CheckExact</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr>(<name>PyObject</name> *)<name>self</name></expr>;</return>
    }</block></then></if>

    <expr_stmt><expr><name>u</name> = <call><name>PyString_FromStringAndSize</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>,
				   <argument><expr><name>left</name> + <call><name>PyString_GET_SIZE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call> + <name>right</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>u</name></expr>)</condition><then> <block>{
        <if>if <condition>(<expr><name>left</name></expr>)</condition><then>
            <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>u</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>fill</name></expr></argument>, <argument><expr><name>left</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
        <expr_stmt><expr><call><name>Py_MEMCPY</name><argument_list>(<argument><expr><call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>u</name></expr></argument>)</argument_list></call> + <name>left</name></expr></argument>,
	       <argument><expr><call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></argument>,
	       <argument><expr><call><name>PyString_GET_SIZE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>right</name></expr>)</condition><then>
            <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>u</name></expr></argument>)</argument_list></call> + <name>left</name> + <call><name>PyString_GET_SIZE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></argument>,
		   <argument><expr><name>fill</name></expr></argument>, <argument><expr><name>right</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
    }</block></then></if>

    <return>return <expr><name>u</name></expr>;</return>
}</block>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>ljust__doc__</name></expr></argument>,
<argument><expr>"S.ljust(width[, fillchar]) -&gt; string\n"
"\n"
"Return S left-justified in a string of length width. Padding is\n"
"done using the specified fill character (default is a space)."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>string_ljust</name><parameter_list>(<param><decl><type><name>PyStringObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>width</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type> <name>fillchar</name> <init>= <expr>' '</expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"n|c:ljust"</expr></argument>, <argument><expr>&amp;<name>width</name></expr></argument>, <argument><expr>&amp;<name>fillchar</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>NULL</name></expr>;</return></then></if>

    <if>if <condition>(<expr><call><name>PyString_GET_SIZE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call> &gt;= <name>width</name> &amp;&amp; <call><name>PyString_CheckExact</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr>(<name>PyObject</name>*) <name>self</name></expr>;</return>
    }</block></then></if>

    <return>return <expr><call><name>pad</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>width</name> - <call><name>PyString_GET_SIZE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>fillchar</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>


<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>rjust__doc__</name></expr></argument>,
<argument><expr>"S.rjust(width[, fillchar]) -&gt; string\n"
"\n"
"Return S right-justified in a string of length width. Padding is\n"
"done using the specified fill character (default is a space)"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>string_rjust</name><parameter_list>(<param><decl><type><name>PyStringObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>width</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type> <name>fillchar</name> <init>= <expr>' '</expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"n|c:rjust"</expr></argument>, <argument><expr>&amp;<name>width</name></expr></argument>, <argument><expr>&amp;<name>fillchar</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>NULL</name></expr>;</return></then></if>

    <if>if <condition>(<expr><call><name>PyString_GET_SIZE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call> &gt;= <name>width</name> &amp;&amp; <call><name>PyString_CheckExact</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr>(<name>PyObject</name>*) <name>self</name></expr>;</return>
    }</block></then></if>

    <return>return <expr><call><name>pad</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>width</name> - <call><name>PyString_GET_SIZE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>fillchar</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>


<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>center__doc__</name></expr></argument>,
<argument><expr>"S.center(width[, fillchar]) -&gt; string\n"
"\n"
"Return S centered in a string of length width. Padding is\n"
"done using the specified fill character (default is a space)"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>string_center</name><parameter_list>(<param><decl><type><name>PyStringObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>marg</name></decl>, <decl><type ref="prev"/><name>left</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>width</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type> <name>fillchar</name> <init>= <expr>' '</expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"n|c:center"</expr></argument>, <argument><expr>&amp;<name>width</name></expr></argument>, <argument><expr>&amp;<name>fillchar</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>NULL</name></expr>;</return></then></if>

    <if>if <condition>(<expr><call><name>PyString_GET_SIZE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call> &gt;= <name>width</name> &amp;&amp; <call><name>PyString_CheckExact</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr>(<name>PyObject</name>*) <name>self</name></expr>;</return>
    }</block></then></if>

    <expr_stmt><expr><name>marg</name> = <name>width</name> - <call><name>PyString_GET_SIZE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>left</name> = <name>marg</name> / 2 + (<name>marg</name> &amp; <name>width</name> &amp; 1)</expr>;</expr_stmt>

    <return>return <expr><call><name>pad</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>left</name></expr></argument>, <argument><expr><name>marg</name> - <name>left</name></expr></argument>, <argument><expr><name>fillchar</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>zfill__doc__</name></expr></argument>,
<argument><expr>"S.zfill(width) -&gt; string\n"
"\n"
"Pad a numeric string S with zeros on the left, to fill a field\n"
"of the specified width.  The string S is never truncated."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>string_zfill</name><parameter_list>(<param><decl><type><name>PyStringObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>fill</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PyObject</name> *</type><name>s</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> *</type><name>p</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>width</name></decl>;</decl_stmt>

    <if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"n:zfill"</expr></argument>, <argument><expr>&amp;<name>width</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>NULL</name></expr>;</return></then></if>

    <if>if <condition>(<expr><call><name>PyString_GET_SIZE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call> &gt;= <name>width</name></expr>)</condition><then> <block>{
        <if>if <condition>(<expr><call><name>PyString_CheckExact</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr>(<name>PyObject</name>*) <name>self</name></expr>;</return>
        }</block></then>
        <else>else
            <return>return <expr><call><name>PyString_FromStringAndSize</name><argument_list>(
                <argument><expr><call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></argument>,
                <argument><expr><call><name>PyString_GET_SIZE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></argument>
            )</argument_list></call></expr>;</return></else></if>
    }</block></then></if>

    <expr_stmt><expr><name>fill</name> = <name>width</name> - <call><name>PyString_GET_SIZE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>s</name> = <call><name>pad</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>fill</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>'0'</expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr><name>s</name> == <name>NULL</name></expr>)</condition><then>
        <return>return <expr><name>NULL</name></expr>;</return></then></if>

    <expr_stmt><expr><name>p</name> = <call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name><name>p</name><index>[<expr><name>fill</name></expr>]</index></name> == '+' || <name><name>p</name><index>[<expr><name>fill</name></expr>]</index></name> == '-'</expr>)</condition><then> <block>{
        <comment type="block">/* move sign to beginning of string */</comment>
        <expr_stmt><expr><name><name>p</name><index>[<expr>0</expr>]</index></name> = <name><name>p</name><index>[<expr><name>fill</name></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>p</name><index>[<expr><name>fill</name></expr>]</index></name> = '0'</expr>;</expr_stmt>
    }</block></then></if>

    <return>return <expr>(<name>PyObject</name>*) <name>s</name></expr>;</return>
}</block></function>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>isspace__doc__</name></expr></argument>,
<argument><expr>"S.isspace() -&gt; bool\n\
\n\
Return True if all characters in S are whitespace\n\
and there is at least one character in S, False otherwise."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name>*</type>
<name>string_isspace</name><parameter_list>(<param><decl><type><name>PyStringObject</name> *</type><name>self</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>register</name> <specifier>const</specifier> <name>unsigned</name> <name>char</name> *</type><name>p</name>
        <init>= <expr>(<name>unsigned</name> <name>char</name> *) <call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>register</name> <specifier>const</specifier> <name>unsigned</name> <name>char</name> *</type><name>e</name></decl>;</decl_stmt>

    <comment type="block">/* Shortcut for single character strings */</comment>
    <if>if <condition>(<expr><call><name>PyString_GET_SIZE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call> == 1 &amp;&amp;
	<call><name>isspace</name><argument_list>(<argument><expr>*<name>p</name></expr></argument>)</argument_list></call></expr>)</condition><then>
	<return>return <expr><call><name>PyBool_FromLong</name><argument_list>(<argument><expr>1</expr></argument>)</argument_list></call></expr>;</return></then></if>

    <comment type="block">/* Special case for empty strings */</comment>
    <if>if <condition>(<expr><call><name>PyString_GET_SIZE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call> == 0</expr>)</condition><then>
	<return>return <expr><call><name>PyBool_FromLong</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</return></then></if>

    <expr_stmt><expr><name>e</name> = <name>p</name> + <call><name>PyString_GET_SIZE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for (<init>;</init> <condition><expr><name>p</name> &lt; <name>e</name></expr>;</condition> <incr><expr><name>p</name>++</expr></incr>) <block>{
	<if>if <condition>(<expr>!<call><name>isspace</name><argument_list>(<argument><expr>*<name>p</name></expr></argument>)</argument_list></call></expr>)</condition><then>
	    <return>return <expr><call><name>PyBool_FromLong</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</return></then></if>
    }</block></for>
    <return>return <expr><call><name>PyBool_FromLong</name><argument_list>(<argument><expr>1</expr></argument>)</argument_list></call></expr>;</return>
}</block></function>


<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>isalpha__doc__</name></expr></argument>,
<argument><expr>"S.isalpha() -&gt; bool\n\
\n\
Return True if all characters in S are alphabetic\n\
and there is at least one character in S, False otherwise."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name>*</type>
<name>string_isalpha</name><parameter_list>(<param><decl><type><name>PyStringObject</name> *</type><name>self</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>register</name> <specifier>const</specifier> <name>unsigned</name> <name>char</name> *</type><name>p</name>
        <init>= <expr>(<name>unsigned</name> <name>char</name> *) <call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>register</name> <specifier>const</specifier> <name>unsigned</name> <name>char</name> *</type><name>e</name></decl>;</decl_stmt>

    <comment type="block">/* Shortcut for single character strings */</comment>
    <if>if <condition>(<expr><call><name>PyString_GET_SIZE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call> == 1 &amp;&amp;
	<call><name>isalpha</name><argument_list>(<argument><expr>*<name>p</name></expr></argument>)</argument_list></call></expr>)</condition><then>
	<return>return <expr><call><name>PyBool_FromLong</name><argument_list>(<argument><expr>1</expr></argument>)</argument_list></call></expr>;</return></then></if>

    <comment type="block">/* Special case for empty strings */</comment>
    <if>if <condition>(<expr><call><name>PyString_GET_SIZE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call> == 0</expr>)</condition><then>
	<return>return <expr><call><name>PyBool_FromLong</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</return></then></if>

    <expr_stmt><expr><name>e</name> = <name>p</name> + <call><name>PyString_GET_SIZE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for (<init>;</init> <condition><expr><name>p</name> &lt; <name>e</name></expr>;</condition> <incr><expr><name>p</name>++</expr></incr>) <block>{
	<if>if <condition>(<expr>!<call><name>isalpha</name><argument_list>(<argument><expr>*<name>p</name></expr></argument>)</argument_list></call></expr>)</condition><then>
	    <return>return <expr><call><name>PyBool_FromLong</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</return></then></if>
    }</block></for>
    <return>return <expr><call><name>PyBool_FromLong</name><argument_list>(<argument><expr>1</expr></argument>)</argument_list></call></expr>;</return>
}</block></function>


<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>isalnum__doc__</name></expr></argument>,
<argument><expr>"S.isalnum() -&gt; bool\n\
\n\
Return True if all characters in S are alphanumeric\n\
and there is at least one character in S, False otherwise."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name>*</type>
<name>string_isalnum</name><parameter_list>(<param><decl><type><name>PyStringObject</name> *</type><name>self</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>register</name> <specifier>const</specifier> <name>unsigned</name> <name>char</name> *</type><name>p</name>
        <init>= <expr>(<name>unsigned</name> <name>char</name> *) <call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>register</name> <specifier>const</specifier> <name>unsigned</name> <name>char</name> *</type><name>e</name></decl>;</decl_stmt>

    <comment type="block">/* Shortcut for single character strings */</comment>
    <if>if <condition>(<expr><call><name>PyString_GET_SIZE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call> == 1 &amp;&amp;
	<call><name>isalnum</name><argument_list>(<argument><expr>*<name>p</name></expr></argument>)</argument_list></call></expr>)</condition><then>
	<return>return <expr><call><name>PyBool_FromLong</name><argument_list>(<argument><expr>1</expr></argument>)</argument_list></call></expr>;</return></then></if>

    <comment type="block">/* Special case for empty strings */</comment>
    <if>if <condition>(<expr><call><name>PyString_GET_SIZE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call> == 0</expr>)</condition><then>
	<return>return <expr><call><name>PyBool_FromLong</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</return></then></if>

    <expr_stmt><expr><name>e</name> = <name>p</name> + <call><name>PyString_GET_SIZE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for (<init>;</init> <condition><expr><name>p</name> &lt; <name>e</name></expr>;</condition> <incr><expr><name>p</name>++</expr></incr>) <block>{
	<if>if <condition>(<expr>!<call><name>isalnum</name><argument_list>(<argument><expr>*<name>p</name></expr></argument>)</argument_list></call></expr>)</condition><then>
	    <return>return <expr><call><name>PyBool_FromLong</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</return></then></if>
    }</block></for>
    <return>return <expr><call><name>PyBool_FromLong</name><argument_list>(<argument><expr>1</expr></argument>)</argument_list></call></expr>;</return>
}</block></function>


<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>isdigit__doc__</name></expr></argument>,
<argument><expr>"S.isdigit() -&gt; bool\n\
\n\
Return True if all characters in S are digits\n\
and there is at least one character in S, False otherwise."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name>*</type>
<name>string_isdigit</name><parameter_list>(<param><decl><type><name>PyStringObject</name> *</type><name>self</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>register</name> <specifier>const</specifier> <name>unsigned</name> <name>char</name> *</type><name>p</name>
        <init>= <expr>(<name>unsigned</name> <name>char</name> *) <call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>register</name> <specifier>const</specifier> <name>unsigned</name> <name>char</name> *</type><name>e</name></decl>;</decl_stmt>

    <comment type="block">/* Shortcut for single character strings */</comment>
    <if>if <condition>(<expr><call><name>PyString_GET_SIZE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call> == 1 &amp;&amp;
	<call><name>isdigit</name><argument_list>(<argument><expr>*<name>p</name></expr></argument>)</argument_list></call></expr>)</condition><then>
	<return>return <expr><call><name>PyBool_FromLong</name><argument_list>(<argument><expr>1</expr></argument>)</argument_list></call></expr>;</return></then></if>

    <comment type="block">/* Special case for empty strings */</comment>
    <if>if <condition>(<expr><call><name>PyString_GET_SIZE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call> == 0</expr>)</condition><then>
	<return>return <expr><call><name>PyBool_FromLong</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</return></then></if>

    <expr_stmt><expr><name>e</name> = <name>p</name> + <call><name>PyString_GET_SIZE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for (<init>;</init> <condition><expr><name>p</name> &lt; <name>e</name></expr>;</condition> <incr><expr><name>p</name>++</expr></incr>) <block>{
	<if>if <condition>(<expr>!<call><name>isdigit</name><argument_list>(<argument><expr>*<name>p</name></expr></argument>)</argument_list></call></expr>)</condition><then>
	    <return>return <expr><call><name>PyBool_FromLong</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</return></then></if>
    }</block></for>
    <return>return <expr><call><name>PyBool_FromLong</name><argument_list>(<argument><expr>1</expr></argument>)</argument_list></call></expr>;</return>
}</block></function>


<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>islower__doc__</name></expr></argument>,
<argument><expr>"S.islower() -&gt; bool\n\
\n\
Return True if all cased characters in S are lowercase and there is\n\
at least one cased character in S, False otherwise."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name>*</type>
<name>string_islower</name><parameter_list>(<param><decl><type><name>PyStringObject</name> *</type><name>self</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>register</name> <specifier>const</specifier> <name>unsigned</name> <name>char</name> *</type><name>p</name>
        <init>= <expr>(<name>unsigned</name> <name>char</name> *) <call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>register</name> <specifier>const</specifier> <name>unsigned</name> <name>char</name> *</type><name>e</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>cased</name></decl>;</decl_stmt>

    <comment type="block">/* Shortcut for single character strings */</comment>
    <if>if <condition>(<expr><call><name>PyString_GET_SIZE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call> == 1</expr>)</condition><then>
	<return>return <expr><call><name>PyBool_FromLong</name><argument_list>(<argument><expr><call><name>islower</name><argument_list>(<argument><expr>*<name>p</name></expr></argument>)</argument_list></call> != 0</expr></argument>)</argument_list></call></expr>;</return></then></if>

    <comment type="block">/* Special case for empty strings */</comment>
    <if>if <condition>(<expr><call><name>PyString_GET_SIZE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call> == 0</expr>)</condition><then>
	<return>return <expr><call><name>PyBool_FromLong</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</return></then></if>

    <expr_stmt><expr><name>e</name> = <name>p</name> + <call><name>PyString_GET_SIZE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>cased</name> = 0</expr>;</expr_stmt>
    <for>for (<init>;</init> <condition><expr><name>p</name> &lt; <name>e</name></expr>;</condition> <incr><expr><name>p</name>++</expr></incr>) <block>{
	<if>if <condition>(<expr><call><name>isupper</name><argument_list>(<argument><expr>*<name>p</name></expr></argument>)</argument_list></call></expr>)</condition><then>
	    <return>return <expr><call><name>PyBool_FromLong</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</return></then>
	<else>else <if>if <condition>(<expr>!<name>cased</name> &amp;&amp; <call><name>islower</name><argument_list>(<argument><expr>*<name>p</name></expr></argument>)</argument_list></call></expr>)</condition><then>
	    <expr_stmt><expr><name>cased</name> = 1</expr>;</expr_stmt></then></if></else></if>
    }</block></for>
    <return>return <expr><call><name>PyBool_FromLong</name><argument_list>(<argument><expr><name>cased</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>


<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>isupper__doc__</name></expr></argument>,
<argument><expr>"S.isupper() -&gt; bool\n\
\n\
Return True if all cased characters in S are uppercase and there is\n\
at least one cased character in S, False otherwise."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name>*</type>
<name>string_isupper</name><parameter_list>(<param><decl><type><name>PyStringObject</name> *</type><name>self</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>register</name> <specifier>const</specifier> <name>unsigned</name> <name>char</name> *</type><name>p</name>
        <init>= <expr>(<name>unsigned</name> <name>char</name> *) <call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>register</name> <specifier>const</specifier> <name>unsigned</name> <name>char</name> *</type><name>e</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>cased</name></decl>;</decl_stmt>

    <comment type="block">/* Shortcut for single character strings */</comment>
    <if>if <condition>(<expr><call><name>PyString_GET_SIZE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call> == 1</expr>)</condition><then>
	<return>return <expr><call><name>PyBool_FromLong</name><argument_list>(<argument><expr><call><name>isupper</name><argument_list>(<argument><expr>*<name>p</name></expr></argument>)</argument_list></call> != 0</expr></argument>)</argument_list></call></expr>;</return></then></if>

    <comment type="block">/* Special case for empty strings */</comment>
    <if>if <condition>(<expr><call><name>PyString_GET_SIZE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call> == 0</expr>)</condition><then>
	<return>return <expr><call><name>PyBool_FromLong</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</return></then></if>

    <expr_stmt><expr><name>e</name> = <name>p</name> + <call><name>PyString_GET_SIZE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>cased</name> = 0</expr>;</expr_stmt>
    <for>for (<init>;</init> <condition><expr><name>p</name> &lt; <name>e</name></expr>;</condition> <incr><expr><name>p</name>++</expr></incr>) <block>{
	<if>if <condition>(<expr><call><name>islower</name><argument_list>(<argument><expr>*<name>p</name></expr></argument>)</argument_list></call></expr>)</condition><then>
	    <return>return <expr><call><name>PyBool_FromLong</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</return></then>
	<else>else <if>if <condition>(<expr>!<name>cased</name> &amp;&amp; <call><name>isupper</name><argument_list>(<argument><expr>*<name>p</name></expr></argument>)</argument_list></call></expr>)</condition><then>
	    <expr_stmt><expr><name>cased</name> = 1</expr>;</expr_stmt></then></if></else></if>
    }</block></for>
    <return>return <expr><call><name>PyBool_FromLong</name><argument_list>(<argument><expr><name>cased</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>


<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>istitle__doc__</name></expr></argument>,
<argument><expr>"S.istitle() -&gt; bool\n\
\n\
Return True if S is a titlecased string and there is at least one\n\
character in S, i.e. uppercase characters may only follow uncased\n\
characters and lowercase characters only cased ones. Return False\n\
otherwise."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name>*</type>
<name>string_istitle</name><parameter_list>(<param><decl><type><name>PyStringObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>uncased</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>register</name> <specifier>const</specifier> <name>unsigned</name> <name>char</name> *</type><name>p</name>
        <init>= <expr>(<name>unsigned</name> <name>char</name> *) <call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>register</name> <specifier>const</specifier> <name>unsigned</name> <name>char</name> *</type><name>e</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>cased</name></decl>, <decl><type ref="prev"/><name>previous_is_cased</name></decl>;</decl_stmt>

    <comment type="block">/* Shortcut for single character strings */</comment>
    <if>if <condition>(<expr><call><name>PyString_GET_SIZE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call> == 1</expr>)</condition><then>
	<return>return <expr><call><name>PyBool_FromLong</name><argument_list>(<argument><expr><call><name>isupper</name><argument_list>(<argument><expr>*<name>p</name></expr></argument>)</argument_list></call> != 0</expr></argument>)</argument_list></call></expr>;</return></then></if>

    <comment type="block">/* Special case for empty strings */</comment>
    <if>if <condition>(<expr><call><name>PyString_GET_SIZE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call> == 0</expr>)</condition><then>
	<return>return <expr><call><name>PyBool_FromLong</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</return></then></if>

    <expr_stmt><expr><name>e</name> = <name>p</name> + <call><name>PyString_GET_SIZE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>cased</name> = 0</expr>;</expr_stmt>
    <expr_stmt><expr><name>previous_is_cased</name> = 0</expr>;</expr_stmt>
    <for>for (<init>;</init> <condition><expr><name>p</name> &lt; <name>e</name></expr>;</condition> <incr><expr><name>p</name>++</expr></incr>) <block>{
	<decl_stmt><decl><type><name>register</name> <specifier>const</specifier> <name>unsigned</name> <name>char</name></type> <name>ch</name> <init>= <expr>*<name>p</name></expr></init></decl>;</decl_stmt>

	<if>if <condition>(<expr><call><name>isupper</name><argument_list>(<argument><expr><name>ch</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
	    <if>if <condition>(<expr><name>previous_is_cased</name></expr>)</condition><then>
		<return>return <expr><call><name>PyBool_FromLong</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</return></then></if>
	    <expr_stmt><expr><name>previous_is_cased</name> = 1</expr>;</expr_stmt>
	    <expr_stmt><expr><name>cased</name> = 1</expr>;</expr_stmt>
	}</block></then>
	<else>else <if>if <condition>(<expr><call><name>islower</name><argument_list>(<argument><expr><name>ch</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
	    <if>if <condition>(<expr>!<name>previous_is_cased</name></expr>)</condition><then>
		<return>return <expr><call><name>PyBool_FromLong</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</return></then></if>
	    <expr_stmt><expr><name>previous_is_cased</name> = 1</expr>;</expr_stmt>
	    <expr_stmt><expr><name>cased</name> = 1</expr>;</expr_stmt>
	}</block></then>
	<else>else
	    <expr_stmt><expr><name>previous_is_cased</name> = 0</expr>;</expr_stmt></else></if></else></if>
    }</block></for>
    <return>return <expr><call><name>PyBool_FromLong</name><argument_list>(<argument><expr><name>cased</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>


<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>splitlines__doc__</name></expr></argument>,
<argument><expr>"S.splitlines([keepends]) -&gt; list of strings\n\
\n\
Return a list of the lines in S, breaking at line boundaries.\n\
Line breaks are not included in the resulting list unless keepends\n\
is given and true."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name>*</type>
<name>string_splitlines</name><parameter_list>(<param><decl><type><name>PyStringObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>register</name> <name>Py_ssize_t</name></type> <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>register</name> <name>Py_ssize_t</name></type> <name>j</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>len</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>keepends</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PyObject</name> *</type><name>list</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PyObject</name> *</type><name>str</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> *</type><name>data</name></decl>;</decl_stmt>

    <if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"|i:splitlines"</expr></argument>, <argument><expr>&amp;<name>keepends</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>NULL</name></expr>;</return></then></if>

    <expr_stmt><expr><name>data</name> = <call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>len</name> = <call><name>PyString_GET_SIZE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* This does not use the preallocated list because splitlines is
       usually run with hundreds of newlines.  The overhead of
       switching between PyList_SET_ITEM and append causes about a
       2-3% slowdown for that common case.  A smarter implementation
       could move the if check out, so the SET_ITEMs are done first
       and the appends only done when the prealloc buffer is full.
       That's too much work for little gain.*/</comment>

    <expr_stmt><expr><name>list</name> = <call><name>PyList_New</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr>!<name>list</name></expr>)</condition><then>
        <goto>goto <name>onError</name>;</goto></then></if>

    <for>for (<init><expr><name>i</name> = <name>j</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>len</name></expr>;</condition> <incr/>) <block>{
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>eol</name></decl>;</decl_stmt>

	<comment type="block">/* Find a line and append it */</comment>
	<while>while <condition>(<expr><name>i</name> &lt; <name>len</name> &amp;&amp; <name><name>data</name><index>[<expr><name>i</name></expr>]</index></name> != '\n' &amp;&amp; <name><name>data</name><index>[<expr><name>i</name></expr>]</index></name> != '\r'</expr>)</condition>
	    <expr_stmt><expr><name>i</name>++</expr>;</expr_stmt></while>

	<comment type="block">/* Skip the line break reading CRLF as one line break */</comment>
	<expr_stmt><expr><name>eol</name> = <name>i</name></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>i</name> &lt; <name>len</name></expr>)</condition><then> <block>{
	    <if>if <condition>(<expr><name><name>data</name><index>[<expr><name>i</name></expr>]</index></name> == '\r' &amp;&amp; <name>i</name> + 1 &lt; <name>len</name> &amp;&amp;
		<name><name>data</name><index>[<expr><name>i</name>+1</expr>]</index></name> == '\n'</expr>)</condition><then>
		<expr_stmt><expr><name>i</name> += 2</expr>;</expr_stmt></then>
	    <else>else
		<expr_stmt><expr><name>i</name>++</expr>;</expr_stmt></else></if>
	    <if>if <condition>(<expr><name>keepends</name></expr>)</condition><then>
		<expr_stmt><expr><name>eol</name> = <name>i</name></expr>;</expr_stmt></then></if>
	}</block></then></if>
	<expr_stmt><expr><call><name>SPLIT_APPEND</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><name>eol</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>j</name> = <name>i</name></expr>;</expr_stmt>
    }</block></for>
    <if>if <condition>(<expr><name>j</name> &lt; <name>len</name></expr>)</condition><then> <block>{
	<expr_stmt><expr><call><name>SPLIT_APPEND</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

    <return>return <expr><name>list</name></expr>;</return>

 <label><name>onError</name>:</label>
    <expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>NULL</name></expr>;</return>
}</block></function>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>sizeof__doc__</name></expr></argument>,
<argument><expr>"S.__sizeof__() -&gt; size of S in memory, in bytes"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>string_sizeof</name><parameter_list>(<param><decl><type><name>PyStringObject</name> *</type><name>v</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>res</name></decl>;</decl_stmt>
	<expr_stmt><expr><name>res</name> = <sizeof>sizeof<argument_list>(<argument><expr><name>PyStringObject</name></expr></argument>)</argument_list></sizeof> + <name><name>v</name>-&gt;<name>ob_size</name></name> * <name><name>v</name>-&gt;<name>ob_type</name>-&gt;<name>tp_itemsize</name></name></expr>;</expr_stmt>
	<return>return <expr><call><name>PyInt_FromSsize_t</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>SPLIT_APPEND</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>SPLIT_ADD</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>MAX_PREALLOC</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>PREALLOC_SIZE</name></cpp:undef>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>string_getnewargs</name><parameter_list>(<param><decl><type><name>PyStringObject</name> *</type><name>v</name></decl></param>)</parameter_list>
<block>{
	<return>return <expr><call><name>Py_BuildValue</name><argument_list>(<argument><expr>"(s#)"</expr></argument>, <argument><expr><name><name>v</name>-&gt;<name>ob_sval</name></name></expr></argument>, <argument><expr><call><name>Py_SIZE</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>


<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"stringlib/string_format.h"</cpp:file></cpp:include>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>format__doc__</name></expr></argument>,
<argument><expr>"S.format(*args, **kwargs) -&gt; unicode\n\
\n\
"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>string__format__</name><parameter_list>(<param><decl><type><name>PyObject</name>*</type> <name>self</name></decl></param>, <param><decl><type><name>PyObject</name>*</type> <name>args</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>PyObject</name> *</type><name>format_spec</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PyObject</name> *</type><name>result</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PyObject</name> *</type><name>tmp</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

    <comment type="block">/* If 2.x, convert format_spec to the same type as value */</comment>
    <comment type="block">/* This is to allow things like u''.format('') */</comment>
    <if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"O:__format__"</expr></argument>, <argument><expr>&amp;<name>format_spec</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <goto>goto <name>done</name>;</goto></then></if>
    <if>if <condition>(<expr>!(<call><name>PyString_Check</name><argument_list>(<argument><expr><name>format_spec</name></expr></argument>)</argument_list></call> || <call><name>PyUnicode_Check</name><argument_list>(<argument><expr><name>format_spec</name></expr></argument>)</argument_list></call>)</expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>, <argument><expr>"__format__ arg must be str "
		     "or unicode, not %s"</expr></argument>, <argument><expr><call><name>Py_TYPE</name><argument_list>(<argument><expr><name>format_spec</name></expr></argument>)</argument_list></call>-&gt;<name>tp_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<goto>goto <name>done</name>;</goto>
    }</block></then></if>
    <expr_stmt><expr><name>tmp</name> = <call><name>PyObject_Str</name><argument_list>(<argument><expr><name>format_spec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>tmp</name> == <name>NULL</name></expr>)</condition><then>
        <goto>goto <name>done</name>;</goto></then></if>
    <expr_stmt><expr><name>format_spec</name> = <name>tmp</name></expr>;</expr_stmt>

    <expr_stmt><expr><name>result</name> = <call><name>_PyBytes_FormatAdvanced</name><argument_list>(<argument><expr><name>self</name></expr></argument>,
				     <argument><expr><call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>format_spec</name></expr></argument>)</argument_list></call></expr></argument>,
				     <argument><expr><call><name>PyString_GET_SIZE</name><argument_list>(<argument><expr><name>format_spec</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<label><name>done</name>:</label>
    <expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>result</name></expr>;</return>
}</block></function>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>p_format__doc__</name></expr></argument>,
<argument><expr>"S.__format__(format_spec) -&gt; unicode\n\
\n\
"</expr></argument>)</argument_list></call></expr>;</expr_stmt>


<decl_stmt><decl><type><specifier>static</specifier> <name>PyMethodDef</name></type>
<name><name>string_methods</name><index>[]</index></name> <init>= <expr><block>{
	<comment type="block">/* Counterparts of the obsolete stropmodule functions; except
	   string.maketrans(). */</comment>
	<expr><block>{<expr>"join"</expr>, <expr>(<name>PyCFunction</name>)<name>string_join</name></expr>, <expr><name>METH_O</name></expr>, <expr><name>join__doc__</name></expr>}</block></expr>,
	<expr><block>{<expr>"split"</expr>, <expr>(<name>PyCFunction</name>)<name>string_split</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>split__doc__</name></expr>}</block></expr>,
	<expr><block>{<expr>"rsplit"</expr>, <expr>(<name>PyCFunction</name>)<name>string_rsplit</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>rsplit__doc__</name></expr>}</block></expr>,
	<expr><block>{<expr>"lower"</expr>, <expr>(<name>PyCFunction</name>)<name>string_lower</name></expr>, <expr><name>METH_NOARGS</name></expr>, <expr><name>lower__doc__</name></expr>}</block></expr>,
	<expr><block>{<expr>"upper"</expr>, <expr>(<name>PyCFunction</name>)<name>string_upper</name></expr>, <expr><name>METH_NOARGS</name></expr>, <expr><name>upper__doc__</name></expr>}</block></expr>,
	<expr><block>{<expr>"islower"</expr>, <expr>(<name>PyCFunction</name>)<name>string_islower</name></expr>, <expr><name>METH_NOARGS</name></expr>, <expr><name>islower__doc__</name></expr>}</block></expr>,
	<expr><block>{<expr>"isupper"</expr>, <expr>(<name>PyCFunction</name>)<name>string_isupper</name></expr>, <expr><name>METH_NOARGS</name></expr>, <expr><name>isupper__doc__</name></expr>}</block></expr>,
	<expr><block>{<expr>"isspace"</expr>, <expr>(<name>PyCFunction</name>)<name>string_isspace</name></expr>, <expr><name>METH_NOARGS</name></expr>, <expr><name>isspace__doc__</name></expr>}</block></expr>,
	<expr><block>{<expr>"isdigit"</expr>, <expr>(<name>PyCFunction</name>)<name>string_isdigit</name></expr>, <expr><name>METH_NOARGS</name></expr>, <expr><name>isdigit__doc__</name></expr>}</block></expr>,
	<expr><block>{<expr>"istitle"</expr>, <expr>(<name>PyCFunction</name>)<name>string_istitle</name></expr>, <expr><name>METH_NOARGS</name></expr>, <expr><name>istitle__doc__</name></expr>}</block></expr>,
	<expr><block>{<expr>"isalpha"</expr>, <expr>(<name>PyCFunction</name>)<name>string_isalpha</name></expr>, <expr><name>METH_NOARGS</name></expr>, <expr><name>isalpha__doc__</name></expr>}</block></expr>,
	<expr><block>{<expr>"isalnum"</expr>, <expr>(<name>PyCFunction</name>)<name>string_isalnum</name></expr>, <expr><name>METH_NOARGS</name></expr>, <expr><name>isalnum__doc__</name></expr>}</block></expr>,
	<expr><block>{<expr>"capitalize"</expr>, <expr>(<name>PyCFunction</name>)<name>string_capitalize</name></expr>, <expr><name>METH_NOARGS</name></expr>,
	 <expr><name>capitalize__doc__</name></expr>}</block></expr>,
	<expr><block>{<expr>"count"</expr>, <expr>(<name>PyCFunction</name>)<name>string_count</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>count__doc__</name></expr>}</block></expr>,
	<expr><block>{<expr>"endswith"</expr>, <expr>(<name>PyCFunction</name>)<name>string_endswith</name></expr>, <expr><name>METH_VARARGS</name></expr>,
	 <expr><name>endswith__doc__</name></expr>}</block></expr>,
	<expr><block>{<expr>"partition"</expr>, <expr>(<name>PyCFunction</name>)<name>string_partition</name></expr>, <expr><name>METH_O</name></expr>, <expr><name>partition__doc__</name></expr>}</block></expr>,
	<expr><block>{<expr>"find"</expr>, <expr>(<name>PyCFunction</name>)<name>string_find</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>find__doc__</name></expr>}</block></expr>,
	<expr><block>{<expr>"index"</expr>, <expr>(<name>PyCFunction</name>)<name>string_index</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>index__doc__</name></expr>}</block></expr>,
	<expr><block>{<expr>"lstrip"</expr>, <expr>(<name>PyCFunction</name>)<name>string_lstrip</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>lstrip__doc__</name></expr>}</block></expr>,
	<expr><block>{<expr>"replace"</expr>, <expr>(<name>PyCFunction</name>)<name>string_replace</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>replace__doc__</name></expr>}</block></expr>,
	<expr><block>{<expr>"rfind"</expr>, <expr>(<name>PyCFunction</name>)<name>string_rfind</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>rfind__doc__</name></expr>}</block></expr>,
	<expr><block>{<expr>"rindex"</expr>, <expr>(<name>PyCFunction</name>)<name>string_rindex</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>rindex__doc__</name></expr>}</block></expr>,
	<expr><block>{<expr>"rstrip"</expr>, <expr>(<name>PyCFunction</name>)<name>string_rstrip</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>rstrip__doc__</name></expr>}</block></expr>,
	<expr><block>{<expr>"rpartition"</expr>, <expr>(<name>PyCFunction</name>)<name>string_rpartition</name></expr>, <expr><name>METH_O</name></expr>,
	 <expr><name>rpartition__doc__</name></expr>}</block></expr>,
	<expr><block>{<expr>"startswith"</expr>, <expr>(<name>PyCFunction</name>)<name>string_startswith</name></expr>, <expr><name>METH_VARARGS</name></expr>,
	 <expr><name>startswith__doc__</name></expr>}</block></expr>,
	<expr><block>{<expr>"strip"</expr>, <expr>(<name>PyCFunction</name>)<name>string_strip</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>strip__doc__</name></expr>}</block></expr>,
	<expr><block>{<expr>"swapcase"</expr>, <expr>(<name>PyCFunction</name>)<name>string_swapcase</name></expr>, <expr><name>METH_NOARGS</name></expr>,
	 <expr><name>swapcase__doc__</name></expr>}</block></expr>,
	<expr><block>{<expr>"translate"</expr>, <expr>(<name>PyCFunction</name>)<name>string_translate</name></expr>, <expr><name>METH_VARARGS</name></expr>,
	 <expr><name>translate__doc__</name></expr>}</block></expr>,
	<expr><block>{<expr>"title"</expr>, <expr>(<name>PyCFunction</name>)<name>string_title</name></expr>, <expr><name>METH_NOARGS</name></expr>, <expr><name>title__doc__</name></expr>}</block></expr>,
	<expr><block>{<expr>"ljust"</expr>, <expr>(<name>PyCFunction</name>)<name>string_ljust</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>ljust__doc__</name></expr>}</block></expr>,
	<expr><block>{<expr>"rjust"</expr>, <expr>(<name>PyCFunction</name>)<name>string_rjust</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>rjust__doc__</name></expr>}</block></expr>,
	<expr><block>{<expr>"center"</expr>, <expr>(<name>PyCFunction</name>)<name>string_center</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>center__doc__</name></expr>}</block></expr>,
	<expr><block>{<expr>"zfill"</expr>, <expr>(<name>PyCFunction</name>)<name>string_zfill</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>zfill__doc__</name></expr>}</block></expr>,
	<expr><block>{<expr>"format"</expr>, <expr>(<name>PyCFunction</name>) <name>do_string_format</name></expr>, <expr><name>METH_VARARGS</name> | <name>METH_KEYWORDS</name></expr>, <expr><name>format__doc__</name></expr>}</block></expr>,
	<expr><block>{<expr>"__format__"</expr>, <expr>(<name>PyCFunction</name>) <name>string__format__</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>p_format__doc__</name></expr>}</block></expr>,
	<expr><block>{<expr>"_formatter_field_name_split"</expr>, <expr>(<name>PyCFunction</name>) <name>formatter_field_name_split</name></expr>, <expr><name>METH_NOARGS</name></expr>}</block></expr>,
	<expr><block>{<expr>"_formatter_parser"</expr>, <expr>(<name>PyCFunction</name>) <name>formatter_parser</name></expr>, <expr><name>METH_NOARGS</name></expr>}</block></expr>,
	<expr><block>{<expr>"encode"</expr>, <expr>(<name>PyCFunction</name>)<name>string_encode</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>encode__doc__</name></expr>}</block></expr>,
	<expr><block>{<expr>"decode"</expr>, <expr>(<name>PyCFunction</name>)<name>string_decode</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>decode__doc__</name></expr>}</block></expr>,
	<expr><block>{<expr>"expandtabs"</expr>, <expr>(<name>PyCFunction</name>)<name>string_expandtabs</name></expr>, <expr><name>METH_VARARGS</name></expr>,
	 <expr><name>expandtabs__doc__</name></expr>}</block></expr>,
	<expr><block>{<expr>"splitlines"</expr>, <expr>(<name>PyCFunction</name>)<name>string_splitlines</name></expr>, <expr><name>METH_VARARGS</name></expr>,
	 <expr><name>splitlines__doc__</name></expr>}</block></expr>,
	<expr><block>{<expr>"__sizeof__"</expr>, <expr>(<name>PyCFunction</name>)<name>string_sizeof</name></expr>, <expr><name>METH_NOARGS</name></expr>,
	 <expr><name>sizeof__doc__</name></expr>}</block></expr>,
	<expr><block>{<expr>"__getnewargs__"</expr>,	<expr>(<name>PyCFunction</name>)<name>string_getnewargs</name></expr>,	<expr><name>METH_NOARGS</name></expr>}</block></expr>,
	<expr><block>{<expr><name>NULL</name></expr>,     <expr><name>NULL</name></expr>}</block></expr>		     <comment type="block">/* sentinel */</comment>
}</block></expr></init></decl>;</decl_stmt>

<function_decl><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>str_subtype_new</name><parameter_list>(<param><decl><type><name>PyTypeObject</name> *</type><name>type</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>kwds</name></decl></param>)</parameter_list>;</function_decl>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>string_new</name><parameter_list>(<param><decl><type><name>PyTypeObject</name> *</type><name>type</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>kwds</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>x</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> *</type><name><name>kwlist</name><index>[]</index></name> <init>= <expr><block>{<expr>"object"</expr>, <expr>0</expr>}</block></expr></init></decl>;</decl_stmt>

	<if>if <condition>(<expr><name>type</name> != &amp;<name>PyString_Type</name></expr>)</condition><then>
		<return>return <expr><call><name>str_subtype_new</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><name>args</name></expr></argument>, <argument><expr><name>kwds</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
	<if>if <condition>(<expr>!<call><name>PyArg_ParseTupleAndKeywords</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>kwds</name></expr></argument>, <argument><expr>"|O:str"</expr></argument>, <argument><expr><name>kwlist</name></expr></argument>, <argument><expr>&amp;<name>x</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<if>if <condition>(<expr><name>x</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr><call><name>PyString_FromString</name><argument_list>(<argument><expr>""</expr></argument>)</argument_list></call></expr>;</return></then></if>
	<return>return <expr><call><name>PyObject_Str</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>str_subtype_new</name><parameter_list>(<param><decl><type><name>PyTypeObject</name> *</type><name>type</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>kwds</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>tmp</name></decl>, *<decl><type ref="prev"/><name>pnew</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>n</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>PyType_IsSubtype</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr>&amp;<name>PyString_Type</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>tmp</name> = <call><name>string_new</name><argument_list>(<argument><expr>&amp;<name>PyString_Type</name></expr></argument>, <argument><expr><name>args</name></expr></argument>, <argument><expr><name>kwds</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>tmp</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>PyString_CheckExact</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>n</name> = <call><name>PyString_GET_SIZE</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>pnew</name> = <call><name><name>type</name>-&gt;<name>tp_alloc</name></name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>pnew</name> != <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>Py_MEMCPY</name><argument_list>(<argument><expr><call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>pnew</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>n</name>+1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr>((<name>PyStringObject</name> *)<name>pnew</name>)-&gt;<name>ob_shash</name> =
			((<name>PyStringObject</name> *)<name>tmp</name>)-&gt;<name>ob_shash</name></expr>;</expr_stmt>
		<expr_stmt><expr>((<name>PyStringObject</name> *)<name>pnew</name>)-&gt;<name>ob_sstate</name> = <name>SSTATE_NOT_INTERNED</name></expr>;</expr_stmt>
	}</block></then></if>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>pnew</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>basestring_new</name><parameter_list>(<param><decl><type><name>PyTypeObject</name> *</type><name>type</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>kwds</name></decl></param>)</parameter_list>
<block>{
	<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
			<argument><expr>"The basestring type cannot be instantiated"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>NULL</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>string_mod</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>v</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>w</name></decl></param>)</parameter_list>
<block>{
	<if>if <condition>(<expr>!<call><name>PyString_Check</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_NotImplemented</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>Py_NotImplemented</name></expr>;</return>
	}</block></then></if>
	<return>return <expr><call><name>PyString_Format</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>basestring_doc</name></expr></argument>,
<argument><expr>"Type basestring cannot be instantiated; it is the base for str and unicode."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>PyNumberMethods</name></type> <name>string_as_number</name> <init>= <expr><block>{
	<expr>0</expr>,			<comment type="block">/*nb_add*/</comment>
	<expr>0</expr>,			<comment type="block">/*nb_subtract*/</comment>
	<expr>0</expr>,			<comment type="block">/*nb_multiply*/</comment>
	<expr>0</expr>, 			<comment type="block">/*nb_divide*/</comment>
	<expr><name>string_mod</name></expr>,		<comment type="block">/*nb_remainder*/</comment>
}</block></expr></init></decl>;</decl_stmt>


<decl_stmt><decl><type><name>PyTypeObject</name></type> <name>PyBaseString_Type</name> <init>= <expr><block>{
	<expr><call><name>PyVarObject_HEAD_INIT</name><argument_list>(<argument><expr>&amp;<name>PyType_Type</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call>
	"basestring"</expr>,
	<expr>0</expr>,
	<expr>0</expr>,
 	<expr>0</expr>,			 		<comment type="block">/* tp_dealloc */</comment>
	<expr>0</expr>,			 		<comment type="block">/* tp_print */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_getattr */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_setattr */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_compare */</comment>
	<expr>0</expr>,		 			<comment type="block">/* tp_repr */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_as_number */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_as_sequence */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_as_mapping */</comment>
	<expr>0</expr>,		 			<comment type="block">/* tp_hash */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_call */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_str */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_getattro */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_setattro */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_as_buffer */</comment>
	<expr><name>Py_TPFLAGS_DEFAULT</name> | <name>Py_TPFLAGS_BASETYPE</name></expr>, <comment type="block">/* tp_flags */</comment>
	<expr><name>basestring_doc</name></expr>,				<comment type="block">/* tp_doc */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_traverse */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_clear */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_richcompare */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_weaklistoffset */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_iter */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_iternext */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_methods */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_members */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_getset */</comment>
	<expr>&amp;<name>PyBaseObject_Type</name></expr>,			<comment type="block">/* tp_base */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_dict */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_descr_get */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_descr_set */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_dictoffset */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_init */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_alloc */</comment>
	<expr><name>basestring_new</name></expr>,				<comment type="block">/* tp_new */</comment>
	<expr>0</expr>,		                	<comment type="block">/* tp_free */</comment>
}</block></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>string_doc</name></expr></argument>,
<argument><expr>"str(object) -&gt; string\n\
\n\
Return a nice string representation of the object.\n\
If the argument is a string, the return value is the same object."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name>PyTypeObject</name></type> <name>PyString_Type</name> <init>= <expr><block>{
	<expr><call><name>PyVarObject_HEAD_INIT</name><argument_list>(<argument><expr>&amp;<name>PyType_Type</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call>
	"str"</expr>,
	<expr><sizeof>sizeof<argument_list>(<argument><expr><name>PyStringObject</name></expr></argument>)</argument_list></sizeof></expr>,
	<expr><sizeof>sizeof<argument_list>(<argument><expr><name>char</name></expr></argument>)</argument_list></sizeof></expr>,
 	<expr><name>string_dealloc</name></expr>, 			<comment type="block">/* tp_dealloc */</comment>
	<expr>(<name>printfunc</name>)<name>string_print</name></expr>, 		<comment type="block">/* tp_print */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_getattr */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_setattr */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_compare */</comment>
	<expr><name>string_repr</name></expr>, 				<comment type="block">/* tp_repr */</comment>
	<expr>&amp;<name>string_as_number</name></expr>,			<comment type="block">/* tp_as_number */</comment>
	<expr>&amp;<name>string_as_sequence</name></expr>,			<comment type="block">/* tp_as_sequence */</comment>
	<expr>&amp;<name>string_as_mapping</name></expr>,			<comment type="block">/* tp_as_mapping */</comment>
	<expr>(<name>hashfunc</name>)<name>string_hash</name></expr>, 			<comment type="block">/* tp_hash */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_call */</comment>
	<expr><name>string_str</name></expr>,				<comment type="block">/* tp_str */</comment>
	<expr><name>PyObject_GenericGetAttr</name></expr>,		<comment type="block">/* tp_getattro */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_setattro */</comment>
	<expr>&amp;<name>string_as_buffer</name></expr>,			<comment type="block">/* tp_as_buffer */</comment>
	<expr><name>Py_TPFLAGS_DEFAULT</name> | <name>Py_TPFLAGS_CHECKTYPES</name> |
		<name>Py_TPFLAGS_BASETYPE</name> | <name>Py_TPFLAGS_STRING_SUBCLASS</name> |
		<name>Py_TPFLAGS_HAVE_NEWBUFFER</name></expr>,	<comment type="block">/* tp_flags */</comment>
	<expr><name>string_doc</name></expr>,				<comment type="block">/* tp_doc */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_traverse */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_clear */</comment>
	<expr>(<name>richcmpfunc</name>)<name>string_richcompare</name></expr>,	<comment type="block">/* tp_richcompare */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_weaklistoffset */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_iter */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_iternext */</comment>
	<expr><name>string_methods</name></expr>,				<comment type="block">/* tp_methods */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_members */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_getset */</comment>
	<expr>&amp;<name>PyBaseString_Type</name></expr>,			<comment type="block">/* tp_base */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_dict */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_descr_get */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_descr_set */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_dictoffset */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_init */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_alloc */</comment>
	<expr><name>string_new</name></expr>,				<comment type="block">/* tp_new */</comment>
	<expr><name>PyObject_Del</name></expr>,	                	<comment type="block">/* tp_free */</comment>
}</block></expr></init></decl>;</decl_stmt>

<function><type><name>void</name></type>
<name>PyString_Concat</name><parameter_list>(<param><decl><type><name>register</name> <name>PyObject</name> **</type><name>pv</name></decl></param>, <param><decl><type><name>register</name> <name>PyObject</name> *</type><name>w</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>register</name> <name>PyObject</name> *</type><name>v</name></decl>;</decl_stmt>
	<if>if <condition>(<expr>*<name>pv</name> == <name>NULL</name></expr>)</condition><then>
		<return>return;</return></then></if>
	<if>if <condition>(<expr><name>w</name> == <name>NULL</name> || !<call><name>PyString_Check</name><argument_list>(<argument><expr>*<name>pv</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr>*<name>pv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr>*<name>pv</name> = <name>NULL</name></expr>;</expr_stmt>
		<return>return;</return>
	}</block></then></if>
	<expr_stmt><expr><name>v</name> = <call><name>string_concat</name><argument_list>(<argument><expr>(<name>PyStringObject</name> *) *<name>pv</name></expr></argument>, <argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr>*<name>pv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr>*<name>pv</name> = <name>v</name></expr>;</expr_stmt>
}</block></function>

<function><type><name>void</name></type>
<name>PyString_ConcatAndDel</name><parameter_list>(<param><decl><type><name>register</name> <name>PyObject</name> **</type><name>pv</name></decl></param>, <param><decl><type><name>register</name> <name>PyObject</name> *</type><name>w</name></decl></param>)</parameter_list>
<block>{
	<expr_stmt><expr><call><name>PyString_Concat</name><argument_list>(<argument><expr><name>pv</name></expr></argument>, <argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>


<comment type="block">/* The following function breaks the notion that strings are immutable:
   it changes the size of a string.  We get away with this only if there
   is only one module referencing the object.  You can also think of it
   as creating a new string object and destroying the old one, only
   more efficiently.  In any case, don't use this if the string may
   already be known to some other part of the code...
   Note that if there's not enough memory to resize the string, the original
   string object at *pv is deallocated, *pv is set to NULL, an "out of
   memory" exception is set, and -1 is returned.  Else (on success) 0 is
   returned, and the value in *pv may or may not be the same as on input.
   As always, an extra byte is allocated for a trailing \0 byte (newsize
   does *not* include that), and a trailing \0 byte is stored.
*/</comment>

<function><type><name>int</name></type>
<name>_PyString_Resize</name><parameter_list>(<param><decl><type><name>PyObject</name> **</type><name>pv</name></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>newsize</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>register</name> <name>PyObject</name> *</type><name>v</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>register</name> <name>PyStringObject</name> *</type><name>sv</name></decl>;</decl_stmt>
	<expr_stmt><expr><name>v</name> = *<name>pv</name></expr>;</expr_stmt>
	<if>if <condition>(<expr>!<call><name>PyString_Check</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call> || <call><name>Py_REFCNT</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call> != 1 || <name>newsize</name> &lt; 0 ||
	    <call><name>PyString_CHECK_INTERNED</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr>*<name>pv</name> = 0</expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PyErr_BadInternalCall</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>-1</expr>;</return>
	}</block></then></if>
	<comment type="block">/* XXX UNREF/NEWREF interface should be more symmetrical */</comment>
	<expr_stmt><expr><name>_Py_DEC_REFTOTAL</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>_Py_ForgetReference</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr>*<name>pv</name> = (<name>PyObject</name> *)
		<call><name>PyObject_REALLOC</name><argument_list>(<argument><expr>(<name>char</name> *)<name>v</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PyStringObject</name></expr></argument>)</argument_list></sizeof> + <name>newsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr>*<name>pv</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyObject_Del</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PyErr_NoMemory</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>-1</expr>;</return>
	}</block></then></if>
	<expr_stmt><expr><call><name>_Py_NewReference</name><argument_list>(<argument><expr>*<name>pv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>sv</name> = (<name>PyStringObject</name> *) *<name>pv</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_SIZE</name><argument_list>(<argument><expr><name>sv</name></expr></argument>)</argument_list></call> = <name>newsize</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>sv</name>-&gt;<name>ob_sval</name><index>[<expr><name>newsize</name></expr>]</index></name> = '\0'</expr>;</expr_stmt>
	<expr_stmt><expr><name><name>sv</name>-&gt;<name>ob_shash</name></name> = -1</expr>;</expr_stmt>	<comment type="block">/* invalidate cached hash value */</comment>
	<return>return <expr>0</expr>;</return>
}</block></function>

<comment type="block">/* Helpers for formatstring */</comment>

<macro><name>Py_LOCAL_INLINE</name><argument_list>(<argument>PyObject *</argument>)</argument_list></macro>
<macro><name>getnextarg</name><argument_list>(<argument>PyObject *args</argument>, <argument>Py_ssize_t arglen</argument>, <argument>Py_ssize_t *p_argidx</argument>)</argument_list></macro>
<block>{
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>argidx</name> <init>= <expr>*<name>p_argidx</name></expr></init></decl>;</decl_stmt>
	<if>if <condition>(<expr><name>argidx</name> &lt; <name>arglen</name></expr>)</condition><then> <block>{
		<expr_stmt><expr>(*<name>p_argidx</name>)++</expr>;</expr_stmt>
		<if>if <condition>(<expr><name>arglen</name> &lt; 0</expr>)</condition><then>
			<return>return <expr><name>args</name></expr>;</return></then>
		<else>else
			<return>return <expr><call><name>PyTuple_GetItem</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>argidx</name></expr></argument>)</argument_list></call></expr>;</return></else></if>
	}</block></then></if>
	<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
			<argument><expr>"not enough arguments for format string"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>NULL</name></expr>;</return>
}</block>

<comment type="block">/* Format codes
 * F_LJUST	'-'
 * F_SIGN	'+'
 * F_BLANK	' '
 * F_ALT	'#'
 * F_ZERO	'0'
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>F_LJUST</name></cpp:macro> <cpp:value>(1&lt;&lt;0)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>F_SIGN</name></cpp:macro>	<cpp:value>(1&lt;&lt;1)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>F_BLANK</name></cpp:macro> <cpp:value>(1&lt;&lt;2)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>F_ALT</name></cpp:macro>	<cpp:value>(1&lt;&lt;3)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>F_ZERO</name></cpp:macro>	<cpp:value>(1&lt;&lt;4)</cpp:value></cpp:define>

<macro><name>Py_LOCAL_INLINE</name><argument_list>(<argument>int</argument>)</argument_list></macro>
<macro><name>formatfloat</name><argument_list>(<argument>char *buf</argument>, <argument>size_t buflen</argument>, <argument>int flags</argument>,
            <argument>int prec</argument>, <argument>int type</argument>, <argument>PyObject *v</argument>)</argument_list></macro>
<block>{
	<comment type="block">/* fmt = '%#.' + `prec` + `type`
	   worst case length = 3 + 10 (len of INT_MAX) + 1 = 14 (use 20)*/</comment>
	<decl_stmt><decl><type><name>char</name></type> <name><name>fmt</name><index>[<expr>20</expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type> <name>x</name></decl>;</decl_stmt>
	<expr_stmt><expr><name>x</name> = <call><name>PyFloat_AsDouble</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>x</name> == -1.0 &amp;&amp; <call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>, <argument><expr>"float argument required, "
			     "not %.200s"</expr></argument>, <argument><expr><call><name>Py_TYPE</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call>-&gt;<name>tp_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>-1</expr>;</return>
	}</block></then></if>
	<if>if <condition>(<expr><name>prec</name> &lt; 0</expr>)</condition><then>
		<expr_stmt><expr><name>prec</name> = 6</expr>;</expr_stmt></then></if>
	<if>if <condition>(<expr><name>type</name> == 'f' &amp;&amp; <call><name>fabs</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call>/1e25 &gt;= 1e25</expr>)</condition><then>
		<expr_stmt><expr><name>type</name> = 'g'</expr>;</expr_stmt></then></if>
	<comment type="block">/* Worst case length calc to ensure no buffer overrun:

	   'g' formats:
	     fmt = %#.&lt;prec&gt;g
	     buf = '-' + [0-9]*prec + '.' + 'e+' + (longest exp
	        for any double rep.)
	     len = 1 + prec + 1 + 2 + 5 = 9 + prec

	   'f' formats:
	     buf = '-' + [0-9]*x + '.' + [0-9]*prec (with x &lt; 50)
	     len = 1 + 50 + 1 + prec = 52 + prec

	   If prec=0 the effective precision is 1 (the leading digit is
	   always given), therefore increase the length by one.

	*/</comment>
	<if>if <condition>(<expr>((<name>type</name> == 'g' || <name>type</name> == 'G') &amp;&amp;
              <name>buflen</name> &lt;= (<name>size_t</name>)10 + (<name>size_t</name>)<name>prec</name>) ||
	    (<name>type</name> == 'f' &amp;&amp; <name>buflen</name> &lt;= (<name>size_t</name>)53 + (<name>size_t</name>)<name>prec</name>)</expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_OverflowError</name></expr></argument>,
			<argument><expr>"formatted float is too long (precision too large?)"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>-1</expr>;</return>
	}</block></then></if>
	<expr_stmt><expr><call><name>PyOS_snprintf</name><argument_list>(<argument><expr><name>fmt</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>fmt</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr>"%%%s.%d%c"</expr></argument>,
		      <argument><expr>(<name>flags</name>&amp;<name>F_ALT</name>) ? "#" : ""</expr></argument>,
		      <argument><expr><name>prec</name></expr></argument>, <argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>PyOS_ascii_formatd</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>buflen</name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>, <argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr>(<name>int</name>)<call><name>strlen</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<comment type="block">/* _PyString_FormatLong emulates the format codes d, u, o, x and X, and
 * the F_ALT flag, for Python's long (unbounded) ints.  It's not used for
 * Python's regular ints.
 * Return value:  a new PyString*, or NULL if error.
 *  .  *pbuf is set to point into it,
 *     *plen set to the # of chars following that.
 *     Caller must decref it when done using pbuf.
 *     The string starting at *pbuf is of the form
 *         "-"? ("0x" | "0X")? digit+
 *     "0x"/"0X" are present only for x and X conversions, with F_ALT
 *         set in flags.  The case of hex digits will be correct,
 *     There will be at least prec digits, zero-filled on the left if
 *         necessary to get that many.
 * val		object to be converted
 * flags	bitmask of format flags; only F_ALT is looked at
 * prec		minimum number of digits; 0-fill on left if needed
 * type		a character in [duoxX]; u acts the same as d
 *
 * CAUTION:  o, x and X conversions on regular ints can never
 * produce a '-' sign, but can for Python's unbounded ints.
 */</comment>
<function><type><name>PyObject</name>*</type>
<name>_PyString_FormatLong</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>val</name></decl></param>, <param><decl><type><name>int</name></type> <name>flags</name></decl></param>, <param><decl><type><name>int</name></type> <name>prec</name></decl></param>, <param><decl><type><name>int</name></type> <name>type</name></decl></param>,
		     <param><decl><type><name>char</name> **</type><name>pbuf</name></decl></param>, <param><decl><type><name>int</name> *</type><name>plen</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>result</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> *</type><name>buf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>sign</name></decl>;</decl_stmt>	<comment type="block">/* 1 if '-', else 0 */</comment>
	<decl_stmt><decl><type><name>int</name></type> <name>len</name></decl>;</decl_stmt>	<comment type="block">/* number of characters */</comment>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>llen</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>numdigits</name></decl>;</decl_stmt>	<comment type="block">/* len == numnondigits + numdigits */</comment>
	<decl_stmt><decl><type><name>int</name></type> <name>numnondigits</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>

	<switch>switch <condition>(<expr><name>type</name></expr>)</condition> <block>{
	<case>case <expr>'d'</expr>:
	</case><case>case <expr>'u'</expr>:
		<expr_stmt><expr><name>result</name> = <call><name>Py_TYPE</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call>-&gt;<call><name>tp_str</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<break>break;</break>
	</case><case>case <expr>'o'</expr>:
		<expr_stmt><expr><name>result</name> = <call><name>Py_TYPE</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call>-&gt;<call><name><name>tp_as_number</name>-&gt;<name>nb_oct</name></name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<break>break;</break>
	</case><case>case <expr>'x'</expr>:
	</case><case>case <expr>'X'</expr>:
		<expr_stmt><expr><name>numnondigits</name> = 2</expr>;</expr_stmt>
		<expr_stmt><expr><name>result</name> = <call><name>Py_TYPE</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call>-&gt;<call><name><name>tp_as_number</name>-&gt;<name>nb_hex</name></name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<break>break;</break>
	</case><default>default:
		<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr>!"'type' not in [duoxX]"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</default>}</block></switch>
	<if>if <condition>(<expr>!<name>result</name></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>

	<expr_stmt><expr><name>buf</name> = <call><name>PyString_AsString</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr>!<name>buf</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>

	<comment type="block">/* To modify the string in-place, there can only be one reference. */</comment>
	<if>if <condition>(<expr><call><name>Py_REFCNT</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call> != 1</expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_BadInternalCall</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>
	<expr_stmt><expr><name>llen</name> = <call><name>PyString_Size</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>llen</name> &gt; <name>INT_MAX</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>, <argument><expr>"string too large in _PyString_FormatLong"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>
	<expr_stmt><expr><name>len</name> = (<name>int</name>)<name>llen</name></expr>;</expr_stmt>
	<if>if <condition>(<expr><name><name>buf</name><index>[<expr><name>len</name>-1</expr>]</index></name> == 'L'</expr>)</condition><then> <block>{
		<expr_stmt><expr>--<name>len</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>buf</name><index>[<expr><name>len</name></expr>]</index></name> = '\0'</expr>;</expr_stmt>
	}</block></then></if>
	<expr_stmt><expr><name>sign</name> = <name><name>buf</name><index>[<expr>0</expr>]</index></name> == '-'</expr>;</expr_stmt>
	<expr_stmt><expr><name>numnondigits</name> += <name>sign</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>numdigits</name> = <name>len</name> - <name>numnondigits</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>numdigits</name> &gt; 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Get rid of base marker unless F_ALT */</comment>
	<if>if <condition>(<expr>(<name>flags</name> &amp; <name>F_ALT</name>) == 0</expr>)</condition><then> <block>{
		<comment type="block">/* Need to skip 0x, 0X or 0. */</comment>
		<decl_stmt><decl><type><name>int</name></type> <name>skipped</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
		<switch>switch <condition>(<expr><name>type</name></expr>)</condition> <block>{
		<case>case <expr>'o'</expr>:
			<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>buf</name><index>[<expr><name>sign</name></expr>]</index></name> == '0'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* If 0 is only digit, leave it alone. */</comment>
			<if>if <condition>(<expr><name>numdigits</name> &gt; 1</expr>)</condition><then> <block>{
				<expr_stmt><expr><name>skipped</name> = 1</expr>;</expr_stmt>
				<expr_stmt><expr>--<name>numdigits</name></expr>;</expr_stmt>
			}</block></then></if>
			<break>break;</break>
		</case><case>case <expr>'x'</expr>:
		</case><case>case <expr>'X'</expr>:
			<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>buf</name><index>[<expr><name>sign</name></expr>]</index></name> == '0'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>buf</name><index>[<expr><name>sign</name> + 1</expr>]</index></name> == 'x'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>skipped</name> = 2</expr>;</expr_stmt>
			<expr_stmt><expr><name>numnondigits</name> -= 2</expr>;</expr_stmt>
			<break>break;</break>
		</case>}</block></switch>
		<if>if <condition>(<expr><name>skipped</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><name>buf</name> += <name>skipped</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>len</name> -= <name>skipped</name></expr>;</expr_stmt>
			<if>if <condition>(<expr><name>sign</name></expr>)</condition><then>
				<expr_stmt><expr><name><name>buf</name><index>[<expr>0</expr>]</index></name> = '-'</expr>;</expr_stmt></then></if>
		}</block></then></if>
		<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>len</name> == <name>numnondigits</name> + <name>numdigits</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>numdigits</name> &gt; 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>

	<comment type="block">/* Fill with leading zeroes to meet minimum width. */</comment>
	<if>if <condition>(<expr><name>prec</name> &gt; <name>numdigits</name></expr>)</condition><then> <block>{
		<decl_stmt><decl><type><name>PyObject</name> *</type><name>r1</name> <init>= <expr><call><name>PyString_FromStringAndSize</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>,
					<argument><expr><name>numnondigits</name> + <name>prec</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name> *</type><name>b1</name></decl>;</decl_stmt>
		<if>if <condition>(<expr>!<name>r1</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>NULL</name></expr>;</return>
		}</block></then></if>
		<expr_stmt><expr><name>b1</name> = <call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>r1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>numnondigits</name></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>)
			<expr_stmt><expr>*<name>b1</name>++ = *<name>buf</name>++</expr>;</expr_stmt></for>
		<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>prec</name> - <name>numdigits</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
			<expr_stmt><expr>*<name>b1</name>++ = '0'</expr>;</expr_stmt></for>
		<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>numdigits</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
			<expr_stmt><expr>*<name>b1</name>++ = *<name>buf</name>++</expr>;</expr_stmt></for>
		<expr_stmt><expr>*<name>b1</name> = '\0'</expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>result</name> = <name>r1</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>buf</name> = <call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>len</name> = <name>numnondigits</name> + <name>prec</name></expr>;</expr_stmt>
	}</block></then></if>

	<comment type="block">/* Fix up case for hex conversions. */</comment>
	<if>if <condition>(<expr><name>type</name> == 'X'</expr>)</condition><then> <block>{
		<comment type="block">/* Need to convert all lower case letters to upper case.
		   and need to convert 0x to 0X (and -0x to -0X). */</comment>
		<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>len</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
			<if>if <condition>(<expr><name><name>buf</name><index>[<expr><name>i</name></expr>]</index></name> &gt;= 'a' &amp;&amp; <name><name>buf</name><index>[<expr><name>i</name></expr>]</index></name> &lt;= 'x'</expr>)</condition><then>
				<expr_stmt><expr><name><name>buf</name><index>[<expr><name>i</name></expr>]</index></name> -= 'a'-'A'</expr>;</expr_stmt></then></if></for>
	}</block></then></if>
	<expr_stmt><expr>*<name>pbuf</name> = <name>buf</name></expr>;</expr_stmt>
	<expr_stmt><expr>*<name>plen</name> = <name>len</name></expr>;</expr_stmt>
	<return>return <expr><name>result</name></expr>;</return>
}</block></function>

<macro><name>Py_LOCAL_INLINE</name><argument_list>(<argument>int</argument>)</argument_list></macro>
<macro><name>formatint</name><argument_list>(<argument>char *buf</argument>, <argument>size_t buflen</argument>, <argument>int flags</argument>,
          <argument>int prec</argument>, <argument>int type</argument>, <argument>PyObject *v</argument>)</argument_list></macro>
<block>{
	<comment type="block">/* fmt = '%#.' + `prec` + 'l' + `type`
	   worst case length = 3 + 19 (worst len of INT_MAX on 64-bit machine)
	   + 1 + 1 = 24 */</comment>
	<decl_stmt><decl><type><name>char</name></type> <name><name>fmt</name><index>[<expr>64</expr>]</index></name></decl>;</decl_stmt>	<comment type="block">/* plenty big enough! */</comment>
	<decl_stmt><decl><type><name>char</name> *</type><name>sign</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>long</name></type> <name>x</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>x</name> = <call><name>PyInt_AsLong</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>x</name> == -1 &amp;&amp; <call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>, <argument><expr>"int argument required, not %.200s"</expr></argument>,
			     <argument><expr><call><name>Py_TYPE</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call>-&gt;<name>tp_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>-1</expr>;</return>
	}</block></then></if>
	<if>if <condition>(<expr><name>x</name> &lt; 0 &amp;&amp; <name>type</name> == 'u'</expr>)</condition><then> <block>{
		<expr_stmt><expr><name>type</name> = 'd'</expr>;</expr_stmt>
	}</block></then></if>
	<if>if <condition>(<expr><name>x</name> &lt; 0 &amp;&amp; (<name>type</name> == 'x' || <name>type</name> == 'X' || <name>type</name> == 'o')</expr>)</condition><then>
		<expr_stmt><expr><name>sign</name> = "-"</expr>;</expr_stmt></then>
	<else>else
		<expr_stmt><expr><name>sign</name> = ""</expr>;</expr_stmt></else></if>
	<if>if <condition>(<expr><name>prec</name> &lt; 0</expr>)</condition><then>
		<expr_stmt><expr><name>prec</name> = 1</expr>;</expr_stmt></then></if>

	<if>if <condition>(<expr>(<name>flags</name> &amp; <name>F_ALT</name>) &amp;&amp;
	    (<name>type</name> == 'x' || <name>type</name> == 'X')</expr>)</condition><then> <block>{
		<comment type="block">/* When converting under %#x or %#X, there are a number
		 * of issues that cause pain:
		 * - when 0 is being converted, the C standard leaves off
		 *   the '0x' or '0X', which is inconsistent with other
		 *   %#x/%#X conversions and inconsistent with Python's
		 *   hex() function
		 * - there are platforms that violate the standard and
		 *   convert 0 with the '0x' or '0X'
		 *   (Metrowerks, Compaq Tru64)
		 * - there are platforms that give '0x' when converting
		 *   under %#X, but convert 0 in accordance with the
		 *   standard (OS/2 EMX)
		 *
		 * We can achieve the desired consistency by inserting our
		 * own '0x' or '0X' prefix, and substituting %x/%X in place
		 * of %#x/%#X.
		 *
		 * Note that this is the same approach as used in
		 * formatint() in unicodeobject.c
		 */</comment>
		<expr_stmt><expr><call><name>PyOS_snprintf</name><argument_list>(<argument><expr><name>fmt</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>fmt</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr>"%s0%c%%.%dl%c"</expr></argument>,
			      <argument><expr><name>sign</name></expr></argument>, <argument><expr><name>type</name></expr></argument>, <argument><expr><name>prec</name></expr></argument>, <argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then>
	<else>else <block>{
		<expr_stmt><expr><call><name>PyOS_snprintf</name><argument_list>(<argument><expr><name>fmt</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>fmt</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr>"%s%%%s.%dl%c"</expr></argument>,
			      <argument><expr><name>sign</name></expr></argument>, <argument><expr>(<name>flags</name>&amp;<name>F_ALT</name>) ? "#" : ""</expr></argument>,
			      <argument><expr><name>prec</name></expr></argument>, <argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></else></if>

	<comment type="block">/* buf = '+'/'-'/'' + '0'/'0x'/'' + '[0-9]'*max(prec, len(x in octal))
	 * worst case buf = '-0x' + [0-9]*prec, where prec &gt;= 11
	 */</comment>
	<if>if <condition>(<expr><name>buflen</name> &lt;= 14 || <name>buflen</name> &lt;= (<name>size_t</name>)3 + (<name>size_t</name>)<name>prec</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_OverflowError</name></expr></argument>,
		    <argument><expr>"formatted integer is too long (precision too large?)"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>-1</expr>;</return>
	}</block></then></if>
	<if>if <condition>(<expr><name><name>sign</name><index>[<expr>0</expr>]</index></name></expr>)</condition><then>
		<expr_stmt><expr><call><name>PyOS_snprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>buflen</name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>, <argument><expr>-<name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
	<else>else
		<expr_stmt><expr><call><name>PyOS_snprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>buflen</name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>, <argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
	<return>return <expr>(<name>int</name>)<call><name>strlen</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<macro><name>Py_LOCAL_INLINE</name><argument_list>(<argument>int</argument>)</argument_list></macro>
<macro><name>formatchar</name><argument_list>(<argument>char *buf</argument>, <argument>size_t buflen</argument>, <argument>PyObject *v</argument>)</argument_list></macro>
<block>{
	<comment type="block">/* presume that the buffer is at least 2 characters long */</comment>
	<if>if <condition>(<expr><call><name>PyString_Check</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<if>if <condition>(<expr>!<call><name>PyArg_Parse</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr>"c;%c requires int or char"</expr></argument>, <argument><expr>&amp;<name><name>buf</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><then>
			<return>return <expr>-1</expr>;</return></then></if>
	}</block></then>
	<else>else <block>{
		<if>if <condition>(<expr>!<call><name>PyArg_Parse</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr>"b;%c requires int or char"</expr></argument>, <argument><expr>&amp;<name><name>buf</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><then>
			<return>return <expr>-1</expr>;</return></then></if>
	}</block></else></if>
	<expr_stmt><expr><name><name>buf</name><index>[<expr>1</expr>]</index></name> = '\0'</expr>;</expr_stmt>
	<return>return <expr>1</expr>;</return>
}</block>

<comment type="block">/* fmt%(v1,v2,...) is roughly equivalent to sprintf(fmt, v1, v2, ...)

   FORMATBUFLEN is the length of the buffer in which the floats, ints, &amp;
   chars are formatted. XXX This is a magic number. Each formatting
   routine does bounds checking to ensure no overflow, but a better
   solution may be to malloc a buffer of appropriate size for each
   format. For now, the current solution is sufficient.
*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FORMATBUFLEN</name></cpp:macro> <cpp:value>(size_t)120</cpp:value></cpp:define>

<function><type><name>PyObject</name> *</type>
<name>PyString_Format</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>format</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>char</name> *</type><name>fmt</name></decl>, *<decl><type ref="prev"/><name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>arglen</name></decl>, <decl><type ref="prev"/><name>argidx</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>reslen</name></decl>, <decl><type ref="prev"/><name>rescnt</name></decl>, <decl><type ref="prev"/><name>fmtcnt</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>args_owned</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>result</name></decl>, *<decl><type ref="prev"/><name>orig_args</name></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>Py_USING_UNICODE</name></cpp:ifdef>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>v</name></decl>, *<decl><type ref="prev"/><name>w</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>dict</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<if>if <condition>(<expr><name>format</name> == <name>NULL</name> || !<call><name>PyString_Check</name><argument_list>(<argument><expr><name>format</name></expr></argument>)</argument_list></call> || <name>args</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_BadInternalCall</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>
	<expr_stmt><expr><name>orig_args</name> = <name>args</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>fmt</name> = <call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>format</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>fmtcnt</name> = <call><name>PyString_GET_SIZE</name><argument_list>(<argument><expr><name>format</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>reslen</name> = <name>rescnt</name> = <name>fmtcnt</name> + 100</expr>;</expr_stmt>
	<expr_stmt><expr><name>result</name> = <call><name>PyString_FromStringAndSize</name><argument_list>(<argument><expr>(<name>char</name> *)<name>NULL</name></expr></argument>, <argument><expr><name>reslen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>result</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<expr_stmt><expr><name>res</name> = <call><name>PyString_AsString</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><call><name>PyTuple_Check</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>arglen</name> = <call><name>PyTuple_GET_SIZE</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>argidx</name> = 0</expr>;</expr_stmt>
	}</block></then>
	<else>else <block>{
		<expr_stmt><expr><name>arglen</name> = -1</expr>;</expr_stmt>
		<expr_stmt><expr><name>argidx</name> = -2</expr>;</expr_stmt>
	}</block></else></if>
	<if>if <condition>(<expr><call><name>Py_TYPE</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call>-&gt;<name>tp_as_mapping</name> &amp;&amp; !<call><name>PyTuple_Check</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call> &amp;&amp;
	    !<call><name>PyObject_TypeCheck</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>&amp;<name>PyBaseString_Type</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<expr_stmt><expr><name>dict</name> = <name>args</name></expr>;</expr_stmt></then></if>
	<while>while <condition>(<expr>--<name>fmtcnt</name> &gt;= 0</expr>)</condition> <block>{
		<if>if <condition>(<expr>*<name>fmt</name> != '%'</expr>)</condition><then> <block>{
			<if>if <condition>(<expr>--<name>rescnt</name> &lt; 0</expr>)</condition><then> <block>{
				<expr_stmt><expr><name>rescnt</name> = <name>fmtcnt</name> + 100</expr>;</expr_stmt>
				<expr_stmt><expr><name>reslen</name> += <name>rescnt</name></expr>;</expr_stmt>
				<if>if <condition>(<expr><call><name>_PyString_Resize</name><argument_list>(<argument><expr>&amp;<name>result</name></expr></argument>, <argument><expr><name>reslen</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
					<return>return <expr><name>NULL</name></expr>;</return></then></if>
				<expr_stmt><expr><name>res</name> = <call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call>
					+ <name>reslen</name> - <name>rescnt</name></expr>;</expr_stmt>
				<expr_stmt><expr>--<name>rescnt</name></expr>;</expr_stmt>
			}</block></then></if>
			<expr_stmt><expr>*<name>res</name>++ = *<name>fmt</name>++</expr>;</expr_stmt>
		}</block></then>
		<else>else <block>{
			<comment type="block">/* Got a format specifier */</comment>
			<decl_stmt><decl><type><name>int</name></type> <name>flags</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>width</name> <init>= <expr>-1</expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type> <name>prec</name> <init>= <expr>-1</expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type> <name>c</name> <init>= <expr>'\0'</expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type> <name>fill</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type> <name>isnumok</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>PyObject</name> *</type><name>v</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>PyObject</name> *</type><name>temp</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>char</name> *</type><name>pbuf</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type> <name>sign</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>len</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>char</name></type> <name><name>formatbuf</name><index>[<expr><name>FORMATBUFLEN</name></expr>]</index></name></decl>;</decl_stmt>
			     <comment type="block">/* For format{float,int,char}() */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>Py_USING_UNICODE</name></cpp:ifdef>
			<decl_stmt><decl><type><name>char</name> *</type><name>fmt_start</name> <init>= <expr><name>fmt</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>argidx_start</name> <init>= <expr><name>argidx</name></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

			<expr_stmt><expr><name>fmt</name>++</expr>;</expr_stmt>
			<if>if <condition>(<expr>*<name>fmt</name> == '('</expr>)</condition><then> <block>{
				<decl_stmt><decl><type><name>char</name> *</type><name>keystart</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>keylen</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>PyObject</name> *</type><name>key</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>int</name></type> <name>pcount</name> <init>= <expr>1</expr></init></decl>;</decl_stmt>

				<if>if <condition>(<expr><name>dict</name> == <name>NULL</name></expr>)</condition><then> <block>{
					<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
						 <argument><expr>"format requires a mapping"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<goto>goto <name>error</name>;</goto>
				}</block></then></if>
				<expr_stmt><expr>++<name>fmt</name></expr>;</expr_stmt>
				<expr_stmt><expr>--<name>fmtcnt</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>keystart</name> = <name>fmt</name></expr>;</expr_stmt>
				<comment type="block">/* Skip over balanced parentheses */</comment>
				<while>while <condition>(<expr><name>pcount</name> &gt; 0 &amp;&amp; --<name>fmtcnt</name> &gt;= 0</expr>)</condition> <block>{
					<if>if <condition>(<expr>*<name>fmt</name> == ')'</expr>)</condition><then>
						<expr_stmt><expr>--<name>pcount</name></expr>;</expr_stmt></then>
					<else>else <if>if <condition>(<expr>*<name>fmt</name> == '('</expr>)</condition><then>
						<expr_stmt><expr>++<name>pcount</name></expr>;</expr_stmt></then></if></else></if>
					<expr_stmt><expr><name>fmt</name>++</expr>;</expr_stmt>
				}</block></while>
				<expr_stmt><expr><name>keylen</name> = <name>fmt</name> - <name>keystart</name> - 1</expr>;</expr_stmt>
				<if>if <condition>(<expr><name>fmtcnt</name> &lt; 0 || <name>pcount</name> &gt; 0</expr>)</condition><then> <block>{
					<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>,
						   <argument><expr>"incomplete format key"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<goto>goto <name>error</name>;</goto>
				}</block></then></if>
				<expr_stmt><expr><name>key</name> = <call><name>PyString_FromStringAndSize</name><argument_list>(<argument><expr><name>keystart</name></expr></argument>,
								 <argument><expr><name>keylen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if>if <condition>(<expr><name>key</name> == <name>NULL</name></expr>)</condition><then>
					<goto>goto <name>error</name>;</goto></then></if>
				<if>if <condition>(<expr><name>args_owned</name></expr>)</condition><then> <block>{
					<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>args_owned</name> = 0</expr>;</expr_stmt>
				}</block></then></if>
				<expr_stmt><expr><name>args</name> = <call><name>PyObject_GetItem</name><argument_list>(<argument><expr><name>dict</name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if>if <condition>(<expr><name>args</name> == <name>NULL</name></expr>)</condition><then> <block>{
					<goto>goto <name>error</name>;</goto>
				}</block></then></if>
				<expr_stmt><expr><name>args_owned</name> = 1</expr>;</expr_stmt>
				<expr_stmt><expr><name>arglen</name> = -1</expr>;</expr_stmt>
				<expr_stmt><expr><name>argidx</name> = -2</expr>;</expr_stmt>
			}</block></then></if>
			<while>while <condition>(<expr>--<name>fmtcnt</name> &gt;= 0</expr>)</condition> <block>{
				<switch>switch <condition>(<expr><name>c</name> = *<name>fmt</name>++</expr>)</condition> <block>{
				<case>case <expr>'-'</expr>: <expr_stmt><expr><name>flags</name> |= <name>F_LJUST</name></expr>;</expr_stmt> <continue>continue;</continue>
				</case><case>case <expr>'+'</expr>: <expr_stmt><expr><name>flags</name> |= <name>F_SIGN</name></expr>;</expr_stmt> <continue>continue;</continue>
				</case><case>case <expr>' '</expr>: <expr_stmt><expr><name>flags</name> |= <name>F_BLANK</name></expr>;</expr_stmt> <continue>continue;</continue>
				</case><case>case <expr>'#'</expr>: <expr_stmt><expr><name>flags</name> |= <name>F_ALT</name></expr>;</expr_stmt> <continue>continue;</continue>
				</case><case>case <expr>'0'</expr>: <expr_stmt><expr><name>flags</name> |= <name>F_ZERO</name></expr>;</expr_stmt> <continue>continue;</continue>
				</case>}</block></switch>
				<break>break;</break>
			}</block></while>
			<if>if <condition>(<expr><name>c</name> == '*'</expr>)</condition><then> <block>{
				<expr_stmt><expr><name>v</name> = <call><name>getnextarg</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>arglen</name></expr></argument>, <argument><expr>&amp;<name>argidx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if>if <condition>(<expr><name>v</name> == <name>NULL</name></expr>)</condition><then>
					<goto>goto <name>error</name>;</goto></then></if>
				<if>if <condition>(<expr>!<call><name>PyInt_Check</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
					<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
							<argument><expr>"* wants int"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<goto>goto <name>error</name>;</goto>
				}</block></then></if>
				<expr_stmt><expr><name>width</name> = <call><name>PyInt_AsLong</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if>if <condition>(<expr><name>width</name> &lt; 0</expr>)</condition><then> <block>{
					<expr_stmt><expr><name>flags</name> |= <name>F_LJUST</name></expr>;</expr_stmt>
					<expr_stmt><expr><name>width</name> = -<name>width</name></expr>;</expr_stmt>
				}</block></then></if>
				<if>if <condition>(<expr>--<name>fmtcnt</name> &gt;= 0</expr>)</condition><then>
					<expr_stmt><expr><name>c</name> = *<name>fmt</name>++</expr>;</expr_stmt></then></if>
			}</block></then>
			<else>else <if>if <condition>(<expr><name>c</name> &gt;= 0 &amp;&amp; <call><name>isdigit</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
				<expr_stmt><expr><name>width</name> = <name>c</name> - '0'</expr>;</expr_stmt>
				<while>while <condition>(<expr>--<name>fmtcnt</name> &gt;= 0</expr>)</condition> <block>{
					<expr_stmt><expr><name>c</name> = <call><name>Py_CHARMASK</name><argument_list>(<argument><expr>*<name>fmt</name>++</expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if>if <condition>(<expr>!<call><name>isdigit</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>)</condition><then>
						<break>break;</break></then></if>
					<if>if <condition>(<expr>(<name>width</name>*10) / 10 != <name>width</name></expr>)</condition><then> <block>{
						<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(
							<argument><expr><name>PyExc_ValueError</name></expr></argument>,
							<argument><expr>"width too big"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<goto>goto <name>error</name>;</goto>
					}</block></then></if>
					<expr_stmt><expr><name>width</name> = <name>width</name>*10 + (<name>c</name> - '0')</expr>;</expr_stmt>
				}</block></while>
			}</block></then></if></else></if>
			<if>if <condition>(<expr><name>c</name> == '.'</expr>)</condition><then> <block>{
				<expr_stmt><expr><name>prec</name> = 0</expr>;</expr_stmt>
				<if>if <condition>(<expr>--<name>fmtcnt</name> &gt;= 0</expr>)</condition><then>
					<expr_stmt><expr><name>c</name> = *<name>fmt</name>++</expr>;</expr_stmt></then></if>
				<if>if <condition>(<expr><name>c</name> == '*'</expr>)</condition><then> <block>{
					<expr_stmt><expr><name>v</name> = <call><name>getnextarg</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>arglen</name></expr></argument>, <argument><expr>&amp;<name>argidx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if>if <condition>(<expr><name>v</name> == <name>NULL</name></expr>)</condition><then>
						<goto>goto <name>error</name>;</goto></then></if>
					<if>if <condition>(<expr>!<call><name>PyInt_Check</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
						<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(
							<argument><expr><name>PyExc_TypeError</name></expr></argument>,
							<argument><expr>"* wants int"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<goto>goto <name>error</name>;</goto>
					}</block></then></if>
					<expr_stmt><expr><name>prec</name> = <call><name>PyInt_AsLong</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if>if <condition>(<expr><name>prec</name> &lt; 0</expr>)</condition><then>
						<expr_stmt><expr><name>prec</name> = 0</expr>;</expr_stmt></then></if>
					<if>if <condition>(<expr>--<name>fmtcnt</name> &gt;= 0</expr>)</condition><then>
						<expr_stmt><expr><name>c</name> = *<name>fmt</name>++</expr>;</expr_stmt></then></if>
				}</block></then>
				<else>else <if>if <condition>(<expr><name>c</name> &gt;= 0 &amp;&amp; <call><name>isdigit</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
					<expr_stmt><expr><name>prec</name> = <name>c</name> - '0'</expr>;</expr_stmt>
					<while>while <condition>(<expr>--<name>fmtcnt</name> &gt;= 0</expr>)</condition> <block>{
						<expr_stmt><expr><name>c</name> = <call><name>Py_CHARMASK</name><argument_list>(<argument><expr>*<name>fmt</name>++</expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<if>if <condition>(<expr>!<call><name>isdigit</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>)</condition><then>
							<break>break;</break></then></if>
						<if>if <condition>(<expr>(<name>prec</name>*10) / 10 != <name>prec</name></expr>)</condition><then> <block>{
							<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(
							    <argument><expr><name>PyExc_ValueError</name></expr></argument>,
							    <argument><expr>"prec too big"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<goto>goto <name>error</name>;</goto>
						}</block></then></if>
						<expr_stmt><expr><name>prec</name> = <name>prec</name>*10 + (<name>c</name> - '0')</expr>;</expr_stmt>
					}</block></while>
				}</block></then></if></else></if>
			}</block></then></if> <comment type="block">/* prec */</comment>
			<if>if <condition>(<expr><name>fmtcnt</name> &gt;= 0</expr>)</condition><then> <block>{
				<if>if <condition>(<expr><name>c</name> == 'h' || <name>c</name> == 'l' || <name>c</name> == 'L'</expr>)</condition><then> <block>{
					<if>if <condition>(<expr>--<name>fmtcnt</name> &gt;= 0</expr>)</condition><then>
						<expr_stmt><expr><name>c</name> = *<name>fmt</name>++</expr>;</expr_stmt></then></if>
				}</block></then></if>
			}</block></then></if>
			<if>if <condition>(<expr><name>fmtcnt</name> &lt; 0</expr>)</condition><then> <block>{
				<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>,
						<argument><expr>"incomplete format"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<goto>goto <name>error</name>;</goto>
			}</block></then></if>
			<if>if <condition>(<expr><name>c</name> != '%'</expr>)</condition><then> <block>{
				<expr_stmt><expr><name>v</name> = <call><name>getnextarg</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>arglen</name></expr></argument>, <argument><expr>&amp;<name>argidx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if>if <condition>(<expr><name>v</name> == <name>NULL</name></expr>)</condition><then>
					<goto>goto <name>error</name>;</goto></then></if>
			}</block></then></if>
			<expr_stmt><expr><name>sign</name> = 0</expr>;</expr_stmt>
			<expr_stmt><expr><name>fill</name> = ' '</expr>;</expr_stmt>
			<switch>switch <condition>(<expr><name>c</name></expr>)</condition> <block>{
			<case>case <expr>'%'</expr>:
				<expr_stmt><expr><name>pbuf</name> = "%"</expr>;</expr_stmt>
				<expr_stmt><expr><name>len</name> = 1</expr>;</expr_stmt>
				<break>break;</break>
			</case><case>case <expr>'s'</expr>:
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>Py_USING_UNICODE</name></cpp:ifdef>
				<if>if <condition>(<expr><call><name>PyUnicode_Check</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
					<expr_stmt><expr><name>fmt</name> = <name>fmt_start</name></expr>;</expr_stmt>
					<expr_stmt><expr><name>argidx</name> = <name>argidx_start</name></expr>;</expr_stmt>
					<goto>goto <name>unicode</name>;</goto>
				}</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
				<expr_stmt><expr><name>temp</name> = <call><name>_PyObject_Str</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>Py_USING_UNICODE</name></cpp:ifdef>
				<if>if <condition>(<expr><name>temp</name> != <name>NULL</name> &amp;&amp; <call><name>PyUnicode_Check</name><argument_list>(<argument><expr><name>temp</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
					<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>temp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>fmt</name> = <name>fmt_start</name></expr>;</expr_stmt>
					<expr_stmt><expr><name>argidx</name> = <name>argidx_start</name></expr>;</expr_stmt>
					<goto>goto <name>unicode</name>;</goto>
				}</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
				<comment type="block">/* Fall through */</comment>
			</case><case>case <expr>'r'</expr>:
				<if>if <condition>(<expr><name>c</name> == 'r'</expr>)</condition><then>
					<expr_stmt><expr><name>temp</name> = <call><name>PyObject_Repr</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
				<if>if <condition>(<expr><name>temp</name> == <name>NULL</name></expr>)</condition><then>
					<goto>goto <name>error</name>;</goto></then></if>
				<if>if <condition>(<expr>!<call><name>PyString_Check</name><argument_list>(<argument><expr><name>temp</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
					<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
					  <argument><expr>"%s argument has non-string str()"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>temp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<goto>goto <name>error</name>;</goto>
				}</block></then></if>
				<expr_stmt><expr><name>pbuf</name> = <call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>temp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>len</name> = <call><name>PyString_GET_SIZE</name><argument_list>(<argument><expr><name>temp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if>if <condition>(<expr><name>prec</name> &gt;= 0 &amp;&amp; <name>len</name> &gt; <name>prec</name></expr>)</condition><then>
					<expr_stmt><expr><name>len</name> = <name>prec</name></expr>;</expr_stmt></then></if>
				<break>break;</break>
			</case><case>case <expr>'i'</expr>:
			</case><case>case <expr>'d'</expr>:
			</case><case>case <expr>'u'</expr>:
			</case><case>case <expr>'o'</expr>:
			</case><case>case <expr>'x'</expr>:
			</case><case>case <expr>'X'</expr>:
				<if>if <condition>(<expr><name>c</name> == 'i'</expr>)</condition><then>
					<expr_stmt><expr><name>c</name> = 'd'</expr>;</expr_stmt></then></if>
				<expr_stmt><expr><name>isnumok</name> = 0</expr>;</expr_stmt>
				<if>if <condition>(<expr><call><name>PyNumber_Check</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
					<decl_stmt><decl><type><name>PyObject</name> *</type><name>iobj</name><init>=<expr><name>NULL</name></expr></init></decl>;</decl_stmt>

					<if>if <condition>(<expr><call><name>PyInt_Check</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call> || (<call><name>PyLong_Check</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call>)</expr>)</condition><then> <block>{
						<expr_stmt><expr><name>iobj</name> = <name>v</name></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>iobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					}</block></then>
					<else>else <block>{
						<expr_stmt><expr><name>iobj</name> = <call><name>PyNumber_Int</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<if>if <condition>(<expr><name>iobj</name>==<name>NULL</name></expr>)</condition><then> <expr_stmt><expr><name>iobj</name> = <call><name>PyNumber_Long</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
					}</block></else></if>
					<if>if <condition>(<expr><name>iobj</name>!=<name>NULL</name></expr>)</condition><then> <block>{
						<if>if <condition>(<expr><call><name>PyInt_Check</name><argument_list>(<argument><expr><name>iobj</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
							<expr_stmt><expr><name>isnumok</name> = 1</expr>;</expr_stmt>
							<expr_stmt><expr><name>pbuf</name> = <name>formatbuf</name></expr>;</expr_stmt>
							<expr_stmt><expr><name>len</name> = <call><name>formatint</name><argument_list>(<argument><expr><name>pbuf</name></expr></argument>,
									<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>formatbuf</name></expr></argument>)</argument_list></sizeof></expr></argument>,
									<argument><expr><name>flags</name></expr></argument>, <argument><expr><name>prec</name></expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><name>iobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>iobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<if>if <condition>(<expr><name>len</name> &lt; 0</expr>)</condition><then>
								<goto>goto <name>error</name>;</goto></then></if>
							<expr_stmt><expr><name>sign</name> = 1</expr>;</expr_stmt>
						}</block></then>
						<else>else <if>if <condition>(<expr><call><name>PyLong_Check</name><argument_list>(<argument><expr><name>iobj</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
							<decl_stmt><decl><type><name>int</name></type> <name>ilen</name></decl>;</decl_stmt>
							
							<expr_stmt><expr><name>isnumok</name> = 1</expr>;</expr_stmt>
							<expr_stmt><expr><name>temp</name> = <call><name>_PyString_FormatLong</name><argument_list>(<argument><expr><name>iobj</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>,
								<argument><expr><name>prec</name></expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr>&amp;<name>pbuf</name></expr></argument>, <argument><expr>&amp;<name>ilen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>iobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<expr_stmt><expr><name>len</name> = <name>ilen</name></expr>;</expr_stmt>
							<if>if <condition>(<expr>!<name>temp</name></expr>)</condition><then>
								<goto>goto <name>error</name>;</goto></then></if>
							<expr_stmt><expr><name>sign</name> = 1</expr>;</expr_stmt>
						}</block></then>
						<else>else <block>{
							<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>iobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						}</block></else></if></else></if>
					}</block></then></if>
				}</block></then></if>
				<if>if <condition>(<expr>!<name>isnumok</name></expr>)</condition><then> <block>{
					<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>, 
					    <argument><expr>"%%%c format: a number is required, "
					    "not %.200s"</expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><call><name>Py_TYPE</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call>-&gt;<name>tp_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<goto>goto <name>error</name>;</goto>
				}</block></then></if>
				<if>if <condition>(<expr><name>flags</name> &amp; <name>F_ZERO</name></expr>)</condition><then>
					<expr_stmt><expr><name>fill</name> = '0'</expr>;</expr_stmt></then></if>
				<break>break;</break>
			</case><case>case <expr>'e'</expr>:
			</case><case>case <expr>'E'</expr>:
			</case><case>case <expr>'f'</expr>:
			</case><case>case <expr>'F'</expr>:
			</case><case>case <expr>'g'</expr>:
			</case><case>case <expr>'G'</expr>:
				<if>if <condition>(<expr><name>c</name> == 'F'</expr>)</condition><then>
					<expr_stmt><expr><name>c</name> = 'f'</expr>;</expr_stmt></then></if>
				<expr_stmt><expr><name>pbuf</name> = <name>formatbuf</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>len</name> = <call><name>formatfloat</name><argument_list>(<argument><expr><name>pbuf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>formatbuf</name></expr></argument>)</argument_list></sizeof></expr></argument>,
						  <argument><expr><name>flags</name></expr></argument>, <argument><expr><name>prec</name></expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if>if <condition>(<expr><name>len</name> &lt; 0</expr>)</condition><then>
					<goto>goto <name>error</name>;</goto></then></if>
				<expr_stmt><expr><name>sign</name> = 1</expr>;</expr_stmt>
				<if>if <condition>(<expr><name>flags</name> &amp; <name>F_ZERO</name></expr>)</condition><then>
					<expr_stmt><expr><name>fill</name> = '0'</expr>;</expr_stmt></then></if>
				<break>break;</break>
			</case><case>case <expr>'c'</expr>:
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>Py_USING_UNICODE</name></cpp:ifdef>
				<if>if <condition>(<expr><call><name>PyUnicode_Check</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
					<expr_stmt><expr><name>fmt</name> = <name>fmt_start</name></expr>;</expr_stmt>
					<expr_stmt><expr><name>argidx</name> = <name>argidx_start</name></expr>;</expr_stmt>
					<goto>goto <name>unicode</name>;</goto>
				}</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
				<expr_stmt><expr><name>pbuf</name> = <name>formatbuf</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>len</name> = <call><name>formatchar</name><argument_list>(<argument><expr><name>pbuf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>formatbuf</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if>if <condition>(<expr><name>len</name> &lt; 0</expr>)</condition><then>
					<goto>goto <name>error</name>;</goto></then></if>
				<break>break;</break>
			</case><default>default:
				<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>,
				  <argument><expr>"unsupported format character '%c' (0x%x) "
				  "at index %zd"</expr></argument>,
				  <argument><expr><name>c</name></expr></argument>, <argument><expr><name>c</name></expr></argument>,
				  <argument><expr><call>(<name>Py_ssize_t</name>)<argument_list>(<argument><expr><name>fmt</name> - 1 -
					       <call><name>PyString_AsString</name><argument_list>(<argument><expr><name>format</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<goto>goto <name>error</name>;</goto>
			</default>}</block></switch>
			<if>if <condition>(<expr><name>sign</name></expr>)</condition><then> <block>{
				<if>if <condition>(<expr>*<name>pbuf</name> == '-' || *<name>pbuf</name> == '+'</expr>)</condition><then> <block>{
					<expr_stmt><expr><name>sign</name> = *<name>pbuf</name>++</expr>;</expr_stmt>
					<expr_stmt><expr><name>len</name>--</expr>;</expr_stmt>
				}</block></then>
				<else>else <if>if <condition>(<expr><name>flags</name> &amp; <name>F_SIGN</name></expr>)</condition><then>
					<expr_stmt><expr><name>sign</name> = '+'</expr>;</expr_stmt></then>
				<else>else <if>if <condition>(<expr><name>flags</name> &amp; <name>F_BLANK</name></expr>)</condition><then>
					<expr_stmt><expr><name>sign</name> = ' '</expr>;</expr_stmt></then>
				<else>else
					<expr_stmt><expr><name>sign</name> = 0</expr>;</expr_stmt></else></if></else></if></else></if>
			}</block></then></if>
			<if>if <condition>(<expr><name>width</name> &lt; <name>len</name></expr>)</condition><then>
				<expr_stmt><expr><name>width</name> = <name>len</name></expr>;</expr_stmt></then></if>
			<if>if <condition>(<expr><name>rescnt</name> - (<name>sign</name> != 0) &lt; <name>width</name></expr>)</condition><then> <block>{
				<expr_stmt><expr><name>reslen</name> -= <name>rescnt</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>rescnt</name> = <name>width</name> + <name>fmtcnt</name> + 100</expr>;</expr_stmt>
				<expr_stmt><expr><name>reslen</name> += <name>rescnt</name></expr>;</expr_stmt>
				<if>if <condition>(<expr><name>reslen</name> &lt; 0</expr>)</condition><then> <block>{
					<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>temp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<return>return <expr><call><name>PyErr_NoMemory</name><argument_list>()</argument_list></call></expr>;</return>
				}</block></then></if>
				<if>if <condition>(<expr><call><name>_PyString_Resize</name><argument_list>(<argument><expr>&amp;<name>result</name></expr></argument>, <argument><expr><name>reslen</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then> <block>{
					<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>temp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<return>return <expr><name>NULL</name></expr>;</return>
				}</block></then></if>
				<expr_stmt><expr><name>res</name> = <call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call>
					+ <name>reslen</name> - <name>rescnt</name></expr>;</expr_stmt>
			}</block></then></if>
			<if>if <condition>(<expr><name>sign</name></expr>)</condition><then> <block>{
				<if>if <condition>(<expr><name>fill</name> != ' '</expr>)</condition><then>
					<expr_stmt><expr>*<name>res</name>++ = <name>sign</name></expr>;</expr_stmt></then></if>
				<expr_stmt><expr><name>rescnt</name>--</expr>;</expr_stmt>
				<if>if <condition>(<expr><name>width</name> &gt; <name>len</name></expr>)</condition><then>
					<expr_stmt><expr><name>width</name>--</expr>;</expr_stmt></then></if>
			}</block></then></if>
			<if>if <condition>(<expr>(<name>flags</name> &amp; <name>F_ALT</name>) &amp;&amp; (<name>c</name> == 'x' || <name>c</name> == 'X')</expr>)</condition><then> <block>{
				<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>pbuf</name><index>[<expr>0</expr>]</index></name> == '0'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>pbuf</name><index>[<expr>1</expr>]</index></name> == <name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if>if <condition>(<expr><name>fill</name> != ' '</expr>)</condition><then> <block>{
					<expr_stmt><expr>*<name>res</name>++ = *<name>pbuf</name>++</expr>;</expr_stmt>
					<expr_stmt><expr>*<name>res</name>++ = *<name>pbuf</name>++</expr>;</expr_stmt>
				}</block></then></if>
				<expr_stmt><expr><name>rescnt</name> -= 2</expr>;</expr_stmt>
				<expr_stmt><expr><name>width</name> -= 2</expr>;</expr_stmt>
				<if>if <condition>(<expr><name>width</name> &lt; 0</expr>)</condition><then>
					<expr_stmt><expr><name>width</name> = 0</expr>;</expr_stmt></then></if>
				<expr_stmt><expr><name>len</name> -= 2</expr>;</expr_stmt>
			}</block></then></if>
			<if>if <condition>(<expr><name>width</name> &gt; <name>len</name> &amp;&amp; !(<name>flags</name> &amp; <name>F_LJUST</name>)</expr>)</condition><then> <block>{
				<do>do <block>{
					<expr_stmt><expr>--<name>rescnt</name></expr>;</expr_stmt>
					<expr_stmt><expr>*<name>res</name>++ = <name>fill</name></expr>;</expr_stmt>
				}</block> while <condition>(<expr>--<name>width</name> &gt; <name>len</name></expr>)</condition>;</do>
			}</block></then></if>
			<if>if <condition>(<expr><name>fill</name> == ' '</expr>)</condition><then> <block>{
				<if>if <condition>(<expr><name>sign</name></expr>)</condition><then>
					<expr_stmt><expr>*<name>res</name>++ = <name>sign</name></expr>;</expr_stmt></then></if>
				<if>if <condition>(<expr>(<name>flags</name> &amp; <name>F_ALT</name>) &amp;&amp;
				    (<name>c</name> == 'x' || <name>c</name> == 'X')</expr>)</condition><then> <block>{
					<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>pbuf</name><index>[<expr>0</expr>]</index></name> == '0'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>pbuf</name><index>[<expr>1</expr>]</index></name> == <name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr>*<name>res</name>++ = *<name>pbuf</name>++</expr>;</expr_stmt>
					<expr_stmt><expr>*<name>res</name>++ = *<name>pbuf</name>++</expr>;</expr_stmt>
				}</block></then></if>
			}</block></then></if>
			<expr_stmt><expr><call><name>Py_MEMCPY</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>pbuf</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>res</name> += <name>len</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>rescnt</name> -= <name>len</name></expr>;</expr_stmt>
			<while>while <condition>(<expr>--<name>width</name> &gt;= <name>len</name></expr>)</condition> <block>{
				<expr_stmt><expr>--<name>rescnt</name></expr>;</expr_stmt>
				<expr_stmt><expr>*<name>res</name>++ = ' '</expr>;</expr_stmt>
			}</block></while>
                        <if>if <condition>(<expr><name>dict</name> &amp;&amp; (<name>argidx</name> &lt; <name>arglen</name>) &amp;&amp; <name>c</name> != '%'</expr>)</condition><then> <block>{
                                <expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
                                           <argument><expr>"not all arguments converted during string formatting"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                <expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>temp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                <goto>goto <name>error</name>;</goto>
                        }</block></then></if>
			<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>temp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></else></if> <comment type="block">/* '%' */</comment>
	}</block></while> <comment type="block">/* until end */</comment>
	<if>if <condition>(<expr><name>argidx</name> &lt; <name>arglen</name> &amp;&amp; !<name>dict</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
				<argument><expr>"not all arguments converted during string formatting"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<goto>goto <name>error</name>;</goto>
	}</block></then></if>
	<if>if <condition>(<expr><name>args_owned</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>
	<expr_stmt><expr><call><name>_PyString_Resize</name><argument_list>(<argument><expr>&amp;<name>result</name></expr></argument>, <argument><expr><name>reslen</name> - <name>rescnt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>result</name></expr>;</return>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>Py_USING_UNICODE</name></cpp:ifdef>
 <label><name>unicode</name>:</label>
	<if>if <condition>(<expr><name>args_owned</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>args_owned</name> = 0</expr>;</expr_stmt>
	}</block></then></if>
	<comment type="block">/* Fiddle args right (remove the first argidx arguments) */</comment>
	<if>if <condition>(<expr><call><name>PyTuple_Check</name><argument_list>(<argument><expr><name>orig_args</name></expr></argument>)</argument_list></call> &amp;&amp; <name>argidx</name> &gt; 0</expr>)</condition><then> <block>{
		<decl_stmt><decl><type><name>PyObject</name> *</type><name>v</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>n</name> <init>= <expr><call><name>PyTuple_GET_SIZE</name><argument_list>(<argument><expr><name>orig_args</name></expr></argument>)</argument_list></call> - <name>argidx</name></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name>v</name> = <call><name>PyTuple_New</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>v</name> == <name>NULL</name></expr>)</condition><then>
			<goto>goto <name>error</name>;</goto></then></if>
		<while>while <condition>(<expr>--<name>n</name> &gt;= 0</expr>)</condition> <block>{
			<decl_stmt><decl><type><name>PyObject</name> *</type><name>w</name> <init>= <expr><call><name>PyTuple_GET_ITEM</name><argument_list>(<argument><expr><name>orig_args</name></expr></argument>, <argument><expr><name>n</name> + <name>argidx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>PyTuple_SET_ITEM</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></while>
		<expr_stmt><expr><name>args</name> = <name>v</name></expr>;</expr_stmt>
	}</block></then> <else>else <block>{
		<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>orig_args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>args</name> = <name>orig_args</name></expr>;</expr_stmt>
	}</block></else></if>
	<expr_stmt><expr><name>args_owned</name> = 1</expr>;</expr_stmt>
	<comment type="block">/* Take what we have of the result and let the Unicode formatting
	   function format the rest of the input. */</comment>
	<expr_stmt><expr><name>rescnt</name> = <name>res</name> - <call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><call><name>_PyString_Resize</name><argument_list>(<argument><expr>&amp;<name>result</name></expr></argument>, <argument><expr><name>rescnt</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<goto>goto <name>error</name>;</goto></then></if>
	<expr_stmt><expr><name>fmtcnt</name> = <call><name>PyString_GET_SIZE</name><argument_list>(<argument><expr><name>format</name></expr></argument>)</argument_list></call> - \
		 (<name>fmt</name> - <call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>format</name></expr></argument>)</argument_list></call>)</expr>;</expr_stmt>
	<expr_stmt><expr><name>format</name> = <call><name>PyUnicode_Decode</name><argument_list>(<argument><expr><name>fmt</name></expr></argument>, <argument><expr><name>fmtcnt</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>format</name> == <name>NULL</name></expr>)</condition><then>
		<goto>goto <name>error</name>;</goto></then></if>
	<expr_stmt><expr><name>v</name> = <call><name>PyUnicode_Format</name><argument_list>(<argument><expr><name>format</name></expr></argument>, <argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>format</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>v</name> == <name>NULL</name></expr>)</condition><then>
		<goto>goto <name>error</name>;</goto></then></if>
	<comment type="block">/* Paste what we have (result) to what the Unicode formatting
	   function returned (v) and return the result (or error) */</comment>
	<expr_stmt><expr><name>w</name> = <call><name>PyUnicode_Concat</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>w</name></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* Py_USING_UNICODE */</comment>

 <label><name>error</name>:</label>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>args_owned</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>
	<return>return <expr><name>NULL</name></expr>;</return>
}</block></function>

<function><type><name>void</name></type>
<name>PyString_InternInPlace</name><parameter_list>(<param><decl><type><name>PyObject</name> **</type><name>p</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>register</name> <name>PyStringObject</name> *</type><name>s</name> <init>= <expr><call>(<name>PyStringObject</name> *)<argument_list>(<argument><expr>*<name>p</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>t</name></decl>;</decl_stmt>
	<if>if <condition>(<expr><name>s</name> == <name>NULL</name> || !<call><name>PyString_Check</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<expr_stmt><expr><call><name>Py_FatalError</name><argument_list>(<argument><expr>"PyString_InternInPlace: strings only please!"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
	<comment type="block">/* If it's a string subclass, we don't really know what putting
	   it in the interned dict might do. */</comment>
	<if>if <condition>(<expr>!<call><name>PyString_CheckExact</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return;</return></then></if>
	<if>if <condition>(<expr><call><name>PyString_CHECK_INTERNED</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return;</return></then></if>
	<if>if <condition>(<expr><name>interned</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>interned</name> = <call><name>PyDict_New</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>interned</name> == <name>NULL</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>PyErr_Clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt> <comment type="block">/* Don't leave an exception */</comment>
			<return>return;</return>
		}</block></then></if>
	}</block></then></if>
	<expr_stmt><expr><name>t</name> = <call><name>PyDict_GetItem</name><argument_list>(<argument><expr><name>interned</name></expr></argument>, <argument><expr>(<name>PyObject</name> *)<name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>t</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr>*<name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr>*<name>p</name> = <name>t</name></expr>;</expr_stmt>
		<return>return;</return>
	}</block></then></if>

	<if>if <condition>(<expr><call><name>PyDict_SetItem</name><argument_list>(<argument><expr><name>interned</name></expr></argument>, <argument><expr>(<name>PyObject</name> *)<name>s</name></expr></argument>, <argument><expr>(<name>PyObject</name> *)<name>s</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_Clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	}</block></then></if>
	<comment type="block">/* The two references in interned are not counted by refcnt.
	   The string deallocator will take care of this */</comment>
	<expr_stmt><expr><call><name>Py_REFCNT</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call> -= 2</expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PyString_CHECK_INTERNED</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call> = <name>SSTATE_INTERNED_MORTAL</name></expr>;</expr_stmt>
}</block></function>

<function><type><name>void</name></type>
<name>PyString_InternImmortal</name><parameter_list>(<param><decl><type><name>PyObject</name> **</type><name>p</name></decl></param>)</parameter_list>
<block>{
	<expr_stmt><expr><call><name>PyString_InternInPlace</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><call><name>PyString_CHECK_INTERNED</name><argument_list>(<argument><expr>*<name>p</name></expr></argument>)</argument_list></call> != <name>SSTATE_INTERNED_IMMORTAL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyString_CHECK_INTERNED</name><argument_list>(<argument><expr>*<name>p</name></expr></argument>)</argument_list></call> = <name>SSTATE_INTERNED_IMMORTAL</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr>*<name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>
}</block></function>


<function><type><name>PyObject</name> *</type>
<name>PyString_InternFromString</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>cp</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>s</name> <init>= <expr><call><name>PyString_FromString</name><argument_list>(<argument><expr><name>cp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if>if <condition>(<expr><name>s</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<expr_stmt><expr><call><name>PyString_InternInPlace</name><argument_list>(<argument><expr>&amp;<name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>s</name></expr>;</return>
}</block></function>

<function><type><name>void</name></type>
<name>PyString_Fini</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
	<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>UCHAR_MAX</name> + 1</expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
		<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name><name>characters</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>characters</name><index>[<expr><name>i</name></expr>]</index></name> = <name>NULL</name></expr>;</expr_stmt>
	}</block></for>
	<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>nullstring</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>nullstring</name> = <name>NULL</name></expr>;</expr_stmt>
}</block></function>

<function><type><name>void</name></type> <name>_Py_ReleaseInternedStrings</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>keys</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyStringObject</name> *</type><name>s</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>n</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>immortal_size</name> <init>= <expr>0</expr></init>, <name>mortal_size</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>

	<if>if <condition>(<expr><name>interned</name> == <name>NULL</name> || !<call><name>PyDict_Check</name><argument_list>(<argument><expr><name>interned</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return;</return></then></if>
	<expr_stmt><expr><name>keys</name> = <call><name>PyDict_Keys</name><argument_list>(<argument><expr><name>interned</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>keys</name> == <name>NULL</name> || !<call><name>PyList_Check</name><argument_list>(<argument><expr><name>keys</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_Clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	}</block></then></if>

	<comment type="block">/* Since _Py_ReleaseInternedStrings() is intended to help a leak
	   detector, interned strings are not forcibly deallocated; rather, we
	   give them their stolen references back, and then clear and DECREF
	   the interned dict. */</comment>

	<expr_stmt><expr><name>n</name> = <call><name>PyList_GET_SIZE</name><argument_list>(<argument><expr><name>keys</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr>"releasing %" <name>PY_FORMAT_SIZE_T</name> "d interned strings\n"</expr></argument>,
		<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>n</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
		<expr_stmt><expr><name>s</name> = (<name>PyStringObject</name> *) <call><name>PyList_GET_ITEM</name><argument_list>(<argument><expr><name>keys</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<switch>switch <condition>(<expr><name><name>s</name>-&gt;<name>ob_sstate</name></name></expr>)</condition> <block>{
		<case>case <expr><name>SSTATE_NOT_INTERNED</name></expr>:
			<comment type="block">/* XXX Shouldn't happen */</comment>
			<break>break;</break>
		</case><case>case <expr><name>SSTATE_INTERNED_IMMORTAL</name></expr>:
			<expr_stmt><expr><call><name>Py_REFCNT</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call> += 1</expr>;</expr_stmt>
			<expr_stmt><expr><name>immortal_size</name> += <call><name>Py_SIZE</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		</case><case>case <expr><name>SSTATE_INTERNED_MORTAL</name></expr>:
			<expr_stmt><expr><call><name>Py_REFCNT</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call> += 2</expr>;</expr_stmt>
			<expr_stmt><expr><name>mortal_size</name> += <call><name>Py_SIZE</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		</case><default>default:
			<expr_stmt><expr><call><name>Py_FatalError</name><argument_list>(<argument><expr>"Inconsistent interned string state."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</default>}</block></switch>
		<expr_stmt><expr><name><name>s</name>-&gt;<name>ob_sstate</name></name> = <name>SSTATE_NOT_INTERNED</name></expr>;</expr_stmt>
	}</block></for>
	<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr>"total size of all interned strings: "
			"%" <name>PY_FORMAT_SIZE_T</name> "d/%" <name>PY_FORMAT_SIZE_T</name> "d "
			"mortal/immortal\n"</expr></argument>, <argument><expr><name>mortal_size</name></expr></argument>, <argument><expr><name>immortal_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>keys</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PyDict_Clear</name><argument_list>(<argument><expr><name>interned</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>interned</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>interned</name> = <name>NULL</name></expr>;</expr_stmt>
}</block></function>
</unit>
