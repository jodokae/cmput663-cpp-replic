<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C" filename="projects/cpython-2.6.1/source/Objects/stringlib/unicodedefs.h"><cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>STRINGLIB_UNICODEDEFS_H</name></cpp:ifndef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>STRINGLIB_UNICODEDEFS_H</name></cpp:macro></cpp:define>

<comment type="block">/* this is sort of a hack.  there's at least one place (formatting
   floats) where some stringlib code takes a different path if it's
   compiled as unicode. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>STRINGLIB_IS_UNICODE</name></cpp:macro>     <cpp:value>1</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>STRINGLIB_OBJECT</name></cpp:macro>         <cpp:value>PyUnicodeObject</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>STRINGLIB_CHAR</name></cpp:macro>           <cpp:value>Py_UNICODE</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>STRINGLIB_TYPE_NAME</name></cpp:macro>      <cpp:value>"unicode"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>STRINGLIB_PARSE_CODE</name></cpp:macro>     <cpp:value>"U"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>STRINGLIB_EMPTY</name></cpp:macro>          <cpp:value>unicode_empty</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>STRINGLIB_ISDECIMAL</name></cpp:macro>      <cpp:value>Py_UNICODE_ISDECIMAL</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>STRINGLIB_TODECIMAL</name></cpp:macro>      <cpp:value>Py_UNICODE_TODECIMAL</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>STRINGLIB_TOUPPER</name></cpp:macro>        <cpp:value>Py_UNICODE_TOUPPER</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>STRINGLIB_TOLOWER</name></cpp:macro>        <cpp:value>Py_UNICODE_TOLOWER</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>STRINGLIB_FILL</name></cpp:macro>           <cpp:value>Py_UNICODE_FILL</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>STRINGLIB_STR</name></cpp:macro>            <cpp:value>PyUnicode_AS_UNICODE</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>STRINGLIB_LEN</name></cpp:macro>            <cpp:value>PyUnicode_GET_SIZE</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>STRINGLIB_NEW</name></cpp:macro>            <cpp:value>PyUnicode_FromUnicode</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>STRINGLIB_RESIZE</name></cpp:macro>         <cpp:value>PyUnicode_Resize</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>STRINGLIB_CHECK</name></cpp:macro>          <cpp:value>PyUnicode_Check</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>STRINGLIB_GROUPING</name></cpp:macro>       <cpp:value>_PyUnicode_InsertThousandsGrouping</cpp:value></cpp:define>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PY_VERSION_HEX</name> &lt; 0x03000000</expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>STRINGLIB_TOSTR</name></cpp:macro>          <cpp:value>PyObject_Unicode</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>STRINGLIB_TOSTR</name></cpp:macro>          <cpp:value>PyObject_Str</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>STRINGLIB_WANT_CONTAINS_OBJ</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>

<comment type="block">/* STRINGLIB_CMP was defined as:

Py_LOCAL_INLINE(int)
STRINGLIB_CMP(const Py_UNICODE* str, const Py_UNICODE* other, Py_ssize_t len)
{
    if (str[0] != other[0])
        return 1;
    return memcmp((void*) str, (void*) other, len * sizeof(Py_UNICODE));
}

but unfortunately that gives a error if the function isn't used in a file that
includes this file.  So, reluctantly convert it to a macro instead. */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>STRINGLIB_CMP</name><parameter_list>(<param><type><name>str</name></type></param>, <param><type><name>other</name></type></param>, <param><type><name>len</name></type></param>)</parameter_list></cpp:macro> \
    <cpp:value>(((str)[0] != (other)[0]) ? \
     1 : \
     memcmp((void*) (str), (void*) (other), (len) * sizeof(Py_UNICODE)))</cpp:value></cpp:define>


<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* !STRINGLIB_UNICODEDEFS_H */</comment>
</unit>
