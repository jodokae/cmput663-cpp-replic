<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C" filename="projects/cpython-2.6.1/source/Objects/longobject.c">

<comment type="block">/* Long (arbitrary precision) integer object implementation */</comment>

<comment type="block">/* XXX The functional organization of this file is terrible */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"Python.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"longintrepr.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;ctype.h&gt;</cpp:file></cpp:include>

<comment type="block">/* For long multiplication, use the O(N**2) school algorithm unless
 * both operands contain more than KARATSUBA_CUTOFF digits (this
 * being an internal Python long digit, in base PyLong_BASE).
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>KARATSUBA_CUTOFF</name></cpp:macro> <cpp:value>70</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>KARATSUBA_SQUARE_CUTOFF</name></cpp:macro> <cpp:value>(2 * KARATSUBA_CUTOFF)</cpp:value></cpp:define>

<comment type="block">/* For exponentiation, use the binary left-to-right algorithm
 * unless the exponent contains more than FIVEARY_CUTOFF digits.
 * In that case, do 5 bits at a time.  The potential drawback is that
 * a table of 2**5 intermediate results is computed.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FIVEARY_CUTOFF</name></cpp:macro> <cpp:value>8</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ABS</name><parameter_list>(<param><type><name>x</name></type></param>)</parameter_list></cpp:macro> <cpp:value>((x) &lt; 0 ? -(x) : (x))</cpp:value></cpp:define>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>MIN</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>MAX</name></cpp:undef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAX</name><parameter_list>(<param><type><name>x</name></type></param>, <param><type><name>y</name></type></param>)</parameter_list></cpp:macro> <cpp:value>((x) &lt; (y) ? (y) : (x))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MIN</name><parameter_list>(<param><type><name>x</name></type></param>, <param><type><name>y</name></type></param>)</parameter_list></cpp:macro> <cpp:value>((x) &gt; (y) ? (y) : (x))</cpp:value></cpp:define>

<comment type="block">/* Forward */</comment>
<function_decl><type><specifier>static</specifier> <name>PyLongObject</name> *</type><name>long_normalize</name><parameter_list>(<param><decl><type><name>PyLongObject</name> *</type></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>PyLongObject</name> *</type><name>mul1</name><parameter_list>(<param><decl><type><name>PyLongObject</name> *</type></decl></param>, <param><decl><type><name>wdigit</name></type></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>PyLongObject</name> *</type><name>muladd1</name><parameter_list>(<param><decl><type><name>PyLongObject</name> *</type></decl></param>, <param><decl><type><name>wdigit</name></type></decl></param>, <param><decl><type><name>wdigit</name></type></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>PyLongObject</name> *</type><name>divrem1</name><parameter_list>(<param><decl><type><name>PyLongObject</name> *</type></decl></param>, <param><decl><type><name>digit</name></type></decl></param>, <param><decl><type><name>digit</name> *</type></decl></param>)</parameter_list>;</function_decl>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SIGCHECK</name><parameter_list>(<param><type><name>PyTryBlock</name></type></param>)</parameter_list></cpp:macro> \
	<cpp:value>if (--_Py_Ticker &lt; 0) { \
		_Py_Ticker = _Py_CheckInterval; \
		if (PyErr_CheckSignals()) PyTryBlock \
	}</cpp:value></cpp:define>

<comment type="block">/* Normalize (remove leading zeros from) a long int object.
   Doesn't attempt to free the storage--in most cases, due to the nature
   of the algorithms used, this could save at most be one word anyway. */</comment>

<function><type><specifier>static</specifier> <name>PyLongObject</name> *</type>
<name>long_normalize</name><parameter_list>(<param><decl><type><name>register</name> <name>PyLongObject</name> *</type><name>v</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>j</name> <init>= <expr><call><name>ABS</name><argument_list>(<argument><expr><call><name>Py_SIZE</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>i</name> <init>= <expr><name>j</name></expr></init></decl>;</decl_stmt>

	<while>while <condition>(<expr><name>i</name> &gt; 0 &amp;&amp; <name><name>v</name>-&gt;<name>ob_digit</name><index>[<expr><name>i</name>-1</expr>]</index></name> == 0</expr>)</condition>
		<expr_stmt><expr>--<name>i</name></expr>;</expr_stmt></while>
	<if>if <condition>(<expr><name>i</name> != <name>j</name></expr>)</condition><then>
		<expr_stmt><expr><call><name>Py_SIZE</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call> = (<call><name>Py_SIZE</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call> &lt; 0) ? -(<name>i</name>) : <name>i</name></expr>;</expr_stmt></then></if>
	<return>return <expr><name>v</name></expr>;</return>
}</block></function>

<comment type="block">/* Allocate a new long int object with size digits.
   Return NULL and set exception if we run out of memory. */</comment>

<function><type><name>PyLongObject</name> *</type>
<name>_PyLong_New</name><parameter_list>(<param><decl><type><name>Py_ssize_t</name></type> <name>size</name></decl></param>)</parameter_list>
<block>{
	<if>if <condition>(<expr><name>size</name> &gt; <name>PY_SSIZE_T_MAX</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_NoMemory</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>
	<comment type="block">/* coverity[ampersand_in_size] */</comment>
	<comment type="block">/* XXX(nnorwitz): This can overflow --
           PyObject_NEW_VAR / _PyObject_VAR_SIZE need to detect overflow */</comment>
	<return>return <expr><call><name>PyObject_NEW_VAR</name><argument_list>(<argument><expr><name>PyLongObject</name></expr></argument>, <argument><expr>&amp;<name>PyLong_Type</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>PyObject</name> *</type>
<name>_PyLong_Copy</name><parameter_list>(<param><decl><type><name>PyLongObject</name> *</type><name>src</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyLongObject</name> *</type><name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>src</name> != <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i</name> = <name><name>src</name>-&gt;<name>ob_size</name></name></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>i</name> &lt; 0</expr>)</condition><then>
		<expr_stmt><expr><name>i</name> = -(<name>i</name>)</expr>;</expr_stmt></then></if>
	<expr_stmt><expr><name>result</name> = <call><name>_PyLong_New</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>result</name> != <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name><name>result</name>-&gt;<name>ob_size</name></name> = <name><name>src</name>-&gt;<name>ob_size</name></name></expr>;</expr_stmt>
		<while>while <condition>(<expr>--<name>i</name> &gt;= 0</expr>)</condition>
			<expr_stmt><expr><name><name>result</name>-&gt;<name>ob_digit</name><index>[<expr><name>i</name></expr>]</index></name> = <name><name>src</name>-&gt;<name>ob_digit</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt></while>
	}</block></then></if>
	<return>return <expr>(<name>PyObject</name> *)<name>result</name></expr>;</return>
}</block></function>

<comment type="block">/* Create a new long int object from a C long int */</comment>

<function><type><name>PyObject</name> *</type>
<name>PyLong_FromLong</name><parameter_list>(<param><decl><type><name>long</name></type> <name>ival</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyLongObject</name> *</type><name>v</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>abs_ival</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>t</name></decl>;</decl_stmt>  <comment type="block">/* unsigned so &gt;&gt; doesn't propagate sign bit */</comment>
	<decl_stmt><decl><type><name>int</name></type> <name>ndigits</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>negative</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>

	<if>if <condition>(<expr><name>ival</name> &lt; 0</expr>)</condition><then> <block>{
		<comment type="block">/* if LONG_MIN == -LONG_MAX-1 (true on most platforms) then
		   ANSI C says that the result of -ival is undefined when ival
		   == LONG_MIN.  Hence the following workaround. */</comment>
		<expr_stmt><expr><name>abs_ival</name> = <call>(<name>unsigned</name> <name>long</name>)<argument_list>(<argument><expr>-1-<name>ival</name></expr></argument>)</argument_list></call> + 1</expr>;</expr_stmt>
		<expr_stmt><expr><name>negative</name> = 1</expr>;</expr_stmt>
	}</block></then>
	<else>else <block>{
		<expr_stmt><expr><name>abs_ival</name> = (<name>unsigned</name> <name>long</name>)<name>ival</name></expr>;</expr_stmt>
	}</block></else></if>

	<comment type="block">/* Count the number of Python digits.
	   We used to pick 5 ("big enough for anything"), but that's a
	   waste of time and space given that 5*15 = 75 bits are rarely
	   needed. */</comment>
	<expr_stmt><expr><name>t</name> = <name>abs_ival</name></expr>;</expr_stmt>
	<while>while <condition>(<expr><name>t</name></expr>)</condition> <block>{
		<expr_stmt><expr>++<name>ndigits</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>t</name> &gt;&gt;= <name>PyLong_SHIFT</name></expr>;</expr_stmt>
	}</block></while>
	<expr_stmt><expr><name>v</name> = <call><name>_PyLong_New</name><argument_list>(<argument><expr><name>ndigits</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>v</name> != <name>NULL</name></expr>)</condition><then> <block>{
		<decl_stmt><decl><type><name>digit</name> *</type><name>p</name> <init>= <expr><name><name>v</name>-&gt;<name>ob_digit</name></name></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name><name>v</name>-&gt;<name>ob_size</name></name> = <name>negative</name> ? -<name>ndigits</name> : <name>ndigits</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>t</name> = <name>abs_ival</name></expr>;</expr_stmt>
		<while>while <condition>(<expr><name>t</name></expr>)</condition> <block>{
			<expr_stmt><expr>*<name>p</name>++ = <call>(<name>digit</name>)<argument_list>(<argument><expr><name>t</name> &amp; <name>PyLong_MASK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>t</name> &gt;&gt;= <name>PyLong_SHIFT</name></expr>;</expr_stmt>
		}</block></while>
	}</block></then></if>
	<return>return <expr>(<name>PyObject</name> *)<name>v</name></expr>;</return>
}</block></function>

<comment type="block">/* Create a new long int object from a C unsigned long int */</comment>

<function><type><name>PyObject</name> *</type>
<name>PyLong_FromUnsignedLong</name><parameter_list>(<param><decl><type><name>unsigned</name> <name>long</name></type> <name>ival</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyLongObject</name> *</type><name>v</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>t</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>ndigits</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>

	<comment type="block">/* Count the number of Python digits. */</comment>
	<expr_stmt><expr><name>t</name> = (<name>unsigned</name> <name>long</name>)<name>ival</name></expr>;</expr_stmt>
	<while>while <condition>(<expr><name>t</name></expr>)</condition> <block>{
		<expr_stmt><expr>++<name>ndigits</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>t</name> &gt;&gt;= <name>PyLong_SHIFT</name></expr>;</expr_stmt>
	}</block></while>
	<expr_stmt><expr><name>v</name> = <call><name>_PyLong_New</name><argument_list>(<argument><expr><name>ndigits</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>v</name> != <name>NULL</name></expr>)</condition><then> <block>{
		<decl_stmt><decl><type><name>digit</name> *</type><name>p</name> <init>= <expr><name><name>v</name>-&gt;<name>ob_digit</name></name></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>Py_SIZE</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call> = <name>ndigits</name></expr>;</expr_stmt>
		<while>while <condition>(<expr><name>ival</name></expr>)</condition> <block>{
			<expr_stmt><expr>*<name>p</name>++ = <call>(<name>digit</name>)<argument_list>(<argument><expr><name>ival</name> &amp; <name>PyLong_MASK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>ival</name> &gt;&gt;= <name>PyLong_SHIFT</name></expr>;</expr_stmt>
		}</block></while>
	}</block></then></if>
	<return>return <expr>(<name>PyObject</name> *)<name>v</name></expr>;</return>
}</block></function>

<comment type="block">/* Create a new long int object from a C double */</comment>

<function><type><name>PyObject</name> *</type>
<name>PyLong_FromDouble</name><parameter_list>(<param><decl><type><name>double</name></type> <name>dval</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyLongObject</name> *</type><name>v</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type> <name>frac</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>ndig</name></decl>, <decl><type ref="prev"/><name>expo</name></decl>, <decl><type ref="prev"/><name>neg</name></decl>;</decl_stmt>
	<expr_stmt><expr><name>neg</name> = 0</expr>;</expr_stmt>
	<if>if <condition>(<expr><call><name>Py_IS_INFINITY</name><argument_list>(<argument><expr><name>dval</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_OverflowError</name></expr></argument>,
			<argument><expr>"cannot convert float infinity to integer"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>
	<if>if <condition>(<expr><call><name>Py_IS_NAN</name><argument_list>(<argument><expr><name>dval</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>,
			<argument><expr>"cannot convert float NaN to integer"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>
	<if>if <condition>(<expr><name>dval</name> &lt; 0.0</expr>)</condition><then> <block>{
		<expr_stmt><expr><name>neg</name> = 1</expr>;</expr_stmt>
		<expr_stmt><expr><name>dval</name> = -<name>dval</name></expr>;</expr_stmt>
	}</block></then></if>
	<expr_stmt><expr><name>frac</name> = <call><name>frexp</name><argument_list>(<argument><expr><name>dval</name></expr></argument>, <argument><expr>&amp;<name>expo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* dval = frac*2**expo; 0.0 &lt;= frac &lt; 1.0 */</comment>
	<if>if <condition>(<expr><name>expo</name> &lt;= 0</expr>)</condition><then>
		<return>return <expr><call><name>PyLong_FromLong</name><argument_list>(<argument><expr>0L</expr></argument>)</argument_list></call></expr>;</return></then></if>
	<expr_stmt><expr><name>ndig</name> = (<name>expo</name>-1) / <name>PyLong_SHIFT</name> + 1</expr>;</expr_stmt> <comment type="block">/* Number of 'digits' in result */</comment>
	<expr_stmt><expr><name>v</name> = <call><name>_PyLong_New</name><argument_list>(<argument><expr><name>ndig</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>v</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<expr_stmt><expr><name>frac</name> = <call><name>ldexp</name><argument_list>(<argument><expr><name>frac</name></expr></argument>, <argument><expr>(<name>expo</name>-1) % <name>PyLong_SHIFT</name> + 1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for (<init><expr><name>i</name> = <name>ndig</name></expr>;</init> <condition><expr>--<name>i</name> &gt;= 0</expr>;</condition> <incr/>) <block>{
		<decl_stmt><decl><type><name>long</name></type> <name>bits</name> <init>= <expr>(<name>long</name>)<name>frac</name></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name><name>v</name>-&gt;<name>ob_digit</name><index>[<expr><name>i</name></expr>]</index></name> = (<name>digit</name>) <name>bits</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>frac</name> = <name>frac</name> - (<name>double</name>)<name>bits</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>frac</name> = <call><name>ldexp</name><argument_list>(<argument><expr><name>frac</name></expr></argument>, <argument><expr><name>PyLong_SHIFT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></for>
	<if>if <condition>(<expr><name>neg</name></expr>)</condition><then>
		<expr_stmt><expr><call><name>Py_SIZE</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call> = -(<call><name>Py_SIZE</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call>)</expr>;</expr_stmt></then></if>
	<return>return <expr>(<name>PyObject</name> *)<name>v</name></expr>;</return>
}</block></function>

<comment type="block">/* Checking for overflow in PyLong_AsLong is a PITA since C doesn't define
 * anything about what happens when a signed integer operation overflows,
 * and some compilers think they're doing you a favor by being "clever"
 * then.  The bit pattern for the largest postive signed long is
 * (unsigned long)LONG_MAX, and for the smallest negative signed long
 * it is abs(LONG_MIN), which we could write -(unsigned long)LONG_MIN.
 * However, some other compilers warn about applying unary minus to an
 * unsigned operand.  Hence the weird "0-".
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PY_ABS_LONG_MIN</name></cpp:macro>		<cpp:value>(0-(unsigned long)LONG_MIN)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PY_ABS_SSIZE_T_MIN</name></cpp:macro>	<cpp:value>(0-(size_t)PY_SSIZE_T_MIN)</cpp:value></cpp:define>

<comment type="block">/* Get a C long int from a long int object.
   Returns -1 and sets an error condition if overflow occurs. */</comment>

<function><type><name>long</name></type>
<name>PyLong_AsLong</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>vv</name></decl></param>)</parameter_list>
<block>{
	<comment type="block">/* This version by Tim Peters */</comment>
	<decl_stmt><decl><type><name>register</name> <name>PyLongObject</name> *</type><name>v</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>x</name></decl>, <decl><type ref="prev"/><name>prev</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>sign</name></decl>;</decl_stmt>

	<if>if <condition>(<expr><name>vv</name> == <name>NULL</name> || !<call><name>PyLong_Check</name><argument_list>(<argument><expr><name>vv</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<if>if <condition>(<expr><name>vv</name> != <name>NULL</name> &amp;&amp; <call><name>PyInt_Check</name><argument_list>(<argument><expr><name>vv</name></expr></argument>)</argument_list></call></expr>)</condition><then>
			<return>return <expr><call><name>PyInt_AsLong</name><argument_list>(<argument><expr><name>vv</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
		<expr_stmt><expr><call><name>PyErr_BadInternalCall</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>-1</expr>;</return>
	}</block></then></if>
	<expr_stmt><expr><name>v</name> = (<name>PyLongObject</name> *)<name>vv</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>i</name> = <name><name>v</name>-&gt;<name>ob_size</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>sign</name> = 1</expr>;</expr_stmt>
	<expr_stmt><expr><name>x</name> = 0</expr>;</expr_stmt>
	<if>if <condition>(<expr><name>i</name> &lt; 0</expr>)</condition><then> <block>{
		<expr_stmt><expr><name>sign</name> = -1</expr>;</expr_stmt>
		<expr_stmt><expr><name>i</name> = -(<name>i</name>)</expr>;</expr_stmt>
	}</block></then></if>
	<while>while <condition>(<expr>--<name>i</name> &gt;= 0</expr>)</condition> <block>{
		<expr_stmt><expr><name>prev</name> = <name>x</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>x</name> = (<name>x</name> &lt;&lt; <name>PyLong_SHIFT</name>) + <name><name>v</name>-&gt;<name>ob_digit</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
		<if>if <condition>(<expr>(<name>x</name> &gt;&gt; <name>PyLong_SHIFT</name>) != <name>prev</name></expr>)</condition><then>
			<goto>goto <name>overflow</name>;</goto></then></if>
	}</block></while>
	<comment type="block">/* Haven't lost any bits, but casting to long requires extra care
	 * (see comment above).
         */</comment>
	<if>if <condition>(<expr><name>x</name> &lt;= (<name>unsigned</name> <name>long</name>)<name>LONG_MAX</name></expr>)</condition><then> <block>{
		<return>return <expr>(<name>long</name>)<name>x</name> * <name>sign</name></expr>;</return>
	}</block></then>
	<else>else <if>if <condition>(<expr><name>sign</name> &lt; 0 &amp;&amp; <name>x</name> == <name>PY_ABS_LONG_MIN</name></expr>)</condition><then> <block>{
		<return>return <expr><name>LONG_MIN</name></expr>;</return>
	}</block></then></if></else></if>
	<comment type="block">/* else overflow */</comment>

 <label><name>overflow</name>:</label>
	<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_OverflowError</name></expr></argument>,
			<argument><expr>"long int too large to convert to int"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr>-1</expr>;</return>
}</block></function>

<comment type="block">/* Get a Py_ssize_t from a long int object.
   Returns -1 and sets an error condition if overflow occurs. */</comment>

<function><type><name>Py_ssize_t</name></type>
<name>PyLong_AsSsize_t</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>vv</name></decl></param>)</parameter_list> <block>{
	<decl_stmt><decl><type><name>register</name> <name>PyLongObject</name> *</type><name>v</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>size_t</name></type> <name>x</name></decl>, <decl><type ref="prev"/><name>prev</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>sign</name></decl>;</decl_stmt>

	<if>if <condition>(<expr><name>vv</name> == <name>NULL</name> || !<call><name>PyLong_Check</name><argument_list>(<argument><expr><name>vv</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_BadInternalCall</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>-1</expr>;</return>
	}</block></then></if>
	<expr_stmt><expr><name>v</name> = (<name>PyLongObject</name> *)<name>vv</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>i</name> = <name><name>v</name>-&gt;<name>ob_size</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>sign</name> = 1</expr>;</expr_stmt>
	<expr_stmt><expr><name>x</name> = 0</expr>;</expr_stmt>
	<if>if <condition>(<expr><name>i</name> &lt; 0</expr>)</condition><then> <block>{
		<expr_stmt><expr><name>sign</name> = -1</expr>;</expr_stmt>
		<expr_stmt><expr><name>i</name> = -(<name>i</name>)</expr>;</expr_stmt>
	}</block></then></if>
	<while>while <condition>(<expr>--<name>i</name> &gt;= 0</expr>)</condition> <block>{
		<expr_stmt><expr><name>prev</name> = <name>x</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>x</name> = (<name>x</name> &lt;&lt; <name>PyLong_SHIFT</name>) + <name><name>v</name>-&gt;<name>ob_digit</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
		<if>if <condition>(<expr>(<name>x</name> &gt;&gt; <name>PyLong_SHIFT</name>) != <name>prev</name></expr>)</condition><then>
			<goto>goto <name>overflow</name>;</goto></then></if>
	}</block></while>
	<comment type="block">/* Haven't lost any bits, but casting to a signed type requires
	 * extra care (see comment above).
	 */</comment>
	<if>if <condition>(<expr><name>x</name> &lt;= (<name>size_t</name>)<name>PY_SSIZE_T_MAX</name></expr>)</condition><then> <block>{
		<return>return <expr>(<name>Py_ssize_t</name>)<name>x</name> * <name>sign</name></expr>;</return>
	}</block></then>
	<else>else <if>if <condition>(<expr><name>sign</name> &lt; 0 &amp;&amp; <name>x</name> == <name>PY_ABS_SSIZE_T_MIN</name></expr>)</condition><then> <block>{
		<return>return <expr><name>PY_SSIZE_T_MIN</name></expr>;</return>
	}</block></then></if></else></if>
	<comment type="block">/* else overflow */</comment>

 <label><name>overflow</name>:</label>
	<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_OverflowError</name></expr></argument>,
			<argument><expr>"long int too large to convert to int"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr>-1</expr>;</return>
}</block></function>

<comment type="block">/* Get a C unsigned long int from a long int object.
   Returns -1 and sets an error condition if overflow occurs. */</comment>

<function><type><name>unsigned</name> <name>long</name></type>
<name>PyLong_AsUnsignedLong</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>vv</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>register</name> <name>PyLongObject</name> *</type><name>v</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>x</name></decl>, <decl><type ref="prev"/><name>prev</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>i</name></decl>;</decl_stmt>

	<if>if <condition>(<expr><name>vv</name> == <name>NULL</name> || !<call><name>PyLong_Check</name><argument_list>(<argument><expr><name>vv</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<if>if <condition>(<expr><name>vv</name> != <name>NULL</name> &amp;&amp; <call><name>PyInt_Check</name><argument_list>(<argument><expr><name>vv</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
			<decl_stmt><decl><type><name>long</name></type> <name>val</name> <init>= <expr><call><name>PyInt_AsLong</name><argument_list>(<argument><expr><name>vv</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<if>if <condition>(<expr><name>val</name> &lt; 0</expr>)</condition><then> <block>{
				<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_OverflowError</name></expr></argument>,
				<argument><expr>"can't convert negative value to unsigned long"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr>(<name>unsigned</name> <name>long</name>) -1</expr>;</return>
			}</block></then></if>
			<return>return <expr><name>val</name></expr>;</return>
		}</block></then></if>
		<expr_stmt><expr><call><name>PyErr_BadInternalCall</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>(<name>unsigned</name> <name>long</name>) -1</expr>;</return>
	}</block></then></if>
	<expr_stmt><expr><name>v</name> = (<name>PyLongObject</name> *)<name>vv</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>i</name> = <call><name>Py_SIZE</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>x</name> = 0</expr>;</expr_stmt>
	<if>if <condition>(<expr><name>i</name> &lt; 0</expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_OverflowError</name></expr></argument>,
			   <argument><expr>"can't convert negative value to unsigned long"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>(<name>unsigned</name> <name>long</name>) -1</expr>;</return>
	}</block></then></if>
	<while>while <condition>(<expr>--<name>i</name> &gt;= 0</expr>)</condition> <block>{
		<expr_stmt><expr><name>prev</name> = <name>x</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>x</name> = (<name>x</name> &lt;&lt; <name>PyLong_SHIFT</name>) + <name><name>v</name>-&gt;<name>ob_digit</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
		<if>if <condition>(<expr>(<name>x</name> &gt;&gt; <name>PyLong_SHIFT</name>) != <name>prev</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_OverflowError</name></expr></argument>,
				<argument><expr>"long int too large to convert"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr>(<name>unsigned</name> <name>long</name>) -1</expr>;</return>
		}</block></then></if>
	}</block></while>
	<return>return <expr><name>x</name></expr>;</return>
}</block></function>

<comment type="block">/* Get a C unsigned long int from a long int object, ignoring the high bits.
   Returns -1 and sets an error condition if an error occurs. */</comment>

<function><type><name>unsigned</name> <name>long</name></type>
<name>PyLong_AsUnsignedLongMask</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>vv</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>register</name> <name>PyLongObject</name> *</type><name>v</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>x</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>sign</name></decl>;</decl_stmt>

	<if>if <condition>(<expr><name>vv</name> == <name>NULL</name> || !<call><name>PyLong_Check</name><argument_list>(<argument><expr><name>vv</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<if>if <condition>(<expr><name>vv</name> != <name>NULL</name> &amp;&amp; <call><name>PyInt_Check</name><argument_list>(<argument><expr><name>vv</name></expr></argument>)</argument_list></call></expr>)</condition><then>
			<return>return <expr><call><name>PyInt_AsUnsignedLongMask</name><argument_list>(<argument><expr><name>vv</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
		<expr_stmt><expr><call><name>PyErr_BadInternalCall</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>(<name>unsigned</name> <name>long</name>) -1</expr>;</return>
	}</block></then></if>
	<expr_stmt><expr><name>v</name> = (<name>PyLongObject</name> *)<name>vv</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>i</name> = <name><name>v</name>-&gt;<name>ob_size</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>sign</name> = 1</expr>;</expr_stmt>
	<expr_stmt><expr><name>x</name> = 0</expr>;</expr_stmt>
	<if>if <condition>(<expr><name>i</name> &lt; 0</expr>)</condition><then> <block>{
		<expr_stmt><expr><name>sign</name> = -1</expr>;</expr_stmt>
		<expr_stmt><expr><name>i</name> = -<name>i</name></expr>;</expr_stmt>
	}</block></then></if>
	<while>while <condition>(<expr>--<name>i</name> &gt;= 0</expr>)</condition> <block>{
		<expr_stmt><expr><name>x</name> = (<name>x</name> &lt;&lt; <name>PyLong_SHIFT</name>) + <name><name>v</name>-&gt;<name>ob_digit</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
	}</block></while>
	<return>return <expr><name>x</name> * <name>sign</name></expr>;</return>
}</block></function>

<function><type><name>int</name></type>
<name>_PyLong_Sign</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>vv</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyLongObject</name> *</type><name>v</name> <init>= <expr>(<name>PyLongObject</name> *)<name>vv</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>v</name> != <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>PyLong_Check</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><call><name>Py_SIZE</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call> == 0 ? 0 : (<call><name>Py_SIZE</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call> &lt; 0 ? -1 : 1)</expr>;</return>
}</block></function>

<function><type><name>size_t</name></type>
<name>_PyLong_NumBits</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>vv</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyLongObject</name> *</type><name>v</name> <init>= <expr>(<name>PyLongObject</name> *)<name>vv</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>size_t</name></type> <name>result</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>ndigits</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>v</name> != <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>PyLong_Check</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>ndigits</name> = <call><name>ABS</name><argument_list>(<argument><expr><call><name>Py_SIZE</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>ndigits</name> == 0 || <name><name>v</name>-&gt;<name>ob_digit</name><index>[<expr><name>ndigits</name> - 1</expr>]</index></name> != 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>ndigits</name> &gt; 0</expr>)</condition><then> <block>{
		<decl_stmt><decl><type><name>digit</name></type> <name>msd</name> <init>= <expr><name><name>v</name>-&gt;<name>ob_digit</name><index>[<expr><name>ndigits</name> - 1</expr>]</index></name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>result</name> = (<name>ndigits</name> - 1) * <name>PyLong_SHIFT</name></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>result</name> / <name>PyLong_SHIFT</name> != <call>(<name>size_t</name>)<argument_list>(<argument><expr><name>ndigits</name> - 1</expr></argument>)</argument_list></call></expr>)</condition><then>
			<goto>goto <name>Overflow</name>;</goto></then></if>
		<do>do <block>{
			<expr_stmt><expr>++<name>result</name></expr>;</expr_stmt>
			<if>if <condition>(<expr><name>result</name> == 0</expr>)</condition><then>
				<goto>goto <name>Overflow</name>;</goto></then></if>
			<expr_stmt><expr><name>msd</name> &gt;&gt;= 1</expr>;</expr_stmt>
		}</block> while <condition>(<expr><name>msd</name></expr>)</condition>;</do>
	}</block></then></if>
	<return>return <expr><name>result</name></expr>;</return>

<label><name>Overflow</name>:</label>
	<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_OverflowError</name></expr></argument>, <argument><expr>"long has too many bits "
			"to express in a platform size_t"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr>(<name>size_t</name>)-1</expr>;</return>
}</block></function>

<function><type><name>PyObject</name> *</type>
<name>_PyLong_FromByteArray</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name>*</type> <name>bytes</name></decl></param>, <param><decl><type><name>size_t</name></type> <name>n</name></decl></param>,
		      <param><decl><type><name>int</name></type> <name>little_endian</name></decl></param>, <param><decl><type><name>int</name></type> <name>is_signed</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name>*</type> <name>pstartbyte</name></decl>;</decl_stmt><comment type="block">/* LSB of bytes */</comment>
	<decl_stmt><decl><type><name>int</name></type> <name>incr</name></decl>;</decl_stmt>			<comment type="block">/* direction to move pstartbyte */</comment>
	<decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name>*</type> <name>pendbyte</name></decl>;</decl_stmt>	<comment type="block">/* MSB of bytes */</comment>
	<decl_stmt><decl><type><name>size_t</name></type> <name>numsignificantbytes</name></decl>;</decl_stmt>	<comment type="block">/* number of bytes that matter */</comment>
	<decl_stmt><decl><type><name>size_t</name></type> <name>ndigits</name></decl>;</decl_stmt>			<comment type="block">/* number of Python long digits */</comment>
	<decl_stmt><decl><type><name>PyLongObject</name>*</type> <name>v</name></decl>;</decl_stmt>		<comment type="block">/* result */</comment>
	<decl_stmt><decl><type><name>int</name></type> <name>idigit</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>  		<comment type="block">/* next free index in v-&gt;ob_digit */</comment>

	<if>if <condition>(<expr><name>n</name> == 0</expr>)</condition><then>
		<return>return <expr><call><name>PyLong_FromLong</name><argument_list>(<argument><expr>0L</expr></argument>)</argument_list></call></expr>;</return></then></if>

	<if>if <condition>(<expr><name>little_endian</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>pstartbyte</name> = <name>bytes</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>pendbyte</name> = <name>bytes</name> + <name>n</name> - 1</expr>;</expr_stmt>
		<expr_stmt><expr><name>incr</name> = 1</expr>;</expr_stmt>
	}</block></then>
	<else>else <block>{
		<expr_stmt><expr><name>pstartbyte</name> = <name>bytes</name> + <name>n</name> - 1</expr>;</expr_stmt>
		<expr_stmt><expr><name>pendbyte</name> = <name>bytes</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>incr</name> = -1</expr>;</expr_stmt>
	}</block></else></if>

	<if>if <condition>(<expr><name>is_signed</name></expr>)</condition><then>
		<expr_stmt><expr><name>is_signed</name> = *<name>pendbyte</name> &gt;= 0x80</expr>;</expr_stmt></then></if>

	<comment type="block">/* Compute numsignificantbytes.  This consists of finding the most
	   significant byte.  Leading 0 bytes are insignficant if the number
	   is positive, and leading 0xff bytes if negative. */</comment>
	<block>{
		<decl_stmt><decl><type><name>size_t</name></type> <name>i</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name>*</type> <name>p</name> <init>= <expr><name>pendbyte</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>pincr</name> <init>= <expr>-<name>incr</name></expr></init></decl>;</decl_stmt>  <comment type="block">/* search MSB to LSB */</comment>
		<decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name></type> <name>insignficant</name> <init>= <expr><name>is_signed</name> ? 0xff : 0x00</expr></init></decl>;</decl_stmt>

		<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>n</name></expr>;</condition> <incr><expr>++<name>i</name></expr>, <expr><name>p</name> += <name>pincr</name></expr></incr>) <block>{
			<if>if <condition>(<expr>*<name>p</name> != <name>insignficant</name></expr>)</condition><then>
				<break>break;</break></then></if>
		}</block></for>
		<expr_stmt><expr><name>numsignificantbytes</name> = <name>n</name> - <name>i</name></expr>;</expr_stmt>
		<comment type="block">/* 2's-comp is a bit tricky here, e.g. 0xff00 == -0x0100, so
		   actually has 2 significant bytes.  OTOH, 0xff0001 ==
		   -0x00ffff, so we wouldn't *need* to bump it there; but we
		   do for 0xffff = -0x0001.  To be safe without bothering to
		   check every case, bump it regardless. */</comment>
		<if>if <condition>(<expr><name>is_signed</name> &amp;&amp; <name>numsignificantbytes</name> &lt; <name>n</name></expr>)</condition><then>
			<expr_stmt><expr>++<name>numsignificantbytes</name></expr>;</expr_stmt></then></if>
	}</block>

	<comment type="block">/* How many Python long digits do we need?  We have
	   8*numsignificantbytes bits, and each Python long digit has PyLong_SHIFT
	   bits, so it's the ceiling of the quotient. */</comment>
	<expr_stmt><expr><name>ndigits</name> = (<name>numsignificantbytes</name> * 8 + <name>PyLong_SHIFT</name> - 1) / <name>PyLong_SHIFT</name></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>ndigits</name> &gt; (<name>size_t</name>)<name>INT_MAX</name></expr>)</condition><then>
		<return>return <expr><call><name>PyErr_NoMemory</name><argument_list>()</argument_list></call></expr>;</return></then></if>
	<expr_stmt><expr><name>v</name> = <call><name>_PyLong_New</name><argument_list>(<argument><expr>(<name>int</name>)<name>ndigits</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>v</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>

	<comment type="block">/* Copy the bits over.  The tricky parts are computing 2's-comp on
	   the fly for signed numbers, and dealing with the mismatch between
	   8-bit bytes and (probably) 15-bit Python digits.*/</comment>
	<block>{
		<decl_stmt><decl><type><name>size_t</name></type> <name>i</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>twodigits</name></type> <name>carry</name> <init>= <expr>1</expr></init></decl>;</decl_stmt>		<comment type="block">/* for 2's-comp calculation */</comment>
		<decl_stmt><decl><type><name>twodigits</name></type> <name>accum</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>		<comment type="block">/* sliding register */</comment>
		<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>accumbits</name> <init>= <expr>0</expr></init></decl>;</decl_stmt> 	<comment type="block">/* number of bits in accum */</comment>
		<decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name>*</type> <name>p</name> <init>= <expr><name>pstartbyte</name></expr></init></decl>;</decl_stmt>

		<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>numsignificantbytes</name></expr>;</condition> <incr><expr>++<name>i</name></expr>, <expr><name>p</name> += <name>incr</name></expr></incr>) <block>{
			<decl_stmt><decl><type><name>twodigits</name></type> <name>thisbyte</name> <init>= <expr>*<name>p</name></expr></init></decl>;</decl_stmt>
			<comment type="block">/* Compute correction for 2's comp, if needed. */</comment>
			<if>if <condition>(<expr><name>is_signed</name></expr>)</condition><then> <block>{
				<expr_stmt><expr><name>thisbyte</name> = (0xff ^ <name>thisbyte</name>) + <name>carry</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>carry</name> = <name>thisbyte</name> &gt;&gt; 8</expr>;</expr_stmt>
				<expr_stmt><expr><name>thisbyte</name> &amp;= 0xff</expr>;</expr_stmt>
			}</block></then></if>
			<comment type="block">/* Because we're going LSB to MSB, thisbyte is
			   more significant than what's already in accum,
			   so needs to be prepended to accum. */</comment>
			<expr_stmt><expr><name>accum</name> |= <name>thisbyte</name> &lt;&lt; <name>accumbits</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>accumbits</name> += 8</expr>;</expr_stmt>
			<if>if <condition>(<expr><name>accumbits</name> &gt;= <name>PyLong_SHIFT</name></expr>)</condition><then> <block>{
				<comment type="block">/* There's enough to fill a Python digit. */</comment>
				<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>idigit</name> &lt; (<name>int</name>)<name>ndigits</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>v</name>-&gt;<name>ob_digit</name><index>[<expr><name>idigit</name></expr>]</index></name> = <call>(<name>digit</name>)<argument_list>(<argument><expr><name>accum</name> &amp; <name>PyLong_MASK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr>++<name>idigit</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>accum</name> &gt;&gt;= <name>PyLong_SHIFT</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>accumbits</name> -= <name>PyLong_SHIFT</name></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>accumbits</name> &lt; <name>PyLong_SHIFT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			}</block></then></if>
		}</block></for>
		<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>accumbits</name> &lt; <name>PyLong_SHIFT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>accumbits</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>idigit</name> &lt; (<name>int</name>)<name>ndigits</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>v</name>-&gt;<name>ob_digit</name><index>[<expr><name>idigit</name></expr>]</index></name> = (<name>digit</name>)<name>accum</name></expr>;</expr_stmt>
			<expr_stmt><expr>++<name>idigit</name></expr>;</expr_stmt>
		}</block></then></if>
	}</block>

	<expr_stmt><expr><call><name>Py_SIZE</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call> = <name>is_signed</name> ? -<name>idigit</name> : <name>idigit</name></expr>;</expr_stmt>
	<return>return <expr>(<name>PyObject</name> *)<call><name>long_normalize</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>int</name></type>
<name>_PyLong_AsByteArray</name><parameter_list>(<param><decl><type><name>PyLongObject</name>*</type> <name>v</name></decl></param>,
		    <param><decl><type><name>unsigned</name> <name>char</name>*</type> <name>bytes</name></decl></param>, <param><decl><type><name>size_t</name></type> <name>n</name></decl></param>,
		    <param><decl><type><name>int</name></type> <name>little_endian</name></decl></param>, <param><decl><type><name>int</name></type> <name>is_signed</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>			<comment type="block">/* index into v-&gt;ob_digit */</comment>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>ndigits</name></decl>;</decl_stmt>		<comment type="block">/* |v-&gt;ob_size| */</comment>
	<decl_stmt><decl><type><name>twodigits</name></type> <name>accum</name></decl>;</decl_stmt>	<comment type="block">/* sliding register */</comment>
	<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>accumbits</name></decl>;</decl_stmt> <comment type="block">/* # bits in accum */</comment>
	<decl_stmt><decl><type><name>int</name></type> <name>do_twos_comp</name></decl>;</decl_stmt>	<comment type="block">/* store 2's-comp?  is_signed and v &lt; 0 */</comment>
	<decl_stmt><decl><type><name>twodigits</name></type> <name>carry</name></decl>;</decl_stmt>	<comment type="block">/* for computing 2's-comp */</comment>
	<decl_stmt><decl><type><name>size_t</name></type> <name>j</name></decl>;</decl_stmt>		<comment type="block">/* # bytes filled */</comment>
	<decl_stmt><decl><type><name>unsigned</name> <name>char</name>*</type> <name>p</name></decl>;</decl_stmt>	<comment type="block">/* pointer to next byte in bytes */</comment>
	<decl_stmt><decl><type><name>int</name></type> <name>pincr</name></decl>;</decl_stmt>		<comment type="block">/* direction to move p */</comment>

	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>v</name> != <name>NULL</name> &amp;&amp; <call><name>PyLong_Check</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if>if <condition>(<expr><call><name>Py_SIZE</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then> <block>{
		<expr_stmt><expr><name>ndigits</name> = -(<call><name>Py_SIZE</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call>)</expr>;</expr_stmt>
		<if>if <condition>(<expr>!<name>is_signed</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
				<argument><expr>"can't convert negative long to unsigned"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr>-1</expr>;</return>
		}</block></then></if>
		<expr_stmt><expr><name>do_twos_comp</name> = 1</expr>;</expr_stmt>
	}</block></then>
	<else>else <block>{
		<expr_stmt><expr><name>ndigits</name> = <call><name>Py_SIZE</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>do_twos_comp</name> = 0</expr>;</expr_stmt>
	}</block></else></if>

	<if>if <condition>(<expr><name>little_endian</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>p</name> = <name>bytes</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>pincr</name> = 1</expr>;</expr_stmt>
	}</block></then>
	<else>else <block>{
		<expr_stmt><expr><name>p</name> = <name>bytes</name> + <name>n</name> - 1</expr>;</expr_stmt>
		<expr_stmt><expr><name>pincr</name> = -1</expr>;</expr_stmt>
	}</block></else></if>

	<comment type="block">/* Copy over all the Python digits.
	   It's crucial that every Python digit except for the MSD contribute
	   exactly PyLong_SHIFT bits to the total, so first assert that the long is
	   normalized. */</comment>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>ndigits</name> == 0 || <name><name>v</name>-&gt;<name>ob_digit</name><index>[<expr><name>ndigits</name> - 1</expr>]</index></name> != 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>j</name> = 0</expr>;</expr_stmt>
	<expr_stmt><expr><name>accum</name> = 0</expr>;</expr_stmt>
	<expr_stmt><expr><name>accumbits</name> = 0</expr>;</expr_stmt>
	<expr_stmt><expr><name>carry</name> = <name>do_twos_comp</name> ? 1 : 0</expr>;</expr_stmt>
	<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>ndigits</name></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>) <block>{
		<decl_stmt><decl><type><name>twodigits</name></type> <name>thisdigit</name> <init>= <expr><name><name>v</name>-&gt;<name>ob_digit</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<if>if <condition>(<expr><name>do_twos_comp</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><name>thisdigit</name> = (<name>thisdigit</name> ^ <name>PyLong_MASK</name>) + <name>carry</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>carry</name> = <name>thisdigit</name> &gt;&gt; <name>PyLong_SHIFT</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>thisdigit</name> &amp;= <name>PyLong_MASK</name></expr>;</expr_stmt>
		}</block></then></if>
		<comment type="block">/* Because we're going LSB to MSB, thisdigit is more
		   significant than what's already in accum, so needs to be
		   prepended to accum. */</comment>
		<expr_stmt><expr><name>accum</name> |= <name>thisdigit</name> &lt;&lt; <name>accumbits</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>accumbits</name> += <name>PyLong_SHIFT</name></expr>;</expr_stmt>

		<comment type="block">/* The most-significant digit may be (probably is) at least
		   partly empty. */</comment>
		<if>if <condition>(<expr><name>i</name> == <name>ndigits</name> - 1</expr>)</condition><then> <block>{
			<comment type="block">/* Count # of sign bits -- they needn't be stored,
			 * although for signed conversion we need later to
			 * make sure at least one sign bit gets stored.
			 * First shift conceptual sign bit to real sign bit.
			 */</comment>
			<decl_stmt><decl><type><name>stwodigits</name></type> <name>s</name> <init>= <expr><call>(<name>stwodigits</name>)<argument_list>(<argument><expr><name>thisdigit</name> &lt;&lt;
				(8*<sizeof>sizeof<argument_list>(<argument><expr><name>stwodigits</name></expr></argument>)</argument_list></sizeof> - <name>PyLong_SHIFT</name>)</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>nsignbits</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
			<while>while <condition>(<expr>(<name>s</name> &lt; 0) == <name>do_twos_comp</name> &amp;&amp; <name>nsignbits</name> &lt; <name>PyLong_SHIFT</name></expr>)</condition> <block>{
				<expr_stmt><expr>++<name>nsignbits</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>s</name> &lt;&lt;= 1</expr>;</expr_stmt>
			}</block></while>
			<expr_stmt><expr><name>accumbits</name> -= <name>nsignbits</name></expr>;</expr_stmt>
		}</block></then></if>

		<comment type="block">/* Store as many bytes as possible. */</comment>
		<while>while <condition>(<expr><name>accumbits</name> &gt;= 8</expr>)</condition> <block>{
			<if>if <condition>(<expr><name>j</name> &gt;= <name>n</name></expr>)</condition><then>
				<goto>goto <name>Overflow</name>;</goto></then></if>
			<expr_stmt><expr>++<name>j</name></expr>;</expr_stmt>
			<expr_stmt><expr>*<name>p</name> = <call>(<name>unsigned</name> <name>char</name>)<argument_list>(<argument><expr><name>accum</name> &amp; 0xff</expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>p</name> += <name>pincr</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>accumbits</name> -= 8</expr>;</expr_stmt>
			<expr_stmt><expr><name>accum</name> &gt;&gt;= 8</expr>;</expr_stmt>
		}</block></while>
	}</block></for>

	<comment type="block">/* Store the straggler (if any). */</comment>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>accumbits</name> &lt; 8</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>carry</name> == 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* else do_twos_comp and *every* digit was 0 */</comment>
	<if>if <condition>(<expr><name>accumbits</name> &gt; 0</expr>)</condition><then> <block>{
		<if>if <condition>(<expr><name>j</name> &gt;= <name>n</name></expr>)</condition><then>
			<goto>goto <name>Overflow</name>;</goto></then></if>
		<expr_stmt><expr>++<name>j</name></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>do_twos_comp</name></expr>)</condition><then> <block>{
			<comment type="block">/* Fill leading bits of the byte with sign bits
			   (appropriately pretending that the long had an
			   infinite supply of sign bits). */</comment>
			<expr_stmt><expr><name>accum</name> |= (~(<name>twodigits</name>)0) &lt;&lt; <name>accumbits</name></expr>;</expr_stmt>
		}</block></then></if>
		<expr_stmt><expr>*<name>p</name> = <call>(<name>unsigned</name> <name>char</name>)<argument_list>(<argument><expr><name>accum</name> &amp; 0xff</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>p</name> += <name>pincr</name></expr>;</expr_stmt>
	}</block></then>
	<else>else <if>if <condition>(<expr><name>j</name> == <name>n</name> &amp;&amp; <name>n</name> &gt; 0 &amp;&amp; <name>is_signed</name></expr>)</condition><then> <block>{
		<comment type="block">/* The main loop filled the byte array exactly, so the code
		   just above didn't get to ensure there's a sign bit, and the
		   loop below wouldn't add one either.  Make sure a sign bit
		   exists. */</comment>
		<decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name>msb</name> <init>= <expr>*(<name>p</name> - <name>pincr</name>)</expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>sign_bit_set</name> <init>= <expr><name>msb</name> &gt;= 0x80</expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>accumbits</name> == 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>sign_bit_set</name> == <name>do_twos_comp</name></expr>)</condition><then>
			<return>return <expr>0</expr>;</return></then>
		<else>else
			<goto>goto <name>Overflow</name>;</goto></else></if>
	}</block></then></if></else></if>

	<comment type="block">/* Fill remaining bytes with copies of the sign bit. */</comment>
	<block>{
		<decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name>signbyte</name> <init>= <expr><name>do_twos_comp</name> ? 0xffU : 0U</expr></init></decl>;</decl_stmt>
		<for>for ( <init>;</init> <condition><expr><name>j</name> &lt; <name>n</name></expr>;</condition> <incr><expr>++<name>j</name></expr>, <expr><name>p</name> += <name>pincr</name></expr></incr>)
			<expr_stmt><expr>*<name>p</name> = <name>signbyte</name></expr>;</expr_stmt></for>
	}</block>

	<return>return <expr>0</expr>;</return>

<label><name>Overflow</name>:</label>
	<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_OverflowError</name></expr></argument>, <argument><expr>"long too big to convert"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr>-1</expr>;</return>

}</block></function>

<function><type><name>double</name></type>
<name>_PyLong_AsScaledDouble</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>vv</name></decl></param>, <param><decl><type><name>int</name> *</type><name>exponent</name></decl></param>)</parameter_list>
<block>{
<comment type="block">/* NBITS_WANTED should be &gt; the number of bits in a double's precision,
   but small enough so that 2**NBITS_WANTED is within the normal double
   range.  nbitsneeded is set to 1 less than that because the most-significant
   Python digit contains at least 1 significant bit, but we don't want to
   bother counting them (catering to the worst case cheaply).

   57 is one more than VAX-D double precision; I (Tim) don't know of a double
   format with more precision than that; it's 1 larger so that we add in at
   least one round bit to stand in for the ignored least-significant bits.
*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NBITS_WANTED</name></cpp:macro> <cpp:value>57</cpp:value></cpp:define>
	<decl_stmt><decl><type><name>PyLongObject</name> *</type><name>v</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type> <name>x</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>double</name></type> <name>multiplier</name> <init>= <expr><call>(<name>double</name>)<argument_list>(<argument><expr>1L &lt;&lt; <name>PyLong_SHIFT</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>sign</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>nbitsneeded</name></decl>;</decl_stmt>

	<if>if <condition>(<expr><name>vv</name> == <name>NULL</name> || !<call><name>PyLong_Check</name><argument_list>(<argument><expr><name>vv</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_BadInternalCall</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>-1</expr>;</return>
	}</block></then></if>
	<expr_stmt><expr><name>v</name> = (<name>PyLongObject</name> *)<name>vv</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>i</name> = <call><name>Py_SIZE</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>sign</name> = 1</expr>;</expr_stmt>
	<if>if <condition>(<expr><name>i</name> &lt; 0</expr>)</condition><then> <block>{
		<expr_stmt><expr><name>sign</name> = -1</expr>;</expr_stmt>
		<expr_stmt><expr><name>i</name> = -(<name>i</name>)</expr>;</expr_stmt>
	}</block></then>
	<else>else <if>if <condition>(<expr><name>i</name> == 0</expr>)</condition><then> <block>{
		<expr_stmt><expr>*<name>exponent</name> = 0</expr>;</expr_stmt>
		<return>return <expr>0.0</expr>;</return>
	}</block></then></if></else></if>
	<expr_stmt><expr>--<name>i</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>x</name> = (<name>double</name>)<name><name>v</name>-&gt;<name>ob_digit</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>nbitsneeded</name> = <name>NBITS_WANTED</name> - 1</expr>;</expr_stmt>
	<comment type="block">/* Invariant:  i Python digits remain unaccounted for. */</comment>
	<while>while <condition>(<expr><name>i</name> &gt; 0 &amp;&amp; <name>nbitsneeded</name> &gt; 0</expr>)</condition> <block>{
		<expr_stmt><expr>--<name>i</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>x</name> = <name>x</name> * <name>multiplier</name> + (<name>double</name>)<name><name>v</name>-&gt;<name>ob_digit</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>nbitsneeded</name> -= <name>PyLong_SHIFT</name></expr>;</expr_stmt>
	}</block></while>
	<comment type="block">/* There are i digits we didn't shift in.  Pretending they're all
	   zeroes, the true value is x * 2**(i*PyLong_SHIFT). */</comment>
	<expr_stmt><expr>*<name>exponent</name> = <name>i</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>x</name> &gt; 0.0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>x</name> * <name>sign</name></expr>;</return>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>NBITS_WANTED</name></cpp:undef>
}</block></function>

<comment type="block">/* Get a C double from a long int object. */</comment>

<function><type><name>double</name></type>
<name>PyLong_AsDouble</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>vv</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>int</name></type> <name>e</name> <init>= <expr>-1</expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type> <name>x</name></decl>;</decl_stmt>

	<if>if <condition>(<expr><name>vv</name> == <name>NULL</name> || !<call><name>PyLong_Check</name><argument_list>(<argument><expr><name>vv</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_BadInternalCall</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>-1</expr>;</return>
	}</block></then></if>
	<expr_stmt><expr><name>x</name> = <call><name>_PyLong_AsScaledDouble</name><argument_list>(<argument><expr><name>vv</name></expr></argument>, <argument><expr>&amp;<name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>x</name> == -1.0 &amp;&amp; <call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then>
		<return>return <expr>-1.0</expr>;</return></then></if>
	<comment type="block">/* 'e' initialized to -1 to silence gcc-4.0.x, but it should be
	   set correctly after a successful _PyLong_AsScaledDouble() call */</comment>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>e</name> &gt;= 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>e</name> &gt; <name>INT_MAX</name> / <name>PyLong_SHIFT</name></expr>)</condition><then>
		<goto>goto <name>overflow</name>;</goto></then></if>
	<expr_stmt><expr><name>errno</name> = 0</expr>;</expr_stmt>
	<expr_stmt><expr><name>x</name> = <call><name>ldexp</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><name>e</name> * <name>PyLong_SHIFT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><call><name>Py_OVERFLOWED</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<goto>goto <name>overflow</name>;</goto></then></if>
	<return>return <expr><name>x</name></expr>;</return>

<label><name>overflow</name>:</label>
	<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_OverflowError</name></expr></argument>,
		<argument><expr>"long int too large to convert to float"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr>-1.0</expr>;</return>
}</block></function>

<comment type="block">/* Create a new long (or int) object from a C pointer */</comment>

<function><type><name>PyObject</name> *</type>
<name>PyLong_FromVoidPtr</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>p</name></decl></param>)</parameter_list>
<block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SIZEOF_VOID_P</name> &lt;= <name>SIZEOF_LONG</name></expr></cpp:if>
	<if>if <condition>(<expr>(<name>long</name>)<name>p</name> &lt; 0</expr>)</condition><then>
		<return>return <expr><call><name>PyLong_FromUnsignedLong</name><argument_list>(<argument><expr>(<name>unsigned</name> <name>long</name>)<name>p</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
	<return>return <expr><call><name>PyInt_FromLong</name><argument_list>(<argument><expr>(<name>long</name>)<name>p</name></expr></argument>)</argument_list></call></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>HAVE_LONG_LONG</name></cpp:ifndef>
<cpp:error>#   <cpp:directive>error</cpp:directive> "PyLong_FromVoidPtr: sizeof(void*) &gt; sizeof(long), but no long long"</cpp:error>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SIZEOF_LONG_LONG</name> &lt; <name>SIZEOF_VOID_P</name></expr></cpp:if>
<cpp:error>#   <cpp:directive>error</cpp:directive> "PyLong_FromVoidPtr: sizeof(PY_LONG_LONG) &lt; sizeof(void*)"</cpp:error>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<comment type="block">/* optimize null pointers */</comment>
	<if>if <condition>(<expr><name>p</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr><call><name>PyInt_FromLong</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</return></then></if>
	<return>return <expr><call><name>PyLong_FromUnsignedLongLong</name><argument_list>(<argument><expr>(<name>unsigned</name> <name>PY_LONG_LONG</name>)<name>p</name></expr></argument>)</argument_list></call></expr>;</return>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SIZEOF_VOID_P &lt;= SIZEOF_LONG */</comment>
}</block></function>

<comment type="block">/* Get a C pointer from a long object (or an int object in some cases) */</comment>

<function><type><name>void</name> *</type>
<name>PyLong_AsVoidPtr</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>vv</name></decl></param>)</parameter_list>
<block>{
	<comment type="block">/* This function will allow int or long objects. If vv is neither,
	   then the PyLong_AsLong*() functions will raise the exception:
	   PyExc_SystemError, "bad argument to internal function"
	*/</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SIZEOF_VOID_P</name> &lt;= <name>SIZEOF_LONG</name></expr></cpp:if>
	<decl_stmt><decl><type><name>long</name></type> <name>x</name></decl>;</decl_stmt>

	<if>if <condition>(<expr><call><name>PyInt_Check</name><argument_list>(<argument><expr><name>vv</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<expr_stmt><expr><name>x</name> = <call><name>PyInt_AS_LONG</name><argument_list>(<argument><expr><name>vv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
	<else>else <if>if <condition>(<expr><call><name>PyLong_Check</name><argument_list>(<argument><expr><name>vv</name></expr></argument>)</argument_list></call> &amp;&amp; <call><name>_PyLong_Sign</name><argument_list>(<argument><expr><name>vv</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
		<expr_stmt><expr><name>x</name> = <call><name>PyLong_AsLong</name><argument_list>(<argument><expr><name>vv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
	<else>else
		<expr_stmt><expr><name>x</name> = <call><name>PyLong_AsUnsignedLong</name><argument_list>(<argument><expr><name>vv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if></else></if>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>HAVE_LONG_LONG</name></cpp:ifndef>
<cpp:error>#   <cpp:directive>error</cpp:directive> "PyLong_AsVoidPtr: sizeof(void*) &gt; sizeof(long), but no long long"</cpp:error>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SIZEOF_LONG_LONG</name> &lt; <name>SIZEOF_VOID_P</name></expr></cpp:if>
<cpp:error>#   <cpp:directive>error</cpp:directive> "PyLong_AsVoidPtr: sizeof(PY_LONG_LONG) &lt; sizeof(void*)"</cpp:error>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<decl_stmt><decl><type><name>PY_LONG_LONG</name></type> <name>x</name></decl>;</decl_stmt>

	<if>if <condition>(<expr><call><name>PyInt_Check</name><argument_list>(<argument><expr><name>vv</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<expr_stmt><expr><name>x</name> = <call><name>PyInt_AS_LONG</name><argument_list>(<argument><expr><name>vv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
	<else>else <if>if <condition>(<expr><call><name>PyLong_Check</name><argument_list>(<argument><expr><name>vv</name></expr></argument>)</argument_list></call> &amp;&amp; <call><name>_PyLong_Sign</name><argument_list>(<argument><expr><name>vv</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
		<expr_stmt><expr><name>x</name> = <call><name>PyLong_AsLongLong</name><argument_list>(<argument><expr><name>vv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
	<else>else
		<expr_stmt><expr><name>x</name> = <call><name>PyLong_AsUnsignedLongLong</name><argument_list>(<argument><expr><name>vv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if></else></if>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SIZEOF_VOID_P &lt;= SIZEOF_LONG */</comment>

	<if>if <condition>(<expr><name>x</name> == -1 &amp;&amp; <call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<return>return <expr>(<name>void</name> *)<name>x</name></expr>;</return>
}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_LONG_LONG</name></cpp:ifdef>

<comment type="block">/* Initial PY_LONG_LONG support by Chris Herborth (chrish@qnx.com), later
 * rewritten to use the newer PyLong_{As,From}ByteArray API.
 */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IS_LITTLE_ENDIAN</name></cpp:macro> <cpp:value>(int)*(unsigned char*)&amp;one</cpp:value></cpp:define>

<comment type="block">/* Create a new long int object from a C PY_LONG_LONG int. */</comment>

<function><type><name>PyObject</name> *</type>
<name>PyLong_FromLongLong</name><parameter_list>(<param><decl><type><name>PY_LONG_LONG</name></type> <name>ival</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyLongObject</name> *</type><name>v</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unsigned</name> <name>PY_LONG_LONG</name></type> <name>abs_ival</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unsigned</name> <name>PY_LONG_LONG</name></type> <name>t</name></decl>;</decl_stmt>  <comment type="block">/* unsigned so &gt;&gt; doesn't propagate sign bit */</comment>
	<decl_stmt><decl><type><name>int</name></type> <name>ndigits</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>negative</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>

	<if>if <condition>(<expr><name>ival</name> &lt; 0</expr>)</condition><then> <block>{
		<comment type="block">/* avoid signed overflow on negation;  see comments
		   in PyLong_FromLong above. */</comment>
		<expr_stmt><expr><name>abs_ival</name> = <call>(<name>unsigned</name> <name>PY_LONG_LONG</name>)<argument_list>(<argument><expr>-1-<name>ival</name></expr></argument>)</argument_list></call> + 1</expr>;</expr_stmt>
		<expr_stmt><expr><name>negative</name> = 1</expr>;</expr_stmt>
	}</block></then>
	<else>else <block>{
		<expr_stmt><expr><name>abs_ival</name> = (<name>unsigned</name> <name>PY_LONG_LONG</name>)<name>ival</name></expr>;</expr_stmt>
	}</block></else></if>

	<comment type="block">/* Count the number of Python digits.
	   We used to pick 5 ("big enough for anything"), but that's a
	   waste of time and space given that 5*15 = 75 bits are rarely
	   needed. */</comment>
	<expr_stmt><expr><name>t</name> = <name>abs_ival</name></expr>;</expr_stmt>
	<while>while <condition>(<expr><name>t</name></expr>)</condition> <block>{
		<expr_stmt><expr>++<name>ndigits</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>t</name> &gt;&gt;= <name>PyLong_SHIFT</name></expr>;</expr_stmt>
	}</block></while>
	<expr_stmt><expr><name>v</name> = <call><name>_PyLong_New</name><argument_list>(<argument><expr><name>ndigits</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>v</name> != <name>NULL</name></expr>)</condition><then> <block>{
		<decl_stmt><decl><type><name>digit</name> *</type><name>p</name> <init>= <expr><name><name>v</name>-&gt;<name>ob_digit</name></name></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>Py_SIZE</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call> = <name>negative</name> ? -<name>ndigits</name> : <name>ndigits</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>t</name> = <name>abs_ival</name></expr>;</expr_stmt>
		<while>while <condition>(<expr><name>t</name></expr>)</condition> <block>{
			<expr_stmt><expr>*<name>p</name>++ = <call>(<name>digit</name>)<argument_list>(<argument><expr><name>t</name> &amp; <name>PyLong_MASK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>t</name> &gt;&gt;= <name>PyLong_SHIFT</name></expr>;</expr_stmt>
		}</block></while>
	}</block></then></if>
	<return>return <expr>(<name>PyObject</name> *)<name>v</name></expr>;</return>
}</block></function>

<comment type="block">/* Create a new long int object from a C unsigned PY_LONG_LONG int. */</comment>

<function><type><name>PyObject</name> *</type>
<name>PyLong_FromUnsignedLongLong</name><parameter_list>(<param><decl><type><name>unsigned</name> <name>PY_LONG_LONG</name></type> <name>ival</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyLongObject</name> *</type><name>v</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unsigned</name> <name>PY_LONG_LONG</name></type> <name>t</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>ndigits</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>

	<comment type="block">/* Count the number of Python digits. */</comment>
	<expr_stmt><expr><name>t</name> = (<name>unsigned</name> <name>PY_LONG_LONG</name>)<name>ival</name></expr>;</expr_stmt>
	<while>while <condition>(<expr><name>t</name></expr>)</condition> <block>{
		<expr_stmt><expr>++<name>ndigits</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>t</name> &gt;&gt;= <name>PyLong_SHIFT</name></expr>;</expr_stmt>
	}</block></while>
	<expr_stmt><expr><name>v</name> = <call><name>_PyLong_New</name><argument_list>(<argument><expr><name>ndigits</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>v</name> != <name>NULL</name></expr>)</condition><then> <block>{
		<decl_stmt><decl><type><name>digit</name> *</type><name>p</name> <init>= <expr><name><name>v</name>-&gt;<name>ob_digit</name></name></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>Py_SIZE</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call> = <name>ndigits</name></expr>;</expr_stmt>
		<while>while <condition>(<expr><name>ival</name></expr>)</condition> <block>{
			<expr_stmt><expr>*<name>p</name>++ = <call>(<name>digit</name>)<argument_list>(<argument><expr><name>ival</name> &amp; <name>PyLong_MASK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>ival</name> &gt;&gt;= <name>PyLong_SHIFT</name></expr>;</expr_stmt>
		}</block></while>
	}</block></then></if>
	<return>return <expr>(<name>PyObject</name> *)<name>v</name></expr>;</return>
}</block></function>

<comment type="block">/* Create a new long int object from a C Py_ssize_t. */</comment>

<function><type><name>PyObject</name> *</type>
<name>PyLong_FromSsize_t</name><parameter_list>(<param><decl><type><name>Py_ssize_t</name></type> <name>ival</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>bytes</name> <init>= <expr><name>ival</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>one</name> <init>= <expr>1</expr></init></decl>;</decl_stmt>
	<return>return <expr><call><name>_PyLong_FromByteArray</name><argument_list>(
			<argument><expr>(<name>unsigned</name> <name>char</name> *)&amp;<name>bytes</name></expr></argument>,
			<argument><expr><name>SIZEOF_SIZE_T</name></expr></argument>, <argument><expr><name>IS_LITTLE_ENDIAN</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<comment type="block">/* Create a new long int object from a C size_t. */</comment>

<function><type><name>PyObject</name> *</type>
<name>PyLong_FromSize_t</name><parameter_list>(<param><decl><type><name>size_t</name></type> <name>ival</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>size_t</name></type> <name>bytes</name> <init>= <expr><name>ival</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>one</name> <init>= <expr>1</expr></init></decl>;</decl_stmt>
	<return>return <expr><call><name>_PyLong_FromByteArray</name><argument_list>(
			<argument><expr>(<name>unsigned</name> <name>char</name> *)&amp;<name>bytes</name></expr></argument>,
			<argument><expr><name>SIZEOF_SIZE_T</name></expr></argument>, <argument><expr><name>IS_LITTLE_ENDIAN</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<comment type="block">/* Get a C PY_LONG_LONG int from a long int object.
   Return -1 and set an error if overflow occurs. */</comment>

<function><type><name>PY_LONG_LONG</name></type>
<name>PyLong_AsLongLong</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>vv</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PY_LONG_LONG</name></type> <name>bytes</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>one</name> <init>= <expr>1</expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>res</name></decl>;</decl_stmt>

	<if>if <condition>(<expr><name>vv</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_BadInternalCall</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>-1</expr>;</return>
	}</block></then></if>
	<if>if <condition>(<expr>!<call><name>PyLong_Check</name><argument_list>(<argument><expr><name>vv</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<decl_stmt><decl><type><name>PyNumberMethods</name> *</type><name>nb</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PyObject</name> *</type><name>io</name></decl>;</decl_stmt>
		<if>if <condition>(<expr><call><name>PyInt_Check</name><argument_list>(<argument><expr><name>vv</name></expr></argument>)</argument_list></call></expr>)</condition><then>
			<return>return <expr>(<name>PY_LONG_LONG</name>)<call><name>PyInt_AsLong</name><argument_list>(<argument><expr><name>vv</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
		<if>if <condition>(<expr>(<name>nb</name> = <name><name>vv</name>-&gt;<name>ob_type</name>-&gt;<name>tp_as_number</name></name>) == <name>NULL</name> ||
		    <name><name>nb</name>-&gt;<name>nb_int</name></name> == <name>NULL</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>, <argument><expr>"an integer is required"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr>-1</expr>;</return>
		}</block></then></if>
		<expr_stmt><expr><name>io</name> = <call>(*<name><name>nb</name>-&gt;<name>nb_int</name></name>) <argument_list>(<argument><expr><name>vv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>io</name> == <name>NULL</name></expr>)</condition><then>
			<return>return <expr>-1</expr>;</return></then></if>
		<if>if <condition>(<expr><call><name>PyInt_Check</name><argument_list>(<argument><expr><name>io</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
			<expr_stmt><expr><name>bytes</name> = <call><name>PyInt_AsLong</name><argument_list>(<argument><expr><name>io</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>io</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>bytes</name></expr>;</return>
		}</block></then></if>
		<if>if <condition>(<expr><call><name>PyLong_Check</name><argument_list>(<argument><expr><name>io</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
			<expr_stmt><expr><name>bytes</name> = <call><name>PyLong_AsLongLong</name><argument_list>(<argument><expr><name>io</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>io</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>bytes</name></expr>;</return>
		}</block></then></if>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>io</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>, <argument><expr>"integer conversion failed"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>-1</expr>;</return>
	}</block></then></if>

	<expr_stmt><expr><name>res</name> = <call><name>_PyLong_AsByteArray</name><argument_list>(
			<argument><expr>(<name>PyLongObject</name> *)<name>vv</name></expr></argument>, <argument><expr>(<name>unsigned</name> <name>char</name> *)&amp;<name>bytes</name></expr></argument>,
			<argument><expr><name>SIZEOF_LONG_LONG</name></expr></argument>, <argument><expr><name>IS_LITTLE_ENDIAN</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Plan 9 can't handle PY_LONG_LONG in ? : expressions */</comment>
	<if>if <condition>(<expr><name>res</name> &lt; 0</expr>)</condition><then>
		<return>return <expr>(<name>PY_LONG_LONG</name>)-1</expr>;</return></then>
	<else>else
		<return>return <expr><name>bytes</name></expr>;</return></else></if>
}</block></function>

<comment type="block">/* Get a C unsigned PY_LONG_LONG int from a long int object.
   Return -1 and set an error if overflow occurs. */</comment>

<function><type><name>unsigned</name> <name>PY_LONG_LONG</name></type>
<name>PyLong_AsUnsignedLongLong</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>vv</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>unsigned</name> <name>PY_LONG_LONG</name></type> <name>bytes</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>one</name> <init>= <expr>1</expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>res</name></decl>;</decl_stmt>

	<if>if <condition>(<expr><name>vv</name> == <name>NULL</name> || !<call><name>PyLong_Check</name><argument_list>(<argument><expr><name>vv</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_BadInternalCall</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>(<name>unsigned</name> <name>PY_LONG_LONG</name>)-1</expr>;</return>
	}</block></then></if>

	<expr_stmt><expr><name>res</name> = <call><name>_PyLong_AsByteArray</name><argument_list>(
			<argument><expr>(<name>PyLongObject</name> *)<name>vv</name></expr></argument>, <argument><expr>(<name>unsigned</name> <name>char</name> *)&amp;<name>bytes</name></expr></argument>,
			<argument><expr><name>SIZEOF_LONG_LONG</name></expr></argument>, <argument><expr><name>IS_LITTLE_ENDIAN</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Plan 9 can't handle PY_LONG_LONG in ? : expressions */</comment>
	<if>if <condition>(<expr><name>res</name> &lt; 0</expr>)</condition><then>
		<return>return <expr>(<name>unsigned</name> <name>PY_LONG_LONG</name>)<name>res</name></expr>;</return></then>
	<else>else
		<return>return <expr><name>bytes</name></expr>;</return></else></if>
}</block></function>

<comment type="block">/* Get a C unsigned long int from a long int object, ignoring the high bits.
   Returns -1 and sets an error condition if an error occurs. */</comment>

<function><type><name>unsigned</name> <name>PY_LONG_LONG</name></type>
<name>PyLong_AsUnsignedLongLongMask</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>vv</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>register</name> <name>PyLongObject</name> *</type><name>v</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unsigned</name> <name>PY_LONG_LONG</name></type> <name>x</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>sign</name></decl>;</decl_stmt>

	<if>if <condition>(<expr><name>vv</name> == <name>NULL</name> || !<call><name>PyLong_Check</name><argument_list>(<argument><expr><name>vv</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_BadInternalCall</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>(<name>unsigned</name> <name>long</name>) -1</expr>;</return>
	}</block></then></if>
	<expr_stmt><expr><name>v</name> = (<name>PyLongObject</name> *)<name>vv</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>i</name> = <name><name>v</name>-&gt;<name>ob_size</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>sign</name> = 1</expr>;</expr_stmt>
	<expr_stmt><expr><name>x</name> = 0</expr>;</expr_stmt>
	<if>if <condition>(<expr><name>i</name> &lt; 0</expr>)</condition><then> <block>{
		<expr_stmt><expr><name>sign</name> = -1</expr>;</expr_stmt>
		<expr_stmt><expr><name>i</name> = -<name>i</name></expr>;</expr_stmt>
	}</block></then></if>
	<while>while <condition>(<expr>--<name>i</name> &gt;= 0</expr>)</condition> <block>{
		<expr_stmt><expr><name>x</name> = (<name>x</name> &lt;&lt; <name>PyLong_SHIFT</name>) + <name><name>v</name>-&gt;<name>ob_digit</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
	}</block></while>
	<return>return <expr><name>x</name> * <name>sign</name></expr>;</return>
}</block></function>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>IS_LITTLE_ENDIAN</name></cpp:undef>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* HAVE_LONG_LONG */</comment>


<function><type><specifier>static</specifier> <name>int</name></type>
<name>convert_binop</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>v</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>w</name></decl></param>, <param><decl><type><name>PyLongObject</name> **</type><name>a</name></decl></param>, <param><decl><type><name>PyLongObject</name> **</type><name>b</name></decl></param>)</parameter_list> <block>{
	<if>if <condition>(<expr><call><name>PyLong_Check</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr>*<name>a</name> = (<name>PyLongObject</name> *) <name>v</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then>
	<else>else <if>if <condition>(<expr><call><name>PyInt_Check</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr>*<name>a</name> = (<name>PyLongObject</name> *) <call><name>PyLong_FromLong</name><argument_list>(<argument><expr><call><name>PyInt_AS_LONG</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then>
	<else>else <block>{
		<return>return <expr>0</expr>;</return>
	}</block></else></if></else></if>
	<if>if <condition>(<expr><call><name>PyLong_Check</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr>*<name>b</name> = (<name>PyLongObject</name> *) <name>w</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then>
	<else>else <if>if <condition>(<expr><call><name>PyInt_Check</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr>*<name>b</name> = (<name>PyLongObject</name> *) <call><name>PyLong_FromLong</name><argument_list>(<argument><expr><call><name>PyInt_AS_LONG</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then>
	<else>else <block>{
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr>*<name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>0</expr>;</return>
	}</block></else></if></else></if>
	<return>return <expr>1</expr>;</return>
}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CONVERT_BINOP</name><parameter_list>(<param><type><name>v</name></type></param>, <param><type><name>w</name></type></param>, <param><type><name>a</name></type></param>, <param><type><name>b</name></type></param>)</parameter_list></cpp:macro> \
	<cpp:value>if (!convert_binop(v, w, a, b)) { \
		Py_INCREF(Py_NotImplemented); \
		return Py_NotImplemented; \
	}</cpp:value></cpp:define>

<comment type="block">/* x[0:m] and y[0:n] are digit vectors, LSD first, m &gt;= n required.  x[0:n]
 * is modified in place, by adding y to it.  Carries are propagated as far as
 * x[m-1], and the remaining carry (0 or 1) is returned.
 */</comment>
<function><type><specifier>static</specifier> <name>digit</name></type>
<name>v_iadd</name><parameter_list>(<param><decl><type><name>digit</name> *</type><name>x</name></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>m</name></decl></param>, <param><decl><type><name>digit</name> *</type><name>y</name></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>n</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>digit</name></type> <name>carry</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>m</name> &gt;= <name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>n</name></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>) <block>{
		<expr_stmt><expr><name>carry</name> += <name><name>x</name><index>[<expr><name>i</name></expr>]</index></name> + <name><name>y</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>x</name><index>[<expr><name>i</name></expr>]</index></name> = <name>carry</name> &amp; <name>PyLong_MASK</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>carry</name> &gt;&gt;= <name>PyLong_SHIFT</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr>(<name>carry</name> &amp; 1) == <name>carry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></for>
	<for>for (<init>;</init> <condition><expr><name>carry</name> &amp;&amp; <name>i</name> &lt; <name>m</name></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>) <block>{
		<expr_stmt><expr><name>carry</name> += <name><name>x</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>x</name><index>[<expr><name>i</name></expr>]</index></name> = <name>carry</name> &amp; <name>PyLong_MASK</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>carry</name> &gt;&gt;= <name>PyLong_SHIFT</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr>(<name>carry</name> &amp; 1) == <name>carry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></for>
	<return>return <expr><name>carry</name></expr>;</return>
}</block></function>

<comment type="block">/* x[0:m] and y[0:n] are digit vectors, LSD first, m &gt;= n required.  x[0:n]
 * is modified in place, by subtracting y from it.  Borrows are propagated as
 * far as x[m-1], and the remaining borrow (0 or 1) is returned.
 */</comment>
<function><type><specifier>static</specifier> <name>digit</name></type>
<name>v_isub</name><parameter_list>(<param><decl><type><name>digit</name> *</type><name>x</name></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>m</name></decl></param>, <param><decl><type><name>digit</name> *</type><name>y</name></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>n</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>digit</name></type> <name>borrow</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>m</name> &gt;= <name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>n</name></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>) <block>{
		<expr_stmt><expr><name>borrow</name> = <name><name>x</name><index>[<expr><name>i</name></expr>]</index></name> - <name><name>y</name><index>[<expr><name>i</name></expr>]</index></name> - <name>borrow</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>x</name><index>[<expr><name>i</name></expr>]</index></name> = <name>borrow</name> &amp; <name>PyLong_MASK</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>borrow</name> &gt;&gt;= <name>PyLong_SHIFT</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>borrow</name> &amp;= 1</expr>;</expr_stmt>	<comment type="block">/* keep only 1 sign bit */</comment>
	}</block></for>
	<for>for (<init>;</init> <condition><expr><name>borrow</name> &amp;&amp; <name>i</name> &lt; <name>m</name></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>) <block>{
		<expr_stmt><expr><name>borrow</name> = <name><name>x</name><index>[<expr><name>i</name></expr>]</index></name> - <name>borrow</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>x</name><index>[<expr><name>i</name></expr>]</index></name> = <name>borrow</name> &amp; <name>PyLong_MASK</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>borrow</name> &gt;&gt;= <name>PyLong_SHIFT</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>borrow</name> &amp;= 1</expr>;</expr_stmt>
	}</block></for>
	<return>return <expr><name>borrow</name></expr>;</return>
}</block></function>

<comment type="block">/* Multiply by a single digit, ignoring the sign. */</comment>

<function><type><specifier>static</specifier> <name>PyLongObject</name> *</type>
<name>mul1</name><parameter_list>(<param><decl><type><name>PyLongObject</name> *</type><name>a</name></decl></param>, <param><decl><type><name>wdigit</name></type> <name>n</name></decl></param>)</parameter_list>
<block>{
	<return>return <expr><call><name>muladd1</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr>(<name>digit</name>)0</expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<comment type="block">/* Multiply by a single digit and add a single digit, ignoring the sign. */</comment>

<function><type><specifier>static</specifier> <name>PyLongObject</name> *</type>
<name>muladd1</name><parameter_list>(<param><decl><type><name>PyLongObject</name> *</type><name>a</name></decl></param>, <param><decl><type><name>wdigit</name></type> <name>n</name></decl></param>, <param><decl><type><name>wdigit</name></type> <name>extra</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>size_a</name> <init>= <expr><call><name>ABS</name><argument_list>(<argument><expr><call><name>Py_SIZE</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyLongObject</name> *</type><name>z</name> <init>= <expr><call><name>_PyLong_New</name><argument_list>(<argument><expr><name>size_a</name>+1</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>twodigits</name></type> <name>carry</name> <init>= <expr><name>extra</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>i</name></decl>;</decl_stmt>

	<if>if <condition>(<expr><name>z</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>size_a</name></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>) <block>{
		<expr_stmt><expr><name>carry</name> += (<name>twodigits</name>)<name><name>a</name>-&gt;<name>ob_digit</name><index>[<expr><name>i</name></expr>]</index></name> * <name>n</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>z</name>-&gt;<name>ob_digit</name><index>[<expr><name>i</name></expr>]</index></name> = <call>(<name>digit</name>) <argument_list>(<argument><expr><name>carry</name> &amp; <name>PyLong_MASK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>carry</name> &gt;&gt;= <name>PyLong_SHIFT</name></expr>;</expr_stmt>
	}</block></for>
	<expr_stmt><expr><name><name>z</name>-&gt;<name>ob_digit</name><index>[<expr><name>i</name></expr>]</index></name> = (<name>digit</name>) <name>carry</name></expr>;</expr_stmt>
	<return>return <expr><call><name>long_normalize</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<comment type="block">/* Divide long pin, w/ size digits, by non-zero digit n, storing quotient
   in pout, and returning the remainder.  pin and pout point at the LSD.
   It's OK for pin == pout on entry, which saves oodles of mallocs/frees in
   _PyLong_Format, but that should be done with great care since longs are
   immutable. */</comment>

<function><type><specifier>static</specifier> <name>digit</name></type>
<name>inplace_divrem1</name><parameter_list>(<param><decl><type><name>digit</name> *</type><name>pout</name></decl></param>, <param><decl><type><name>digit</name> *</type><name>pin</name></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>size</name></decl></param>, <param><decl><type><name>digit</name></type> <name>n</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>twodigits</name></type> <name>rem</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>n</name> &gt; 0 &amp;&amp; <name>n</name> &lt;= <name>PyLong_MASK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>pin</name> += <name>size</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>pout</name> += <name>size</name></expr>;</expr_stmt>
	<while>while <condition>(<expr>--<name>size</name> &gt;= 0</expr>)</condition> <block>{
		<decl_stmt><decl><type><name>digit</name></type> <name>hi</name></decl>;</decl_stmt>
		<expr_stmt><expr><name>rem</name> = (<name>rem</name> &lt;&lt; <name>PyLong_SHIFT</name>) + *--<name>pin</name></expr>;</expr_stmt>
		<expr_stmt><expr>*--<name>pout</name> = <name>hi</name> = <call>(<name>digit</name>)<argument_list>(<argument><expr><name>rem</name> / <name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>rem</name> -= <name>hi</name> * <name>n</name></expr>;</expr_stmt>
	}</block></while>
	<return>return <expr>(<name>digit</name>)<name>rem</name></expr>;</return>
}</block></function>

<comment type="block">/* Divide a long integer by a digit, returning both the quotient
   (as function result) and the remainder (through *prem).
   The sign of a is ignored; n should not be zero. */</comment>

<function><type><specifier>static</specifier> <name>PyLongObject</name> *</type>
<name>divrem1</name><parameter_list>(<param><decl><type><name>PyLongObject</name> *</type><name>a</name></decl></param>, <param><decl><type><name>digit</name></type> <name>n</name></decl></param>, <param><decl><type><name>digit</name> *</type><name>prem</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><specifier>const</specifier> <name>Py_ssize_t</name></type> <name>size</name> <init>= <expr><call><name>ABS</name><argument_list>(<argument><expr><call><name>Py_SIZE</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyLongObject</name> *</type><name>z</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>n</name> &gt; 0 &amp;&amp; <name>n</name> &lt;= <name>PyLong_MASK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>z</name> = <call><name>_PyLong_New</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>z</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<expr_stmt><expr>*<name>prem</name> = <call><name>inplace_divrem1</name><argument_list>(<argument><expr><name><name>z</name>-&gt;<name>ob_digit</name></name></expr></argument>, <argument><expr><name><name>a</name>-&gt;<name>ob_digit</name></name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><call><name>long_normalize</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<comment type="block">/* Convert the long to a string object with given base,
   appending a base prefix of 0[box] if base is 2, 8 or 16.
   Add a trailing "L" if addL is non-zero.
   If newstyle is zero, then use the pre-2.6 behavior of octal having
   a leading "0", instead of the prefix "0o" */</comment>
<macro><name>PyAPI_FUNC</name><argument_list>(<argument>PyObject *</argument>)</argument_list></macro>
<macro><name>_PyLong_Format</name><argument_list>(<argument>PyObject *aa</argument>, <argument>int base</argument>, <argument>int addL</argument>, <argument>int newstyle</argument>)</argument_list></macro>
<block>{
	<decl_stmt><decl><type><name>register</name> <name>PyLongObject</name> *</type><name>a</name> <init>= <expr>(<name>PyLongObject</name> *)<name>aa</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyStringObject</name> *</type><name>str</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>, <decl><type ref="prev"/><name>sz</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>size_a</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> *</type><name>p</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>bits</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type> <name>sign</name> <init>= <expr>'\0'</expr></init></decl>;</decl_stmt>

	<if>if <condition>(<expr><name>a</name> == <name>NULL</name> || !<call><name>PyLong_Check</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_BadInternalCall</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>base</name> &gt;= 2 &amp;&amp; <name>base</name> &lt;= 36</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>size_a</name> = <call><name>ABS</name><argument_list>(<argument><expr><call><name>Py_SIZE</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Compute a rough upper bound for the length of the string */</comment>
	<expr_stmt><expr><name>i</name> = <name>base</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>bits</name> = 0</expr>;</expr_stmt>
	<while>while <condition>(<expr><name>i</name> &gt; 1</expr>)</condition> <block>{
		<expr_stmt><expr>++<name>bits</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>i</name> &gt;&gt;= 1</expr>;</expr_stmt>
	}</block></while>
	<expr_stmt><expr><name>i</name> = 5 + (<name>addL</name> ? 1 : 0)</expr>;</expr_stmt>
	<expr_stmt><expr><name>j</name> = <name>size_a</name>*<name>PyLong_SHIFT</name> + <name>bits</name>-1</expr>;</expr_stmt>
	<expr_stmt><expr><name>sz</name> = <name>i</name> + <name>j</name> / <name>bits</name></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>j</name> / <name>PyLong_SHIFT</name> &lt; <name>size_a</name> || <name>sz</name> &lt; <name>i</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_OverflowError</name></expr></argument>,
				<argument><expr>"long is too large to format"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>
	<expr_stmt><expr><name>str</name> = (<name>PyStringObject</name> *) <call><name>PyString_FromStringAndSize</name><argument_list>(<argument><expr>(<name>char</name> *)0</expr></argument>, <argument><expr><name>sz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>str</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<expr_stmt><expr><name>p</name> = <call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call> + <name>sz</name></expr>;</expr_stmt>
	<expr_stmt><expr>*<name>p</name> = '\0'</expr>;</expr_stmt>
        <if>if <condition>(<expr><name>addL</name></expr>)</condition><then>
                <expr_stmt><expr>*--<name>p</name> = 'L'</expr>;</expr_stmt></then></if>
	<if>if <condition>(<expr><name><name>a</name>-&gt;<name>ob_size</name></name> &lt; 0</expr>)</condition><then>
		<expr_stmt><expr><name>sign</name> = '-'</expr>;</expr_stmt></then></if>

	<if>if <condition>(<expr><name><name>a</name>-&gt;<name>ob_size</name></name> == 0</expr>)</condition><then> <block>{
		<expr_stmt><expr>*--<name>p</name> = '0'</expr>;</expr_stmt>
	}</block></then>
	<else>else <if>if <condition>(<expr>(<name>base</name> &amp; (<name>base</name> - 1)) == 0</expr>)</condition><then> <block>{
		<comment type="block">/* JRH: special case for power-of-2 bases */</comment>
		<decl_stmt><decl><type><name>twodigits</name></type> <name>accum</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>accumbits</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>	<comment type="block">/* # of bits in accum */</comment>
		<decl_stmt><decl><type><name>int</name></type> <name>basebits</name> <init>= <expr>1</expr></init></decl>;</decl_stmt>	<comment type="block">/* # of bits in base-1 */</comment>
		<expr_stmt><expr><name>i</name> = <name>base</name></expr>;</expr_stmt>
		<while>while <condition>(<expr>(<name>i</name> &gt;&gt;= 1) &gt; 1</expr>)</condition>
			<expr_stmt><expr>++<name>basebits</name></expr>;</expr_stmt></while>

		<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>size_a</name></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>) <block>{
			<expr_stmt><expr><name>accum</name> |= (<name>twodigits</name>)<name><name>a</name>-&gt;<name>ob_digit</name><index>[<expr><name>i</name></expr>]</index></name> &lt;&lt; <name>accumbits</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>accumbits</name> += <name>PyLong_SHIFT</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>accumbits</name> &gt;= <name>basebits</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<do>do <block>{
				<decl_stmt><decl><type><name>char</name></type> <name>cdigit</name> <init>= <expr><call>(<name>char</name>)<argument_list>(<argument><expr><name>accum</name> &amp; (<name>base</name> - 1)</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<expr_stmt><expr><name>cdigit</name> += (<name>cdigit</name> &lt; 10) ? '0' : 'a'-10</expr>;</expr_stmt>
				<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>p</name> &gt; <call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr>*--<name>p</name> = <name>cdigit</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>accumbits</name> -= <name>basebits</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>accum</name> &gt;&gt;= <name>basebits</name></expr>;</expr_stmt>
			}</block> while <condition>(<expr><name>i</name> &lt; <name>size_a</name>-1 ? <name>accumbits</name> &gt;= <name>basebits</name> :
					 	<name>accum</name> &gt; 0</expr>)</condition>;</do>
		}</block></for>
	}</block></then>
	<else>else <block>{
		<comment type="block">/* Not 0, and base not a power of 2.  Divide repeatedly by
		   base, but for speed use the highest power of base that
		   fits in a digit. */</comment>
		<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>size</name> <init>= <expr><name>size_a</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>digit</name> *</type><name>pin</name> <init>= <expr><name><name>a</name>-&gt;<name>ob_digit</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PyLongObject</name> *</type><name>scratch</name></decl>;</decl_stmt>
		<comment type="block">/* powbasw &lt;- largest power of base that fits in a digit. */</comment>
		<decl_stmt><decl><type><name>digit</name></type> <name>powbase</name> <init>= <expr><name>base</name></expr></init></decl>;</decl_stmt>  <comment type="block">/* powbase == base ** power */</comment>
		<decl_stmt><decl><type><name>int</name></type> <name>power</name> <init>= <expr>1</expr></init></decl>;</decl_stmt>
		<for>for (<init>;</init><condition>;</condition><incr/>) <block>{
			<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>newpow</name> <init>= <macro><name>powbase</name></macro> <expr>* (<name>unsigned</name> <name>long</name>)<name>base</name></expr></init></decl>;</decl_stmt>
			<if>if <condition>(<expr><name>newpow</name> &gt;&gt; <name>PyLong_SHIFT</name></expr>)</condition><then>  <comment type="block">/* doesn't fit in a digit */</comment>
				<break>break;</break></then></if>
			<expr_stmt><expr><name>powbase</name> = (<name>digit</name>)<name>newpow</name></expr>;</expr_stmt>
			<expr_stmt><expr>++<name>power</name></expr>;</expr_stmt>
		}</block></for>

		<comment type="block">/* Get a scratch area for repeated division. */</comment>
		<expr_stmt><expr><name>scratch</name> = <call><name>_PyLong_New</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>scratch</name> == <name>NULL</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>NULL</name></expr>;</return>
		}</block></then></if>

		<comment type="block">/* Repeatedly divide by powbase. */</comment>
		<do>do <block>{
			<decl_stmt><decl><type><name>int</name></type> <name>ntostore</name> <init>= <expr><name>power</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>digit</name></type> <name>rem</name> <init>= <expr><call><name>inplace_divrem1</name><argument_list>(<argument><expr><name><name>scratch</name>-&gt;<name>ob_digit</name></name></expr></argument>,
						     <argument><expr><name>pin</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><name>powbase</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><name>pin</name> = <name><name>scratch</name>-&gt;<name>ob_digit</name></name></expr>;</expr_stmt> <comment type="block">/* no need to use a again */</comment>
			<if>if <condition>(<expr><name><name>pin</name><index>[<expr><name>size</name> - 1</expr>]</index></name> == 0</expr>)</condition><then>
				<expr_stmt><expr>--<name>size</name></expr>;</expr_stmt></then></if>
			<macro><name>SIGCHECK</name><argument_list>(<argument>{
				Py_DECREF(scratch);
				Py_DECREF(str);
				return NULL;
			}</argument>)</argument_list></macro>

			<comment type="block">/* Break rem into digits. */</comment>
			<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>ntostore</name> &gt; 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<do>do <block>{
				<decl_stmt><decl><type><name>digit</name></type> <name>nextrem</name> <init>= <expr><call>(<name>digit</name>)<argument_list>(<argument><expr><name>rem</name> / <name>base</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>char</name></type> <name>c</name> <init>= <expr><call>(<name>char</name>)<argument_list>(<argument><expr><name>rem</name> - <name>nextrem</name> * <name>base</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>p</name> &gt; <call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>c</name> += (<name>c</name> &lt; 10) ? '0' : 'a'-10</expr>;</expr_stmt>
				<expr_stmt><expr>*--<name>p</name> = <name>c</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>rem</name> = <name>nextrem</name></expr>;</expr_stmt>
				<expr_stmt><expr>--<name>ntostore</name></expr>;</expr_stmt>
				<comment type="block">/* Termination is a bit delicate:  must not
				   store leading zeroes, so must get out if
				   remaining quotient and rem are both 0. */</comment>
			}</block> while <condition>(<expr><name>ntostore</name> &amp;&amp; (<name>size</name> || <name>rem</name>)</expr>)</condition>;</do>
		}</block> while <condition>(<expr><name>size</name> != 0</expr>)</condition>;</do>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>scratch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></else></if></else></if>

	<if>if <condition>(<expr><name>base</name> == 2</expr>)</condition><then> <block>{
		<expr_stmt><expr>*--<name>p</name> = 'b'</expr>;</expr_stmt>
		<expr_stmt><expr>*--<name>p</name> = '0'</expr>;</expr_stmt>
	}</block></then>
	<else>else <if>if <condition>(<expr><name>base</name> == 8</expr>)</condition><then> <block>{
 		<if>if <condition>(<expr><name>newstyle</name></expr>)</condition><then> <block>{
			<expr_stmt><expr>*--<name>p</name> = 'o'</expr>;</expr_stmt>
			<expr_stmt><expr>*--<name>p</name> = '0'</expr>;</expr_stmt>
		}</block></then>
		<else>else
			<if>if <condition>(<expr><name>size_a</name> != 0</expr>)</condition><then>
				<expr_stmt><expr>*--<name>p</name> = '0'</expr>;</expr_stmt></then></if></else></if>
	}</block></then>
	<else>else <if>if <condition>(<expr><name>base</name> == 16</expr>)</condition><then> <block>{
		<expr_stmt><expr>*--<name>p</name> = 'x'</expr>;</expr_stmt>
		<expr_stmt><expr>*--<name>p</name> = '0'</expr>;</expr_stmt>
	}</block></then>
	<else>else <if>if <condition>(<expr><name>base</name> != 10</expr>)</condition><then> <block>{
		<expr_stmt><expr>*--<name>p</name> = '#'</expr>;</expr_stmt>
		<expr_stmt><expr>*--<name>p</name> = '0' + <name>base</name>%10</expr>;</expr_stmt>
		<if>if <condition>(<expr><name>base</name> &gt; 10</expr>)</condition><then>
			<expr_stmt><expr>*--<name>p</name> = '0' + <name>base</name>/10</expr>;</expr_stmt></then></if>
	}</block></then></if></else></if></else></if></else></if>
	<if>if <condition>(<expr><name>sign</name></expr>)</condition><then>
		<expr_stmt><expr>*--<name>p</name> = <name>sign</name></expr>;</expr_stmt></then></if>
	<if>if <condition>(<expr><name>p</name> != <call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<decl_stmt><decl><type><name>char</name> *</type><name>q</name> <init>= <expr><call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>p</name> &gt; <name>q</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<do>do <block>{
		}</block> while <condition>(<expr>(*<name>q</name>++ = *<name>p</name>++) != '\0'</expr>)</condition>;</do>
		<expr_stmt><expr><name>q</name>--</expr>;</expr_stmt>
		<expr_stmt><expr><call><name>_PyString_Resize</name><argument_list>(<argument><expr>(<name>PyObject</name> **)&amp;<name>str</name></expr></argument>,
				 <argument><expr><call>(<name>Py_ssize_t</name>) <argument_list>(<argument><expr><name>q</name> - <call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>
	<return>return <expr>(<name>PyObject</name> *)<name>str</name></expr>;</return>
}</block>

<comment type="block">/* Table of digit values for 8-bit string -&gt; integer conversion.
 * '0' maps to 0, ..., '9' maps to 9.
 * 'a' and 'A' map to 10, ..., 'z' and 'Z' map to 35.
 * All other indices map to 37.
 * Note that when converting a base B string, a char c is a legitimate
 * base B digit iff _PyLong_DigitValue[Py_CHARMASK(c)] &lt; B.
 */</comment>
<decl_stmt><decl><type><name>int</name></type> <name><name>_PyLong_DigitValue</name><index>[<expr>256</expr>]</index></name> <init>= <expr><block>{
	<expr>37</expr>, <expr>37</expr>, <expr>37</expr>, <expr>37</expr>, <expr>37</expr>, <expr>37</expr>, <expr>37</expr>, <expr>37</expr>, <expr>37</expr>, <expr>37</expr>, <expr>37</expr>, <expr>37</expr>, <expr>37</expr>, <expr>37</expr>, <expr>37</expr>, <expr>37</expr>,
	<expr>37</expr>, <expr>37</expr>, <expr>37</expr>, <expr>37</expr>, <expr>37</expr>, <expr>37</expr>, <expr>37</expr>, <expr>37</expr>, <expr>37</expr>, <expr>37</expr>, <expr>37</expr>, <expr>37</expr>, <expr>37</expr>, <expr>37</expr>, <expr>37</expr>, <expr>37</expr>,
	<expr>37</expr>, <expr>37</expr>, <expr>37</expr>, <expr>37</expr>, <expr>37</expr>, <expr>37</expr>, <expr>37</expr>, <expr>37</expr>, <expr>37</expr>, <expr>37</expr>, <expr>37</expr>, <expr>37</expr>, <expr>37</expr>, <expr>37</expr>, <expr>37</expr>, <expr>37</expr>,
	<expr>0</expr>,  <expr>1</expr>,  <expr>2</expr>,  <expr>3</expr>,  <expr>4</expr>,  <expr>5</expr>,  <expr>6</expr>,  <expr>7</expr>,  <expr>8</expr>,  <expr>9</expr>,  <expr>37</expr>, <expr>37</expr>, <expr>37</expr>, <expr>37</expr>, <expr>37</expr>, <expr>37</expr>,
	<expr>37</expr>, <expr>10</expr>, <expr>11</expr>, <expr>12</expr>, <expr>13</expr>, <expr>14</expr>, <expr>15</expr>, <expr>16</expr>, <expr>17</expr>, <expr>18</expr>, <expr>19</expr>, <expr>20</expr>, <expr>21</expr>, <expr>22</expr>, <expr>23</expr>, <expr>24</expr>,
	<expr>25</expr>, <expr>26</expr>, <expr>27</expr>, <expr>28</expr>, <expr>29</expr>, <expr>30</expr>, <expr>31</expr>, <expr>32</expr>, <expr>33</expr>, <expr>34</expr>, <expr>35</expr>, <expr>37</expr>, <expr>37</expr>, <expr>37</expr>, <expr>37</expr>, <expr>37</expr>,
	<expr>37</expr>, <expr>10</expr>, <expr>11</expr>, <expr>12</expr>, <expr>13</expr>, <expr>14</expr>, <expr>15</expr>, <expr>16</expr>, <expr>17</expr>, <expr>18</expr>, <expr>19</expr>, <expr>20</expr>, <expr>21</expr>, <expr>22</expr>, <expr>23</expr>, <expr>24</expr>,
	<expr>25</expr>, <expr>26</expr>, <expr>27</expr>, <expr>28</expr>, <expr>29</expr>, <expr>30</expr>, <expr>31</expr>, <expr>32</expr>, <expr>33</expr>, <expr>34</expr>, <expr>35</expr>, <expr>37</expr>, <expr>37</expr>, <expr>37</expr>, <expr>37</expr>, <expr>37</expr>,
	<expr>37</expr>, <expr>37</expr>, <expr>37</expr>, <expr>37</expr>, <expr>37</expr>, <expr>37</expr>, <expr>37</expr>, <expr>37</expr>, <expr>37</expr>, <expr>37</expr>, <expr>37</expr>, <expr>37</expr>, <expr>37</expr>, <expr>37</expr>, <expr>37</expr>, <expr>37</expr>,
	<expr>37</expr>, <expr>37</expr>, <expr>37</expr>, <expr>37</expr>, <expr>37</expr>, <expr>37</expr>, <expr>37</expr>, <expr>37</expr>, <expr>37</expr>, <expr>37</expr>, <expr>37</expr>, <expr>37</expr>, <expr>37</expr>, <expr>37</expr>, <expr>37</expr>, <expr>37</expr>,
	<expr>37</expr>, <expr>37</expr>, <expr>37</expr>, <expr>37</expr>, <expr>37</expr>, <expr>37</expr>, <expr>37</expr>, <expr>37</expr>, <expr>37</expr>, <expr>37</expr>, <expr>37</expr>, <expr>37</expr>, <expr>37</expr>, <expr>37</expr>, <expr>37</expr>, <expr>37</expr>,
	<expr>37</expr>, <expr>37</expr>, <expr>37</expr>, <expr>37</expr>, <expr>37</expr>, <expr>37</expr>, <expr>37</expr>, <expr>37</expr>, <expr>37</expr>, <expr>37</expr>, <expr>37</expr>, <expr>37</expr>, <expr>37</expr>, <expr>37</expr>, <expr>37</expr>, <expr>37</expr>,
	<expr>37</expr>, <expr>37</expr>, <expr>37</expr>, <expr>37</expr>, <expr>37</expr>, <expr>37</expr>, <expr>37</expr>, <expr>37</expr>, <expr>37</expr>, <expr>37</expr>, <expr>37</expr>, <expr>37</expr>, <expr>37</expr>, <expr>37</expr>, <expr>37</expr>, <expr>37</expr>,
	<expr>37</expr>, <expr>37</expr>, <expr>37</expr>, <expr>37</expr>, <expr>37</expr>, <expr>37</expr>, <expr>37</expr>, <expr>37</expr>, <expr>37</expr>, <expr>37</expr>, <expr>37</expr>, <expr>37</expr>, <expr>37</expr>, <expr>37</expr>, <expr>37</expr>, <expr>37</expr>,
	<expr>37</expr>, <expr>37</expr>, <expr>37</expr>, <expr>37</expr>, <expr>37</expr>, <expr>37</expr>, <expr>37</expr>, <expr>37</expr>, <expr>37</expr>, <expr>37</expr>, <expr>37</expr>, <expr>37</expr>, <expr>37</expr>, <expr>37</expr>, <expr>37</expr>, <expr>37</expr>,
	<expr>37</expr>, <expr>37</expr>, <expr>37</expr>, <expr>37</expr>, <expr>37</expr>, <expr>37</expr>, <expr>37</expr>, <expr>37</expr>, <expr>37</expr>, <expr>37</expr>, <expr>37</expr>, <expr>37</expr>, <expr>37</expr>, <expr>37</expr>, <expr>37</expr>, <expr>37</expr>,
}</block></expr></init></decl>;</decl_stmt>

<comment type="block">/* *str points to the first digit in a string of base `base` digits.  base
 * is a power of 2 (2, 4, 8, 16, or 32).  *str is set to point to the first
 * non-digit (which may be *str!).  A normalized long is returned.
 * The point to this routine is that it takes time linear in the number of
 * string characters.
 */</comment>
<function><type><specifier>static</specifier> <name>PyLongObject</name> *</type>
<name>long_from_binary_base</name><parameter_list>(<param><decl><type><name>char</name> **</type><name>str</name></decl></param>, <param><decl><type><name>int</name></type> <name>base</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>char</name> *</type><name>p</name> <init>= <expr>*<name>str</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> *</type><name>start</name> <init>= <expr><name>p</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>bits_per_char</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>n</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyLongObject</name> *</type><name>z</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>twodigits</name></type> <name>accum</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>bits_in_accum</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>digit</name> *</type><name>pdigit</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>base</name> &gt;= 2 &amp;&amp; <name>base</name> &lt;= 32 &amp;&amp; (<name>base</name> &amp; (<name>base</name> - 1)) == 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>n</name> = <name>base</name></expr>;</expr_stmt>
	<for>for (<init><expr><name>bits_per_char</name> = -1</expr>;</init> <condition><expr><name>n</name></expr>;</condition> <incr><expr>++<name>bits_per_char</name></expr></incr>)
		<expr_stmt><expr><name>n</name> &gt;&gt;= 1</expr>;</expr_stmt></for>
	<comment type="block">/* n &lt;- total # of bits needed, while setting p to end-of-string */</comment>
	<expr_stmt><expr><name>n</name> = 0</expr>;</expr_stmt>
	<while>while <condition>(<expr><name><name>_PyLong_DigitValue</name><index>[<expr><call><name>Py_CHARMASK</name><argument_list>(<argument><expr>*<name>p</name></expr></argument>)</argument_list></call></expr>]</index></name> &lt; <name>base</name></expr>)</condition>
		<expr_stmt><expr>++<name>p</name></expr>;</expr_stmt></while>
	<expr_stmt><expr>*<name>str</name> = <name>p</name></expr>;</expr_stmt>
	<comment type="block">/* n &lt;- # of Python digits needed, = ceiling(n/PyLong_SHIFT). */</comment>
	<expr_stmt><expr><name>n</name> = (<name>p</name> - <name>start</name>) * <name>bits_per_char</name> + <name>PyLong_SHIFT</name> - 1</expr>;</expr_stmt>
	<if>if <condition>(<expr><name>n</name> / <name>bits_per_char</name> &lt; <name>p</name> - <name>start</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>,
				<argument><expr>"long string too large to convert"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>
	<expr_stmt><expr><name>n</name> = <name>n</name> / <name>PyLong_SHIFT</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>z</name> = <call><name>_PyLong_New</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>z</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<comment type="block">/* Read string from right, and fill in long from left; i.e.,
	 * from least to most significant in both.
	 */</comment>
	<expr_stmt><expr><name>accum</name> = 0</expr>;</expr_stmt>
	<expr_stmt><expr><name>bits_in_accum</name> = 0</expr>;</expr_stmt>
	<expr_stmt><expr><name>pdigit</name> = <name><name>z</name>-&gt;<name>ob_digit</name></name></expr>;</expr_stmt>
	<while>while <condition>(<expr>--<name>p</name> &gt;= <name>start</name></expr>)</condition> <block>{
		<decl_stmt><decl><type><name>int</name></type> <name>k</name> <init>= <expr><name><name>_PyLong_DigitValue</name><index>[<expr><call><name>Py_CHARMASK</name><argument_list>(<argument><expr>*<name>p</name></expr></argument>)</argument_list></call></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>k</name> &gt;= 0 &amp;&amp; <name>k</name> &lt; <name>base</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>accum</name> |= <call>(<name>twodigits</name>)<argument_list>(<argument><expr><name>k</name> &lt;&lt; <name>bits_in_accum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>bits_in_accum</name> += <name>bits_per_char</name></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>bits_in_accum</name> &gt;= <name>PyLong_SHIFT</name></expr>)</condition><then> <block>{
			<expr_stmt><expr>*<name>pdigit</name>++ = <call>(<name>digit</name>)<argument_list>(<argument><expr><name>accum</name> &amp; <name>PyLong_MASK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>pdigit</name> - <name><name>z</name>-&gt;<name>ob_digit</name></name> &lt;= (<name>int</name>)<name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>accum</name> &gt;&gt;= <name>PyLong_SHIFT</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>bits_in_accum</name> -= <name>PyLong_SHIFT</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>bits_in_accum</name> &lt; <name>PyLong_SHIFT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></then></if>
	}</block></while>
	<if>if <condition>(<expr><name>bits_in_accum</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>bits_in_accum</name> &lt;= <name>PyLong_SHIFT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr>*<name>pdigit</name>++ = (<name>digit</name>)<name>accum</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>pdigit</name> - <name><name>z</name>-&gt;<name>ob_digit</name></name> &lt;= (<name>int</name>)<name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>
	<while>while <condition>(<expr><name>pdigit</name> - <name><name>z</name>-&gt;<name>ob_digit</name></name> &lt; <name>n</name></expr>)</condition>
		<expr_stmt><expr>*<name>pdigit</name>++ = 0</expr>;</expr_stmt></while>
	<return>return <expr><call><name>long_normalize</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>PyObject</name> *</type>
<name>PyLong_FromString</name><parameter_list>(<param><decl><type><name>char</name> *</type><name>str</name></decl></param>, <param><decl><type><name>char</name> **</type><name>pend</name></decl></param>, <param><decl><type><name>int</name></type> <name>base</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>int</name></type> <name>sign</name> <init>= <expr>1</expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> *</type><name>start</name></decl>, *<decl><type ref="prev"/><name>orig_str</name> <init>= <expr><name>str</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyLongObject</name> *</type><name>z</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>strobj</name></decl>, *<decl><type ref="prev"/><name>strrepr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>slen</name></decl>;</decl_stmt>

	<if>if <condition>(<expr>(<name>base</name> != 0 &amp;&amp; <name>base</name> &lt; 2) || <name>base</name> &gt; 36</expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>,
				<argument><expr>"long() arg 2 must be &gt;= 2 and &lt;= 36"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>
	<while>while <condition>(<expr>*<name>str</name> != '\0' &amp;&amp; <call><name>isspace</name><argument_list>(<argument><expr><call><name>Py_CHARMASK</name><argument_list>(<argument><expr>*<name>str</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
		<expr_stmt><expr><name>str</name>++</expr>;</expr_stmt></while>
	<if>if <condition>(<expr>*<name>str</name> == '+'</expr>)</condition><then>
		<expr_stmt><expr>++<name>str</name></expr>;</expr_stmt></then>
	<else>else <if>if <condition>(<expr>*<name>str</name> == '-'</expr>)</condition><then> <block>{
		<expr_stmt><expr>++<name>str</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>sign</name> = -1</expr>;</expr_stmt>
	}</block></then></if></else></if>
	<while>while <condition>(<expr>*<name>str</name> != '\0' &amp;&amp; <call><name>isspace</name><argument_list>(<argument><expr><call><name>Py_CHARMASK</name><argument_list>(<argument><expr>*<name>str</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
		<expr_stmt><expr><name>str</name>++</expr>;</expr_stmt></while>
	<if>if <condition>(<expr><name>base</name> == 0</expr>)</condition><then> <block>{
		<comment type="block">/* No base given.  Deduce the base from the contents
		   of the string */</comment>
		<if>if <condition>(<expr><name><name>str</name><index>[<expr>0</expr>]</index></name> != '0'</expr>)</condition><then>
			<expr_stmt><expr><name>base</name> = 10</expr>;</expr_stmt></then>
		<else>else <if>if <condition>(<expr><name><name>str</name><index>[<expr>1</expr>]</index></name> == 'x' || <name><name>str</name><index>[<expr>1</expr>]</index></name> == 'X'</expr>)</condition><then>
			<expr_stmt><expr><name>base</name> = 16</expr>;</expr_stmt></then>
		<else>else <if>if <condition>(<expr><name><name>str</name><index>[<expr>1</expr>]</index></name> == 'o' || <name><name>str</name><index>[<expr>1</expr>]</index></name> == 'O'</expr>)</condition><then>
			<expr_stmt><expr><name>base</name> = 8</expr>;</expr_stmt></then>
		<else>else <if>if <condition>(<expr><name><name>str</name><index>[<expr>1</expr>]</index></name> == 'b' || <name><name>str</name><index>[<expr>1</expr>]</index></name> == 'B'</expr>)</condition><then>
			<expr_stmt><expr><name>base</name> = 2</expr>;</expr_stmt></then>
		<else>else
			<comment type="block">/* "old" (C-style) octal literal, still valid in
			   2.x, although illegal in 3.x */</comment>
			<expr_stmt><expr><name>base</name> = 8</expr>;</expr_stmt></else></if></else></if></else></if></else></if>
	}</block></then></if>
	<comment type="block">/* Whether or not we were deducing the base, skip leading chars
	   as needed */</comment>
	<if>if <condition>(<expr><name><name>str</name><index>[<expr>0</expr>]</index></name> == '0' &amp;&amp;
	    ((<name>base</name> == 16 &amp;&amp; (<name><name>str</name><index>[<expr>1</expr>]</index></name> == 'x' || <name><name>str</name><index>[<expr>1</expr>]</index></name> == 'X')) ||
	     (<name>base</name> == 8  &amp;&amp; (<name><name>str</name><index>[<expr>1</expr>]</index></name> == 'o' || <name><name>str</name><index>[<expr>1</expr>]</index></name> == 'O')) ||
	     (<name>base</name> == 2  &amp;&amp; (<name><name>str</name><index>[<expr>1</expr>]</index></name> == 'b' || <name><name>str</name><index>[<expr>1</expr>]</index></name> == 'B')))</expr>)</condition><then>
		<expr_stmt><expr><name>str</name> += 2</expr>;</expr_stmt></then></if>

	<expr_stmt><expr><name>start</name> = <name>str</name></expr>;</expr_stmt>
	<if>if <condition>(<expr>(<name>base</name> &amp; (<name>base</name> - 1)) == 0</expr>)</condition><then>
		<expr_stmt><expr><name>z</name> = <call><name>long_from_binary_base</name><argument_list>(<argument><expr>&amp;<name>str</name></expr></argument>, <argument><expr><name>base</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
	<else>else <block>{
<comment type="block">/***
Binary bases can be converted in time linear in the number of digits, because
Python's representation base is binary.  Other bases (including decimal!) use
the simple quadratic-time algorithm below, complicated by some speed tricks.

First some math:  the largest integer that can be expressed in N base-B digits
is B**N-1.  Consequently, if we have an N-digit input in base B, the worst-
case number of Python digits needed to hold it is the smallest integer n s.t.

    PyLong_BASE**n-1 &gt;= B**N-1  [or, adding 1 to both sides]
    PyLong_BASE**n &gt;= B**N      [taking logs to base PyLong_BASE]
    n &gt;= log(B**N)/log(PyLong_BASE) = N * log(B)/log(PyLong_BASE)

The static array log_base_PyLong_BASE[base] == log(base)/log(PyLong_BASE) so we can compute
this quickly.  A Python long with that much space is reserved near the start,
and the result is computed into it.

The input string is actually treated as being in base base**i (i.e., i digits
are processed at a time), where two more static arrays hold:

    convwidth_base[base] = the largest integer i such that base**i &lt;= PyLong_BASE
    convmultmax_base[base] = base ** convwidth_base[base]

The first of these is the largest i such that i consecutive input digits
must fit in a single Python digit.  The second is effectively the input
base we're really using.

Viewing the input as a sequence &lt;c0, c1, ..., c_n-1&gt; of digits in base
convmultmax_base[base], the result is "simply"

   (((c0*B + c1)*B + c2)*B + c3)*B + ... ))) + c_n-1

where B = convmultmax_base[base].

Error analysis:  as above, the number of Python digits `n` needed is worst-
case

    n &gt;= N * log(B)/log(PyLong_BASE)

where `N` is the number of input digits in base `B`.  This is computed via

    size_z = (Py_ssize_t)((scan - str) * log_base_PyLong_BASE[base]) + 1;

below.  Two numeric concerns are how much space this can waste, and whether
the computed result can be too small.  To be concrete, assume PyLong_BASE = 2**15,
which is the default (and it's unlikely anyone changes that).

Waste isn't a problem:  provided the first input digit isn't 0, the difference
between the worst-case input with N digits and the smallest input with N
digits is about a factor of B, but B is small compared to PyLong_BASE so at most
one allocated Python digit can remain unused on that count.  If
N*log(B)/log(PyLong_BASE) is mathematically an exact integer, then truncating that
and adding 1 returns a result 1 larger than necessary.  However, that can't
happen:  whenever B is a power of 2, long_from_binary_base() is called
instead, and it's impossible for B**i to be an integer power of 2**15 when
B is not a power of 2 (i.e., it's impossible for N*log(B)/log(PyLong_BASE) to be
an exact integer when B is not a power of 2, since B**i has a prime factor
other than 2 in that case, but (2**15)**j's only prime factor is 2).

The computed result can be too small if the true value of N*log(B)/log(PyLong_BASE)
is a little bit larger than an exact integer, but due to roundoff errors (in
computing log(B), log(PyLong_BASE), their quotient, and/or multiplying that by N)
yields a numeric result a little less than that integer.  Unfortunately, "how
close can a transcendental function get to an integer over some range?"
questions are generally theoretically intractable.  Computer analysis via
continued fractions is practical:  expand log(B)/log(PyLong_BASE) via continued
fractions, giving a sequence i/j of "the best" rational approximations.  Then
j*log(B)/log(PyLong_BASE) is approximately equal to (the integer) i.  This shows that
we can get very close to being in trouble, but very rarely.  For example,
76573 is a denominator in one of the continued-fraction approximations to
log(10)/log(2**15), and indeed:

    &gt;&gt;&gt; log(10)/log(2**15)*76573
    16958.000000654003

is very close to an integer.  If we were working with IEEE single-precision,
rounding errors could kill us.  Finding worst cases in IEEE double-precision
requires better-than-double-precision log() functions, and Tim didn't bother.
Instead the code checks to see whether the allocated space is enough as each
new Python digit is added, and copies the whole thing to a larger long if not.
This should happen extremely rarely, and in fact I don't have a test case
that triggers it(!).  Instead the code was tested by artificially allocating
just 1 digit at the start, so that the copying code was exercised for every
digit beyond the first.
***/</comment>
		<decl_stmt><decl><type><name>register</name> <name>twodigits</name></type> <name>c</name></decl>;</decl_stmt>	<comment type="block">/* current input character */</comment>
		<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>size_z</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>convwidth</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>twodigits</name></type> <name>convmultmax</name></decl>, <decl><type ref="prev"/><name>convmult</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>digit</name> *</type><name>pz</name></decl>, *<decl><type ref="prev"/><name>pzstop</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>*</type> <name>scan</name></decl>;</decl_stmt>

		<decl_stmt><decl><type><specifier>static</specifier> <name>double</name></type> <name><name>log_base_PyLong_BASE</name><index>[<expr>37</expr>]</index></name> <init>= <expr><block>{<expr>0.0e0</expr>,}</block></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name><name>convwidth_base</name><index>[<expr>37</expr>]</index></name> <init>= <expr><block>{<expr>0</expr>,}</block></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><specifier>static</specifier> <name>twodigits</name></type> <name><name>convmultmax_base</name><index>[<expr>37</expr>]</index></name> <init>= <expr><block>{<expr>0</expr>,}</block></expr></init></decl>;</decl_stmt>

		<if>if <condition>(<expr><name><name>log_base_PyLong_BASE</name><index>[<expr><name>base</name></expr>]</index></name> == 0.0</expr>)</condition><then> <block>{
			<decl_stmt><decl><type><name>twodigits</name></type> <name>convmax</name> <init>= <expr><name>base</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr>1</expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name><name>log_base_PyLong_BASE</name><index>[<expr><name>base</name></expr>]</index></name> = <call><name>log</name><argument_list>(<argument><expr>(<name>double</name>)<name>base</name></expr></argument>)</argument_list></call> /
						<call><name>log</name><argument_list>(<argument><expr>(<name>double</name>)<name>PyLong_BASE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<for>for (<init>;</init><condition>;</condition><incr/>) <block>{
				<decl_stmt><decl><type><name>twodigits</name></type> <name>next</name> <init>= <expr><name>convmax</name> * <name>base</name></expr></init></decl>;</decl_stmt>
				<if>if <condition>(<expr><name>next</name> &gt; <name>PyLong_BASE</name></expr>)</condition><then>
					<break>break;</break></then></if>
				<expr_stmt><expr><name>convmax</name> = <name>next</name></expr>;</expr_stmt>
				<expr_stmt><expr>++<name>i</name></expr>;</expr_stmt>
			}</block></for>
			<expr_stmt><expr><name><name>convmultmax_base</name><index>[<expr><name>base</name></expr>]</index></name> = <name>convmax</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>i</name> &gt; 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>convwidth_base</name><index>[<expr><name>base</name></expr>]</index></name> = <name>i</name></expr>;</expr_stmt>
		}</block></then></if>

		<comment type="block">/* Find length of the string of numeric characters. */</comment>
		<expr_stmt><expr><name>scan</name> = <name>str</name></expr>;</expr_stmt>
		<while>while <condition>(<expr><name><name>_PyLong_DigitValue</name><index>[<expr><call><name>Py_CHARMASK</name><argument_list>(<argument><expr>*<name>scan</name></expr></argument>)</argument_list></call></expr>]</index></name> &lt; <name>base</name></expr>)</condition>
			<expr_stmt><expr>++<name>scan</name></expr>;</expr_stmt></while>

		<comment type="block">/* Create a long object that can contain the largest possible
		 * integer with this base and length.  Note that there's no
		 * need to initialize z-&gt;ob_digit -- no slot is read up before
		 * being stored into.
		 */</comment>
		<expr_stmt><expr><name>size_z</name> = <call>(<name>Py_ssize_t</name>)<argument_list>(<argument><expr>(<name>scan</name> - <name>str</name>) * <name><name>log_base_PyLong_BASE</name><index>[<expr><name>base</name></expr>]</index></name></expr></argument>)</argument_list></call> + 1</expr>;</expr_stmt>
		<comment type="block">/* Uncomment next line to test exceedingly rare copy code */</comment>
		<comment type="block">/* size_z = 1; */</comment>
		<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>size_z</name> &gt; 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>z</name> = <call><name>_PyLong_New</name><argument_list>(<argument><expr><name>size_z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>z</name> == <name>NULL</name></expr>)</condition><then>
			<return>return <expr><name>NULL</name></expr>;</return></then></if>
		<expr_stmt><expr><call><name>Py_SIZE</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call> = 0</expr>;</expr_stmt>

		<comment type="block">/* `convwidth` consecutive input digits are treated as a single
		 * digit in base `convmultmax`.
		 */</comment>
		<expr_stmt><expr><name>convwidth</name> = <name><name>convwidth_base</name><index>[<expr><name>base</name></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>convmultmax</name> = <name><name>convmultmax_base</name><index>[<expr><name>base</name></expr>]</index></name></expr>;</expr_stmt>

		<comment type="block">/* Work ;-) */</comment>
		<while>while <condition>(<expr><name>str</name> &lt; <name>scan</name></expr>)</condition> <block>{
			<comment type="block">/* grab up to convwidth digits from the input string */</comment>
			<expr_stmt><expr><name>c</name> = (<name>digit</name>)<name><name>_PyLong_DigitValue</name><index>[<expr><call><name>Py_CHARMASK</name><argument_list>(<argument><expr>*<name>str</name>++</expr></argument>)</argument_list></call></expr>]</index></name></expr>;</expr_stmt>
			<for>for (<init><expr><name>i</name> = 1</expr>;</init> <condition><expr><name>i</name> &lt; <name>convwidth</name> &amp;&amp; <name>str</name> != <name>scan</name></expr>;</condition> <incr><expr>++<name>i</name></expr>, <expr>++<name>str</name></expr></incr>) <block>{
				<expr_stmt><expr><name>c</name> = <call>(<name>twodigits</name>)<argument_list>(<argument><expr><name>c</name> *  <name>base</name> +
					<name><name>_PyLong_DigitValue</name><index>[<expr><call><name>Py_CHARMASK</name><argument_list>(<argument><expr>*<name>str</name></expr></argument>)</argument_list></call></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>c</name> &lt; <name>PyLong_BASE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			}</block></for>

			<expr_stmt><expr><name>convmult</name> = <name>convmultmax</name></expr>;</expr_stmt>
			<comment type="block">/* Calculate the shift only if we couldn't get
			 * convwidth digits.
			 */</comment>
			<if>if <condition>(<expr><name>i</name> != <name>convwidth</name></expr>)</condition><then> <block>{
				<expr_stmt><expr><name>convmult</name> = <name>base</name></expr>;</expr_stmt>
				<for>for ( <init>;</init> <condition><expr><name>i</name> &gt; 1</expr>;</condition> <incr><expr>--<name>i</name></expr></incr>)
					<expr_stmt><expr><name>convmult</name> *= <name>base</name></expr>;</expr_stmt></for>
			}</block></then></if>

			<comment type="block">/* Multiply z by convmult, and add c. */</comment>
			<expr_stmt><expr><name>pz</name> = <name><name>z</name>-&gt;<name>ob_digit</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name>pzstop</name> = <name>pz</name> + <call><name>Py_SIZE</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<for>for (<init>;</init> <condition><expr><name>pz</name> &lt; <name>pzstop</name></expr>;</condition> <incr><expr>++<name>pz</name></expr></incr>) <block>{
				<expr_stmt><expr><name>c</name> += (<name>twodigits</name>)*<name>pz</name> * <name>convmult</name></expr>;</expr_stmt>
				<expr_stmt><expr>*<name>pz</name> = <call>(<name>digit</name>)<argument_list>(<argument><expr><name>c</name> &amp; <name>PyLong_MASK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>c</name> &gt;&gt;= <name>PyLong_SHIFT</name></expr>;</expr_stmt>
			}</block></for>
			<comment type="block">/* carry off the current end? */</comment>
			<if>if <condition>(<expr><name>c</name></expr>)</condition><then> <block>{
				<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>c</name> &lt; <name>PyLong_BASE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if>if <condition>(<expr><call><name>Py_SIZE</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call> &lt; <name>size_z</name></expr>)</condition><then> <block>{
					<expr_stmt><expr>*<name>pz</name> = (<name>digit</name>)<name>c</name></expr>;</expr_stmt>
					<expr_stmt><expr>++<call><name>Py_SIZE</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				}</block></then>
				<else>else <block>{
					<decl_stmt><decl><type><name>PyLongObject</name> *</type><name>tmp</name></decl>;</decl_stmt>
					<comment type="block">/* Extremely rare.  Get more space. */</comment>
					<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>Py_SIZE</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call> == <name>size_z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>tmp</name> = <call><name>_PyLong_New</name><argument_list>(<argument><expr><name>size_z</name> + 1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if>if <condition>(<expr><name>tmp</name> == <name>NULL</name></expr>)</condition><then> <block>{
						<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<return>return <expr><name>NULL</name></expr>;</return>
					}</block></then></if>
					<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>tmp</name>-&gt;<name>ob_digit</name></name></expr></argument>,
					       <argument><expr><name><name>z</name>-&gt;<name>ob_digit</name></name></expr></argument>,
					       <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>digit</name></expr></argument>)</argument_list></sizeof> * <name>size_z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>z</name> = <name>tmp</name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>z</name>-&gt;<name>ob_digit</name><index>[<expr><name>size_z</name></expr>]</index></name> = (<name>digit</name>)<name>c</name></expr>;</expr_stmt>
					<expr_stmt><expr>++<name>size_z</name></expr>;</expr_stmt>
				}</block></else></if>
			}</block></then></if>
		}</block></while>
	}</block></else></if>
	<if>if <condition>(<expr><name>z</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<if>if <condition>(<expr><name>str</name> == <name>start</name></expr>)</condition><then>
		<goto>goto <name>onError</name>;</goto></then></if>
	<if>if <condition>(<expr><name>sign</name> &lt; 0</expr>)</condition><then>
		<expr_stmt><expr><call><name>Py_SIZE</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call> = -(<call><name>Py_SIZE</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call>)</expr>;</expr_stmt></then></if>
	<if>if <condition>(<expr>*<name>str</name> == 'L' || *<name>str</name> == 'l'</expr>)</condition><then>
		<expr_stmt><expr><name>str</name>++</expr>;</expr_stmt></then></if>
	<while>while <condition>(<expr>*<name>str</name> &amp;&amp; <call><name>isspace</name><argument_list>(<argument><expr><call><name>Py_CHARMASK</name><argument_list>(<argument><expr>*<name>str</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
		<expr_stmt><expr><name>str</name>++</expr>;</expr_stmt></while>
	<if>if <condition>(<expr>*<name>str</name> != '\0'</expr>)</condition><then>
		<goto>goto <name>onError</name>;</goto></then></if>
	<if>if <condition>(<expr><name>pend</name></expr>)</condition><then>
		<expr_stmt><expr>*<name>pend</name> = <name>str</name></expr>;</expr_stmt></then></if>
	<return>return <expr>(<name>PyObject</name> *) <name>z</name></expr>;</return>

 <label><name>onError</name>:</label>
	<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>slen</name> = <call><name>strlen</name><argument_list>(<argument><expr><name>orig_str</name></expr></argument>)</argument_list></call> &lt; 200 ? <call><name>strlen</name><argument_list>(<argument><expr><name>orig_str</name></expr></argument>)</argument_list></call> : 200</expr>;</expr_stmt>
	<expr_stmt><expr><name>strobj</name> = <call><name>PyString_FromStringAndSize</name><argument_list>(<argument><expr><name>orig_str</name></expr></argument>, <argument><expr><name>slen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>strobj</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<expr_stmt><expr><name>strrepr</name> = <call><name>PyObject_Repr</name><argument_list>(<argument><expr><name>strobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>strobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>strrepr</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>,
		     <argument><expr>"invalid literal for long() with base %d: %s"</expr></argument>,
		     <argument><expr><name>base</name></expr></argument>, <argument><expr><call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>strrepr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>strrepr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>NULL</name></expr>;</return>
}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>Py_USING_UNICODE</name></cpp:ifdef>
<function><type><name>PyObject</name> *</type>
<name>PyLong_FromUnicode</name><parameter_list>(<param><decl><type><name>Py_UNICODE</name> *</type><name>u</name></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>length</name></decl></param>, <param><decl><type><name>int</name></type> <name>base</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> *</type><name>buffer</name> <init>= <expr>(<name>char</name> *)<call><name>PyMem_MALLOC</name><argument_list>(<argument><expr><name>length</name>+1</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if>if <condition>(<expr><name>buffer</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>

	<if>if <condition>(<expr><call><name>PyUnicode_EncodeDecimal</name><argument_list>(<argument><expr><name>u</name></expr></argument>, <argument><expr><name>length</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyMem_FREE</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>
	<expr_stmt><expr><name>result</name> = <call><name>PyLong_FromString</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>base</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PyMem_FREE</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>result</name></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* forward */</comment>
<function_decl><type><specifier>static</specifier> <name>PyLongObject</name> *</type><name>x_divrem</name>
	<parameter_list>(<param><decl><type><name>PyLongObject</name> *</type></decl></param>, <param><decl><type><name>PyLongObject</name> *</type></decl></param>, <param><decl><type><name>PyLongObject</name> **</type></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>PyObject</name> *</type><name>long_long</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>v</name></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>long_divrem</name><parameter_list>(<param><decl><type><name>PyLongObject</name> *</type></decl></param>, <param><decl><type><name>PyLongObject</name> *</type></decl></param>,
	<param><decl><type><name>PyLongObject</name> **</type></decl></param>, <param><decl><type><name>PyLongObject</name> **</type></decl></param>)</parameter_list>;</function_decl>

<comment type="block">/* Long division with remainder, top-level routine */</comment>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>long_divrem</name><parameter_list>(<param><decl><type><name>PyLongObject</name> *</type><name>a</name></decl></param>, <param><decl><type><name>PyLongObject</name> *</type><name>b</name></decl></param>,
	    <param><decl><type><name>PyLongObject</name> **</type><name>pdiv</name></decl></param>, <param><decl><type><name>PyLongObject</name> **</type><name>prem</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>size_a</name> <init>= <expr><call><name>ABS</name><argument_list>(<argument><expr><call><name>Py_SIZE</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init>, <name>size_b</name> <init>= <expr><call><name>ABS</name><argument_list>(<argument><expr><call><name>Py_SIZE</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyLongObject</name> *</type><name>z</name></decl>;</decl_stmt>

	<if>if <condition>(<expr><name>size_b</name> == 0</expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ZeroDivisionError</name></expr></argument>,
				<argument><expr>"long division or modulo by zero"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>-1</expr>;</return>
	}</block></then></if>
	<if>if <condition>(<expr><name>size_a</name> &lt; <name>size_b</name> ||
	    (<name>size_a</name> == <name>size_b</name> &amp;&amp;
	     <name><name>a</name>-&gt;<name>ob_digit</name><index>[<expr><name>size_a</name>-1</expr>]</index></name> &lt; <name><name>b</name>-&gt;<name>ob_digit</name><index>[<expr><name>size_b</name>-1</expr>]</index></name>)</expr>)</condition><then> <block>{
		<comment type="block">/* |a| &lt; |b|. */</comment>
		<expr_stmt><expr>*<name>pdiv</name> = <call><name>_PyLong_New</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr>*<name>pdiv</name> == <name>NULL</name></expr>)</condition><then>
			<return>return <expr>-1</expr>;</return></then></if>
		<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr>*<name>prem</name> = (<name>PyLongObject</name> *) <name>a</name></expr>;</expr_stmt>
		<return>return <expr>0</expr>;</return>
	}</block></then></if>
	<if>if <condition>(<expr><name>size_b</name> == 1</expr>)</condition><then> <block>{
		<decl_stmt><decl><type><name>digit</name></type> <name>rem</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name>z</name> = <call><name>divrem1</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name><name>b</name>-&gt;<name>ob_digit</name><index>[<expr>0</expr>]</index></name></expr></argument>, <argument><expr>&amp;<name>rem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>z</name> == <name>NULL</name></expr>)</condition><then>
			<return>return <expr>-1</expr>;</return></then></if>
		<expr_stmt><expr>*<name>prem</name> = (<name>PyLongObject</name> *) <call><name>PyLong_FromLong</name><argument_list>(<argument><expr>(<name>long</name>)<name>rem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr>*<name>prem</name> == <name>NULL</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr>-1</expr>;</return>
		}</block></then></if>
	}</block></then>
	<else>else <block>{
		<expr_stmt><expr><name>z</name> = <call><name>x_divrem</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><name>prem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>z</name> == <name>NULL</name></expr>)</condition><then>
			<return>return <expr>-1</expr>;</return></then></if>
	}</block></else></if>
	<comment type="block">/* Set the signs.
	   The quotient z has the sign of a*b;
	   the remainder r has the sign of a,
	   so a = b*z + r. */</comment>
	<if>if <condition>(<expr>(<name><name>a</name>-&gt;<name>ob_size</name></name> &lt; 0) != (<name><name>b</name>-&gt;<name>ob_size</name></name> &lt; 0)</expr>)</condition><then>
		<expr_stmt><expr><name><name>z</name>-&gt;<name>ob_size</name></name> = -(<name><name>z</name>-&gt;<name>ob_size</name></name>)</expr>;</expr_stmt></then></if>
	<if>if <condition>(<expr><name><name>a</name>-&gt;<name>ob_size</name></name> &lt; 0 &amp;&amp; <name>(*<name>prem</name>)-&gt;<name>ob_size</name></name> != 0</expr>)</condition><then>
		<expr_stmt><expr><name>(*<name>prem</name>)-&gt;<name>ob_size</name></name> = -(<name>(*<name>prem</name>)-&gt;<name>ob_size</name></name>)</expr>;</expr_stmt></then></if>
	<expr_stmt><expr>*<name>pdiv</name> = <name>z</name></expr>;</expr_stmt>
	<return>return <expr>0</expr>;</return>
}</block></function>

<comment type="block">/* Unsigned long division with remainder -- the algorithm */</comment>

<function><type><specifier>static</specifier> <name>PyLongObject</name> *</type>
<name>x_divrem</name><parameter_list>(<param><decl><type><name>PyLongObject</name> *</type><name>v1</name></decl></param>, <param><decl><type><name>PyLongObject</name> *</type><name>w1</name></decl></param>, <param><decl><type><name>PyLongObject</name> **</type><name>prem</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>size_v</name> <init>= <expr><call><name>ABS</name><argument_list>(<argument><expr><call><name>Py_SIZE</name><argument_list>(<argument><expr><name>v1</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init>, <name>size_w</name> <init>= <expr><call><name>ABS</name><argument_list>(<argument><expr><call><name>Py_SIZE</name><argument_list>(<argument><expr><name>w1</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>digit</name></type> <name>d</name> <init>= <expr><call>(<name>digit</name>) <argument_list>(<argument><expr>(<name>twodigits</name>)<name>PyLong_BASE</name> / (<name><name>w1</name>-&gt;<name>ob_digit</name><index>[<expr><name>size_w</name>-1</expr>]</index></name> + 1)</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyLongObject</name> *</type><name>v</name> <init>= <expr><call><name>mul1</name><argument_list>(<argument><expr><name>v1</name></expr></argument>, <argument><expr><name>d</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyLongObject</name> *</type><name>w</name> <init>= <expr><call><name>mul1</name><argument_list>(<argument><expr><name>w1</name></expr></argument>, <argument><expr><name>d</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyLongObject</name> *</type><name>a</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>j</name></decl>, <decl><type ref="prev"/><name>k</name></decl>;</decl_stmt>

	<if>if <condition>(<expr><name>v</name> == <name>NULL</name> || <name>w</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>

	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>size_v</name> &gt;= <name>size_w</name> &amp;&amp; <name>size_w</name> &gt; 1</expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* Assert checks by div() */</comment>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>Py_REFCNT</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call> == 1</expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* Since v will be used as accumulator! */</comment>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>size_w</name> == <call><name>ABS</name><argument_list>(<argument><expr><call><name>Py_SIZE</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* That's how d was calculated */</comment>

	<expr_stmt><expr><name>size_v</name> = <call><name>ABS</name><argument_list>(<argument><expr><call><name>Py_SIZE</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>k</name> = <name>size_v</name> - <name>size_w</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>a</name> = <call><name>_PyLong_New</name><argument_list>(<argument><expr><name>k</name> + 1</expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for (<init><expr><name>j</name> = <name>size_v</name></expr>;</init> <condition><expr><name>a</name> != <name>NULL</name> &amp;&amp; <name>k</name> &gt;= 0</expr>;</condition> <incr><expr>--<name>j</name></expr>, <expr>--<name>k</name></expr></incr>) <block>{
		<decl_stmt><decl><type><name>digit</name></type> <name>vj</name> <init>= <expr>(<name>j</name> &gt;= <name>size_v</name>) ? 0 : <name><name>v</name>-&gt;<name>ob_digit</name><index>[<expr><name>j</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>twodigits</name></type> <name>q</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>stwodigits</name></type> <name>carry</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

		<macro><name>SIGCHECK</name><argument_list>(<argument>{
			Py_DECREF(a);
			a = NULL;
			break;
		}</argument>)</argument_list></macro>
		<if>if <condition>(<expr><name>vj</name> == <name><name>w</name>-&gt;<name>ob_digit</name><index>[<expr><name>size_w</name>-1</expr>]</index></name></expr>)</condition><then>
			<expr_stmt><expr><name>q</name> = <name>PyLong_MASK</name></expr>;</expr_stmt></then>
		<else>else
			<expr_stmt><expr><name>q</name> = (((<name>twodigits</name>)<name>vj</name> &lt;&lt; <name>PyLong_SHIFT</name>) + <name><name>v</name>-&gt;<name>ob_digit</name><index>[<expr><name>j</name>-1</expr>]</index></name>) /
				<name><name>w</name>-&gt;<name>ob_digit</name><index>[<expr><name>size_w</name>-1</expr>]</index></name></expr>;</expr_stmt></else></if>

		<while>while <condition>(<expr><name><name>w</name>-&gt;<name>ob_digit</name><index>[<expr><name>size_w</name>-2</expr>]</index></name>*<name>q</name> &gt;
				((
					((<name>twodigits</name>)<name>vj</name> &lt;&lt; <name>PyLong_SHIFT</name>)
					+ <name><name>v</name>-&gt;<name>ob_digit</name><index>[<expr><name>j</name>-1</expr>]</index></name>
					- <name>q</name>*<name><name>w</name>-&gt;<name>ob_digit</name><index>[<expr><name>size_w</name>-1</expr>]</index></name>
								) &lt;&lt; <name>PyLong_SHIFT</name>)
				+ <name><name>v</name>-&gt;<name>ob_digit</name><index>[<expr><name>j</name>-2</expr>]</index></name></expr>)</condition>
			<expr_stmt><expr>--<name>q</name></expr>;</expr_stmt></while>

		<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>size_w</name> &amp;&amp; <name>i</name>+<name>k</name> &lt; <name>size_v</name></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>) <block>{
			<decl_stmt><decl><type><name>twodigits</name></type> <name>z</name> <init>= <expr><name><name>w</name>-&gt;<name>ob_digit</name><index>[<expr><name>i</name></expr>]</index></name> * <name>q</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>digit</name></type> <name>zz</name> <init>= <expr><call>(<name>digit</name>) <argument_list>(<argument><expr><name>z</name> &gt;&gt; <name>PyLong_SHIFT</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><name>carry</name> += <name><name>v</name>-&gt;<name>ob_digit</name><index>[<expr><name>i</name>+<name>k</name></expr>]</index></name> - <name>z</name>
				+ ((<name>twodigits</name>)<name>zz</name> &lt;&lt; <name>PyLong_SHIFT</name>)</expr>;</expr_stmt>
			<expr_stmt><expr><name><name>v</name>-&gt;<name>ob_digit</name><index>[<expr><name>i</name>+<name>k</name></expr>]</index></name> = <call>(<name>digit</name>)<argument_list>(<argument><expr><name>carry</name> &amp; <name>PyLong_MASK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>carry</name> = <call><name>Py_ARITHMETIC_RIGHT_SHIFT</name><argument_list>(<argument><expr><name>PyLong_BASE_TWODIGITS_TYPE</name></expr></argument>,
							  <argument><expr><name>carry</name></expr></argument>, <argument><expr><name>PyLong_SHIFT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>carry</name> -= <name>zz</name></expr>;</expr_stmt>
		}</block></for>

		<if>if <condition>(<expr><name>i</name>+<name>k</name> &lt; <name>size_v</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><name>carry</name> += <name><name>v</name>-&gt;<name>ob_digit</name><index>[<expr><name>i</name>+<name>k</name></expr>]</index></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>v</name>-&gt;<name>ob_digit</name><index>[<expr><name>i</name>+<name>k</name></expr>]</index></name> = 0</expr>;</expr_stmt>
		}</block></then></if>

		<if>if <condition>(<expr><name>carry</name> == 0</expr>)</condition><then>
			<expr_stmt><expr><name><name>a</name>-&gt;<name>ob_digit</name><index>[<expr><name>k</name></expr>]</index></name> = (<name>digit</name>) <name>q</name></expr>;</expr_stmt></then>
		<else>else <block>{
			<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>carry</name> == -1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>a</name>-&gt;<name>ob_digit</name><index>[<expr><name>k</name></expr>]</index></name> = (<name>digit</name>) <name>q</name>-1</expr>;</expr_stmt>
			<expr_stmt><expr><name>carry</name> = 0</expr>;</expr_stmt>
			<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>size_w</name> &amp;&amp; <name>i</name>+<name>k</name> &lt; <name>size_v</name></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>) <block>{
				<expr_stmt><expr><name>carry</name> += <name><name>v</name>-&gt;<name>ob_digit</name><index>[<expr><name>i</name>+<name>k</name></expr>]</index></name> + <name><name>w</name>-&gt;<name>ob_digit</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>v</name>-&gt;<name>ob_digit</name><index>[<expr><name>i</name>+<name>k</name></expr>]</index></name> = <call>(<name>digit</name>)<argument_list>(<argument><expr><name>carry</name> &amp; <name>PyLong_MASK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>carry</name> = <call><name>Py_ARITHMETIC_RIGHT_SHIFT</name><argument_list>(
						<argument><expr><name>PyLong_BASE_TWODIGITS_TYPE</name></expr></argument>,
						<argument><expr><name>carry</name></expr></argument>, <argument><expr><name>PyLong_SHIFT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			}</block></for>
		}</block></else></if>
	}</block></for> <comment type="block">/* for j, k */</comment>

	<if>if <condition>(<expr><name>a</name> == <name>NULL</name></expr>)</condition><then>
		<expr_stmt><expr>*<name>prem</name> = <name>NULL</name></expr>;</expr_stmt></then>
	<else>else <block>{
		<expr_stmt><expr><name>a</name> = <call><name>long_normalize</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr>*<name>prem</name> = <call><name>divrem1</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>d</name></expr></argument>, <argument><expr>&amp;<name>d</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* d receives the (unused) remainder */</comment>
		<if>if <condition>(<expr>*<name>prem</name> == <name>NULL</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>a</name> = <name>NULL</name></expr>;</expr_stmt>
		}</block></then></if>
	}</block></else></if>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>a</name></expr>;</return>
}</block></function>

<comment type="block">/* Methods */</comment>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>long_dealloc</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>v</name></decl></param>)</parameter_list>
<block>{
	<expr_stmt><expr><call><name>Py_TYPE</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call>-&gt;<call><name>tp_free</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>long_repr</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>v</name></decl></param>)</parameter_list>
<block>{
	<return>return <expr><call><name>_PyLong_Format</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr>10</expr></argument>, <argument><expr>1</expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>long_str</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>v</name></decl></param>)</parameter_list>
<block>{
	<return>return <expr><call><name>_PyLong_Format</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr>10</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>long_compare</name><parameter_list>(<param><decl><type><name>PyLongObject</name> *</type><name>a</name></decl></param>, <param><decl><type><name>PyLongObject</name> *</type><name>b</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>sign</name></decl>;</decl_stmt>

	<if>if <condition>(<expr><call><name>Py_SIZE</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call> != <call><name>Py_SIZE</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<if>if <condition>(<expr><call><name>ABS</name><argument_list>(<argument><expr><call><name>Py_SIZE</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> == 0 &amp;&amp; <call><name>ABS</name><argument_list>(<argument><expr><call><name>Py_SIZE</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> == 0</expr>)</condition><then>
			<expr_stmt><expr><name>sign</name> = 0</expr>;</expr_stmt></then>
		<else>else
			<expr_stmt><expr><name>sign</name> = <call><name>Py_SIZE</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call> - <call><name>Py_SIZE</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
	}</block></then>
	<else>else <block>{
		<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>i</name> <init>= <expr><call><name>ABS</name><argument_list>(<argument><expr><call><name>Py_SIZE</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<while>while <condition>(<expr>--<name>i</name> &gt;= 0 &amp;&amp; <name><name>a</name>-&gt;<name>ob_digit</name><index>[<expr><name>i</name></expr>]</index></name> == <name><name>b</name>-&gt;<name>ob_digit</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition>
			<empty_stmt>;</empty_stmt></while>
		<if>if <condition>(<expr><name>i</name> &lt; 0</expr>)</condition><then>
			<expr_stmt><expr><name>sign</name> = 0</expr>;</expr_stmt></then>
		<else>else <block>{
			<expr_stmt><expr><name>sign</name> = (<name>int</name>)<name><name>a</name>-&gt;<name>ob_digit</name><index>[<expr><name>i</name></expr>]</index></name> - (<name>int</name>)<name><name>b</name>-&gt;<name>ob_digit</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
			<if>if <condition>(<expr><call><name>Py_SIZE</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
				<expr_stmt><expr><name>sign</name> = -<name>sign</name></expr>;</expr_stmt></then></if>
		}</block></else></if>
	}</block></else></if>
	<return>return <expr><name>sign</name> &lt; 0 ? -1 : <name>sign</name> &gt; 0 ? 1 : 0</expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>long</name></type>
<name>long_hash</name><parameter_list>(<param><decl><type><name>PyLongObject</name> *</type><name>v</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>long</name></type> <name>x</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>sign</name></decl>;</decl_stmt>

	<comment type="block">/* This is designed so that Python ints and longs with the
	   same value hash to the same value, otherwise comparisons
	   of mapping keys will turn out weird */</comment>
	<expr_stmt><expr><name>i</name> = <name><name>v</name>-&gt;<name>ob_size</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>sign</name> = 1</expr>;</expr_stmt>
	<expr_stmt><expr><name>x</name> = 0</expr>;</expr_stmt>
	<if>if <condition>(<expr><name>i</name> &lt; 0</expr>)</condition><then> <block>{
		<expr_stmt><expr><name>sign</name> = -1</expr>;</expr_stmt>
		<expr_stmt><expr><name>i</name> = -(<name>i</name>)</expr>;</expr_stmt>
	}</block></then></if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LONG_BIT_PyLong_SHIFT</name></cpp:macro>	<cpp:value>(8*sizeof(long) - PyLong_SHIFT)</cpp:value></cpp:define>
	<comment type="block">/* The following loop produces a C long x such that (unsigned long)x
	   is congruent to the absolute value of v modulo ULONG_MAX.  The
	   resulting x is nonzero if and only if v is. */</comment>
	<while>while <condition>(<expr>--<name>i</name> &gt;= 0</expr>)</condition> <block>{
		<comment type="block">/* Force a native long #-bits (32 or 64) circular shift */</comment>
		<expr_stmt><expr><name>x</name> = ((<name>x</name> &lt;&lt; <name>PyLong_SHIFT</name>) &amp; ~<name>PyLong_MASK</name>) | ((<name>x</name> &gt;&gt; <name>LONG_BIT_PyLong_SHIFT</name>) &amp; <name>PyLong_MASK</name>)</expr>;</expr_stmt>
		<expr_stmt><expr><name>x</name> += <name><name>v</name>-&gt;<name>ob_digit</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
		<comment type="block">/* If the addition above overflowed (thinking of x as
		   unsigned), we compensate by incrementing.  This preserves
		   the value modulo ULONG_MAX. */</comment>
		<if>if <condition>(<expr>(<name>unsigned</name> <name>long</name>)<name>x</name> &lt; <name><name>v</name>-&gt;<name>ob_digit</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><then>
			<expr_stmt><expr><name>x</name>++</expr>;</expr_stmt></then></if>
	}</block></while>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>LONG_BIT_PyLong_SHIFT</name></cpp:undef>
	<expr_stmt><expr><name>x</name> = <name>x</name> * <name>sign</name></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>x</name> == -1</expr>)</condition><then>
		<expr_stmt><expr><name>x</name> = -2</expr>;</expr_stmt></then></if>
	<return>return <expr><name>x</name></expr>;</return>
}</block></function>


<comment type="block">/* Add the absolute values of two long integers. */</comment>

<function><type><specifier>static</specifier> <name>PyLongObject</name> *</type>
<name>x_add</name><parameter_list>(<param><decl><type><name>PyLongObject</name> *</type><name>a</name></decl></param>, <param><decl><type><name>PyLongObject</name> *</type><name>b</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>size_a</name> <init>= <expr><call><name>ABS</name><argument_list>(<argument><expr><call><name>Py_SIZE</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init>, <name>size_b</name> <init>= <expr><call><name>ABS</name><argument_list>(<argument><expr><call><name>Py_SIZE</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyLongObject</name> *</type><name>z</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>digit</name></type> <name>carry</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>

	<comment type="block">/* Ensure a is the larger of the two: */</comment>
	<if>if <condition>(<expr><name>size_a</name> &lt; <name>size_b</name></expr>)</condition><then> <block>{
		<block>{ <decl_stmt><decl><type><name>PyLongObject</name> *</type><name>temp</name> <init>= <expr><name>a</name></expr></init></decl>;</decl_stmt> <expr_stmt><expr><name>a</name> = <name>b</name></expr>;</expr_stmt> <expr_stmt><expr><name>b</name> = <name>temp</name></expr>;</expr_stmt> }</block>
		<block>{ <decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>size_temp</name> <init>= <expr><name>size_a</name></expr></init></decl>;</decl_stmt>
		  <expr_stmt><expr><name>size_a</name> = <name>size_b</name></expr>;</expr_stmt>
		  <expr_stmt><expr><name>size_b</name> = <name>size_temp</name></expr>;</expr_stmt> }</block>
	}</block></then></if>
	<expr_stmt><expr><name>z</name> = <call><name>_PyLong_New</name><argument_list>(<argument><expr><name>size_a</name>+1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>z</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>size_b</name></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>) <block>{
		<expr_stmt><expr><name>carry</name> += <name><name>a</name>-&gt;<name>ob_digit</name><index>[<expr><name>i</name></expr>]</index></name> + <name><name>b</name>-&gt;<name>ob_digit</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>z</name>-&gt;<name>ob_digit</name><index>[<expr><name>i</name></expr>]</index></name> = <name>carry</name> &amp; <name>PyLong_MASK</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>carry</name> &gt;&gt;= <name>PyLong_SHIFT</name></expr>;</expr_stmt>
	}</block></for>
	<for>for (<init>;</init> <condition><expr><name>i</name> &lt; <name>size_a</name></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>) <block>{
		<expr_stmt><expr><name>carry</name> += <name><name>a</name>-&gt;<name>ob_digit</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>z</name>-&gt;<name>ob_digit</name><index>[<expr><name>i</name></expr>]</index></name> = <name>carry</name> &amp; <name>PyLong_MASK</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>carry</name> &gt;&gt;= <name>PyLong_SHIFT</name></expr>;</expr_stmt>
	}</block></for>
	<expr_stmt><expr><name><name>z</name>-&gt;<name>ob_digit</name><index>[<expr><name>i</name></expr>]</index></name> = <name>carry</name></expr>;</expr_stmt>
	<return>return <expr><call><name>long_normalize</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<comment type="block">/* Subtract the absolute values of two integers. */</comment>

<function><type><specifier>static</specifier> <name>PyLongObject</name> *</type>
<name>x_sub</name><parameter_list>(<param><decl><type><name>PyLongObject</name> *</type><name>a</name></decl></param>, <param><decl><type><name>PyLongObject</name> *</type><name>b</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>size_a</name> <init>= <expr><call><name>ABS</name><argument_list>(<argument><expr><call><name>Py_SIZE</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init>, <name>size_b</name> <init>= <expr><call><name>ABS</name><argument_list>(<argument><expr><call><name>Py_SIZE</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyLongObject</name> *</type><name>z</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>sign</name> <init>= <expr>1</expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>digit</name></type> <name>borrow</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>

	<comment type="block">/* Ensure a is the larger of the two: */</comment>
	<if>if <condition>(<expr><name>size_a</name> &lt; <name>size_b</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>sign</name> = -1</expr>;</expr_stmt>
		<block>{ <decl_stmt><decl><type><name>PyLongObject</name> *</type><name>temp</name> <init>= <expr><name>a</name></expr></init></decl>;</decl_stmt> <expr_stmt><expr><name>a</name> = <name>b</name></expr>;</expr_stmt> <expr_stmt><expr><name>b</name> = <name>temp</name></expr>;</expr_stmt> }</block>
		<block>{ <decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>size_temp</name> <init>= <expr><name>size_a</name></expr></init></decl>;</decl_stmt>
		  <expr_stmt><expr><name>size_a</name> = <name>size_b</name></expr>;</expr_stmt>
		  <expr_stmt><expr><name>size_b</name> = <name>size_temp</name></expr>;</expr_stmt> }</block>
	}</block></then>
	<else>else <if>if <condition>(<expr><name>size_a</name> == <name>size_b</name></expr>)</condition><then> <block>{
		<comment type="block">/* Find highest digit where a and b differ: */</comment>
		<expr_stmt><expr><name>i</name> = <name>size_a</name></expr>;</expr_stmt>
		<while>while <condition>(<expr>--<name>i</name> &gt;= 0 &amp;&amp; <name><name>a</name>-&gt;<name>ob_digit</name><index>[<expr><name>i</name></expr>]</index></name> == <name><name>b</name>-&gt;<name>ob_digit</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition>
			<empty_stmt>;</empty_stmt></while>
		<if>if <condition>(<expr><name>i</name> &lt; 0</expr>)</condition><then>
			<return>return <expr><call><name>_PyLong_New</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</return></then></if>
		<if>if <condition>(<expr><name><name>a</name>-&gt;<name>ob_digit</name><index>[<expr><name>i</name></expr>]</index></name> &lt; <name><name>b</name>-&gt;<name>ob_digit</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><then> <block>{
			<expr_stmt><expr><name>sign</name> = -1</expr>;</expr_stmt>
			<block>{ <decl_stmt><decl><type><name>PyLongObject</name> *</type><name>temp</name> <init>= <expr><name>a</name></expr></init></decl>;</decl_stmt> <expr_stmt><expr><name>a</name> = <name>b</name></expr>;</expr_stmt> <expr_stmt><expr><name>b</name> = <name>temp</name></expr>;</expr_stmt> }</block>
		}</block></then></if>
		<expr_stmt><expr><name>size_a</name> = <name>size_b</name> = <name>i</name>+1</expr>;</expr_stmt>
	}</block></then></if></else></if>
	<expr_stmt><expr><name>z</name> = <call><name>_PyLong_New</name><argument_list>(<argument><expr><name>size_a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>z</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>size_b</name></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>) <block>{
		<comment type="block">/* The following assumes unsigned arithmetic
		   works module 2**N for some N&gt;PyLong_SHIFT. */</comment>
		<expr_stmt><expr><name>borrow</name> = <name><name>a</name>-&gt;<name>ob_digit</name><index>[<expr><name>i</name></expr>]</index></name> - <name><name>b</name>-&gt;<name>ob_digit</name><index>[<expr><name>i</name></expr>]</index></name> - <name>borrow</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>z</name>-&gt;<name>ob_digit</name><index>[<expr><name>i</name></expr>]</index></name> = <name>borrow</name> &amp; <name>PyLong_MASK</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>borrow</name> &gt;&gt;= <name>PyLong_SHIFT</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>borrow</name> &amp;= 1</expr>;</expr_stmt> <comment type="block">/* Keep only one sign bit */</comment>
	}</block></for>
	<for>for (<init>;</init> <condition><expr><name>i</name> &lt; <name>size_a</name></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>) <block>{
		<expr_stmt><expr><name>borrow</name> = <name><name>a</name>-&gt;<name>ob_digit</name><index>[<expr><name>i</name></expr>]</index></name> - <name>borrow</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>z</name>-&gt;<name>ob_digit</name><index>[<expr><name>i</name></expr>]</index></name> = <name>borrow</name> &amp; <name>PyLong_MASK</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>borrow</name> &gt;&gt;= <name>PyLong_SHIFT</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>borrow</name> &amp;= 1</expr>;</expr_stmt> <comment type="block">/* Keep only one sign bit */</comment>
	}</block></for>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>borrow</name> == 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>sign</name> &lt; 0</expr>)</condition><then>
		<expr_stmt><expr><name><name>z</name>-&gt;<name>ob_size</name></name> = -(<name><name>z</name>-&gt;<name>ob_size</name></name>)</expr>;</expr_stmt></then></if>
	<return>return <expr><call><name>long_normalize</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>long_add</name><parameter_list>(<param><decl><type><name>PyLongObject</name> *</type><name>v</name></decl></param>, <param><decl><type><name>PyLongObject</name> *</type><name>w</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyLongObject</name> *</type><name>a</name></decl>, *<decl><type ref="prev"/><name>b</name></decl>, *<decl><type ref="prev"/><name>z</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>CONVERT_BINOP</name><argument_list>(<argument><expr>(<name>PyObject</name> *)<name>v</name></expr></argument>, <argument><expr>(<name>PyObject</name> *)<name>w</name></expr></argument>, <argument><expr>&amp;<name>a</name></expr></argument>, <argument><expr>&amp;<name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if>if <condition>(<expr><name><name>a</name>-&gt;<name>ob_size</name></name> &lt; 0</expr>)</condition><then> <block>{
		<if>if <condition>(<expr><name><name>b</name>-&gt;<name>ob_size</name></name> &lt; 0</expr>)</condition><then> <block>{
			<expr_stmt><expr><name>z</name> = <call><name>x_add</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><name>z</name> != <name>NULL</name> &amp;&amp; <name><name>z</name>-&gt;<name>ob_size</name></name> != 0</expr>)</condition><then>
				<expr_stmt><expr><name><name>z</name>-&gt;<name>ob_size</name></name> = -(<name><name>z</name>-&gt;<name>ob_size</name></name>)</expr>;</expr_stmt></then></if>
		}</block></then>
		<else>else
			<expr_stmt><expr><name>z</name> = <call><name>x_sub</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
	}</block></then>
	<else>else <block>{
		<if>if <condition>(<expr><name><name>b</name>-&gt;<name>ob_size</name></name> &lt; 0</expr>)</condition><then>
			<expr_stmt><expr><name>z</name> = <call><name>x_sub</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
		<else>else
			<expr_stmt><expr><name>z</name> = <call><name>x_add</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
	}</block></else></if>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr>(<name>PyObject</name> *)<name>z</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>long_sub</name><parameter_list>(<param><decl><type><name>PyLongObject</name> *</type><name>v</name></decl></param>, <param><decl><type><name>PyLongObject</name> *</type><name>w</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyLongObject</name> *</type><name>a</name></decl>, *<decl><type ref="prev"/><name>b</name></decl>, *<decl><type ref="prev"/><name>z</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>CONVERT_BINOP</name><argument_list>(<argument><expr>(<name>PyObject</name> *)<name>v</name></expr></argument>, <argument><expr>(<name>PyObject</name> *)<name>w</name></expr></argument>, <argument><expr>&amp;<name>a</name></expr></argument>, <argument><expr>&amp;<name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if>if <condition>(<expr><name><name>a</name>-&gt;<name>ob_size</name></name> &lt; 0</expr>)</condition><then> <block>{
		<if>if <condition>(<expr><name><name>b</name>-&gt;<name>ob_size</name></name> &lt; 0</expr>)</condition><then>
			<expr_stmt><expr><name>z</name> = <call><name>x_sub</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
		<else>else
			<expr_stmt><expr><name>z</name> = <call><name>x_add</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
		<if>if <condition>(<expr><name>z</name> != <name>NULL</name> &amp;&amp; <name><name>z</name>-&gt;<name>ob_size</name></name> != 0</expr>)</condition><then>
			<expr_stmt><expr><name><name>z</name>-&gt;<name>ob_size</name></name> = -(<name><name>z</name>-&gt;<name>ob_size</name></name>)</expr>;</expr_stmt></then></if>
	}</block></then>
	<else>else <block>{
		<if>if <condition>(<expr><name><name>b</name>-&gt;<name>ob_size</name></name> &lt; 0</expr>)</condition><then>
			<expr_stmt><expr><name>z</name> = <call><name>x_add</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
		<else>else
			<expr_stmt><expr><name>z</name> = <call><name>x_sub</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
	}</block></else></if>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr>(<name>PyObject</name> *)<name>z</name></expr>;</return>
}</block></function>

<comment type="block">/* Grade school multiplication, ignoring the signs.
 * Returns the absolute value of the product, or NULL if error.
 */</comment>
<function><type><specifier>static</specifier> <name>PyLongObject</name> *</type>
<name>x_mul</name><parameter_list>(<param><decl><type><name>PyLongObject</name> *</type><name>a</name></decl></param>, <param><decl><type><name>PyLongObject</name> *</type><name>b</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyLongObject</name> *</type><name>z</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>size_a</name> <init>= <expr><call><name>ABS</name><argument_list>(<argument><expr><call><name>Py_SIZE</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>size_b</name> <init>= <expr><call><name>ABS</name><argument_list>(<argument><expr><call><name>Py_SIZE</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>i</name></decl>;</decl_stmt>

     	<expr_stmt><expr><name>z</name> = <call><name>_PyLong_New</name><argument_list>(<argument><expr><name>size_a</name> + <name>size_b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>z</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>

	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>z</name>-&gt;<name>ob_digit</name></name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><call><name>Py_SIZE</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call> * <sizeof>sizeof<argument_list>(<argument><expr><name>digit</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>a</name> == <name>b</name></expr>)</condition><then> <block>{
		<comment type="block">/* Efficient squaring per HAC, Algorithm 14.16:
		 * http://www.cacr.math.uwaterloo.ca/hac/about/chap14.pdf
		 * Gives slightly less than a 2x speedup when a == b,
		 * via exploiting that each entry in the multiplication
		 * pyramid appears twice (except for the size_a squares).
		 */</comment>
		<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>size_a</name></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>) <block>{
			<decl_stmt><decl><type><name>twodigits</name></type> <name>carry</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>twodigits</name></type> <name>f</name> <init>= <expr><name><name>a</name>-&gt;<name>ob_digit</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>digit</name> *</type><name>pz</name> <init>= <expr><name><name>z</name>-&gt;<name>ob_digit</name></name> + (<name>i</name> &lt;&lt; 1)</expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>digit</name> *</type><name>pa</name> <init>= <expr><name><name>a</name>-&gt;<name>ob_digit</name></name> + <name>i</name> + 1</expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>digit</name> *</type><name>paend</name> <init>= <expr><name><name>a</name>-&gt;<name>ob_digit</name></name> + <name>size_a</name></expr></init></decl>;</decl_stmt>

			<macro><name>SIGCHECK</name><argument_list>(<argument>{
				Py_DECREF(z);
				return NULL;
			}</argument>)</argument_list></macro>

			<expr_stmt><expr><name>carry</name> = *<name>pz</name> + <name>f</name> * <name>f</name></expr>;</expr_stmt>
			<expr_stmt><expr>*<name>pz</name>++ = <call>(<name>digit</name>)<argument_list>(<argument><expr><name>carry</name> &amp; <name>PyLong_MASK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>carry</name> &gt;&gt;= <name>PyLong_SHIFT</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>carry</name> &lt;= <name>PyLong_MASK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* Now f is added in twice in each column of the
			 * pyramid it appears.  Same as adding f&lt;&lt;1 once.
			 */</comment>
			<expr_stmt><expr><name>f</name> &lt;&lt;= 1</expr>;</expr_stmt>
			<while>while <condition>(<expr><name>pa</name> &lt; <name>paend</name></expr>)</condition> <block>{
				<expr_stmt><expr><name>carry</name> += *<name>pz</name> + *<name>pa</name>++ * <name>f</name></expr>;</expr_stmt>
				<expr_stmt><expr>*<name>pz</name>++ = <call>(<name>digit</name>)<argument_list>(<argument><expr><name>carry</name> &amp; <name>PyLong_MASK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>carry</name> &gt;&gt;= <name>PyLong_SHIFT</name></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>carry</name> &lt;= (<name>PyLong_MASK</name> &lt;&lt; 1)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
			}</block></while>
			<if>if <condition>(<expr><name>carry</name></expr>)</condition><then> <block>{
				<expr_stmt><expr><name>carry</name> += *<name>pz</name></expr>;</expr_stmt>
				<expr_stmt><expr>*<name>pz</name>++ = <call>(<name>digit</name>)<argument_list>(<argument><expr><name>carry</name> &amp; <name>PyLong_MASK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>carry</name> &gt;&gt;= <name>PyLong_SHIFT</name></expr>;</expr_stmt>
			}</block></then></if>
			<if>if <condition>(<expr><name>carry</name></expr>)</condition><then>
				<expr_stmt><expr>*<name>pz</name> += <call>(<name>digit</name>)<argument_list>(<argument><expr><name>carry</name> &amp; <name>PyLong_MASK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
			<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr>(<name>carry</name> &gt;&gt; <name>PyLong_SHIFT</name>) == 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></for>
	}</block></then>
	<else>else <block>{	<comment type="block">/* a is not the same as b -- gradeschool long mult */</comment>
		<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>size_a</name></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>) <block>{
			<decl_stmt><decl><type><name>twodigits</name></type> <name>carry</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>twodigits</name></type> <name>f</name> <init>= <expr><name><name>a</name>-&gt;<name>ob_digit</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>digit</name> *</type><name>pz</name> <init>= <expr><name><name>z</name>-&gt;<name>ob_digit</name></name> + <name>i</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>digit</name> *</type><name>pb</name> <init>= <expr><name><name>b</name>-&gt;<name>ob_digit</name></name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>digit</name> *</type><name>pbend</name> <init>= <expr><name><name>b</name>-&gt;<name>ob_digit</name></name> + <name>size_b</name></expr></init></decl>;</decl_stmt>

			<macro><name>SIGCHECK</name><argument_list>(<argument>{
				Py_DECREF(z);
				return NULL;
			}</argument>)</argument_list></macro>

			<while>while <condition>(<expr><name>pb</name> &lt; <name>pbend</name></expr>)</condition> <block>{
				<expr_stmt><expr><name>carry</name> += *<name>pz</name> + *<name>pb</name>++ * <name>f</name></expr>;</expr_stmt>
				<expr_stmt><expr>*<name>pz</name>++ = <call>(<name>digit</name>)<argument_list>(<argument><expr><name>carry</name> &amp; <name>PyLong_MASK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>carry</name> &gt;&gt;= <name>PyLong_SHIFT</name></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>carry</name> &lt;= <name>PyLong_MASK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			}</block></while>
			<if>if <condition>(<expr><name>carry</name></expr>)</condition><then>
				<expr_stmt><expr>*<name>pz</name> += <call>(<name>digit</name>)<argument_list>(<argument><expr><name>carry</name> &amp; <name>PyLong_MASK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
			<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr>(<name>carry</name> &gt;&gt; <name>PyLong_SHIFT</name>) == 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></for>
	}</block></else></if>
	<return>return <expr><call><name>long_normalize</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<comment type="block">/* A helper for Karatsuba multiplication (k_mul).
   Takes a long "n" and an integer "size" representing the place to
   split, and sets low and high such that abs(n) == (high &lt;&lt; size) + low,
   viewing the shift as being by digits.  The sign bit is ignored, and
   the return values are &gt;= 0.
   Returns 0 on success, -1 on failure.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>kmul_split</name><parameter_list>(<param><decl><type><name>PyLongObject</name> *</type><name>n</name></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>size</name></decl></param>, <param><decl><type><name>PyLongObject</name> **</type><name>high</name></decl></param>, <param><decl><type><name>PyLongObject</name> **</type><name>low</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyLongObject</name> *</type><name>hi</name></decl>, *<decl><type ref="prev"/><name>lo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>size_lo</name></decl>, <decl><type ref="prev"/><name>size_hi</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>Py_ssize_t</name></type> <name>size_n</name> <init>= <expr><call><name>ABS</name><argument_list>(<argument><expr><call><name>Py_SIZE</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>size_lo</name> = <call><name>MIN</name><argument_list>(<argument><expr><name>size_n</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>size_hi</name> = <name>size_n</name> - <name>size_lo</name></expr>;</expr_stmt>

	<if>if <condition>(<expr>(<name>hi</name> = <call><name>_PyLong_New</name><argument_list>(<argument><expr><name>size_hi</name></expr></argument>)</argument_list></call>) == <name>NULL</name></expr>)</condition><then>
		<return>return <expr>-1</expr>;</return></then></if>
	<if>if <condition>(<expr>(<name>lo</name> = <call><name>_PyLong_New</name><argument_list>(<argument><expr><name>size_lo</name></expr></argument>)</argument_list></call>) == <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>hi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>-1</expr>;</return>
	}</block></then></if>

	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>lo</name>-&gt;<name>ob_digit</name></name></expr></argument>, <argument><expr><name><name>n</name>-&gt;<name>ob_digit</name></name></expr></argument>, <argument><expr><name>size_lo</name> * <sizeof>sizeof<argument_list>(<argument><expr><name>digit</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>hi</name>-&gt;<name>ob_digit</name></name></expr></argument>, <argument><expr><name><name>n</name>-&gt;<name>ob_digit</name></name> + <name>size_lo</name></expr></argument>, <argument><expr><name>size_hi</name> * <sizeof>sizeof<argument_list>(<argument><expr><name>digit</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr>*<name>high</name> = <call><name>long_normalize</name><argument_list>(<argument><expr><name>hi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr>*<name>low</name> = <call><name>long_normalize</name><argument_list>(<argument><expr><name>lo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr>0</expr>;</return>
}</block></function>

<function_decl><type><specifier>static</specifier> <name>PyLongObject</name> *</type><name>k_lopsided_mul</name><parameter_list>(<param><decl><type><name>PyLongObject</name> *</type><name>a</name></decl></param>, <param><decl><type><name>PyLongObject</name> *</type><name>b</name></decl></param>)</parameter_list>;</function_decl>

<comment type="block">/* Karatsuba multiplication.  Ignores the input signs, and returns the
 * absolute value of the product (or NULL if error).
 * See Knuth Vol. 2 Chapter 4.3.3 (Pp. 294-295).
 */</comment>
<function><type><specifier>static</specifier> <name>PyLongObject</name> *</type>
<name>k_mul</name><parameter_list>(<param><decl><type><name>PyLongObject</name> *</type><name>a</name></decl></param>, <param><decl><type><name>PyLongObject</name> *</type><name>b</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>asize</name> <init>= <expr><call><name>ABS</name><argument_list>(<argument><expr><call><name>Py_SIZE</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>bsize</name> <init>= <expr><call><name>ABS</name><argument_list>(<argument><expr><call><name>Py_SIZE</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyLongObject</name> *</type><name>ah</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyLongObject</name> *</type><name>al</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyLongObject</name> *</type><name>bh</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyLongObject</name> *</type><name>bl</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyLongObject</name> *</type><name>ret</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyLongObject</name> *</type><name>t1</name></decl>, *<decl><type ref="prev"/><name>t2</name></decl>, *<decl><type ref="prev"/><name>t3</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>shift</name></decl>;</decl_stmt>	<comment type="block">/* the number of digits we split off */</comment>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>i</name></decl>;</decl_stmt>

	<comment type="block">/* (ah*X+al)(bh*X+bl) = ah*bh*X*X + (ah*bl + al*bh)*X + al*bl
	 * Let k = (ah+al)*(bh+bl) = ah*bl + al*bh  + ah*bh + al*bl
	 * Then the original product is
	 *     ah*bh*X*X + (k - ah*bh - al*bl)*X + al*bl
	 * By picking X to be a power of 2, "*X" is just shifting, and it's
	 * been reduced to 3 multiplies on numbers half the size.
	 */</comment>

	<comment type="block">/* We want to split based on the larger number; fiddle so that b
	 * is largest.
	 */</comment>
	<if>if <condition>(<expr><name>asize</name> &gt; <name>bsize</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>t1</name> = <name>a</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>a</name> = <name>b</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>b</name> = <name>t1</name></expr>;</expr_stmt>

		<expr_stmt><expr><name>i</name> = <name>asize</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>asize</name> = <name>bsize</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>bsize</name> = <name>i</name></expr>;</expr_stmt>
	}</block></then></if>

	<comment type="block">/* Use gradeschool math when either number is too small. */</comment>
	<expr_stmt><expr><name>i</name> = <name>a</name> == <name>b</name> ? <name>KARATSUBA_SQUARE_CUTOFF</name> : <name>KARATSUBA_CUTOFF</name></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>asize</name> &lt;= <name>i</name></expr>)</condition><then> <block>{
		<if>if <condition>(<expr><name>asize</name> == 0</expr>)</condition><then>
			<return>return <expr><call><name>_PyLong_New</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</return></then>
		<else>else
			<return>return <expr><call><name>x_mul</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</return></else></if>
	}</block></then></if>

	<comment type="block">/* If a is small compared to b, splitting on b gives a degenerate
	 * case with ah==0, and Karatsuba may be (even much) less efficient
	 * than "grade school" then.  However, we can still win, by viewing
	 * b as a string of "big digits", each of width a-&gt;ob_size.  That
	 * leads to a sequence of balanced calls to k_mul.
	 */</comment>
	<if>if <condition>(<expr>2 * <name>asize</name> &lt;= <name>bsize</name></expr>)</condition><then>
		<return>return <expr><call><name>k_lopsided_mul</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</return></then></if>

	<comment type="block">/* Split a &amp; b into hi &amp; lo pieces. */</comment>
	<expr_stmt><expr><name>shift</name> = <name>bsize</name> &gt;&gt; 1</expr>;</expr_stmt>
	<if>if <condition>(<expr><call><name>kmul_split</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>shift</name></expr></argument>, <argument><expr>&amp;<name>ah</name></expr></argument>, <argument><expr>&amp;<name>al</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then> <goto>goto <name>fail</name>;</goto></then></if>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>Py_SIZE</name><argument_list>(<argument><expr><name>ah</name></expr></argument>)</argument_list></call> &gt; 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* the split isn't degenerate */</comment>

	<if>if <condition>(<expr><name>a</name> == <name>b</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>bh</name> = <name>ah</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>bl</name> = <name>al</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>bh</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>bl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then>
	<else>else <if>if <condition>(<expr><call><name>kmul_split</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name>shift</name></expr></argument>, <argument><expr>&amp;<name>bh</name></expr></argument>, <argument><expr>&amp;<name>bl</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then> <goto>goto <name>fail</name>;</goto></then></if></else></if>

	<comment type="block">/* The plan:
	 * 1. Allocate result space (asize + bsize digits:  that's always
	 *    enough).
	 * 2. Compute ah*bh, and copy into result at 2*shift.
	 * 3. Compute al*bl, and copy into result at 0.  Note that this
	 *    can't overlap with #2.
	 * 4. Subtract al*bl from the result, starting at shift.  This may
	 *    underflow (borrow out of the high digit), but we don't care:
	 *    we're effectively doing unsigned arithmetic mod
	 *    PyLong_BASE**(sizea + sizeb), and so long as the *final* result fits,
	 *    borrows and carries out of the high digit can be ignored.
	 * 5. Subtract ah*bh from the result, starting at shift.
	 * 6. Compute (ah+al)*(bh+bl), and add it into the result starting
	 *    at shift.
	 */</comment>

	<comment type="block">/* 1. Allocate result space. */</comment>
	<expr_stmt><expr><name>ret</name> = <call><name>_PyLong_New</name><argument_list>(<argument><expr><name>asize</name> + <name>bsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>ret</name> == <name>NULL</name></expr>)</condition><then> <goto>goto <name>fail</name>;</goto></then></if>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>Py_DEBUG</name></cpp:ifdef>
	<comment type="block">/* Fill with trash, to catch reference to uninitialized digits. */</comment>
	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>ret</name>-&gt;<name>ob_digit</name></name></expr></argument>, <argument><expr>0xDF</expr></argument>, <argument><expr><call><name>Py_SIZE</name><argument_list>(<argument><expr><name>ret</name></expr></argument>)</argument_list></call> * <sizeof>sizeof<argument_list>(<argument><expr><name>digit</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<comment type="block">/* 2. t1 &lt;- ah*bh, and copy into high digits of result. */</comment>
	<if>if <condition>(<expr>(<name>t1</name> = <call><name>k_mul</name><argument_list>(<argument><expr><name>ah</name></expr></argument>, <argument><expr><name>bh</name></expr></argument>)</argument_list></call>) == <name>NULL</name></expr>)</condition><then> <goto>goto <name>fail</name>;</goto></then></if>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>Py_SIZE</name><argument_list>(<argument><expr><name>t1</name></expr></argument>)</argument_list></call> &gt;= 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr>2*<name>shift</name> + <call><name>Py_SIZE</name><argument_list>(<argument><expr><name>t1</name></expr></argument>)</argument_list></call> &lt;= <call><name>Py_SIZE</name><argument_list>(<argument><expr><name>ret</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>ret</name>-&gt;<name>ob_digit</name></name> + 2*<name>shift</name></expr></argument>, <argument><expr><name><name>t1</name>-&gt;<name>ob_digit</name></name></expr></argument>,
	       <argument><expr><call><name>Py_SIZE</name><argument_list>(<argument><expr><name>t1</name></expr></argument>)</argument_list></call> * <sizeof>sizeof<argument_list>(<argument><expr><name>digit</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Zero-out the digits higher than the ah*bh copy. */</comment>
	<expr_stmt><expr><name>i</name> = <call><name>Py_SIZE</name><argument_list>(<argument><expr><name>ret</name></expr></argument>)</argument_list></call> - 2*<name>shift</name> - <call><name>Py_SIZE</name><argument_list>(<argument><expr><name>t1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>i</name></expr>)</condition><then>
		<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>ret</name>-&gt;<name>ob_digit</name></name> + 2*<name>shift</name> + <call><name>Py_SIZE</name><argument_list>(<argument><expr><name>t1</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>0</expr></argument>,
		       <argument><expr><name>i</name> * <sizeof>sizeof<argument_list>(<argument><expr><name>digit</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

	<comment type="block">/* 3. t2 &lt;- al*bl, and copy into the low digits. */</comment>
	<if>if <condition>(<expr>(<name>t2</name> = <call><name>k_mul</name><argument_list>(<argument><expr><name>al</name></expr></argument>, <argument><expr><name>bl</name></expr></argument>)</argument_list></call>) == <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>t1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<goto>goto <name>fail</name>;</goto>
	}</block></then></if>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>Py_SIZE</name><argument_list>(<argument><expr><name>t2</name></expr></argument>)</argument_list></call> &gt;= 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>Py_SIZE</name><argument_list>(<argument><expr><name>t2</name></expr></argument>)</argument_list></call> &lt;= 2*<name>shift</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* no overlap with high digits */</comment>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>ret</name>-&gt;<name>ob_digit</name></name></expr></argument>, <argument><expr><name><name>t2</name>-&gt;<name>ob_digit</name></name></expr></argument>, <argument><expr><call><name>Py_SIZE</name><argument_list>(<argument><expr><name>t2</name></expr></argument>)</argument_list></call> * <sizeof>sizeof<argument_list>(<argument><expr><name>digit</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Zero out remaining digits. */</comment>
	<expr_stmt><expr><name>i</name> = 2*<name>shift</name> - <call><name>Py_SIZE</name><argument_list>(<argument><expr><name>t2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* number of uninitialized digits */</comment>
	<if>if <condition>(<expr><name>i</name></expr>)</condition><then>
		<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>ret</name>-&gt;<name>ob_digit</name></name> + <call><name>Py_SIZE</name><argument_list>(<argument><expr><name>t2</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>i</name> * <sizeof>sizeof<argument_list>(<argument><expr><name>digit</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

	<comment type="block">/* 4 &amp; 5. Subtract ah*bh (t1) and al*bl (t2).  We do al*bl first
	 * because it's fresher in cache.
	 */</comment>
	<expr_stmt><expr><name>i</name> = <call><name>Py_SIZE</name><argument_list>(<argument><expr><name>ret</name></expr></argument>)</argument_list></call> - <name>shift</name></expr>;</expr_stmt>  <comment type="block">/* # digits after shift */</comment>
	<expr_stmt><expr>(<name>void</name>)<call><name>v_isub</name><argument_list>(<argument><expr><name><name>ret</name>-&gt;<name>ob_digit</name></name> + <name>shift</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name><name>t2</name>-&gt;<name>ob_digit</name></name></expr></argument>, <argument><expr><call><name>Py_SIZE</name><argument_list>(<argument><expr><name>t2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>t2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr>(<name>void</name>)<call><name>v_isub</name><argument_list>(<argument><expr><name><name>ret</name>-&gt;<name>ob_digit</name></name> + <name>shift</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name><name>t1</name>-&gt;<name>ob_digit</name></name></expr></argument>, <argument><expr><call><name>Py_SIZE</name><argument_list>(<argument><expr><name>t1</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>t1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* 6. t3 &lt;- (ah+al)(bh+bl), and add into result. */</comment>
	<if>if <condition>(<expr>(<name>t1</name> = <call><name>x_add</name><argument_list>(<argument><expr><name>ah</name></expr></argument>, <argument><expr><name>al</name></expr></argument>)</argument_list></call>) == <name>NULL</name></expr>)</condition><then> <goto>goto <name>fail</name>;</goto></then></if>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>ah</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>al</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>ah</name> = <name>al</name> = <name>NULL</name></expr>;</expr_stmt>

	<if>if <condition>(<expr><name>a</name> == <name>b</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>t2</name> = <name>t1</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>t2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then>
	<else>else <if>if <condition>(<expr>(<name>t2</name> = <call><name>x_add</name><argument_list>(<argument><expr><name>bh</name></expr></argument>, <argument><expr><name>bl</name></expr></argument>)</argument_list></call>) == <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>t1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<goto>goto <name>fail</name>;</goto>
	}</block></then></if></else></if>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>bh</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>bl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>bh</name> = <name>bl</name> = <name>NULL</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>t3</name> = <call><name>k_mul</name><argument_list>(<argument><expr><name>t1</name></expr></argument>, <argument><expr><name>t2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>t1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>t2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>t3</name> == <name>NULL</name></expr>)</condition><then> <goto>goto <name>fail</name>;</goto></then></if>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>Py_SIZE</name><argument_list>(<argument><expr><name>t3</name></expr></argument>)</argument_list></call> &gt;= 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Add t3.  It's not obvious why we can't run out of room here.
	 * See the (*) comment after this function.
	 */</comment>
	<expr_stmt><expr>(<name>void</name>)<call><name>v_iadd</name><argument_list>(<argument><expr><name><name>ret</name>-&gt;<name>ob_digit</name></name> + <name>shift</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name><name>t3</name>-&gt;<name>ob_digit</name></name></expr></argument>, <argument><expr><call><name>Py_SIZE</name><argument_list>(<argument><expr><name>t3</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>t3</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><call><name>long_normalize</name><argument_list>(<argument><expr><name>ret</name></expr></argument>)</argument_list></call></expr>;</return>

 <label><name>fail</name>:</label>
 	<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>ret</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>ah</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>al</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>bh</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>bl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>NULL</name></expr>;</return>
}</block></function>

<comment type="block">/* (*) Why adding t3 can't "run out of room" above.

Let f(x) mean the floor of x and c(x) mean the ceiling of x.  Some facts
to start with:

1. For any integer i, i = c(i/2) + f(i/2).  In particular,
   bsize = c(bsize/2) + f(bsize/2).
2. shift = f(bsize/2)
3. asize &lt;= bsize
4. Since we call k_lopsided_mul if asize*2 &lt;= bsize, asize*2 &gt; bsize in this
   routine, so asize &gt; bsize/2 &gt;= f(bsize/2) in this routine.

We allocated asize + bsize result digits, and add t3 into them at an offset
of shift.  This leaves asize+bsize-shift allocated digit positions for t3
to fit into, = (by #1 and #2) asize + f(bsize/2) + c(bsize/2) - f(bsize/2) =
asize + c(bsize/2) available digit positions.

bh has c(bsize/2) digits, and bl at most f(size/2) digits.  So bh+hl has
at most c(bsize/2) digits + 1 bit.

If asize == bsize, ah has c(bsize/2) digits, else ah has at most f(bsize/2)
digits, and al has at most f(bsize/2) digits in any case.  So ah+al has at
most (asize == bsize ? c(bsize/2) : f(bsize/2)) digits + 1 bit.

The product (ah+al)*(bh+bl) therefore has at most

    c(bsize/2) + (asize == bsize ? c(bsize/2) : f(bsize/2)) digits + 2 bits

and we have asize + c(bsize/2) available digit positions.  We need to show
this is always enough.  An instance of c(bsize/2) cancels out in both, so
the question reduces to whether asize digits is enough to hold
(asize == bsize ? c(bsize/2) : f(bsize/2)) digits + 2 bits.  If asize &lt; bsize,
then we're asking whether asize digits &gt;= f(bsize/2) digits + 2 bits.  By #4,
asize is at least f(bsize/2)+1 digits, so this in turn reduces to whether 1
digit is enough to hold 2 bits.  This is so since PyLong_SHIFT=15 &gt;= 2.  If
asize == bsize, then we're asking whether bsize digits is enough to hold
c(bsize/2) digits + 2 bits, or equivalently (by #1) whether f(bsize/2) digits
is enough to hold 2 bits.  This is so if bsize &gt;= 2, which holds because
bsize &gt;= KARATSUBA_CUTOFF &gt;= 2.

Note that since there's always enough room for (ah+al)*(bh+bl), and that's
clearly &gt;= each of ah*bh and al*bl, there's always enough room to subtract
ah*bh and al*bl too.
*/</comment>

<comment type="block">/* b has at least twice the digits of a, and a is big enough that Karatsuba
 * would pay off *if* the inputs had balanced sizes.  View b as a sequence
 * of slices, each with a-&gt;ob_size digits, and multiply the slices by a,
 * one at a time.  This gives k_mul balanced inputs to work with, and is
 * also cache-friendly (we compute one double-width slice of the result
 * at a time, then move on, never bactracking except for the helpful
 * single-width slice overlap between successive partial sums).
 */</comment>
<function><type><specifier>static</specifier> <name>PyLongObject</name> *</type>
<name>k_lopsided_mul</name><parameter_list>(<param><decl><type><name>PyLongObject</name> *</type><name>a</name></decl></param>, <param><decl><type><name>PyLongObject</name> *</type><name>b</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><specifier>const</specifier> <name>Py_ssize_t</name></type> <name>asize</name> <init>= <expr><call><name>ABS</name><argument_list>(<argument><expr><call><name>Py_SIZE</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>bsize</name> <init>= <expr><call><name>ABS</name><argument_list>(<argument><expr><call><name>Py_SIZE</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>nbdone</name></decl>;</decl_stmt>	<comment type="block">/* # of b digits already multiplied */</comment>
	<decl_stmt><decl><type><name>PyLongObject</name> *</type><name>ret</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyLongObject</name> *</type><name>bslice</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>asize</name> &gt; <name>KARATSUBA_CUTOFF</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr>2 * <name>asize</name> &lt;= <name>bsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Allocate result space, and zero it out. */</comment>
	<expr_stmt><expr><name>ret</name> = <call><name>_PyLong_New</name><argument_list>(<argument><expr><name>asize</name> + <name>bsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>ret</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>ret</name>-&gt;<name>ob_digit</name></name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><call><name>Py_SIZE</name><argument_list>(<argument><expr><name>ret</name></expr></argument>)</argument_list></call> * <sizeof>sizeof<argument_list>(<argument><expr><name>digit</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Successive slices of b are copied into bslice. */</comment>
	<expr_stmt><expr><name>bslice</name> = <call><name>_PyLong_New</name><argument_list>(<argument><expr><name>asize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>bslice</name> == <name>NULL</name></expr>)</condition><then>
		<goto>goto <name>fail</name>;</goto></then></if>

	<expr_stmt><expr><name>nbdone</name> = 0</expr>;</expr_stmt>
	<while>while <condition>(<expr><name>bsize</name> &gt; 0</expr>)</condition> <block>{
		<decl_stmt><decl><type><name>PyLongObject</name> *</type><name>product</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><specifier>const</specifier> <name>Py_ssize_t</name></type> <name>nbtouse</name> <init>= <expr><call><name>MIN</name><argument_list>(<argument><expr><name>bsize</name></expr></argument>, <argument><expr><name>asize</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/* Multiply the next slice of b by a. */</comment>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>bslice</name>-&gt;<name>ob_digit</name></name></expr></argument>, <argument><expr><name><name>b</name>-&gt;<name>ob_digit</name></name> + <name>nbdone</name></expr></argument>,
		       <argument><expr><name>nbtouse</name> * <sizeof>sizeof<argument_list>(<argument><expr><name>digit</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_SIZE</name><argument_list>(<argument><expr><name>bslice</name></expr></argument>)</argument_list></call> = <name>nbtouse</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>product</name> = <call><name>k_mul</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>bslice</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>product</name> == <name>NULL</name></expr>)</condition><then>
			<goto>goto <name>fail</name>;</goto></then></if>

		<comment type="block">/* Add into result. */</comment>
		<expr_stmt><expr>(<name>void</name>)<call><name>v_iadd</name><argument_list>(<argument><expr><name><name>ret</name>-&gt;<name>ob_digit</name></name> + <name>nbdone</name></expr></argument>, <argument><expr><call><name>Py_SIZE</name><argument_list>(<argument><expr><name>ret</name></expr></argument>)</argument_list></call> - <name>nbdone</name></expr></argument>,
			     <argument><expr><name><name>product</name>-&gt;<name>ob_digit</name></name></expr></argument>, <argument><expr><call><name>Py_SIZE</name><argument_list>(<argument><expr><name>product</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>product</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>bsize</name> -= <name>nbtouse</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>nbdone</name> += <name>nbtouse</name></expr>;</expr_stmt>
	}</block></while>

	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>bslice</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><call><name>long_normalize</name><argument_list>(<argument><expr><name>ret</name></expr></argument>)</argument_list></call></expr>;</return>

 <label><name>fail</name>:</label>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>ret</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>bslice</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>NULL</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>long_mul</name><parameter_list>(<param><decl><type><name>PyLongObject</name> *</type><name>v</name></decl></param>, <param><decl><type><name>PyLongObject</name> *</type><name>w</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyLongObject</name> *</type><name>a</name></decl>, *<decl><type ref="prev"/><name>b</name></decl>, *<decl><type ref="prev"/><name>z</name></decl>;</decl_stmt>

	<if>if <condition>(<expr>!<call><name>convert_binop</name><argument_list>(<argument><expr>(<name>PyObject</name> *)<name>v</name></expr></argument>, <argument><expr>(<name>PyObject</name> *)<name>w</name></expr></argument>, <argument><expr>&amp;<name>a</name></expr></argument>, <argument><expr>&amp;<name>b</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_NotImplemented</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>Py_NotImplemented</name></expr>;</return>
	}</block></then></if>

	<expr_stmt><expr><name>z</name> = <call><name>k_mul</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Negate if exactly one of the inputs is negative. */</comment>
	<if>if <condition>(<expr>((<name><name>a</name>-&gt;<name>ob_size</name></name> ^ <name><name>b</name>-&gt;<name>ob_size</name></name>) &lt; 0) &amp;&amp; <name>z</name></expr>)</condition><then>
		<expr_stmt><expr><name><name>z</name>-&gt;<name>ob_size</name></name> = -(<name><name>z</name>-&gt;<name>ob_size</name></name>)</expr>;</expr_stmt></then></if>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr>(<name>PyObject</name> *)<name>z</name></expr>;</return>
}</block></function>

<comment type="block">/* The / and % operators are now defined in terms of divmod().
   The expression a mod b has the value a - b*floor(a/b).
   The long_divrem function gives the remainder after division of
   |a| by |b|, with the sign of a.  This is also expressed
   as a - b*trunc(a/b), if trunc truncates towards zero.
   Some examples:
   	 a	 b	a rem b		a mod b
   	 13	 10	 3		 3
   	-13	 10	-3		 7
   	 13	-10	 3		-7
   	-13	-10	-3		-3
   So, to get from rem to mod, we have to add b if a and b
   have different signs.  We then subtract one from the 'div'
   part of the outcome to keep the invariant intact. */</comment>

<comment type="block">/* Compute
 *     *pdiv, *pmod = divmod(v, w)
 * NULL can be passed for pdiv or pmod, in which case that part of
 * the result is simply thrown away.  The caller owns a reference to
 * each of these it requests (does not pass NULL for).
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>l_divmod</name><parameter_list>(<param><decl><type><name>PyLongObject</name> *</type><name>v</name></decl></param>, <param><decl><type><name>PyLongObject</name> *</type><name>w</name></decl></param>,
	 <param><decl><type><name>PyLongObject</name> **</type><name>pdiv</name></decl></param>, <param><decl><type><name>PyLongObject</name> **</type><name>pmod</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyLongObject</name> *</type><name>div</name></decl>, *<decl><type ref="prev"/><name>mod</name></decl>;</decl_stmt>

	<if>if <condition>(<expr><call><name>long_divrem</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>w</name></expr></argument>, <argument><expr>&amp;<name>div</name></expr></argument>, <argument><expr>&amp;<name>mod</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
		<return>return <expr>-1</expr>;</return></then></if>
	<if>if <condition>(<expr>(<call><name>Py_SIZE</name><argument_list>(<argument><expr><name>mod</name></expr></argument>)</argument_list></call> &lt; 0 &amp;&amp; <call><name>Py_SIZE</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call> &gt; 0) ||
	    (<call><name>Py_SIZE</name><argument_list>(<argument><expr><name>mod</name></expr></argument>)</argument_list></call> &gt; 0 &amp;&amp; <call><name>Py_SIZE</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call> &lt; 0)</expr>)</condition><then> <block>{
		<decl_stmt><decl><type><name>PyLongObject</name> *</type><name>temp</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PyLongObject</name> *</type><name>one</name></decl>;</decl_stmt>
		<expr_stmt><expr><name>temp</name> = (<name>PyLongObject</name> *) <call><name>long_add</name><argument_list>(<argument><expr><name>mod</name></expr></argument>, <argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>mod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>mod</name> = <name>temp</name></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>mod</name> == <name>NULL</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>div</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr>-1</expr>;</return>
		}</block></then></if>
		<expr_stmt><expr><name>one</name> = (<name>PyLongObject</name> *) <call><name>PyLong_FromLong</name><argument_list>(<argument><expr>1L</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>one</name> == <name>NULL</name> ||
		    (<name>temp</name> = (<name>PyLongObject</name> *) <call><name>long_sub</name><argument_list>(<argument><expr><name>div</name></expr></argument>, <argument><expr><name>one</name></expr></argument>)</argument_list></call>) == <name>NULL</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>mod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>div</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>one</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr>-1</expr>;</return>
		}</block></then></if>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>one</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>div</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>div</name> = <name>temp</name></expr>;</expr_stmt>
	}</block></then></if>
	<if>if <condition>(<expr><name>pdiv</name> != <name>NULL</name></expr>)</condition><then>
		<expr_stmt><expr>*<name>pdiv</name> = <name>div</name></expr>;</expr_stmt></then>
	<else>else
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>div</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>

	<if>if <condition>(<expr><name>pmod</name> != <name>NULL</name></expr>)</condition><then>
		<expr_stmt><expr>*<name>pmod</name> = <name>mod</name></expr>;</expr_stmt></then>
	<else>else
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>mod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>

	<return>return <expr>0</expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>long_div</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>v</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>w</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyLongObject</name> *</type><name>a</name></decl>, *<decl><type ref="prev"/><name>b</name></decl>, *<decl><type ref="prev"/><name>div</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>CONVERT_BINOP</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>w</name></expr></argument>, <argument><expr>&amp;<name>a</name></expr></argument>, <argument><expr>&amp;<name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><call><name>l_divmod</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr>&amp;<name>div</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
		<expr_stmt><expr><name>div</name> = <name>NULL</name></expr>;</expr_stmt></then></if>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr>(<name>PyObject</name> *)<name>div</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>long_classic_div</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>v</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>w</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyLongObject</name> *</type><name>a</name></decl>, *<decl><type ref="prev"/><name>b</name></decl>, *<decl><type ref="prev"/><name>div</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>CONVERT_BINOP</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>w</name></expr></argument>, <argument><expr>&amp;<name>a</name></expr></argument>, <argument><expr>&amp;<name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>Py_DivisionWarningFlag</name> &amp;&amp;
	    <call><name>PyErr_Warn</name><argument_list>(<argument><expr><name>PyExc_DeprecationWarning</name></expr></argument>, <argument><expr>"classic long division"</expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
		<expr_stmt><expr><name>div</name> = <name>NULL</name></expr>;</expr_stmt></then>
	<else>else <if>if <condition>(<expr><call><name>l_divmod</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr>&amp;<name>div</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
		<expr_stmt><expr><name>div</name> = <name>NULL</name></expr>;</expr_stmt></then></if></else></if>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr>(<name>PyObject</name> *)<name>div</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>long_true_divide</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>v</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>w</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyLongObject</name> *</type><name>a</name></decl>, *<decl><type ref="prev"/><name>b</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type> <name>ad</name></decl>, <decl><type ref="prev"/><name>bd</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>failed</name></decl>, <decl><type ref="prev"/><name>aexp</name> <init>= <expr>-1</expr></init>, <name>bexp</name> <init>= <expr>-1</expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>CONVERT_BINOP</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>w</name></expr></argument>, <argument><expr>&amp;<name>a</name></expr></argument>, <argument><expr>&amp;<name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>ad</name> = <call><name>_PyLong_AsScaledDouble</name><argument_list>(<argument><expr>(<name>PyObject</name> *)<name>a</name></expr></argument>, <argument><expr>&amp;<name>aexp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>bd</name> = <call><name>_PyLong_AsScaledDouble</name><argument_list>(<argument><expr>(<name>PyObject</name> *)<name>b</name></expr></argument>, <argument><expr>&amp;<name>bexp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>failed</name> = (<name>ad</name> == -1.0 || <name>bd</name> == -1.0) &amp;&amp; <call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>failed</name></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<comment type="block">/* 'aexp' and 'bexp' were initialized to -1 to silence gcc-4.0.x,
	   but should really be set correctly after sucessful calls to
	   _PyLong_AsScaledDouble() */</comment>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>aexp</name> &gt;= 0 &amp;&amp; <name>bexp</name> &gt;= 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if>if <condition>(<expr><name>bd</name> == 0.0</expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ZeroDivisionError</name></expr></argument>,
			<argument><expr>"long division or modulo by zero"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>

	<comment type="block">/* True value is very close to ad/bd * 2**(PyLong_SHIFT*(aexp-bexp)) */</comment>
	<expr_stmt><expr><name>ad</name> /= <name>bd</name></expr>;</expr_stmt>	<comment type="block">/* overflow/underflow impossible here */</comment>
	<expr_stmt><expr><name>aexp</name> -= <name>bexp</name></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>aexp</name> &gt; <name>INT_MAX</name> / <name>PyLong_SHIFT</name></expr>)</condition><then>
		<goto>goto <name>overflow</name>;</goto></then>
	<else>else <if>if <condition>(<expr><name>aexp</name> &lt; -(<name>INT_MAX</name> / <name>PyLong_SHIFT</name>)</expr>)</condition><then>
		<return>return <expr><call><name>PyFloat_FromDouble</name><argument_list>(<argument><expr>0.0</expr></argument>)</argument_list></call></expr>;</return></then></if></else></if>	<comment type="block">/* underflow to 0 */</comment>
	<expr_stmt><expr><name>errno</name> = 0</expr>;</expr_stmt>
	<expr_stmt><expr><name>ad</name> = <call><name>ldexp</name><argument_list>(<argument><expr><name>ad</name></expr></argument>, <argument><expr><name>aexp</name> * <name>PyLong_SHIFT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><call><name>Py_OVERFLOWED</name><argument_list>(<argument><expr><name>ad</name></expr></argument>)</argument_list></call></expr>)</condition><then> <comment type="block">/* ignore underflow to 0.0 */</comment>
		<goto>goto <name>overflow</name>;</goto></then></if>
	<return>return <expr><call><name>PyFloat_FromDouble</name><argument_list>(<argument><expr><name>ad</name></expr></argument>)</argument_list></call></expr>;</return>

<label><name>overflow</name>:</label>
	<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_OverflowError</name></expr></argument>,
		<argument><expr>"long/long too large for a float"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>NULL</name></expr>;</return>

}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>long_mod</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>v</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>w</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyLongObject</name> *</type><name>a</name></decl>, *<decl><type ref="prev"/><name>b</name></decl>, *<decl><type ref="prev"/><name>mod</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>CONVERT_BINOP</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>w</name></expr></argument>, <argument><expr>&amp;<name>a</name></expr></argument>, <argument><expr>&amp;<name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if>if <condition>(<expr><call><name>l_divmod</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr>&amp;<name>mod</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
		<expr_stmt><expr><name>mod</name> = <name>NULL</name></expr>;</expr_stmt></then></if>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr>(<name>PyObject</name> *)<name>mod</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>long_divmod</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>v</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>w</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyLongObject</name> *</type><name>a</name></decl>, *<decl><type ref="prev"/><name>b</name></decl>, *<decl><type ref="prev"/><name>div</name></decl>, *<decl><type ref="prev"/><name>mod</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>z</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>CONVERT_BINOP</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>w</name></expr></argument>, <argument><expr>&amp;<name>a</name></expr></argument>, <argument><expr>&amp;<name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if>if <condition>(<expr><call><name>l_divmod</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr>&amp;<name>div</name></expr></argument>, <argument><expr>&amp;<name>mod</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>
	<expr_stmt><expr><name>z</name> = <call><name>PyTuple_New</name><argument_list>(<argument><expr>2</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>z</name> != <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyTuple_SetItem</name><argument_list>(<argument><expr><name>z</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>(<name>PyObject</name> *) <name>div</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PyTuple_SetItem</name><argument_list>(<argument><expr><name>z</name></expr></argument>, <argument><expr>1</expr></argument>, <argument><expr>(<name>PyObject</name> *) <name>mod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then>
	<else>else <block>{
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>div</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>mod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></else></if>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>z</name></expr>;</return>
}</block></function>

<comment type="block">/* pow(v, w, x) */</comment>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>long_pow</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>v</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>w</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>x</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyLongObject</name> *</type><name>a</name></decl>, *<decl><type ref="prev"/><name>b</name></decl>, *<decl><type ref="prev"/><name>c</name></decl>;</decl_stmt> <comment type="block">/* a,b,c = v,w,x */</comment>
	<decl_stmt><decl><type><name>int</name></type> <name>negativeOutput</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>  <comment type="block">/* if x&lt;0 return negative output */</comment>

	<decl_stmt><decl><type><name>PyLongObject</name> *</type><name>z</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>  <comment type="block">/* accumulated result */</comment>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>, <decl><type ref="prev"/><name>k</name></decl>;</decl_stmt>             <comment type="block">/* counters */</comment>
	<decl_stmt><decl><type><name>PyLongObject</name> *</type><name>temp</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* 5-ary values.  If the exponent is large enough, table is
	 * precomputed so that table[i] == a**i % c for i in range(32).
	 */</comment>
	<decl_stmt><decl><type><name>PyLongObject</name> *</type><name><name>table</name><index>[<expr>32</expr>]</index></name> <init>= <expr><block>{<expr>0</expr>,<expr>0</expr>,<expr>0</expr>,<expr>0</expr>,<expr>0</expr>,<expr>0</expr>,<expr>0</expr>,<expr>0</expr>,<expr>0</expr>,<expr>0</expr>,<expr>0</expr>,<expr>0</expr>,<expr>0</expr>,<expr>0</expr>,<expr>0</expr>,<expr>0</expr>,
				   <expr>0</expr>,<expr>0</expr>,<expr>0</expr>,<expr>0</expr>,<expr>0</expr>,<expr>0</expr>,<expr>0</expr>,<expr>0</expr>,<expr>0</expr>,<expr>0</expr>,<expr>0</expr>,<expr>0</expr>,<expr>0</expr>,<expr>0</expr>,<expr>0</expr>,<expr>0</expr>}</block></expr></init></decl>;</decl_stmt>

	<comment type="block">/* a, b, c = v, w, x */</comment>
	<expr_stmt><expr><call><name>CONVERT_BINOP</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>w</name></expr></argument>, <argument><expr>&amp;<name>a</name></expr></argument>, <argument><expr>&amp;<name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><call><name>PyLong_Check</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>c</name> = (<name>PyLongObject</name> *)<name>x</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then>
	<else>else <if>if <condition>(<expr><call><name>PyInt_Check</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>c</name> = (<name>PyLongObject</name> *)<call><name>PyLong_FromLong</name><argument_list>(<argument><expr><call><name>PyInt_AS_LONG</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>c</name> == <name>NULL</name></expr>)</condition><then>
			<goto>goto <name>Error</name>;</goto></then></if>
	}</block></then>
	<else>else <if>if <condition>(<expr><name>x</name> == <name>Py_None</name></expr>)</condition><then>
		<expr_stmt><expr><name>c</name> = <name>NULL</name></expr>;</expr_stmt></then>
	<else>else <block>{
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_NotImplemented</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>Py_NotImplemented</name></expr>;</return>
	}</block></else></if></else></if></else></if>

	<if>if <condition>(<expr><call><name>Py_SIZE</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then> <block>{  <comment type="block">/* if exponent is negative */</comment>
		<if>if <condition>(<expr><name>c</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>, <argument><expr>"pow() 2nd argument "
			    "cannot be negative when 3rd argument specified"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<goto>goto <name>Error</name>;</goto>
		}</block></then>
		<else>else <block>{
			<comment type="block">/* else return a float.  This works because we know
			   that this calls float_pow() which converts its
			   arguments to double. */</comment>
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><call><name><name>PyFloat_Type</name>.<name>tp_as_number</name>-&gt;<name>nb_power</name></name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>w</name></expr></argument>, <argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</return>
		}</block></else></if>
	}</block></then></if>

	<if>if <condition>(<expr><name>c</name></expr>)</condition><then> <block>{
		<comment type="block">/* if modulus == 0:
		       raise ValueError() */</comment>
		<if>if <condition>(<expr><call><name>Py_SIZE</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call> == 0</expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>,
					<argument><expr>"pow() 3rd argument cannot be 0"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<goto>goto <name>Error</name>;</goto>
		}</block></then></if>

		<comment type="block">/* if modulus &lt; 0:
		       negativeOutput = True
		       modulus = -modulus */</comment>
		<if>if <condition>(<expr><call><name>Py_SIZE</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then> <block>{
			<expr_stmt><expr><name>negativeOutput</name> = 1</expr>;</expr_stmt>
			<expr_stmt><expr><name>temp</name> = (<name>PyLongObject</name> *)<call><name>_PyLong_Copy</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><name>temp</name> == <name>NULL</name></expr>)</condition><then>
				<goto>goto <name>Error</name>;</goto></then></if>
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>c</name> = <name>temp</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>temp</name> = <name>NULL</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>c</name>-&gt;<name>ob_size</name></name> = - <name><name>c</name>-&gt;<name>ob_size</name></name></expr>;</expr_stmt>
		}</block></then></if>

		<comment type="block">/* if modulus == 1:
		       return 0 */</comment>
		<if>if <condition>(<expr>(<call><name>Py_SIZE</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call> == 1) &amp;&amp; (<name><name>c</name>-&gt;<name>ob_digit</name><index>[<expr>0</expr>]</index></name> == 1)</expr>)</condition><then> <block>{
			<expr_stmt><expr><name>z</name> = (<name>PyLongObject</name> *)<call><name>PyLong_FromLong</name><argument_list>(<argument><expr>0L</expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<goto>goto <name>Done</name>;</goto>
		}</block></then></if>

		<comment type="block">/* if base &lt; 0:
		       base = base % modulus
		   Having the base positive just makes things easier. */</comment>
		<if>if <condition>(<expr><call><name>Py_SIZE</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then> <block>{
			<if>if <condition>(<expr><call><name>l_divmod</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr>&amp;<name>temp</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
				<goto>goto <name>Error</name>;</goto></then></if>
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>a</name> = <name>temp</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>temp</name> = <name>NULL</name></expr>;</expr_stmt>
		}</block></then></if>
	}</block></then></if>

	<comment type="block">/* At this point a, b, and c are guaranteed non-negative UNLESS
	   c is NULL, in which case a may be negative. */</comment>

	<expr_stmt><expr><name>z</name> = (<name>PyLongObject</name> *)<call><name>PyLong_FromLong</name><argument_list>(<argument><expr>1L</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>z</name> == <name>NULL</name></expr>)</condition><then>
		<goto>goto <name>Error</name>;</goto></then></if>

	<comment type="block">/* Perform a modular reduction, X = X % c, but leave X alone if c
	 * is NULL.
	 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>REDUCE</name><parameter_list>(<param><type><name>X</name></type></param>)</parameter_list></cpp:macro>					\
	<cpp:value>if (c != NULL) {				\
		if (l_divmod(X, c, NULL, &amp;temp) &lt; 0)	\
			goto Error;			\
		Py_XDECREF(X);				\
		X = temp;				\
		temp = NULL;				\
	}</cpp:value></cpp:define>

	<comment type="block">/* Multiply two values, then reduce the result:
	   result = X*Y % c.  If c is NULL, skip the mod. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MULT</name><parameter_list>(<param><type><name>X</name></type></param>, <param><type><name>Y</name></type></param>, <param><type><name>result</name></type></param>)</parameter_list></cpp:macro>				\
<cpp:value>{							\
	temp = (PyLongObject *)long_mul(X, Y);		\
	if (temp == NULL)				\
		goto Error;				\
	Py_XDECREF(result);				\
	result = temp;					\
	temp = NULL;					\
	REDUCE(result)					\
}</cpp:value></cpp:define>

	<if>if <condition>(<expr><call><name>Py_SIZE</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call> &lt;= <name>FIVEARY_CUTOFF</name></expr>)</condition><then> <block>{
		<comment type="block">/* Left-to-right binary exponentiation (HAC Algorithm 14.79) */</comment>
		<comment type="block">/* http://www.cacr.math.uwaterloo.ca/hac/about/chap14.pdf    */</comment>
		<for>for (<init><expr><name>i</name> = <call><name>Py_SIZE</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call> - 1</expr>;</init> <condition><expr><name>i</name> &gt;= 0</expr>;</condition> <incr><expr>--<name>i</name></expr></incr>) <block>{
			<decl_stmt><decl><type><name>digit</name></type> <name>bi</name> <init>= <expr><name><name>b</name>-&gt;<name>ob_digit</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

			<for>for (<init><expr><name>j</name> = 1 &lt;&lt; (<name>PyLong_SHIFT</name>-1)</expr>;</init> <condition><expr><name>j</name> != 0</expr>;</condition> <incr><expr><name>j</name> &gt;&gt;= 1</expr></incr>) <block>{
				<macro><name>MULT</name><argument_list>(<argument>z</argument>, <argument>z</argument>, <argument>z</argument>)</argument_list></macro>
				<if>if <condition>(<expr><name>bi</name> &amp; <name>j</name></expr>)</condition><then>
					<macro><name>MULT</name><argument_list>(<argument>z</argument>, <argument>a</argument>, <argument>z</argument>)</argument_list></macro></then></if>
			}</block></for>
		}</block></for>
	}</block></then>
	<else>else <block>{
		<comment type="block">/* Left-to-right 5-ary exponentiation (HAC Algorithm 14.82) */</comment>
		<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* still holds 1L */</comment>
		<expr_stmt><expr><name><name>table</name><index>[<expr>0</expr>]</index></name> = <name>z</name></expr>;</expr_stmt>
		<for>for (<init><expr><name>i</name> = 1</expr>;</init> <condition><expr><name>i</name> &lt; 32</expr>;</condition> <incr><expr>++<name>i</name></expr></incr>)
			<macro><name>MULT</name><argument_list>(<argument>table[i-1]</argument>, <argument>a</argument>, <argument>table[i]</argument>)</argument_list></macro>

		<for>for (<init><expr><name>i</name> = <call><name>Py_SIZE</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call> - 1</expr>;</init> <condition><expr><name>i</name> &gt;= 0</expr>;</condition> <incr><expr>--<name>i</name></expr></incr>) <block>{
			<decl_stmt><decl><type><specifier>const</specifier> <name>digit</name></type> <name>bi</name> <init>= <expr><name><name>b</name>-&gt;<name>ob_digit</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

			<for>for (<init><expr><name>j</name> = <name>PyLong_SHIFT</name> - 5</expr>;</init> <condition><expr><name>j</name> &gt;= 0</expr>;</condition> <incr><expr><name>j</name> -= 5</expr></incr>) <block>{
				<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>index</name> <init>= <expr>(<name>bi</name> &gt;&gt; <name>j</name>) &amp; 0x1f</expr></init></decl>;</decl_stmt>
				<for>for (<init><expr><name>k</name> = 0</expr>;</init> <condition><expr><name>k</name> &lt; 5</expr>;</condition> <incr><expr>++<name>k</name></expr></incr>)
					<macro><name>MULT</name><argument_list>(<argument>z</argument>, <argument>z</argument>, <argument>z</argument>)</argument_list></macro>
				<if>if <condition>(<expr><name>index</name></expr>)</condition><then>
					<macro><name>MULT</name><argument_list>(<argument>z</argument>, <argument>table[index]</argument>, <argument>z</argument>)</argument_list></macro></then></if></for>
			}</block></for>
		}</block></for></for>
	}</block></else></if>

	<if>if <condition>(<expr><name>negativeOutput</name> &amp;&amp; (<call><name>Py_SIZE</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call> != 0)</expr>)</condition><then> <block>{
		<expr_stmt><expr><name>temp</name> = (<name>PyLongObject</name> *)<call><name>long_sub</name><argument_list>(<argument><expr><name>z</name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>temp</name> == <name>NULL</name></expr>)</condition><then>
			<goto>goto <name>Error</name>;</goto></then></if>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>z</name> = <name>temp</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>temp</name> = <name>NULL</name></expr>;</expr_stmt>
	}</block></then></if>
	<goto>goto <name>Done</name>;</goto>

 <label><name>Error</name>:</label>
 	<if>if <condition>(<expr><name>z</name> != <name>NULL</name></expr>)</condition><then> <block>{
 		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
 		<expr_stmt><expr><name>z</name> = <name>NULL</name></expr>;</expr_stmt>
 	}</block></then></if>
	<comment type="block">/* fall through */</comment>
 <label><name>Done</name>:</label>
	<if>if <condition>(<expr><call><name>Py_SIZE</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call> &gt; <name>FIVEARY_CUTOFF</name></expr>)</condition><then> <block>{
		<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; 32</expr>;</condition> <incr><expr>++<name>i</name></expr></incr>)
			<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name><name>table</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></for>
	}</block></then></if>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>temp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr>(<name>PyObject</name> *)<name>z</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>long_invert</name><parameter_list>(<param><decl><type><name>PyLongObject</name> *</type><name>v</name></decl></param>)</parameter_list>
<block>{
	<comment type="block">/* Implement ~x as -(x+1) */</comment>
	<decl_stmt><decl><type><name>PyLongObject</name> *</type><name>x</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyLongObject</name> *</type><name>w</name></decl>;</decl_stmt>
	<expr_stmt><expr><name>w</name> = (<name>PyLongObject</name> *)<call><name>PyLong_FromLong</name><argument_list>(<argument><expr>1L</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>w</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<expr_stmt><expr><name>x</name> = (<name>PyLongObject</name> *) <call><name>long_add</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>x</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<expr_stmt><expr><call><name>Py_SIZE</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call> = -(<call><name>Py_SIZE</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call>)</expr>;</expr_stmt>
	<return>return <expr>(<name>PyObject</name> *)<name>x</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>long_neg</name><parameter_list>(<param><decl><type><name>PyLongObject</name> *</type><name>v</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyLongObject</name> *</type><name>z</name></decl>;</decl_stmt>
	<if>if <condition>(<expr><name><name>v</name>-&gt;<name>ob_size</name></name> == 0 &amp;&amp; <call><name>PyLong_CheckExact</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<comment type="block">/* -0 == 0 */</comment>
		<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>(<name>PyObject</name> *) <name>v</name></expr>;</return>
	}</block></then></if>
	<expr_stmt><expr><name>z</name> = (<name>PyLongObject</name> *)<call><name>_PyLong_Copy</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>z</name> != <name>NULL</name></expr>)</condition><then>
		<expr_stmt><expr><name><name>z</name>-&gt;<name>ob_size</name></name> = -(<name><name>v</name>-&gt;<name>ob_size</name></name>)</expr>;</expr_stmt></then></if>
	<return>return <expr>(<name>PyObject</name> *)<name>z</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>long_abs</name><parameter_list>(<param><decl><type><name>PyLongObject</name> *</type><name>v</name></decl></param>)</parameter_list>
<block>{
	<if>if <condition>(<expr><name><name>v</name>-&gt;<name>ob_size</name></name> &lt; 0</expr>)</condition><then>
		<return>return <expr><call><name>long_neg</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</return></then>
	<else>else
		<return>return <expr><call><name>long_long</name><argument_list>(<argument><expr>(<name>PyObject</name> *)<name>v</name></expr></argument>)</argument_list></call></expr>;</return></else></if>
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>long_nonzero</name><parameter_list>(<param><decl><type><name>PyLongObject</name> *</type><name>v</name></decl></param>)</parameter_list>
<block>{
	<return>return <expr><call><name>ABS</name><argument_list>(<argument><expr><call><name>Py_SIZE</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> != 0</expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>long_rshift</name><parameter_list>(<param><decl><type><name>PyLongObject</name> *</type><name>v</name></decl></param>, <param><decl><type><name>PyLongObject</name> *</type><name>w</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyLongObject</name> *</type><name>a</name></decl>, *<decl><type ref="prev"/><name>b</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyLongObject</name> *</type><name>z</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>long</name></type> <name>shiftby</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>newsize</name></decl>, <decl><type ref="prev"/><name>wordshift</name></decl>, <decl><type ref="prev"/><name>loshift</name></decl>, <decl><type ref="prev"/><name>hishift</name></decl>, <decl><type ref="prev"/><name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>digit</name></type> <name>lomask</name></decl>, <decl><type ref="prev"/><name>himask</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>CONVERT_BINOP</name><argument_list>(<argument><expr>(<name>PyObject</name> *)<name>v</name></expr></argument>, <argument><expr>(<name>PyObject</name> *)<name>w</name></expr></argument>, <argument><expr>&amp;<name>a</name></expr></argument>, <argument><expr>&amp;<name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if>if <condition>(<expr><call><name>Py_SIZE</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then> <block>{
		<comment type="block">/* Right shifting negative numbers is harder */</comment>
		<decl_stmt><decl><type><name>PyLongObject</name> *</type><name>a1</name></decl>, *<decl><type ref="prev"/><name>a2</name></decl>;</decl_stmt>
		<expr_stmt><expr><name>a1</name> = (<name>PyLongObject</name> *) <call><name>long_invert</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>a1</name> == <name>NULL</name></expr>)</condition><then>
			<goto>goto <name>rshift_error</name>;</goto></then></if>
		<expr_stmt><expr><name>a2</name> = (<name>PyLongObject</name> *) <call><name>long_rshift</name><argument_list>(<argument><expr><name>a1</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>a1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>a2</name> == <name>NULL</name></expr>)</condition><then>
			<goto>goto <name>rshift_error</name>;</goto></then></if>
		<expr_stmt><expr><name>z</name> = (<name>PyLongObject</name> *) <call><name>long_invert</name><argument_list>(<argument><expr><name>a2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>a2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then>
	<else>else <block>{

		<expr_stmt><expr><name>shiftby</name> = <call><name>PyLong_AsLong</name><argument_list>(<argument><expr>(<name>PyObject</name> *)<name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>shiftby</name> == -1L &amp;&amp; <call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then>
			<goto>goto <name>rshift_error</name>;</goto></then></if>
		<if>if <condition>(<expr><name>shiftby</name> &lt; 0</expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>,
					<argument><expr>"negative shift count"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<goto>goto <name>rshift_error</name>;</goto>
		}</block></then></if>
		<expr_stmt><expr><name>wordshift</name> = <name>shiftby</name> / <name>PyLong_SHIFT</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>newsize</name> = <call><name>ABS</name><argument_list>(<argument><expr><call><name>Py_SIZE</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> - <name>wordshift</name></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>newsize</name> &lt;= 0</expr>)</condition><then> <block>{
			<expr_stmt><expr><name>z</name> = <call><name>_PyLong_New</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr>(<name>PyObject</name> *)<name>z</name></expr>;</return>
		}</block></then></if>
		<expr_stmt><expr><name>loshift</name> = <name>shiftby</name> % <name>PyLong_SHIFT</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>hishift</name> = <name>PyLong_SHIFT</name> - <name>loshift</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>lomask</name> = ((<name>digit</name>)1 &lt;&lt; <name>hishift</name>) - 1</expr>;</expr_stmt>
		<expr_stmt><expr><name>himask</name> = <name>PyLong_MASK</name> ^ <name>lomask</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>z</name> = <call><name>_PyLong_New</name><argument_list>(<argument><expr><name>newsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>z</name> == <name>NULL</name></expr>)</condition><then>
			<goto>goto <name>rshift_error</name>;</goto></then></if>
		<if>if <condition>(<expr><call><name>Py_SIZE</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
			<expr_stmt><expr><call><name>Py_SIZE</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call> = -(<call><name>Py_SIZE</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call>)</expr>;</expr_stmt></then></if>
		<for>for (<init><expr><name>i</name> = 0</expr>, <expr><name>j</name> = <name>wordshift</name></expr>;</init> <condition><expr><name>i</name> &lt; <name>newsize</name></expr>;</condition> <incr><expr><name>i</name>++</expr>, <expr><name>j</name>++</expr></incr>) <block>{
			<expr_stmt><expr><name><name>z</name>-&gt;<name>ob_digit</name><index>[<expr><name>i</name></expr>]</index></name> = (<name><name>a</name>-&gt;<name>ob_digit</name><index>[<expr><name>j</name></expr>]</index></name> &gt;&gt; <name>loshift</name>) &amp; <name>lomask</name></expr>;</expr_stmt>
			<if>if <condition>(<expr><name>i</name>+1 &lt; <name>newsize</name></expr>)</condition><then>
				<expr_stmt><expr><name><name>z</name>-&gt;<name>ob_digit</name><index>[<expr><name>i</name></expr>]</index></name> |=
				  (<name><name>a</name>-&gt;<name>ob_digit</name><index>[<expr><name>j</name>+1</expr>]</index></name> &lt;&lt; <name>hishift</name>) &amp; <name>himask</name></expr>;</expr_stmt></then></if>
		}</block></for>
		<expr_stmt><expr><name>z</name> = <call><name>long_normalize</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></else></if>
<label><name>rshift_error</name>:</label>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr>(<name>PyObject</name> *) <name>z</name></expr>;</return>

}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>long_lshift</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>v</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>w</name></decl></param>)</parameter_list>
<block>{
	<comment type="block">/* This version due to Tim Peters */</comment>
	<decl_stmt><decl><type><name>PyLongObject</name> *</type><name>a</name></decl>, *<decl><type ref="prev"/><name>b</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyLongObject</name> *</type><name>z</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>long</name></type> <name>shiftby</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>oldsize</name></decl>, <decl><type ref="prev"/><name>newsize</name></decl>, <decl><type ref="prev"/><name>wordshift</name></decl>, <decl><type ref="prev"/><name>remshift</name></decl>, <decl><type ref="prev"/><name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>twodigits</name></type> <name>accum</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>CONVERT_BINOP</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>w</name></expr></argument>, <argument><expr>&amp;<name>a</name></expr></argument>, <argument><expr>&amp;<name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>shiftby</name> = <call><name>PyLong_AsLong</name><argument_list>(<argument><expr>(<name>PyObject</name> *)<name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>shiftby</name> == -1L &amp;&amp; <call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then>
		<goto>goto <name>lshift_error</name>;</goto></then></if>
	<if>if <condition>(<expr><name>shiftby</name> &lt; 0</expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>, <argument><expr>"negative shift count"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<goto>goto <name>lshift_error</name>;</goto>
	}</block></then></if>
	<if>if <condition>(<expr>(<name>long</name>)(<name>int</name>)<name>shiftby</name> != <name>shiftby</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>,
				<argument><expr>"outrageous left shift count"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<goto>goto <name>lshift_error</name>;</goto>
	}</block></then></if>
	<comment type="block">/* wordshift, remshift = divmod(shiftby, PyLong_SHIFT) */</comment>
	<expr_stmt><expr><name>wordshift</name> = (<name>int</name>)<name>shiftby</name> / <name>PyLong_SHIFT</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>remshift</name>  = (<name>int</name>)<name>shiftby</name> - <name>wordshift</name> * <name>PyLong_SHIFT</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>oldsize</name> = <call><name>ABS</name><argument_list>(<argument><expr><name><name>a</name>-&gt;<name>ob_size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>newsize</name> = <name>oldsize</name> + <name>wordshift</name></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>remshift</name></expr>)</condition><then>
		<expr_stmt><expr>++<name>newsize</name></expr>;</expr_stmt></then></if>
	<expr_stmt><expr><name>z</name> = <call><name>_PyLong_New</name><argument_list>(<argument><expr><name>newsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>z</name> == <name>NULL</name></expr>)</condition><then>
		<goto>goto <name>lshift_error</name>;</goto></then></if>
	<if>if <condition>(<expr><name><name>a</name>-&gt;<name>ob_size</name></name> &lt; 0</expr>)</condition><then>
		<expr_stmt><expr><name><name>z</name>-&gt;<name>ob_size</name></name> = -(<name><name>z</name>-&gt;<name>ob_size</name></name>)</expr>;</expr_stmt></then></if>
	<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>wordshift</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
		<expr_stmt><expr><name><name>z</name>-&gt;<name>ob_digit</name><index>[<expr><name>i</name></expr>]</index></name> = 0</expr>;</expr_stmt></for>
	<expr_stmt><expr><name>accum</name> = 0</expr>;</expr_stmt>
	<for>for (<init><expr><name>i</name> = <name>wordshift</name></expr>, <expr><name>j</name> = 0</expr>;</init> <condition><expr><name>j</name> &lt; <name>oldsize</name></expr>;</condition> <incr><expr><name>i</name>++</expr>, <expr><name>j</name>++</expr></incr>) <block>{
		<expr_stmt><expr><name>accum</name> |= (<name>twodigits</name>)<name><name>a</name>-&gt;<name>ob_digit</name><index>[<expr><name>j</name></expr>]</index></name> &lt;&lt; <name>remshift</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>z</name>-&gt;<name>ob_digit</name><index>[<expr><name>i</name></expr>]</index></name> = <call>(<name>digit</name>)<argument_list>(<argument><expr><name>accum</name> &amp; <name>PyLong_MASK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>accum</name> &gt;&gt;= <name>PyLong_SHIFT</name></expr>;</expr_stmt>
	}</block></for>
	<if>if <condition>(<expr><name>remshift</name></expr>)</condition><then>
		<expr_stmt><expr><name><name>z</name>-&gt;<name>ob_digit</name><index>[<expr><name>newsize</name>-1</expr>]</index></name> = (<name>digit</name>)<name>accum</name></expr>;</expr_stmt></then>
	<else>else
		<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr>!<name>accum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
	<expr_stmt><expr><name>z</name> = <call><name>long_normalize</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<label><name>lshift_error</name>:</label>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr>(<name>PyObject</name> *) <name>z</name></expr>;</return>
}</block></function>


<comment type="block">/* Bitwise and/xor/or operations */</comment>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>long_bitwise</name><parameter_list>(<param><decl><type><name>PyLongObject</name> *</type><name>a</name></decl></param>,
	     <param><decl><type><name>int</name></type> <name>op</name></decl></param>,  <comment type="block">/* '&amp;', '|', '^' */</comment>
	     <param><decl><type><name>PyLongObject</name> *</type><name>b</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>digit</name></type> <name>maska</name></decl>, <decl><type ref="prev"/><name>maskb</name></decl>;</decl_stmt> <comment type="block">/* 0 or PyLong_MASK */</comment>
	<decl_stmt><decl><type><name>int</name></type> <name>negz</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>size_a</name></decl>, <decl><type ref="prev"/><name>size_b</name></decl>, <decl><type ref="prev"/><name>size_z</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyLongObject</name> *</type><name>z</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>digit</name></type> <name>diga</name></decl>, <decl><type ref="prev"/><name>digb</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>v</name></decl>;</decl_stmt>

	<if>if <condition>(<expr><call><name>Py_SIZE</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then> <block>{
		<expr_stmt><expr><name>a</name> = (<name>PyLongObject</name> *) <call><name>long_invert</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>a</name> == <name>NULL</name></expr>)</condition><then>
			<return>return <expr><name>NULL</name></expr>;</return></then></if>
		<expr_stmt><expr><name>maska</name> = <name>PyLong_MASK</name></expr>;</expr_stmt>
	}</block></then>
	<else>else <block>{
		<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>maska</name> = 0</expr>;</expr_stmt>
	}</block></else></if>
	<if>if <condition>(<expr><call><name>Py_SIZE</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then> <block>{
		<expr_stmt><expr><name>b</name> = (<name>PyLongObject</name> *) <call><name>long_invert</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>b</name> == <name>NULL</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>NULL</name></expr>;</return>
		}</block></then></if>
		<expr_stmt><expr><name>maskb</name> = <name>PyLong_MASK</name></expr>;</expr_stmt>
	}</block></then>
	<else>else <block>{
		<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>maskb</name> = 0</expr>;</expr_stmt>
	}</block></else></if>

	<expr_stmt><expr><name>negz</name> = 0</expr>;</expr_stmt>
	<switch>switch <condition>(<expr><name>op</name></expr>)</condition> <block>{
	<case>case <expr>'^'</expr>:
		<if>if <condition>(<expr><name>maska</name> != <name>maskb</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><name>maska</name> ^= <name>PyLong_MASK</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>negz</name> = -1</expr>;</expr_stmt>
		}</block></then></if>
		<break>break;</break>
	</case><case>case <expr>'&amp;'</expr>:
		<if>if <condition>(<expr><name>maska</name> &amp;&amp; <name>maskb</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><name>op</name> = '|'</expr>;</expr_stmt>
			<expr_stmt><expr><name>maska</name> ^= <name>PyLong_MASK</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>maskb</name> ^= <name>PyLong_MASK</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>negz</name> = -1</expr>;</expr_stmt>
		}</block></then></if>
		<break>break;</break>
	</case><case>case <expr>'|'</expr>:
		<if>if <condition>(<expr><name>maska</name> || <name>maskb</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><name>op</name> = '&amp;'</expr>;</expr_stmt>
			<expr_stmt><expr><name>maska</name> ^= <name>PyLong_MASK</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>maskb</name> ^= <name>PyLong_MASK</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>negz</name> = -1</expr>;</expr_stmt>
		}</block></then></if>
		<break>break;</break>
	</case>}</block></switch>

	<comment type="block">/* JRH: The original logic here was to allocate the result value (z)
	   as the longer of the two operands.  However, there are some cases
	   where the result is guaranteed to be shorter than that: AND of two
	   positives, OR of two negatives: use the shorter number.  AND with
	   mixed signs: use the positive number.  OR with mixed signs: use the
	   negative number.  After the transformations above, op will be '&amp;'
	   iff one of these cases applies, and mask will be non-0 for operands
	   whose length should be ignored.
	*/</comment>

	<expr_stmt><expr><name>size_a</name> = <call><name>Py_SIZE</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>size_b</name> = <call><name>Py_SIZE</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>size_z</name> = <name>op</name> == '&amp;'
		? (<name>maska</name>
		   ? <name>size_b</name>
		   : (<name>maskb</name> ? <name>size_a</name> : <call><name>MIN</name><argument_list>(<argument><expr><name>size_a</name></expr></argument>, <argument><expr><name>size_b</name></expr></argument>)</argument_list></call>))
		: <call><name>MAX</name><argument_list>(<argument><expr><name>size_a</name></expr></argument>, <argument><expr><name>size_b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>z</name> = <call><name>_PyLong_New</name><argument_list>(<argument><expr><name>size_z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>z</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>

	<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>size_z</name></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>) <block>{
		<expr_stmt><expr><name>diga</name> = (<name>i</name> &lt; <name>size_a</name> ? <name><name>a</name>-&gt;<name>ob_digit</name><index>[<expr><name>i</name></expr>]</index></name> : 0) ^ <name>maska</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>digb</name> = (<name>i</name> &lt; <name>size_b</name> ? <name><name>b</name>-&gt;<name>ob_digit</name><index>[<expr><name>i</name></expr>]</index></name> : 0) ^ <name>maskb</name></expr>;</expr_stmt>
		<switch>switch <condition>(<expr><name>op</name></expr>)</condition> <block>{
		<case>case <expr>'&amp;'</expr>: <expr_stmt><expr><name><name>z</name>-&gt;<name>ob_digit</name><index>[<expr><name>i</name></expr>]</index></name> = <name>diga</name> &amp; <name>digb</name></expr>;</expr_stmt> <break>break;</break>
		</case><case>case <expr>'|'</expr>: <expr_stmt><expr><name><name>z</name>-&gt;<name>ob_digit</name><index>[<expr><name>i</name></expr>]</index></name> = <name>diga</name> | <name>digb</name></expr>;</expr_stmt> <break>break;</break>
		</case><case>case <expr>'^'</expr>: <expr_stmt><expr><name><name>z</name>-&gt;<name>ob_digit</name><index>[<expr><name>i</name></expr>]</index></name> = <name>diga</name> ^ <name>digb</name></expr>;</expr_stmt> <break>break;</break>
		</case>}</block></switch>
	}</block></for>

	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>z</name> = <call><name>long_normalize</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>negz</name> == 0</expr>)</condition><then>
		<return>return <expr>(<name>PyObject</name> *) <name>z</name></expr>;</return></then></if>
	<expr_stmt><expr><name>v</name> = <call><name>long_invert</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>v</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>long_and</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>v</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>w</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyLongObject</name> *</type><name>a</name></decl>, *<decl><type ref="prev"/><name>b</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>c</name></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>CONVERT_BINOP</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>w</name></expr></argument>, <argument><expr>&amp;<name>a</name></expr></argument>, <argument><expr>&amp;<name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>c</name> = <call><name>long_bitwise</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr>'&amp;'</expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>c</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>long_xor</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>v</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>w</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyLongObject</name> *</type><name>a</name></decl>, *<decl><type ref="prev"/><name>b</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>c</name></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>CONVERT_BINOP</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>w</name></expr></argument>, <argument><expr>&amp;<name>a</name></expr></argument>, <argument><expr>&amp;<name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>c</name> = <call><name>long_bitwise</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr>'^'</expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>c</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>long_or</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>v</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>w</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyLongObject</name> *</type><name>a</name></decl>, *<decl><type ref="prev"/><name>b</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>c</name></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>CONVERT_BINOP</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>w</name></expr></argument>, <argument><expr>&amp;<name>a</name></expr></argument>, <argument><expr>&amp;<name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>c</name> = <call><name>long_bitwise</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr>'|'</expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>c</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>long_coerce</name><parameter_list>(<param><decl><type><name>PyObject</name> **</type><name>pv</name></decl></param>, <param><decl><type><name>PyObject</name> **</type><name>pw</name></decl></param>)</parameter_list>
<block>{
	<if>if <condition>(<expr><call><name>PyInt_Check</name><argument_list>(<argument><expr>*<name>pw</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr>*<name>pw</name> = <call><name>PyLong_FromLong</name><argument_list>(<argument><expr><call><name>PyInt_AS_LONG</name><argument_list>(<argument><expr>*<name>pw</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr>*<name>pw</name> == <name>NULL</name></expr>)</condition><then>
			<return>return <expr>-1</expr>;</return></then></if>
		<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr>*<name>pv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>0</expr>;</return>
	}</block></then>
	<else>else <if>if <condition>(<expr><call><name>PyLong_Check</name><argument_list>(<argument><expr>*<name>pw</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr>*<name>pv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr>*<name>pw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>0</expr>;</return>
	}</block></then></if></else></if>
	<return>return <expr>1</expr>;</return> <comment type="block">/* Can't do it */</comment>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>long_long</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>v</name></decl></param>)</parameter_list>
<block>{
	<if>if <condition>(<expr><call><name>PyLong_CheckExact</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
	<else>else
		<expr_stmt><expr><name>v</name> = <call><name>_PyLong_Copy</name><argument_list>(<argument><expr>(<name>PyLongObject</name> *)<name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
	<return>return <expr><name>v</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>long_int</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>v</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>long</name></type> <name>x</name></decl>;</decl_stmt>
	<expr_stmt><expr><name>x</name> = <call><name>PyLong_AsLong</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
		<if>if <condition>(<expr><call><name>PyErr_ExceptionMatches</name><argument_list>(<argument><expr><name>PyExc_OverflowError</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
				<expr_stmt><expr><call><name>PyErr_Clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<if>if <condition>(<expr><call><name>PyLong_CheckExact</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
					<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<return>return <expr><name>v</name></expr>;</return>
				}</block></then>
				<else>else
					<return>return <expr><call><name>_PyLong_Copy</name><argument_list>(<argument><expr>(<name>PyLongObject</name> *)<name>v</name></expr></argument>)</argument_list></call></expr>;</return></else></if>
		}</block></then>
		<else>else
			<return>return <expr><name>NULL</name></expr>;</return></else></if>
	}</block></then></if>
	<return>return <expr><call><name>PyInt_FromLong</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>long_float</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>v</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>double</name></type> <name>result</name></decl>;</decl_stmt>
	<expr_stmt><expr><name>result</name> = <call><name>PyLong_AsDouble</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>result</name> == -1.0 &amp;&amp; <call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<return>return <expr><call><name>PyFloat_FromDouble</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>long_oct</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>v</name></decl></param>)</parameter_list>
<block>{
	<return>return <expr><call><name>_PyLong_Format</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr>8</expr></argument>, <argument><expr>1</expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>long_hex</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>v</name></decl></param>)</parameter_list>
<block>{
	<return>return <expr><call><name>_PyLong_Format</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr>16</expr></argument>, <argument><expr>1</expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function_decl><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>long_subtype_new</name><parameter_list>(<param><decl><type><name>PyTypeObject</name> *</type><name>type</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>kwds</name></decl></param>)</parameter_list>;</function_decl>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>long_new</name><parameter_list>(<param><decl><type><name>PyTypeObject</name> *</type><name>type</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>kwds</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>x</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>base</name> <init>= <expr>-909</expr></init></decl>;</decl_stmt>		     <comment type="block">/* unlikely! */</comment>
	<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> *</type><name><name>kwlist</name><index>[]</index></name> <init>= <expr><block>{<expr>"x"</expr>, <expr>"base"</expr>, <expr>0</expr>}</block></expr></init></decl>;</decl_stmt>

	<if>if <condition>(<expr><name>type</name> != &amp;<name>PyLong_Type</name></expr>)</condition><then>
		<return>return <expr><call><name>long_subtype_new</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><name>args</name></expr></argument>, <argument><expr><name>kwds</name></expr></argument>)</argument_list></call></expr>;</return></then></if> <comment type="block">/* Wimp out */</comment>
	<if>if <condition>(<expr>!<call><name>PyArg_ParseTupleAndKeywords</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>kwds</name></expr></argument>, <argument><expr>"|Oi:long"</expr></argument>, <argument><expr><name>kwlist</name></expr></argument>,
					 <argument><expr>&amp;<name>x</name></expr></argument>, <argument><expr>&amp;<name>base</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<if>if <condition>(<expr><name>x</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr><call><name>PyLong_FromLong</name><argument_list>(<argument><expr>0L</expr></argument>)</argument_list></call></expr>;</return></then></if>
	<if>if <condition>(<expr><name>base</name> == -909</expr>)</condition><then>
		<return>return <expr><call><name>PyNumber_Long</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</return></then>
	<else>else <if>if <condition>(<expr><call><name>PyString_Check</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<comment type="block">/* Since PyLong_FromString doesn't have a length parameter,
		 * check here for possible NULs in the string. */</comment>
		<decl_stmt><decl><type><name>char</name> *</type><name>string</name> <init>= <expr><call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if>if <condition>(<expr><call><name>strlen</name><argument_list>(<argument><expr><name>string</name></expr></argument>)</argument_list></call> != <call><name>PyString_Size</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
			<comment type="block">/* create a repr() of the input string,
			 * just like PyLong_FromString does. */</comment>
			<decl_stmt><decl><type><name>PyObject</name> *</type><name>srepr</name></decl>;</decl_stmt>
			<expr_stmt><expr><name>srepr</name> = <call><name>PyObject_Repr</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><name>srepr</name> == <name>NULL</name></expr>)</condition><then>
				<return>return <expr><name>NULL</name></expr>;</return></then></if>
			<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>,
			     <argument><expr>"invalid literal for long() with base %d: %s"</expr></argument>,
			     <argument><expr><name>base</name></expr></argument>, <argument><expr><call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>srepr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>srepr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>NULL</name></expr>;</return>
		}</block></then></if>
		<return>return <expr><call><name>PyLong_FromString</name><argument_list>(<argument><expr><call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>base</name></expr></argument>)</argument_list></call></expr>;</return>
	}</block></then>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>Py_USING_UNICODE</name></cpp:ifdef>
	<else>else <if>if <condition>(<expr><call><name>PyUnicode_Check</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><call><name>PyLong_FromUnicode</name><argument_list>(<argument><expr><call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr></argument>,
					  <argument><expr><call><name>PyUnicode_GET_SIZE</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr></argument>,
					  <argument><expr><name>base</name></expr></argument>)</argument_list></call></expr>;</return></then>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<else>else <block>{
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
			<argument><expr>"long() can't convert non-string with explicit base"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></else></if></else></if></else></if>
}</block></function>

<comment type="block">/* Wimpy, slow approach to tp_new calls for subtypes of long:
   first create a regular long from whatever arguments we got,
   then allocate a subtype instance and initialize it from
   the regular long.  The regular long is then thrown away.
*/</comment>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>long_subtype_new</name><parameter_list>(<param><decl><type><name>PyTypeObject</name> *</type><name>type</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>kwds</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyLongObject</name> *</type><name>tmp</name></decl>, *<decl><type ref="prev"/><name>newobj</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>n</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>PyType_IsSubtype</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr>&amp;<name>PyLong_Type</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>tmp</name> = (<name>PyLongObject</name> *)<call><name>long_new</name><argument_list>(<argument><expr>&amp;<name>PyLong_Type</name></expr></argument>, <argument><expr><name>args</name></expr></argument>, <argument><expr><name>kwds</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>tmp</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>PyLong_CheckExact</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>n</name> = <call><name>Py_SIZE</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>n</name> &lt; 0</expr>)</condition><then>
		<expr_stmt><expr><name>n</name> = -<name>n</name></expr>;</expr_stmt></then></if>
	<expr_stmt><expr><name>newobj</name> = (<name>PyLongObject</name> *)<call><name><name>type</name>-&gt;<name>tp_alloc</name></name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>newobj</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>PyLong_Check</name><argument_list>(<argument><expr><name>newobj</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_SIZE</name><argument_list>(<argument><expr><name>newobj</name></expr></argument>)</argument_list></call> = <call><name>Py_SIZE</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>n</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
		<expr_stmt><expr><name><name>newobj</name>-&gt;<name>ob_digit</name><index>[<expr><name>i</name></expr>]</index></name> = <name><name>tmp</name>-&gt;<name>ob_digit</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt></for>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr>(<name>PyObject</name> *)<name>newobj</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>long_getnewargs</name><parameter_list>(<param><decl><type><name>PyLongObject</name> *</type><name>v</name></decl></param>)</parameter_list>
<block>{
	<return>return <expr><call><name>Py_BuildValue</name><argument_list>(<argument><expr>"(N)"</expr></argument>, <argument><expr><call><name>_PyLong_Copy</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>long_getN</name><parameter_list>(<param><decl><type><name>PyLongObject</name> *</type><name>v</name></decl></param>, <param><decl><type><name>void</name> *</type><name>context</name></decl></param>)</parameter_list> <block>{
	<return>return <expr><call><name>PyLong_FromLong</name><argument_list>(<argument><expr>(<name>Py_intptr_t</name>)<name>context</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>long__format__</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>format_spec</name></decl>;</decl_stmt>

	<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"O:__format__"</expr></argument>, <argument><expr>&amp;<name>format_spec</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<if>if <condition>(<expr><call><name>PyBytes_Check</name><argument_list>(<argument><expr><name>format_spec</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><call><name>_PyLong_FormatAdvanced</name><argument_list>(<argument><expr><name>self</name></expr></argument>,
					      <argument><expr><call><name>PyBytes_AS_STRING</name><argument_list>(<argument><expr><name>format_spec</name></expr></argument>)</argument_list></call></expr></argument>,
					      <argument><expr><call><name>PyBytes_GET_SIZE</name><argument_list>(<argument><expr><name>format_spec</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></then></if>
	<if>if <condition>(<expr><call><name>PyUnicode_Check</name><argument_list>(<argument><expr><name>format_spec</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<comment type="block">/* Convert format_spec to a str */</comment>
		<decl_stmt><decl><type><name>PyObject</name> *</type><name>result</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PyObject</name> *</type><name>str_spec</name> <init>= <expr><call><name>PyObject_Str</name><argument_list>(<argument><expr><name>format_spec</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if>if <condition>(<expr><name>str_spec</name> == <name>NULL</name></expr>)</condition><then>
			<return>return <expr><name>NULL</name></expr>;</return></then></if>

		<expr_stmt><expr><name>result</name> = <call><name>_PyLong_FormatAdvanced</name><argument_list>(<argument><expr><name>self</name></expr></argument>,
						<argument><expr><call><name>PyBytes_AS_STRING</name><argument_list>(<argument><expr><name>str_spec</name></expr></argument>)</argument_list></call></expr></argument>,
						<argument><expr><call><name>PyBytes_GET_SIZE</name><argument_list>(<argument><expr><name>str_spec</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>str_spec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>result</name></expr>;</return>
	}</block></then></if>
	<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>, <argument><expr>"__format__ requires str or unicode"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>NULL</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>long_sizeof</name><parameter_list>(<param><decl><type><name>PyLongObject</name> *</type><name>v</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>res</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>res</name> = <name><name>v</name>-&gt;<name>ob_type</name>-&gt;<name>tp_basicsize</name></name></expr>;</expr_stmt>
        <if>if <condition>(<expr><name><name>v</name>-&gt;<name>ob_size</name></name> != 0</expr>)</condition><then>
		<expr_stmt><expr><name>res</name> += <call><name>abs</name><argument_list>(<argument><expr><name><name>v</name>-&gt;<name>ob_size</name></name></expr></argument>)</argument_list></call> * <sizeof>sizeof<argument_list>(<argument><expr><name>digit</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt></then></if>
	<return>return <expr><call><name>PyInt_FromSsize_t</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr>0</expr></cpp:if>
static PyObject *
long_is_finite(PyObject *v)
{
	Py_RETURN_TRUE;
}
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<decl_stmt><decl><type><specifier>static</specifier> <name>PyMethodDef</name></type> <name><name>long_methods</name><index>[]</index></name> <init>= <expr><block>{
	<expr><block>{<expr>"conjugate"</expr>,	<expr>(<name>PyCFunction</name>)<name>long_long</name></expr>,	<expr><name>METH_NOARGS</name></expr>,
	 <expr>"Returns self, the complex conjugate of any long."</expr>}</block></expr>,
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>0</expr></cpp:if>
	{"is_finite",	(PyCFunction)long_is_finite,	METH_NOARGS,
	 "Returns always True."},
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<expr><block>{<expr>"__trunc__"</expr>,	<expr>(<name>PyCFunction</name>)<name>long_long</name></expr>,	<expr><name>METH_NOARGS</name></expr>,
         <expr>"Truncating an Integral returns itself."</expr>}</block></expr>,
	<expr><block>{<expr>"__getnewargs__"</expr>,	<expr>(<name>PyCFunction</name>)<name>long_getnewargs</name></expr>,	<expr><name>METH_NOARGS</name></expr>}</block></expr>,
        <expr><block>{<expr>"__format__"</expr>, <expr>(<name>PyCFunction</name>)<name>long__format__</name></expr>, <expr><name>METH_VARARGS</name></expr>}</block></expr>,
	<expr><block>{<expr>"__sizeof__"</expr>,	<expr>(<name>PyCFunction</name>)<name>long_sizeof</name></expr>, <expr><name>METH_NOARGS</name></expr>,
	 <expr>"Returns size in memory, in bytes"</expr>}</block></expr>,
	<expr><block>{<expr><name>NULL</name></expr>,		<expr><name>NULL</name></expr>}</block></expr>		<comment type="block">/* sentinel */</comment>
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>PyGetSetDef</name></type> <name><name>long_getset</name><index>[]</index></name> <init>= <expr><block>{
    <expr><block>{<expr>"real"</expr>, 
     <expr>(<name>getter</name>)<name>long_long</name></expr>, <expr>(<name>setter</name>)<name>NULL</name></expr>,
     <expr>"the real part of a complex number"</expr>,
     <expr><name>NULL</name></expr>}</block></expr>,
    <expr><block>{<expr>"imag"</expr>, 
     <expr>(<name>getter</name>)<name>long_getN</name></expr>, <expr>(<name>setter</name>)<name>NULL</name></expr>,
     <expr>"the imaginary part of a complex number"</expr>,
     <expr>(<name>void</name>*)0</expr>}</block></expr>,
    <expr><block>{<expr>"numerator"</expr>, 
     <expr>(<name>getter</name>)<name>long_long</name></expr>, <expr>(<name>setter</name>)<name>NULL</name></expr>,
     <expr>"the numerator of a rational number in lowest terms"</expr>,
     <expr><name>NULL</name></expr>}</block></expr>,
    <expr><block>{<expr>"denominator"</expr>, 
     <expr>(<name>getter</name>)<name>long_getN</name></expr>, <expr>(<name>setter</name>)<name>NULL</name></expr>,
     <expr>"the denominator of a rational number in lowest terms"</expr>,
     <expr>(<name>void</name>*)1</expr>}</block></expr>,
    <expr><block>{<expr><name>NULL</name></expr>}</block></expr>  <comment type="block">/* Sentinel */</comment>
}</block></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>long_doc</name></expr></argument>,
<argument><expr>"long(x[, base]) -&gt; integer\n\
\n\
Convert a string or number to a long integer, if possible.  A floating\n\
point argument will be truncated towards zero (this does not include a\n\
string representation of a floating point number!)  When converting a\n\
string, use the optional base.  It is an error to supply a base when\n\
converting a non-string."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>PyNumberMethods</name></type> <name>long_as_number</name> <init>= <expr><block>{
	<expr>(<name>binaryfunc</name>)	<name>long_add</name></expr>,	<comment type="block">/*nb_add*/</comment>
	<expr>(<name>binaryfunc</name>)	<name>long_sub</name></expr>,	<comment type="block">/*nb_subtract*/</comment>
	<expr>(<name>binaryfunc</name>)	<name>long_mul</name></expr>,	<comment type="block">/*nb_multiply*/</comment>
			<expr><name>long_classic_div</name></expr>, <comment type="block">/*nb_divide*/</comment>
			<expr><name>long_mod</name></expr>,	<comment type="block">/*nb_remainder*/</comment>
			<expr><name>long_divmod</name></expr>,	<comment type="block">/*nb_divmod*/</comment>
			<expr><name>long_pow</name></expr>,	<comment type="block">/*nb_power*/</comment>
	<expr>(<name>unaryfunc</name>) 	<name>long_neg</name></expr>,	<comment type="block">/*nb_negative*/</comment>
	<expr>(<name>unaryfunc</name>) 	<name>long_long</name></expr>,	<comment type="block">/*tp_positive*/</comment>
	<expr>(<name>unaryfunc</name>) 	<name>long_abs</name></expr>,	<comment type="block">/*tp_absolute*/</comment>
	<expr>(<name>inquiry</name>)	<name>long_nonzero</name></expr>,	<comment type="block">/*tp_nonzero*/</comment>
	<expr>(<name>unaryfunc</name>)	<name>long_invert</name></expr>,	<comment type="block">/*nb_invert*/</comment>
			<expr><name>long_lshift</name></expr>,	<comment type="block">/*nb_lshift*/</comment>
	<expr>(<name>binaryfunc</name>)	<name>long_rshift</name></expr>,	<comment type="block">/*nb_rshift*/</comment>
			<expr><name>long_and</name></expr>,	<comment type="block">/*nb_and*/</comment>
			<expr><name>long_xor</name></expr>,	<comment type="block">/*nb_xor*/</comment>
			<expr><name>long_or</name></expr>,	<comment type="block">/*nb_or*/</comment>
			<expr><name>long_coerce</name></expr>,	<comment type="block">/*nb_coerce*/</comment>
			<expr><name>long_int</name></expr>,	<comment type="block">/*nb_int*/</comment>
			<expr><name>long_long</name></expr>,	<comment type="block">/*nb_long*/</comment>
			<expr><name>long_float</name></expr>,	<comment type="block">/*nb_float*/</comment>
			<expr><name>long_oct</name></expr>,	<comment type="block">/*nb_oct*/</comment>
			<expr><name>long_hex</name></expr>,	<comment type="block">/*nb_hex*/</comment>
	<expr>0</expr>,				<comment type="block">/* nb_inplace_add */</comment>
	<expr>0</expr>,				<comment type="block">/* nb_inplace_subtract */</comment>
	<expr>0</expr>,				<comment type="block">/* nb_inplace_multiply */</comment>
	<expr>0</expr>,				<comment type="block">/* nb_inplace_divide */</comment>
	<expr>0</expr>,				<comment type="block">/* nb_inplace_remainder */</comment>
	<expr>0</expr>,				<comment type="block">/* nb_inplace_power */</comment>
	<expr>0</expr>,				<comment type="block">/* nb_inplace_lshift */</comment>
	<expr>0</expr>,				<comment type="block">/* nb_inplace_rshift */</comment>
	<expr>0</expr>,				<comment type="block">/* nb_inplace_and */</comment>
	<expr>0</expr>,				<comment type="block">/* nb_inplace_xor */</comment>
	<expr>0</expr>,				<comment type="block">/* nb_inplace_or */</comment>
	<expr><name>long_div</name></expr>,			<comment type="block">/* nb_floor_divide */</comment>
	<expr><name>long_true_divide</name></expr>,		<comment type="block">/* nb_true_divide */</comment>
	<expr>0</expr>,				<comment type="block">/* nb_inplace_floor_divide */</comment>
	<expr>0</expr>,				<comment type="block">/* nb_inplace_true_divide */</comment>
	<expr><name>long_long</name></expr>,			<comment type="block">/* nb_index */</comment>
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>PyTypeObject</name></type> <name>PyLong_Type</name> <init>= <expr><block>{
	<expr><call><name>PyObject_HEAD_INIT</name><argument_list>(<argument><expr>&amp;<name>PyType_Type</name></expr></argument>)</argument_list></call>
	0</expr>,					<comment type="block">/* ob_size */</comment>
	<expr>"long"</expr>,					<comment type="block">/* tp_name */</comment>
	<expr><sizeof>sizeof<argument_list>(<argument><expr><name>PyLongObject</name></expr></argument>)</argument_list></sizeof> - <sizeof>sizeof<argument_list>(<argument><expr><name>digit</name></expr></argument>)</argument_list></sizeof></expr>,	<comment type="block">/* tp_basicsize */</comment>
	<expr><sizeof>sizeof<argument_list>(<argument><expr><name>digit</name></expr></argument>)</argument_list></sizeof></expr>,				<comment type="block">/* tp_itemsize */</comment>
	<expr><name>long_dealloc</name></expr>,				<comment type="block">/* tp_dealloc */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_print */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_getattr */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_setattr */</comment>
	<expr>(<name>cmpfunc</name>)<name>long_compare</name></expr>,			<comment type="block">/* tp_compare */</comment>
	<expr><name>long_repr</name></expr>,				<comment type="block">/* tp_repr */</comment>
	<expr>&amp;<name>long_as_number</name></expr>,			<comment type="block">/* tp_as_number */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_as_sequence */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_as_mapping */</comment>
	<expr>(<name>hashfunc</name>)<name>long_hash</name></expr>,			<comment type="block">/* tp_hash */</comment>
        <expr>0</expr>,              			<comment type="block">/* tp_call */</comment>
        <expr><name>long_str</name></expr>,				<comment type="block">/* tp_str */</comment>
	<expr><name>PyObject_GenericGetAttr</name></expr>,		<comment type="block">/* tp_getattro */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_setattro */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_as_buffer */</comment>
	<expr><name>Py_TPFLAGS_DEFAULT</name> | <name>Py_TPFLAGS_CHECKTYPES</name> |
		<name>Py_TPFLAGS_BASETYPE</name> | <name>Py_TPFLAGS_LONG_SUBCLASS</name></expr>,	<comment type="block">/* tp_flags */</comment>
	<expr><name>long_doc</name></expr>,				<comment type="block">/* tp_doc */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_traverse */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_clear */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_richcompare */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_weaklistoffset */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_iter */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_iternext */</comment>
	<expr><name>long_methods</name></expr>,				<comment type="block">/* tp_methods */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_members */</comment>
	<expr><name>long_getset</name></expr>,				<comment type="block">/* tp_getset */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_base */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_dict */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_descr_get */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_descr_set */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_dictoffset */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_init */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_alloc */</comment>
	<expr><name>long_new</name></expr>,				<comment type="block">/* tp_new */</comment>
	<expr><name>PyObject_Del</name></expr>,                           <comment type="block">/* tp_free */</comment>
}</block></expr></init></decl>;</decl_stmt>
</unit>
