<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C" filename="projects/cpython-2.6.1/source/Objects/obmalloc.c"><cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"Python.h"</cpp:file></cpp:include>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WITH_PYMALLOC</name></cpp:ifdef>

<comment type="block">/* An object allocator for Python.

   Here is an introduction to the layers of the Python memory architecture,
   showing where the object allocator is actually used (layer +2), It is
   called for every object allocation and deallocation (PyObject_New/Del),
   unless the object-specific allocators implement a proprietary allocation
   scheme (ex.: ints use a simple free list). This is also the place where
   the cyclic garbage collector operates selectively on container objects.


        Object-specific allocators
    _____   ______   ______       ________
   [ int ] [ dict ] [ list ] ... [ string ]       Python core         |
+3 | &lt;----- Object-specific memory -----&gt; | &lt;-- Non-object memory --&gt; |
    _______________________________       |                           |
   [   Python's object allocator   ]      |                           |
+2 | ####### Object memory ####### | &lt;------ Internal buffers ------&gt; |
    ______________________________________________________________    |
   [          Python's raw memory allocator (PyMem_ API)          ]   |
+1 | &lt;----- Python memory (under PyMem manager's control) ------&gt; |   |
    __________________________________________________________________
   [    Underlying general-purpose allocator (ex: C library malloc)   ]
 0 | &lt;------ Virtual memory allocated for the python process -------&gt; |

   =========================================================================
    _______________________________________________________________________
   [                OS-specific Virtual Memory Manager (VMM)               ]
-1 | &lt;--- Kernel dynamic storage allocation &amp; management (page-based) ---&gt; |
    __________________________________   __________________________________
   [                                  ] [                                  ]
-2 | &lt;-- Physical memory: ROM/RAM --&gt; | | &lt;-- Secondary storage (swap) --&gt; |

*/</comment>
<comment type="block">/*==========================================================================*/</comment>

<comment type="block">/* A fast, special-purpose memory allocator for small blocks, to be used
   on top of a general-purpose malloc -- heavily based on previous art. */</comment>

<comment type="block">/* Vladimir Marangozov -- August 2000 */</comment>

<comment type="block">/*
 * "Memory management is where the rubber meets the road -- if we do the wrong
 * thing at any level, the results will not be good. And if we don't make the
 * levels work well together, we are in serious trouble." (1)
 *
 * (1) Paul R. Wilson, Mark S. Johnstone, Michael Neely, and David Boles,
 *    "Dynamic Storage Allocation: A Survey and Critical Review",
 *    in Proc. 1995 Int'l. Workshop on Memory Management, September 1995.
 */</comment>

<comment type="block">/* #undef WITH_MEMORY_LIMITS */</comment>		<comment type="block">/* disable mem limit checks  */</comment>

<comment type="block">/*==========================================================================*/</comment>

<comment type="block">/*
 * Allocation strategy abstract:
 *
 * For small requests, the allocator sub-allocates &lt;Big&gt; blocks of memory.
 * Requests greater than 256 bytes are routed to the system's allocator.
 *
 * Small requests are grouped in size classes spaced 8 bytes apart, due
 * to the required valid alignment of the returned address. Requests of
 * a particular size are serviced from memory pools of 4K (one VMM page).
 * Pools are fragmented on demand and contain free lists of blocks of one
 * particular size class. In other words, there is a fixed-size allocator
 * for each size class. Free pools are shared by the different allocators
 * thus minimizing the space reserved for a particular size class.
 *
 * This allocation strategy is a variant of what is known as "simple
 * segregated storage based on array of free lists". The main drawback of
 * simple segregated storage is that we might end up with lot of reserved
 * memory for the different free lists, which degenerate in time. To avoid
 * this, we partition each free list in pools and we share dynamically the
 * reserved space between all free lists. This technique is quite efficient
 * for memory intensive programs which allocate mainly small-sized blocks.
 *
 * For small requests we have the following table:
 *
 * Request in bytes	Size of allocated block      Size class idx
 * ----------------------------------------------------------------
 *        1-8                     8                       0
 *	  9-16                   16                       1
 *	 17-24                   24                       2
 *	 25-32                   32                       3
 *	 33-40                   40                       4
 *	 41-48                   48                       5
 *	 49-56                   56                       6
 *	 57-64                   64                       7
 *	 65-72                   72                       8
 *	  ...                   ...                     ...
 *	241-248                 248                      30
 *	249-256                 256                      31
 *
 *	0, 257 and up: routed to the underlying allocator.
 */</comment>

<comment type="block">/*==========================================================================*/</comment>

<comment type="block">/*
 * -- Main tunable settings section --
 */</comment>

<comment type="block">/*
 * Alignment of addresses returned to the user. 8-bytes alignment works
 * on most current architectures (with 32-bit or 64-bit address busses).
 * The alignment value is also used for grouping small requests in size
 * classes spaced ALIGNMENT bytes apart.
 *
 * You shouldn't change this unless you know what you are doing.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ALIGNMENT</name></cpp:macro>		<cpp:value>8</cpp:value></cpp:define>		<comment type="block">/* must be 2^N */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ALIGNMENT_SHIFT</name></cpp:macro>		<cpp:value>3</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ALIGNMENT_MASK</name></cpp:macro>		<cpp:value>(ALIGNMENT - 1)</cpp:value></cpp:define>

<comment type="block">/* Return the number of bytes in size class I, as a uint. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INDEX2SIZE</name><parameter_list>(<param><type><name>I</name></type></param>)</parameter_list></cpp:macro> <cpp:value>(((uint)(I) + 1) &lt;&lt; ALIGNMENT_SHIFT)</cpp:value></cpp:define>

<comment type="block">/*
 * Max size threshold below which malloc requests are considered to be
 * small enough in order to use preallocated memory pools. You can tune
 * this value according to your application behaviour and memory needs.
 *
 * The following invariants must hold:
 *	1) ALIGNMENT &lt;= SMALL_REQUEST_THRESHOLD &lt;= 256
 *	2) SMALL_REQUEST_THRESHOLD is evenly divisible by ALIGNMENT
 *
 * Although not required, for better performance and space efficiency,
 * it is recommended that SMALL_REQUEST_THRESHOLD is set to a power of 2.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SMALL_REQUEST_THRESHOLD</name></cpp:macro>	<cpp:value>256</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NB_SMALL_SIZE_CLASSES</name></cpp:macro>	<cpp:value>(SMALL_REQUEST_THRESHOLD / ALIGNMENT)</cpp:value></cpp:define>

<comment type="block">/*
 * The system's VMM page size can be obtained on most unices with a
 * getpagesize() call or deduced from various header files. To make
 * things simpler, we assume that it is 4K, which is OK for most systems.
 * It is probably better if this is the native page size, but it doesn't
 * have to be.  In theory, if SYSTEM_PAGE_SIZE is larger than the native page
 * size, then `POOL_ADDR(p)-&gt;arenaindex' could rarely cause a segmentation
 * violation fault.  4K is apparently OK for all the platforms that python
 * currently targets.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SYSTEM_PAGE_SIZE</name></cpp:macro>	<cpp:value>(4 * 1024)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SYSTEM_PAGE_SIZE_MASK</name></cpp:macro>	<cpp:value>(SYSTEM_PAGE_SIZE - 1)</cpp:value></cpp:define>

<comment type="block">/*
 * Maximum amount of memory managed by the allocator for small requests.
 */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WITH_MEMORY_LIMITS</name></cpp:ifdef>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SMALL_MEMORY_LIMIT</name></cpp:ifndef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SMALL_MEMORY_LIMIT</name></cpp:macro>	<cpp:value>(64 * 1024 * 1024)</cpp:value></cpp:define>	<comment type="block">/* 64 MB -- more? */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
 * The allocator sub-allocates &lt;Big&gt; blocks of memory (called arenas) aligned
 * on a page boundary. This is a reserved virtual address space for the
 * current process (obtained through a malloc call). In no way this means
 * that the memory arenas will be used entirely. A malloc(&lt;Big&gt;) is usually
 * an address range reservation for &lt;Big&gt; bytes, unless all pages within this
 * space are referenced subsequently. So malloc'ing big blocks and not using
 * them does not mean "wasting memory". It's an addressable range wastage...
 *
 * Therefore, allocating arenas with malloc is not optimal, because there is
 * some address space wastage, but this is the most portable way to request
 * memory from the system across various platforms.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ARENA_SIZE</name></cpp:macro>		<cpp:value>(256 &lt;&lt; 10)</cpp:value></cpp:define>	<comment type="block">/* 256KB */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WITH_MEMORY_LIMITS</name></cpp:ifdef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAX_ARENAS</name></cpp:macro>		<cpp:value>(SMALL_MEMORY_LIMIT / ARENA_SIZE)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
 * Size of the pools used for small blocks. Should be a power of 2,
 * between 1K and SYSTEM_PAGE_SIZE, that is: 1k, 2k, 4k.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>POOL_SIZE</name></cpp:macro>		<cpp:value>SYSTEM_PAGE_SIZE</cpp:value></cpp:define>	<comment type="block">/* must be 2^N */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>POOL_SIZE_MASK</name></cpp:macro>		<cpp:value>SYSTEM_PAGE_SIZE_MASK</cpp:value></cpp:define>

<comment type="block">/*
 * -- End of tunable settings section --
 */</comment>

<comment type="block">/*==========================================================================*/</comment>

<comment type="block">/*
 * Locking
 *
 * To reduce lock contention, it would probably be better to refine the
 * crude function locking with per size class locking. I'm not positive
 * however, whether it's worth switching to such locking policy because
 * of the performance penalty it might introduce.
 *
 * The following macros describe the simplest (should also be the fastest)
 * lock object on a particular platform and the init/fini/lock/unlock
 * operations on it. The locks defined here are not expected to be recursive
 * because it is assumed that they will always be called in the order:
 * INIT, [LOCK, UNLOCK]*, FINI.
 */</comment>

<comment type="block">/*
 * Python's threads are serialized, so object malloc locking is disabled.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SIMPLELOCK_DECL</name><parameter_list>(<param><type><name>lock</name></type></param>)</parameter_list></cpp:macro></cpp:define>	<comment type="block">/* simple lock declaration		*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SIMPLELOCK_INIT</name><parameter_list>(<param><type><name>lock</name></type></param>)</parameter_list></cpp:macro></cpp:define>	<comment type="block">/* allocate (if needed) and initialize	*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SIMPLELOCK_FINI</name><parameter_list>(<param><type><name>lock</name></type></param>)</parameter_list></cpp:macro></cpp:define>	<comment type="block">/* free/destroy an existing lock 	*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SIMPLELOCK_LOCK</name><parameter_list>(<param><type><name>lock</name></type></param>)</parameter_list></cpp:macro></cpp:define>	<comment type="block">/* acquire released lock */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SIMPLELOCK_UNLOCK</name><parameter_list>(<param><type><name>lock</name></type></param>)</parameter_list></cpp:macro></cpp:define>	<comment type="block">/* release acquired lock */</comment>

<comment type="block">/*
 * Basic types
 * I don't care if these are defined in &lt;sys/types.h&gt; or elsewhere. Axiom.
 */</comment>
<cpp:undef>#<cpp:directive>undef</cpp:directive>  <name>uchar</name></cpp:undef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>uchar</name></cpp:macro>	<cpp:value>unsigned char</cpp:value></cpp:define>	<comment type="block">/* assuming == 8 bits  */</comment>

<cpp:undef>#<cpp:directive>undef</cpp:directive>  <name>uint</name></cpp:undef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>uint</name></cpp:macro>	<cpp:value>unsigned int</cpp:value></cpp:define>	<comment type="block">/* assuming &gt;= 16 bits */</comment>

<cpp:undef>#<cpp:directive>undef</cpp:directive>  <name>ulong</name></cpp:undef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ulong</name></cpp:macro>	<cpp:value>unsigned long</cpp:value></cpp:define>	<comment type="block">/* assuming &gt;= 32 bits */</comment>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>uptr</name></cpp:undef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>uptr</name></cpp:macro>	<cpp:value>Py_uintptr_t</cpp:value></cpp:define>

<comment type="block">/* When you say memory, my mind reasons in terms of (pointers to) blocks */</comment>
<typedef>typedef <type><name>uchar</name></type> <name>block</name>;</typedef>

<comment type="block">/* Pool for small blocks. */</comment>
<struct>struct <name>pool_header</name> <block>{
	<union>union <block>{ <decl_stmt><decl><type><name>block</name> *</type><name>_padding</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>uint</name></type> <name>count</name></decl>;</decl_stmt> }</block> <decl><name>ref</name></decl>;</union>	<comment type="block">/* number of allocated blocks    */</comment>
	<decl_stmt><decl><type><name>block</name> *</type><name>freeblock</name></decl>;</decl_stmt>		<comment type="block">/* pool's free list head         */</comment>
	<decl_stmt><decl><type>struct <name>pool_header</name> *</type><name>nextpool</name></decl>;</decl_stmt>	<comment type="block">/* next pool of this size class  */</comment>
	<decl_stmt><decl><type>struct <name>pool_header</name> *</type><name>prevpool</name></decl>;</decl_stmt>	<comment type="block">/* previous pool       ""        */</comment>
	<decl_stmt><decl><type><name>uint</name></type> <name>arenaindex</name></decl>;</decl_stmt>		<comment type="block">/* index into arenas of base adr */</comment>
	<decl_stmt><decl><type><name>uint</name></type> <name>szidx</name></decl>;</decl_stmt>			<comment type="block">/* block size class index	 */</comment>
	<decl_stmt><decl><type><name>uint</name></type> <name>nextoffset</name></decl>;</decl_stmt>		<comment type="block">/* bytes to virgin block	 */</comment>
	<decl_stmt><decl><type><name>uint</name></type> <name>maxnextoffset</name></decl>;</decl_stmt>		<comment type="block">/* largest valid nextoffset	 */</comment>
}</block>;</struct>

<typedef>typedef <type>struct <name>pool_header</name> *</type><name>poolp</name>;</typedef>

<comment type="block">/* Record keeping for arenas. */</comment>
<struct>struct <name>arena_object</name> <block>{
	<comment type="block">/* The address of the arena, as returned by malloc.  Note that 0
	 * will never be returned by a successful malloc, and is used
	 * here to mark an arena_object that doesn't correspond to an
	 * allocated arena.
	 */</comment>
	<decl_stmt><decl><type><name>uptr</name></type> <name>address</name></decl>;</decl_stmt>

	<comment type="block">/* Pool-aligned pointer to the next pool to be carved off. */</comment>
	<decl_stmt><decl><type><name>block</name>*</type> <name>pool_address</name></decl>;</decl_stmt>

	<comment type="block">/* The number of available pools in the arena:  free pools + never-
	 * allocated pools.
	 */</comment>
	<decl_stmt><decl><type><name>uint</name></type> <name>nfreepools</name></decl>;</decl_stmt>

	<comment type="block">/* The total number of pools in the arena, whether or not available. */</comment>
	<decl_stmt><decl><type><name>uint</name></type> <name>ntotalpools</name></decl>;</decl_stmt>

	<comment type="block">/* Singly-linked list of available pools. */</comment>
	<decl_stmt><decl><type>struct <name>pool_header</name>*</type> <name>freepools</name></decl>;</decl_stmt>

	<comment type="block">/* Whenever this arena_object is not associated with an allocated
	 * arena, the nextarena member is used to link all unassociated
	 * arena_objects in the singly-linked `unused_arena_objects` list.
	 * The prevarena member is unused in this case.
	 *
	 * When this arena_object is associated with an allocated arena
	 * with at least one available pool, both members are used in the
	 * doubly-linked `usable_arenas` list, which is maintained in
	 * increasing order of `nfreepools` values.
	 *
	 * Else this arena_object is associated with an allocated arena
	 * all of whose pools are in use.  `nextarena` and `prevarena`
	 * are both meaningless in this case.
	 */</comment>
	<decl_stmt><decl><type>struct <name>arena_object</name>*</type> <name>nextarena</name></decl>;</decl_stmt>
	<decl_stmt><decl><type>struct <name>arena_object</name>*</type> <name>prevarena</name></decl>;</decl_stmt>
}</block>;</struct>

<cpp:undef>#<cpp:directive>undef</cpp:directive>  <name>ROUNDUP</name></cpp:undef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ROUNDUP</name><parameter_list>(<param><type><name>x</name></type></param>)</parameter_list></cpp:macro>		<cpp:value>(((x) + ALIGNMENT_MASK) &amp; ~ALIGNMENT_MASK)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>POOL_OVERHEAD</name></cpp:macro>		<cpp:value>ROUNDUP(sizeof(struct pool_header))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DUMMY_SIZE_IDX</name></cpp:macro>		<cpp:value>0xffff</cpp:value></cpp:define>	<comment type="block">/* size class of newly cached pools */</comment>

<comment type="block">/* Round pointer P down to the closest pool-aligned address &lt;= P, as a poolp */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>POOL_ADDR</name><parameter_list>(<param><type><name>P</name></type></param>)</parameter_list></cpp:macro> <cpp:value>((poolp)((uptr)(P) &amp; ~(uptr)POOL_SIZE_MASK))</cpp:value></cpp:define>

<comment type="block">/* Return total number of blocks in pool of size index I, as a uint. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NUMBLOCKS</name><parameter_list>(<param><type><name>I</name></type></param>)</parameter_list></cpp:macro> <cpp:value>((uint)(POOL_SIZE - POOL_OVERHEAD) / INDEX2SIZE(I))</cpp:value></cpp:define>

<comment type="block">/*==========================================================================*/</comment>

<comment type="block">/*
 * This malloc lock
 */</comment>
<macro><name>SIMPLELOCK_DECL</name><argument_list>(<argument>_malloc_lock</argument>)</argument_list></macro>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LOCK</name><parameter_list>()</parameter_list></cpp:macro>		<cpp:value>SIMPLELOCK_LOCK(_malloc_lock)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>UNLOCK</name><parameter_list>()</parameter_list></cpp:macro>	<cpp:value>SIMPLELOCK_UNLOCK(_malloc_lock)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LOCK_INIT</name><parameter_list>()</parameter_list></cpp:macro>	<cpp:value>SIMPLELOCK_INIT(_malloc_lock)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LOCK_FINI</name><parameter_list>()</parameter_list></cpp:macro>	<cpp:value>SIMPLELOCK_FINI(_malloc_lock)</cpp:value></cpp:define>

<comment type="block">/*
 * Pool table -- headed, circular, doubly-linked lists of partially used pools.

This is involved.  For an index i, usedpools[i+i] is the header for a list of
all partially used pools holding small blocks with "size class idx" i. So
usedpools[0] corresponds to blocks of size 8, usedpools[2] to blocks of size
16, and so on:  index 2*i &lt;-&gt; blocks of size (i+1)&lt;&lt;ALIGNMENT_SHIFT.

Pools are carved off an arena's highwater mark (an arena_object's pool_address
member) as needed.  Once carved off, a pool is in one of three states forever
after:

used == partially used, neither empty nor full
    At least one block in the pool is currently allocated, and at least one
    block in the pool is not currently allocated (note this implies a pool
    has room for at least two blocks).
    This is a pool's initial state, as a pool is created only when malloc
    needs space.
    The pool holds blocks of a fixed size, and is in the circular list headed
    at usedpools[i] (see above).  It's linked to the other used pools of the
    same size class via the pool_header's nextpool and prevpool members.
    If all but one block is currently allocated, a malloc can cause a
    transition to the full state.  If all but one block is not currently
    allocated, a free can cause a transition to the empty state.

full == all the pool's blocks are currently allocated
    On transition to full, a pool is unlinked from its usedpools[] list.
    It's not linked to from anything then anymore, and its nextpool and
    prevpool members are meaningless until it transitions back to used.
    A free of a block in a full pool puts the pool back in the used state.
    Then it's linked in at the front of the appropriate usedpools[] list, so
    that the next allocation for its size class will reuse the freed block.

empty == all the pool's blocks are currently available for allocation
    On transition to empty, a pool is unlinked from its usedpools[] list,
    and linked to the front of its arena_object's singly-linked freepools list,
    via its nextpool member.  The prevpool member has no meaning in this case.
    Empty pools have no inherent size class:  the next time a malloc finds
    an empty list in usedpools[], it takes the first pool off of freepools.
    If the size class needed happens to be the same as the size class the pool
    last had, some pool initialization can be skipped.


Block Management

Blocks within pools are again carved out as needed.  pool-&gt;freeblock points to
the start of a singly-linked list of free blocks within the pool.  When a
block is freed, it's inserted at the front of its pool's freeblock list.  Note
that the available blocks in a pool are *not* linked all together when a pool
is initialized.  Instead only "the first two" (lowest addresses) blocks are
set up, returning the first such block, and setting pool-&gt;freeblock to a
one-block list holding the second such block.  This is consistent with that
pymalloc strives at all levels (arena, pool, and block) never to touch a piece
of memory until it's actually needed.

So long as a pool is in the used state, we're certain there *is* a block
available for allocating, and pool-&gt;freeblock is not NULL.  If pool-&gt;freeblock
points to the end of the free list before we've carved the entire pool into
blocks, that means we simply haven't yet gotten to one of the higher-address
blocks.  The offset from the pool_header to the start of "the next" virgin
block is stored in the pool_header nextoffset member, and the largest value
of nextoffset that makes sense is stored in the maxnextoffset member when a
pool is initialized.  All the blocks in a pool have been passed out at least
once when and only when nextoffset &gt; maxnextoffset.


Major obscurity:  While the usedpools vector is declared to have poolp
entries, it doesn't really.  It really contains two pointers per (conceptual)
poolp entry, the nextpool and prevpool members of a pool_header.  The
excruciating initialization code below fools C so that

    usedpool[i+i]

"acts like" a genuine poolp, but only so long as you only reference its
nextpool and prevpool members.  The "- 2*sizeof(block *)" gibberish is
compensating for that a pool_header's nextpool and prevpool members
immediately follow a pool_header's first two members:

	union { block *_padding;
		uint count; } ref;
	block *freeblock;

each of which consume sizeof(block *) bytes.  So what usedpools[i+i] really
contains is a fudged-up pointer p such that *if* C believes it's a poolp
pointer, then p-&gt;nextpool and p-&gt;prevpool are both p (meaning that the headed
circular list is empty).

It's unclear why the usedpools setup is so convoluted.  It could be to
minimize the amount of cache required to hold this heavily-referenced table
(which only *needs* the two interpool pointer members of a pool_header). OTOH,
referencing code has to remember to "double the index" and doing so isn't
free, usedpools[0] isn't a strictly legal pointer, and we're crucially relying
on that C doesn't insert any padding anywhere in a pool_header at or before
the prevpool member.
**************************************************************************** */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PTA</name><parameter_list>(<param><type><name>x</name></type></param>)</parameter_list></cpp:macro>	<cpp:value>((poolp )((uchar *)&amp;(usedpools[2*(x)]) - 2*sizeof(block *)))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PT</name><parameter_list>(<param><type><name>x</name></type></param>)</parameter_list></cpp:macro>	<cpp:value>PTA(x), PTA(x)</cpp:value></cpp:define>

<decl_stmt><decl><type><specifier>static</specifier> <name>poolp</name></type> <name><name>usedpools</name><index>[<expr>2 * ((<name>NB_SMALL_SIZE_CLASSES</name> + 7) / 8) * 8</expr>]</index></name> <init>= <expr><block>{
	<expr><call><name>PT</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>, <expr><call><name>PT</name><argument_list>(<argument><expr>1</expr></argument>)</argument_list></call></expr>, <expr><call><name>PT</name><argument_list>(<argument><expr>2</expr></argument>)</argument_list></call></expr>, <expr><call><name>PT</name><argument_list>(<argument><expr>3</expr></argument>)</argument_list></call></expr>, <expr><call><name>PT</name><argument_list>(<argument><expr>4</expr></argument>)</argument_list></call></expr>, <expr><call><name>PT</name><argument_list>(<argument><expr>5</expr></argument>)</argument_list></call></expr>, <expr><call><name>PT</name><argument_list>(<argument><expr>6</expr></argument>)</argument_list></call></expr>, <expr><call><name>PT</name><argument_list>(<argument><expr>7</expr></argument>)</argument_list></call></expr>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>NB_SMALL_SIZE_CLASSES</name> &gt; 8</expr></cpp:if>
	, <expr><call><name>PT</name><argument_list>(<argument><expr>8</expr></argument>)</argument_list></call></expr>, <expr><call><name>PT</name><argument_list>(<argument><expr>9</expr></argument>)</argument_list></call></expr>, <expr><call><name>PT</name><argument_list>(<argument><expr>10</expr></argument>)</argument_list></call></expr>, <expr><call><name>PT</name><argument_list>(<argument><expr>11</expr></argument>)</argument_list></call></expr>, <expr><call><name>PT</name><argument_list>(<argument><expr>12</expr></argument>)</argument_list></call></expr>, <expr><call><name>PT</name><argument_list>(<argument><expr>13</expr></argument>)</argument_list></call></expr>, <expr><call><name>PT</name><argument_list>(<argument><expr>14</expr></argument>)</argument_list></call></expr>, <expr><call><name>PT</name><argument_list>(<argument><expr>15</expr></argument>)</argument_list></call></expr>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>NB_SMALL_SIZE_CLASSES</name> &gt; 16</expr></cpp:if>
	, <expr><call><name>PT</name><argument_list>(<argument><expr>16</expr></argument>)</argument_list></call></expr>, <expr><call><name>PT</name><argument_list>(<argument><expr>17</expr></argument>)</argument_list></call></expr>, <expr><call><name>PT</name><argument_list>(<argument><expr>18</expr></argument>)</argument_list></call></expr>, <expr><call><name>PT</name><argument_list>(<argument><expr>19</expr></argument>)</argument_list></call></expr>, <expr><call><name>PT</name><argument_list>(<argument><expr>20</expr></argument>)</argument_list></call></expr>, <expr><call><name>PT</name><argument_list>(<argument><expr>21</expr></argument>)</argument_list></call></expr>, <expr><call><name>PT</name><argument_list>(<argument><expr>22</expr></argument>)</argument_list></call></expr>, <expr><call><name>PT</name><argument_list>(<argument><expr>23</expr></argument>)</argument_list></call></expr>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>NB_SMALL_SIZE_CLASSES</name> &gt; 24</expr></cpp:if>
	, <expr><call><name>PT</name><argument_list>(<argument><expr>24</expr></argument>)</argument_list></call></expr>, <expr><call><name>PT</name><argument_list>(<argument><expr>25</expr></argument>)</argument_list></call></expr>, <expr><call><name>PT</name><argument_list>(<argument><expr>26</expr></argument>)</argument_list></call></expr>, <expr><call><name>PT</name><argument_list>(<argument><expr>27</expr></argument>)</argument_list></call></expr>, <expr><call><name>PT</name><argument_list>(<argument><expr>28</expr></argument>)</argument_list></call></expr>, <expr><call><name>PT</name><argument_list>(<argument><expr>29</expr></argument>)</argument_list></call></expr>, <expr><call><name>PT</name><argument_list>(<argument><expr>30</expr></argument>)</argument_list></call></expr>, <expr><call><name>PT</name><argument_list>(<argument><expr>31</expr></argument>)</argument_list></call></expr>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>NB_SMALL_SIZE_CLASSES</name> &gt; 32</expr></cpp:if>
	, <expr><call><name>PT</name><argument_list>(<argument><expr>32</expr></argument>)</argument_list></call></expr>, <expr><call><name>PT</name><argument_list>(<argument><expr>33</expr></argument>)</argument_list></call></expr>, <expr><call><name>PT</name><argument_list>(<argument><expr>34</expr></argument>)</argument_list></call></expr>, <expr><call><name>PT</name><argument_list>(<argument><expr>35</expr></argument>)</argument_list></call></expr>, <expr><call><name>PT</name><argument_list>(<argument><expr>36</expr></argument>)</argument_list></call></expr>, <expr><call><name>PT</name><argument_list>(<argument><expr>37</expr></argument>)</argument_list></call></expr>, <expr><call><name>PT</name><argument_list>(<argument><expr>38</expr></argument>)</argument_list></call></expr>, <expr><call><name>PT</name><argument_list>(<argument><expr>39</expr></argument>)</argument_list></call></expr>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>NB_SMALL_SIZE_CLASSES</name> &gt; 40</expr></cpp:if>
	, <expr><call><name>PT</name><argument_list>(<argument><expr>40</expr></argument>)</argument_list></call></expr>, <expr><call><name>PT</name><argument_list>(<argument><expr>41</expr></argument>)</argument_list></call></expr>, <expr><call><name>PT</name><argument_list>(<argument><expr>42</expr></argument>)</argument_list></call></expr>, <expr><call><name>PT</name><argument_list>(<argument><expr>43</expr></argument>)</argument_list></call></expr>, <expr><call><name>PT</name><argument_list>(<argument><expr>44</expr></argument>)</argument_list></call></expr>, <expr><call><name>PT</name><argument_list>(<argument><expr>45</expr></argument>)</argument_list></call></expr>, <expr><call><name>PT</name><argument_list>(<argument><expr>46</expr></argument>)</argument_list></call></expr>, <expr><call><name>PT</name><argument_list>(<argument><expr>47</expr></argument>)</argument_list></call></expr>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>NB_SMALL_SIZE_CLASSES</name> &gt; 48</expr></cpp:if>
	, <expr><call><name>PT</name><argument_list>(<argument><expr>48</expr></argument>)</argument_list></call></expr>, <expr><call><name>PT</name><argument_list>(<argument><expr>49</expr></argument>)</argument_list></call></expr>, <expr><call><name>PT</name><argument_list>(<argument><expr>50</expr></argument>)</argument_list></call></expr>, <expr><call><name>PT</name><argument_list>(<argument><expr>51</expr></argument>)</argument_list></call></expr>, <expr><call><name>PT</name><argument_list>(<argument><expr>52</expr></argument>)</argument_list></call></expr>, <expr><call><name>PT</name><argument_list>(<argument><expr>53</expr></argument>)</argument_list></call></expr>, <expr><call><name>PT</name><argument_list>(<argument><expr>54</expr></argument>)</argument_list></call></expr>, <expr><call><name>PT</name><argument_list>(<argument><expr>55</expr></argument>)</argument_list></call></expr>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>NB_SMALL_SIZE_CLASSES</name> &gt; 56</expr></cpp:if>
	, <expr><call><name>PT</name><argument_list>(<argument><expr>56</expr></argument>)</argument_list></call></expr>, <expr><call><name>PT</name><argument_list>(<argument><expr>57</expr></argument>)</argument_list></call></expr>, <expr><call><name>PT</name><argument_list>(<argument><expr>58</expr></argument>)</argument_list></call></expr>, <expr><call><name>PT</name><argument_list>(<argument><expr>59</expr></argument>)</argument_list></call></expr>, <expr><call><name>PT</name><argument_list>(<argument><expr>60</expr></argument>)</argument_list></call></expr>, <expr><call><name>PT</name><argument_list>(<argument><expr>61</expr></argument>)</argument_list></call></expr>, <expr><call><name>PT</name><argument_list>(<argument><expr>62</expr></argument>)</argument_list></call></expr>, <macro><name>PT</name><argument_list>(<argument>63</argument>)</argument_list></macro>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* NB_SMALL_SIZE_CLASSES &gt; 56 */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* NB_SMALL_SIZE_CLASSES &gt; 48 */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* NB_SMALL_SIZE_CLASSES &gt; 40 */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* NB_SMALL_SIZE_CLASSES &gt; 32 */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* NB_SMALL_SIZE_CLASSES &gt; 24 */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* NB_SMALL_SIZE_CLASSES &gt; 16 */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* NB_SMALL_SIZE_CLASSES &gt;  8 */</comment>
}</block></expr></init></decl>;</decl_stmt>

<comment type="block">/*==========================================================================
Arena management.

`arenas` is a vector of arena_objects.  It contains maxarenas entries, some of
which may not be currently used (== they're arena_objects that aren't
currently associated with an allocated arena).  Note that arenas proper are
separately malloc'ed.

Prior to Python 2.5, arenas were never free()'ed.  Starting with Python 2.5,
we do try to free() arenas, and use some mild heuristic strategies to increase
the likelihood that arenas eventually can be freed.

unused_arena_objects

    This is a singly-linked list of the arena_objects that are currently not
    being used (no arena is associated with them).  Objects are taken off the
    head of the list in new_arena(), and are pushed on the head of the list in
    PyObject_Free() when the arena is empty.  Key invariant:  an arena_object
    is on this list if and only if its .address member is 0.

usable_arenas

    This is a doubly-linked list of the arena_objects associated with arenas
    that have pools available.  These pools are either waiting to be reused,
    or have not been used before.  The list is sorted to have the most-
    allocated arenas first (ascending order based on the nfreepools member).
    This means that the next allocation will come from a heavily used arena,
    which gives the nearly empty arenas a chance to be returned to the system.
    In my unscientific tests this dramatically improved the number of arenas
    that could be freed.

Note that an arena_object associated with an arena all of whose pools are
currently in use isn't on either list.
*/</comment>

<comment type="block">/* Array of objects used to track chunks of memory (arenas). */</comment>
<decl_stmt><decl><type><specifier>static</specifier> struct <name>arena_object</name>*</type> <name>arenas</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<comment type="block">/* Number of slots currently allocated in the `arenas` vector. */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>uint</name></type> <name>maxarenas</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>

<comment type="block">/* The head of the singly-linked, NULL-terminated list of available
 * arena_objects.
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> struct <name>arena_object</name>*</type> <name>unused_arena_objects</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<comment type="block">/* The head of the doubly-linked, NULL-terminated at each end, list of
 * arena_objects associated with arenas that have pools available.
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> struct <name>arena_object</name>*</type> <name>usable_arenas</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<comment type="block">/* How many arena_objects do we initially allocate?
 * 16 = can allocate 16 arenas = 16 * ARENA_SIZE = 4MB before growing the
 * `arenas` vector.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INITIAL_ARENA_OBJECTS</name></cpp:macro> <cpp:value>16</cpp:value></cpp:define>

<comment type="block">/* Number of arenas allocated that haven't been free()'d. */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>size_t</name></type> <name>narenas_currently_allocated</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PYMALLOC_DEBUG</name></cpp:ifdef>
<comment type="block">/* Total number of times malloc() called to allocate an arena. */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>size_t</name></type> <name>ntimes_arena_allocated</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<comment type="block">/* High water mark (max value ever seen) for narenas_currently_allocated. */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>size_t</name></type> <name>narenas_highwater</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* Allocate a new arena.  If we run out of memory, return NULL.  Else
 * allocate a new arena, and return the address of an arena_object
 * describing the new arena.  It's expected that the caller will set
 * `usable_arenas` to the return value.
 */</comment>
<function><type><specifier>static</specifier> struct <name>arena_object</name>*</type>
<name>new_arena</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type>struct <name>arena_object</name>*</type> <name>arenaobj</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint</name></type> <name>excess</name></decl>;</decl_stmt>	<comment type="block">/* number of bytes above pool alignment */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PYMALLOC_DEBUG</name></cpp:ifdef>
	<if>if <condition>(<expr><call><name>Py_GETENV</name><argument_list>(<argument><expr>"PYTHONMALLOCSTATS"</expr></argument>)</argument_list></call></expr>)</condition><then>
		<expr_stmt><expr><call><name>_PyObject_DebugMallocStats</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<if>if <condition>(<expr><name>unused_arena_objects</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<decl_stmt><decl><type><name>uint</name></type> <name>i</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>uint</name></type> <name>numarenas</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>size_t</name></type> <name>nbytes</name></decl>;</decl_stmt>

		<comment type="block">/* Double the number of arena objects on each allocation.
		 * Note that it's possible for `numarenas` to overflow.
		 */</comment>
		<expr_stmt><expr><name>numarenas</name> = <name>maxarenas</name> ? <name>maxarenas</name> &lt;&lt; 1 : <name>INITIAL_ARENA_OBJECTS</name></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>numarenas</name> &lt;= <name>maxarenas</name></expr>)</condition><then>
			<return>return <expr><name>NULL</name></expr>;</return></then></if>	<comment type="block">/* overflow */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SIZEOF_SIZE_T</name> &lt;= <name>SIZEOF_INT</name></expr></cpp:if>
		<if>if <condition>(<expr><name>numarenas</name> &gt; <name>PY_SIZE_MAX</name> / <sizeof>sizeof<argument_list>(<argument><expr>*<name>arenas</name></expr></argument>)</argument_list></sizeof></expr>)</condition><then>
			<return>return <expr><name>NULL</name></expr>;</return></then></if>	<comment type="block">/* overflow */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		<expr_stmt><expr><name>nbytes</name> = <name>numarenas</name> * <sizeof>sizeof<argument_list>(<argument><expr>*<name>arenas</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
		<expr_stmt><expr><name>arenaobj</name> = (struct <name>arena_object</name> *)<call><name>realloc</name><argument_list>(<argument><expr><name>arenas</name></expr></argument>, <argument><expr><name>nbytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>arenaobj</name> == <name>NULL</name></expr>)</condition><then>
			<return>return <expr><name>NULL</name></expr>;</return></then></if>
		<expr_stmt><expr><name>arenas</name> = <name>arenaobj</name></expr>;</expr_stmt>

		<comment type="block">/* We might need to fix pointers that were copied.  However,
		 * new_arena only gets called when all the pages in the
		 * previous arenas are full.  Thus, there are *no* pointers
		 * into the old array. Thus, we don't have to worry about
		 * invalid pointers.  Just to be sure, some asserts:
		 */</comment>
		<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>usable_arenas</name> == <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>unused_arena_objects</name> == <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Put the new arenas on the unused_arena_objects list. */</comment>
		<for>for (<init><expr><name>i</name> = <name>maxarenas</name></expr>;</init> <condition><expr><name>i</name> &lt; <name>numarenas</name></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>) <block>{
			<expr_stmt><expr><name><name>arenas</name><index>[<expr><name>i</name></expr>]</index></name>.<name>address</name> = 0</expr>;</expr_stmt>	<comment type="block">/* mark as unassociated */</comment>
			<expr_stmt><expr><name><name>arenas</name><index>[<expr><name>i</name></expr>]</index></name>.<name>nextarena</name> = <name>i</name> &lt; <name>numarenas</name> - 1 ?
					       &amp;<name><name>arenas</name><index>[<expr><name>i</name>+1</expr>]</index></name> : <name>NULL</name></expr>;</expr_stmt>
		}</block></for>

		<comment type="block">/* Update globals. */</comment>
		<expr_stmt><expr><name>unused_arena_objects</name> = &amp;<name><name>arenas</name><index>[<expr><name>maxarenas</name></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>maxarenas</name> = <name>numarenas</name></expr>;</expr_stmt>
	}</block></then></if>

	<comment type="block">/* Take the next available arena object off the head of the list. */</comment>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>unused_arena_objects</name> != <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>arenaobj</name> = <name>unused_arena_objects</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>unused_arena_objects</name> = <name><name>arenaobj</name>-&gt;<name>nextarena</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>arenaobj</name>-&gt;<name>address</name></name> == 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>arenaobj</name>-&gt;<name>address</name></name> = (<name>uptr</name>)<call><name>malloc</name><argument_list>(<argument><expr><name>ARENA_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name><name>arenaobj</name>-&gt;<name>address</name></name> == 0</expr>)</condition><then> <block>{
		<comment type="block">/* The allocation failed: return NULL after putting the
		 * arenaobj back.
		 */</comment>
		<expr_stmt><expr><name><name>arenaobj</name>-&gt;<name>nextarena</name></name> = <name>unused_arena_objects</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>unused_arena_objects</name> = <name>arenaobj</name></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>

	<expr_stmt><expr>++<name>narenas_currently_allocated</name></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PYMALLOC_DEBUG</name></cpp:ifdef>
	<expr_stmt><expr>++<name>ntimes_arena_allocated</name></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>narenas_currently_allocated</name> &gt; <name>narenas_highwater</name></expr>)</condition><then>
		<expr_stmt><expr><name>narenas_highwater</name> = <name>narenas_currently_allocated</name></expr>;</expr_stmt></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<expr_stmt><expr><name><name>arenaobj</name>-&gt;<name>freepools</name></name> = <name>NULL</name></expr>;</expr_stmt>
	<comment type="block">/* pool_address &lt;- first pool-aligned address in the arena
	   nfreepools &lt;- number of whole pools that fit after alignment */</comment>
	<expr_stmt><expr><name><name>arenaobj</name>-&gt;<name>pool_address</name></name> = (<name>block</name>*)<name><name>arenaobj</name>-&gt;<name>address</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>arenaobj</name>-&gt;<name>nfreepools</name></name> = <name>ARENA_SIZE</name> / <name>POOL_SIZE</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>POOL_SIZE</name> * <name><name>arenaobj</name>-&gt;<name>nfreepools</name></name> == <name>ARENA_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>excess</name> = <call>(<name>uint</name>)<argument_list>(<argument><expr><name><name>arenaobj</name>-&gt;<name>address</name></name> &amp; <name>POOL_SIZE_MASK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>excess</name> != 0</expr>)</condition><then> <block>{
		<expr_stmt><expr>--<name><name>arenaobj</name>-&gt;<name>nfreepools</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>arenaobj</name>-&gt;<name>pool_address</name></name> += <name>POOL_SIZE</name> - <name>excess</name></expr>;</expr_stmt>
	}</block></then></if>
	<expr_stmt><expr><name><name>arenaobj</name>-&gt;<name>ntotalpools</name></name> = <name><name>arenaobj</name>-&gt;<name>nfreepools</name></name></expr>;</expr_stmt>

	<return>return <expr><name>arenaobj</name></expr>;</return>
}</block></function>

<comment type="block">/*
Py_ADDRESS_IN_RANGE(P, POOL)

Return true if and only if P is an address that was allocated by pymalloc.
POOL must be the pool address associated with P, i.e., POOL = POOL_ADDR(P)
(the caller is asked to compute this because the macro expands POOL more than
once, and for efficiency it's best for the caller to assign POOL_ADDR(P) to a
variable and pass the latter to the macro; because Py_ADDRESS_IN_RANGE is
called on every alloc/realloc/free, micro-efficiency is important here).

Tricky:  Let B be the arena base address associated with the pool, B =
arenas[(POOL)-&gt;arenaindex].address.  Then P belongs to the arena if and only if

	B &lt;= P &lt; B + ARENA_SIZE

Subtracting B throughout, this is true iff

	0 &lt;= P-B &lt; ARENA_SIZE

By using unsigned arithmetic, the "0 &lt;=" half of the test can be skipped.

Obscure:  A PyMem "free memory" function can call the pymalloc free or realloc
before the first arena has been allocated.  `arenas` is still NULL in that
case.  We're relying on that maxarenas is also 0 in that case, so that
(POOL)-&gt;arenaindex &lt; maxarenas  must be false, saving us from trying to index
into a NULL arenas.

Details:  given P and POOL, the arena_object corresponding to P is AO =
arenas[(POOL)-&gt;arenaindex].  Suppose obmalloc controls P.  Then (barring wild
stores, etc), POOL is the correct address of P's pool, AO.address is the
correct base address of the pool's arena, and P must be within ARENA_SIZE of
AO.address.  In addition, AO.address is not 0 (no arena can start at address 0
(NULL)).  Therefore Py_ADDRESS_IN_RANGE correctly reports that obmalloc
controls P.

Now suppose obmalloc does not control P (e.g., P was obtained via a direct
call to the system malloc() or realloc()).  (POOL)-&gt;arenaindex may be anything
in this case -- it may even be uninitialized trash.  If the trash arenaindex
is &gt;= maxarenas, the macro correctly concludes at once that obmalloc doesn't
control P.

Else arenaindex is &lt; maxarena, and AO is read up.  If AO corresponds to an
allocated arena, obmalloc controls all the memory in slice AO.address :
AO.address+ARENA_SIZE.  By case assumption, P is not controlled by obmalloc,
so P doesn't lie in that slice, so the macro correctly reports that P is not
controlled by obmalloc.

Finally, if P is not controlled by obmalloc and AO corresponds to an unused
arena_object (one not currently associated with an allocated arena),
AO.address is 0, and the second test in the macro reduces to:

	P &lt; ARENA_SIZE

If P &gt;= ARENA_SIZE (extremely likely), the macro again correctly concludes
that P is not controlled by obmalloc.  However, if P &lt; ARENA_SIZE, this part
of the test still passes, and the third clause (AO.address != 0) is necessary
to get the correct result:  AO.address is 0 in this case, so the macro
correctly reports that P is not controlled by obmalloc (despite that P lies in
slice AO.address : AO.address + ARENA_SIZE).

Note:  The third (AO.address != 0) clause was added in Python 2.5.  Before
2.5, arenas were never free()'ed, and an arenaindex &lt; maxarena always
corresponded to a currently-allocated arena, so the "P is not controlled by
obmalloc, AO corresponds to an unused arena_object, and P &lt; ARENA_SIZE" case
was impossible.

Note that the logic is excruciating, and reading up possibly uninitialized
memory when P is not controlled by obmalloc (to get at (POOL)-&gt;arenaindex)
creates problems for some memory debuggers.  The overwhelming advantage is
that this test determines whether an arbitrary address is controlled by
obmalloc in a small constant time, independent of the number of arenas
obmalloc controls.  Since this test is needed at every entry point, it's
extremely desirable that it be this fast.
*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Py_ADDRESS_IN_RANGE</name><parameter_list>(<param><type><name>P</name></type></param>, <param><type><name>POOL</name></type></param>)</parameter_list></cpp:macro>			\
	<cpp:value>((POOL)-&gt;arenaindex &lt; maxarenas &amp;&amp;		\
	 (uptr)(P) - arenas[(POOL)-&gt;arenaindex].address &lt; (uptr)ARENA_SIZE &amp;&amp; \
	 arenas[(POOL)-&gt;arenaindex].address != 0)</cpp:value></cpp:define>


<comment type="block">/* This is only useful when running memory debuggers such as
 * Purify or Valgrind.  Uncomment to use.
 *
#define Py_USING_MEMORY_DEBUGGER
 */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>Py_USING_MEMORY_DEBUGGER</name></cpp:ifdef>

<comment type="block">/* Py_ADDRESS_IN_RANGE may access uninitialized memory by design
 * This leads to thousands of spurious warnings when using
 * Purify or Valgrind.  By making a function, we can easily
 * suppress the uninitialized memory reads in this one function.
 * So we won't ignore real errors elsewhere.
 *
 * Disable the macro and use a function.
 */</comment>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>Py_ADDRESS_IN_RANGE</name></cpp:undef>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__GNUC__</name></expr></argument>)</argument_list></call> &amp;&amp; ((<name>__GNUC__</name> == 3) &amp;&amp; (<name>__GNUC_MINOR__</name> &gt;= 1) || \
			  (<name>__GNUC__</name> &gt;= 4))</expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Py_NO_INLINE</name></cpp:macro> <cpp:value>__attribute__((__noinline__))</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Py_NO_INLINE</name></cpp:macro></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* Don't make static, to try to ensure this isn't inlined. */</comment>
<decl_stmt><decl><type><name>int</name></type> <name>Py_ADDRESS_IN_RANGE</name><argument_list>(<argument><expr><name>void</name> *<name>P</name></expr></argument>, <argument><expr><name>poolp</name> <name>pool</name></expr></argument>)</argument_list> <name>Py_NO_INLINE</name></decl>;</decl_stmt>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>Py_NO_INLINE</name></cpp:undef>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*==========================================================================*/</comment>

<comment type="block">/* malloc.  Note that nbytes==0 tries to return a non-NULL pointer, distinct
 * from all other currently live pointers.  This may not be possible.
 */</comment>

<comment type="block">/*
 * The basic blocks are ordered by decreasing execution frequency,
 * which minimizes the number of jumps in the most common cases,
 * improves branching prediction and instruction scheduling (small
 * block allocations typically result in a couple of instructions).
 * Unless the optimizer reorders everything, being too smart...
 */</comment>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>PyObject_Malloc</name></cpp:undef>
<function><type><name>void</name> *</type>
<name>PyObject_Malloc</name><parameter_list>(<param><decl><type><name>size_t</name></type> <name>nbytes</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>block</name> *</type><name>bp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>poolp</name></type> <name>pool</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>poolp</name></type> <name>next</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint</name></type> <name>size</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Limit ourselves to PY_SSIZE_T_MAX bytes to prevent security holes.
	 * Most python internals blindly use a signed Py_ssize_t to track
	 * things without checking for overflows or negatives.
	 * As size_t is unsigned, checking for nbytes &lt; 0 is not required.
	 */</comment>
	<if>if <condition>(<expr><name>nbytes</name> &gt; <name>PY_SSIZE_T_MAX</name></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>

	<comment type="block">/*
	 * This implicitly redirects malloc(0).
	 */</comment>
	<if>if <condition>(<expr>(<name>nbytes</name> - 1) &lt; <name>SMALL_REQUEST_THRESHOLD</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>LOCK</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/*
		 * Most frequent paths first
		 */</comment>
		<expr_stmt><expr><name>size</name> = <call>(<name>uint</name>)<argument_list>(<argument><expr><name>nbytes</name> - 1</expr></argument>)</argument_list></call> &gt;&gt; <name>ALIGNMENT_SHIFT</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>pool</name> = <name><name>usedpools</name><index>[<expr><name>size</name> + <name>size</name></expr>]</index></name></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>pool</name> != <name><name>pool</name>-&gt;<name>nextpool</name></name></expr>)</condition><then> <block>{
			<comment type="block">/*
			 * There is a used pool for this size class.
			 * Pick up the head block of its free list.
			 */</comment>
			<expr_stmt><expr>++<name><name>pool</name>-&gt;<name>ref</name>.<name>count</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name>bp</name> = <name><name>pool</name>-&gt;<name>freeblock</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>bp</name> != <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr>(<name><name>pool</name>-&gt;<name>freeblock</name></name> = *(<name>block</name> **)<name>bp</name>) != <name>NULL</name></expr>)</condition><then> <block>{
				<expr_stmt><expr><call><name>UNLOCK</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<return>return <expr>(<name>void</name> *)<name>bp</name></expr>;</return>
			}</block></then></if>
			<comment type="block">/*
			 * Reached the end of the free list, try to extend it.
			 */</comment>
			<if>if <condition>(<expr><name><name>pool</name>-&gt;<name>nextoffset</name></name> &lt;= <name><name>pool</name>-&gt;<name>maxnextoffset</name></name></expr>)</condition><then> <block>{
				<comment type="block">/* There is room for another block. */</comment>
				<expr_stmt><expr><name><name>pool</name>-&gt;<name>freeblock</name></name> = (<name>block</name>*)<name>pool</name> +
						  <name><name>pool</name>-&gt;<name>nextoffset</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>pool</name>-&gt;<name>nextoffset</name></name> += <call><name>INDEX2SIZE</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr>*<call>(<name>block</name> **)<argument_list>(<argument><expr><name><name>pool</name>-&gt;<name>freeblock</name></name></expr></argument>)</argument_list></call> = <name>NULL</name></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>UNLOCK</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<return>return <expr>(<name>void</name> *)<name>bp</name></expr>;</return>
			}</block></then></if>
			<comment type="block">/* Pool is full, unlink from used pools. */</comment>
			<expr_stmt><expr><name>next</name> = <name><name>pool</name>-&gt;<name>nextpool</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name>pool</name> = <name><name>pool</name>-&gt;<name>prevpool</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>next</name>-&gt;<name>prevpool</name></name> = <name>pool</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>pool</name>-&gt;<name>nextpool</name></name> = <name>next</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>UNLOCK</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<return>return <expr>(<name>void</name> *)<name>bp</name></expr>;</return>
		}</block></then></if>

		<comment type="block">/* There isn't a pool of the right size class immediately
		 * available:  use a free pool.
		 */</comment>
		<if>if <condition>(<expr><name>usable_arenas</name> == <name>NULL</name></expr>)</condition><then> <block>{
			<comment type="block">/* No arena has a free pool:  allocate a new arena. */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WITH_MEMORY_LIMITS</name></cpp:ifdef>
			<if>if <condition>(<expr><name>narenas_currently_allocated</name> &gt;= <name>MAX_ARENAS</name></expr>)</condition><then> <block>{
				<expr_stmt><expr><call><name>UNLOCK</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<goto>goto <name>redirect</name>;</goto>
			}</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
			<expr_stmt><expr><name>usable_arenas</name> = <call><name>new_arena</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><name>usable_arenas</name> == <name>NULL</name></expr>)</condition><then> <block>{
				<expr_stmt><expr><call><name>UNLOCK</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<goto>goto <name>redirect</name>;</goto>
			}</block></then></if>
			<expr_stmt><expr><name><name>usable_arenas</name>-&gt;<name>nextarena</name></name> =
				<name><name>usable_arenas</name>-&gt;<name>prevarena</name></name> = <name>NULL</name></expr>;</expr_stmt>
		}</block></then></if>
		<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>usable_arenas</name>-&gt;<name>address</name></name> != 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Try to get a cached free pool. */</comment>
		<expr_stmt><expr><name>pool</name> = <name><name>usable_arenas</name>-&gt;<name>freepools</name></name></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>pool</name> != <name>NULL</name></expr>)</condition><then> <block>{
			<comment type="block">/* Unlink from cached pools. */</comment>
			<expr_stmt><expr><name><name>usable_arenas</name>-&gt;<name>freepools</name></name> = <name><name>pool</name>-&gt;<name>nextpool</name></name></expr>;</expr_stmt>

			<comment type="block">/* This arena already had the smallest nfreepools
			 * value, so decreasing nfreepools doesn't change
			 * that, and we don't need to rearrange the
			 * usable_arenas list.  However, if the arena has
			 * become wholly allocated, we need to remove its
			 * arena_object from usable_arenas.
			 */</comment>
			<expr_stmt><expr>--<name><name>usable_arenas</name>-&gt;<name>nfreepools</name></name></expr>;</expr_stmt>
			<if>if <condition>(<expr><name><name>usable_arenas</name>-&gt;<name>nfreepools</name></name> == 0</expr>)</condition><then> <block>{
				<comment type="block">/* Wholly allocated:  remove. */</comment>
				<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>usable_arenas</name>-&gt;<name>freepools</name></name> == <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>usable_arenas</name>-&gt;<name>nextarena</name></name> == <name>NULL</name> ||
				       <name><name>usable_arenas</name>-&gt;<name>nextarena</name>-&gt;<name>prevarena</name></name> ==
					   <name>usable_arenas</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><name>usable_arenas</name> = <name><name>usable_arenas</name>-&gt;<name>nextarena</name></name></expr>;</expr_stmt>
				<if>if <condition>(<expr><name>usable_arenas</name> != <name>NULL</name></expr>)</condition><then> <block>{
					<expr_stmt><expr><name><name>usable_arenas</name>-&gt;<name>prevarena</name></name> = <name>NULL</name></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>usable_arenas</name>-&gt;<name>address</name></name> != 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
				}</block></then></if>
			}</block></then>
			<else>else <block>{
				<comment type="block">/* nfreepools &gt; 0:  it must be that freepools
				 * isn't NULL, or that we haven't yet carved
				 * off all the arena's pools for the first
				 * time.
				 */</comment>
				<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>usable_arenas</name>-&gt;<name>freepools</name></name> != <name>NULL</name> ||
				       <name><name>usable_arenas</name>-&gt;<name>pool_address</name></name> &lt;=
				           (<name>block</name>*)<name><name>usable_arenas</name>-&gt;<name>address</name></name> +
				               <name>ARENA_SIZE</name> - <name>POOL_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			}</block></else></if>
		<label><name>init_pool</name>:</label>
			<comment type="block">/* Frontlink to used pools. */</comment>
			<expr_stmt><expr><name>next</name> = <name><name>usedpools</name><index>[<expr><name>size</name> + <name>size</name></expr>]</index></name></expr>;</expr_stmt> <comment type="block">/* == prev */</comment>
			<expr_stmt><expr><name><name>pool</name>-&gt;<name>nextpool</name></name> = <name>next</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>pool</name>-&gt;<name>prevpool</name></name> = <name>next</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>next</name>-&gt;<name>nextpool</name></name> = <name>pool</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>next</name>-&gt;<name>prevpool</name></name> = <name>pool</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>pool</name>-&gt;<name>ref</name>.<name>count</name></name> = 1</expr>;</expr_stmt>
			<if>if <condition>(<expr><name><name>pool</name>-&gt;<name>szidx</name></name> == <name>size</name></expr>)</condition><then> <block>{
				<comment type="block">/* Luckily, this pool last contained blocks
				 * of the same size class, so its header
				 * and free list are already initialized.
				 */</comment>
				<expr_stmt><expr><name>bp</name> = <name><name>pool</name>-&gt;<name>freeblock</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>pool</name>-&gt;<name>freeblock</name></name> = *(<name>block</name> **)<name>bp</name></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>UNLOCK</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<return>return <expr>(<name>void</name> *)<name>bp</name></expr>;</return>
			}</block></then></if>
			<comment type="block">/*
			 * Initialize the pool header, set up the free list to
			 * contain just the second block, and return the first
			 * block.
			 */</comment>
			<expr_stmt><expr><name><name>pool</name>-&gt;<name>szidx</name></name> = <name>size</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>size</name> = <call><name>INDEX2SIZE</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>bp</name> = (<name>block</name> *)<name>pool</name> + <name>POOL_OVERHEAD</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>pool</name>-&gt;<name>nextoffset</name></name> = <name>POOL_OVERHEAD</name> + (<name>size</name> &lt;&lt; 1)</expr>;</expr_stmt>
			<expr_stmt><expr><name><name>pool</name>-&gt;<name>maxnextoffset</name></name> = <name>POOL_SIZE</name> - <name>size</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>pool</name>-&gt;<name>freeblock</name></name> = <name>bp</name> + <name>size</name></expr>;</expr_stmt>
			<expr_stmt><expr>*<call>(<name>block</name> **)<argument_list>(<argument><expr><name><name>pool</name>-&gt;<name>freeblock</name></name></expr></argument>)</argument_list></call> = <name>NULL</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>UNLOCK</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<return>return <expr>(<name>void</name> *)<name>bp</name></expr>;</return>
		}</block></then></if>

		<comment type="block">/* Carve off a new pool. */</comment>
		<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>usable_arenas</name>-&gt;<name>nfreepools</name></name> &gt; 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>usable_arenas</name>-&gt;<name>freepools</name></name> == <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>pool</name> = (<name>poolp</name>)<name><name>usable_arenas</name>-&gt;<name>pool_address</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr>(<name>block</name>*)<name>pool</name> &lt;= (<name>block</name>*)<name><name>usable_arenas</name>-&gt;<name>address</name></name> +
		                       <name>ARENA_SIZE</name> - <name>POOL_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>pool</name>-&gt;<name>arenaindex</name></name> = <name>usable_arenas</name> - <name>arenas</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr>&amp;<name><name>arenas</name><index>[<expr><name><name>pool</name>-&gt;<name>arenaindex</name></name></expr>]</index></name> == <name>usable_arenas</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>pool</name>-&gt;<name>szidx</name></name> = <name>DUMMY_SIZE_IDX</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>usable_arenas</name>-&gt;<name>pool_address</name></name> += <name>POOL_SIZE</name></expr>;</expr_stmt>
		<expr_stmt><expr>--<name><name>usable_arenas</name>-&gt;<name>nfreepools</name></name></expr>;</expr_stmt>

		<if>if <condition>(<expr><name><name>usable_arenas</name>-&gt;<name>nfreepools</name></name> == 0</expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>usable_arenas</name>-&gt;<name>nextarena</name></name> == <name>NULL</name> ||
			       <name><name>usable_arenas</name>-&gt;<name>nextarena</name>-&gt;<name>prevarena</name></name> ==
			       	   <name>usable_arenas</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* Unlink the arena:  it is completely allocated. */</comment>
			<expr_stmt><expr><name>usable_arenas</name> = <name><name>usable_arenas</name>-&gt;<name>nextarena</name></name></expr>;</expr_stmt>
			<if>if <condition>(<expr><name>usable_arenas</name> != <name>NULL</name></expr>)</condition><then> <block>{
				<expr_stmt><expr><name><name>usable_arenas</name>-&gt;<name>prevarena</name></name> = <name>NULL</name></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>usable_arenas</name>-&gt;<name>address</name></name> != 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
			}</block></then></if>
		}</block></then></if>

		<goto>goto <name>init_pool</name>;</goto>
	}</block></then></if>

        <comment type="block">/* The small block allocator ends here. */</comment>

<label><name>redirect</name>:</label>
	<comment type="block">/* Redirect the original request to the underlying (libc) allocator.
	 * We jump here on bigger requests, on error in the code above (as a
	 * last chance to serve the request) or when the max memory limit
	 * has been reached.
	 */</comment>
	<if>if <condition>(<expr><name>nbytes</name> == 0</expr>)</condition><then>
		<expr_stmt><expr><name>nbytes</name> = 1</expr>;</expr_stmt></then></if>
	<return>return <expr>(<name>void</name> *)<call><name>malloc</name><argument_list>(<argument><expr><name>nbytes</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<comment type="block">/* free */</comment>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>PyObject_Free</name></cpp:undef>
<function><type><name>void</name></type>
<name>PyObject_Free</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>p</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>poolp</name></type> <name>pool</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>block</name> *</type><name>lastfree</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>poolp</name></type> <name>next</name></decl>, <decl><type ref="prev"/><name>prev</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint</name></type> <name>size</name></decl>;</decl_stmt>

	<if>if <condition>(<expr><name>p</name> == <name>NULL</name></expr>)</condition><then>	<comment type="block">/* free(NULL) has no effect */</comment>
		<return>return;</return></then></if>

	<expr_stmt><expr><name>pool</name> = <call><name>POOL_ADDR</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><call><name>Py_ADDRESS_IN_RANGE</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<comment type="block">/* We allocated this address. */</comment>
		<expr_stmt><expr><call><name>LOCK</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* Link p to the start of the pool's freeblock list.  Since
		 * the pool had at least the p block outstanding, the pool
		 * wasn't empty (so it's already in a usedpools[] list, or
		 * was full and is in no list -- it's not in the freeblocks
		 * list in any case).
		 */</comment>
		<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>pool</name>-&gt;<name>ref</name>.<name>count</name></name> &gt; 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* else it was empty */</comment>
		<expr_stmt><expr>*(<name>block</name> **)<name>p</name> = <name>lastfree</name> = <name><name>pool</name>-&gt;<name>freeblock</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>pool</name>-&gt;<name>freeblock</name></name> = (<name>block</name> *)<name>p</name></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>lastfree</name></expr>)</condition><then> <block>{
			<decl_stmt><decl><type>struct <name>arena_object</name>*</type> <name>ao</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>uint</name></type> <name>nf</name></decl>;</decl_stmt>  <comment type="block">/* ao-&gt;nfreepools */</comment>

			<comment type="block">/* freeblock wasn't NULL, so the pool wasn't full,
			 * and the pool is in a usedpools[] list.
			 */</comment>
			<if>if <condition>(<expr>--<name><name>pool</name>-&gt;<name>ref</name>.<name>count</name></name> != 0</expr>)</condition><then> <block>{
				<comment type="block">/* pool isn't empty:  leave it in usedpools */</comment>
				<expr_stmt><expr><call><name>UNLOCK</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<return>return;</return>
			}</block></then></if>
			<comment type="block">/* Pool is now empty:  unlink from usedpools, and
			 * link to the front of freepools.  This ensures that
			 * previously freed pools will be allocated later
			 * (being not referenced, they are perhaps paged out).
			 */</comment>
			<expr_stmt><expr><name>next</name> = <name><name>pool</name>-&gt;<name>nextpool</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name>prev</name> = <name><name>pool</name>-&gt;<name>prevpool</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>next</name>-&gt;<name>prevpool</name></name> = <name>prev</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>prev</name>-&gt;<name>nextpool</name></name> = <name>next</name></expr>;</expr_stmt>

			<comment type="block">/* Link the pool to freepools.  This is a singly-linked
			 * list, and pool-&gt;prevpool isn't used there.
			 */</comment>
			<expr_stmt><expr><name>ao</name> = &amp;<name><name>arenas</name><index>[<expr><name><name>pool</name>-&gt;<name>arenaindex</name></name></expr>]</index></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>pool</name>-&gt;<name>nextpool</name></name> = <name><name>ao</name>-&gt;<name>freepools</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>ao</name>-&gt;<name>freepools</name></name> = <name>pool</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>nf</name> = ++<name><name>ao</name>-&gt;<name>nfreepools</name></name></expr>;</expr_stmt>

			<comment type="block">/* All the rest is arena management.  We just freed
			 * a pool, and there are 4 cases for arena mgmt:
			 * 1. If all the pools are free, return the arena to
			 *    the system free().
			 * 2. If this is the only free pool in the arena,
			 *    add the arena back to the `usable_arenas` list.
			 * 3. If the "next" arena has a smaller count of free
			 *    pools, we have to "slide this arena right" to
			 *    restore that usable_arenas is sorted in order of
			 *    nfreepools.
			 * 4. Else there's nothing more to do.
			 */</comment>
			<if>if <condition>(<expr><name>nf</name> == <name><name>ao</name>-&gt;<name>ntotalpools</name></name></expr>)</condition><then> <block>{
				<comment type="block">/* Case 1.  First unlink ao from usable_arenas.
				 */</comment>
				<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>ao</name>-&gt;<name>prevarena</name></name> == <name>NULL</name> ||
				       <name><name>ao</name>-&gt;<name>prevarena</name>-&gt;<name>address</name></name> != 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>ao</name> -&gt;<name>nextarena</name></name> == <name>NULL</name> ||
				       <name><name>ao</name>-&gt;<name>nextarena</name>-&gt;<name>address</name></name> != 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/* Fix the pointer in the prevarena, or the
				 * usable_arenas pointer.
				 */</comment>
				<if>if <condition>(<expr><name><name>ao</name>-&gt;<name>prevarena</name></name> == <name>NULL</name></expr>)</condition><then> <block>{
					<expr_stmt><expr><name>usable_arenas</name> = <name><name>ao</name>-&gt;<name>nextarena</name></name></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>usable_arenas</name> == <name>NULL</name> ||
					       <name><name>usable_arenas</name>-&gt;<name>address</name></name> != 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
				}</block></then>
				<else>else <block>{
					<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>ao</name>-&gt;<name>prevarena</name>-&gt;<name>nextarena</name></name> == <name>ao</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>ao</name>-&gt;<name>prevarena</name>-&gt;<name>nextarena</name></name> =
						<name><name>ao</name>-&gt;<name>nextarena</name></name></expr>;</expr_stmt>
				}</block></else></if>
				<comment type="block">/* Fix the pointer in the nextarena. */</comment>
				<if>if <condition>(<expr><name><name>ao</name>-&gt;<name>nextarena</name></name> != <name>NULL</name></expr>)</condition><then> <block>{
					<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>ao</name>-&gt;<name>nextarena</name>-&gt;<name>prevarena</name></name> == <name>ao</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>ao</name>-&gt;<name>nextarena</name>-&gt;<name>prevarena</name></name> =
						<name><name>ao</name>-&gt;<name>prevarena</name></name></expr>;</expr_stmt>
				}</block></then></if>
				<comment type="block">/* Record that this arena_object slot is
				 * available to be reused.
				 */</comment>
				<expr_stmt><expr><name><name>ao</name>-&gt;<name>nextarena</name></name> = <name>unused_arena_objects</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>unused_arena_objects</name> = <name>ao</name></expr>;</expr_stmt>

				<comment type="block">/* Free the entire arena. */</comment>
				<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr>(<name>void</name> *)<name><name>ao</name>-&gt;<name>address</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>ao</name>-&gt;<name>address</name></name> = 0</expr>;</expr_stmt>	<comment type="block">/* mark unassociated */</comment>
				<expr_stmt><expr>--<name>narenas_currently_allocated</name></expr>;</expr_stmt>

				<expr_stmt><expr><call><name>UNLOCK</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<return>return;</return>
			}</block></then></if>
			<if>if <condition>(<expr><name>nf</name> == 1</expr>)</condition><then> <block>{
				<comment type="block">/* Case 2.  Put ao at the head of
				 * usable_arenas.  Note that because
				 * ao-&gt;nfreepools was 0 before, ao isn't
				 * currently on the usable_arenas list.
				 */</comment>
				<expr_stmt><expr><name><name>ao</name>-&gt;<name>nextarena</name></name> = <name>usable_arenas</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>ao</name>-&gt;<name>prevarena</name></name> = <name>NULL</name></expr>;</expr_stmt>
				<if>if <condition>(<expr><name>usable_arenas</name></expr>)</condition><then>
					<expr_stmt><expr><name><name>usable_arenas</name>-&gt;<name>prevarena</name></name> = <name>ao</name></expr>;</expr_stmt></then></if>
				<expr_stmt><expr><name>usable_arenas</name> = <name>ao</name></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>usable_arenas</name>-&gt;<name>address</name></name> != 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><call><name>UNLOCK</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<return>return;</return>
			}</block></then></if>
			<comment type="block">/* If this arena is now out of order, we need to keep
			 * the list sorted.  The list is kept sorted so that
			 * the "most full" arenas are used first, which allows
			 * the nearly empty arenas to be completely freed.  In
			 * a few un-scientific tests, it seems like this
			 * approach allowed a lot more memory to be freed.
			 */</comment>
			<if>if <condition>(<expr><name><name>ao</name>-&gt;<name>nextarena</name></name> == <name>NULL</name> ||
				     <name>nf</name> &lt;= <name><name>ao</name>-&gt;<name>nextarena</name>-&gt;<name>nfreepools</name></name></expr>)</condition><then> <block>{
				<comment type="block">/* Case 4.  Nothing to do. */</comment>
				<expr_stmt><expr><call><name>UNLOCK</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<return>return;</return>
			}</block></then></if>
			<comment type="block">/* Case 3:  We have to move the arena towards the end
			 * of the list, because it has more free pools than
			 * the arena to its right.
			 * First unlink ao from usable_arenas.
			 */</comment>
			<if>if <condition>(<expr><name><name>ao</name>-&gt;<name>prevarena</name></name> != <name>NULL</name></expr>)</condition><then> <block>{
				<comment type="block">/* ao isn't at the head of the list */</comment>
				<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>ao</name>-&gt;<name>prevarena</name>-&gt;<name>nextarena</name></name> == <name>ao</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>ao</name>-&gt;<name>prevarena</name>-&gt;<name>nextarena</name></name> = <name><name>ao</name>-&gt;<name>nextarena</name></name></expr>;</expr_stmt>
			}</block></then>
			<else>else <block>{
				<comment type="block">/* ao is at the head of the list */</comment>
				<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>usable_arenas</name> == <name>ao</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>usable_arenas</name> = <name><name>ao</name>-&gt;<name>nextarena</name></name></expr>;</expr_stmt>
			}</block></else></if>
			<expr_stmt><expr><name><name>ao</name>-&gt;<name>nextarena</name>-&gt;<name>prevarena</name></name> = <name><name>ao</name>-&gt;<name>prevarena</name></name></expr>;</expr_stmt>

			<comment type="block">/* Locate the new insertion point by iterating over
			 * the list, using our nextarena pointer.
			 */</comment>
			<while>while <condition>(<expr><name><name>ao</name>-&gt;<name>nextarena</name></name> != <name>NULL</name> &amp;&amp;
					<name>nf</name> &gt; <name><name>ao</name>-&gt;<name>nextarena</name>-&gt;<name>nfreepools</name></name></expr>)</condition> <block>{
				<expr_stmt><expr><name><name>ao</name>-&gt;<name>prevarena</name></name> = <name><name>ao</name>-&gt;<name>nextarena</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>ao</name>-&gt;<name>nextarena</name></name> = <name><name>ao</name>-&gt;<name>nextarena</name>-&gt;<name>nextarena</name></name></expr>;</expr_stmt>
			}</block></while>

			<comment type="block">/* Insert ao at this point. */</comment>
			<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>ao</name>-&gt;<name>nextarena</name></name> == <name>NULL</name> ||
				<name><name>ao</name>-&gt;<name>prevarena</name></name> == <name><name>ao</name>-&gt;<name>nextarena</name>-&gt;<name>prevarena</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>ao</name>-&gt;<name>prevarena</name>-&gt;<name>nextarena</name></name> == <name><name>ao</name>-&gt;<name>nextarena</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name><name>ao</name>-&gt;<name>prevarena</name>-&gt;<name>nextarena</name></name> = <name>ao</name></expr>;</expr_stmt>
			<if>if <condition>(<expr><name><name>ao</name>-&gt;<name>nextarena</name></name> != <name>NULL</name></expr>)</condition><then>
				<expr_stmt><expr><name><name>ao</name>-&gt;<name>nextarena</name>-&gt;<name>prevarena</name></name> = <name>ao</name></expr>;</expr_stmt></then></if>

			<comment type="block">/* Verify that the swaps worked. */</comment>
			<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>ao</name>-&gt;<name>nextarena</name></name> == <name>NULL</name> ||
				  <name>nf</name> &lt;= <name><name>ao</name>-&gt;<name>nextarena</name>-&gt;<name>nfreepools</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>ao</name>-&gt;<name>prevarena</name></name> == <name>NULL</name> ||
				  <name>nf</name> &gt; <name><name>ao</name>-&gt;<name>prevarena</name>-&gt;<name>nfreepools</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>ao</name>-&gt;<name>nextarena</name></name> == <name>NULL</name> ||
				<name><name>ao</name>-&gt;<name>nextarena</name>-&gt;<name>prevarena</name></name> == <name>ao</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr>(<name>usable_arenas</name> == <name>ao</name> &amp;&amp;
				<name><name>ao</name>-&gt;<name>prevarena</name></name> == <name>NULL</name>) ||
				<name><name>ao</name>-&gt;<name>prevarena</name>-&gt;<name>nextarena</name></name> == <name>ao</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>UNLOCK</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<return>return;</return>
		}</block></then></if>
		<comment type="block">/* Pool was full, so doesn't currently live in any list:
		 * link it to the front of the appropriate usedpools[] list.
		 * This mimics LRU pool usage for new allocations and
		 * targets optimal filling when several pools contain
		 * blocks of the same size class.
		 */</comment>
		<expr_stmt><expr>--<name><name>pool</name>-&gt;<name>ref</name>.<name>count</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>pool</name>-&gt;<name>ref</name>.<name>count</name></name> &gt; 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* else the pool is empty */</comment>
		<expr_stmt><expr><name>size</name> = <name><name>pool</name>-&gt;<name>szidx</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>next</name> = <name><name>usedpools</name><index>[<expr><name>size</name> + <name>size</name></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>prev</name> = <name><name>next</name>-&gt;<name>prevpool</name></name></expr>;</expr_stmt>
		<comment type="block">/* insert pool before next:   prev &lt;-&gt; pool &lt;-&gt; next */</comment>
		<expr_stmt><expr><name><name>pool</name>-&gt;<name>nextpool</name></name> = <name>next</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>pool</name>-&gt;<name>prevpool</name></name> = <name>prev</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>next</name>-&gt;<name>prevpool</name></name> = <name>pool</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>prev</name>-&gt;<name>nextpool</name></name> = <name>pool</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>UNLOCK</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	}</block></then></if>

	<comment type="block">/* We didn't allocate this address. */</comment>
	<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<comment type="block">/* realloc.  If p is NULL, this acts like malloc(nbytes).  Else if nbytes==0,
 * then as the Python docs promise, we do not treat this like free(p), and
 * return a non-NULL result.
 */</comment>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>PyObject_Realloc</name></cpp:undef>
<function><type><name>void</name> *</type>
<name>PyObject_Realloc</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>p</name></decl></param>, <param><decl><type><name>size_t</name></type> <name>nbytes</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>void</name> *</type><name>bp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>poolp</name></type> <name>pool</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>size_t</name></type> <name>size</name></decl>;</decl_stmt>

	<if>if <condition>(<expr><name>p</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr><call><name>PyObject_Malloc</name><argument_list>(<argument><expr><name>nbytes</name></expr></argument>)</argument_list></call></expr>;</return></then></if>

	<comment type="block">/*
	 * Limit ourselves to PY_SSIZE_T_MAX bytes to prevent security holes.
	 * Most python internals blindly use a signed Py_ssize_t to track
	 * things without checking for overflows or negatives.
	 * As size_t is unsigned, checking for nbytes &lt; 0 is not required.
	 */</comment>
	<if>if <condition>(<expr><name>nbytes</name> &gt; <name>PY_SSIZE_T_MAX</name></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>

	<expr_stmt><expr><name>pool</name> = <call><name>POOL_ADDR</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><call><name>Py_ADDRESS_IN_RANGE</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<comment type="block">/* We're in charge of this block */</comment>
		<expr_stmt><expr><name>size</name> = <call><name>INDEX2SIZE</name><argument_list>(<argument><expr><name><name>pool</name>-&gt;<name>szidx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>nbytes</name> &lt;= <name>size</name></expr>)</condition><then> <block>{
			<comment type="block">/* The block is staying the same or shrinking.  If
			 * it's shrinking, there's a tradeoff:  it costs
			 * cycles to copy the block to a smaller size class,
			 * but it wastes memory not to copy it.  The
			 * compromise here is to copy on shrink only if at
			 * least 25% of size can be shaved off.
			 */</comment>
			<if>if <condition>(<expr>4 * <name>nbytes</name> &gt; 3 * <name>size</name></expr>)</condition><then> <block>{
				<comment type="block">/* It's the same,
				 * or shrinking and new/old &gt; 3/4.
				 */</comment>
				<return>return <expr><name>p</name></expr>;</return>
			}</block></then></if>
			<expr_stmt><expr><name>size</name> = <name>nbytes</name></expr>;</expr_stmt>
		}</block></then></if>
		<expr_stmt><expr><name>bp</name> = <call><name>PyObject_Malloc</name><argument_list>(<argument><expr><name>nbytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>bp</name> != <name>NULL</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>bp</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>PyObject_Free</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></then></if>
		<return>return <expr><name>bp</name></expr>;</return>
	}</block></then></if>
	<comment type="block">/* We're not managing this block.  If nbytes &lt;=
	 * SMALL_REQUEST_THRESHOLD, it's tempting to try to take over this
	 * block.  However, if we do, we need to copy the valid data from
	 * the C-managed block to one of our blocks, and there's no portable
	 * way to know how much of the memory space starting at p is valid.
	 * As bug 1185883 pointed out the hard way, it's possible that the
	 * C-managed block is "at the end" of allocated VM space, so that
	 * a memory fault can occur if we try to copy nbytes bytes starting
	 * at p.  Instead we punt:  let C continue to manage this block.
         */</comment>
	<if>if <condition>(<expr><name>nbytes</name></expr>)</condition><then>
		<return>return <expr><call><name>realloc</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>nbytes</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
	<comment type="block">/* C doesn't define the result of realloc(p, 0) (it may or may not
	 * return NULL then), but Python's docs promise that nbytes==0 never
	 * returns NULL.  We don't pass 0 to realloc(), to avoid that endcase
	 * to begin with.  Even then, we can't be sure that realloc() won't
	 * return NULL.
	 */</comment>
	<expr_stmt><expr><name>bp</name> = <call><name>realloc</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
   	<return>return <expr><name>bp</name> ? <name>bp</name> : <name>p</name></expr>;</return>
}</block></function>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>	<comment type="block">/* ! WITH_PYMALLOC */</comment>

<comment type="block">/*==========================================================================*/</comment>
<comment type="block">/* pymalloc not enabled:  Redirect the entry points to malloc.  These will
 * only be used by extensions that are compiled with pymalloc enabled. */</comment>

<function><type><name>void</name> *</type>
<name>PyObject_Malloc</name><parameter_list>(<param><decl><type><name>size_t</name></type> <name>n</name></decl></param>)</parameter_list>
<block>{
	<return>return <expr><call><name>PyMem_MALLOC</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>void</name> *</type>
<name>PyObject_Realloc</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>p</name></decl></param>, <param><decl><type><name>size_t</name></type> <name>n</name></decl></param>)</parameter_list>
<block>{
	<return>return <expr><call><name>PyMem_REALLOC</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>void</name></type>
<name>PyObject_Free</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>p</name></decl></param>)</parameter_list>
<block>{
	<expr_stmt><expr><call><name>PyMem_FREE</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* WITH_PYMALLOC */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PYMALLOC_DEBUG</name></cpp:ifdef>
<comment type="block">/*==========================================================================*/</comment>
<comment type="block">/* A x-platform debugging allocator.  This doesn't manage memory directly,
 * it wraps a real allocator, adding extra debugging info to the memory blocks.
 */</comment>

<comment type="block">/* Special bytes broadcast into debug memory blocks at appropriate times.
 * Strings of these are unlikely to be valid addresses, floats, ints or
 * 7-bit ASCII.
 */</comment>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>CLEANBYTE</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>DEADBYTE</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>FORBIDDENBYTE</name></cpp:undef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CLEANBYTE</name></cpp:macro>      <cpp:value>0xCB</cpp:value></cpp:define>    <comment type="block">/* clean (newly allocated) memory */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DEADBYTE</name></cpp:macro>       <cpp:value>0xDB</cpp:value></cpp:define>    <comment type="block">/* dead (newly freed) memory */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FORBIDDENBYTE</name></cpp:macro>  <cpp:value>0xFB</cpp:value></cpp:define>    <comment type="block">/* untouchable bytes at each end of a block */</comment>

<decl_stmt><decl><type><specifier>static</specifier> <name>size_t</name></type> <name>serialno</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>	<comment type="block">/* incremented on each debug {m,re}alloc */</comment>

<comment type="block">/* serialno is always incremented via calling this routine.  The point is
 * to supply a single place to set a breakpoint.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>bumpserialno</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list>
<block>{
	<expr_stmt><expr>++<name>serialno</name></expr>;</expr_stmt>
}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SST</name></cpp:macro> <cpp:value>SIZEOF_SIZE_T</cpp:value></cpp:define>

<comment type="block">/* Read sizeof(size_t) bytes at p as a big-endian size_t. */</comment>
<function><type><specifier>static</specifier> <name>size_t</name></type>
<name>read_size_t</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>void</name> *</type><name>p</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><specifier>const</specifier> <name>uchar</name> *</type><name>q</name> <init>= <expr>(const <name>uchar</name> *)<name>p</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>size_t</name></type> <name>result</name> <init>= <expr>*<name>q</name>++</expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

	<for>for (<init><expr><name>i</name> = <name>SST</name></expr>;</init> <condition><expr>--<name>i</name> &gt; 0</expr>;</condition> <incr><expr>++<name>q</name></expr></incr>)
		<expr_stmt><expr><name>result</name> = (<name>result</name> &lt;&lt; 8) | *<name>q</name></expr>;</expr_stmt></for>
	<return>return <expr><name>result</name></expr>;</return>
}</block></function>

<comment type="block">/* Write n as a big-endian size_t, MSB at address p, LSB at
 * p + sizeof(size_t) - 1.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>write_size_t</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>p</name></decl></param>, <param><decl><type><name>size_t</name></type> <name>n</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>uchar</name> *</type><name>q</name> <init>= <expr>(<name>uchar</name> *)<name>p</name> + <name>SST</name> - 1</expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

	<for>for (<init><expr><name>i</name> = <name>SST</name></expr>;</init> <condition><expr>--<name>i</name> &gt;= 0</expr>;</condition> <incr><expr>--<name>q</name></expr></incr>) <block>{
		<expr_stmt><expr>*<name>q</name> = <call>(<name>uchar</name>)<argument_list>(<argument><expr><name>n</name> &amp; 0xff</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>n</name> &gt;&gt;= 8</expr>;</expr_stmt>
	}</block></for>
}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>Py_DEBUG</name></cpp:ifdef>
<comment type="block">/* Is target in the list?  The list is traversed via the nextpool pointers.
 * The list may be NULL-terminated, or circular.  Return 1 if target is in
 * list, else 0.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>pool_is_in_list</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>poolp</name></type> <name>target</name></decl></param>, <param><decl><type><name>poolp</name></type> <name>list</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>poolp</name></type> <name>origlist</name> <init>= <expr><name>list</name></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>target</name> != <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>list</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr>0</expr>;</return></then></if>
	<do>do <block>{
		<if>if <condition>(<expr><name>target</name> == <name>list</name></expr>)</condition><then>
			<return>return <expr>1</expr>;</return></then></if>
		<expr_stmt><expr><name>list</name> = <name><name>list</name>-&gt;<name>nextpool</name></name></expr>;</expr_stmt>
	}</block> while <condition>(<expr><name>list</name> != <name>NULL</name> &amp;&amp; <name>list</name> != <name>origlist</name></expr>)</condition>;</do>
	<return>return <expr>0</expr>;</return>
}</block></function>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>pool_is_in_list</name><parameter_list>(<param><type><name>X</name></type></param>, <param><type><name>Y</name></type></param>)</parameter_list></cpp:macro> <cpp:value>1</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>	<comment type="block">/* Py_DEBUG */</comment>

<comment type="block">/* Let S = sizeof(size_t).  The debug malloc asks for 4*S extra bytes and
   fills them with useful stuff, here calling the underlying malloc's result p:

p[0: S]
    Number of bytes originally asked for.  This is a size_t, big-endian (easier
    to read in a memory dump).
p[S: 2*S]
    Copies of FORBIDDENBYTE.  Used to catch under- writes and reads.
p[2*S: 2*S+n]
    The requested memory, filled with copies of CLEANBYTE.
    Used to catch reference to uninitialized memory.
    &amp;p[2*S] is returned.  Note that this is 8-byte aligned if pymalloc
    handled the request itself.
p[2*S+n: 2*S+n+S]
    Copies of FORBIDDENBYTE.  Used to catch over- writes and reads.
p[2*S+n+S: 2*S+n+2*S]
    A serial number, incremented by 1 on each call to _PyObject_DebugMalloc
    and _PyObject_DebugRealloc.
    This is a big-endian size_t.
    If "bad memory" is detected later, the serial number gives an
    excellent way to set a breakpoint on the next run, to capture the
    instant at which this block was passed out.
*/</comment>

<function><type><name>void</name> *</type>
<name>_PyObject_DebugMalloc</name><parameter_list>(<param><decl><type><name>size_t</name></type> <name>nbytes</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>uchar</name> *</type><name>p</name></decl>;</decl_stmt>	<comment type="block">/* base address of malloc'ed block */</comment>
	<decl_stmt><decl><type><name>uchar</name> *</type><name>tail</name></decl>;</decl_stmt>	<comment type="block">/* p + 2*SST + nbytes == pointer to tail pad bytes */</comment>
	<decl_stmt><decl><type><name>size_t</name></type> <name>total</name></decl>;</decl_stmt>	<comment type="block">/* nbytes + 4*SST */</comment>

	<expr_stmt><expr><call><name>bumpserialno</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>total</name> = <name>nbytes</name> + 4*<name>SST</name></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>total</name> &lt; <name>nbytes</name></expr>)</condition><then>
		<comment type="block">/* overflow:  can't represent total as a size_t */</comment>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>

	<expr_stmt><expr><name>p</name> = (<name>uchar</name> *)<call><name>PyObject_Malloc</name><argument_list>(<argument><expr><name>total</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>p</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>

	<expr_stmt><expr><call><name>write_size_t</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>nbytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>p</name> + <name>SST</name></expr></argument>, <argument><expr><name>FORBIDDENBYTE</name></expr></argument>, <argument><expr><name>SST</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if>if <condition>(<expr><name>nbytes</name> &gt; 0</expr>)</condition><then>
		<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>p</name> + 2*<name>SST</name></expr></argument>, <argument><expr><name>CLEANBYTE</name></expr></argument>, <argument><expr><name>nbytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

	<expr_stmt><expr><name>tail</name> = <name>p</name> + 2*<name>SST</name> + <name>nbytes</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>tail</name></expr></argument>, <argument><expr><name>FORBIDDENBYTE</name></expr></argument>, <argument><expr><name>SST</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>write_size_t</name><argument_list>(<argument><expr><name>tail</name> + <name>SST</name></expr></argument>, <argument><expr><name>serialno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>p</name> + 2*<name>SST</name></expr>;</return>
}</block></function>

<comment type="block">/* The debug free first checks the 2*SST bytes on each end for sanity (in
   particular, that the FORBIDDENBYTEs are still intact).
   Then fills the original bytes with DEADBYTE.
   Then calls the underlying free.
*/</comment>
<function><type><name>void</name></type>
<name>_PyObject_DebugFree</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>p</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>uchar</name> *</type><name>q</name> <init>= <expr>(<name>uchar</name> *)<name>p</name> - 2*<name>SST</name></expr></init></decl>;</decl_stmt>  <comment type="block">/* address returned from malloc */</comment>
	<decl_stmt><decl><type><name>size_t</name></type> <name>nbytes</name></decl>;</decl_stmt>

	<if>if <condition>(<expr><name>p</name> == <name>NULL</name></expr>)</condition><then>
		<return>return;</return></then></if>
	<expr_stmt><expr><call><name>_PyObject_DebugCheckAddress</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>nbytes</name> = <call><name>read_size_t</name><argument_list>(<argument><expr><name>q</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>nbytes</name> &gt; 0</expr>)</condition><then>
		<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><name>DEADBYTE</name></expr></argument>, <argument><expr><name>nbytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
	<expr_stmt><expr><call><name>PyObject_Free</name><argument_list>(<argument><expr><name>q</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><name>void</name> *</type>
<name>_PyObject_DebugRealloc</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>p</name></decl></param>, <param><decl><type><name>size_t</name></type> <name>nbytes</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>uchar</name> *</type><name>q</name> <init>= <expr>(<name>uchar</name> *)<name>p</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uchar</name> *</type><name>tail</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>size_t</name></type> <name>total</name></decl>;</decl_stmt>	<comment type="block">/* nbytes + 4*SST */</comment>
	<decl_stmt><decl><type><name>size_t</name></type> <name>original_nbytes</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

	<if>if <condition>(<expr><name>p</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr><call><name>_PyObject_DebugMalloc</name><argument_list>(<argument><expr><name>nbytes</name></expr></argument>)</argument_list></call></expr>;</return></then></if>

	<expr_stmt><expr><call><name>_PyObject_DebugCheckAddress</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>bumpserialno</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>original_nbytes</name> = <call><name>read_size_t</name><argument_list>(<argument><expr><name>q</name> - 2*<name>SST</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>total</name> = <name>nbytes</name> + 4*<name>SST</name></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>total</name> &lt; <name>nbytes</name></expr>)</condition><then>
		<comment type="block">/* overflow:  can't represent total as a size_t */</comment>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>

	<if>if <condition>(<expr><name>nbytes</name> &lt; <name>original_nbytes</name></expr>)</condition><then> <block>{
		<comment type="block">/* shrinking:  mark old extra memory dead */</comment>
		<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>q</name> + <name>nbytes</name></expr></argument>, <argument><expr><name>DEADBYTE</name></expr></argument>, <argument><expr><name>original_nbytes</name> - <name>nbytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>

	<comment type="block">/* Resize and add decorations. */</comment>
	<expr_stmt><expr><name>q</name> = (<name>uchar</name> *)<call><name>PyObject_Realloc</name><argument_list>(<argument><expr><name>q</name> - 2*<name>SST</name></expr></argument>, <argument><expr><name>total</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>q</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>

	<expr_stmt><expr><call><name>write_size_t</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><name>nbytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>SST</name></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>)
		<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>q</name><index>[<expr><name>SST</name> + <name>i</name></expr>]</index></name> == <name>FORBIDDENBYTE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></for>
	<expr_stmt><expr><name>q</name> += 2*<name>SST</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>tail</name> = <name>q</name> + <name>nbytes</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>tail</name></expr></argument>, <argument><expr><name>FORBIDDENBYTE</name></expr></argument>, <argument><expr><name>SST</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>write_size_t</name><argument_list>(<argument><expr><name>tail</name> + <name>SST</name></expr></argument>, <argument><expr><name>serialno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if>if <condition>(<expr><name>nbytes</name> &gt; <name>original_nbytes</name></expr>)</condition><then> <block>{
		<comment type="block">/* growing:  mark new extra memory clean */</comment>
		<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>q</name> + <name>original_nbytes</name></expr></argument>, <argument><expr><name>CLEANBYTE</name></expr></argument>,
			<argument><expr><name>nbytes</name> - <name>original_nbytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>

	<return>return <expr><name>q</name></expr>;</return>
}</block></function>

<comment type="block">/* Check the forbidden bytes on both ends of the memory allocated for p.
 * If anything is wrong, print info to stderr via _PyObject_DebugDumpAddress,
 * and call Py_FatalError to kill the program.
 */</comment>
 <function><type><name>void</name></type>
<name>_PyObject_DebugCheckAddress</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>void</name> *</type><name>p</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><specifier>const</specifier> <name>uchar</name> *</type><name>q</name> <init>= <expr>(const <name>uchar</name> *)<name>p</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> *</type><name>msg</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>size_t</name></type> <name>nbytes</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>uchar</name> *</type><name>tail</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

	<if>if <condition>(<expr><name>p</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>msg</name> = "didn't expect a NULL pointer"</expr>;</expr_stmt>
		<goto>goto <name>error</name>;</goto>
	}</block></then></if>

	<comment type="block">/* Check the stuff at the start of p first:  if there's underwrite
	 * corruption, the number-of-bytes field may be nuts, and checking
	 * the tail could lead to a segfault then.
	 */</comment>
	<for>for (<init><expr><name>i</name> = <name>SST</name></expr>;</init> <condition><expr><name>i</name> &gt;= 1</expr>;</condition> <incr><expr>--<name>i</name></expr></incr>) <block>{
		<if>if <condition>(<expr>*(<name>q</name>-<name>i</name>) != <name>FORBIDDENBYTE</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><name>msg</name> = "bad leading pad byte"</expr>;</expr_stmt>
			<goto>goto <name>error</name>;</goto>
		}</block></then></if>
	}</block></for>

	<expr_stmt><expr><name>nbytes</name> = <call><name>read_size_t</name><argument_list>(<argument><expr><name>q</name> - 2*<name>SST</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>tail</name> = <name>q</name> + <name>nbytes</name></expr>;</expr_stmt>
	<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>SST</name></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>) <block>{
		<if>if <condition>(<expr><name><name>tail</name><index>[<expr><name>i</name></expr>]</index></name> != <name>FORBIDDENBYTE</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><name>msg</name> = "bad trailing pad byte"</expr>;</expr_stmt>
			<goto>goto <name>error</name>;</goto>
		}</block></then></if>
	}</block></for>

	<return>return;</return>

<label><name>error</name>:</label>
	<expr_stmt><expr><call><name>_PyObject_DebugDumpAddress</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_FatalError</name><argument_list>(<argument><expr><name>msg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<comment type="block">/* Display info to stderr about the memory block at p. */</comment>
<function><type><name>void</name></type>
<name>_PyObject_DebugDumpAddress</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>void</name> *</type><name>p</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><specifier>const</specifier> <name>uchar</name> *</type><name>q</name> <init>= <expr>(const <name>uchar</name> *)<name>p</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>uchar</name> *</type><name>tail</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>size_t</name></type> <name>nbytes</name></decl>, <decl><type ref="prev"/><name>serial</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>ok</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr>"Debug memory block at address p=%p:\n"</expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>p</name> == <name>NULL</name></expr>)</condition><then>
		<return>return;</return></then></if>

	<expr_stmt><expr><name>nbytes</name> = <call><name>read_size_t</name><argument_list>(<argument><expr><name>q</name> - 2*<name>SST</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr>"    %" <name>PY_FORMAT_SIZE_T</name> "u bytes originally "
	                "requested\n"</expr></argument>, <argument><expr><name>nbytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* In case this is nuts, check the leading pad bytes first. */</comment>
	<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr>"    The %d pad bytes at p-%d are "</expr></argument>, <argument><expr><name>SST</name></expr></argument>, <argument><expr><name>SST</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>ok</name> = 1</expr>;</expr_stmt>
	<for>for (<init><expr><name>i</name> = 1</expr>;</init> <condition><expr><name>i</name> &lt;= <name>SST</name></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>) <block>{
		<if>if <condition>(<expr>*(<name>q</name>-<name>i</name>) != <name>FORBIDDENBYTE</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><name>ok</name> = 0</expr>;</expr_stmt>
			<break>break;</break>
		}</block></then></if>
	}</block></for>
	<if>if <condition>(<expr><name>ok</name></expr>)</condition><then>
		<expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr>"FORBIDDENBYTE, as expected.\n"</expr></argument>, <argument><expr><name>stderr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
	<else>else <block>{
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr>"not all FORBIDDENBYTE (0x%02x):\n"</expr></argument>,
			<argument><expr><name>FORBIDDENBYTE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<for>for (<init><expr><name>i</name> = <name>SST</name></expr>;</init> <condition><expr><name>i</name> &gt;= 1</expr>;</condition> <incr><expr>--<name>i</name></expr></incr>) <block>{
			<decl_stmt><decl><type><specifier>const</specifier> <name>uchar</name></type> <name>byte</name> <init>= <expr>*(<name>q</name>-<name>i</name>)</expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr>"        at p-%d: 0x%02x"</expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>byte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><name>byte</name> != <name>FORBIDDENBYTE</name></expr>)</condition><then>
				<expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr>" *** OUCH"</expr></argument>, <argument><expr><name>stderr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
			<expr_stmt><expr><call><name>fputc</name><argument_list>(<argument><expr>'\n'</expr></argument>, <argument><expr><name>stderr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></for>

		<expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr>"    Because memory is corrupted at the start, the "
		      "count of bytes requested\n"
		      "       may be bogus, and checking the trailing pad "
		      "bytes may segfault.\n"</expr></argument>, <argument><expr><name>stderr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></else></if>

	<expr_stmt><expr><name>tail</name> = <name>q</name> + <name>nbytes</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr>"    The %d pad bytes at tail=%p are "</expr></argument>, <argument><expr><name>SST</name></expr></argument>, <argument><expr><name>tail</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>ok</name> = 1</expr>;</expr_stmt>
	<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>SST</name></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>) <block>{
		<if>if <condition>(<expr><name><name>tail</name><index>[<expr><name>i</name></expr>]</index></name> != <name>FORBIDDENBYTE</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><name>ok</name> = 0</expr>;</expr_stmt>
			<break>break;</break>
		}</block></then></if>
	}</block></for>
	<if>if <condition>(<expr><name>ok</name></expr>)</condition><then>
		<expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr>"FORBIDDENBYTE, as expected.\n"</expr></argument>, <argument><expr><name>stderr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
	<else>else <block>{
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr>"not all FORBIDDENBYTE (0x%02x):\n"</expr></argument>,
			<argument><expr><name>FORBIDDENBYTE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>SST</name></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>) <block>{
			<decl_stmt><decl><type><specifier>const</specifier> <name>uchar</name></type> <name>byte</name> <init>= <expr><name><name>tail</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr>"        at tail+%d: 0x%02x"</expr></argument>,
				<argument><expr><name>i</name></expr></argument>, <argument><expr><name>byte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><name>byte</name> != <name>FORBIDDENBYTE</name></expr>)</condition><then>
				<expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr>" *** OUCH"</expr></argument>, <argument><expr><name>stderr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
			<expr_stmt><expr><call><name>fputc</name><argument_list>(<argument><expr>'\n'</expr></argument>, <argument><expr><name>stderr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></for>
	}</block></else></if>

	<expr_stmt><expr><name>serial</name> = <call><name>read_size_t</name><argument_list>(<argument><expr><name>tail</name> + <name>SST</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr>"    The block was made by call #%" <name>PY_FORMAT_SIZE_T</name>
			"u to debug malloc/realloc.\n"</expr></argument>, <argument><expr><name>serial</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if>if <condition>(<expr><name>nbytes</name> &gt; 0</expr>)</condition><then> <block>{
		<expr_stmt><expr><name>i</name> = 0</expr>;</expr_stmt>
		<expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr>"    Data at p:"</expr></argument>, <argument><expr><name>stderr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* print up to 8 bytes at the start */</comment>
		<while>while <condition>(<expr><name>q</name> &lt; <name>tail</name> &amp;&amp; <name>i</name> &lt; 8</expr>)</condition> <block>{
			<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr>" %02x"</expr></argument>, <argument><expr>*<name>q</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr>++<name>i</name></expr>;</expr_stmt>
			<expr_stmt><expr>++<name>q</name></expr>;</expr_stmt>
		}</block></while>
		<comment type="block">/* and up to 8 at the end */</comment>
		<if>if <condition>(<expr><name>q</name> &lt; <name>tail</name></expr>)</condition><then> <block>{
			<if>if <condition>(<expr><name>tail</name> - <name>q</name> &gt; 8</expr>)</condition><then> <block>{
				<expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr>" ..."</expr></argument>, <argument><expr><name>stderr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>q</name> = <name>tail</name> - 8</expr>;</expr_stmt>
			}</block></then></if>
			<while>while <condition>(<expr><name>q</name> &lt; <name>tail</name></expr>)</condition> <block>{
				<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr>" %02x"</expr></argument>, <argument><expr>*<name>q</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr>++<name>q</name></expr>;</expr_stmt>
			}</block></while>
		}</block></then></if>
		<expr_stmt><expr><call><name>fputc</name><argument_list>(<argument><expr>'\n'</expr></argument>, <argument><expr><name>stderr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>
}</block></function>

<function><type><specifier>static</specifier> <name>size_t</name></type>
<name>printone</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name>*</type> <name>msg</name></decl></param>, <param><decl><type><name>size_t</name></type> <name>value</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>k</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type> <name><name>buf</name><index>[<expr>100</expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>size_t</name></type> <name>origvalue</name> <init>= <expr><name>value</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><name>msg</name></expr></argument>, <argument><expr><name>stderr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for (<init><expr><name>i</name> = (<name>int</name>)<call><name>strlen</name><argument_list>(<argument><expr><name>msg</name></expr></argument>)</argument_list></call></expr>;</init> <condition><expr><name>i</name> &lt; 35</expr>;</condition> <incr><expr>++<name>i</name></expr></incr>)
		<expr_stmt><expr><call><name>fputc</name><argument_list>(<argument><expr>' '</expr></argument>, <argument><expr><name>stderr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></for>
	<expr_stmt><expr><call><name>fputc</name><argument_list>(<argument><expr>'='</expr></argument>, <argument><expr><name>stderr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Write the value with commas. */</comment>
	<expr_stmt><expr><name>i</name> = 22</expr>;</expr_stmt>
	<expr_stmt><expr><name><name>buf</name><index>[<expr><name>i</name>--</expr>]</index></name> = '\0'</expr>;</expr_stmt>
	<expr_stmt><expr><name><name>buf</name><index>[<expr><name>i</name>--</expr>]</index></name> = '\n'</expr>;</expr_stmt>
	<expr_stmt><expr><name>k</name> = 3</expr>;</expr_stmt>
	<do>do <block>{
		<decl_stmt><decl><type><name>size_t</name></type> <name>nextvalue</name> <init>= <expr><name>value</name> / 10</expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>uint</name></type> <name>digit</name> <init>= <expr><call>(<name>uint</name>)<argument_list>(<argument><expr><name>value</name> - <name>nextvalue</name> * 10</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name>value</name> = <name>nextvalue</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>buf</name><index>[<expr><name>i</name>--</expr>]</index></name> = <call>(<name>char</name>)<argument_list>(<argument><expr><name>digit</name> + '0'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr>--<name>k</name></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>k</name> == 0 &amp;&amp; <name>value</name> &amp;&amp; <name>i</name> &gt;= 0</expr>)</condition><then> <block>{
			<expr_stmt><expr><name>k</name> = 3</expr>;</expr_stmt>
			<expr_stmt><expr><name><name>buf</name><index>[<expr><name>i</name>--</expr>]</index></name> = ','</expr>;</expr_stmt>
		}</block></then></if>
	}</block> while <condition>(<expr><name>value</name> &amp;&amp; <name>i</name> &gt;= 0</expr>)</condition>;</do>

	<while>while <condition>(<expr><name>i</name> &gt;= 0</expr>)</condition>
		<expr_stmt><expr><name><name>buf</name><index>[<expr><name>i</name>--</expr>]</index></name> = ' '</expr>;</expr_stmt></while>
	<expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>stderr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>origvalue</name></expr>;</return>
}</block></function>

<comment type="block">/* Print summary info to stderr about the state of pymalloc's structures.
 * In Py_DEBUG mode, also perform some expensive internal consistency
 * checks.
 */</comment>
<function><type><name>void</name></type>
<name>_PyObject_DebugMallocStats</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>uint</name></type> <name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>uint</name></type> <name>numclasses</name> <init>= <expr><name>SMALL_REQUEST_THRESHOLD</name> &gt;&gt; <name>ALIGNMENT_SHIFT</name></expr></init></decl>;</decl_stmt>
	<comment type="block">/* # of pools, allocated blocks, and free blocks per class index */</comment>
	<decl_stmt><decl><type><name>size_t</name></type> <name><name>numpools</name><index>[<expr><name>SMALL_REQUEST_THRESHOLD</name> &gt;&gt; <name>ALIGNMENT_SHIFT</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>size_t</name></type> <name><name>numblocks</name><index>[<expr><name>SMALL_REQUEST_THRESHOLD</name> &gt;&gt; <name>ALIGNMENT_SHIFT</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>size_t</name></type> <name><name>numfreeblocks</name><index>[<expr><name>SMALL_REQUEST_THRESHOLD</name> &gt;&gt; <name>ALIGNMENT_SHIFT</name></expr>]</index></name></decl>;</decl_stmt>
	<comment type="block">/* total # of allocated bytes in used and full pools */</comment>
	<decl_stmt><decl><type><name>size_t</name></type> <name>allocated_bytes</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
	<comment type="block">/* total # of available bytes in used pools */</comment>
	<decl_stmt><decl><type><name>size_t</name></type> <name>available_bytes</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
	<comment type="block">/* # of free pools + pools not yet carved out of current arena */</comment>
	<decl_stmt><decl><type><name>uint</name></type> <name>numfreepools</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
	<comment type="block">/* # of bytes for arena alignment padding */</comment>
	<decl_stmt><decl><type><name>size_t</name></type> <name>arena_alignment</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
	<comment type="block">/* # of bytes in used and full pools used for pool_headers */</comment>
	<decl_stmt><decl><type><name>size_t</name></type> <name>pool_header_bytes</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
	<comment type="block">/* # of bytes in used and full pools wasted due to quantization,
	 * i.e. the necessarily leftover space at the ends of used and
	 * full pools.
	 */</comment>
	<decl_stmt><decl><type><name>size_t</name></type> <name>quantization</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
	<comment type="block">/* # of arenas actually allocated. */</comment>
	<decl_stmt><decl><type><name>size_t</name></type> <name>narenas</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
	<comment type="block">/* running total -- should equal narenas * ARENA_SIZE */</comment>
	<decl_stmt><decl><type><name>size_t</name></type> <name>total</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type> <name><name>buf</name><index>[<expr>128</expr>]</index></name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr>"Small block threshold = %d, in %u size classes.\n"</expr></argument>,
		<argument><expr><name>SMALL_REQUEST_THRESHOLD</name></expr></argument>, <argument><expr><name>numclasses</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>numclasses</name></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>)
		<expr_stmt><expr><name><name>numpools</name><index>[<expr><name>i</name></expr>]</index></name> = <name><name>numblocks</name><index>[<expr><name>i</name></expr>]</index></name> = <name><name>numfreeblocks</name><index>[<expr><name>i</name></expr>]</index></name> = 0</expr>;</expr_stmt></for>

	<comment type="block">/* Because full pools aren't linked to from anything, it's easiest
	 * to march over all the arenas.  If we're lucky, most of the memory
	 * will be living in full pools -- would be a shame to miss them.
	 */</comment>
	<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>maxarenas</name></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>) <block>{
		<decl_stmt><decl><type><name>uint</name></type> <name>poolsinarena</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>uint</name></type> <name>j</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>uptr</name></type> <name>base</name> <init>= <expr><name><name>arenas</name><index>[<expr><name>i</name></expr>]</index></name>.<name>address</name></expr></init></decl>;</decl_stmt>

		<comment type="block">/* Skip arenas which are not allocated. */</comment>
		<if>if <condition>(<expr><name><name>arenas</name><index>[<expr><name>i</name></expr>]</index></name>.<name>address</name> == (<name>uptr</name>)<name>NULL</name></expr>)</condition><then>
			<continue>continue;</continue></then></if>
		<expr_stmt><expr><name>narenas</name> += 1</expr>;</expr_stmt>

		<expr_stmt><expr><name>poolsinarena</name> = <name><name>arenas</name><index>[<expr><name>i</name></expr>]</index></name>.<name>ntotalpools</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>numfreepools</name> += <name><name>arenas</name><index>[<expr><name>i</name></expr>]</index></name>.<name>nfreepools</name></expr>;</expr_stmt>

		<comment type="block">/* round up to pool alignment */</comment>
		<if>if <condition>(<expr><name>base</name> &amp; (<name>uptr</name>)<name>POOL_SIZE_MASK</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><name>arena_alignment</name> += <name>POOL_SIZE</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>base</name> &amp;= ~(<name>uptr</name>)<name>POOL_SIZE_MASK</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>base</name> += <name>POOL_SIZE</name></expr>;</expr_stmt>
		}</block></then></if>

		<comment type="block">/* visit every pool in the arena */</comment>
		<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>base</name> &lt;= (<name>uptr</name>) <name><name>arenas</name><index>[<expr><name>i</name></expr>]</index></name>.<name>pool_address</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<for>for (<init><expr><name>j</name> = 0</expr>;</init>
			    <condition><expr><name>base</name> &lt; (<name>uptr</name>) <name><name>arenas</name><index>[<expr><name>i</name></expr>]</index></name>.<name>pool_address</name></expr>;</condition>
			    <incr><expr>++<name>j</name></expr>, <expr><name>base</name> += <name>POOL_SIZE</name></expr></incr>) <block>{
			<decl_stmt><decl><type><name>poolp</name></type> <name>p</name> <init>= <expr>(<name>poolp</name>)<name>base</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><specifier>const</specifier> <name>uint</name></type> <name>sz</name> <init>= <expr><name><name>p</name>-&gt;<name>szidx</name></name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>uint</name></type> <name>freeblocks</name></decl>;</decl_stmt>

			<if>if <condition>(<expr><name><name>p</name>-&gt;<name>ref</name>.<name>count</name></name> == 0</expr>)</condition><then> <block>{
				<comment type="block">/* currently unused */</comment>
				<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>pool_is_in_list</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>arenas</name><index>[<expr><name>i</name></expr>]</index></name>.<name>freepools</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<continue>continue;</continue>
			}</block></then></if>
			<expr_stmt><expr>++<name><name>numpools</name><index>[<expr><name>sz</name></expr>]</index></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>numblocks</name><index>[<expr><name>sz</name></expr>]</index></name> += <name><name>p</name>-&gt;<name>ref</name>.<name>count</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name>freeblocks</name> = <call><name>NUMBLOCKS</name><argument_list>(<argument><expr><name>sz</name></expr></argument>)</argument_list></call> - <name><name>p</name>-&gt;<name>ref</name>.<name>count</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>numfreeblocks</name><index>[<expr><name>sz</name></expr>]</index></name> += <name>freeblocks</name></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>Py_DEBUG</name></cpp:ifdef>
			<if>if <condition>(<expr><name>freeblocks</name> &gt; 0</expr>)</condition><then>
				<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>pool_is_in_list</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>usedpools</name><index>[<expr><name>sz</name> + <name>sz</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		}</block></for>
	}</block></for>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>narenas</name> == <name>narenas_currently_allocated</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>fputc</name><argument_list>(<argument><expr>'\n'</expr></argument>, <argument><expr><name>stderr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr>"class   size   num pools   blocks in use  avail blocks\n"
	      "-----   ----   ---------   -------------  ------------\n"</expr></argument>,
		<argument><expr><name>stderr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>numclasses</name></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>) <block>{
		<decl_stmt><decl><type><name>size_t</name></type> <name>p</name> <init>= <expr><name><name>numpools</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>size_t</name></type> <name>b</name> <init>= <expr><name><name>numblocks</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>size_t</name></type> <name>f</name> <init>= <expr><name><name>numfreeblocks</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>uint</name></type> <name>size</name> <init>= <expr><call><name>INDEX2SIZE</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if>if <condition>(<expr><name>p</name> == 0</expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>b</name> == 0 &amp;&amp; <name>f</name> == 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<continue>continue;</continue>
		}</block></then></if>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr>"%5u %6u "
				"%11" <name>PY_FORMAT_SIZE_T</name> "u "
				"%15" <name>PY_FORMAT_SIZE_T</name> "u "
				"%13" <name>PY_FORMAT_SIZE_T</name> "u\n"</expr></argument>,
			<argument><expr><name>i</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>allocated_bytes</name> += <name>b</name> * <name>size</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>available_bytes</name> += <name>f</name> * <name>size</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>pool_header_bytes</name> += <name>p</name> * <name>POOL_OVERHEAD</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>quantization</name> += <call><name>p</name> * <argument_list>(<argument><expr>(<name>POOL_SIZE</name> - <name>POOL_OVERHEAD</name>) % <name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></for>
	<expr_stmt><expr><call><name>fputc</name><argument_list>(<argument><expr>'\n'</expr></argument>, <argument><expr><name>stderr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr>(<name>void</name>)<call><name>printone</name><argument_list>(<argument><expr>"# times object malloc called"</expr></argument>, <argument><expr><name>serialno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr>(<name>void</name>)<call><name>printone</name><argument_list>(<argument><expr>"# arenas allocated total"</expr></argument>, <argument><expr><name>ntimes_arena_allocated</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr>(<name>void</name>)<call><name>printone</name><argument_list>(<argument><expr>"# arenas reclaimed"</expr></argument>, <argument><expr><name>ntimes_arena_allocated</name> - <name>narenas</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr>(<name>void</name>)<call><name>printone</name><argument_list>(<argument><expr>"# arenas highwater mark"</expr></argument>, <argument><expr><name>narenas_highwater</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr>(<name>void</name>)<call><name>printone</name><argument_list>(<argument><expr>"# arenas allocated current"</expr></argument>, <argument><expr><name>narenas</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PyOS_snprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>,
		<argument><expr>"%" <name>PY_FORMAT_SIZE_T</name> "u arenas * %d bytes/arena"</expr></argument>,
		<argument><expr><name>narenas</name></expr></argument>, <argument><expr><name>ARENA_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr>(<name>void</name>)<call><name>printone</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>narenas</name> * <name>ARENA_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>fputc</name><argument_list>(<argument><expr>'\n'</expr></argument>, <argument><expr><name>stderr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>total</name> = <call><name>printone</name><argument_list>(<argument><expr>"# bytes in allocated blocks"</expr></argument>, <argument><expr><name>allocated_bytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>total</name> += <call><name>printone</name><argument_list>(<argument><expr>"# bytes in available blocks"</expr></argument>, <argument><expr><name>available_bytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PyOS_snprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>,
		<argument><expr>"%u unused pools * %d bytes"</expr></argument>, <argument><expr><name>numfreepools</name></expr></argument>, <argument><expr><name>POOL_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>total</name> += <call><name>printone</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr>(<name>size_t</name>)<name>numfreepools</name> * <name>POOL_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>total</name> += <call><name>printone</name><argument_list>(<argument><expr>"# bytes lost to pool headers"</expr></argument>, <argument><expr><name>pool_header_bytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>total</name> += <call><name>printone</name><argument_list>(<argument><expr>"# bytes lost to quantization"</expr></argument>, <argument><expr><name>quantization</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>total</name> += <call><name>printone</name><argument_list>(<argument><expr>"# bytes lost to arena alignment"</expr></argument>, <argument><expr><name>arena_alignment</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr>(<name>void</name>)<call><name>printone</name><argument_list>(<argument><expr>"Total"</expr></argument>, <argument><expr><name>total</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>	<comment type="block">/* PYMALLOC_DEBUG */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>Py_USING_MEMORY_DEBUGGER</name></cpp:ifdef>
<comment type="block">/* Make this function last so gcc won't inline it since the definition is
 * after the reference.
 */</comment>
<function><type><name>int</name></type>
<name>Py_ADDRESS_IN_RANGE</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>P</name></decl></param>, <param><decl><type><name>poolp</name></type> <name>pool</name></decl></param>)</parameter_list>
<block>{
	<return>return <expr><name><name>pool</name>-&gt;<name>arenaindex</name></name> &lt; <name>maxarenas</name> &amp;&amp;
	       (<name>uptr</name>)<name>P</name> - <name><name>arenas</name><index>[<expr><name><name>pool</name>-&gt;<name>arenaindex</name></name></expr>]</index></name>.<name>address</name> &lt; (<name>uptr</name>)<name>ARENA_SIZE</name> &amp;&amp;
	       <name><name>arenas</name><index>[<expr><name><name>pool</name>-&gt;<name>arenaindex</name></name></expr>]</index></name>.<name>address</name> != 0</expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</unit>
