<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C" filename="projects/cpython-2.6.1/source/Objects/floatobject.c">
<comment type="block">/* Float object implementation */</comment>

<comment type="block">/* XXX There should be overflow checks here, but it's hard to check
   for any kind of float exception without losing portability. */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"Python.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"structseq.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;ctype.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;float.h&gt;</cpp:file></cpp:include>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>MAX</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>MIN</name></cpp:undef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAX</name><parameter_list>(<param><type><name>x</name></type></param>, <param><type><name>y</name></type></param>)</parameter_list></cpp:macro> <cpp:value>((x) &lt; (y) ? (y) : (x))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MIN</name><parameter_list>(<param><type><name>x</name></type></param>, <param><type><name>y</name></type></param>)</parameter_list></cpp:macro> <cpp:value>((x) &lt; (y) ? (x) : (y))</cpp:value></cpp:define>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_IEEEFP_H</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;ieeefp.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_OSF_SOURCE</name></cpp:ifdef>
<comment type="block">/* OSF1 5.1 doesn't make this available with XOPEN_SOURCE_EXTENDED defined */</comment>
<function_decl><type><specifier>extern</specifier> <name>int</name></type> <name>finite</name><parameter_list>(<param><decl><type><name>double</name></type></decl></param>)</parameter_list>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* Special free list -- see comments for same code in intobject.c. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BLOCK_SIZE</name></cpp:macro>	<cpp:value>1000</cpp:value></cpp:define>	<comment type="block">/* 1K less typical malloc overhead */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BHEAD_SIZE</name></cpp:macro>	<cpp:value>8</cpp:value></cpp:define>	<comment type="block">/* Enough for a 64-bit pointer */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>N_FLOATOBJECTS</name></cpp:macro>	<cpp:value>((BLOCK_SIZE - BHEAD_SIZE) / sizeof(PyFloatObject))</cpp:value></cpp:define>

<struct>struct <name>_floatblock</name> <block>{
	<decl_stmt><decl><type>struct <name>_floatblock</name> *</type><name>next</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyFloatObject</name></type> <name><name>objects</name><index>[<expr><name>N_FLOATOBJECTS</name></expr>]</index></name></decl>;</decl_stmt>
}</block>;</struct>

<typedef>typedef <type>struct <name>_floatblock</name></type> <name>PyFloatBlock</name>;</typedef>

<decl_stmt><decl><type><specifier>static</specifier> <name>PyFloatBlock</name> *</type><name>block_list</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>PyFloatObject</name> *</type><name>free_list</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>PyFloatObject</name> *</type>
<name>fill_free_list</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyFloatObject</name> *</type><name>p</name></decl>, *<decl><type ref="prev"/><name>q</name></decl>;</decl_stmt>
	<comment type="block">/* XXX Float blocks escape the object heap. Use PyObject_MALLOC ??? */</comment>
	<expr_stmt><expr><name>p</name> = (<name>PyFloatObject</name> *) <call><name>PyMem_MALLOC</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PyFloatBlock</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>p</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr>(<name>PyFloatObject</name> *) <call><name>PyErr_NoMemory</name><argument_list>()</argument_list></call></expr>;</return></then></if>
	<expr_stmt><expr>((<name>PyFloatBlock</name> *)<name>p</name>)-&gt;<name>next</name> = <name>block_list</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>block_list</name> = (<name>PyFloatBlock</name> *)<name>p</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>p</name> = &amp;((<name>PyFloatBlock</name> *)<name>p</name>)-&gt;<name><name>objects</name><index>[<expr>0</expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>q</name> = <name>p</name> + <name>N_FLOATOBJECTS</name></expr>;</expr_stmt>
	<while>while <condition>(<expr>--<name>q</name> &gt; <name>p</name></expr>)</condition>
		<expr_stmt><expr><call><name>Py_TYPE</name><argument_list>(<argument><expr><name>q</name></expr></argument>)</argument_list></call> = (struct <name>_typeobject</name> *)(<name>q</name>-1)</expr>;</expr_stmt></while>
	<expr_stmt><expr><call><name>Py_TYPE</name><argument_list>(<argument><expr><name>q</name></expr></argument>)</argument_list></call> = <name>NULL</name></expr>;</expr_stmt>
	<return>return <expr><name>p</name> + <name>N_FLOATOBJECTS</name> - 1</expr>;</return>
}</block></function>

<function><type><name>double</name></type>
<name>PyFloat_GetMax</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list>
<block>{
	<return>return <expr><name>DBL_MAX</name></expr>;</return>
}</block></function>

<function><type><name>double</name></type>
<name>PyFloat_GetMin</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list>
<block>{
	<return>return <expr><name>DBL_MIN</name></expr>;</return>
}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <name>PyTypeObject</name></type> <name>FloatInfoType</name> <init>= <expr><block>{<expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>}</block></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>floatinfo__doc__</name></expr></argument>,
<argument><expr>"sys.floatinfo\n\
\n\
A structseq holding information about the float type. It contains low level\n\
information about the precision and internal representation. Please study\n\
your system's :file:`float.h` for more information."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>PyStructSequence_Field</name></type> <name><name>floatinfo_fields</name><index>[]</index></name> <init>= <expr><block>{
	<expr><block>{<expr>"max"</expr>,		<expr>"DBL_MAX -- maximum representable finite float"</expr>}</block></expr>,
	<expr><block>{<expr>"max_exp"</expr>,	<expr>"DBL_MAX_EXP -- maximum int e such that radix**(e-1) "
			"is representable"</expr>}</block></expr>,
	<expr><block>{<expr>"max_10_exp"</expr>,	<expr>"DBL_MAX_10_EXP -- maximum int e such that 10**e "
			"is representable"</expr>}</block></expr>,
	<expr><block>{<expr>"min"</expr>,		<expr>"DBL_MIN -- Minimum positive normalizer float"</expr>}</block></expr>,
	<expr><block>{<expr>"min_exp"</expr>,	<expr>"DBL_MIN_EXP -- minimum int e such that radix**(e-1) "
			"is a normalized float"</expr>}</block></expr>,
	<expr><block>{<expr>"min_10_exp"</expr>,	<expr>"DBL_MIN_10_EXP -- minimum int e such that 10**e is "
			"a normalized"</expr>}</block></expr>,
	<expr><block>{<expr>"dig"</expr>,		<expr>"DBL_DIG -- digits"</expr>}</block></expr>,
	<expr><block>{<expr>"mant_dig"</expr>,	<expr>"DBL_MANT_DIG -- mantissa digits"</expr>}</block></expr>,
	<expr><block>{<expr>"epsilon"</expr>,	<expr>"DBL_EPSILON -- Difference between 1 and the next "
			"representable float"</expr>}</block></expr>,
	<expr><block>{<expr>"radix"</expr>,	<expr>"FLT_RADIX -- radix of exponent"</expr>}</block></expr>,
	<expr><block>{<expr>"rounds"</expr>,	<expr>"FLT_ROUNDS -- addition rounds"</expr>}</block></expr>,
	<expr><block>{<expr>0</expr>}</block></expr>
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>PyStructSequence_Desc</name></type> <name>floatinfo_desc</name> <init>= <expr><block>{
	<expr>"sys.floatinfo"</expr>,	<comment type="block">/* name */</comment>
	<expr><name>floatinfo__doc__</name></expr>,	<comment type="block">/* doc */</comment>
	<expr><name>floatinfo_fields</name></expr>,	<comment type="block">/* fields */</comment>
	<expr>11</expr>
}</block></expr></init></decl>;</decl_stmt>

<function><type><name>PyObject</name> *</type>
<name>PyFloat_GetInfo</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name>*</type> <name>floatinfo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>pos</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>floatinfo</name> = <call><name>PyStructSequence_New</name><argument_list>(<argument><expr>&amp;<name>FloatInfoType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>floatinfo</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SetIntFlag</name><parameter_list>(<param><type><name>flag</name></type></param>)</parameter_list></cpp:macro> \
	<cpp:value>PyStructSequence_SET_ITEM(floatinfo, pos++, PyInt_FromLong(flag))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SetDblFlag</name><parameter_list>(<param><type><name>flag</name></type></param>)</parameter_list></cpp:macro> \
	<cpp:value>PyStructSequence_SET_ITEM(floatinfo, pos++, PyFloat_FromDouble(flag))</cpp:value></cpp:define>

	<expr_stmt><expr><call><name>SetDblFlag</name><argument_list>(<argument><expr><name>DBL_MAX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SetIntFlag</name><argument_list>(<argument><expr><name>DBL_MAX_EXP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SetIntFlag</name><argument_list>(<argument><expr><name>DBL_MAX_10_EXP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SetDblFlag</name><argument_list>(<argument><expr><name>DBL_MIN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SetIntFlag</name><argument_list>(<argument><expr><name>DBL_MIN_EXP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SetIntFlag</name><argument_list>(<argument><expr><name>DBL_MIN_10_EXP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SetIntFlag</name><argument_list>(<argument><expr><name>DBL_DIG</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SetIntFlag</name><argument_list>(<argument><expr><name>DBL_MANT_DIG</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SetDblFlag</name><argument_list>(<argument><expr><name>DBL_EPSILON</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SetIntFlag</name><argument_list>(<argument><expr><name>FLT_RADIX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SetIntFlag</name><argument_list>(<argument><expr><name>FLT_ROUNDS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>SetIntFlag</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>SetDblFlag</name></cpp:undef>
	
	<if>if <condition>(<expr><call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>Py_CLEAR</name><argument_list>(<argument><expr><name>floatinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>
	<return>return <expr><name>floatinfo</name></expr>;</return>
}</block></function>

<function><type><name>PyObject</name> *</type>
<name>PyFloat_FromDouble</name><parameter_list>(<param><decl><type><name>double</name></type> <name>fval</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>register</name> <name>PyFloatObject</name> *</type><name>op</name></decl>;</decl_stmt>
	<if>if <condition>(<expr><name>free_list</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<if>if <condition>(<expr>(<name>free_list</name> = <call><name>fill_free_list</name><argument_list>()</argument_list></call>) == <name>NULL</name></expr>)</condition><then>
			<return>return <expr><name>NULL</name></expr>;</return></then></if>
	}</block></then></if>
	<comment type="block">/* Inline PyObject_New */</comment>
	<expr_stmt><expr><name>op</name> = <name>free_list</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>free_list</name> = (<name>PyFloatObject</name> *)<call><name>Py_TYPE</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PyObject_INIT</name><argument_list>(<argument><expr><name>op</name></expr></argument>, <argument><expr>&amp;<name>PyFloat_Type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>op</name>-&gt;<name>ob_fval</name></name> = <name>fval</name></expr>;</expr_stmt>
	<return>return <expr>(<name>PyObject</name> *) <name>op</name></expr>;</return>
}</block></function>

<comment type="block">/**************************************************************************
RED_FLAG 22-Sep-2000 tim
PyFloat_FromString's pend argument is braindead.  Prior to this RED_FLAG,

1.  If v was a regular string, *pend was set to point to its terminating
    null byte.  That's useless (the caller can find that without any
    help from this function!).

2.  If v was a Unicode string, or an object convertible to a character
    buffer, *pend was set to point into stack trash (the auto temp
    vector holding the character buffer).  That was downright dangerous.

Since we can't change the interface of a public API function, pend is
still supported but now *officially* useless:  if pend is not NULL,
*pend is set to NULL.
**************************************************************************/</comment>
<function><type><name>PyObject</name> *</type>
<name>PyFloat_FromString</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>v</name></decl></param>, <param><decl><type><name>char</name> **</type><name>pend</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>s</name></decl>, *<decl><type ref="prev"/><name>last</name></decl>, *<decl><type ref="prev"/><name>end</name></decl>, *<decl><type ref="prev"/><name>sp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type> <name>x</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type> <name><name>buffer</name><index>[<expr>256</expr>]</index></name></decl>;</decl_stmt> <comment type="block">/* for errors */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>Py_USING_UNICODE</name></cpp:ifdef>
	<decl_stmt><decl><type><name>char</name></type> <name><name>s_buffer</name><index>[<expr>256</expr>]</index></name></decl>;</decl_stmt> <comment type="block">/* for objects convertible to a char buffer */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>len</name></decl>;</decl_stmt>

	<if>if <condition>(<expr><name>pend</name></expr>)</condition><then>
		<expr_stmt><expr>*<name>pend</name> = <name>NULL</name></expr>;</expr_stmt></then></if>
	<if>if <condition>(<expr><call><name>PyString_Check</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>s</name> = <call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>len</name> = <call><name>PyString_GET_SIZE</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>Py_USING_UNICODE</name></cpp:ifdef>
	<else>else <if>if <condition>(<expr><call><name>PyUnicode_Check</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<if>if <condition>(<expr><call><name>PyUnicode_GET_SIZE</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call> &gt;= (<name>Py_ssize_t</name>)<sizeof>sizeof<argument_list>(<argument><expr><name>s_buffer</name></expr></argument>)</argument_list></sizeof></expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>,
				<argument><expr>"Unicode float() literal too long to convert"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>NULL</name></expr>;</return>
		}</block></then></if>
		<if>if <condition>(<expr><call><name>PyUnicode_EncodeDecimal</name><argument_list>(<argument><expr><call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></argument>,
					    <argument><expr><call><name>PyUnicode_GET_SIZE</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></argument>,
					    <argument><expr><name>s_buffer</name></expr></argument>,
					    <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition><then>
			<return>return <expr><name>NULL</name></expr>;</return></then></if>
		<expr_stmt><expr><name>s</name> = <name>s_buffer</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>len</name> = <call><name>strlen</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<else>else <if>if <condition>(<expr><call><name>PyObject_AsCharBuffer</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr>&amp;<name>s</name></expr></argument>, <argument><expr>&amp;<name>len</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
				<argument><expr>"float() argument must be a string or a number"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if></else></if></else></if>

	<expr_stmt><expr><name>last</name> = <name>s</name> + <name>len</name></expr>;</expr_stmt>
	<while>while <condition>(<expr>*<name>s</name> &amp;&amp; <call><name>isspace</name><argument_list>(<argument><expr><call><name>Py_CHARMASK</name><argument_list>(<argument><expr>*<name>s</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
		<expr_stmt><expr><name>s</name>++</expr>;</expr_stmt></while>
	<if>if <condition>(<expr>*<name>s</name> == '\0'</expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>, <argument><expr>"empty string for float()"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>
	<expr_stmt><expr><name>sp</name> = <name>s</name></expr>;</expr_stmt>
	<comment type="block">/* We don't care about overflow or underflow.  If the platform supports
	 * them, infinities and signed zeroes (on underflow) are fine.
	 * However, strtod can return 0 for denormalized numbers, where atof
	 * does not.  So (alas!) we special-case a zero result.  Note that
	 * whether strtod sets errno on underflow is not defined, so we can't
	 * key off errno.
         */</comment>
	<macro><name>PyFPE_START_PROTECT</name><argument_list>(<argument>"strtod"</argument>, <argument>return NULL</argument>)</argument_list></macro>
	<expr_stmt><expr><name>x</name> = <call><name>PyOS_ascii_strtod</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr>(<name>char</name> **)&amp;<name>end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<macro><name>PyFPE_END_PROTECT</name><argument_list>(<argument>x</argument>)</argument_list></macro>
	<expr_stmt><expr><name>errno</name> = 0</expr>;</expr_stmt>
	<comment type="block">/* Believe it or not, Solaris 2.6 can move end *beyond* the null
	   byte at the end of the string, when the input is inf(inity). */</comment>
	<if>if <condition>(<expr><name>end</name> &gt; <name>last</name></expr>)</condition><then>
		<expr_stmt><expr><name>end</name> = <name>last</name></expr>;</expr_stmt></then></if>
	<comment type="block">/* Check for inf and nan. This is done late because it rarely happens. */</comment>
	<if>if <condition>(<expr><name>end</name> == <name>s</name></expr>)</condition><then> <block>{
		<decl_stmt><decl><type><name>char</name> *</type><name>p</name> <init>= <expr>(<name>char</name>*)<name>sp</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>sign</name> <init>= <expr>1</expr></init></decl>;</decl_stmt>

		<if>if <condition>(<expr>*<name>p</name> == '-'</expr>)</condition><then> <block>{
			<expr_stmt><expr><name>sign</name> = -1</expr>;</expr_stmt>
			<expr_stmt><expr><name>p</name>++</expr>;</expr_stmt>
		}</block></then></if>
		<if>if <condition>(<expr>*<name>p</name> == '+'</expr>)</condition><then> <block>{
			<expr_stmt><expr><name>p</name>++</expr>;</expr_stmt>
		}</block></then></if>
		<if>if <condition>(<expr><call><name>PyOS_strnicmp</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr>"inf"</expr></argument>, <argument><expr>4</expr></argument>)</argument_list></call> == 0</expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>Py_RETURN_INF</name><argument_list>(<argument><expr><name>sign</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></then></if>
		<if>if <condition>(<expr><call><name>PyOS_strnicmp</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr>"infinity"</expr></argument>, <argument><expr>9</expr></argument>)</argument_list></call> == 0</expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>Py_RETURN_INF</name><argument_list>(<argument><expr><name>sign</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></then></if>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>Py_NAN</name></cpp:ifdef>
		<if>if<condition>(<expr><call><name>PyOS_strnicmp</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr>"nan"</expr></argument>, <argument><expr>4</expr></argument>)</argument_list></call> == 0</expr>)</condition><then> <block>{
			<expr_stmt><expr><name>Py_RETURN_NAN</name></expr>;</expr_stmt>
		}</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		<expr_stmt><expr><call><name>PyOS_snprintf</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></sizeof></expr></argument>,
			      <argument><expr>"invalid literal for float(): %.200s"</expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>
	<comment type="block">/* Since end != s, the platform made *some* kind of sense out
	   of the input.  Trust it. */</comment>
	<while>while <condition>(<expr>*<name>end</name> &amp;&amp; <call><name>isspace</name><argument_list>(<argument><expr><call><name>Py_CHARMASK</name><argument_list>(<argument><expr>*<name>end</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
		<expr_stmt><expr><name>end</name>++</expr>;</expr_stmt></while>
	<if>if <condition>(<expr>*<name>end</name> != '\0'</expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyOS_snprintf</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></sizeof></expr></argument>,
			      <argument><expr>"invalid literal for float(): %.200s"</expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then>
	<else>else <if>if <condition>(<expr><name>end</name> != <name>last</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>,
				<argument><expr>"null byte in argument for float()"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if></else></if>
	<if>if <condition>(<expr><name>x</name> == 0.0</expr>)</condition><then> <block>{
		<comment type="block">/* See above -- may have been strtod being anal
		   about denorms. */</comment>
		<macro><name>PyFPE_START_PROTECT</name><argument_list>(<argument>"atof"</argument>, <argument>return NULL</argument>)</argument_list></macro>
		<expr_stmt><expr><name>x</name> = <call><name>PyOS_ascii_atof</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<macro><name>PyFPE_END_PROTECT</name><argument_list>(<argument>x</argument>)</argument_list></macro>
		<expr_stmt><expr><name>errno</name> = 0</expr>;</expr_stmt>    <comment type="block">/* whether atof ever set errno is undefined */</comment>
	}</block></then></if>
	<return>return <expr><call><name>PyFloat_FromDouble</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>float_dealloc</name><parameter_list>(<param><decl><type><name>PyFloatObject</name> *</type><name>op</name></decl></param>)</parameter_list>
<block>{
	<if>if <condition>(<expr><call><name>PyFloat_CheckExact</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>Py_TYPE</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call> = (struct <name>_typeobject</name> *)<name>free_list</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>free_list</name> = <name>op</name></expr>;</expr_stmt>
	}</block></then>
	<else>else
		<expr_stmt><expr><call><name>Py_TYPE</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call>-&gt;<call><name>tp_free</name><argument_list>(<argument><expr>(<name>PyObject</name> *)<name>op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
}</block></function>

<function><type><name>double</name></type>
<name>PyFloat_AsDouble</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>op</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyNumberMethods</name> *</type><name>nb</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyFloatObject</name> *</type><name>fo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type> <name>val</name></decl>;</decl_stmt>

	<if>if <condition>(<expr><name>op</name> &amp;&amp; <call><name>PyFloat_Check</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><call><name>PyFloat_AS_DOUBLE</name><argument_list>(<argument><expr>(<name>PyFloatObject</name>*) <name>op</name></expr></argument>)</argument_list></call></expr>;</return></then></if>

	<if>if <condition>(<expr><name>op</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_BadArgument</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>-1</expr>;</return>
	}</block></then></if>

	<if>if <condition>(<expr>(<name>nb</name> = <call><name>Py_TYPE</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call>-&gt;<name>tp_as_number</name>) == <name>NULL</name> || <name><name>nb</name>-&gt;<name>nb_float</name></name> == <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>, <argument><expr>"a float is required"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>-1</expr>;</return>
	}</block></then></if>

	<expr_stmt><expr><name>fo</name> = <call><call>(<name>PyFloatObject</name>*) <argument_list>(<argument><expr>*<name><name>nb</name>-&gt;<name>nb_float</name></name></expr></argument>)</argument_list></call> <argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>fo</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr>-1</expr>;</return></then></if>
	<if>if <condition>(<expr>!<call><name>PyFloat_Check</name><argument_list>(<argument><expr><name>fo</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
				<argument><expr>"nb_float should return float object"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>-1</expr>;</return>
	}</block></then></if>

	<expr_stmt><expr><name>val</name> = <call><name>PyFloat_AS_DOUBLE</name><argument_list>(<argument><expr><name>fo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>fo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>val</name></expr>;</return>
}</block></function>

<comment type="block">/* Methods */</comment>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>format_float</name><parameter_list>(<param><decl><type><name>char</name> *</type><name>buf</name></decl></param>, <param><decl><type><name>size_t</name></type> <name>buflen</name></decl></param>, <param><decl><type><name>PyFloatObject</name> *</type><name>v</name></decl></param>, <param><decl><type><name>int</name></type> <name>precision</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>register</name> <name>char</name> *</type><name>cp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type> <name><name>format</name><index>[<expr>32</expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

	<comment type="block">/* Subroutine for float_repr and float_print.
	   We want float numbers to be recognizable as such,
	   i.e., they should contain a decimal point or an exponent.
	   However, %g may print the number as an integer;
	   in such cases, we append ".0" to the string. */</comment>

	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>PyFloat_Check</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PyOS_snprintf</name><argument_list>(<argument><expr><name>format</name></expr></argument>, <argument><expr>32</expr></argument>, <argument><expr>"%%.%ig"</expr></argument>, <argument><expr><name>precision</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PyOS_ascii_formatd</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>buflen</name></expr></argument>, <argument><expr><name>format</name></expr></argument>, <argument><expr><name><name>v</name>-&gt;<name>ob_fval</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>cp</name> = <name>buf</name></expr>;</expr_stmt>
	<if>if <condition>(<expr>*<name>cp</name> == '-'</expr>)</condition><then>
		<expr_stmt><expr><name>cp</name>++</expr>;</expr_stmt></then></if>
	<for>for (<init>;</init> <condition><expr>*<name>cp</name> != '\0'</expr>;</condition> <incr><expr><name>cp</name>++</expr></incr>) <block>{
		<comment type="block">/* Any non-digit means it's not an integer;
		   this takes care of NAN and INF as well. */</comment>
		<if>if <condition>(<expr>!<call><name>isdigit</name><argument_list>(<argument><expr><call><name>Py_CHARMASK</name><argument_list>(<argument><expr>*<name>cp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then>
			<break>break;</break></then></if>
	}</block></for>
	<if>if <condition>(<expr>*<name>cp</name> == '\0'</expr>)</condition><then> <block>{
		<expr_stmt><expr>*<name>cp</name>++ = '.'</expr>;</expr_stmt>
		<expr_stmt><expr>*<name>cp</name>++ = '0'</expr>;</expr_stmt>
		<expr_stmt><expr>*<name>cp</name>++ = '\0'</expr>;</expr_stmt>
		<return>return;</return>
	}</block></then></if>
	<comment type="block">/* Checking the next three chars should be more than enough to
	 * detect inf or nan, even on Windows. We check for inf or nan
	 * at last because they are rare cases.
	 */</comment>
	<for>for (<init><expr><name>i</name>=0</expr>;</init> <condition><expr>*<name>cp</name> != '\0' &amp;&amp; <name>i</name>&lt;3</expr>;</condition> <incr><expr><name>cp</name>++</expr>, <expr><name>i</name>++</expr></incr>) <block>{
		<if>if <condition>(<expr><call><name>isdigit</name><argument_list>(<argument><expr><call><name>Py_CHARMASK</name><argument_list>(<argument><expr>*<name>cp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> || *<name>cp</name> == '.'</expr>)</condition><then>
			<continue>continue;</continue></then></if>
		<comment type="block">/* found something that is neither a digit nor point
		 * it might be a NaN or INF
		 */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>Py_NAN</name></cpp:ifdef>
		<if>if <condition>(<expr><call><name>Py_IS_NAN</name><argument_list>(<argument><expr><name><name>v</name>-&gt;<name>ob_fval</name></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr>"nan"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></then>
                <else>else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		<if>if <condition>(<expr><call><name>Py_IS_INFINITY</name><argument_list>(<argument><expr><name><name>v</name>-&gt;<name>ob_fval</name></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
			<expr_stmt><expr><name>cp</name> = <name>buf</name></expr>;</expr_stmt>
			<if>if <condition>(<expr>*<name>cp</name> == '-'</expr>)</condition><then>
				<expr_stmt><expr><name>cp</name>++</expr>;</expr_stmt></then></if>
			<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr>"inf"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></then></if></else></if>
		<break>break;</break>
	}</block></for>

}</block></function>

<comment type="block">/* XXX PyFloat_AsStringEx should not be a public API function (for one
   XXX thing, its signature passes a buffer without a length; for another,
   XXX it isn't useful outside this file).
*/</comment>
<function><type><name>void</name></type>
<name>PyFloat_AsStringEx</name><parameter_list>(<param><decl><type><name>char</name> *</type><name>buf</name></decl></param>, <param><decl><type><name>PyFloatObject</name> *</type><name>v</name></decl></param>, <param><decl><type><name>int</name></type> <name>precision</name></decl></param>)</parameter_list>
<block>{
	<expr_stmt><expr><call><name>format_float</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr>100</expr></argument>, <argument><expr><name>v</name></expr></argument>, <argument><expr><name>precision</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<comment type="block">/* Macro and helper that convert PyObject obj to a C double and store
   the value in dbl; this replaces the functionality of the coercion
   slot function.  If conversion to double raises an exception, obj is
   set to NULL, and the function invoking this macro returns NULL.  If
   obj is not of float, int or long type, Py_NotImplemented is incref'ed,
   stored in obj, and returned from the function invoking this macro.
*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CONVERT_TO_DOUBLE</name><parameter_list>(<param><type><name>obj</name></type></param>, <param><type><name>dbl</name></type></param>)</parameter_list></cpp:macro>			\
	<cpp:value>if (PyFloat_Check(obj))				\
		dbl = PyFloat_AS_DOUBLE(obj);		\
	else if (convert_to_double(&amp;(obj), &amp;(dbl)) &lt; 0)	\
		return obj;</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>convert_to_double</name><parameter_list>(<param><decl><type><name>PyObject</name> **</type><name>v</name></decl></param>, <param><decl><type><name>double</name> *</type><name>dbl</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>register</name> <name>PyObject</name> *</type><name>obj</name> <init>= <expr>*<name>v</name></expr></init></decl>;</decl_stmt>

	<if>if <condition>(<expr><call><name>PyInt_Check</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr>*<name>dbl</name> = (<name>double</name>)<call><name>PyInt_AS_LONG</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then>
	<else>else <if>if <condition>(<expr><call><name>PyLong_Check</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr>*<name>dbl</name> = <call><name>PyLong_AsDouble</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr>*<name>dbl</name> == -1.0 &amp;&amp; <call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
			<expr_stmt><expr>*<name>v</name> = <name>NULL</name></expr>;</expr_stmt>
			<return>return <expr>-1</expr>;</return>
		}</block></then></if>
	}</block></then>
	<else>else <block>{
		<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_NotImplemented</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr>*<name>v</name> = <name>Py_NotImplemented</name></expr>;</expr_stmt>
		<return>return <expr>-1</expr>;</return>
	}</block></else></if></else></if>
	<return>return <expr>0</expr>;</return>
}</block></function>

<comment type="block">/* Precisions used by repr() and str(), respectively.

   The repr() precision (17 significant decimal digits) is the minimal number
   that is guaranteed to have enough precision so that if the number is read
   back in the exact same binary value is recreated.  This is true for IEEE
   floating point by design, and also happens to work for all other modern
   hardware.

   The str() precision is chosen so that in most cases, the rounding noise
   created by various operations is suppressed, while giving plenty of
   precision for practical use.

*/</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PREC_REPR</name></cpp:macro>	<cpp:value>17</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PREC_STR</name></cpp:macro>	<cpp:value>12</cpp:value></cpp:define>

<comment type="block">/* XXX PyFloat_AsString and PyFloat_AsReprString should be deprecated:
   XXX they pass a char buffer without passing a length.
*/</comment>
<function><type><name>void</name></type>
<name>PyFloat_AsString</name><parameter_list>(<param><decl><type><name>char</name> *</type><name>buf</name></decl></param>, <param><decl><type><name>PyFloatObject</name> *</type><name>v</name></decl></param>)</parameter_list>
<block>{
	<expr_stmt><expr><call><name>format_float</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr>100</expr></argument>, <argument><expr><name>v</name></expr></argument>, <argument><expr><name>PREC_STR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><name>void</name></type>
<name>PyFloat_AsReprString</name><parameter_list>(<param><decl><type><name>char</name> *</type><name>buf</name></decl></param>, <param><decl><type><name>PyFloatObject</name> *</type><name>v</name></decl></param>)</parameter_list>
<block>{
	<expr_stmt><expr><call><name>format_float</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr>100</expr></argument>, <argument><expr><name>v</name></expr></argument>, <argument><expr><name>PREC_REPR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<comment type="block">/* ARGSUSED */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>float_print</name><parameter_list>(<param><decl><type><name>PyFloatObject</name> *</type><name>v</name></decl></param>, <param><decl><type><name>FILE</name> *</type><name>fp</name></decl></param>, <param><decl><type><name>int</name></type> <name>flags</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>char</name></type> <name><name>buf</name><index>[<expr>100</expr>]</index></name></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>format_float</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>v</name></expr></argument>,
		     <argument><expr>(<name>flags</name> &amp; <name>Py_PRINT_RAW</name>) ? <name>PREC_STR</name> : <name>PREC_REPR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<function_decl><type><name>Py_BEGIN_ALLOW_THREADS</name></type>
	<name>fputs</name><parameter_list>(<param><decl><type><name>buf</name></type></decl></param>, <param><decl><type><name>fp</name></type></decl></param>)</parameter_list>;</function_decl>
	<macro><name>Py_END_ALLOW_THREADS</name></macro>
	<return>return <expr>0</expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>float_repr</name><parameter_list>(<param><decl><type><name>PyFloatObject</name> *</type><name>v</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>char</name></type> <name><name>buf</name><index>[<expr>100</expr>]</index></name></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>format_float</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>v</name></expr></argument>, <argument><expr><name>PREC_REPR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><call><name>PyString_FromString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>float_str</name><parameter_list>(<param><decl><type><name>PyFloatObject</name> *</type><name>v</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>char</name></type> <name><name>buf</name><index>[<expr>100</expr>]</index></name></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>format_float</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>v</name></expr></argument>, <argument><expr><name>PREC_STR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><call><name>PyString_FromString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<comment type="block">/* Comparison is pretty much a nightmare.  When comparing float to float,
 * we do it as straightforwardly (and long-windedly) as conceivable, so
 * that, e.g., Python x == y delivers the same result as the platform
 * C x == y when x and/or y is a NaN.
 * When mixing float with an integer type, there's no good *uniform* approach.
 * Converting the double to an integer obviously doesn't work, since we
 * may lose info from fractional bits.  Converting the integer to a double
 * also has two failure modes:  (1) a long int may trigger overflow (too
 * large to fit in the dynamic range of a C double); (2) even a C long may have
 * more bits than fit in a C double (e.g., on a a 64-bit box long may have
 * 63 bits of precision, but a C double probably has only 53), and then
 * we can falsely claim equality when low-order integer bits are lost by
 * coercion to double.  So this part is painful too.
 */</comment>

<function><type><specifier>static</specifier> <name>PyObject</name>*</type>
<name>float_richcompare</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>v</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>w</name></decl></param>, <param><decl><type><name>int</name></type> <name>op</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>double</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>r</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>PyFloat_Check</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i</name> = <call><name>PyFloat_AS_DOUBLE</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Switch on the type of w.  Set i and j to doubles to be compared,
	 * and op to the richcomp to use.
	 */</comment>
	<if>if <condition>(<expr><call><name>PyFloat_Check</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<expr_stmt><expr><name>j</name> = <call><name>PyFloat_AS_DOUBLE</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>

	<else>else <if>if <condition>(<expr>!<call><name>Py_IS_FINITE</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<if>if <condition>(<expr><call><name>PyInt_Check</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call> || <call><name>PyLong_Check</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>)</condition><then>
			<comment type="block">/* If i is an infinity, its magnitude exceeds any
			 * finite integer, so it doesn't matter which int we
			 * compare i with.  If i is a NaN, similarly.
			 */</comment>
			<expr_stmt><expr><name>j</name> = 0.0</expr>;</expr_stmt></then>
		<else>else
			<goto>goto <name>Unimplemented</name>;</goto></else></if>
	}</block></then>

	<else>else <if>if <condition>(<expr><call><name>PyInt_Check</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<decl_stmt><decl><type><name>long</name></type> <name>jj</name> <init>= <expr><call><name>PyInt_AS_LONG</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<comment type="block">/* In the worst realistic case I can imagine, C double is a
		 * Cray single with 48 bits of precision, and long has 64
		 * bits.
		 */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SIZEOF_LONG</name> &gt; 6</expr></cpp:if>
		<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>abs</name> <init>= <expr><call>(<name>unsigned</name> <name>long</name>)<argument_list>(<argument><expr><name>jj</name> &lt; 0 ? -<name>jj</name> : <name>jj</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if>if <condition>(<expr><name>abs</name> &gt;&gt; 48</expr>)</condition><then> <block>{
			<comment type="block">/* Needs more than 48 bits.  Make it take the
			 * PyLong path.
			 */</comment>
			<decl_stmt><decl><type><name>PyObject</name> *</type><name>result</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>PyObject</name> *</type><name>ww</name> <init>= <expr><call><name>PyLong_FromLong</name><argument_list>(<argument><expr><name>jj</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if>if <condition>(<expr><name>ww</name> == <name>NULL</name></expr>)</condition><then>
				<return>return <expr><name>NULL</name></expr>;</return></then></if>
			<expr_stmt><expr><name>result</name> = <call><name>float_richcompare</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>ww</name></expr></argument>, <argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>ww</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>result</name></expr>;</return>
		}</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		<expr_stmt><expr><name>j</name> = (<name>double</name>)<name>jj</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr>(<name>long</name>)<name>j</name> == <name>jj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then>

	<else>else <if>if <condition>(<expr><call><name>PyLong_Check</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<decl_stmt><decl><type><name>int</name></type> <name>vsign</name> <init>= <expr><name>i</name> == 0.0 ? 0 : <name>i</name> &lt; 0.0 ? -1 : 1</expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>wsign</name> <init>= <expr><call><name>_PyLong_Sign</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>size_t</name></type> <name>nbits</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>exponent</name></decl>;</decl_stmt>

		<if>if <condition>(<expr><name>vsign</name> != <name>wsign</name></expr>)</condition><then> <block>{
			<comment type="block">/* Magnitudes are irrelevant -- the signs alone
			 * determine the outcome.
			 */</comment>
			<expr_stmt><expr><name>i</name> = (<name>double</name>)<name>vsign</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>j</name> = (<name>double</name>)<name>wsign</name></expr>;</expr_stmt>
			<goto>goto <name>Compare</name>;</goto>
		}</block></then></if>
		<comment type="block">/* The signs are the same. */</comment>
		<comment type="block">/* Convert w to a double if it fits.  In particular, 0 fits. */</comment>
		<expr_stmt><expr><name>nbits</name> = <call><name>_PyLong_NumBits</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>nbits</name> == (<name>size_t</name>)-1 &amp;&amp; <call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
			<comment type="block">/* This long is so large that size_t isn't big enough
			 * to hold the # of bits.  Replace with little doubles
			 * that give the same outcome -- w is so large that
			 * its magnitude must exceed the magnitude of any
			 * finite float.
			 */</comment>
			<expr_stmt><expr><call><name>PyErr_Clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>i</name> = (<name>double</name>)<name>vsign</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>wsign</name> != 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>j</name> = <name>wsign</name> * 2.0</expr>;</expr_stmt>
			<goto>goto <name>Compare</name>;</goto>
		}</block></then></if>
		<if>if <condition>(<expr><name>nbits</name> &lt;= 48</expr>)</condition><then> <block>{
			<expr_stmt><expr><name>j</name> = <call><name>PyLong_AsDouble</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* It's impossible that &lt;= 48 bits overflowed. */</comment>
			<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>j</name> != -1.0 || ! <call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<goto>goto <name>Compare</name>;</goto>
		}</block></then></if>
		<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>wsign</name> != 0</expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* else nbits was 0 */</comment>
		<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>vsign</name> != 0</expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* if vsign were 0, then since wsign is
		                     * not 0, we would have taken the
		                     * vsign != wsign branch at the start */</comment>
		<comment type="block">/* We want to work with non-negative numbers. */</comment>
		<if>if <condition>(<expr><name>vsign</name> &lt; 0</expr>)</condition><then> <block>{
			<comment type="block">/* "Multiply both sides" by -1; this also swaps the
			 * comparator.
			 */</comment>
			<expr_stmt><expr><name>i</name> = -<name>i</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>op</name> = <name><name>_Py_SwappedOp</name><index>[<expr><name>op</name></expr>]</index></name></expr>;</expr_stmt>
		}</block></then></if>
		<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>i</name> &gt; 0.0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr>(<name>void</name>) <call><name>frexp</name><argument_list>(<argument><expr><name>i</name></expr></argument>, <argument><expr>&amp;<name>exponent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* exponent is the # of bits in v before the radix point;
		 * we know that nbits (the # of bits in w) &gt; 48 at this point
		 */</comment>
		<if>if <condition>(<expr><name>exponent</name> &lt; 0 || (<name>size_t</name>)<name>exponent</name> &lt; <name>nbits</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><name>i</name> = 1.0</expr>;</expr_stmt>
			<expr_stmt><expr><name>j</name> = 2.0</expr>;</expr_stmt>
			<goto>goto <name>Compare</name>;</goto>
		}</block></then></if>
		<if>if <condition>(<expr>(<name>size_t</name>)<name>exponent</name> &gt; <name>nbits</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><name>i</name> = 2.0</expr>;</expr_stmt>
			<expr_stmt><expr><name>j</name> = 1.0</expr>;</expr_stmt>
			<goto>goto <name>Compare</name>;</goto>
		}</block></then></if>
		<comment type="block">/* v and w have the same number of bits before the radix
		 * point.  Construct two longs that have the same comparison
		 * outcome.
		 */</comment>
		<block>{
			<decl_stmt><decl><type><name>double</name></type> <name>fracpart</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>double</name></type> <name>intpart</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>PyObject</name> *</type><name>result</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>PyObject</name> *</type><name>one</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>PyObject</name> *</type><name>vv</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>PyObject</name> *</type><name>ww</name> <init>= <expr><name>w</name></expr></init></decl>;</decl_stmt>

			<if>if <condition>(<expr><name>wsign</name> &lt; 0</expr>)</condition><then> <block>{
				<expr_stmt><expr><name>ww</name> = <call><name>PyNumber_Negative</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if>if <condition>(<expr><name>ww</name> == <name>NULL</name></expr>)</condition><then>
					<goto>goto <name>Error</name>;</goto></then></if>
			}</block></then>
			<else>else
				<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>ww</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>

			<expr_stmt><expr><name>fracpart</name> = <call><name>modf</name><argument_list>(<argument><expr><name>i</name></expr></argument>, <argument><expr>&amp;<name>intpart</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>vv</name> = <call><name>PyLong_FromDouble</name><argument_list>(<argument><expr><name>intpart</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><name>vv</name> == <name>NULL</name></expr>)</condition><then>
				<goto>goto <name>Error</name>;</goto></then></if>

			<if>if <condition>(<expr><name>fracpart</name> != 0.0</expr>)</condition><then> <block>{
				<comment type="block">/* Shift left, and or a 1 bit into vv
				 * to represent the lost fraction.
				 */</comment>
				<decl_stmt><decl><type><name>PyObject</name> *</type><name>temp</name></decl>;</decl_stmt>

				<expr_stmt><expr><name>one</name> = <call><name>PyInt_FromLong</name><argument_list>(<argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if>if <condition>(<expr><name>one</name> == <name>NULL</name></expr>)</condition><then>
					<goto>goto <name>Error</name>;</goto></then></if>

				<expr_stmt><expr><name>temp</name> = <call><name>PyNumber_Lshift</name><argument_list>(<argument><expr><name>ww</name></expr></argument>, <argument><expr><name>one</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if>if <condition>(<expr><name>temp</name> == <name>NULL</name></expr>)</condition><then>
					<goto>goto <name>Error</name>;</goto></then></if>
				<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>ww</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>ww</name> = <name>temp</name></expr>;</expr_stmt>

				<expr_stmt><expr><name>temp</name> = <call><name>PyNumber_Lshift</name><argument_list>(<argument><expr><name>vv</name></expr></argument>, <argument><expr><name>one</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if>if <condition>(<expr><name>temp</name> == <name>NULL</name></expr>)</condition><then>
					<goto>goto <name>Error</name>;</goto></then></if>
				<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>vv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>vv</name> = <name>temp</name></expr>;</expr_stmt>

				<expr_stmt><expr><name>temp</name> = <call><name>PyNumber_Or</name><argument_list>(<argument><expr><name>vv</name></expr></argument>, <argument><expr><name>one</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if>if <condition>(<expr><name>temp</name> == <name>NULL</name></expr>)</condition><then>
					<goto>goto <name>Error</name>;</goto></then></if>
				<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>vv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>vv</name> = <name>temp</name></expr>;</expr_stmt>
			}</block></then></if>

			<expr_stmt><expr><name>r</name> = <call><name>PyObject_RichCompareBool</name><argument_list>(<argument><expr><name>vv</name></expr></argument>, <argument><expr><name>ww</name></expr></argument>, <argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><name>r</name> &lt; 0</expr>)</condition><then>
				<goto>goto <name>Error</name>;</goto></then></if>
			<expr_stmt><expr><name>result</name> = <call><name>PyBool_FromLong</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
 		 <label><name>Error</name>:</label>
 		 	<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>vv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
 		 	<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>ww</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
 		 	<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>one</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
 		 	<return>return <expr><name>result</name></expr>;</return>
		}</block>
	}</block></then> <comment type="block">/* else if (PyLong_Check(w)) */</comment>

	<else>else	<comment type="block">/* w isn't float, int, or long */</comment>
		<goto>goto <name>Unimplemented</name>;</goto></else></if></else></if></else></if></else></if>

 <label><name>Compare</name>:</label>
	<macro><name>PyFPE_START_PROTECT</name><argument_list>(<argument>"richcompare"</argument>, <argument>return NULL</argument>)</argument_list></macro>
	<switch>switch <condition>(<expr><name>op</name></expr>)</condition> <block>{
	<case>case <expr><name>Py_EQ</name></expr>:
		<expr_stmt><expr><name>r</name> = <name>i</name> == <name>j</name></expr>;</expr_stmt>
		<break>break;</break>
	</case><case>case <expr><name>Py_NE</name></expr>:
		<expr_stmt><expr><name>r</name> = <name>i</name> != <name>j</name></expr>;</expr_stmt>
		<break>break;</break>
	</case><case>case <expr><name>Py_LE</name></expr>:
		<expr_stmt><expr><name>r</name> = <name>i</name> &lt;= <name>j</name></expr>;</expr_stmt>
		<break>break;</break>
	</case><case>case <expr><name>Py_GE</name></expr>:
		<expr_stmt><expr><name>r</name> = <name>i</name> &gt;= <name>j</name></expr>;</expr_stmt>
		<break>break;</break>
	</case><case>case <expr><name>Py_LT</name></expr>:
		<expr_stmt><expr><name>r</name> = <name>i</name> &lt; <name>j</name></expr>;</expr_stmt>
		<break>break;</break>
	</case><case>case <expr><name>Py_GT</name></expr>:
		<expr_stmt><expr><name>r</name> = <name>i</name> &gt; <name>j</name></expr>;</expr_stmt>
		<break>break;</break>
	</case>}</block></switch>
	<macro><name>PyFPE_END_PROTECT</name><argument_list>(<argument>r</argument>)</argument_list></macro>
	<return>return <expr><call><name>PyBool_FromLong</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</return>

 <label><name>Unimplemented</name>:</label>
	<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_NotImplemented</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>Py_NotImplemented</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>long</name></type>
<name>float_hash</name><parameter_list>(<param><decl><type><name>PyFloatObject</name> *</type><name>v</name></decl></param>)</parameter_list>
<block>{
	<return>return <expr><call><name>_Py_HashDouble</name><argument_list>(<argument><expr><name><name>v</name>-&gt;<name>ob_fval</name></name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>float_add</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>v</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>w</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>double</name></type> <name>a</name></decl>,<decl><type ref="prev"/><name>b</name></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>CONVERT_TO_DOUBLE</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CONVERT_TO_DOUBLE</name><argument_list>(<argument><expr><name>w</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<macro><name>PyFPE_START_PROTECT</name><argument_list>(<argument>"add"</argument>, <argument>return 0</argument>)</argument_list></macro>
	<expr_stmt><expr><name>a</name> = <name>a</name> + <name>b</name></expr>;</expr_stmt>
	<macro><name>PyFPE_END_PROTECT</name><argument_list>(<argument>a</argument>)</argument_list></macro>
	<return>return <expr><call><name>PyFloat_FromDouble</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>float_sub</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>v</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>w</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>double</name></type> <name>a</name></decl>,<decl><type ref="prev"/><name>b</name></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>CONVERT_TO_DOUBLE</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CONVERT_TO_DOUBLE</name><argument_list>(<argument><expr><name>w</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<macro><name>PyFPE_START_PROTECT</name><argument_list>(<argument>"subtract"</argument>, <argument>return 0</argument>)</argument_list></macro>
	<expr_stmt><expr><name>a</name> = <name>a</name> - <name>b</name></expr>;</expr_stmt>
	<macro><name>PyFPE_END_PROTECT</name><argument_list>(<argument>a</argument>)</argument_list></macro>
	<return>return <expr><call><name>PyFloat_FromDouble</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>float_mul</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>v</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>w</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>double</name></type> <name>a</name></decl>,<decl><type ref="prev"/><name>b</name></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>CONVERT_TO_DOUBLE</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CONVERT_TO_DOUBLE</name><argument_list>(<argument><expr><name>w</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<macro><name>PyFPE_START_PROTECT</name><argument_list>(<argument>"multiply"</argument>, <argument>return 0</argument>)</argument_list></macro>
	<expr_stmt><expr><name>a</name> = <name>a</name> * <name>b</name></expr>;</expr_stmt>
	<macro><name>PyFPE_END_PROTECT</name><argument_list>(<argument>a</argument>)</argument_list></macro>
	<return>return <expr><call><name>PyFloat_FromDouble</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>float_div</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>v</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>w</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>double</name></type> <name>a</name></decl>,<decl><type ref="prev"/><name>b</name></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>CONVERT_TO_DOUBLE</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CONVERT_TO_DOUBLE</name><argument_list>(<argument><expr><name>w</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>Py_NAN</name></cpp:ifdef>
	<if>if <condition>(<expr><name>b</name> == 0.0</expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ZeroDivisionError</name></expr></argument>,
				<argument><expr>"float division"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<macro><name>PyFPE_START_PROTECT</name><argument_list>(<argument>"divide"</argument>, <argument>return 0</argument>)</argument_list></macro>
	<expr_stmt><expr><name>a</name> = <name>a</name> / <name>b</name></expr>;</expr_stmt>
	<macro><name>PyFPE_END_PROTECT</name><argument_list>(<argument>a</argument>)</argument_list></macro>
	<return>return <expr><call><name>PyFloat_FromDouble</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>float_classic_div</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>v</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>w</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>double</name></type> <name>a</name></decl>,<decl><type ref="prev"/><name>b</name></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>CONVERT_TO_DOUBLE</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CONVERT_TO_DOUBLE</name><argument_list>(<argument><expr><name>w</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>Py_DivisionWarningFlag</name> &gt;= 2 &amp;&amp;
	    <call><name>PyErr_Warn</name><argument_list>(<argument><expr><name>PyExc_DeprecationWarning</name></expr></argument>, <argument><expr>"classic float division"</expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>Py_NAN</name></cpp:ifdef>
	<if>if <condition>(<expr><name>b</name> == 0.0</expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ZeroDivisionError</name></expr></argument>,
				<argument><expr>"float division"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<macro><name>PyFPE_START_PROTECT</name><argument_list>(<argument>"divide"</argument>, <argument>return 0</argument>)</argument_list></macro>
	<expr_stmt><expr><name>a</name> = <name>a</name> / <name>b</name></expr>;</expr_stmt>
	<macro><name>PyFPE_END_PROTECT</name><argument_list>(<argument>a</argument>)</argument_list></macro>
	<return>return <expr><call><name>PyFloat_FromDouble</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>float_rem</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>v</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>w</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>double</name></type> <name>vx</name></decl>, <decl><type ref="prev"/><name>wx</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type> <name>mod</name></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>CONVERT_TO_DOUBLE</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>vx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CONVERT_TO_DOUBLE</name><argument_list>(<argument><expr><name>w</name></expr></argument>, <argument><expr><name>wx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>Py_NAN</name></cpp:ifdef>
	<if>if <condition>(<expr><name>wx</name> == 0.0</expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ZeroDivisionError</name></expr></argument>,
				<argument><expr>"float modulo"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<macro><name>PyFPE_START_PROTECT</name><argument_list>(<argument>"modulo"</argument>, <argument>return 0</argument>)</argument_list></macro>
	<expr_stmt><expr><name>mod</name> = <call><name>fmod</name><argument_list>(<argument><expr><name>vx</name></expr></argument>, <argument><expr><name>wx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* note: checking mod*wx &lt; 0 is incorrect -- underflows to
	   0 if wx &lt; sqrt(smallest nonzero double) */</comment>
	<if>if <condition>(<expr><name>mod</name> &amp;&amp; ((<name>wx</name> &lt; 0) != (<name>mod</name> &lt; 0))</expr>)</condition><then> <block>{
		<expr_stmt><expr><name>mod</name> += <name>wx</name></expr>;</expr_stmt>
	}</block></then></if>
	<macro><name>PyFPE_END_PROTECT</name><argument_list>(<argument>mod</argument>)</argument_list></macro>
	<return>return <expr><call><name>PyFloat_FromDouble</name><argument_list>(<argument><expr><name>mod</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>float_divmod</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>v</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>w</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>double</name></type> <name>vx</name></decl>, <decl><type ref="prev"/><name>wx</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type> <name>div</name></decl>, <decl><type ref="prev"/><name>mod</name></decl>, <decl><type ref="prev"/><name>floordiv</name></decl>;</decl_stmt>
 	<expr_stmt><expr><call><name>CONVERT_TO_DOUBLE</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>vx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
 	<expr_stmt><expr><call><name>CONVERT_TO_DOUBLE</name><argument_list>(<argument><expr><name>w</name></expr></argument>, <argument><expr><name>wx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>wx</name> == 0.0</expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ZeroDivisionError</name></expr></argument>, <argument><expr>"float divmod()"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>
	<macro><name>PyFPE_START_PROTECT</name><argument_list>(<argument>"divmod"</argument>, <argument>return 0</argument>)</argument_list></macro>
	<expr_stmt><expr><name>mod</name> = <call><name>fmod</name><argument_list>(<argument><expr><name>vx</name></expr></argument>, <argument><expr><name>wx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* fmod is typically exact, so vx-mod is *mathematically* an
	   exact multiple of wx.  But this is fp arithmetic, and fp
	   vx - mod is an approximation; the result is that div may
	   not be an exact integral value after the division, although
	   it will always be very close to one.
	*/</comment>
	<expr_stmt><expr><name>div</name> = (<name>vx</name> - <name>mod</name>) / <name>wx</name></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>mod</name></expr>)</condition><then> <block>{
		<comment type="block">/* ensure the remainder has the same sign as the denominator */</comment>
		<if>if <condition>(<expr>(<name>wx</name> &lt; 0) != (<name>mod</name> &lt; 0)</expr>)</condition><then> <block>{
			<expr_stmt><expr><name>mod</name> += <name>wx</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>div</name> -= 1.0</expr>;</expr_stmt>
		}</block></then></if>
	}</block></then>
	<else>else <block>{
		<comment type="block">/* the remainder is zero, and in the presence of signed zeroes
		   fmod returns different results across platforms; ensure
		   it has the same sign as the denominator; we'd like to do
		   "mod = wx * 0.0", but that may get optimized away */</comment>
		<expr_stmt><expr><name>mod</name> *= <name>mod</name></expr>;</expr_stmt>  <comment type="block">/* hide "mod = +0" from optimizer */</comment>
		<if>if <condition>(<expr><name>wx</name> &lt; 0.0</expr>)</condition><then>
			<expr_stmt><expr><name>mod</name> = -<name>mod</name></expr>;</expr_stmt></then></if>
	}</block></else></if>
	<comment type="block">/* snap quotient to nearest integral value */</comment>
	<if>if <condition>(<expr><name>div</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>floordiv</name> = <call><name>floor</name><argument_list>(<argument><expr><name>div</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>div</name> - <name>floordiv</name> &gt; 0.5</expr>)</condition><then>
			<expr_stmt><expr><name>floordiv</name> += 1.0</expr>;</expr_stmt></then></if>
	}</block></then>
	<else>else <block>{
		<comment type="block">/* div is zero - get the same sign as the true quotient */</comment>
		<expr_stmt><expr><name>div</name> *= <name>div</name></expr>;</expr_stmt>	<comment type="block">/* hide "div = +0" from optimizers */</comment>
		<expr_stmt><expr><name>floordiv</name> = <name>div</name> * <name>vx</name> / <name>wx</name></expr>;</expr_stmt> <comment type="block">/* zero w/ sign of vx/wx */</comment>
	}</block></else></if>
	<macro><name>PyFPE_END_PROTECT</name><argument_list>(<argument>floordiv</argument>)</argument_list></macro>
	<return>return <expr><call><name>Py_BuildValue</name><argument_list>(<argument><expr>"(dd)"</expr></argument>, <argument><expr><name>floordiv</name></expr></argument>, <argument><expr><name>mod</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>float_floor_div</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>v</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>w</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>t</name></decl>, *<decl><type ref="prev"/><name>r</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>t</name> = <call><name>float_divmod</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>t</name> == <name>NULL</name> || <name>t</name> == <name>Py_NotImplemented</name></expr>)</condition><then>
		<return>return <expr><name>t</name></expr>;</return></then></if>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>PyTuple_CheckExact</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>r</name> = <call><name>PyTuple_GET_ITEM</name><argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>r</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>float_pow</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>v</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>w</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>z</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>double</name></type> <name>iv</name></decl>, <decl><type ref="prev"/><name>iw</name></decl>, <decl><type ref="prev"/><name>ix</name></decl>;</decl_stmt>

	<if>if <condition>(<expr>(<name>PyObject</name> *)<name>z</name> != <name>Py_None</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>, <argument><expr>"pow() 3rd argument not "
			"allowed unless all arguments are integers"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>

	<expr_stmt><expr><call><name>CONVERT_TO_DOUBLE</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>iv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CONVERT_TO_DOUBLE</name><argument_list>(<argument><expr><name>w</name></expr></argument>, <argument><expr><name>iw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Sort out special cases here instead of relying on pow() */</comment>
	<if>if <condition>(<expr><name>iw</name> == 0</expr>)</condition><then> <block>{ 		<comment type="block">/* v**0 is 1, even 0**0 */</comment>
		<return>return <expr><call><name>PyFloat_FromDouble</name><argument_list>(<argument><expr>1.0</expr></argument>)</argument_list></call></expr>;</return>
	}</block></then></if>
	<if>if <condition>(<expr><name>iv</name> == 0.0</expr>)</condition><then> <block>{  <comment type="block">/* 0**w is error if w&lt;0, else 1 */</comment>
		<if>if <condition>(<expr><name>iw</name> &lt; 0.0</expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ZeroDivisionError</name></expr></argument>,
					<argument><expr>"0.0 cannot be raised to a negative power"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>NULL</name></expr>;</return>
		}</block></then></if>
		<return>return <expr><call><name>PyFloat_FromDouble</name><argument_list>(<argument><expr>0.0</expr></argument>)</argument_list></call></expr>;</return>
	}</block></then></if>
	<if>if <condition>(<expr><name>iv</name> == 1.0</expr>)</condition><then> <block>{ <comment type="block">/* 1**w is 1, even 1**inf and 1**nan */</comment>
		<return>return <expr><call><name>PyFloat_FromDouble</name><argument_list>(<argument><expr>1.0</expr></argument>)</argument_list></call></expr>;</return>
	}</block></then></if>
	<if>if <condition>(<expr><name>iv</name> &lt; 0.0</expr>)</condition><then> <block>{
		<comment type="block">/* Whether this is an error is a mess, and bumps into libm
		 * bugs so we have to figure it out ourselves.
		 */</comment>
		<if>if <condition>(<expr><name>iw</name> != <call><name>floor</name><argument_list>(<argument><expr><name>iw</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>, <argument><expr>"negative number "
				"cannot be raised to a fractional power"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>NULL</name></expr>;</return>
		}</block></then></if>
		<comment type="block">/* iw is an exact integer, albeit perhaps a very large one.
		 * -1 raised to an exact integer should never be exceptional.
		 * Alas, some libms (chiefly glibc as of early 2003) return
		 * NaN and set EDOM on pow(-1, large_int) if the int doesn't
		 * happen to be representable in a *C* integer.  That's a
		 * bug; we let that slide in math.pow() (which currently
		 * reflects all platform accidents), but not for Python's **.
		 */</comment>
		 <if>if <condition>(<expr><name>iv</name> == -1.0 &amp;&amp; <call><name>Py_IS_FINITE</name><argument_list>(<argument><expr><name>iw</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		 	<comment type="block">/* Return 1 if iw is even, -1 if iw is odd; there's
		 	 * no guarantee that any C integral type is big
		 	 * enough to hold iw, so we have to check this
		 	 * indirectly.
		 	 */</comment>
		 	<expr_stmt><expr><name>ix</name> = <call><name>floor</name><argument_list>(<argument><expr><name>iw</name> * 0.5</expr></argument>)</argument_list></call> * 2.0</expr>;</expr_stmt>
			<return>return <expr><call><name>PyFloat_FromDouble</name><argument_list>(<argument><expr><name>ix</name> == <name>iw</name> ? 1.0 : -1.0</expr></argument>)</argument_list></call></expr>;</return>
		}</block></then></if>
		<comment type="block">/* Else iv != -1.0, and overflow or underflow are possible.
		 * Unless we're to write pow() ourselves, we have to trust
		 * the platform to do this correctly.
		 */</comment>
	}</block></then></if>
	<expr_stmt><expr><name>errno</name> = 0</expr>;</expr_stmt>
	<macro><name>PyFPE_START_PROTECT</name><argument_list>(<argument>"pow"</argument>, <argument>return NULL</argument>)</argument_list></macro>
	<expr_stmt><expr><name>ix</name> = <call><name>pow</name><argument_list>(<argument><expr><name>iv</name></expr></argument>, <argument><expr><name>iw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<macro><name>PyFPE_END_PROTECT</name><argument_list>(<argument>ix</argument>)</argument_list></macro>
	<expr_stmt><expr><call><name>Py_ADJUST_ERANGE1</name><argument_list>(<argument><expr><name>ix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>errno</name> != 0</expr>)</condition><then> <block>{
		<comment type="block">/* We don't expect any errno value other than ERANGE, but
		 * the range of libm bugs appears unbounded.
		 */</comment>
		<expr_stmt><expr><call><name>PyErr_SetFromErrno</name><argument_list>(<argument><expr><name>errno</name> == <name>ERANGE</name> ? <name>PyExc_OverflowError</name> :
						     <name>PyExc_ValueError</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>
	<return>return <expr><call><name>PyFloat_FromDouble</name><argument_list>(<argument><expr><name>ix</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>float_neg</name><parameter_list>(<param><decl><type><name>PyFloatObject</name> *</type><name>v</name></decl></param>)</parameter_list>
<block>{
	<return>return <expr><call><name>PyFloat_FromDouble</name><argument_list>(<argument><expr>-<name><name>v</name>-&gt;<name>ob_fval</name></name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>float_abs</name><parameter_list>(<param><decl><type><name>PyFloatObject</name> *</type><name>v</name></decl></param>)</parameter_list>
<block>{
	<return>return <expr><call><name>PyFloat_FromDouble</name><argument_list>(<argument><expr><call><name>fabs</name><argument_list>(<argument><expr><name><name>v</name>-&gt;<name>ob_fval</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>float_nonzero</name><parameter_list>(<param><decl><type><name>PyFloatObject</name> *</type><name>v</name></decl></param>)</parameter_list>
<block>{
	<return>return <expr><name><name>v</name>-&gt;<name>ob_fval</name></name> != 0.0</expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>float_coerce</name><parameter_list>(<param><decl><type><name>PyObject</name> **</type><name>pv</name></decl></param>, <param><decl><type><name>PyObject</name> **</type><name>pw</name></decl></param>)</parameter_list>
<block>{
	<if>if <condition>(<expr><call><name>PyInt_Check</name><argument_list>(<argument><expr>*<name>pw</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<decl_stmt><decl><type><name>long</name></type> <name>x</name> <init>= <expr><call><name>PyInt_AsLong</name><argument_list>(<argument><expr>*<name>pw</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr>*<name>pw</name> = <call><name>PyFloat_FromDouble</name><argument_list>(<argument><expr>(<name>double</name>)<name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr>*<name>pv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>0</expr>;</return>
	}</block></then>
	<else>else <if>if <condition>(<expr><call><name>PyLong_Check</name><argument_list>(<argument><expr>*<name>pw</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<decl_stmt><decl><type><name>double</name></type> <name>x</name> <init>= <expr><call><name>PyLong_AsDouble</name><argument_list>(<argument><expr>*<name>pw</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if>if <condition>(<expr><name>x</name> == -1.0 &amp;&amp; <call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then>
			<return>return <expr>-1</expr>;</return></then></if>
		<expr_stmt><expr>*<name>pw</name> = <call><name>PyFloat_FromDouble</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr>*<name>pv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>0</expr>;</return>
	}</block></then>
	<else>else <if>if <condition>(<expr><call><name>PyFloat_Check</name><argument_list>(<argument><expr>*<name>pw</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr>*<name>pv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr>*<name>pw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>0</expr>;</return>
	}</block></then></if></else></if></else></if>
	<return>return <expr>1</expr>;</return> <comment type="block">/* Can't do it */</comment>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>float_is_integer</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>v</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>double</name></type> <name>x</name> <init>= <expr><call><name>PyFloat_AsDouble</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>o</name></decl>;</decl_stmt>
	
	<if>if <condition>(<expr><name>x</name> == -1.0 &amp;&amp; <call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<if>if <condition>(<expr>!<call><name>Py_IS_FINITE</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<expr_stmt><expr><name>Py_RETURN_FALSE</name></expr>;</expr_stmt></then></if>
	<expr_stmt><expr><name>errno</name> = 0</expr>;</expr_stmt>
	<macro><name>PyFPE_START_PROTECT</name><argument_list>(<argument>"is_integer"</argument>, <argument>return NULL</argument>)</argument_list></macro>
	<expr_stmt><expr><name>o</name> = (<call><name>floor</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call> == <name>x</name>) ? <name>Py_True</name> : <name>Py_False</name></expr>;</expr_stmt>
	<macro><name>PyFPE_END_PROTECT</name><argument_list>(<argument>x</argument>)</argument_list></macro>
	<if>if <condition>(<expr><name>errno</name> != 0</expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_SetFromErrno</name><argument_list>(<argument><expr><name>errno</name> == <name>ERANGE</name> ? <name>PyExc_OverflowError</name> :
						     <name>PyExc_ValueError</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>
	<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>o</name></expr>;</return>
}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr>0</expr></cpp:if>
static PyObject *
float_is_inf(PyObject *v)
{
	double x = PyFloat_AsDouble(v);
	if (x == -1.0 &amp;&amp; PyErr_Occurred())
		return NULL;
	return PyBool_FromLong((long)Py_IS_INFINITY(x));
}

static PyObject *
float_is_nan(PyObject *v)
{
	double x = PyFloat_AsDouble(v);
	if (x == -1.0 &amp;&amp; PyErr_Occurred())
		return NULL;
	return PyBool_FromLong((long)Py_IS_NAN(x));
}

static PyObject *
float_is_finite(PyObject *v)
{
	double x = PyFloat_AsDouble(v);
	if (x == -1.0 &amp;&amp; PyErr_Occurred())
		return NULL;
	return PyBool_FromLong((long)Py_IS_FINITE(x));
}
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>float_trunc</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>v</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>double</name></type> <name>x</name> <init>= <expr><call><name>PyFloat_AsDouble</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type> <name>wholepart</name></decl>;</decl_stmt>	<comment type="block">/* integral portion of x, rounded toward 0 */</comment>

	<expr_stmt><expr>(<name>void</name>)<call><name>modf</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr>&amp;<name>wholepart</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Try to get out cheap if this fits in a Python int.  The attempt
	 * to cast to long must be protected, as C doesn't define what
	 * happens if the double is too big to fit in a long.  Some rare
	 * systems raise an exception then (RISCOS was mentioned as one,
	 * and someone using a non-default option on Sun also bumped into
	 * that).  Note that checking for &gt;= and &lt;= LONG_{MIN,MAX} would
	 * still be vulnerable:  if a long has more bits of precision than
	 * a double, casting MIN/MAX to double may yield an approximation,
	 * and if that's rounded up, then, e.g., wholepart=LONG_MAX+1 would
	 * yield true from the C expression wholepart&lt;=LONG_MAX, despite
	 * that wholepart is actually greater than LONG_MAX.
	 */</comment>
	<if>if <condition>(<expr><name>LONG_MIN</name> &lt; <name>wholepart</name> &amp;&amp; <name>wholepart</name> &lt; <name>LONG_MAX</name></expr>)</condition><then> <block>{
		<decl_stmt><decl><type><specifier>const</specifier> <name>long</name></type> <name>aslong</name> <init>= <expr>(<name>long</name>)<name>wholepart</name></expr></init></decl>;</decl_stmt>
		<return>return <expr><call><name>PyInt_FromLong</name><argument_list>(<argument><expr><name>aslong</name></expr></argument>)</argument_list></call></expr>;</return>
	}</block></then></if>
	<return>return <expr><call><name>PyLong_FromDouble</name><argument_list>(<argument><expr><name>wholepart</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>float_long</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>v</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>double</name></type> <name>x</name> <init>= <expr><call><name>PyFloat_AsDouble</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<return>return <expr><call><name>PyLong_FromDouble</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>float_float</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>v</name></decl></param>)</parameter_list>
<block>{
	<if>if <condition>(<expr><call><name>PyFloat_CheckExact</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
	<else>else
		<expr_stmt><expr><name>v</name> = <call><name>PyFloat_FromDouble</name><argument_list>(<argument><expr>((<name>PyFloatObject</name> *)<name>v</name>)-&gt;<name>ob_fval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
	<return>return <expr><name>v</name></expr>;</return>
}</block></function>

<comment type="block">/* turn ASCII hex characters into integer values and vice versa */</comment>

<function><type><specifier>static</specifier> <name>char</name></type>
<name>char_from_hex</name><parameter_list>(<param><decl><type><name>int</name></type> <name>x</name></decl></param>)</parameter_list>
<block>{
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr>0 &lt;= <name>x</name> &amp;&amp; <name>x</name> &lt; 16</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr>"0123456789abcdef"<index>[<expr><name>x</name></expr>]</index></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>hex_from_char</name><parameter_list>(<param><decl><type><name>char</name></type> <name>c</name></decl></param>)</parameter_list> <block>{
	<decl_stmt><decl><type><name>int</name></type> <name>x</name></decl>;</decl_stmt>
	<switch>switch<condition>(<expr><name>c</name></expr>)</condition> <block>{
	<case>case <expr>'0'</expr>:
		<expr_stmt><expr><name>x</name> = 0</expr>;</expr_stmt>
		<break>break;</break>
	</case><case>case <expr>'1'</expr>:
		<expr_stmt><expr><name>x</name> = 1</expr>;</expr_stmt>
		<break>break;</break>
	</case><case>case <expr>'2'</expr>:
		<expr_stmt><expr><name>x</name> = 2</expr>;</expr_stmt>
		<break>break;</break>
	</case><case>case <expr>'3'</expr>:
		<expr_stmt><expr><name>x</name> = 3</expr>;</expr_stmt>
		<break>break;</break>
	</case><case>case <expr>'4'</expr>:
		<expr_stmt><expr><name>x</name> = 4</expr>;</expr_stmt>
		<break>break;</break>
	</case><case>case <expr>'5'</expr>:
		<expr_stmt><expr><name>x</name> = 5</expr>;</expr_stmt>
		<break>break;</break>
	</case><case>case <expr>'6'</expr>:
		<expr_stmt><expr><name>x</name> = 6</expr>;</expr_stmt>
		<break>break;</break>
	</case><case>case <expr>'7'</expr>:
		<expr_stmt><expr><name>x</name> = 7</expr>;</expr_stmt>
		<break>break;</break>
	</case><case>case <expr>'8'</expr>:
		<expr_stmt><expr><name>x</name> = 8</expr>;</expr_stmt>
		<break>break;</break>
	</case><case>case <expr>'9'</expr>:
		<expr_stmt><expr><name>x</name> = 9</expr>;</expr_stmt>
		<break>break;</break>
	</case><case>case <expr>'a'</expr>:
	</case><case>case <expr>'A'</expr>:
		<expr_stmt><expr><name>x</name> = 10</expr>;</expr_stmt>
		<break>break;</break>
	</case><case>case <expr>'b'</expr>:
	</case><case>case <expr>'B'</expr>:
		<expr_stmt><expr><name>x</name> = 11</expr>;</expr_stmt>
		<break>break;</break>
	</case><case>case <expr>'c'</expr>:
	</case><case>case <expr>'C'</expr>:
		<expr_stmt><expr><name>x</name> = 12</expr>;</expr_stmt>
		<break>break;</break>
	</case><case>case <expr>'d'</expr>:
	</case><case>case <expr>'D'</expr>:
		<expr_stmt><expr><name>x</name> = 13</expr>;</expr_stmt>
		<break>break;</break>
	</case><case>case <expr>'e'</expr>:
	</case><case>case <expr>'E'</expr>:
		<expr_stmt><expr><name>x</name> = 14</expr>;</expr_stmt>
		<break>break;</break>
	</case><case>case <expr>'f'</expr>:
	</case><case>case <expr>'F'</expr>:
		<expr_stmt><expr><name>x</name> = 15</expr>;</expr_stmt>
		<break>break;</break>
	</case><default>default:
		<expr_stmt><expr><name>x</name> = -1</expr>;</expr_stmt>
		<break>break;</break>
	</default>}</block></switch>
	<return>return <expr><name>x</name></expr>;</return>
}</block></function>

<comment type="block">/* convert a float to a hexadecimal string */</comment>

<comment type="block">/* TOHEX_NBITS is DBL_MANT_DIG rounded up to the next integer
   of the form 4k+1. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TOHEX_NBITS</name></cpp:macro> <cpp:value>DBL_MANT_DIG + 3 - (DBL_MANT_DIG+2)%4</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>float_hex</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>v</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>double</name></type> <name>x</name></decl>, <decl><type ref="prev"/><name>m</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>e</name></decl>, <decl><type ref="prev"/><name>shift</name></decl>, <decl><type ref="prev"/><name>i</name></decl>, <decl><type ref="prev"/><name>si</name></decl>, <decl><type ref="prev"/><name>esign</name></decl>;</decl_stmt>
	<comment type="block">/* Space for 1+(TOHEX_NBITS-1)/4 digits, a decimal point, and the
	   trailing NUL byte. */</comment>
	<decl_stmt><decl><type><name>char</name></type> <name><name>s</name><index>[<expr>(<name>TOHEX_NBITS</name>-1)/4+3</expr>]</index></name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>CONVERT_TO_DOUBLE</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if>if <condition>(<expr><call><name>Py_IS_NAN</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call> || <call><name>Py_IS_INFINITY</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><call><name>float_str</name><argument_list>(<argument><expr>(<name>PyFloatObject</name> *)<name>v</name></expr></argument>)</argument_list></call></expr>;</return></then></if>

	<if>if <condition>(<expr><name>x</name> == 0.0</expr>)</condition><then> <block>{
		<if>if<condition>(<expr><call><name>copysign</name><argument_list>(<argument><expr>1.0</expr></argument>, <argument><expr><name>x</name></expr></argument>)</argument_list></call> == -1.0</expr>)</condition><then>
			<return>return <expr><call><name>PyString_FromString</name><argument_list>(<argument><expr>"-0x0.0p+0"</expr></argument>)</argument_list></call></expr>;</return></then>
		<else>else
			<return>return <expr><call><name>PyString_FromString</name><argument_list>(<argument><expr>"0x0.0p+0"</expr></argument>)</argument_list></call></expr>;</return></else></if>
	}</block></then></if>

	<expr_stmt><expr><name>m</name> = <call><name>frexp</name><argument_list>(<argument><expr><call><name>fabs</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>&amp;<name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>shift</name> = 1 - <call><name>MAX</name><argument_list>(<argument><expr><name>DBL_MIN_EXP</name> - <name>e</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>m</name> = <call><name>ldexp</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr><name>shift</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>e</name> -= <name>shift</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>si</name> = 0</expr>;</expr_stmt>
	<expr_stmt><expr><name><name>s</name><index>[<expr><name>si</name></expr>]</index></name> = <call><name>char_from_hex</name><argument_list>(<argument><expr>(<name>int</name>)<name>m</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>si</name>++</expr>;</expr_stmt>
	<expr_stmt><expr><name>m</name> -= (<name>int</name>)<name>m</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>s</name><index>[<expr><name>si</name></expr>]</index></name> = '.'</expr>;</expr_stmt>
	<expr_stmt><expr><name>si</name>++</expr>;</expr_stmt>
	<for>for (<init><expr><name>i</name>=0</expr>;</init> <condition><expr><name>i</name> &lt; (<name>TOHEX_NBITS</name>-1)/4</expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
		<expr_stmt><expr><name>m</name> *= 16.0</expr>;</expr_stmt>
		<expr_stmt><expr><name><name>s</name><index>[<expr><name>si</name></expr>]</index></name> = <call><name>char_from_hex</name><argument_list>(<argument><expr>(<name>int</name>)<name>m</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>si</name>++</expr>;</expr_stmt>
		<expr_stmt><expr><name>m</name> -= (<name>int</name>)<name>m</name></expr>;</expr_stmt>
	}</block></for>
	<expr_stmt><expr><name><name>s</name><index>[<expr><name>si</name></expr>]</index></name> = '\0'</expr>;</expr_stmt>

	<if>if <condition>(<expr><name>e</name> &lt; 0</expr>)</condition><then> <block>{
		<expr_stmt><expr><name>esign</name> = (<name>int</name>)'-'</expr>;</expr_stmt>
		<expr_stmt><expr><name>e</name> = -<name>e</name></expr>;</expr_stmt>
	}</block></then>
	<else>else
		<expr_stmt><expr><name>esign</name> = (<name>int</name>)'+'</expr>;</expr_stmt></else></if>

	<if>if <condition>(<expr><name>x</name> &lt; 0.0</expr>)</condition><then>
		<return>return <expr><call><name>PyString_FromFormat</name><argument_list>(<argument><expr>"-0x%sp%c%d"</expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>esign</name></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</return></then>
	<else>else
		<return>return <expr><call><name>PyString_FromFormat</name><argument_list>(<argument><expr>"0x%sp%c%d"</expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>esign</name></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</return></else></if>
}</block></function>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>float_hex_doc</name></expr></argument>,
<argument><expr>"float.hex() -&gt; string\n\
\n\
Return a hexadecimal representation of a floating-point number.\n\
&gt;&gt;&gt; (-0.1).hex()\n\
'-0x1.999999999999ap-4'\n\
&gt;&gt;&gt; 3.14159.hex()\n\
'0x1.921f9f01b866ep+1'"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/* Convert a hexadecimal string to a float. */</comment>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>float_fromhex</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>cls</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>arg</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>result_as_float</name></decl>, *<decl><type ref="prev"/><name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type> <name>x</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>long</name></type> <name>exp</name></decl>, <decl><type ref="prev"/><name>top_exp</name></decl>, <decl><type ref="prev"/><name>lsb</name></decl>, <decl><type ref="prev"/><name>key_digit</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> *</type><name>s</name></decl>, *<decl><type ref="prev"/><name>coeff_start</name></decl>, *<decl><type ref="prev"/><name>s_store</name></decl>, *<decl><type ref="prev"/><name>coeff_end</name></decl>, *<decl><type ref="prev"/><name>exp_start</name></decl>, *<decl><type ref="prev"/><name>s_end</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>half_eps</name></decl>, <decl><type ref="prev"/><name>digit</name></decl>, <decl><type ref="prev"/><name>round_up</name></decl>, <decl><type ref="prev"/><name>sign</name><init>=<expr>1</expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>length</name></decl>, <decl><type ref="prev"/><name>ndigits</name></decl>, <decl><type ref="prev"/><name>fdigits</name></decl>, <decl><type ref="prev"/><name>i</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * For the sake of simplicity and correctness, we impose an artificial
	 * limit on ndigits, the total number of hex digits in the coefficient
	 * The limit is chosen to ensure that, writing exp for the exponent,
	 *
	 *   (1) if exp &gt; LONG_MAX/2 then the value of the hex string is
	 *   guaranteed to overflow (provided it's nonzero)
	 *
	 *   (2) if exp &lt; LONG_MIN/2 then the value of the hex string is
	 *   guaranteed to underflow to 0.
	 *
	 *   (3) if LONG_MIN/2 &lt;= exp &lt;= LONG_MAX/2 then there's no danger of
	 *   overflow in the calculation of exp and top_exp below.
	 *
	 * More specifically, ndigits is assumed to satisfy the following
	 * inequalities:
	 *
	 *   4*ndigits &lt;= DBL_MIN_EXP - DBL_MANT_DIG - LONG_MIN/2
	 *   4*ndigits &lt;= LONG_MAX/2 + 1 - DBL_MAX_EXP
	 *
	 * If either of these inequalities is not satisfied, a ValueError is
	 * raised.  Otherwise, write x for the value of the hex string, and
	 * assume x is nonzero.  Then
	 *
	 *   2**(exp-4*ndigits) &lt;= |x| &lt; 2**(exp+4*ndigits).
	 *
	 * Now if exp &gt; LONG_MAX/2 then:
	 *
	 *   exp - 4*ndigits &gt;= LONG_MAX/2 + 1 - (LONG_MAX/2 + 1 - DBL_MAX_EXP)
	 *                    = DBL_MAX_EXP
	 *
	 * so |x| &gt;= 2**DBL_MAX_EXP, which is too large to be stored in C
	 * double, so overflows.  If exp &lt; LONG_MIN/2, then
	 *
	 *   exp + 4*ndigits &lt;= LONG_MIN/2 - 1 + (
	 *                      DBL_MIN_EXP - DBL_MANT_DIG - LONG_MIN/2)
	 *                    = DBL_MIN_EXP - DBL_MANT_DIG - 1
	 *
	 * and so |x| &lt; 2**(DBL_MIN_EXP-DBL_MANT_DIG-1), hence underflows to 0
	 * when converted to a C double.
	 *
	 * It's easy to show that if LONG_MIN/2 &lt;= exp &lt;= LONG_MAX/2 then both
	 * exp+4*ndigits and exp-4*ndigits are within the range of a long.
	 */</comment>

	<if>if <condition>(<expr><call><name>PyString_AsStringAndSize</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr>&amp;<name>s</name></expr></argument>, <argument><expr>&amp;<name>length</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<expr_stmt><expr><name>s_end</name> = <name>s</name> + <name>length</name></expr>;</expr_stmt>

	<comment type="block">/********************
	 * Parse the string *
	 ********************/</comment>

	<comment type="block">/* leading whitespace and optional sign */</comment>
	<while>while <condition>(<expr><call><name>isspace</name><argument_list>(<argument><expr>*<name>s</name></expr></argument>)</argument_list></call></expr>)</condition>
		<expr_stmt><expr><name>s</name>++</expr>;</expr_stmt></while>
	<if>if <condition>(<expr>*<name>s</name> == '-'</expr>)</condition><then> <block>{
		<expr_stmt><expr><name>s</name>++</expr>;</expr_stmt>
		<expr_stmt><expr><name>sign</name> = -1</expr>;</expr_stmt>
	}</block></then>
	<else>else <if>if <condition>(<expr>*<name>s</name> == '+'</expr>)</condition><then>
		<expr_stmt><expr><name>s</name>++</expr>;</expr_stmt></then></if></else></if>

	<comment type="block">/* infinities and nans */</comment>
	<if>if <condition>(<expr><call><name>PyOS_strnicmp</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr>"nan"</expr></argument>, <argument><expr>4</expr></argument>)</argument_list></call> == 0</expr>)</condition><then> <block>{
		<expr_stmt><expr><name>x</name> = <name>Py_NAN</name></expr>;</expr_stmt>
		<goto>goto <name>finished</name>;</goto>
	}</block></then></if>
	<if>if <condition>(<expr><call><name>PyOS_strnicmp</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr>"inf"</expr></argument>, <argument><expr>4</expr></argument>)</argument_list></call> == 0 ||
	    <call><name>PyOS_strnicmp</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr>"infinity"</expr></argument>, <argument><expr>9</expr></argument>)</argument_list></call> == 0</expr>)</condition><then> <block>{
		<expr_stmt><expr><name>x</name> = <name>sign</name>*<name>Py_HUGE_VAL</name></expr>;</expr_stmt>
		<goto>goto <name>finished</name>;</goto>
	}</block></then></if>

	<comment type="block">/* [0x] */</comment>
	<expr_stmt><expr><name>s_store</name> = <name>s</name></expr>;</expr_stmt>
	<if>if <condition>(<expr>*<name>s</name> == '0'</expr>)</condition><then> <block>{
		<expr_stmt><expr><name>s</name>++</expr>;</expr_stmt>
		<if>if <condition>(<expr><call><name>tolower</name><argument_list>(<argument><expr>*<name>s</name></expr></argument>)</argument_list></call> == (<name>int</name>)'x'</expr>)</condition><then>
			<expr_stmt><expr><name>s</name>++</expr>;</expr_stmt></then>
		<else>else
			<expr_stmt><expr><name>s</name> = <name>s_store</name></expr>;</expr_stmt></else></if>
	}</block></then></if>

	<comment type="block">/* coefficient: &lt;integer&gt; [. &lt;fraction&gt;] */</comment>
	<expr_stmt><expr><name>coeff_start</name> = <name>s</name></expr>;</expr_stmt>
	<while>while <condition>(<expr><call><name>hex_from_char</name><argument_list>(<argument><expr>*<name>s</name></expr></argument>)</argument_list></call> &gt;= 0</expr>)</condition>
		<expr_stmt><expr><name>s</name>++</expr>;</expr_stmt></while>
	<expr_stmt><expr><name>s_store</name> = <name>s</name></expr>;</expr_stmt>
	<if>if <condition>(<expr>*<name>s</name> == '.'</expr>)</condition><then> <block>{
		<expr_stmt><expr><name>s</name>++</expr>;</expr_stmt>
		<while>while <condition>(<expr><call><name>hex_from_char</name><argument_list>(<argument><expr>*<name>s</name></expr></argument>)</argument_list></call> &gt;= 0</expr>)</condition>
			<expr_stmt><expr><name>s</name>++</expr>;</expr_stmt></while>
		<expr_stmt><expr><name>coeff_end</name> = <name>s</name>-1</expr>;</expr_stmt>
	}</block></then>
	<else>else
		<expr_stmt><expr><name>coeff_end</name> = <name>s</name></expr>;</expr_stmt></else></if>

	<comment type="block">/* ndigits = total # of hex digits; fdigits = # after point */</comment>
	<expr_stmt><expr><name>ndigits</name> = <name>coeff_end</name> - <name>coeff_start</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>fdigits</name> = <name>coeff_end</name> - <name>s_store</name></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>ndigits</name> == 0</expr>)</condition><then>
		<goto>goto <name>parse_error</name>;</goto></then></if>
	<if>if <condition>(<expr><name>ndigits</name> &gt; <call><name>MIN</name><argument_list>(<argument><expr><name>DBL_MIN_EXP</name> - <name>DBL_MANT_DIG</name> - <name>LONG_MIN</name>/2</expr></argument>,
			  <argument><expr><name>LONG_MAX</name>/2 + 1 - <name>DBL_MAX_EXP</name></expr></argument>)</argument_list></call>/4</expr>)</condition><then>
		<goto>goto <name>insane_length_error</name>;</goto></then></if>

	<comment type="block">/* [p &lt;exponent&gt;] */</comment>
	<if>if <condition>(<expr><call><name>tolower</name><argument_list>(<argument><expr>*<name>s</name></expr></argument>)</argument_list></call> == (<name>int</name>)'p'</expr>)</condition><then> <block>{
		<expr_stmt><expr><name>s</name>++</expr>;</expr_stmt>
		<expr_stmt><expr><name>exp_start</name> = <name>s</name></expr>;</expr_stmt>
		<if>if <condition>(<expr>*<name>s</name> == '-' || *<name>s</name> == '+'</expr>)</condition><then>
			<expr_stmt><expr><name>s</name>++</expr>;</expr_stmt></then></if>
		<if>if <condition>(<expr>!('0' &lt;= *<name>s</name> &amp;&amp; *<name>s</name> &lt;= '9')</expr>)</condition><then>
			<goto>goto <name>parse_error</name>;</goto></then></if>
		<expr_stmt><expr><name>s</name>++</expr>;</expr_stmt>
		<while>while <condition>(<expr>'0' &lt;= *<name>s</name> &amp;&amp; *<name>s</name> &lt;= '9'</expr>)</condition>
			<expr_stmt><expr><name>s</name>++</expr>;</expr_stmt></while>
		<expr_stmt><expr><name>exp</name> = <call><name>strtol</name><argument_list>(<argument><expr><name>exp_start</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr>10</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then>
	<else>else
		<expr_stmt><expr><name>exp</name> = 0</expr>;</expr_stmt></else></if>

	<comment type="block">/* optional trailing whitespace leading to the end of the string */</comment>
	<while>while <condition>(<expr><call><name>isspace</name><argument_list>(<argument><expr>*<name>s</name></expr></argument>)</argument_list></call></expr>)</condition>
		<expr_stmt><expr><name>s</name>++</expr>;</expr_stmt></while>
	<if>if <condition>(<expr><name>s</name> != <name>s_end</name></expr>)</condition><then>
		<goto>goto <name>parse_error</name>;</goto></then></if>

<comment type="block">/* for 0 &lt;= j &lt; ndigits, HEX_DIGIT(j) gives the jth most significant digit */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HEX_DIGIT</name><parameter_list>(<param><type><name>j</name></type></param>)</parameter_list></cpp:macro> <cpp:value>hex_from_char(*((j) &lt; fdigits ?		\
				     coeff_end-(j) :			\
				     coeff_end-1-(j)))</cpp:value></cpp:define>

	<comment type="block">/*******************************************
	 * Compute rounded value of the hex string *
	 *******************************************/</comment>

	<comment type="block">/* Discard leading zeros, and catch extreme overflow and underflow */</comment>
	<while>while <condition>(<expr><name>ndigits</name> &gt; 0 &amp;&amp; <call><name>HEX_DIGIT</name><argument_list>(<argument><expr><name>ndigits</name>-1</expr></argument>)</argument_list></call> == 0</expr>)</condition>
		<expr_stmt><expr><name>ndigits</name>--</expr>;</expr_stmt></while>
	<if>if <condition>(<expr><name>ndigits</name> == 0 || <name>exp</name> &lt; <name>LONG_MIN</name>/2</expr>)</condition><then> <block>{
		<expr_stmt><expr><name>x</name> = <name>sign</name> * 0.0</expr>;</expr_stmt>
		<goto>goto <name>finished</name>;</goto>
	}</block></then></if>
	<if>if <condition>(<expr><name>exp</name> &gt; <name>LONG_MAX</name>/2</expr>)</condition><then>
		<goto>goto <name>overflow_error</name>;</goto></then></if>

	<comment type="block">/* Adjust exponent for fractional part. */</comment>
	<expr_stmt><expr><name>exp</name> = <name>exp</name> - 4*((<name>long</name>)<name>fdigits</name>)</expr>;</expr_stmt>

	<comment type="block">/* top_exp = 1 more than exponent of most sig. bit of coefficient */</comment>
	<expr_stmt><expr><name>top_exp</name> = <name>exp</name> + 4*((<name>long</name>)<name>ndigits</name> - 1)</expr>;</expr_stmt>
	<for>for (<init><expr><name>digit</name> = <call><name>HEX_DIGIT</name><argument_list>(<argument><expr><name>ndigits</name>-1</expr></argument>)</argument_list></call></expr>;</init> <condition><expr><name>digit</name> != 0</expr>;</condition> <incr><expr><name>digit</name> /= 2</expr></incr>)
		<expr_stmt><expr><name>top_exp</name>++</expr>;</expr_stmt></for>

	<comment type="block">/* catch almost all nonextreme cases of overflow and underflow here */</comment>
	<if>if <condition>(<expr><name>top_exp</name> &lt; <name>DBL_MIN_EXP</name> - <name>DBL_MANT_DIG</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>x</name> = <name>sign</name> * 0.0</expr>;</expr_stmt>
		<goto>goto <name>finished</name>;</goto>
	}</block></then></if>
	<if>if <condition>(<expr><name>top_exp</name> &gt; <name>DBL_MAX_EXP</name></expr>)</condition><then>
		<goto>goto <name>overflow_error</name>;</goto></then></if>

	<comment type="block">/* lsb = exponent of least significant bit of the *rounded* value.
	   This is top_exp - DBL_MANT_DIG unless result is subnormal. */</comment>
	<expr_stmt><expr><name>lsb</name> = <call><name>MAX</name><argument_list>(<argument><expr><name>top_exp</name></expr></argument>, <argument><expr>(<name>long</name>)<name>DBL_MIN_EXP</name></expr></argument>)</argument_list></call> - <name>DBL_MANT_DIG</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>x</name> = 0.0</expr>;</expr_stmt>
	<if>if <condition>(<expr><name>exp</name> &gt;= <name>lsb</name></expr>)</condition><then> <block>{
		<comment type="block">/* no rounding required */</comment>
		<for>for (<init><expr><name>i</name> = <name>ndigits</name>-1</expr>;</init> <condition><expr><name>i</name> &gt;= 0</expr>;</condition> <incr><expr><name>i</name>--</expr></incr>)
			<expr_stmt><expr><name>x</name> = 16.0*<name>x</name> + <call><name>HEX_DIGIT</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></for>
		<expr_stmt><expr><name>x</name> = <name>sign</name> * <call><name>ldexp</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><call>(<name>int</name>)<argument_list>(<argument><expr><name>exp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<goto>goto <name>finished</name>;</goto>
	}</block></then></if>
	<comment type="block">/* rounding required.  key_digit is the index of the hex digit
	   containing the first bit to be rounded away. */</comment>
	<expr_stmt><expr><name>half_eps</name> = 1 &lt;&lt; <call>(<name>int</name>)<argument_list>(<argument><expr>(<name>lsb</name> - <name>exp</name> - 1) % 4</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>key_digit</name> = (<name>lsb</name> - <name>exp</name> - 1) / 4</expr>;</expr_stmt>
	<for>for (<init><expr><name>i</name> = <name>ndigits</name>-1</expr>;</init> <condition><expr><name>i</name> &gt; <name>key_digit</name></expr>;</condition> <incr><expr><name>i</name>--</expr></incr>)
		<expr_stmt><expr><name>x</name> = 16.0*<name>x</name> + <call><name>HEX_DIGIT</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></for>
	<expr_stmt><expr><name>digit</name> = <call><name>HEX_DIGIT</name><argument_list>(<argument><expr><name>key_digit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>x</name> = 16.0*<name>x</name> + <call>(<name>double</name>)<argument_list>(<argument><expr><name>digit</name> &amp; (16-2*<name>half_eps</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* round-half-even: round up if bit lsb-1 is 1 and at least one of
	   bits lsb, lsb-2, lsb-3, lsb-4, ... is 1. */</comment>
	<if>if <condition>(<expr>(<name>digit</name> &amp; <name>half_eps</name>) != 0</expr>)</condition><then> <block>{
		<expr_stmt><expr><name>round_up</name> = 0</expr>;</expr_stmt>
		<if>if <condition>(<expr>(<name>digit</name> &amp; (3*<name>half_eps</name>-1)) != 0 ||
		    (<name>half_eps</name> == 8 &amp;&amp; (<call><name>HEX_DIGIT</name><argument_list>(<argument><expr><name>key_digit</name>+1</expr></argument>)</argument_list></call> &amp; 1) != 0)</expr>)</condition><then>
			<expr_stmt><expr><name>round_up</name> = 1</expr>;</expr_stmt></then>
		<else>else
			<for>for (<init><expr><name>i</name> = <name>key_digit</name>-1</expr>;</init> <condition><expr><name>i</name> &gt;= 0</expr>;</condition> <incr><expr><name>i</name>--</expr></incr>)
				<if>if <condition>(<expr><call><name>HEX_DIGIT</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call> != 0</expr>)</condition><then> <block>{
					<expr_stmt><expr><name>round_up</name> = 1</expr>;</expr_stmt>
					<break>break;</break>
				}</block></then></if></for></else></if>
		<if>if <condition>(<expr><name>round_up</name> == 1</expr>)</condition><then> <block>{
			<expr_stmt><expr><name>x</name> += 2*<name>half_eps</name></expr>;</expr_stmt>
			<if>if <condition>(<expr><name>top_exp</name> == <name>DBL_MAX_EXP</name> &amp;&amp;
			    <name>x</name> == <call><name>ldexp</name><argument_list>(<argument><expr><call>(<name>double</name>)<argument_list>(<argument><expr>2*<name>half_eps</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>DBL_MANT_DIG</name></expr></argument>)</argument_list></call></expr>)</condition><then>
				<comment type="block">/* overflow corner case: pre-rounded value &lt;
				   2**DBL_MAX_EXP; rounded=2**DBL_MAX_EXP. */</comment>
				<goto>goto <name>overflow_error</name>;</goto></then></if>
		}</block></then></if>
	}</block></then></if>
	<expr_stmt><expr><name>x</name> = <name>sign</name> * <call><name>ldexp</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><call>(<name>int</name>)<argument_list>(<argument><expr><name>exp</name>+4*<name>key_digit</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <label><name>finished</name>:</label>
	<expr_stmt><expr><name>result_as_float</name> = <call><name>Py_BuildValue</name><argument_list>(<argument><expr>"(d)"</expr></argument>, <argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>result_as_float</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<expr_stmt><expr><name>result</name> = <call><name>PyObject_CallObject</name><argument_list>(<argument><expr><name>cls</name></expr></argument>, <argument><expr><name>result_as_float</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>result_as_float</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>result</name></expr>;</return>

  <label><name>overflow_error</name>:</label>
	<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_OverflowError</name></expr></argument>,
			<argument><expr>"hexadecimal value too large to represent as a float"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>NULL</name></expr>;</return>

  <label><name>parse_error</name>:</label>
	<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>,
			<argument><expr>"invalid hexadecimal floating-point string"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>NULL</name></expr>;</return>

  <label><name>insane_length_error</name>:</label>
	<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>,
			<argument><expr>"hexadecimal string too long to convert"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>NULL</name></expr>;</return>
}</block></function>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>float_fromhex_doc</name></expr></argument>,
<argument><expr>"float.fromhex(string) -&gt; float\n\
\n\
Create a floating-point number from a hexadecimal string.\n\
&gt;&gt;&gt; float.fromhex('0x1.ffffp10')\n\
2047.984375\n\
&gt;&gt;&gt; float.fromhex('-0x1p-1074')\n\
-4.9406564584124654e-324"</expr></argument>)</argument_list></call></expr>;</expr_stmt>


<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>float_as_integer_ratio</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>v</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>unused</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>double</name></type> <name>self</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type> <name>float_part</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>exponent</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>PyObject</name> *</type><name>prev</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>py_exponent</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>numerator</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>denominator</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>result_pair</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyNumberMethods</name> *</type><name>long_methods</name> <init>= <expr><name><name>PyLong_Type</name>.<name>tp_as_number</name></name></expr></init></decl>;</decl_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INPLACE_UPDATE</name><parameter_list>(<param><type><name>obj</name></type></param>, <param><type><name>call</name></type></param>)</parameter_list></cpp:macro> \
	<cpp:value>prev = obj; \
	obj = call; \
	Py_DECREF(prev); \

	CONVERT_TO_DOUBLE(v, self);</cpp:value></cpp:define>

	<if>if <condition>(<expr><call><name>Py_IS_INFINITY</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
	  <expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_OverflowError</name></expr></argument>,
			  <argument><expr>"Cannot pass infinity to float.as_integer_ratio."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	  <return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>Py_NAN</name></cpp:ifdef>
	<if>if <condition>(<expr><call><name>Py_IS_NAN</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
	  <expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>,
			  <argument><expr>"Cannot pass NaN to float.as_integer_ratio."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	  <return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<macro><name>PyFPE_START_PROTECT</name><argument_list>(<argument>"as_integer_ratio"</argument>, <argument>goto error</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
	<expr_stmt><expr><name>float_part</name> = <call><name>frexp</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr>&amp;<name>exponent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  	<comment type="block">/* self == float_part * 2**exponent exactly */</comment>
	<expr_stmt><expr><call><name>PyFPE_END_PROTECT</name><argument_list>(<argument><expr><name>float_part</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	
	<for>for (<init><expr><name>i</name>=0</expr>;</init> <condition><expr><name>i</name>&lt;300 &amp;&amp; <name>float_part</name> != <call><name>floor</name><argument_list>(<argument><expr><name>float_part</name></expr></argument>)</argument_list></call></expr> ;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
		<expr_stmt><expr><name>float_part</name> *= 2.0</expr>;</expr_stmt>
		<expr_stmt><expr><name>exponent</name>--</expr>;</expr_stmt>
	}</block></for>	
	<comment type="block">/* self == float_part * 2**exponent exactly and float_part is integral.
           If FLT_RADIX != 2, the 300 steps may leave a tiny fractional part
           to be truncated by PyLong_FromDouble(). */</comment>

	<expr_stmt><expr><name>numerator</name> = <call><name>PyLong_FromDouble</name><argument_list>(<argument><expr><name>float_part</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>numerator</name> == <name>NULL</name></expr>)</condition><then> <goto>goto <name>error</name>;</goto></then></if>

	<comment type="block">/* fold in 2**exponent */</comment>
	<expr_stmt><expr><name>denominator</name> = <call><name>PyLong_FromLong</name><argument_list>(<argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>py_exponent</name> = <call><name>PyLong_FromLong</name><argument_list>(<argument><expr><call><name>labs</name><argument_list>(<argument><expr>(<name>long</name>)<name>exponent</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>py_exponent</name> == <name>NULL</name></expr>)</condition><then> <goto>goto <name>error</name>;</goto></then></if>
	<expr_stmt><expr><call><name>INPLACE_UPDATE</name><argument_list>(<argument><expr><name>py_exponent</name></expr></argument>,
		       <argument><expr><call><name><name>long_methods</name>-&gt;<name>nb_lshift</name></name><argument_list>(<argument><expr><name>denominator</name></expr></argument>, <argument><expr><name>py_exponent</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>py_exponent</name> == <name>NULL</name></expr>)</condition><then> <goto>goto <name>error</name>;</goto></then></if>
	<if>if <condition>(<expr><name>exponent</name> &gt; 0</expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>INPLACE_UPDATE</name><argument_list>(<argument><expr><name>numerator</name></expr></argument>,
			       <argument><expr><call><name><name>long_methods</name>-&gt;<name>nb_multiply</name></name><argument_list>(<argument><expr><name>numerator</name></expr></argument>, <argument><expr><name>py_exponent</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>numerator</name> == <name>NULL</name></expr>)</condition><then> <goto>goto <name>error</name>;</goto></then></if>
	}</block></then>
	<else>else <block>{
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>denominator</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>denominator</name> = <name>py_exponent</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>py_exponent</name> = <name>NULL</name></expr>;</expr_stmt>
	}</block></else></if>

	<comment type="block">/* Returns ints instead of longs where possible */</comment>
	<expr_stmt><expr><call><name>INPLACE_UPDATE</name><argument_list>(<argument><expr><name>numerator</name></expr></argument>, <argument><expr><call><name>PyNumber_Int</name><argument_list>(<argument><expr><name>numerator</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>numerator</name> == <name>NULL</name></expr>)</condition><then> <goto>goto <name>error</name>;</goto></then></if>
	<expr_stmt><expr><call><name>INPLACE_UPDATE</name><argument_list>(<argument><expr><name>denominator</name></expr></argument>, <argument><expr><call><name>PyNumber_Int</name><argument_list>(<argument><expr><name>denominator</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>denominator</name> == <name>NULL</name></expr>)</condition><then> <goto>goto <name>error</name>;</goto></then></if>

	<expr_stmt><expr><name>result_pair</name> = <call><name>PyTuple_Pack</name><argument_list>(<argument><expr>2</expr></argument>, <argument><expr><name>numerator</name></expr></argument>, <argument><expr><name>denominator</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>INPLACE_UPDATE</name></cpp:undef>
<label><name>error</name>:</label>
	<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>py_exponent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>denominator</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>numerator</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>result_pair</name></expr>;</return>
}</block></function>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>float_as_integer_ratio_doc</name></expr></argument>,
<argument><expr>"float.as_integer_ratio() -&gt; (int, int)\n"
"\n"
"Returns a pair of integers, whose ratio is exactly equal to the original\n"
"float and with a positive denominator.\n"
"Raises OverflowError on infinities and a ValueError on NaNs.\n"
"\n"
"&gt;&gt;&gt; (10.0).as_integer_ratio()\n"
"(10, 1)\n"
"&gt;&gt;&gt; (0.0).as_integer_ratio()\n"
"(0, 1)\n"
"&gt;&gt;&gt; (-.25).as_integer_ratio()\n"
"(-1, 4)"</expr></argument>)</argument_list></call></expr>;</expr_stmt>


<function_decl><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>float_subtype_new</name><parameter_list>(<param><decl><type><name>PyTypeObject</name> *</type><name>type</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>kwds</name></decl></param>)</parameter_list>;</function_decl>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>float_new</name><parameter_list>(<param><decl><type><name>PyTypeObject</name> *</type><name>type</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>kwds</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>x</name> <init>= <expr><name>Py_False</name></expr></init></decl>;</decl_stmt> <comment type="block">/* Integer zero */</comment>
	<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> *</type><name><name>kwlist</name><index>[]</index></name> <init>= <expr><block>{<expr>"x"</expr>, <expr>0</expr>}</block></expr></init></decl>;</decl_stmt>

	<if>if <condition>(<expr><name>type</name> != &amp;<name>PyFloat_Type</name></expr>)</condition><then>
		<return>return <expr><call><name>float_subtype_new</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><name>args</name></expr></argument>, <argument><expr><name>kwds</name></expr></argument>)</argument_list></call></expr>;</return></then></if> <comment type="block">/* Wimp out */</comment>
	<if>if <condition>(<expr>!<call><name>PyArg_ParseTupleAndKeywords</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>kwds</name></expr></argument>, <argument><expr>"|O:float"</expr></argument>, <argument><expr><name>kwlist</name></expr></argument>, <argument><expr>&amp;<name>x</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<if>if <condition>(<expr><call><name>PyString_Check</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><call><name>PyFloat_FromString</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
	<return>return <expr><call><name>PyNumber_Float</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<comment type="block">/* Wimpy, slow approach to tp_new calls for subtypes of float:
   first create a regular float from whatever arguments we got,
   then allocate a subtype instance and initialize its ob_fval
   from the regular float.  The regular float is then thrown away.
*/</comment>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>float_subtype_new</name><parameter_list>(<param><decl><type><name>PyTypeObject</name> *</type><name>type</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>kwds</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>tmp</name></decl>, *<decl><type ref="prev"/><name>newobj</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>PyType_IsSubtype</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr>&amp;<name>PyFloat_Type</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>tmp</name> = <call><name>float_new</name><argument_list>(<argument><expr>&amp;<name>PyFloat_Type</name></expr></argument>, <argument><expr><name>args</name></expr></argument>, <argument><expr><name>kwds</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>tmp</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>PyFloat_CheckExact</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>newobj</name> = <call><name><name>type</name>-&gt;<name>tp_alloc</name></name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>newobj</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>
	<expr_stmt><expr>((<name>PyFloatObject</name> *)<name>newobj</name>)-&gt;<name>ob_fval</name> = ((<name>PyFloatObject</name> *)<name>tmp</name>)-&gt;<name>ob_fval</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>newobj</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>float_getnewargs</name><parameter_list>(<param><decl><type><name>PyFloatObject</name> *</type><name>v</name></decl></param>)</parameter_list>
<block>{
	<return>return <expr><call><name>Py_BuildValue</name><argument_list>(<argument><expr>"(d)"</expr></argument>, <argument><expr><name><name>v</name>-&gt;<name>ob_fval</name></name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<comment type="block">/* this is for the benefit of the pack/unpack routines below */</comment>

<typedef>typedef <type><enum>enum <block>{
	<decl><name>unknown_format</name></decl>, <decl><name>ieee_big_endian_format</name></decl>, <decl><name>ieee_little_endian_format</name></decl>
}</block></enum></type> <name>float_format_type</name>;</typedef>

<decl_stmt><decl><type><specifier>static</specifier> <name>float_format_type</name></type> <name>double_format</name></decl>, <decl><type ref="prev"/><name>float_format</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>float_format_type</name></type> <name>detected_double_format</name></decl>, <decl><type ref="prev"/><name>detected_float_format</name></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>float_getformat</name><parameter_list>(<param><decl><type><name>PyTypeObject</name> *</type><name>v</name></decl></param>, <param><decl><type><name>PyObject</name>*</type> <name>arg</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>char</name>*</type> <name>s</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>float_format_type</name></type> <name>r</name></decl>;</decl_stmt>

	<if>if <condition>(<expr>!<call><name>PyString_Check</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
	     <argument><expr>"__getformat__() argument must be string, not %.500s"</expr></argument>,
			     <argument><expr><call><name>Py_TYPE</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call>-&gt;<name>tp_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>
	<expr_stmt><expr><name>s</name> = <call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr>"double"</expr></argument>)</argument_list></call> == 0</expr>)</condition><then> <block>{
		<expr_stmt><expr><name>r</name> = <name>double_format</name></expr>;</expr_stmt>
	}</block></then>
	<else>else <if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr>"float"</expr></argument>)</argument_list></call> == 0</expr>)</condition><then> <block>{
		<expr_stmt><expr><name>r</name> = <name>float_format</name></expr>;</expr_stmt>
	}</block></then>
	<else>else <block>{
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>,
				<argument><expr>"__getformat__() argument 1 must be "
				"'double' or 'float'"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></else></if></else></if>
	
	<switch>switch <condition>(<expr><name>r</name></expr>)</condition> <block>{
	<case>case <expr><name>unknown_format</name></expr>:
		<return>return <expr><call><name>PyString_FromString</name><argument_list>(<argument><expr>"unknown"</expr></argument>)</argument_list></call></expr>;</return>
	</case><case>case <expr><name>ieee_little_endian_format</name></expr>:
		<return>return <expr><call><name>PyString_FromString</name><argument_list>(<argument><expr>"IEEE, little-endian"</expr></argument>)</argument_list></call></expr>;</return>
	</case><case>case <expr><name>ieee_big_endian_format</name></expr>:
		<return>return <expr><call><name>PyString_FromString</name><argument_list>(<argument><expr>"IEEE, big-endian"</expr></argument>)</argument_list></call></expr>;</return>
	</case><default>default:
		<expr_stmt><expr><call><name>Py_FatalError</name><argument_list>(<argument><expr>"insane float_format or double_format"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	</default>}</block></switch>
}</block></function>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>float_getformat_doc</name></expr></argument>,
<argument><expr>"float.__getformat__(typestr) -&gt; string\n"
"\n"
"You probably don't want to use this function.  It exists mainly to be\n"
"used in Python's test suite.\n"
"\n"
"typestr must be 'double' or 'float'.  This function returns whichever of\n"
"'unknown', 'IEEE, big-endian' or 'IEEE, little-endian' best describes the\n"
"format of floating point numbers used by the C type named by typestr."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>float_setformat</name><parameter_list>(<param><decl><type><name>PyTypeObject</name> *</type><name>v</name></decl></param>, <param><decl><type><name>PyObject</name>*</type> <name>args</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>char</name>*</type> <name>typestr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>*</type> <name>format</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>float_format_type</name></type> <name>f</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>float_format_type</name></type> <name>detected</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>float_format_type</name> *</type><name>p</name></decl>;</decl_stmt>

	<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"ss:__setformat__"</expr></argument>, <argument><expr>&amp;<name>typestr</name></expr></argument>, <argument><expr>&amp;<name>format</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>

	<if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>typestr</name></expr></argument>, <argument><expr>"double"</expr></argument>)</argument_list></call> == 0</expr>)</condition><then> <block>{
		<expr_stmt><expr><name>p</name> = &amp;<name>double_format</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>detected</name> = <name>detected_double_format</name></expr>;</expr_stmt>
	}</block></then>
	<else>else <if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>typestr</name></expr></argument>, <argument><expr>"float"</expr></argument>)</argument_list></call> == 0</expr>)</condition><then> <block>{
		<expr_stmt><expr><name>p</name> = &amp;<name>float_format</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>detected</name> = <name>detected_float_format</name></expr>;</expr_stmt>
	}</block></then>
	<else>else <block>{
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>,
				<argument><expr>"__setformat__() argument 1 must "
				"be 'double' or 'float'"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></else></if></else></if>
	
	<if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>format</name></expr></argument>, <argument><expr>"unknown"</expr></argument>)</argument_list></call> == 0</expr>)</condition><then> <block>{
		<expr_stmt><expr><name>f</name> = <name>unknown_format</name></expr>;</expr_stmt>
	}</block></then>
	<else>else <if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>format</name></expr></argument>, <argument><expr>"IEEE, little-endian"</expr></argument>)</argument_list></call> == 0</expr>)</condition><then> <block>{
		<expr_stmt><expr><name>f</name> = <name>ieee_little_endian_format</name></expr>;</expr_stmt>
	}</block></then>
	<else>else <if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>format</name></expr></argument>, <argument><expr>"IEEE, big-endian"</expr></argument>)</argument_list></call> == 0</expr>)</condition><then> <block>{
		<expr_stmt><expr><name>f</name> = <name>ieee_big_endian_format</name></expr>;</expr_stmt>
	}</block></then>
	<else>else <block>{
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>,
				<argument><expr>"__setformat__() argument 2 must be "
				"'unknown', 'IEEE, little-endian' or "
				"'IEEE, big-endian'"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>

	}</block></else></if></else></if></else></if>

	<if>if <condition>(<expr><name>f</name> != <name>unknown_format</name> &amp;&amp; <name>f</name> != <name>detected</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>,
			     <argument><expr>"can only set %s format to 'unknown' or the "
			     "detected platform value"</expr></argument>, <argument><expr><name>typestr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>

	<expr_stmt><expr>*<name>p</name> = <name>f</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>Py_RETURN_NONE</name></expr>;</expr_stmt>
}</block></function>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>float_setformat_doc</name></expr></argument>,
<argument><expr>"float.__setformat__(typestr, fmt) -&gt; None\n"
"\n"
"You probably don't want to use this function.  It exists mainly to be\n"
"used in Python's test suite.\n"
"\n"
"typestr must be 'double' or 'float'.  fmt must be one of 'unknown',\n"
"'IEEE, big-endian' or 'IEEE, little-endian', and in addition can only be\n"
"one of the latter two if it appears to match the underlying C reality.\n"
"\n"
"Overrides the automatic determination of C-level floating point type.\n"
"This affects how floats are converted to and from binary strings."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>float_getzero</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>v</name></decl></param>, <param><decl><type><name>void</name> *</type><name>closure</name></decl></param>)</parameter_list>
<block>{
	<return>return <expr><call><name>PyFloat_FromDouble</name><argument_list>(<argument><expr>0.0</expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>float__format__</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>format_spec</name></decl>;</decl_stmt>

	<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"O:__format__"</expr></argument>, <argument><expr>&amp;<name>format_spec</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<if>if <condition>(<expr><call><name>PyBytes_Check</name><argument_list>(<argument><expr><name>format_spec</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><call><name>_PyFloat_FormatAdvanced</name><argument_list>(<argument><expr><name>self</name></expr></argument>,
					       <argument><expr><call><name>PyBytes_AS_STRING</name><argument_list>(<argument><expr><name>format_spec</name></expr></argument>)</argument_list></call></expr></argument>,
					       <argument><expr><call><name>PyBytes_GET_SIZE</name><argument_list>(<argument><expr><name>format_spec</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></then></if>
	<if>if <condition>(<expr><call><name>PyUnicode_Check</name><argument_list>(<argument><expr><name>format_spec</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<comment type="block">/* Convert format_spec to a str */</comment>
		<decl_stmt><decl><type><name>PyObject</name> *</type><name>result</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PyObject</name> *</type><name>str_spec</name> <init>= <expr><call><name>PyObject_Str</name><argument_list>(<argument><expr><name>format_spec</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if>if <condition>(<expr><name>str_spec</name> == <name>NULL</name></expr>)</condition><then>
			<return>return <expr><name>NULL</name></expr>;</return></then></if>

		<expr_stmt><expr><name>result</name> = <call><name>_PyFloat_FormatAdvanced</name><argument_list>(<argument><expr><name>self</name></expr></argument>,
						 <argument><expr><call><name>PyBytes_AS_STRING</name><argument_list>(<argument><expr><name>str_spec</name></expr></argument>)</argument_list></call></expr></argument>,
						 <argument><expr><call><name>PyBytes_GET_SIZE</name><argument_list>(<argument><expr><name>str_spec</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>str_spec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>result</name></expr>;</return>
	}</block></then></if>
	<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>, <argument><expr>"__format__ requires str or unicode"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>NULL</name></expr>;</return>
}</block></function>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>float__format__doc</name></expr></argument>,
<argument><expr>"float.__format__(format_spec) -&gt; string\n"
"\n"
"Formats the float according to format_spec."</expr></argument>)</argument_list></call></expr>;</expr_stmt>


<decl_stmt><decl><type><specifier>static</specifier> <name>PyMethodDef</name></type> <name><name>float_methods</name><index>[]</index></name> <init>= <expr><block>{
	<expr><block>{<expr>"conjugate"</expr>,	<expr>(<name>PyCFunction</name>)<name>float_float</name></expr>,	<expr><name>METH_NOARGS</name></expr>,
	 <expr>"Returns self, the complex conjugate of any float."</expr>}</block></expr>,
	<expr><block>{<expr>"__trunc__"</expr>,	<expr>(<name>PyCFunction</name>)<name>float_trunc</name></expr>, <expr><name>METH_NOARGS</name></expr>,
         <expr>"Returns the Integral closest to x between 0 and x."</expr>}</block></expr>,
	<expr><block>{<expr>"as_integer_ratio"</expr>, <expr>(<name>PyCFunction</name>)<name>float_as_integer_ratio</name></expr>, <expr><name>METH_NOARGS</name></expr>,
	 <expr><name>float_as_integer_ratio_doc</name></expr>}</block></expr>,
	<expr><block>{<expr>"fromhex"</expr>, <expr>(<name>PyCFunction</name>)<name>float_fromhex</name></expr>,
	 <expr><name>METH_O</name>|<name>METH_CLASS</name></expr>, <expr><name>float_fromhex_doc</name></expr>}</block></expr>,
	<expr><block>{<expr>"hex"</expr>, <expr>(<name>PyCFunction</name>)<name>float_hex</name></expr>,
	 <expr><name>METH_NOARGS</name></expr>, <expr><name>float_hex_doc</name></expr>}</block></expr>,
	<expr><block>{<expr>"is_integer"</expr>,	<expr>(<name>PyCFunction</name>)<name>float_is_integer</name></expr>,	<expr><name>METH_NOARGS</name></expr>,
	 <expr>"Returns True if the float is an integer."</expr>}</block></expr>,
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>0</expr></cpp:if>
	{"is_inf",	(PyCFunction)float_is_inf,	METH_NOARGS,
	 "Returns True if the float is positive or negative infinite."},
	{"is_finite",	(PyCFunction)float_is_finite,	METH_NOARGS,
	 "Returns True if the float is finite, neither infinite nor NaN."},
	{"is_nan",	(PyCFunction)float_is_nan,	METH_NOARGS,
	 "Returns True if the float is not a number (NaN)."},
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<expr><block>{<expr>"__getnewargs__"</expr>,	<expr>(<name>PyCFunction</name>)<name>float_getnewargs</name></expr>,	<expr><name>METH_NOARGS</name></expr>}</block></expr>,
	<expr><block>{<expr>"__getformat__"</expr>,	<expr>(<name>PyCFunction</name>)<name>float_getformat</name></expr>,	
	 <expr><name>METH_O</name>|<name>METH_CLASS</name></expr>,		<expr><name>float_getformat_doc</name></expr>}</block></expr>,
	<expr><block>{<expr>"__setformat__"</expr>,	<expr>(<name>PyCFunction</name>)<name>float_setformat</name></expr>,	
	 <expr><name>METH_VARARGS</name>|<name>METH_CLASS</name></expr>,	<expr><name>float_setformat_doc</name></expr>}</block></expr>,
        <expr><block>{<expr>"__format__"</expr>,          <expr>(<name>PyCFunction</name>)<name>float__format__</name></expr>,
         <expr><name>METH_VARARGS</name></expr>,                  <expr><name>float__format__doc</name></expr>}</block></expr>,
	<expr><block>{<expr><name>NULL</name></expr>,		<expr><name>NULL</name></expr>}</block></expr>		<comment type="block">/* sentinel */</comment>
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>PyGetSetDef</name></type> <name><name>float_getset</name><index>[]</index></name> <init>= <expr><block>{
    <expr><block>{<expr>"real"</expr>, 
     <expr>(<name>getter</name>)<name>float_float</name></expr>, <expr>(<name>setter</name>)<name>NULL</name></expr>,
     <expr>"the real part of a complex number"</expr>,
     <expr><name>NULL</name></expr>}</block></expr>,
    <expr><block>{<expr>"imag"</expr>, 
     <expr>(<name>getter</name>)<name>float_getzero</name></expr>, <expr>(<name>setter</name>)<name>NULL</name></expr>,
     <expr>"the imaginary part of a complex number"</expr>,
     <expr><name>NULL</name></expr>}</block></expr>,
    <expr><block>{<expr><name>NULL</name></expr>}</block></expr>  <comment type="block">/* Sentinel */</comment>
}</block></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>float_doc</name></expr></argument>,
<argument><expr>"float(x) -&gt; floating point number\n\
\n\
Convert a string or number to a floating point number, if possible."</expr></argument>)</argument_list></call></expr>;</expr_stmt>


<decl_stmt><decl><type><specifier>static</specifier> <name>PyNumberMethods</name></type> <name>float_as_number</name> <init>= <expr><block>{
	<expr><name>float_add</name></expr>, 	<comment type="block">/*nb_add*/</comment>
	<expr><name>float_sub</name></expr>, 	<comment type="block">/*nb_subtract*/</comment>
	<expr><name>float_mul</name></expr>, 	<comment type="block">/*nb_multiply*/</comment>
	<expr><name>float_classic_div</name></expr>, <comment type="block">/*nb_divide*/</comment>
	<expr><name>float_rem</name></expr>, 	<comment type="block">/*nb_remainder*/</comment>
	<expr><name>float_divmod</name></expr>, 	<comment type="block">/*nb_divmod*/</comment>
	<expr><name>float_pow</name></expr>, 	<comment type="block">/*nb_power*/</comment>
	<expr>(<name>unaryfunc</name>)<name>float_neg</name></expr>, <comment type="block">/*nb_negative*/</comment>
	<expr>(<name>unaryfunc</name>)<name>float_float</name></expr>, <comment type="block">/*nb_positive*/</comment>
	<expr>(<name>unaryfunc</name>)<name>float_abs</name></expr>, <comment type="block">/*nb_absolute*/</comment>
	<expr>(<name>inquiry</name>)<name>float_nonzero</name></expr>, <comment type="block">/*nb_nonzero*/</comment>
	<expr>0</expr>,		<comment type="block">/*nb_invert*/</comment>
	<expr>0</expr>,		<comment type="block">/*nb_lshift*/</comment>
	<expr>0</expr>,		<comment type="block">/*nb_rshift*/</comment>
	<expr>0</expr>,		<comment type="block">/*nb_and*/</comment>
	<expr>0</expr>,		<comment type="block">/*nb_xor*/</comment>
	<expr>0</expr>,		<comment type="block">/*nb_or*/</comment>
	<expr><name>float_coerce</name></expr>, 	<comment type="block">/*nb_coerce*/</comment>
	<expr><name>float_trunc</name></expr>, 	<comment type="block">/*nb_int*/</comment>
	<expr><name>float_long</name></expr>, 	<comment type="block">/*nb_long*/</comment>
	<expr><name>float_float</name></expr>,	<comment type="block">/*nb_float*/</comment>
	<expr>0</expr>,		<comment type="block">/* nb_oct */</comment>
	<expr>0</expr>,		<comment type="block">/* nb_hex */</comment>
	<expr>0</expr>,		<comment type="block">/* nb_inplace_add */</comment>
	<expr>0</expr>,		<comment type="block">/* nb_inplace_subtract */</comment>
	<expr>0</expr>,		<comment type="block">/* nb_inplace_multiply */</comment>
	<expr>0</expr>,		<comment type="block">/* nb_inplace_divide */</comment>
	<expr>0</expr>,		<comment type="block">/* nb_inplace_remainder */</comment>
	<expr>0</expr>, 		<comment type="block">/* nb_inplace_power */</comment>
	<expr>0</expr>,		<comment type="block">/* nb_inplace_lshift */</comment>
	<expr>0</expr>,		<comment type="block">/* nb_inplace_rshift */</comment>
	<expr>0</expr>,		<comment type="block">/* nb_inplace_and */</comment>
	<expr>0</expr>,		<comment type="block">/* nb_inplace_xor */</comment>
	<expr>0</expr>,		<comment type="block">/* nb_inplace_or */</comment>
	<expr><name>float_floor_div</name></expr>, <comment type="block">/* nb_floor_divide */</comment>
	<expr><name>float_div</name></expr>,	<comment type="block">/* nb_true_divide */</comment>
	<expr>0</expr>,		<comment type="block">/* nb_inplace_floor_divide */</comment>
	<expr>0</expr>,		<comment type="block">/* nb_inplace_true_divide */</comment>
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>PyTypeObject</name></type> <name>PyFloat_Type</name> <init>= <expr><block>{
	<expr><call><name>PyVarObject_HEAD_INIT</name><argument_list>(<argument><expr>&amp;<name>PyType_Type</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call>
	"float"</expr>,
	<expr><sizeof>sizeof<argument_list>(<argument><expr><name>PyFloatObject</name></expr></argument>)</argument_list></sizeof></expr>,
	<expr>0</expr>,
	<expr>(<name>destructor</name>)<name>float_dealloc</name></expr>,		<comment type="block">/* tp_dealloc */</comment>
	<expr>(<name>printfunc</name>)<name>float_print</name></expr>, 		<comment type="block">/* tp_print */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_getattr */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_setattr */</comment>
	<expr>0</expr>,			 		<comment type="block">/* tp_compare */</comment>
	<expr>(<name>reprfunc</name>)<name>float_repr</name></expr>,			<comment type="block">/* tp_repr */</comment>
	<expr>&amp;<name>float_as_number</name></expr>,			<comment type="block">/* tp_as_number */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_as_sequence */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_as_mapping */</comment>
	<expr>(<name>hashfunc</name>)<name>float_hash</name></expr>,			<comment type="block">/* tp_hash */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_call */</comment>
	<expr>(<name>reprfunc</name>)<name>float_str</name></expr>,			<comment type="block">/* tp_str */</comment>
	<expr><name>PyObject_GenericGetAttr</name></expr>,		<comment type="block">/* tp_getattro */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_setattro */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_as_buffer */</comment>
	<expr><name>Py_TPFLAGS_DEFAULT</name> | <name>Py_TPFLAGS_CHECKTYPES</name> |
		<name>Py_TPFLAGS_BASETYPE</name></expr>,		<comment type="block">/* tp_flags */</comment>
	<expr><name>float_doc</name></expr>,				<comment type="block">/* tp_doc */</comment>
 	<expr>0</expr>,					<comment type="block">/* tp_traverse */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_clear */</comment>
	<expr><name>float_richcompare</name></expr>,			<comment type="block">/* tp_richcompare */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_weaklistoffset */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_iter */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_iternext */</comment>
	<expr><name>float_methods</name></expr>,				<comment type="block">/* tp_methods */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_members */</comment>
	<expr><name>float_getset</name></expr>,				<comment type="block">/* tp_getset */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_base */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_dict */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_descr_get */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_descr_set */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_dictoffset */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_init */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_alloc */</comment>
	<expr><name>float_new</name></expr>,				<comment type="block">/* tp_new */</comment>
}</block></expr></init></decl>;</decl_stmt>

<function><type><name>void</name></type>
<name>_PyFloat_Init</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list>
<block>{
	<comment type="block">/* We attempt to determine if this machine is using IEEE
	   floating point formats by peering at the bits of some
	   carefully chosen values.  If it looks like we are on an
	   IEEE platform, the float packing/unpacking routines can
	   just copy bits, if not they resort to arithmetic &amp; shifts
	   and masks.  The shifts &amp; masks approach works on all finite
	   values, but what happens to infinities, NaNs and signed
	   zeroes on packing is an accident, and attempting to unpack
	   a NaN or an infinity will raise an exception.

	   Note that if we're on some whacked-out platform which uses
	   IEEE formats but isn't strictly little-endian or big-
	   endian, we will fall back to the portable shifts &amp; masks
	   method. */</comment>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SIZEOF_DOUBLE</name> == 8</expr></cpp:if>
	<block>{
		<decl_stmt><decl><type><name>double</name></type> <name>x</name> <init>= <expr>9006104071832581.0</expr></init></decl>;</decl_stmt>
		<if>if <condition>(<expr><call><name>memcmp</name><argument_list>(<argument><expr>&amp;<name>x</name></expr></argument>, <argument><expr>"\x43\x3f\xff\x01\x02\x03\x04\x05"</expr></argument>, <argument><expr>8</expr></argument>)</argument_list></call> == 0</expr>)</condition><then>
			<expr_stmt><expr><name>detected_double_format</name> = <name>ieee_big_endian_format</name></expr>;</expr_stmt></then>
		<else>else <if>if <condition>(<expr><call><name>memcmp</name><argument_list>(<argument><expr>&amp;<name>x</name></expr></argument>, <argument><expr>"\x05\x04\x03\x02\x01\xff\x3f\x43"</expr></argument>, <argument><expr>8</expr></argument>)</argument_list></call> == 0</expr>)</condition><then>
			<expr_stmt><expr><name>detected_double_format</name> = <name>ieee_little_endian_format</name></expr>;</expr_stmt></then>
		<else>else 
			<expr_stmt><expr><name>detected_double_format</name> = <name>unknown_format</name></expr>;</expr_stmt></else></if></else></if>
	}</block>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<expr_stmt><expr><name>detected_double_format</name> = <name>unknown_format</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SIZEOF_FLOAT</name> == 4</expr></cpp:if>
	<block>{
		<decl_stmt><decl><type><name>float</name></type> <name>y</name> <init>= <expr>16711938.0</expr></init></decl>;</decl_stmt>
		<if>if <condition>(<expr><call><name>memcmp</name><argument_list>(<argument><expr>&amp;<name>y</name></expr></argument>, <argument><expr>"\x4b\x7f\x01\x02"</expr></argument>, <argument><expr>4</expr></argument>)</argument_list></call> == 0</expr>)</condition><then>
			<expr_stmt><expr><name>detected_float_format</name> = <name>ieee_big_endian_format</name></expr>;</expr_stmt></then>
		<else>else <if>if <condition>(<expr><call><name>memcmp</name><argument_list>(<argument><expr>&amp;<name>y</name></expr></argument>, <argument><expr>"\x02\x01\x7f\x4b"</expr></argument>, <argument><expr>4</expr></argument>)</argument_list></call> == 0</expr>)</condition><then>
			<expr_stmt><expr><name>detected_float_format</name> = <name>ieee_little_endian_format</name></expr>;</expr_stmt></then>
		<else>else 
			<expr_stmt><expr><name>detected_float_format</name> = <name>unknown_format</name></expr>;</expr_stmt></else></if></else></if>
	}</block>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<expr_stmt><expr><name>detected_float_format</name> = <name>unknown_format</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<expr_stmt><expr><name>double_format</name> = <name>detected_double_format</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>float_format</name> = <name>detected_float_format</name></expr>;</expr_stmt>

	<comment type="block">/* Init float info */</comment>
	<if>if <condition>(<expr><name><name>FloatInfoType</name>.<name>tp_name</name></name> == 0</expr>)</condition><then>
		<expr_stmt><expr><call><name>PyStructSequence_InitType</name><argument_list>(<argument><expr>&amp;<name>FloatInfoType</name></expr></argument>, <argument><expr>&amp;<name>floatinfo_desc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
}</block></function>

<function><type><name>int</name></type>
<name>PyFloat_ClearFreeList</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyFloatObject</name> *</type><name>p</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyFloatBlock</name> *</type><name>list</name></decl>, *<decl><type ref="prev"/><name>next</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>u</name></decl>;</decl_stmt>			<comment type="block">/* remaining unfreed ints per block */</comment>
	<decl_stmt><decl><type><name>int</name></type> <name>freelist_size</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>list</name> = <name>block_list</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>block_list</name> = <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>free_list</name> = <name>NULL</name></expr>;</expr_stmt>
	<while>while <condition>(<expr><name>list</name> != <name>NULL</name></expr>)</condition> <block>{
		<expr_stmt><expr><name>u</name> = 0</expr>;</expr_stmt>
		<for>for (<init><expr><name>i</name> = 0</expr>, <expr><name>p</name> = &amp;<name><name>list</name>-&gt;<name>objects</name><index>[<expr>0</expr>]</index></name></expr>;</init>
		     <condition><expr><name>i</name> &lt; <name>N_FLOATOBJECTS</name></expr>;</condition>
		     <incr><expr><name>i</name>++</expr>, <expr><name>p</name>++</expr></incr>) <block>{
			<if>if <condition>(<expr><call><name>PyFloat_CheckExact</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call> &amp;&amp; <call><name>Py_REFCNT</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call> != 0</expr>)</condition><then>
				<expr_stmt><expr><name>u</name>++</expr>;</expr_stmt></then></if>
		}</block></for>
		<expr_stmt><expr><name>next</name> = <name><name>list</name>-&gt;<name>next</name></name></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>u</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><name><name>list</name>-&gt;<name>next</name></name> = <name>block_list</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>block_list</name> = <name>list</name></expr>;</expr_stmt>
			<for>for (<init><expr><name>i</name> = 0</expr>, <expr><name>p</name> = &amp;<name><name>list</name>-&gt;<name>objects</name><index>[<expr>0</expr>]</index></name></expr>;</init>
			     <condition><expr><name>i</name> &lt; <name>N_FLOATOBJECTS</name></expr>;</condition>
			     <incr><expr><name>i</name>++</expr>, <expr><name>p</name>++</expr></incr>) <block>{
				<if>if <condition>(<expr>!<call><name>PyFloat_CheckExact</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call> ||
				    <call><name>Py_REFCNT</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call> == 0</expr>)</condition><then> <block>{
					<expr_stmt><expr><call><name>Py_TYPE</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call> = (struct <name>_typeobject</name> *)
						<name>free_list</name></expr>;</expr_stmt>
					<expr_stmt><expr><name>free_list</name> = <name>p</name></expr>;</expr_stmt>
				}</block></then></if>
			}</block></for>
		}</block></then>
		<else>else <block>{
			<expr_stmt><expr><call><name>PyMem_FREE</name><argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></else></if>
		<expr_stmt><expr><name>freelist_size</name> += <name>u</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>list</name> = <name>next</name></expr>;</expr_stmt>
	}</block></while>
	<return>return <expr><name>freelist_size</name></expr>;</return>
}</block></function>

<function><type><name>void</name></type>
<name>PyFloat_Fini</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyFloatObject</name> *</type><name>p</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyFloatBlock</name> *</type><name>list</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>u</name></decl>;</decl_stmt>			<comment type="block">/* total unfreed floats per block */</comment>

	<expr_stmt><expr><name>u</name> = <call><name>PyFloat_ClearFreeList</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<if>if <condition>(<expr>!<name>Py_VerboseFlag</name></expr>)</condition><then>
		<return>return;</return></then></if>
	<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr>"# cleanup floats"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr>!<name>u</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr>"\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then>
	<else>else <block>{
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,
			<argument><expr>": %d unfreed float%s\n"</expr></argument>,
			<argument><expr><name>u</name></expr></argument>, <argument><expr><name>u</name> == 1 ? "" : "s"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></else></if>
	<if>if <condition>(<expr><name>Py_VerboseFlag</name> &gt; 1</expr>)</condition><then> <block>{
		<expr_stmt><expr><name>list</name> = <name>block_list</name></expr>;</expr_stmt>
		<while>while <condition>(<expr><name>list</name> != <name>NULL</name></expr>)</condition> <block>{
			<for>for (<init><expr><name>i</name> = 0</expr>, <expr><name>p</name> = &amp;<name><name>list</name>-&gt;<name>objects</name><index>[<expr>0</expr>]</index></name></expr>;</init>
			     <condition><expr><name>i</name> &lt; <name>N_FLOATOBJECTS</name></expr>;</condition>
			     <incr><expr><name>i</name>++</expr>, <expr><name>p</name>++</expr></incr>) <block>{
				<if>if <condition>(<expr><call><name>PyFloat_CheckExact</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call> &amp;&amp;
				    <call><name>Py_REFCNT</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call> != 0</expr>)</condition><then> <block>{
					<decl_stmt><decl><type><name>char</name></type> <name><name>buf</name><index>[<expr>100</expr>]</index></name></decl>;</decl_stmt>
					<expr_stmt><expr><call><name>PyFloat_AsString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<comment type="block">/* XXX(twouters) cast refcount to
					   long until %zd is universally
					   available
					 */</comment>
					<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,
			     <argument><expr>"#   &lt;float at %p, refcnt=%ld, val=%s&gt;\n"</expr></argument>,
						<argument><expr><name>p</name></expr></argument>, <argument><expr>(<name>long</name>)<call><name>Py_REFCNT</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				}</block></then></if>
			}</block></for>
			<expr_stmt><expr><name>list</name> = <name><name>list</name>-&gt;<name>next</name></name></expr>;</expr_stmt>
		}</block></while>
	}</block></then></if>
}</block></function>

<comment type="block">/*----------------------------------------------------------------------------
 * _PyFloat_{Pack,Unpack}{4,8}.  See floatobject.h.
 */</comment>
<function><type><name>int</name></type>
<name>_PyFloat_Pack4</name><parameter_list>(<param><decl><type><name>double</name></type> <name>x</name></decl></param>, <param><decl><type><name>unsigned</name> <name>char</name> *</type><name>p</name></decl></param>, <param><decl><type><name>int</name></type> <name>le</name></decl></param>)</parameter_list>
<block>{
	<if>if <condition>(<expr><name>float_format</name> == <name>unknown_format</name></expr>)</condition><then> <block>{
		<decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name>sign</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>e</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>double</name></type> <name>f</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>fbits</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>incr</name> <init>= <expr>1</expr></init></decl>;</decl_stmt>

		<if>if <condition>(<expr><name>le</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><name>p</name> += 3</expr>;</expr_stmt>
			<expr_stmt><expr><name>incr</name> = -1</expr>;</expr_stmt>
		}</block></then></if>

		<if>if <condition>(<expr><name>x</name> &lt; 0</expr>)</condition><then> <block>{
			<expr_stmt><expr><name>sign</name> = 1</expr>;</expr_stmt>
			<expr_stmt><expr><name>x</name> = -<name>x</name></expr>;</expr_stmt>
		}</block></then>
		<else>else
			<expr_stmt><expr><name>sign</name> = 0</expr>;</expr_stmt></else></if>

		<expr_stmt><expr><name>f</name> = <call><name>frexp</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr>&amp;<name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Normalize f to be in the range [1.0, 2.0) */</comment>
		<if>if <condition>(<expr>0.5 &lt;= <name>f</name> &amp;&amp; <name>f</name> &lt; 1.0</expr>)</condition><then> <block>{
			<expr_stmt><expr><name>f</name> *= 2.0</expr>;</expr_stmt>
			<expr_stmt><expr><name>e</name>--</expr>;</expr_stmt>
		}</block></then>
		<else>else <if>if <condition>(<expr><name>f</name> == 0.0</expr>)</condition><then>
			<expr_stmt><expr><name>e</name> = 0</expr>;</expr_stmt></then>
		<else>else <block>{
			<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_SystemError</name></expr></argument>,
					<argument><expr>"frexp() result out of range"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr>-1</expr>;</return>
		}</block></else></if></else></if>

		<if>if <condition>(<expr><name>e</name> &gt;= 128</expr>)</condition><then>
			<goto>goto <name>Overflow</name>;</goto></then>
		<else>else <if>if <condition>(<expr><name>e</name> &lt; -126</expr>)</condition><then> <block>{
			<comment type="block">/* Gradual underflow */</comment>
			<expr_stmt><expr><name>f</name> = <call><name>ldexp</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr>126 + <name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>e</name> = 0</expr>;</expr_stmt>
		}</block></then>
		<else>else <if>if <condition>(<expr>!(<name>e</name> == 0 &amp;&amp; <name>f</name> == 0.0)</expr>)</condition><then> <block>{
			<expr_stmt><expr><name>e</name> += 127</expr>;</expr_stmt>
			<expr_stmt><expr><name>f</name> -= 1.0</expr>;</expr_stmt> <comment type="block">/* Get rid of leading 1 */</comment>
		}</block></then></if></else></if></else></if>

		<expr_stmt><expr><name>f</name> *= 8388608.0</expr>;</expr_stmt> <comment type="block">/* 2**23 */</comment>
		<expr_stmt><expr><name>fbits</name> = <call>(<name>unsigned</name> <name>int</name>)<argument_list>(<argument><expr><name>f</name> + 0.5</expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* Round */</comment>
		<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>fbits</name> &lt;= 8388608</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>fbits</name> &gt;&gt; 23</expr>)</condition><then> <block>{
			<comment type="block">/* The carry propagated out of a string of 23 1 bits. */</comment>
			<expr_stmt><expr><name>fbits</name> = 0</expr>;</expr_stmt>
			<expr_stmt><expr>++<name>e</name></expr>;</expr_stmt>
			<if>if <condition>(<expr><name>e</name> &gt;= 255</expr>)</condition><then>
				<goto>goto <name>Overflow</name>;</goto></then></if>
		}</block></then></if>

		<comment type="block">/* First byte */</comment>
		<expr_stmt><expr>*<name>p</name> = (<name>sign</name> &lt;&lt; 7) | (<name>e</name> &gt;&gt; 1)</expr>;</expr_stmt>
		<expr_stmt><expr><name>p</name> += <name>incr</name></expr>;</expr_stmt>

		<comment type="block">/* Second byte */</comment>
		<expr_stmt><expr>*<name>p</name> = <call>(<name>char</name>) <argument_list>(<argument><expr>((<name>e</name> &amp; 1) &lt;&lt; 7) | (<name>fbits</name> &gt;&gt; 16)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>p</name> += <name>incr</name></expr>;</expr_stmt>

		<comment type="block">/* Third byte */</comment>
		<expr_stmt><expr>*<name>p</name> = (<name>fbits</name> &gt;&gt; 8) &amp; 0xFF</expr>;</expr_stmt>
		<expr_stmt><expr><name>p</name> += <name>incr</name></expr>;</expr_stmt>

		<comment type="block">/* Fourth byte */</comment>
		<expr_stmt><expr>*<name>p</name> = <name>fbits</name> &amp; 0xFF</expr>;</expr_stmt>

		<comment type="block">/* Done */</comment>
		<return>return <expr>0</expr>;</return>

	}</block></then>
	<else>else <block>{
		<decl_stmt><decl><type><name>float</name></type> <name>y</name> <init>= <expr>(<name>float</name>)<name>x</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>s</name> <init>= <expr>(<name>char</name>*)&amp;<name>y</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>incr</name> <init>= <expr>1</expr></init></decl>;</decl_stmt>

		<if>if <condition>(<expr><call><name>Py_IS_INFINITY</name><argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call> &amp;&amp; !<call><name>Py_IS_INFINITY</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>)</condition><then>
			<goto>goto <name>Overflow</name>;</goto></then></if>

		<if>if <condition>(<expr>(<name>float_format</name> == <name>ieee_little_endian_format</name> &amp;&amp; !<name>le</name>)
		    || (<name>float_format</name> == <name>ieee_big_endian_format</name> &amp;&amp; <name>le</name>)</expr>)</condition><then> <block>{
			<expr_stmt><expr><name>p</name> += 3</expr>;</expr_stmt>
			<expr_stmt><expr><name>incr</name> = -1</expr>;</expr_stmt>
		}</block></then></if>

		<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; 4</expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
			<expr_stmt><expr>*<name>p</name> = *<name>s</name>++</expr>;</expr_stmt>
			<expr_stmt><expr><name>p</name> += <name>incr</name></expr>;</expr_stmt>
		}</block></for>
		<return>return <expr>0</expr>;</return>
	}</block></else></if>
  <label><name>Overflow</name>:</label>
	<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_OverflowError</name></expr></argument>,
			<argument><expr>"float too large to pack with f format"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr>-1</expr>;</return>
}</block></function>

<function><type><name>int</name></type>
<name>_PyFloat_Pack8</name><parameter_list>(<param><decl><type><name>double</name></type> <name>x</name></decl></param>, <param><decl><type><name>unsigned</name> <name>char</name> *</type><name>p</name></decl></param>, <param><decl><type><name>int</name></type> <name>le</name></decl></param>)</parameter_list>
<block>{
	<if>if <condition>(<expr><name>double_format</name> == <name>unknown_format</name></expr>)</condition><then> <block>{
		<decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name>sign</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>e</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>double</name></type> <name>f</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>fhi</name></decl>, <decl><type ref="prev"/><name>flo</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>incr</name> <init>= <expr>1</expr></init></decl>;</decl_stmt>

		<if>if <condition>(<expr><name>le</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><name>p</name> += 7</expr>;</expr_stmt>
			<expr_stmt><expr><name>incr</name> = -1</expr>;</expr_stmt>
		}</block></then></if>

		<if>if <condition>(<expr><name>x</name> &lt; 0</expr>)</condition><then> <block>{
			<expr_stmt><expr><name>sign</name> = 1</expr>;</expr_stmt>
			<expr_stmt><expr><name>x</name> = -<name>x</name></expr>;</expr_stmt>
		}</block></then>
		<else>else
			<expr_stmt><expr><name>sign</name> = 0</expr>;</expr_stmt></else></if>

		<expr_stmt><expr><name>f</name> = <call><name>frexp</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr>&amp;<name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Normalize f to be in the range [1.0, 2.0) */</comment>
		<if>if <condition>(<expr>0.5 &lt;= <name>f</name> &amp;&amp; <name>f</name> &lt; 1.0</expr>)</condition><then> <block>{
			<expr_stmt><expr><name>f</name> *= 2.0</expr>;</expr_stmt>
			<expr_stmt><expr><name>e</name>--</expr>;</expr_stmt>
		}</block></then>
		<else>else <if>if <condition>(<expr><name>f</name> == 0.0</expr>)</condition><then>
			<expr_stmt><expr><name>e</name> = 0</expr>;</expr_stmt></then>
		<else>else <block>{
			<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_SystemError</name></expr></argument>,
					<argument><expr>"frexp() result out of range"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr>-1</expr>;</return>
		}</block></else></if></else></if>

		<if>if <condition>(<expr><name>e</name> &gt;= 1024</expr>)</condition><then>
			<goto>goto <name>Overflow</name>;</goto></then>
		<else>else <if>if <condition>(<expr><name>e</name> &lt; -1022</expr>)</condition><then> <block>{
			<comment type="block">/* Gradual underflow */</comment>
			<expr_stmt><expr><name>f</name> = <call><name>ldexp</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr>1022 + <name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>e</name> = 0</expr>;</expr_stmt>
		}</block></then>
		<else>else <if>if <condition>(<expr>!(<name>e</name> == 0 &amp;&amp; <name>f</name> == 0.0)</expr>)</condition><then> <block>{
			<expr_stmt><expr><name>e</name> += 1023</expr>;</expr_stmt>
			<expr_stmt><expr><name>f</name> -= 1.0</expr>;</expr_stmt> <comment type="block">/* Get rid of leading 1 */</comment>
		}</block></then></if></else></if></else></if>

		<comment type="block">/* fhi receives the high 28 bits; flo the low 24 bits (== 52 bits) */</comment>
		<expr_stmt><expr><name>f</name> *= 268435456.0</expr>;</expr_stmt> <comment type="block">/* 2**28 */</comment>
		<expr_stmt><expr><name>fhi</name> = (<name>unsigned</name> <name>int</name>)<name>f</name></expr>;</expr_stmt> <comment type="block">/* Truncate */</comment>
		<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>fhi</name> &lt; 268435456</expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>f</name> -= (<name>double</name>)<name>fhi</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>f</name> *= 16777216.0</expr>;</expr_stmt> <comment type="block">/* 2**24 */</comment>
		<expr_stmt><expr><name>flo</name> = <call>(<name>unsigned</name> <name>int</name>)<argument_list>(<argument><expr><name>f</name> + 0.5</expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* Round */</comment>
		<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>flo</name> &lt;= 16777216</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>flo</name> &gt;&gt; 24</expr>)</condition><then> <block>{
			<comment type="block">/* The carry propagated out of a string of 24 1 bits. */</comment>
			<expr_stmt><expr><name>flo</name> = 0</expr>;</expr_stmt>
			<expr_stmt><expr>++<name>fhi</name></expr>;</expr_stmt>
			<if>if <condition>(<expr><name>fhi</name> &gt;&gt; 28</expr>)</condition><then> <block>{
				<comment type="block">/* And it also progagated out of the next 28 bits. */</comment>
				<expr_stmt><expr><name>fhi</name> = 0</expr>;</expr_stmt>
				<expr_stmt><expr>++<name>e</name></expr>;</expr_stmt>
				<if>if <condition>(<expr><name>e</name> &gt;= 2047</expr>)</condition><then>
					<goto>goto <name>Overflow</name>;</goto></then></if>
			}</block></then></if>
		}</block></then></if>

		<comment type="block">/* First byte */</comment>
		<expr_stmt><expr>*<name>p</name> = (<name>sign</name> &lt;&lt; 7) | (<name>e</name> &gt;&gt; 4)</expr>;</expr_stmt>
		<expr_stmt><expr><name>p</name> += <name>incr</name></expr>;</expr_stmt>

		<comment type="block">/* Second byte */</comment>
		<expr_stmt><expr>*<name>p</name> = <call>(<name>unsigned</name> <name>char</name>) <argument_list>(<argument><expr>((<name>e</name> &amp; 0xF) &lt;&lt; 4) | (<name>fhi</name> &gt;&gt; 24)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>p</name> += <name>incr</name></expr>;</expr_stmt>

		<comment type="block">/* Third byte */</comment>
		<expr_stmt><expr>*<name>p</name> = (<name>fhi</name> &gt;&gt; 16) &amp; 0xFF</expr>;</expr_stmt>
		<expr_stmt><expr><name>p</name> += <name>incr</name></expr>;</expr_stmt>

		<comment type="block">/* Fourth byte */</comment>
		<expr_stmt><expr>*<name>p</name> = (<name>fhi</name> &gt;&gt; 8) &amp; 0xFF</expr>;</expr_stmt>
		<expr_stmt><expr><name>p</name> += <name>incr</name></expr>;</expr_stmt>

		<comment type="block">/* Fifth byte */</comment>
		<expr_stmt><expr>*<name>p</name> = <name>fhi</name> &amp; 0xFF</expr>;</expr_stmt>
		<expr_stmt><expr><name>p</name> += <name>incr</name></expr>;</expr_stmt>

		<comment type="block">/* Sixth byte */</comment>
		<expr_stmt><expr>*<name>p</name> = (<name>flo</name> &gt;&gt; 16) &amp; 0xFF</expr>;</expr_stmt>
		<expr_stmt><expr><name>p</name> += <name>incr</name></expr>;</expr_stmt>

		<comment type="block">/* Seventh byte */</comment>
		<expr_stmt><expr>*<name>p</name> = (<name>flo</name> &gt;&gt; 8) &amp; 0xFF</expr>;</expr_stmt>
		<expr_stmt><expr><name>p</name> += <name>incr</name></expr>;</expr_stmt>

		<comment type="block">/* Eighth byte */</comment>
		<expr_stmt><expr>*<name>p</name> = <name>flo</name> &amp; 0xFF</expr>;</expr_stmt>
		<expr_stmt><expr><name>p</name> += <name>incr</name></expr>;</expr_stmt>

		<comment type="block">/* Done */</comment>
		<return>return <expr>0</expr>;</return>

	  <label><name>Overflow</name>:</label>
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_OverflowError</name></expr></argument>,
				<argument><expr>"float too large to pack with d format"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>-1</expr>;</return>
	}</block></then>
	<else>else <block>{
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>s</name> <init>= <expr>(<name>char</name>*)&amp;<name>x</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>incr</name> <init>= <expr>1</expr></init></decl>;</decl_stmt>

		<if>if <condition>(<expr>(<name>double_format</name> == <name>ieee_little_endian_format</name> &amp;&amp; !<name>le</name>)
		    || (<name>double_format</name> == <name>ieee_big_endian_format</name> &amp;&amp; <name>le</name>)</expr>)</condition><then> <block>{
			<expr_stmt><expr><name>p</name> += 7</expr>;</expr_stmt>
			<expr_stmt><expr><name>incr</name> = -1</expr>;</expr_stmt>
		}</block></then></if>
		
		<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; 8</expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
			<expr_stmt><expr>*<name>p</name> = *<name>s</name>++</expr>;</expr_stmt>
			<expr_stmt><expr><name>p</name> += <name>incr</name></expr>;</expr_stmt>
		}</block></for>
		<return>return <expr>0</expr>;</return>
	}</block></else></if>
}</block></function>

<function><type><name>double</name></type>
<name>_PyFloat_Unpack4</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> *</type><name>p</name></decl></param>, <param><decl><type><name>int</name></type> <name>le</name></decl></param>)</parameter_list>
<block>{
	<if>if <condition>(<expr><name>float_format</name> == <name>unknown_format</name></expr>)</condition><then> <block>{
		<decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name>sign</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>e</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>f</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>double</name></type> <name>x</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>incr</name> <init>= <expr>1</expr></init></decl>;</decl_stmt>

		<if>if <condition>(<expr><name>le</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><name>p</name> += 3</expr>;</expr_stmt>
			<expr_stmt><expr><name>incr</name> = -1</expr>;</expr_stmt>
		}</block></then></if>

		<comment type="block">/* First byte */</comment>
		<expr_stmt><expr><name>sign</name> = (*<name>p</name> &gt;&gt; 7) &amp; 1</expr>;</expr_stmt>
		<expr_stmt><expr><name>e</name> = (*<name>p</name> &amp; 0x7F) &lt;&lt; 1</expr>;</expr_stmt>
		<expr_stmt><expr><name>p</name> += <name>incr</name></expr>;</expr_stmt>

		<comment type="block">/* Second byte */</comment>
		<expr_stmt><expr><name>e</name> |= (*<name>p</name> &gt;&gt; 7) &amp; 1</expr>;</expr_stmt>
		<expr_stmt><expr><name>f</name> = (*<name>p</name> &amp; 0x7F) &lt;&lt; 16</expr>;</expr_stmt>
		<expr_stmt><expr><name>p</name> += <name>incr</name></expr>;</expr_stmt>

		<if>if <condition>(<expr><name>e</name> == 255</expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(
				<argument><expr><name>PyExc_ValueError</name></expr></argument>,
				<argument><expr>"can't unpack IEEE 754 special value "
				"on non-IEEE platform"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr>-1</expr>;</return>
		}</block></then></if>

		<comment type="block">/* Third byte */</comment>
		<expr_stmt><expr><name>f</name> |= *<name>p</name> &lt;&lt; 8</expr>;</expr_stmt>
		<expr_stmt><expr><name>p</name> += <name>incr</name></expr>;</expr_stmt>

		<comment type="block">/* Fourth byte */</comment>
		<expr_stmt><expr><name>f</name> |= *<name>p</name></expr>;</expr_stmt>

		<expr_stmt><expr><name>x</name> = (<name>double</name>)<name>f</name> / 8388608.0</expr>;</expr_stmt>

		<comment type="block">/* XXX This sadly ignores Inf/NaN issues */</comment>
		<if>if <condition>(<expr><name>e</name> == 0</expr>)</condition><then>
			<expr_stmt><expr><name>e</name> = -126</expr>;</expr_stmt></then>
		<else>else <block>{
			<expr_stmt><expr><name>x</name> += 1.0</expr>;</expr_stmt>
			<expr_stmt><expr><name>e</name> -= 127</expr>;</expr_stmt>
		}</block></else></if>
		<expr_stmt><expr><name>x</name> = <call><name>ldexp</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if>if <condition>(<expr><name>sign</name></expr>)</condition><then>
			<expr_stmt><expr><name>x</name> = -<name>x</name></expr>;</expr_stmt></then></if>

		<return>return <expr><name>x</name></expr>;</return>
	}</block></then>
	<else>else <block>{
		<decl_stmt><decl><type><name>float</name></type> <name>x</name></decl>;</decl_stmt>

		<if>if <condition>(<expr>(<name>float_format</name> == <name>ieee_little_endian_format</name> &amp;&amp; !<name>le</name>)
		    || (<name>float_format</name> == <name>ieee_big_endian_format</name> &amp;&amp; <name>le</name>)</expr>)</condition><then> <block>{
			<decl_stmt><decl><type><name>char</name></type> <name><name>buf</name><index>[<expr>4</expr>]</index></name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>char</name> *</type><name>d</name> <init>= <expr>&amp;<name><name>buf</name><index>[<expr>3</expr>]</index></name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

			<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; 4</expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
				<expr_stmt><expr>*<name>d</name>-- = *<name>p</name>++</expr>;</expr_stmt>
			}</block></for>
			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name>x</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr>4</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></then>
		<else>else <block>{
			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name>x</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr>4</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></else></if>

		<return>return <expr><name>x</name></expr>;</return>
	}</block></else></if>		
}</block></function>

<function><type><name>double</name></type>
<name>_PyFloat_Unpack8</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> *</type><name>p</name></decl></param>, <param><decl><type><name>int</name></type> <name>le</name></decl></param>)</parameter_list>
<block>{
	<if>if <condition>(<expr><name>double_format</name> == <name>unknown_format</name></expr>)</condition><then> <block>{
		<decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name>sign</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>e</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>fhi</name></decl>, <decl><type ref="prev"/><name>flo</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>double</name></type> <name>x</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>incr</name> <init>= <expr>1</expr></init></decl>;</decl_stmt>

		<if>if <condition>(<expr><name>le</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><name>p</name> += 7</expr>;</expr_stmt>
			<expr_stmt><expr><name>incr</name> = -1</expr>;</expr_stmt>
		}</block></then></if>

		<comment type="block">/* First byte */</comment>
		<expr_stmt><expr><name>sign</name> = (*<name>p</name> &gt;&gt; 7) &amp; 1</expr>;</expr_stmt>
		<expr_stmt><expr><name>e</name> = (*<name>p</name> &amp; 0x7F) &lt;&lt; 4</expr>;</expr_stmt>
		
		<expr_stmt><expr><name>p</name> += <name>incr</name></expr>;</expr_stmt>

		<comment type="block">/* Second byte */</comment>
		<expr_stmt><expr><name>e</name> |= (*<name>p</name> &gt;&gt; 4) &amp; 0xF</expr>;</expr_stmt>
		<expr_stmt><expr><name>fhi</name> = (*<name>p</name> &amp; 0xF) &lt;&lt; 24</expr>;</expr_stmt>
		<expr_stmt><expr><name>p</name> += <name>incr</name></expr>;</expr_stmt>

		<if>if <condition>(<expr><name>e</name> == 2047</expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(
				<argument><expr><name>PyExc_ValueError</name></expr></argument>,
				<argument><expr>"can't unpack IEEE 754 special value "
				"on non-IEEE platform"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr>-1.0</expr>;</return>
		}</block></then></if>

		<comment type="block">/* Third byte */</comment>
		<expr_stmt><expr><name>fhi</name> |= *<name>p</name> &lt;&lt; 16</expr>;</expr_stmt>
		<expr_stmt><expr><name>p</name> += <name>incr</name></expr>;</expr_stmt>

		<comment type="block">/* Fourth byte */</comment>
		<expr_stmt><expr><name>fhi</name> |= *<name>p</name>  &lt;&lt; 8</expr>;</expr_stmt>
		<expr_stmt><expr><name>p</name> += <name>incr</name></expr>;</expr_stmt>

		<comment type="block">/* Fifth byte */</comment>
		<expr_stmt><expr><name>fhi</name> |= *<name>p</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>p</name> += <name>incr</name></expr>;</expr_stmt>

		<comment type="block">/* Sixth byte */</comment>
		<expr_stmt><expr><name>flo</name> = *<name>p</name> &lt;&lt; 16</expr>;</expr_stmt>
		<expr_stmt><expr><name>p</name> += <name>incr</name></expr>;</expr_stmt>

		<comment type="block">/* Seventh byte */</comment>
		<expr_stmt><expr><name>flo</name> |= *<name>p</name> &lt;&lt; 8</expr>;</expr_stmt>
		<expr_stmt><expr><name>p</name> += <name>incr</name></expr>;</expr_stmt>

		<comment type="block">/* Eighth byte */</comment>
		<expr_stmt><expr><name>flo</name> |= *<name>p</name></expr>;</expr_stmt>

		<expr_stmt><expr><name>x</name> = (<name>double</name>)<name>fhi</name> + (<name>double</name>)<name>flo</name> / 16777216.0</expr>;</expr_stmt> <comment type="block">/* 2**24 */</comment>
		<expr_stmt><expr><name>x</name> /= 268435456.0</expr>;</expr_stmt> <comment type="block">/* 2**28 */</comment>

		<if>if <condition>(<expr><name>e</name> == 0</expr>)</condition><then>
			<expr_stmt><expr><name>e</name> = -1022</expr>;</expr_stmt></then>
		<else>else <block>{
			<expr_stmt><expr><name>x</name> += 1.0</expr>;</expr_stmt>
			<expr_stmt><expr><name>e</name> -= 1023</expr>;</expr_stmt>
		}</block></else></if>
		<expr_stmt><expr><name>x</name> = <call><name>ldexp</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if>if <condition>(<expr><name>sign</name></expr>)</condition><then>
			<expr_stmt><expr><name>x</name> = -<name>x</name></expr>;</expr_stmt></then></if>

		<return>return <expr><name>x</name></expr>;</return>
	}</block></then>
	<else>else <block>{
		<decl_stmt><decl><type><name>double</name></type> <name>x</name></decl>;</decl_stmt>

		<if>if <condition>(<expr>(<name>double_format</name> == <name>ieee_little_endian_format</name> &amp;&amp; !<name>le</name>)
		    || (<name>double_format</name> == <name>ieee_big_endian_format</name> &amp;&amp; <name>le</name>)</expr>)</condition><then> <block>{
			<decl_stmt><decl><type><name>char</name></type> <name><name>buf</name><index>[<expr>8</expr>]</index></name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>char</name> *</type><name>d</name> <init>= <expr>&amp;<name><name>buf</name><index>[<expr>7</expr>]</index></name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
			
			<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; 8</expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
				<expr_stmt><expr>*<name>d</name>-- = *<name>p</name>++</expr>;</expr_stmt>
			}</block></for>
			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name>x</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr>8</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></then>
		<else>else <block>{
			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name>x</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr>8</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></else></if>

		<return>return <expr><name>x</name></expr>;</return>
	}</block></else></if>
}</block></function>
</unit>
